0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/testing/fixture.go[staging/src/k8s.io/client-go/1.4/testing/fixture.go][staging/src/k8s.io/client-go/testing/fixture.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectTracker keeps track of objects. It is intended to be used to
0000000000000000000000000000000000000000;;	// fake calls to a server by returning objects based on their kind,
0000000000000000000000000000000000000000;;	// namespace and name.
0000000000000000000000000000000000000000;;	type ObjectTracker interface {
0000000000000000000000000000000000000000;;		// Add adds an object to the tracker. If object being added
0000000000000000000000000000000000000000;;		// is a list, its items are added separately.
0000000000000000000000000000000000000000;;		Add(obj runtime.Object) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get retrieves the object by its kind, namespace and name.
0000000000000000000000000000000000000000;;		Get(gvr schema.GroupVersionResource, ns, name string) (runtime.Object, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create adds an object to the tracker in the specified namespace.
0000000000000000000000000000000000000000;;		Create(gvr schema.GroupVersionResource, obj runtime.Object, ns string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update updates an existing object in the tracker in the specified namespace.
0000000000000000000000000000000000000000;;		Update(gvr schema.GroupVersionResource, obj runtime.Object, ns string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List retrieves all objects of a given kind in the given
0000000000000000000000000000000000000000;;		// namespace. Only non-List kinds are accepted.
0000000000000000000000000000000000000000;;		List(gvr schema.GroupVersionResource, gvk schema.GroupVersionKind, ns string) (runtime.Object, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete deletes an existing object from the tracker. If object
0000000000000000000000000000000000000000;;		// didn't exist in the tracker prior to deletion, Delete returns
0000000000000000000000000000000000000000;;		// no error.
0000000000000000000000000000000000000000;;		Delete(gvr schema.GroupVersionResource, ns, name string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectScheme abstracts the implementation of common operations on objects.
0000000000000000000000000000000000000000;;	type ObjectScheme interface {
0000000000000000000000000000000000000000;;		runtime.ObjectCreater
0000000000000000000000000000000000000000;;		runtime.ObjectCopier
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectReaction returns a ReactionFunc that applies core.Action to
0000000000000000000000000000000000000000;;	// the given tracker.
0000000000000000000000000000000000000000;;	func ObjectReaction(tracker ObjectTracker) ReactionFunc {
0000000000000000000000000000000000000000;;		return func(action Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;			ns := action.GetNamespace()
0000000000000000000000000000000000000000;;			gvr := action.GetResource()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Here and below we need to switch on implementation types,
0000000000000000000000000000000000000000;;			// not on interfaces, as some interfaces are identical
0000000000000000000000000000000000000000;;			// (e.g. UpdateAction and CreateAction), so if we use them,
0000000000000000000000000000000000000000;;			// updates and creates end up matching the same case branch.
0000000000000000000000000000000000000000;;			switch action := action.(type) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ListActionImpl:
0000000000000000000000000000000000000000;;				obj, err := tracker.List(gvr, action.GetKind(), ns)
0000000000000000000000000000000000000000;;				return true, obj, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case GetActionImpl:
0000000000000000000000000000000000000000;;				obj, err := tracker.Get(gvr, ns, action.GetName())
0000000000000000000000000000000000000000;;				return true, obj, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case CreateActionImpl:
0000000000000000000000000000000000000000;;				objMeta, err := meta.Accessor(action.GetObject())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return true, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if action.GetSubresource() == "" {
0000000000000000000000000000000000000000;;					err = tracker.Create(gvr, action.GetObject(), ns)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// TODO: Currently we're handling subresource creation as an update
0000000000000000000000000000000000000000;;					// on the enclosing resource. This works for some subresources but
0000000000000000000000000000000000000000;;					// might not be generic enough.
0000000000000000000000000000000000000000;;					err = tracker.Update(gvr, action.GetObject(), ns)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return true, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj, err := tracker.Get(gvr, ns, objMeta.GetName())
0000000000000000000000000000000000000000;;				return true, obj, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case UpdateActionImpl:
0000000000000000000000000000000000000000;;				objMeta, err := meta.Accessor(action.GetObject())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return true, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = tracker.Update(gvr, action.GetObject(), ns)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return true, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj, err := tracker.Get(gvr, ns, objMeta.GetName())
0000000000000000000000000000000000000000;;				return true, obj, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case DeleteActionImpl:
0000000000000000000000000000000000000000;;				err := tracker.Delete(gvr, ns, action.GetName())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return true, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, nil, fmt.Errorf("no reaction implemented for %s", action)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tracker struct {
0000000000000000000000000000000000000000;;		scheme  ObjectScheme
0000000000000000000000000000000000000000;;		decoder runtime.Decoder
0000000000000000000000000000000000000000;;		lock    sync.RWMutex
0000000000000000000000000000000000000000;;		objects map[schema.GroupVersionResource][]runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ObjectTracker = &tracker{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewObjectTracker returns an ObjectTracker that can be used to keep track
0000000000000000000000000000000000000000;;	// of objects for the fake clientset. Mostly useful for unit tests.
0000000000000000000000000000000000000000;;	func NewObjectTracker(scheme ObjectScheme, decoder runtime.Decoder) ObjectTracker {
0000000000000000000000000000000000000000;;		return &tracker{
0000000000000000000000000000000000000000;;			scheme:  scheme,
0000000000000000000000000000000000000000;;			decoder: decoder,
0000000000000000000000000000000000000000;;			objects: make(map[schema.GroupVersionResource][]runtime.Object),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) List(gvr schema.GroupVersionResource, gvk schema.GroupVersionKind, ns string) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		// Heuristic for list kind: original kind + List suffix. Might
0000000000000000000000000000000000000000;;		// not always be true but this tracker has a pretty limited
0000000000000000000000000000000000000000;;		// understanding of the actual API model.
0000000000000000000000000000000000000000;;		listGVK := gvk
0000000000000000000000000000000000000000;;		listGVK.Kind = listGVK.Kind + "List"
0000000000000000000000000000000000000000;;		// GVK does have the concept of "internal version". The scheme recognizes
0000000000000000000000000000000000000000;;		// the runtime.APIVersionInternal, but not the empty string.
0000000000000000000000000000000000000000;;		if listGVK.Version == "" {
0000000000000000000000000000000000000000;;			listGVK.Version = runtime.APIVersionInternal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list, err := t.scheme.New(listGVK)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !meta.IsListType(list) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%q is not a list type", listGVK.Kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.lock.RLock()
0000000000000000000000000000000000000000;;		defer t.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objs, ok := t.objects[gvr]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return list, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matchingObjs, err := filterByNamespaceAndName(objs, ns, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := meta.SetList(list, matchingObjs); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if list, err = t.scheme.Copy(list); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) Get(gvr schema.GroupVersionResource, ns, name string) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		errNotFound := errors.NewNotFound(gvr.GroupResource(), name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.lock.RLock()
0000000000000000000000000000000000000000;;		defer t.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objs, ok := t.objects[gvr]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matchingObjs, err := filterByNamespaceAndName(objs, ns, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matchingObjs) == 0 {
0000000000000000000000000000000000000000;;			return nil, errNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matchingObjs) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("more than one object matched gvr %s, ns: %q name: %q", gvr, ns, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only one object should match in the tracker if it works
0000000000000000000000000000000000000000;;		// correctly, as Add/Update methods enforce kind/namespace/name
0000000000000000000000000000000000000000;;		// uniqueness.
0000000000000000000000000000000000000000;;		obj, err := t.scheme.Copy(matchingObjs[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if status, ok := obj.(*metav1.Status); ok {
0000000000000000000000000000000000000000;;			if status.Status != metav1.StatusSuccess {
0000000000000000000000000000000000000000;;				return nil, &errors.StatusError{ErrStatus: *status}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) Add(obj runtime.Object) error {
0000000000000000000000000000000000000000;;		if meta.IsListType(obj) {
0000000000000000000000000000000000000000;;			return t.addList(obj, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvks, _, err := t.scheme.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(gvks) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no registered kinds for %v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, gvk := range gvks {
0000000000000000000000000000000000000000;;			// NOTE: UnsafeGuessKindToResource is a heuristic and default match. The
0000000000000000000000000000000000000000;;			// actual registration in apiserver can specify arbitrary route for a
0000000000000000000000000000000000000000;;			// gvk. If a test uses such objects, it cannot preset the tracker with
0000000000000000000000000000000000000000;;			// objects via Add(). Instead, it should trigger the Create() function
0000000000000000000000000000000000000000;;			// of the tracker, where an arbitrary gvr can be specified.
0000000000000000000000000000000000000000;;			gvr, _ := meta.UnsafeGuessKindToResource(gvk)
0000000000000000000000000000000000000000;;			// Resource doesn't have the concept of "__internal" version, just set it to "".
0000000000000000000000000000000000000000;;			if gvr.Version == runtime.APIVersionInternal {
0000000000000000000000000000000000000000;;				gvr.Version = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := t.add(gvr, obj, objMeta.GetNamespace(), false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) Create(gvr schema.GroupVersionResource, obj runtime.Object, ns string) error {
0000000000000000000000000000000000000000;;		return t.add(gvr, obj, ns, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) Update(gvr schema.GroupVersionResource, obj runtime.Object, ns string) error {
0000000000000000000000000000000000000000;;		return t.add(gvr, obj, ns, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) add(gvr schema.GroupVersionResource, obj runtime.Object, ns string, replaceExisting bool) error {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		defer t.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gr := gvr.GroupResource()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To avoid the object from being accidentally modified by caller
0000000000000000000000000000000000000000;;		// after it's been added to the tracker, we always store the deep
0000000000000000000000000000000000000000;;		// copy.
0000000000000000000000000000000000000000;;		obj, err := t.scheme.Copy(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Propagate namespace to the new object if hasn't already been set.
0000000000000000000000000000000000000000;;		if len(newMeta.GetNamespace()) == 0 {
0000000000000000000000000000000000000000;;			newMeta.SetNamespace(ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ns != newMeta.GetNamespace() {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("request namespace does not match object namespace, request: %q object: %q", ns, newMeta.GetNamespace())
0000000000000000000000000000000000000000;;			return errors.NewBadRequest(msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, existingObj := range t.objects[gvr] {
0000000000000000000000000000000000000000;;			oldMeta, err := meta.Accessor(existingObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if oldMeta.GetNamespace() == newMeta.GetNamespace() && oldMeta.GetName() == newMeta.GetName() {
0000000000000000000000000000000000000000;;				if replaceExisting {
0000000000000000000000000000000000000000;;					t.objects[gvr][i] = obj
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return errors.NewAlreadyExists(gr, newMeta.GetName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if replaceExisting {
0000000000000000000000000000000000000000;;			// Tried to update but no matching object was found.
0000000000000000000000000000000000000000;;			return errors.NewNotFound(gr, newMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.objects[gvr] = append(t.objects[gvr], obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) addList(obj runtime.Object, replaceExisting bool) error {
0000000000000000000000000000000000000000;;		list, err := meta.ExtractList(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := runtime.DecodeList(list, t.decoder)
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			return errs[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, obj := range list {
0000000000000000000000000000000000000000;;			if err := t.Add(obj); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tracker) Delete(gvr schema.GroupVersionResource, ns, name string) error {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		defer t.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, existingObj := range t.objects[gvr] {
0000000000000000000000000000000000000000;;			objMeta, err := meta.Accessor(existingObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if objMeta.GetNamespace() == ns && objMeta.GetName() == name {
0000000000000000000000000000000000000000;;				t.objects[gvr] = append(t.objects[gvr][:i], t.objects[gvr][i+1:]...)
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors.NewNotFound(gvr.GroupResource(), name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterByNamespaceAndName returns all objects in the collection that
0000000000000000000000000000000000000000;;	// match provided namespace and name. Empty namespace matches
0000000000000000000000000000000000000000;;	// non-namespaced objects.
0000000000000000000000000000000000000000;;	func filterByNamespaceAndName(objs []runtime.Object, ns, name string) ([]runtime.Object, error) {
0000000000000000000000000000000000000000;;		var res []runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, obj := range objs {
0000000000000000000000000000000000000000;;			acc, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ns != "" && acc.GetNamespace() != ns {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if name != "" && acc.GetName() != name {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res = append(res, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultWatchReactor(watchInterface watch.Interface, err error) WatchReactionFunc {
0000000000000000000000000000000000000000;;		return func(action Action) (bool, watch.Interface, error) {
0000000000000000000000000000000000000000;;			return true, watchInterface, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SimpleReactor is a Reactor.  Each reaction function is attached to a given verb,resource tuple.  "*" in either field matches everything for that value.
0000000000000000000000000000000000000000;;	// For instance, *,pods matches all verbs on pods.  This allows for easier composition of reaction functions
0000000000000000000000000000000000000000;;	type SimpleReactor struct {
0000000000000000000000000000000000000000;;		Verb     string
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Reaction ReactionFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SimpleReactor) Handles(action Action) bool {
0000000000000000000000000000000000000000;;		verbCovers := r.Verb == "*" || r.Verb == action.GetVerb()
0000000000000000000000000000000000000000;;		if !verbCovers {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceCovers := r.Resource == "*" || r.Resource == action.GetResource().Resource
0000000000000000000000000000000000000000;;		if !resourceCovers {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SimpleReactor) React(action Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;		return r.Reaction(action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SimpleWatchReactor is a WatchReactor.  Each reaction function is attached to a given resource.  "*" matches everything for that value.
0000000000000000000000000000000000000000;;	// For instance, *,pods matches all verbs on pods.  This allows for easier composition of reaction functions
0000000000000000000000000000000000000000;;	type SimpleWatchReactor struct {
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Reaction WatchReactionFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SimpleWatchReactor) Handles(action Action) bool {
0000000000000000000000000000000000000000;;		resourceCovers := r.Resource == "*" || r.Resource == action.GetResource().Resource
0000000000000000000000000000000000000000;;		if !resourceCovers {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SimpleWatchReactor) React(action Action) (bool, watch.Interface, error) {
0000000000000000000000000000000000000000;;		return r.Reaction(action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SimpleProxyReactor is a ProxyReactor.  Each reaction function is attached to a given resource.  "*" matches everything for that value.
0000000000000000000000000000000000000000;;	// For instance, *,pods matches all verbs on pods.  This allows for easier composition of reaction functions.
0000000000000000000000000000000000000000;;	type SimpleProxyReactor struct {
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Reaction ProxyReactionFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SimpleProxyReactor) Handles(action Action) bool {
0000000000000000000000000000000000000000;;		resourceCovers := r.Resource == "*" || r.Resource == action.GetResource().Resource
0000000000000000000000000000000000000000;;		if !resourceCovers {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SimpleProxyReactor) React(action Action) (bool, restclient.ResponseWrapper, error) {
0000000000000000000000000000000000000000;;		return r.Reaction(action)
0000000000000000000000000000000000000000;;	}
