0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/testing/fake.go[staging/src/k8s.io/client-go/1.4/testing/fake.go][staging/src/k8s.io/client-go/testing/fake.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		kubeversion "k8s.io/client-go/pkg/version"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake implements client.Interface. Meant to be embedded into a struct to get
0000000000000000000000000000000000000000;;	// a default implementation. This makes faking out just the method you want to
0000000000000000000000000000000000000000;;	// test easier.
0000000000000000000000000000000000000000;;	type Fake struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		actions []Action // these may be castable to other types, but "Action" is the minimum
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReactionChain is the list of reactors that will be attempted for every
0000000000000000000000000000000000000000;;		// request in the order they are tried.
0000000000000000000000000000000000000000;;		ReactionChain []Reactor
0000000000000000000000000000000000000000;;		// WatchReactionChain is the list of watch reactors that will be attempted
0000000000000000000000000000000000000000;;		// for every request in the order they are tried.
0000000000000000000000000000000000000000;;		WatchReactionChain []WatchReactor
0000000000000000000000000000000000000000;;		// ProxyReactionChain is the list of proxy reactors that will be attempted
0000000000000000000000000000000000000000;;		// for every request in the order they are tried.
0000000000000000000000000000000000000000;;		ProxyReactionChain []ProxyReactor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Resources []*metav1.APIResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reactor is an interface to allow the composition of reaction functions.
0000000000000000000000000000000000000000;;	type Reactor interface {
0000000000000000000000000000000000000000;;		// Handles indicates whether or not this Reactor deals with a given
0000000000000000000000000000000000000000;;		// action.
0000000000000000000000000000000000000000;;		Handles(action Action) bool
0000000000000000000000000000000000000000;;		// React handles the action and returns results.  It may choose to
0000000000000000000000000000000000000000;;		// delegate by indicated handled=false.
0000000000000000000000000000000000000000;;		React(action Action) (handled bool, ret runtime.Object, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WatchReactor is an interface to allow the composition of watch functions.
0000000000000000000000000000000000000000;;	type WatchReactor interface {
0000000000000000000000000000000000000000;;		// Handles indicates whether or not this Reactor deals with a given
0000000000000000000000000000000000000000;;		// action.
0000000000000000000000000000000000000000;;		Handles(action Action) bool
0000000000000000000000000000000000000000;;		// React handles a watch action and returns results.  It may choose to
0000000000000000000000000000000000000000;;		// delegate by indicating handled=false.
0000000000000000000000000000000000000000;;		React(action Action) (handled bool, ret watch.Interface, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyReactor is an interface to allow the composition of proxy get
0000000000000000000000000000000000000000;;	// functions.
0000000000000000000000000000000000000000;;	type ProxyReactor interface {
0000000000000000000000000000000000000000;;		// Handles indicates whether or not this Reactor deals with a given
0000000000000000000000000000000000000000;;		// action.
0000000000000000000000000000000000000000;;		Handles(action Action) bool
0000000000000000000000000000000000000000;;		// React handles a watch action and returns results.  It may choose to
0000000000000000000000000000000000000000;;		// delegate by indicating handled=false.
0000000000000000000000000000000000000000;;		React(action Action) (handled bool, ret restclient.ResponseWrapper, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReactionFunc is a function that returns an object or error for a given
0000000000000000000000000000000000000000;;	// Action.  If "handled" is false, then the test client will ignore the
0000000000000000000000000000000000000000;;	// results and continue to the next ReactionFunc.  A ReactionFunc can describe
0000000000000000000000000000000000000000;;	// reactions on subresources by testing the result of the action's
0000000000000000000000000000000000000000;;	// GetSubresource() method.
0000000000000000000000000000000000000000;;	type ReactionFunc func(action Action) (handled bool, ret runtime.Object, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WatchReactionFunc is a function that returns a watch interface.  If
0000000000000000000000000000000000000000;;	// "handled" is false, then the test client will ignore the results and
0000000000000000000000000000000000000000;;	// continue to the next ReactionFunc.
0000000000000000000000000000000000000000;;	type WatchReactionFunc func(action Action) (handled bool, ret watch.Interface, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyReactionFunc is a function that returns a ResponseWrapper interface
0000000000000000000000000000000000000000;;	// for a given Action.  If "handled" is false, then the test client will
0000000000000000000000000000000000000000;;	// ignore the results and continue to the next ProxyReactionFunc.
0000000000000000000000000000000000000000;;	type ProxyReactionFunc func(action Action) (handled bool, ret restclient.ResponseWrapper, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddReactor appends a reactor to the end of the chain.
0000000000000000000000000000000000000000;;	func (c *Fake) AddReactor(verb, resource string, reaction ReactionFunc) {
0000000000000000000000000000000000000000;;		c.ReactionChain = append(c.ReactionChain, &SimpleReactor{verb, resource, reaction})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrependReactor adds a reactor to the beginning of the chain.
0000000000000000000000000000000000000000;;	func (c *Fake) PrependReactor(verb, resource string, reaction ReactionFunc) {
0000000000000000000000000000000000000000;;		c.ReactionChain = append([]Reactor{&SimpleReactor{verb, resource, reaction}}, c.ReactionChain...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddWatchReactor appends a reactor to the end of the chain.
0000000000000000000000000000000000000000;;	func (c *Fake) AddWatchReactor(resource string, reaction WatchReactionFunc) {
0000000000000000000000000000000000000000;;		c.WatchReactionChain = append(c.WatchReactionChain, &SimpleWatchReactor{resource, reaction})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrependWatchReactor adds a reactor to the beginning of the chain.
0000000000000000000000000000000000000000;;	func (c *Fake) PrependWatchReactor(resource string, reaction WatchReactionFunc) {
0000000000000000000000000000000000000000;;		c.WatchReactionChain = append([]WatchReactor{&SimpleWatchReactor{resource, reaction}}, c.WatchReactionChain...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddProxyReactor appends a reactor to the end of the chain.
0000000000000000000000000000000000000000;;	func (c *Fake) AddProxyReactor(resource string, reaction ProxyReactionFunc) {
0000000000000000000000000000000000000000;;		c.ProxyReactionChain = append(c.ProxyReactionChain, &SimpleProxyReactor{resource, reaction})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrependProxyReactor adds a reactor to the beginning of the chain.
0000000000000000000000000000000000000000;;	func (c *Fake) PrependProxyReactor(resource string, reaction ProxyReactionFunc) {
0000000000000000000000000000000000000000;;		c.ProxyReactionChain = append([]ProxyReactor{&SimpleProxyReactor{resource, reaction}}, c.ProxyReactionChain...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Invokes records the provided Action and then invokes the ReactionFunc that
0000000000000000000000000000000000000000;;	// handles the action if one exists. defaultReturnObj is expected to be of the
0000000000000000000000000000000000000000;;	// same type a normal call would return.
0000000000000000000000000000000000000000;;	func (c *Fake) Invokes(action Action, defaultReturnObj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.actions = append(c.actions, action)
0000000000000000000000000000000000000000;;		for _, reactor := range c.ReactionChain {
0000000000000000000000000000000000000000;;			if !reactor.Handles(action) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			handled, ret, err := reactor.React(action)
0000000000000000000000000000000000000000;;			if !handled {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ret, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return defaultReturnObj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvokesWatch records the provided Action and then invokes the ReactionFunc
0000000000000000000000000000000000000000;;	// that handles the action if one exists.
0000000000000000000000000000000000000000;;	func (c *Fake) InvokesWatch(action Action) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.actions = append(c.actions, action)
0000000000000000000000000000000000000000;;		for _, reactor := range c.WatchReactionChain {
0000000000000000000000000000000000000000;;			if !reactor.Handles(action) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			handled, ret, err := reactor.React(action)
0000000000000000000000000000000000000000;;			if !handled {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ret, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unhandled watch: %#v", action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvokesProxy records the provided Action and then invokes the ReactionFunc
0000000000000000000000000000000000000000;;	// that handles the action if one exists.
0000000000000000000000000000000000000000;;	func (c *Fake) InvokesProxy(action Action) restclient.ResponseWrapper {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.actions = append(c.actions, action)
0000000000000000000000000000000000000000;;		for _, reactor := range c.ProxyReactionChain {
0000000000000000000000000000000000000000;;			if !reactor.Handles(action) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			handled, ret, err := reactor.React(action)
0000000000000000000000000000000000000000;;			if !handled || err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearActions clears the history of actions called on the fake client.
0000000000000000000000000000000000000000;;	func (c *Fake) ClearActions() {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.actions = make([]Action, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Actions returns a chronologically ordered slice fake actions called on the
0000000000000000000000000000000000000000;;	// fake client.
0000000000000000000000000000000000000000;;	func (c *Fake) Actions() []Action {
0000000000000000000000000000000000000000;;		c.RLock()
0000000000000000000000000000000000000000;;		defer c.RUnlock()
0000000000000000000000000000000000000000;;		fa := make([]Action, len(c.actions))
0000000000000000000000000000000000000000;;		copy(fa, c.actions)
0000000000000000000000000000000000000000;;		return fa
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: this probably should be moved to somewhere else.
0000000000000000000000000000000000000000;;	type FakeDiscovery struct {
0000000000000000000000000000000000000000;;		*Fake
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FakeDiscovery) ServerResourcesForGroupVersion(groupVersion string) (*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		action := ActionImpl{
0000000000000000000000000000000000000000;;			Verb:     "get",
0000000000000000000000000000000000000000;;			Resource: schema.GroupVersionResource{Resource: "resource"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Invokes(action, nil)
0000000000000000000000000000000000000000;;		for _, rl := range c.Resources {
0000000000000000000000000000000000000000;;			if rl.GroupVersion == groupVersion {
0000000000000000000000000000000000000000;;				return rl, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("GroupVersion %q not found", groupVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FakeDiscovery) ServerResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		action := ActionImpl{
0000000000000000000000000000000000000000;;			Verb:     "get",
0000000000000000000000000000000000000000;;			Resource: schema.GroupVersionResource{Resource: "resource"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Invokes(action, nil)
0000000000000000000000000000000000000000;;		return c.Resources, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FakeDiscovery) ServerGroups() (*metav1.APIGroupList, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *FakeDiscovery) ServerVersion() (*version.Info, error) {
0000000000000000000000000000000000000000;;		action := ActionImpl{}
0000000000000000000000000000000000000000;;		action.Verb = "get"
0000000000000000000000000000000000000000;;		action.Resource = schema.GroupVersionResource{Resource: "version"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Invokes(action, nil)
0000000000000000000000000000000000000000;;		versionInfo := kubeversion.Get()
0000000000000000000000000000000000000000;;		return &versionInfo, nil
0000000000000000000000000000000000000000;;	}
