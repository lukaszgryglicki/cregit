0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/client.go[staging/src/k8s.io/client-go/1.4/rest/client.go][staging/src/k8s.io/client-go/rest/client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Environment variables: Note that the duration should be long enough that the backoff
0000000000000000000000000000000000000000;;		// persists for some reasonable time (i.e. 120 seconds).  The typical base might be "1".
0000000000000000000000000000000000000000;;		envBackoffBase     = "KUBE_CLIENT_BACKOFF_BASE"
0000000000000000000000000000000000000000;;		envBackoffDuration = "KUBE_CLIENT_BACKOFF_DURATION"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface captures the set of operations for generically interacting with Kubernetes REST apis.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		GetRateLimiter() flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;		Verb(verb string) *Request
0000000000000000000000000000000000000000;;		Post() *Request
0000000000000000000000000000000000000000;;		Put() *Request
0000000000000000000000000000000000000000;;		Patch(pt types.PatchType) *Request
0000000000000000000000000000000000000000;;		Get() *Request
0000000000000000000000000000000000000000;;		Delete() *Request
0000000000000000000000000000000000000000;;		APIVersion() schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTClient imposes common Kubernetes API conventions on a set of resource paths.
0000000000000000000000000000000000000000;;	// The baseURL is expected to point to an HTTP or HTTPS path that is the parent
0000000000000000000000000000000000000000;;	// of one or more resources.  The server should return a decodable API resource
0000000000000000000000000000000000000000;;	// object, or an api.Status object which contains information about the reason for
0000000000000000000000000000000000000000;;	// any failure.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Most consumers should use client.New() to get a Kubernetes API client.
0000000000000000000000000000000000000000;;	type RESTClient struct {
0000000000000000000000000000000000000000;;		// base is the root URL for all invocations of the client
0000000000000000000000000000000000000000;;		base *url.URL
0000000000000000000000000000000000000000;;		// versionedAPIPath is a path segment connecting the base URL to the resource root
0000000000000000000000000000000000000000;;		versionedAPIPath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// contentConfig is the information used to communicate with the server.
0000000000000000000000000000000000000000;;		contentConfig ContentConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// serializers contain all serializers for underlying content type.
0000000000000000000000000000000000000000;;		serializers Serializers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// creates BackoffManager that is passed to requests.
0000000000000000000000000000000000000000;;		createBackoffMgr func() BackoffManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO extract this into a wrapper interface via the RESTClient interface in kubectl.
0000000000000000000000000000000000000000;;		Throttle flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set specific behavior of the client.  If not set http.DefaultClient will be used.
0000000000000000000000000000000000000000;;		Client *http.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Serializers struct {
0000000000000000000000000000000000000000;;		Encoder             runtime.Encoder
0000000000000000000000000000000000000000;;		Decoder             runtime.Decoder
0000000000000000000000000000000000000000;;		StreamingSerializer runtime.Serializer
0000000000000000000000000000000000000000;;		Framer              runtime.Framer
0000000000000000000000000000000000000000;;		RenegotiatedDecoder func(contentType string, params map[string]string) (runtime.Decoder, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRESTClient creates a new RESTClient. This client performs generic REST functions
0000000000000000000000000000000000000000;;	// such as Get, Put, Post, and Delete on specified paths.  Codec controls encoding and
0000000000000000000000000000000000000000;;	// decoding of responses from the server.
0000000000000000000000000000000000000000;;	func NewRESTClient(baseURL *url.URL, versionedAPIPath string, config ContentConfig, maxQPS float32, maxBurst int, rateLimiter flowcontrol.RateLimiter, client *http.Client) (*RESTClient, error) {
0000000000000000000000000000000000000000;;		base := *baseURL
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(base.Path, "/") {
0000000000000000000000000000000000000000;;			base.Path += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		base.RawQuery = ""
0000000000000000000000000000000000000000;;		base.Fragment = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.GroupVersion == nil {
0000000000000000000000000000000000000000;;			config.GroupVersion = &schema.GroupVersion{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.ContentType) == 0 {
0000000000000000000000000000000000000000;;			config.ContentType = "application/json"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serializers, err := createSerializers(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var throttle flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;		if maxQPS > 0 && rateLimiter == nil {
0000000000000000000000000000000000000000;;			throttle = flowcontrol.NewTokenBucketRateLimiter(maxQPS, maxBurst)
0000000000000000000000000000000000000000;;		} else if rateLimiter != nil {
0000000000000000000000000000000000000000;;			throttle = rateLimiter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &RESTClient{
0000000000000000000000000000000000000000;;			base:             &base,
0000000000000000000000000000000000000000;;			versionedAPIPath: versionedAPIPath,
0000000000000000000000000000000000000000;;			contentConfig:    config,
0000000000000000000000000000000000000000;;			serializers:      *serializers,
0000000000000000000000000000000000000000;;			createBackoffMgr: readExpBackoffConfig,
0000000000000000000000000000000000000000;;			Throttle:         throttle,
0000000000000000000000000000000000000000;;			Client:           client,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRateLimiter returns rate limier for a given client, or nil if it's called on a nil client
0000000000000000000000000000000000000000;;	func (c *RESTClient) GetRateLimiter() flowcontrol.RateLimiter {
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.Throttle
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readExpBackoffConfig handles the internal logic of determining what the
0000000000000000000000000000000000000000;;	// backoff policy is.  By default if no information is available, NoBackoff.
0000000000000000000000000000000000000000;;	// TODO Generalize this see #17727 .
0000000000000000000000000000000000000000;;	func readExpBackoffConfig() BackoffManager {
0000000000000000000000000000000000000000;;		backoffBase := os.Getenv(envBackoffBase)
0000000000000000000000000000000000000000;;		backoffDuration := os.Getenv(envBackoffDuration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backoffBaseInt, errBase := strconv.ParseInt(backoffBase, 10, 64)
0000000000000000000000000000000000000000;;		backoffDurationInt, errDuration := strconv.ParseInt(backoffDuration, 10, 64)
0000000000000000000000000000000000000000;;		if errBase != nil || errDuration != nil {
0000000000000000000000000000000000000000;;			return &NoBackoff{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &URLBackoff{
0000000000000000000000000000000000000000;;			Backoff: flowcontrol.NewBackOff(
0000000000000000000000000000000000000000;;				time.Duration(backoffBaseInt)*time.Second,
0000000000000000000000000000000000000000;;				time.Duration(backoffDurationInt)*time.Second)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createSerializers creates all necessary serializers for given contentType.
0000000000000000000000000000000000000000;;	// TODO: the negotiated serializer passed to this method should probably return
0000000000000000000000000000000000000000;;	//   serializers that control decoding and versioning without this package
0000000000000000000000000000000000000000;;	//   being aware of the types. Depends on whether RESTClient must deal with
0000000000000000000000000000000000000000;;	//   generic infrastructure.
0000000000000000000000000000000000000000;;	func createSerializers(config ContentConfig) (*Serializers, error) {
0000000000000000000000000000000000000000;;		mediaTypes := config.NegotiatedSerializer.SupportedMediaTypes()
0000000000000000000000000000000000000000;;		contentType := config.ContentType
0000000000000000000000000000000000000000;;		mediaType, _, err := mime.ParseMediaType(contentType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("the content type specified in the client configuration is not recognized: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, ok := runtime.SerializerInfoForMediaType(mediaTypes, mediaType)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if len(contentType) != 0 || len(mediaTypes) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("no serializers registered for %s", contentType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info = mediaTypes[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersions{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Group:   config.GroupVersion.Group,
0000000000000000000000000000000000000000;;				Version: runtime.APIVersionInternal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// always include the legacy group as a decoding target to handle non-error `Status` return types
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Group:   "",
0000000000000000000000000000000000000000;;				Version: runtime.APIVersionInternal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &Serializers{
0000000000000000000000000000000000000000;;			Encoder: config.NegotiatedSerializer.EncoderForVersion(info.Serializer, *config.GroupVersion),
0000000000000000000000000000000000000000;;			Decoder: config.NegotiatedSerializer.DecoderToVersion(info.Serializer, internalGV),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			RenegotiatedDecoder: func(contentType string, params map[string]string) (runtime.Decoder, error) {
0000000000000000000000000000000000000000;;				info, ok := runtime.SerializerInfoForMediaType(mediaTypes, contentType)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("serializer for %s not registered", contentType)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return config.NegotiatedSerializer.DecoderToVersion(info.Serializer, internalGV), nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.StreamSerializer != nil {
0000000000000000000000000000000000000000;;			s.StreamingSerializer = info.StreamSerializer.Serializer
0000000000000000000000000000000000000000;;			s.Framer = info.StreamSerializer.Framer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verb begins a request with a verb (GET, POST, PUT, DELETE).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example usage of RESTClient's request building interface:
0000000000000000000000000000000000000000;;	// c, err := NewRESTClient(...)
0000000000000000000000000000000000000000;;	// if err != nil { ... }
0000000000000000000000000000000000000000;;	// resp, err := c.Verb("GET").
0000000000000000000000000000000000000000;;	//  Path("pods").
0000000000000000000000000000000000000000;;	//  SelectorParam("labels", "area=staging").
0000000000000000000000000000000000000000;;	//  Timeout(10*time.Second).
0000000000000000000000000000000000000000;;	//  Do()
0000000000000000000000000000000000000000;;	// if err != nil { ... }
0000000000000000000000000000000000000000;;	// list, ok := resp.(*api.PodList)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (c *RESTClient) Verb(verb string) *Request {
0000000000000000000000000000000000000000;;		backoff := c.createBackoffMgr()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Client == nil {
0000000000000000000000000000000000000000;;			return NewRequest(nil, verb, c.base, c.versionedAPIPath, c.contentConfig, c.serializers, backoff, c.Throttle)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewRequest(c.Client, verb, c.base, c.versionedAPIPath, c.contentConfig, c.serializers, backoff, c.Throttle)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Post begins a POST request. Short for c.Verb("POST").
0000000000000000000000000000000000000000;;	func (c *RESTClient) Post() *Request {
0000000000000000000000000000000000000000;;		return c.Verb("POST")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Put begins a PUT request. Short for c.Verb("PUT").
0000000000000000000000000000000000000000;;	func (c *RESTClient) Put() *Request {
0000000000000000000000000000000000000000;;		return c.Verb("PUT")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Patch begins a PATCH request. Short for c.Verb("Patch").
0000000000000000000000000000000000000000;;	func (c *RESTClient) Patch(pt types.PatchType) *Request {
0000000000000000000000000000000000000000;;		return c.Verb("PATCH").SetHeader("Content-Type", string(pt))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get begins a GET request. Short for c.Verb("GET").
0000000000000000000000000000000000000000;;	func (c *RESTClient) Get() *Request {
0000000000000000000000000000000000000000;;		return c.Verb("GET")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete begins a DELETE request. Short for c.Verb("DELETE").
0000000000000000000000000000000000000000;;	func (c *RESTClient) Delete() *Request {
0000000000000000000000000000000000000000;;		return c.Verb("DELETE")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIVersion returns the APIVersion this RESTClient is expected to use.
0000000000000000000000000000000000000000;;	func (c *RESTClient) APIVersion() schema.GroupVersion {
0000000000000000000000000000000000000000;;		return *c.contentConfig.GroupVersion
0000000000000000000000000000000000000000;;	}
