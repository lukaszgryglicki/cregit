0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/client_test.go[staging/src/k8s.io/client-go/1.4/rest/client_test.go][staging/src/k8s.io/client-go/rest/client_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		v1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestParam struct {
0000000000000000000000000000000000000000;;		actualError           error
0000000000000000000000000000000000000000;;		expectingError        bool
0000000000000000000000000000000000000000;;		actualCreated         bool
0000000000000000000000000000000000000000;;		expCreated            bool
0000000000000000000000000000000000000000;;		expStatus             *metav1.Status
0000000000000000000000000000000000000000;;		testBody              bool
0000000000000000000000000000000000000000;;		testBodyErrorIsNotNil bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSerializer makes sure that you're always able to decode metav1.Status
0000000000000000000000000000000000000000;;	func TestSerializer(t *testing.T) {
0000000000000000000000000000000000000000;;		gv := v1beta1.SchemeGroupVersion
0000000000000000000000000000000000000000;;		contentConfig := ContentConfig{
0000000000000000000000000000000000000000;;			ContentType:          "application/json",
0000000000000000000000000000000000000000;;			GroupVersion:         &gv,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: serializer.DirectCodecFactory{CodecFactory: scheme.Codecs},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializer, err := createSerializers(contentConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// bytes based on actual return from API server when encoding an "unversioned" object
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(serializer.Decoder, []byte(`{"kind":"Status","apiVersion":"v1","metadata":{},"status":"Success"}`))
0000000000000000000000000000000000000000;;		t.Log(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestSuccess(t *testing.T) {
0000000000000000000000000000000000000000;;		testServer, fakeHandler, status := testServerEnv(t, 200)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := restClient(testServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := c.Get().Prefix("test").Do().Raw()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testParam := TestParam{actualError: err, expectingError: false, expCreated: true,
0000000000000000000000000000000000000000;;			expStatus: status, testBody: true, testBodyErrorIsNotNil: false}
0000000000000000000000000000000000000000;;		validate(testParam, t, body, fakeHandler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestFailed(t *testing.T) {
0000000000000000000000000000000000000000;;		status := &metav1.Status{
0000000000000000000000000000000000000000;;			Code:    http.StatusNotFound,
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonNotFound,
0000000000000000000000000000000000000000;;			Message: " \"\" not found",
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), status)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   404,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := restClient(testServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.Get().Do().Error()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss, ok := err.(errors.APIStatus)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error type %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := ss.Status()
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(status, &actual) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected mis-match: %s", diff.ObjectReflectDiff(status, &actual))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRawRequestFailed(t *testing.T) {
0000000000000000000000000000000000000000;;		status := &metav1.Status{
0000000000000000000000000000000000000000;;			Code:    http.StatusNotFound,
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonNotFound,
0000000000000000000000000000000000000000;;			Message: "the server could not find the requested resource",
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Causes: []metav1.StatusCause{
0000000000000000000000000000000000000000;;					{Type: metav1.CauseTypeUnexpectedServerResponse, Message: "unknown"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), status)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   404,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := restClient(testServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := c.Get().Do().Raw()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil || body == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error: %#v", body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss, ok := err.(errors.APIStatus)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error type %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actual := ss.Status()
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(status, &actual) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected mis-match: %s", diff.ObjectReflectDiff(status, &actual))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestCreated(t *testing.T) {
0000000000000000000000000000000000000000;;		testServer, fakeHandler, status := testServerEnv(t, 201)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := restClient(testServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created := false
0000000000000000000000000000000000000000;;		body, err := c.Get().Prefix("test").Do().WasCreated(&created).Raw()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testParam := TestParam{actualError: err, expectingError: false, expCreated: true,
0000000000000000000000000000000000000000;;			expStatus: status, testBody: false}
0000000000000000000000000000000000000000;;		validate(testParam, t, body, fakeHandler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestNotCreated(t *testing.T) {
0000000000000000000000000000000000000000;;		testServer, fakeHandler, expectedStatus := testServerEnv(t, 202)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c, err := restClient(testServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created := false
0000000000000000000000000000000000000000;;		body, err := c.Get().Prefix("test").Do().WasCreated(&created).Raw()
0000000000000000000000000000000000000000;;		testParam := TestParam{actualError: err, expectingError: false, expCreated: false,
0000000000000000000000000000000000000000;;			expStatus: expectedStatus, testBody: false}
0000000000000000000000000000000000000000;;		validate(testParam, t, body, fakeHandler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestAcceptedNoContentReturned(t *testing.T) {
0000000000000000000000000000000000000000;;		testServer, fakeHandler, _ := testServerEnv(t, 204)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := restClient(testServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created := false
0000000000000000000000000000000000000000;;		body, err := c.Get().Prefix("test").Do().WasCreated(&created).Raw()
0000000000000000000000000000000000000000;;		testParam := TestParam{actualError: err, expectingError: false, expCreated: false,
0000000000000000000000000000000000000000;;			testBody: false}
0000000000000000000000000000000000000000;;		validate(testParam, t, body, fakeHandler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBadRequest(t *testing.T) {
0000000000000000000000000000000000000000;;		testServer, fakeHandler, _ := testServerEnv(t, 400)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c, err := restClient(testServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		created := false
0000000000000000000000000000000000000000;;		body, err := c.Get().Prefix("test").Do().WasCreated(&created).Raw()
0000000000000000000000000000000000000000;;		testParam := TestParam{actualError: err, expectingError: true, expCreated: false,
0000000000000000000000000000000000000000;;			testBody: true}
0000000000000000000000000000000000000000;;		validate(testParam, t, body, fakeHandler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validate(testParam TestParam, t *testing.T, body []byte, fakeHandler *utiltesting.FakeHandler) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case testParam.expectingError && testParam.actualError == nil:
0000000000000000000000000000000000000000;;			t.Errorf("Expected error")
0000000000000000000000000000000000000000;;		case !testParam.expectingError && testParam.actualError != nil:
0000000000000000000000000000000000000000;;			t.Error(testParam.actualError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !testParam.expCreated {
0000000000000000000000000000000000000000;;			if testParam.actualCreated {
0000000000000000000000000000000000000000;;				t.Errorf("Expected object not to be created")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statusOut, err := runtime.Decode(scheme.Codecs.UniversalDeserializer(), body)
0000000000000000000000000000000000000000;;		if testParam.testBody {
0000000000000000000000000000000000000000;;			if testParam.testBodyErrorIsNotNil && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected Error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !testParam.testBodyErrorIsNotNil && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected Error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if testParam.expStatus != nil {
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(testParam.expStatus, statusOut) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected mis-match. Expected %#v.  Saw %#v", testParam.expStatus, statusOut)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeHandler.ValidateRequest(t, "/"+v1.SchemeGroupVersion.String()+"/test", "GET", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHttpMethods(t *testing.T) {
0000000000000000000000000000000000000000;;		testServer, _, _ := testServerEnv(t, 200)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c, _ := restClient(testServer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := c.Post()
0000000000000000000000000000000000000000;;		if request == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Post : Object returned should not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request = c.Get()
0000000000000000000000000000000000000000;;		if request == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Get: Object returned should not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request = c.Put()
0000000000000000000000000000000000000000;;		if request == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Put : Object returned should not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request = c.Delete()
0000000000000000000000000000000000000000;;		if request == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Delete : Object returned should not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request = c.Patch(types.JSONPatchType)
0000000000000000000000000000000000000000;;		if request == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Patch : Object returned should not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateBackoffManager(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		theUrl, _ := url.Parse("http://localhost")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1 second base backoff + duration of 2 seconds -> exponential backoff for requests.
0000000000000000000000000000000000000000;;		os.Setenv(envBackoffBase, "1")
0000000000000000000000000000000000000000;;		os.Setenv(envBackoffDuration, "2")
0000000000000000000000000000000000000000;;		backoff := readExpBackoffConfig()
0000000000000000000000000000000000000000;;		backoff.UpdateBackoff(theUrl, nil, 500)
0000000000000000000000000000000000000000;;		backoff.UpdateBackoff(theUrl, nil, 500)
0000000000000000000000000000000000000000;;		if backoff.CalculateBackoff(theUrl)/time.Second != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Backoff env not working.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 0 duration -> no backoff.
0000000000000000000000000000000000000000;;		os.Setenv(envBackoffBase, "1")
0000000000000000000000000000000000000000;;		os.Setenv(envBackoffDuration, "0")
0000000000000000000000000000000000000000;;		backoff.UpdateBackoff(theUrl, nil, 500)
0000000000000000000000000000000000000000;;		backoff.UpdateBackoff(theUrl, nil, 500)
0000000000000000000000000000000000000000;;		backoff = readExpBackoffConfig()
0000000000000000000000000000000000000000;;		if backoff.CalculateBackoff(theUrl)/time.Second != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Zero backoff duration, but backoff still occuring.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No env -> No backoff.
0000000000000000000000000000000000000000;;		os.Setenv(envBackoffBase, "")
0000000000000000000000000000000000000000;;		os.Setenv(envBackoffDuration, "")
0000000000000000000000000000000000000000;;		backoff = readExpBackoffConfig()
0000000000000000000000000000000000000000;;		backoff.UpdateBackoff(theUrl, nil, 500)
0000000000000000000000000000000000000000;;		backoff.UpdateBackoff(theUrl, nil, 500)
0000000000000000000000000000000000000000;;		if backoff.CalculateBackoff(theUrl)/time.Second != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Backoff should have been 0.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testServerEnv(t *testing.T, statusCode int) (*httptest.Server, *utiltesting.FakeHandler, *metav1.Status) {
0000000000000000000000000000000000000000;;		status := &metav1.Status{TypeMeta: metav1.TypeMeta{APIVersion: "v1", Kind: "Status"}, Status: fmt.Sprintf("%s", metav1.StatusSuccess)}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), status)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   statusCode,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		return testServer, &fakeHandler, status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restClient(testServer *httptest.Server) (*RESTClient, error) {
0000000000000000000000000000000000000000;;		c, err := RESTClientFor(&Config{
0000000000000000000000000000000000000000;;			Host: testServer.URL,
0000000000000000000000000000000000000000;;			ContentConfig: ContentConfig{
0000000000000000000000000000000000000000;;				GroupVersion:         &v1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				NegotiatedSerializer: serializer.DirectCodecFactory{CodecFactory: scheme.Codecs},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Username: "user",
0000000000000000000000000000000000000000;;			Password: "pass",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return c, err
0000000000000000000000000000000000000000;;	}
