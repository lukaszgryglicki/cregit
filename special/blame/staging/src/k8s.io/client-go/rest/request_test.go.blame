0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/request_test.go[staging/src/k8s.io/client-go/1.4/rest/request_test.go][staging/src/k8s.io/client-go/rest/request_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/streaming"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		restclientwatch "k8s.io/client-go/rest/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewRequestSetsAccept(t *testing.T) {
0000000000000000000000000000000000000000;;		r := NewRequest(nil, "get", &url.URL{Path: "/path/"}, "", ContentConfig{}, Serializers{}, nil, nil)
0000000000000000000000000000000000000000;;		if r.headers.Get("Accept") != "" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected headers: %#v", r.headers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r = NewRequest(nil, "get", &url.URL{Path: "/path/"}, "", ContentConfig{ContentType: "application/other"}, Serializers{}, nil, nil)
0000000000000000000000000000000000000000;;		if r.headers.Get("Accept") != "application/other, */*" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected headers: %#v", r.headers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientFunc func(req *http.Request) (*http.Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f clientFunc) Do(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return f(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestSetsHeaders(t *testing.T) {
0000000000000000000000000000000000000000;;		server := clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;			if req.Header.Get("Accept") != "application/other, */*" {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected headers: %#v", req.Header)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &http.Response{
0000000000000000000000000000000000000000;;				StatusCode: http.StatusForbidden,
0000000000000000000000000000000000000000;;				Body:       ioutil.NopCloser(bytes.NewReader([]byte{})),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		config := defaultContentConfig()
0000000000000000000000000000000000000000;;		config.ContentType = "application/other"
0000000000000000000000000000000000000000;;		serializers := defaultSerializers(t)
0000000000000000000000000000000000000000;;		r := NewRequest(server, "get", &url.URL{Path: "/path"}, "", config, serializers, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if all "issue" methods are setting headers.
0000000000000000000000000000000000000000;;		_ = r.Do()
0000000000000000000000000000000000000000;;		_, _ = r.Watch()
0000000000000000000000000000000000000000;;		_, _ = r.Stream()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestWithErrorWontChange(t *testing.T) {
0000000000000000000000000000000000000000;;		gvCopy := v1.SchemeGroupVersion
0000000000000000000000000000000000000000;;		original := Request{
0000000000000000000000000000000000000000;;			err:     errors.New("test"),
0000000000000000000000000000000000000000;;			content: ContentConfig{GroupVersion: &gvCopy},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := original
0000000000000000000000000000000000000000;;		changed := r.Param("foo", "bar").
0000000000000000000000000000000000000000;;			LabelsSelectorParam(labels.Set{"a": "b"}.AsSelector()).
0000000000000000000000000000000000000000;;			UintParam("uint", 1).
0000000000000000000000000000000000000000;;			AbsPath("/abs").
0000000000000000000000000000000000000000;;			Prefix("test").
0000000000000000000000000000000000000000;;			Suffix("testing").
0000000000000000000000000000000000000000;;			Namespace("new").
0000000000000000000000000000000000000000;;			Resource("foos").
0000000000000000000000000000000000000000;;			Name("bars").
0000000000000000000000000000000000000000;;			Body("foo").
0000000000000000000000000000000000000000;;			Timeout(time.Millisecond)
0000000000000000000000000000000000000000;;		if changed != &r {
0000000000000000000000000000000000000000;;			t.Errorf("returned request should point to the same object")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(changed, &original) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %#v, got %#v", &original, changed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestPreservesBaseTrailingSlash(t *testing.T) {
0000000000000000000000000000000000000000;;		r := &Request{baseURL: &url.URL{}, pathPrefix: "/path/"}
0000000000000000000000000000000000000000;;		if s := r.URL().String(); s != "/path/" {
0000000000000000000000000000000000000000;;			t.Errorf("trailing slash should be preserved: %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestAbsPathPreservesTrailingSlash(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{baseURL: &url.URL{}}).AbsPath("/foo/")
0000000000000000000000000000000000000000;;		if s := r.URL().String(); s != "/foo/" {
0000000000000000000000000000000000000000;;			t.Errorf("trailing slash should be preserved: %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r = (&Request{baseURL: &url.URL{}}).AbsPath("/foo/")
0000000000000000000000000000000000000000;;		if s := r.URL().String(); s != "/foo/" {
0000000000000000000000000000000000000000;;			t.Errorf("trailing slash should be preserved: %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestAbsPathJoins(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{baseURL: &url.URL{}}).AbsPath("foo/bar", "baz")
0000000000000000000000000000000000000000;;		if s := r.URL().String(); s != "foo/bar/baz" {
0000000000000000000000000000000000000000;;			t.Errorf("trailing slash should be preserved: %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestSetsNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{
0000000000000000000000000000000000000000;;			baseURL: &url.URL{
0000000000000000000000000000000000000000;;				Path: "/",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}).Namespace("foo")
0000000000000000000000000000000000000000;;		if r.namespace == "" {
0000000000000000000000000000000000000000;;			t.Errorf("namespace should be set: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s := r.URL().String(); s != "namespaces/foo" {
0000000000000000000000000000000000000000;;			t.Errorf("namespace should be in path: %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestOrdersNamespaceInPath(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{
0000000000000000000000000000000000000000;;			baseURL:    &url.URL{},
0000000000000000000000000000000000000000;;			pathPrefix: "/test/",
0000000000000000000000000000000000000000;;		}).Name("bar").Resource("baz").Namespace("foo")
0000000000000000000000000000000000000000;;		if s := r.URL().String(); s != "/test/namespaces/foo/baz/bar" {
0000000000000000000000000000000000000000;;			t.Errorf("namespace should be in order in path: %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestOrdersSubResource(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{
0000000000000000000000000000000000000000;;			baseURL:    &url.URL{},
0000000000000000000000000000000000000000;;			pathPrefix: "/test/",
0000000000000000000000000000000000000000;;		}).Name("bar").Resource("baz").Namespace("foo").Suffix("test").SubResource("a", "b")
0000000000000000000000000000000000000000;;		if s := r.URL().String(); s != "/test/namespaces/foo/baz/bar/a/b/test" {
0000000000000000000000000000000000000000;;			t.Errorf("namespace should be in order in path: %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestSetTwiceError(t *testing.T) {
0000000000000000000000000000000000000000;;		if (&Request{}).Name("bar").Name("baz").err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("setting name twice should result in error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (&Request{}).Namespace("bar").Namespace("baz").err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("setting namespace twice should result in error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (&Request{}).Resource("bar").Resource("baz").err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("setting resource twice should result in error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (&Request{}).SubResource("bar").SubResource("baz").err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("setting subresource twice should result in error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInvalidSegments(t *testing.T) {
0000000000000000000000000000000000000000;;		invalidSegments := []string{".", "..", "test/segment", "test%2bsegment"}
0000000000000000000000000000000000000000;;		setters := map[string]func(string, *Request){
0000000000000000000000000000000000000000;;			"namespace":   func(s string, r *Request) { r.Namespace(s) },
0000000000000000000000000000000000000000;;			"resource":    func(s string, r *Request) { r.Resource(s) },
0000000000000000000000000000000000000000;;			"name":        func(s string, r *Request) { r.Name(s) },
0000000000000000000000000000000000000000;;			"subresource": func(s string, r *Request) { r.SubResource(s) },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, invalidSegment := range invalidSegments {
0000000000000000000000000000000000000000;;			for setterName, setter := range setters {
0000000000000000000000000000000000000000;;				r := &Request{}
0000000000000000000000000000000000000000;;				setter(invalidSegment, r)
0000000000000000000000000000000000000000;;				if r.err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: %s: expected error, got none", setterName, invalidSegment)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestParam(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{}).Param("foo", "a")
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(r.params, url.Values{"foo": []string{"a"}}) {
0000000000000000000000000000000000000000;;			t.Errorf("should have set a param: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Param("bar", "1")
0000000000000000000000000000000000000000;;		r.Param("bar", "2")
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(r.params, url.Values{"foo": []string{"a"}, "bar": []string{"1", "2"}}) {
0000000000000000000000000000000000000000;;			t.Errorf("should have set a param: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestVersionedParams(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{content: ContentConfig{GroupVersion: &v1.SchemeGroupVersion}}).Param("foo", "a")
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(r.params, url.Values{"foo": []string{"a"}}) {
0000000000000000000000000000000000000000;;			t.Errorf("should have set a param: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.VersionedParams(&v1.PodLogOptions{Follow: true, Container: "bar"}, scheme.ParameterCodec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(r.params, url.Values{
0000000000000000000000000000000000000000;;			"foo":       []string{"a"},
0000000000000000000000000000000000000000;;			"container": []string{"bar"},
0000000000000000000000000000000000000000;;			"follow":    []string{"true"},
0000000000000000000000000000000000000000;;		}) {
0000000000000000000000000000000000000000;;			t.Errorf("should have set a param: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestVersionedParamsFromListOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		r := &Request{content: ContentConfig{GroupVersion: &v1.SchemeGroupVersion}}
0000000000000000000000000000000000000000;;		r.VersionedParams(&metav1.ListOptions{ResourceVersion: "1"}, scheme.ParameterCodec)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(r.params, url.Values{
0000000000000000000000000000000000000000;;			"resourceVersion": []string{"1"},
0000000000000000000000000000000000000000;;		}) {
0000000000000000000000000000000000000000;;			t.Errorf("should have set a param: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var timeout int64 = 10
0000000000000000000000000000000000000000;;		r.VersionedParams(&metav1.ListOptions{ResourceVersion: "2", TimeoutSeconds: &timeout}, scheme.ParameterCodec)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(r.params, url.Values{
0000000000000000000000000000000000000000;;			"resourceVersion": []string{"1", "2"},
0000000000000000000000000000000000000000;;			"timeoutSeconds":  []string{"10"},
0000000000000000000000000000000000000000;;		}) {
0000000000000000000000000000000000000000;;			t.Errorf("should have set a param: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestURI(t *testing.T) {
0000000000000000000000000000000000000000;;		r := (&Request{}).Param("foo", "a")
0000000000000000000000000000000000000000;;		r.Prefix("other")
0000000000000000000000000000000000000000;;		r.RequestURI("/test?foo=b&a=b&c=1&c=2")
0000000000000000000000000000000000000000;;		if r.pathPrefix != "/test" {
0000000000000000000000000000000000000000;;			t.Errorf("path is wrong: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(r.params, url.Values{"a": []string{"b"}, "foo": []string{"b"}, "c": []string{"1", "2"}}) {
0000000000000000000000000000000000000000;;			t.Errorf("should have set a param: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NotAnAPIObject struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj NotAnAPIObject) GroupVersionKind() *schema.GroupVersionKind       { return nil }
0000000000000000000000000000000000000000;;	func (obj NotAnAPIObject) SetGroupVersionKind(gvk *schema.GroupVersionKind) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultContentConfig() ContentConfig {
0000000000000000000000000000000000000000;;		gvCopy := v1.SchemeGroupVersion
0000000000000000000000000000000000000000;;		return ContentConfig{
0000000000000000000000000000000000000000;;			ContentType:          "application/json",
0000000000000000000000000000000000000000;;			GroupVersion:         &gvCopy,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: serializer.DirectCodecFactory{CodecFactory: scheme.Codecs},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultSerializers(t *testing.T) Serializers {
0000000000000000000000000000000000000000;;		config := defaultContentConfig()
0000000000000000000000000000000000000000;;		serializers, err := createSerializers(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *serializers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestBody(t *testing.T) {
0000000000000000000000000000000000000000;;		// test unknown type
0000000000000000000000000000000000000000;;		r := (&Request{}).Body([]string{"test"})
0000000000000000000000000000000000000000;;		if r.err == nil || r.body != nil {
0000000000000000000000000000000000000000;;			t.Errorf("should have set err and left body nil: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test error set when failing to read file
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unable to create temp file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		os.Remove(f.Name())
0000000000000000000000000000000000000000;;		r = (&Request{}).Body(f.Name())
0000000000000000000000000000000000000000;;		if r.err == nil || r.body != nil {
0000000000000000000000000000000000000000;;			t.Errorf("should have set err and left body nil: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test unencodable api object
0000000000000000000000000000000000000000;;		r = (&Request{content: defaultContentConfig()}).Body(&NotAnAPIObject{})
0000000000000000000000000000000000000000;;		if r.err == nil || r.body != nil {
0000000000000000000000000000000000000000;;			t.Errorf("should have set err and left body nil: %#v", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResultIntoWithErrReturnsErr(t *testing.T) {
0000000000000000000000000000000000000000;;		res := Result{err: errors.New("test")}
0000000000000000000000000000000000000000;;		if err := res.Into(&v1.Pod{}); err != res.err {
0000000000000000000000000000000000000000;;			t.Errorf("should have returned exact error from result")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResultIntoWithNoBodyReturnsErr(t *testing.T) {
0000000000000000000000000000000000000000;;		res := Result{
0000000000000000000000000000000000000000;;			body:    []byte{},
0000000000000000000000000000000000000000;;			decoder: scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := res.Into(&v1.Pod{}); err == nil || !strings.Contains(err.Error(), "0-length") {
0000000000000000000000000000000000000000;;			t.Errorf("should have complained about 0 length body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestURLTemplate(t *testing.T) {
0000000000000000000000000000000000000000;;		uri, _ := url.Parse("http://localhost")
0000000000000000000000000000000000000000;;		r := NewRequest(nil, "POST", uri, "", ContentConfig{GroupVersion: &schema.GroupVersion{Group: "test"}}, Serializers{}, nil, nil)
0000000000000000000000000000000000000000;;		r.Prefix("pre1").Resource("r1").Namespace("ns").Name("nm").Param("p0", "v0")
0000000000000000000000000000000000000000;;		full := r.URL()
0000000000000000000000000000000000000000;;		if full.String() != "http://localhost/pre1/namespaces/ns/r1/nm?p0=v0" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected initial URL: %s", full)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actualURL := r.finalURLTemplate()
0000000000000000000000000000000000000000;;		actual := actualURL.String()
0000000000000000000000000000000000000000;;		expected := "http://localhost/pre1/namespaces/%7Bnamespace%7D/r1/%7Bname%7D?p0=%7Bvalue%7D"
0000000000000000000000000000000000000000;;		if actual != expected {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected URL template: %s %s", actual, expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.URL().String() != full.String() {
0000000000000000000000000000000000000000;;			t.Errorf("creating URL template changed request: %s -> %s", full.String(), r.URL().String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTransformResponse(t *testing.T) {
0000000000000000000000000000000000000000;;		invalid := []byte("aaaaa")
0000000000000000000000000000000000000000;;		uri, _ := url.Parse("http://localhost")
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Response *http.Response
0000000000000000000000000000000000000000;;			Data     []byte
0000000000000000000000000000000000000000;;			Created  bool
0000000000000000000000000000000000000000;;			Error    bool
0000000000000000000000000000000000000000;;			ErrFn    func(err error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 200}, Data: []byte{}},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 201}, Data: []byte{}, Created: true},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 199}, Error: true},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 500}, Error: true},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 422}, Error: true},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 409}, Error: true},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 404}, Error: true},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 401}, Error: true},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 401,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Content-Type": []string{"application/json"}},
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(invalid)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Error: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return err.Error() != "aaaaa" && apierrors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 401,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Content-Type": []string{"text/any"}},
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(invalid)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Error: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return strings.Contains(err.Error(), "server has asked for the client to provide") && apierrors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 403}, Error: true},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 200, Body: ioutil.NopCloser(bytes.NewReader(invalid))}, Data: invalid},
0000000000000000000000000000000000000000;;			{Response: &http.Response{StatusCode: 200, Body: ioutil.NopCloser(bytes.NewReader(invalid))}, Data: invalid},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			r := NewRequest(nil, "", uri, "", defaultContentConfig(), defaultSerializers(t), nil, nil)
0000000000000000000000000000000000000000;;			if test.Response.Body == nil {
0000000000000000000000000000000000000000;;				test.Response.Body = ioutil.NopCloser(bytes.NewReader([]byte{}))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := r.transformResponse(test.Response, &http.Request{})
0000000000000000000000000000000000000000;;			response, created, err := result.body, result.statusCode == http.StatusCreated, result.err
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != test.Error {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %t %v", i, test.Error, err)
0000000000000000000000000000000000000000;;			} else if hasErr && test.Response.StatusCode > 399 {
0000000000000000000000000000000000000000;;				status, ok := err.(apierrors.APIStatus)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Errorf("%d: response should have been transformable into APIStatus: %v", i, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if int(status.Status().Code) != test.Response.StatusCode {
0000000000000000000000000000000000000000;;					t.Errorf("%d: status code did not match response: %#v", i, status.Status())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.ErrFn != nil && !test.ErrFn(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: error function did not match: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !(test.Data == nil && response == nil) && !apiequality.Semantic.DeepDerivative(test.Data, response) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected response: %#v %#v", i, test.Data, response)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.Created != created {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected created %t, got %t", i, test.Created, created)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type renegotiator struct {
0000000000000000000000000000000000000000;;		called      bool
0000000000000000000000000000000000000000;;		contentType string
0000000000000000000000000000000000000000;;		params      map[string]string
0000000000000000000000000000000000000000;;		decoder     runtime.Decoder
0000000000000000000000000000000000000000;;		err         error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *renegotiator) invoke(contentType string, params map[string]string) (runtime.Decoder, error) {
0000000000000000000000000000000000000000;;		r.called = true
0000000000000000000000000000000000000000;;		r.contentType = contentType
0000000000000000000000000000000000000000;;		r.params = params
0000000000000000000000000000000000000000;;		return r.decoder, r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTransformResponseNegotiate(t *testing.T) {
0000000000000000000000000000000000000000;;		invalid := []byte("aaaaa")
0000000000000000000000000000000000000000;;		uri, _ := url.Parse("http://localhost")
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Response *http.Response
0000000000000000000000000000000000000000;;			Data     []byte
0000000000000000000000000000000000000000;;			Created  bool
0000000000000000000000000000000000000000;;			Error    bool
0000000000000000000000000000000000000000;;			ErrFn    func(err error) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ContentType       string
0000000000000000000000000000000000000000;;			Called            bool
0000000000000000000000000000000000000000;;			ExpectContentType string
0000000000000000000000000000000000000000;;			Decoder           runtime.Decoder
0000000000000000000000000000000000000000;;			NegotiateErr      error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ContentType: "application/json",
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 401,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Content-Type": []string{"application/json"}},
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(invalid)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Error: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return err.Error() != "aaaaa" && apierrors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ContentType: "application/json",
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 401,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Content-Type": []string{"application/protobuf"}},
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(invalid)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Decoder: scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Called:            true,
0000000000000000000000000000000000000000;;				ExpectContentType: "application/protobuf",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Error: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return err.Error() != "aaaaa" && apierrors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ContentType: "application/json",
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 500,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Content-Type": []string{"application/,others"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Decoder: scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Error: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return err.Error() == "Internal error occurred: mime: expected token after slash" && err.(apierrors.APIStatus).Status().Code == 500
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// no negotiation when no content type specified
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 200,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Content-Type": []string{"text/any"}},
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(invalid)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Decoder: scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// no negotiation when no response content type specified
0000000000000000000000000000000000000000;;				ContentType: "text/any",
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 200,
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(invalid)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Decoder: scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// unrecognized content type is not handled
0000000000000000000000000000000000000000;;				ContentType: "application/json",
0000000000000000000000000000000000000000;;				Response: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: 404,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Content-Type": []string{"application/unrecognized"}},
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(invalid)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Decoder: scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				NegotiateErr:      fmt.Errorf("aaaa"),
0000000000000000000000000000000000000000;;				Called:            true,
0000000000000000000000000000000000000000;;				ExpectContentType: "application/unrecognized",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Error: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return err.Error() != "aaaaa" && apierrors.IsNotFound(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			serializers := defaultSerializers(t)
0000000000000000000000000000000000000000;;			negotiator := &renegotiator{
0000000000000000000000000000000000000000;;				decoder: test.Decoder,
0000000000000000000000000000000000000000;;				err:     test.NegotiateErr,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serializers.RenegotiatedDecoder = negotiator.invoke
0000000000000000000000000000000000000000;;			contentConfig := defaultContentConfig()
0000000000000000000000000000000000000000;;			contentConfig.ContentType = test.ContentType
0000000000000000000000000000000000000000;;			r := NewRequest(nil, "", uri, "", contentConfig, serializers, nil, nil)
0000000000000000000000000000000000000000;;			if test.Response.Body == nil {
0000000000000000000000000000000000000000;;				test.Response.Body = ioutil.NopCloser(bytes.NewReader([]byte{}))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := r.transformResponse(test.Response, &http.Request{})
0000000000000000000000000000000000000000;;			_, err := result.body, result.err
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != test.Error {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %t %v", i, test.Error, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if hasErr && test.Response.StatusCode > 399 {
0000000000000000000000000000000000000000;;				status, ok := err.(apierrors.APIStatus)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Errorf("%d: response should have been transformable into APIStatus: %v", i, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if int(status.Status().Code) != test.Response.StatusCode {
0000000000000000000000000000000000000000;;					t.Errorf("%d: status code did not match response: %#v", i, status.Status())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.ErrFn != nil && !test.ErrFn(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: error function did not match: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if negotiator.called != test.Called {
0000000000000000000000000000000000000000;;				t.Errorf("%d: negotiator called %t != %t", i, negotiator.called, test.Called)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.Called {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if negotiator.contentType != test.ExpectContentType {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected content type: %s", i, negotiator.contentType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTransformUnstructuredError(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Req *http.Request
0000000000000000000000000000000000000000;;			Res *http.Response
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Resource string
0000000000000000000000000000000000000000;;			Name     string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ErrFn       func(error) bool
0000000000000000000000000000000000000000;;			Transformed error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resource: "foo",
0000000000000000000000000000000000000000;;				Name:     "bar",
0000000000000000000000000000000000000000;;				Req: &http.Request{
0000000000000000000000000000000000000000;;					Method: "POST",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Res: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusConflict,
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(nil)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsAlreadyExists,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resource: "foo",
0000000000000000000000000000000000000000;;				Name:     "bar",
0000000000000000000000000000000000000000;;				Req: &http.Request{
0000000000000000000000000000000000000000;;					Method: "PUT",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Res: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusConflict,
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(nil)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsConflict,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resource: "foo",
0000000000000000000000000000000000000000;;				Name:     "bar",
0000000000000000000000000000000000000000;;				Req:      &http.Request{},
0000000000000000000000000000000000000000;;				Res: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusNotFound,
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(nil)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsNotFound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Req: &http.Request{},
0000000000000000000000000000000000000000;;				Res: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusBadRequest,
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader(nil)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsBadRequest,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// status in response overrides transformed result
0000000000000000000000000000000000000000;;				Req:   &http.Request{},
0000000000000000000000000000000000000000;;				Res:   &http.Response{StatusCode: http.StatusBadRequest, Body: ioutil.NopCloser(bytes.NewReader([]byte(`{"kind":"Status","apiVersion":"v1","status":"Failure","code":404}`)))},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsBadRequest,
0000000000000000000000000000000000000000;;				Transformed: &apierrors.StatusError{
0000000000000000000000000000000000000000;;					ErrStatus: metav1.Status{Status: metav1.StatusFailure, Code: http.StatusNotFound},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// successful status is ignored
0000000000000000000000000000000000000000;;				Req:   &http.Request{},
0000000000000000000000000000000000000000;;				Res:   &http.Response{StatusCode: http.StatusBadRequest, Body: ioutil.NopCloser(bytes.NewReader([]byte(`{"kind":"Status","apiVersion":"v1","status":"Success","code":404}`)))},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsBadRequest,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// empty object does not change result
0000000000000000000000000000000000000000;;				Req:   &http.Request{},
0000000000000000000000000000000000000000;;				Res:   &http.Response{StatusCode: http.StatusBadRequest, Body: ioutil.NopCloser(bytes.NewReader([]byte(`{}`)))},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsBadRequest,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// we default apiVersion for backwards compatibility with old clients
0000000000000000000000000000000000000000;;				// TODO: potentially remove in 1.7
0000000000000000000000000000000000000000;;				Req:   &http.Request{},
0000000000000000000000000000000000000000;;				Res:   &http.Response{StatusCode: http.StatusBadRequest, Body: ioutil.NopCloser(bytes.NewReader([]byte(`{"kind":"Status","status":"Failure","code":404}`)))},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsBadRequest,
0000000000000000000000000000000000000000;;				Transformed: &apierrors.StatusError{
0000000000000000000000000000000000000000;;					ErrStatus: metav1.Status{Status: metav1.StatusFailure, Code: http.StatusNotFound},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// we do not default kind
0000000000000000000000000000000000000000;;				Req:   &http.Request{},
0000000000000000000000000000000000000000;;				Res:   &http.Response{StatusCode: http.StatusBadRequest, Body: ioutil.NopCloser(bytes.NewReader([]byte(`{"status":"Failure","code":404}`)))},
0000000000000000000000000000000000000000;;				ErrFn: apierrors.IsBadRequest,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			r := &Request{
0000000000000000000000000000000000000000;;				content:      defaultContentConfig(),
0000000000000000000000000000000000000000;;				serializers:  defaultSerializers(t),
0000000000000000000000000000000000000000;;				resourceName: testCase.Name,
0000000000000000000000000000000000000000;;				resource:     testCase.Resource,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := r.transformResponse(testCase.Res, testCase.Req)
0000000000000000000000000000000000000000;;			err := result.err
0000000000000000000000000000000000000000;;			if !testCase.ErrFn(err) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apierrors.IsUnexpectedServerError(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error type: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(testCase.Name) != 0 && !strings.Contains(err.Error(), testCase.Name) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error string: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(testCase.Resource) != 0 && !strings.Contains(err.Error(), testCase.Resource) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error string: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify Error() properly transforms the error
0000000000000000000000000000000000000000;;			transformed := result.Error()
0000000000000000000000000000000000000000;;			expect := testCase.Transformed
0000000000000000000000000000000000000000;;			if expect == nil {
0000000000000000000000000000000000000000;;				expect = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expect, transformed) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected Error(): %s", i, diff.ObjectReflectDiff(expect, transformed))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify result.Get properly transforms the error
0000000000000000000000000000000000000000;;			if _, err := result.Get(); !reflect.DeepEqual(expect, err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error on Get(): %s", i, diff.ObjectReflectDiff(expect, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify result.Into properly handles the error
0000000000000000000000000000000000000000;;			if err := result.Into(&v1.Pod{}); !reflect.DeepEqual(expect, err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error on Into(): %s", i, diff.ObjectReflectDiff(expect, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify result.Raw leaves the error in the untransformed state
0000000000000000000000000000000000000000;;			if _, err := result.Raw(); !reflect.DeepEqual(result.err, err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error on Raw(): %s", i, diff.ObjectReflectDiff(expect, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Request *Request
0000000000000000000000000000000000000000;;			Err     bool
0000000000000000000000000000000000000000;;			ErrFn   func(error) bool
0000000000000000000000000000000000000000;;			Empty   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{err: errors.New("bail")},
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{baseURL: &url.URL{}, pathPrefix: "%"},
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return nil, errors.New("err")
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					content:     defaultContentConfig(),
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return &http.Response{
0000000000000000000000000000000000000000;;							StatusCode: http.StatusForbidden,
0000000000000000000000000000000000000000;;							Body:       ioutil.NopCloser(bytes.NewReader([]byte{})),
0000000000000000000000000000000000000000;;						}, nil
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return apierrors.IsForbidden(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					content:     defaultContentConfig(),
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return &http.Response{
0000000000000000000000000000000000000000;;							StatusCode: http.StatusUnauthorized,
0000000000000000000000000000000000000000;;							Body:       ioutil.NopCloser(bytes.NewReader([]byte{})),
0000000000000000000000000000000000000000;;						}, nil
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return apierrors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					content:     defaultContentConfig(),
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return &http.Response{
0000000000000000000000000000000000000000;;							StatusCode: http.StatusUnauthorized,
0000000000000000000000000000000000000000;;							Body: ioutil.NopCloser(bytes.NewReader([]byte(runtime.EncodeOrDie(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), &metav1.Status{
0000000000000000000000000000000000000000;;								Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;								Reason: metav1.StatusReasonUnauthorized,
0000000000000000000000000000000000000000;;							})))),
0000000000000000000000000000000000000000;;						}, nil
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return apierrors.IsUnauthorized(err)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return nil, io.EOF
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Empty: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return nil, &url.Error{Err: io.EOF}
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Empty: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return nil, errors.New("http: can't write HTTP request on broken connection")
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Empty: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return nil, errors.New("foo: connection reset by peer")
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Empty: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			t.Logf("testcase %v", testCase.Request)
0000000000000000000000000000000000000000;;			testCase.Request.backoffMgr = &NoBackoff{}
0000000000000000000000000000000000000000;;			watch, err := testCase.Request.Watch()
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != testCase.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %t, got %t: %v", i, testCase.Err, hasErr, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if testCase.ErrFn != nil && !testCase.ErrFn(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: error not valid: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasErr && watch != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: watch should be nil when error is returned", i)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if testCase.Empty {
0000000000000000000000000000000000000000;;				_, ok := <-watch.ResultChan()
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					t.Errorf("%d: expected the watch to be empty: %#v", i, watch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestStream(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Request *Request
0000000000000000000000000000000000000000;;			Err     bool
0000000000000000000000000000000000000000;;			ErrFn   func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{err: errors.New("bail")},
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{baseURL: &url.URL{}, pathPrefix: "%"},
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return nil, errors.New("err")
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return &http.Response{
0000000000000000000000000000000000000000;;							StatusCode: http.StatusUnauthorized,
0000000000000000000000000000000000000000;;							Body: ioutil.NopCloser(bytes.NewReader([]byte(runtime.EncodeOrDie(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), &metav1.Status{
0000000000000000000000000000000000000000;;								Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;								Reason: metav1.StatusReasonUnauthorized,
0000000000000000000000000000000000000000;;							})))),
0000000000000000000000000000000000000000;;						}, nil
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					content:     defaultContentConfig(),
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					baseURL:     &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return &http.Response{
0000000000000000000000000000000000000000;;							StatusCode: http.StatusBadRequest,
0000000000000000000000000000000000000000;;							Body:       ioutil.NopCloser(bytes.NewReader([]byte(`{"kind":"Status","apiVersion":"v1","metadata":{},"status":"Failure","message":"a container name must be specified for pod kube-dns-v20-mz5cv, choose one of: [kubedns dnsmasq healthz]","reason":"BadRequest","code":400}`))),
0000000000000000000000000000000000000000;;						}, nil
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					content:     defaultContentConfig(),
0000000000000000000000000000000000000000;;					serializers: defaultSerializers(t),
0000000000000000000000000000000000000000;;					baseURL:     &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;				ErrFn: func(err error) bool {
0000000000000000000000000000000000000000;;					if err.Error() == "a container name must be specified for pod kube-dns-v20-mz5cv, choose one of: [kubedns dnsmasq healthz]" {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			testCase.Request.backoffMgr = &NoBackoff{}
0000000000000000000000000000000000000000;;			body, err := testCase.Request.Stream()
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != testCase.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %t, got %t: %v", i, testCase.Err, hasErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasErr && body != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: body should be nil when error is returned", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hasErr {
0000000000000000000000000000000000000000;;				if testCase.ErrFn != nil && !testCase.ErrFn(err) {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeUpgradeConnection struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeUpgradeConnection) CreateStream(headers http.Header) (httpstream.Stream, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *fakeUpgradeConnection) Close() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *fakeUpgradeConnection) CloseChan() <-chan bool {
0000000000000000000000000000000000000000;;		return make(chan bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *fakeUpgradeConnection) SetIdleTimeout(timeout time.Duration) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeUpgradeRoundTripper struct {
0000000000000000000000000000000000000000;;		req  *http.Request
0000000000000000000000000000000000000000;;		conn httpstream.Connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeUpgradeRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		f.req = req
0000000000000000000000000000000000000000;;		b := []byte{}
0000000000000000000000000000000000000000;;		body := ioutil.NopCloser(bytes.NewReader(b))
0000000000000000000000000000000000000000;;		resp := &http.Response{
0000000000000000000000000000000000000000;;			StatusCode: 101,
0000000000000000000000000000000000000000;;			Body:       body,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeUpgradeRoundTripper) NewConnection(resp *http.Response) (httpstream.Connection, error) {
0000000000000000000000000000000000000000;;		return f.conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestDo(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Request *Request
0000000000000000000000000000000000000000;;			Err     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{err: errors.New("bail")},
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{baseURL: &url.URL{}, pathPrefix: "%"},
0000000000000000000000000000000000000000;;				Err:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Request: &Request{
0000000000000000000000000000000000000000;;					client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;						return nil, errors.New("err")
0000000000000000000000000000000000000000;;					}),
0000000000000000000000000000000000000000;;					baseURL: &url.URL{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Err: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			testCase.Request.backoffMgr = &NoBackoff{}
0000000000000000000000000000000000000000;;			body, err := testCase.Request.Do().Raw()
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != testCase.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %t, got %t: %v", i, testCase.Err, hasErr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasErr && body != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: body should be nil when error is returned", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestNewWay(t *testing.T) {
0000000000000000000000000000000000000000;;		reqBody := "request body"
0000000000000000000000000000000000000000;;		expectedObj := &v1.Service{Spec: v1.ServiceSpec{Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;			Protocol:   "TCP",
0000000000000000000000000000000000000000;;			Port:       12345,
0000000000000000000000000000000000000000;;			TargetPort: intstr.FromInt(12345),
0000000000000000000000000000000000000000;;		}}}}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), expectedObj)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   200,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		obj, err := c.Verb("POST").
0000000000000000000000000000000000000000;;			Prefix("foo", "bar").
0000000000000000000000000000000000000000;;			Suffix("baz").
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body([]byte(reqBody)).
0000000000000000000000000000000000000000;;			Do().Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			t.Error("nil obj")
0000000000000000000000000000000000000000;;		} else if !apiequality.Semantic.DeepDerivative(expectedObj, obj) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, got %#v", expectedObj, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestURL := defaultResourcePathWithPrefix("foo/bar", "", "", "baz")
0000000000000000000000000000000000000000;;		requestURL += "?timeout=1s"
0000000000000000000000000000000000000000;;		fakeHandler.ValidateRequest(t, requestURL, "POST", &reqBody)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This test assumes that the client implementation backs off exponentially, for an individual request.
0000000000000000000000000000000000000000;;	func TestBackoffLifecycle(t *testing.T) {
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			t.Logf("Attempt %d", count)
0000000000000000000000000000000000000000;;			if count == 5 || count == 9 {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusGatewayTimeout)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test backoff recovery and increase.  This correlates to the constants
0000000000000000000000000000000000000000;;		// which are used in the server implementation returning StatusOK above.
0000000000000000000000000000000000000000;;		seconds := []int{0, 1, 2, 4, 8, 0, 1, 2, 4, 0}
0000000000000000000000000000000000000000;;		request := c.Verb("POST").Prefix("backofftest").Suffix("abc")
0000000000000000000000000000000000000000;;		clock := clock.FakeClock{}
0000000000000000000000000000000000000000;;		request.backoffMgr = &URLBackoff{
0000000000000000000000000000000000000000;;			// Use a fake backoff here to avoid flakes and speed the test up.
0000000000000000000000000000000000000000;;			Backoff: flowcontrol.NewFakeBackOff(
0000000000000000000000000000000000000000;;				time.Duration(1)*time.Second,
0000000000000000000000000000000000000000;;				time.Duration(200)*time.Second,
0000000000000000000000000000000000000000;;				&clock,
0000000000000000000000000000000000000000;;			)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sec := range seconds {
0000000000000000000000000000000000000000;;			thisBackoff := request.backoffMgr.CalculateBackoff(request.URL())
0000000000000000000000000000000000000000;;			t.Logf("Current backoff %v", thisBackoff)
0000000000000000000000000000000000000000;;			if thisBackoff != time.Duration(sec)*time.Second {
0000000000000000000000000000000000000000;;				t.Errorf("Backoff is %v instead of %v", thisBackoff, sec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			now := clock.Now()
0000000000000000000000000000000000000000;;			request.DoRaw()
0000000000000000000000000000000000000000;;			elapsed := clock.Since(now)
0000000000000000000000000000000000000000;;			if clock.Since(now) != thisBackoff {
0000000000000000000000000000000000000000;;				t.Errorf("CalculatedBackoff not honored by clock: Expected time of %v, but got %v ", thisBackoff, elapsed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testBackoffManager struct {
0000000000000000000000000000000000000000;;		sleeps []time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *testBackoffManager) UpdateBackoff(actualUrl *url.URL, err error, responseCode int) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *testBackoffManager) CalculateBackoff(actualUrl *url.URL) time.Duration {
0000000000000000000000000000000000000000;;		return time.Duration(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *testBackoffManager) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		b.sleeps = append(b.sleeps, d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckRetryClosesBody(t *testing.T) {
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			t.Logf("attempt %d", count)
0000000000000000000000000000000000000000;;			if count >= 5 {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				close(ch)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Retry-After", "1")
0000000000000000000000000000000000000000;;			http.Error(w, "Too many requests, please try again later.", apierrors.StatusTooManyRequests)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backoffMgr := &testBackoffManager{}
0000000000000000000000000000000000000000;;		expectedSleeps := []time.Duration{0, time.Second, 0, time.Second, 0, time.Second, 0, time.Second, 0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		c.createBackoffMgr = func() BackoffManager { return backoffMgr }
0000000000000000000000000000000000000000;;		_, err := c.Verb("POST").
0000000000000000000000000000000000000000;;			Prefix("foo", "bar").
0000000000000000000000000000000000000000;;			Suffix("baz").
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body([]byte(strings.Repeat("abcd", 1000))).
0000000000000000000000000000000000000000;;			DoRaw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;		if count != 5 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected retries: %d", count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(backoffMgr.sleeps, expectedSleeps) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected sleeps, expected: %v, got: %v", expectedSleeps, backoffMgr.sleeps)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnectionResetByPeerIsRetried(t *testing.T) {
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		backoff := &testBackoffManager{}
0000000000000000000000000000000000000000;;		req := &Request{
0000000000000000000000000000000000000000;;			verb: "GET",
0000000000000000000000000000000000000000;;			client: clientFunc(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;				if count >= 3 {
0000000000000000000000000000000000000000;;					return &http.Response{
0000000000000000000000000000000000000000;;						StatusCode: 200,
0000000000000000000000000000000000000000;;						Body:       ioutil.NopCloser(bytes.NewReader([]byte{})),
0000000000000000000000000000000000000000;;					}, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, &net.OpError{Err: syscall.ECONNRESET}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			backoffMgr: backoff,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We expect two retries of "connection reset by peer" and the success.
0000000000000000000000000000000000000000;;		_, err := req.Do().Raw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We have a sleep before each retry (including the initial one) and for
0000000000000000000000000000000000000000;;		// every "retry-after" call - thus 5 together.
0000000000000000000000000000000000000000;;		if len(backoff.sleeps) != 5 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 5 retries, got: %d", len(backoff.sleeps))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckRetryHandles429And5xx(t *testing.T) {
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unable to read request body: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !bytes.Equal(data, []byte(strings.Repeat("abcd", 1000))) {
0000000000000000000000000000000000000000;;				t.Fatalf("retry did not send a complete body: %s", data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("attempt %d", count)
0000000000000000000000000000000000000000;;			if count >= 4 {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				close(ch)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Retry-After", "0")
0000000000000000000000000000000000000000;;			w.WriteHeader([]int{apierrors.StatusTooManyRequests, 500, 501, 504}[count])
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		_, err := c.Verb("POST").
0000000000000000000000000000000000000000;;			Prefix("foo", "bar").
0000000000000000000000000000000000000000;;			Suffix("baz").
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body([]byte(strings.Repeat("abcd", 1000))).
0000000000000000000000000000000000000000;;			DoRaw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;		if count != 4 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected retries: %d", count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkCheckRetryClosesBody(b *testing.B) {
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			if count%3 == 0 {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Retry-After", "0")
0000000000000000000000000000000000000000;;			w.WriteHeader(apierrors.StatusTooManyRequests)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := testRESTClient(b, testServer)
0000000000000000000000000000000000000000;;		r := c.Verb("POST").
0000000000000000000000000000000000000000;;			Prefix("foo", "bar").
0000000000000000000000000000000000000000;;			Suffix("baz").
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body([]byte(strings.Repeat("abcd", 1000)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := r.DoRaw(); err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestNewWayReader(t *testing.T) {
0000000000000000000000000000000000000000;;		reqObj := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		reqBodyExpected, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), reqObj)
0000000000000000000000000000000000000000;;		expectedObj := &v1.Service{Spec: v1.ServiceSpec{Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;			Protocol:   "TCP",
0000000000000000000000000000000000000000;;			Port:       12345,
0000000000000000000000000000000000000000;;			TargetPort: intstr.FromInt(12345),
0000000000000000000000000000000000000000;;		}}}}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), expectedObj)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   200,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		obj, err := c.Verb("POST").
0000000000000000000000000000000000000000;;			Resource("bar").
0000000000000000000000000000000000000000;;			Name("baz").
0000000000000000000000000000000000000000;;			Prefix("foo").
0000000000000000000000000000000000000000;;			LabelsSelectorParam(labels.Set{"name": "foo"}.AsSelector()).
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body(bytes.NewBuffer(reqBodyExpected)).
0000000000000000000000000000000000000000;;			Do().Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			t.Error("nil obj")
0000000000000000000000000000000000000000;;		} else if !apiequality.Semantic.DeepDerivative(expectedObj, obj) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, got %#v", expectedObj, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmpStr := string(reqBodyExpected)
0000000000000000000000000000000000000000;;		requestURL := defaultResourcePathWithPrefix("foo", "bar", "", "baz")
0000000000000000000000000000000000000000;;		requestURL += "?" + metav1.LabelSelectorQueryParam(v1.SchemeGroupVersion.String()) + "=name%3Dfoo&timeout=1s"
0000000000000000000000000000000000000000;;		fakeHandler.ValidateRequest(t, requestURL, "POST", &tmpStr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestNewWayObj(t *testing.T) {
0000000000000000000000000000000000000000;;		reqObj := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		reqBodyExpected, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), reqObj)
0000000000000000000000000000000000000000;;		expectedObj := &v1.Service{Spec: v1.ServiceSpec{Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;			Protocol:   "TCP",
0000000000000000000000000000000000000000;;			Port:       12345,
0000000000000000000000000000000000000000;;			TargetPort: intstr.FromInt(12345),
0000000000000000000000000000000000000000;;		}}}}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), expectedObj)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   200,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		obj, err := c.Verb("POST").
0000000000000000000000000000000000000000;;			Suffix("baz").
0000000000000000000000000000000000000000;;			Name("bar").
0000000000000000000000000000000000000000;;			Resource("foo").
0000000000000000000000000000000000000000;;			LabelsSelectorParam(labels.Set{"name": "foo"}.AsSelector()).
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body(reqObj).
0000000000000000000000000000000000000000;;			Do().Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			t.Error("nil obj")
0000000000000000000000000000000000000000;;		} else if !apiequality.Semantic.DeepDerivative(expectedObj, obj) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, got %#v", expectedObj, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmpStr := string(reqBodyExpected)
0000000000000000000000000000000000000000;;		requestURL := defaultResourcePathWithPrefix("", "foo", "", "bar/baz")
0000000000000000000000000000000000000000;;		requestURL += "?" + metav1.LabelSelectorQueryParam(v1.SchemeGroupVersion.String()) + "=name%3Dfoo&timeout=1s"
0000000000000000000000000000000000000000;;		fakeHandler.ValidateRequest(t, requestURL, "POST", &tmpStr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoRequestNewWayFile(t *testing.T) {
0000000000000000000000000000000000000000;;		reqObj := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		reqBodyExpected, err := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), reqObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := ioutil.TempFile("", "foo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		defer os.Remove(file.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = file.Write(reqBodyExpected)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedObj := &v1.Service{Spec: v1.ServiceSpec{Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;			Protocol:   "TCP",
0000000000000000000000000000000000000000;;			Port:       12345,
0000000000000000000000000000000000000000;;			TargetPort: intstr.FromInt(12345),
0000000000000000000000000000000000000000;;		}}}}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), expectedObj)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   200,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		wasCreated := true
0000000000000000000000000000000000000000;;		obj, err := c.Verb("POST").
0000000000000000000000000000000000000000;;			Prefix("foo/bar", "baz").
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body(file.Name()).
0000000000000000000000000000000000000000;;			Do().WasCreated(&wasCreated).Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			t.Error("nil obj")
0000000000000000000000000000000000000000;;		} else if !apiequality.Semantic.DeepDerivative(expectedObj, obj) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, got %#v", expectedObj, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasCreated {
0000000000000000000000000000000000000000;;			t.Errorf("expected object was created")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmpStr := string(reqBodyExpected)
0000000000000000000000000000000000000000;;		requestURL := defaultResourcePathWithPrefix("foo/bar/baz", "", "", "")
0000000000000000000000000000000000000000;;		requestURL += "?timeout=1s"
0000000000000000000000000000000000000000;;		fakeHandler.ValidateRequest(t, requestURL, "POST", &tmpStr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWasCreated(t *testing.T) {
0000000000000000000000000000000000000000;;		reqObj := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		reqBodyExpected, err := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), reqObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedObj := &v1.Service{Spec: v1.ServiceSpec{Ports: []v1.ServicePort{{
0000000000000000000000000000000000000000;;			Protocol:   "TCP",
0000000000000000000000000000000000000000;;			Port:       12345,
0000000000000000000000000000000000000000;;			TargetPort: intstr.FromInt(12345),
0000000000000000000000000000000000000000;;		}}}}
0000000000000000000000000000000000000000;;		expectedBody, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), expectedObj)
0000000000000000000000000000000000000000;;		fakeHandler := utiltesting.FakeHandler{
0000000000000000000000000000000000000000;;			StatusCode:   201,
0000000000000000000000000000000000000000;;			ResponseBody: string(expectedBody),
0000000000000000000000000000000000000000;;			T:            t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(&fakeHandler)
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		wasCreated := false
0000000000000000000000000000000000000000;;		obj, err := c.Verb("PUT").
0000000000000000000000000000000000000000;;			Prefix("foo/bar", "baz").
0000000000000000000000000000000000000000;;			Timeout(time.Second).
0000000000000000000000000000000000000000;;			Body(reqBodyExpected).
0000000000000000000000000000000000000000;;			Do().WasCreated(&wasCreated).Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v %#v", err, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			t.Error("nil obj")
0000000000000000000000000000000000000000;;		} else if !apiequality.Semantic.DeepDerivative(expectedObj, obj) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, got %#v", expectedObj, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wasCreated {
0000000000000000000000000000000000000000;;			t.Errorf("Expected object was created")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmpStr := string(reqBodyExpected)
0000000000000000000000000000000000000000;;		requestURL := defaultResourcePathWithPrefix("foo/bar/baz", "", "", "")
0000000000000000000000000000000000000000;;		requestURL += "?timeout=1s"
0000000000000000000000000000000000000000;;		fakeHandler.ValidateRequest(t, requestURL, "PUT", &tmpStr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVerbs(t *testing.T) {
0000000000000000000000000000000000000000;;		c := testRESTClient(t, nil)
0000000000000000000000000000000000000000;;		if r := c.Post(); r.verb != "POST" {
0000000000000000000000000000000000000000;;			t.Errorf("Post verb is wrong")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r := c.Put(); r.verb != "PUT" {
0000000000000000000000000000000000000000;;			t.Errorf("Put verb is wrong")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r := c.Get(); r.verb != "GET" {
0000000000000000000000000000000000000000;;			t.Errorf("Get verb is wrong")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r := c.Delete(); r.verb != "DELETE" {
0000000000000000000000000000000000000000;;			t.Errorf("Delete verb is wrong")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAbsPath(t *testing.T) {
0000000000000000000000000000000000000000;;		for i, tc := range []struct {
0000000000000000000000000000000000000000;;			configPrefix   string
0000000000000000000000000000000000000000;;			resourcePrefix string
0000000000000000000000000000000000000000;;			absPath        string
0000000000000000000000000000000000000000;;			wantsAbsPath   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"/", "", "", "/"},
0000000000000000000000000000000000000000;;			{"", "", "/", "/"},
0000000000000000000000000000000000000000;;			{"", "", "/api", "/api"},
0000000000000000000000000000000000000000;;			{"", "", "/api/", "/api/"},
0000000000000000000000000000000000000000;;			{"", "", "/apis", "/apis"},
0000000000000000000000000000000000000000;;			{"", "/foo", "/bar/foo", "/bar/foo"},
0000000000000000000000000000000000000000;;			{"", "/api/foo/123", "/bar/foo", "/bar/foo"},
0000000000000000000000000000000000000000;;			{"/p1", "", "", "/p1"},
0000000000000000000000000000000000000000;;			{"/p1", "", "/", "/p1/"},
0000000000000000000000000000000000000000;;			{"/p1", "", "/api", "/p1/api"},
0000000000000000000000000000000000000000;;			{"/p1", "", "/apis", "/p1/apis"},
0000000000000000000000000000000000000000;;			{"/p1", "/r1", "/apis", "/p1/apis"},
0000000000000000000000000000000000000000;;			{"/p1", "/api/r1", "/apis", "/p1/apis"},
0000000000000000000000000000000000000000;;			{"/p1/api/p2", "", "", "/p1/api/p2"},
0000000000000000000000000000000000000000;;			{"/p1/api/p2", "", "/", "/p1/api/p2/"},
0000000000000000000000000000000000000000;;			{"/p1/api/p2", "", "/api", "/p1/api/p2/api"},
0000000000000000000000000000000000000000;;			{"/p1/api/p2", "", "/api/", "/p1/api/p2/api/"},
0000000000000000000000000000000000000000;;			{"/p1/api/p2", "/r1", "/api/", "/p1/api/p2/api/"},
0000000000000000000000000000000000000000;;			{"/p1/api/p2", "/api/r1", "/api/", "/p1/api/p2/api/"},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			u, _ := url.Parse("http://localhost:123" + tc.configPrefix)
0000000000000000000000000000000000000000;;			r := NewRequest(nil, "POST", u, "", ContentConfig{GroupVersion: &schema.GroupVersion{Group: "test"}}, Serializers{}, nil, nil).Prefix(tc.resourcePrefix).AbsPath(tc.absPath)
0000000000000000000000000000000000000000;;			if r.pathPrefix != tc.wantsAbsPath {
0000000000000000000000000000000000000000;;				t.Errorf("test case %d failed, unexpected path: %q, expected %q", i, r.pathPrefix, tc.wantsAbsPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUintParam(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			name      string
0000000000000000000000000000000000000000;;			testVal   uint64
0000000000000000000000000000000000000000;;			expectStr string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"foo", 31415, "http://localhost?foo=31415"},
0000000000000000000000000000000000000000;;			{"bar", 42, "http://localhost?bar=42"},
0000000000000000000000000000000000000000;;			{"baz", 0, "http://localhost?baz=0"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			u, _ := url.Parse("http://localhost")
0000000000000000000000000000000000000000;;			r := NewRequest(nil, "GET", u, "", ContentConfig{GroupVersion: &schema.GroupVersion{Group: "test"}}, Serializers{}, nil, nil).AbsPath("").UintParam(item.name, item.testVal)
0000000000000000000000000000000000000000;;			if e, a := item.expectStr, r.URL().String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnacceptableParamNames(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;			testVal       string
0000000000000000000000000000000000000000;;			expectSuccess bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"timeout", "42", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			c := testRESTClient(t, nil)
0000000000000000000000000000000000000000;;			r := c.Get().setParam(item.name, item.testVal)
0000000000000000000000000000000000000000;;			if e, a := item.expectSuccess, r.err == nil; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("expected %v, got %v (%v)", e, a, r.err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBody(t *testing.T) {
0000000000000000000000000000000000000000;;		const data = "test payload"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		bodyExpected, _ := runtime.Encode(scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion), obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "test_body")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("TempFile error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := f.WriteString(data); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("TempFile.WriteString error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;		defer os.Remove(f.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var nilObject *v1.DeleteOptions
0000000000000000000000000000000000000000;;		typedObject := interface{}(nilObject)
0000000000000000000000000000000000000000;;		c := testRESTClient(t, nil)
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input    interface{}
0000000000000000000000000000000000000000;;			expected string
0000000000000000000000000000000000000000;;			headers  map[string]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]byte(data), data, nil},
0000000000000000000000000000000000000000;;			{f.Name(), data, nil},
0000000000000000000000000000000000000000;;			{strings.NewReader(data), data, nil},
0000000000000000000000000000000000000000;;			{obj, string(bodyExpected), map[string]string{"Content-Type": "application/json"}},
0000000000000000000000000000000000000000;;			{typedObject, "", nil},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			r := c.Post().Body(tt.input)
0000000000000000000000000000000000000000;;			if r.err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: r.Body(%#v) error: %v", i, tt, r.err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tt.headers != nil {
0000000000000000000000000000000000000000;;				for k, v := range tt.headers {
0000000000000000000000000000000000000000;;					if r.headers.Get(k) != v {
0000000000000000000000000000000000000000;;						t.Errorf("%d: r.headers[%q] = %q; want %q", i, k, v, v)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.body == nil {
0000000000000000000000000000000000000000;;				if len(tt.expected) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%d: r.body = %q; want %q", i, r.body, tt.expected)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := make([]byte, len(tt.expected))
0000000000000000000000000000000000000000;;			if _, err := r.body.Read(buf); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: r.body.Read error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body := string(buf)
0000000000000000000000000000000000000000;;			if body != tt.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%d: r.body = %q; want %q", i, body, tt.expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		var table = []struct {
0000000000000000000000000000000000000000;;			t   watch.EventType
0000000000000000000000000000000000000000;;			obj runtime.Object
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{watch.Added, &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "first"}}},
0000000000000000000000000000000000000000;;			{watch.Modified, &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "second"}}},
0000000000000000000000000000000000000000;;			{watch.Deleted, &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "last"}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			flusher, ok := w.(http.Flusher)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				panic("need flusher!")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Header().Set("Transfer-Encoding", "chunked")
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			flusher.Flush()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			encoder := restclientwatch.NewEncoder(streaming.NewEncoder(w, scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion)), scheme.Codecs.LegacyCodec(v1.SchemeGroupVersion))
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				if err := encoder.Encode(&watch.Event{Type: item.t, Object: item.obj}); err != nil {
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				flusher.Flush()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		watching, err := s.Get().Prefix("path/to/watch/thing").Watch()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			got, ok := <-watching.ResultChan()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected early close")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.t, got.Type; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.obj, got.Object; !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, ok := <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			t.Fatal("Unexpected non-close")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStream(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedBody := "expected body"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			flusher, ok := w.(http.Flusher)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				panic("need flusher!")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Transfer-Encoding", "chunked")
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			w.Write([]byte(expectedBody))
0000000000000000000000000000000000000000;;			flusher.Flush()
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		readCloser, err := s.Get().Prefix("path/to/stream/thing").Stream()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readCloser.Close()
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		buf.ReadFrom(readCloser)
0000000000000000000000000000000000000000;;		resultBody := buf.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectedBody != resultBody {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s, got %s", expectedBody, resultBody)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRESTClient(t testing.TB, srv *httptest.Server) *RESTClient {
0000000000000000000000000000000000000000;;		baseURL, _ := url.Parse("http://localhost")
0000000000000000000000000000000000000000;;		if srv != nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			baseURL, err = url.Parse(srv.URL)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("failed to parse test URL: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionedAPIPath := defaultResourcePathWithPrefix("", "", "", "")
0000000000000000000000000000000000000000;;		client, err := NewRESTClient(baseURL, versionedAPIPath, defaultContentConfig(), 0, 0, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create a client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDoContext(t *testing.T) {
0000000000000000000000000000000000000000;;		receivedCh := make(chan struct{})
0000000000000000000000000000000000000000;;		block := make(chan struct{})
0000000000000000000000000000000000000000;;		testServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			close(receivedCh)
0000000000000000000000000000000000000000;;			<-block
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer testServer.Close()
0000000000000000000000000000000000000000;;		defer close(block)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-receivedCh
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := testRESTClient(t, testServer)
0000000000000000000000000000000000000000;;		_, err := c.Verb("GET").
0000000000000000000000000000000000000000;;			Context(ctx).
0000000000000000000000000000000000000000;;			Prefix("foo").
0000000000000000000000000000000000000000;;			DoRaw()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("Expected context cancellation error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultResourcePathWithPrefix(prefix, resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		var path string
0000000000000000000000000000000000000000;;		path = "/api/" + v1.SchemeGroupVersion.Version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if prefix != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + prefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if namespace != "" {
0000000000000000000000000000000000000000;;			path = path + "/namespaces/" + namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Resource names are lower case.
0000000000000000000000000000000000000000;;		resource = strings.ToLower(resource)
0000000000000000000000000000000000000000;;		if resource != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
