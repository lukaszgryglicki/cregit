0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/request.go[staging/src/k8s.io/client-go/1.4/rest/request.go][staging/src/k8s.io/client-go/rest/request.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/streaming"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		restclientwatch "k8s.io/client-go/rest/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/metrics"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// specialParams lists parameters that are handled specially and which users of Request
0000000000000000000000000000000000000000;;		// are therefore not allowed to set manually.
0000000000000000000000000000000000000000;;		specialParams = sets.NewString("timeout")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// longThrottleLatency defines threshold for logging requests. All requests being
0000000000000000000000000000000000000000;;		// throttle for more than longThrottleLatency will be logged.
0000000000000000000000000000000000000000;;		longThrottleLatency = 50 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPClient is an interface for testing a request object.
0000000000000000000000000000000000000000;;	type HTTPClient interface {
0000000000000000000000000000000000000000;;		Do(req *http.Request) (*http.Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResponseWrapper is an interface for getting a response.
0000000000000000000000000000000000000000;;	// The response may be either accessed as a raw data (the whole output is put into memory) or as a stream.
0000000000000000000000000000000000000000;;	type ResponseWrapper interface {
0000000000000000000000000000000000000000;;		DoRaw() ([]byte, error)
0000000000000000000000000000000000000000;;		Stream() (io.ReadCloser, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestConstructionError is returned when there's an error assembling a request.
0000000000000000000000000000000000000000;;	type RequestConstructionError struct {
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns a textual description of 'r'.
0000000000000000000000000000000000000000;;	func (r *RequestConstructionError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("request construction error: '%v'", r.Err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Request allows for building up a request to a server in a chained fashion.
0000000000000000000000000000000000000000;;	// Any errors are stored until the end of your call, so you only have to
0000000000000000000000000000000000000000;;	// check once.
0000000000000000000000000000000000000000;;	type Request struct {
0000000000000000000000000000000000000000;;		// required
0000000000000000000000000000000000000000;;		client HTTPClient
0000000000000000000000000000000000000000;;		verb   string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		baseURL     *url.URL
0000000000000000000000000000000000000000;;		content     ContentConfig
0000000000000000000000000000000000000000;;		serializers Serializers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// generic components accessible via method setters
0000000000000000000000000000000000000000;;		pathPrefix string
0000000000000000000000000000000000000000;;		subpath    string
0000000000000000000000000000000000000000;;		params     url.Values
0000000000000000000000000000000000000000;;		headers    http.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// structural elements of the request that are part of the Kubernetes API conventions
0000000000000000000000000000000000000000;;		namespace    string
0000000000000000000000000000000000000000;;		namespaceSet bool
0000000000000000000000000000000000000000;;		resource     string
0000000000000000000000000000000000000000;;		resourceName string
0000000000000000000000000000000000000000;;		subresource  string
0000000000000000000000000000000000000000;;		timeout      time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// output
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;		body io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is only used for per-request timeouts, deadlines, and cancellations.
0000000000000000000000000000000000000000;;		ctx context.Context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backoffMgr BackoffManager
0000000000000000000000000000000000000000;;		throttle   flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRequest creates a new request helper object for accessing runtime.Objects on a server.
0000000000000000000000000000000000000000;;	func NewRequest(client HTTPClient, verb string, baseURL *url.URL, versionedAPIPath string, content ContentConfig, serializers Serializers, backoff BackoffManager, throttle flowcontrol.RateLimiter) *Request {
0000000000000000000000000000000000000000;;		if backoff == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Not implementing request backoff strategy.")
0000000000000000000000000000000000000000;;			backoff = &NoBackoff{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pathPrefix := "/"
0000000000000000000000000000000000000000;;		if baseURL != nil {
0000000000000000000000000000000000000000;;			pathPrefix = path.Join(pathPrefix, baseURL.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := &Request{
0000000000000000000000000000000000000000;;			client:      client,
0000000000000000000000000000000000000000;;			verb:        verb,
0000000000000000000000000000000000000000;;			baseURL:     baseURL,
0000000000000000000000000000000000000000;;			pathPrefix:  path.Join(pathPrefix, versionedAPIPath),
0000000000000000000000000000000000000000;;			content:     content,
0000000000000000000000000000000000000000;;			serializers: serializers,
0000000000000000000000000000000000000000;;			backoffMgr:  backoff,
0000000000000000000000000000000000000000;;			throttle:    throttle,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(content.AcceptContentTypes) > 0:
0000000000000000000000000000000000000000;;			r.SetHeader("Accept", content.AcceptContentTypes)
0000000000000000000000000000000000000000;;		case len(content.ContentType) > 0:
0000000000000000000000000000000000000000;;			r.SetHeader("Accept", content.ContentType+", */*")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prefix adds segments to the relative beginning to the request path. These
0000000000000000000000000000000000000000;;	// items will be placed before the optional Namespace, Resource, or Name sections.
0000000000000000000000000000000000000000;;	// Setting AbsPath will clear any previously set Prefix segments
0000000000000000000000000000000000000000;;	func (r *Request) Prefix(segments ...string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.pathPrefix = path.Join(r.pathPrefix, path.Join(segments...))
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Suffix appends segments to the end of the path. These items will be placed after the prefix and optional
0000000000000000000000000000000000000000;;	// Namespace, Resource, or Name sections.
0000000000000000000000000000000000000000;;	func (r *Request) Suffix(segments ...string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.subpath = path.Join(r.subpath, path.Join(segments...))
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resource sets the resource to access (<resource>/[ns/<namespace>/]<name>)
0000000000000000000000000000000000000000;;	func (r *Request) Resource(resource string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.resource) != 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("resource already set to %q, cannot change to %q", r.resource, resource)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msgs := IsValidPathSegmentName(resource); len(msgs) != 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("invalid resource %q: %v", resource, msgs)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.resource = resource
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubResource sets a sub-resource path which can be multiple segments segment after the resource
0000000000000000000000000000000000000000;;	// name but before the suffix.
0000000000000000000000000000000000000000;;	func (r *Request) SubResource(subresources ...string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		subresource := path.Join(subresources...)
0000000000000000000000000000000000000000;;		if len(r.subresource) != 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("subresource already set to %q, cannot change to %q", r.resource, subresource)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, s := range subresources {
0000000000000000000000000000000000000000;;			if msgs := IsValidPathSegmentName(s); len(msgs) != 0 {
0000000000000000000000000000000000000000;;				r.err = fmt.Errorf("invalid subresource %q: %v", s, msgs)
0000000000000000000000000000000000000000;;				return r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.subresource = subresource
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name sets the name of a resource to access (<resource>/[ns/<namespace>/]<name>)
0000000000000000000000000000000000000000;;	func (r *Request) Name(resourceName string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(resourceName) == 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("resource name may not be empty")
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.resourceName) != 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("resource name already set to %q, cannot change to %q", r.resourceName, resourceName)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msgs := IsValidPathSegmentName(resourceName); len(msgs) != 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("invalid resource name %q: %v", resourceName, msgs)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.resourceName = resourceName
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namespace applies the namespace scope to a request (<resource>/[ns/<namespace>/]<name>)
0000000000000000000000000000000000000000;;	func (r *Request) Namespace(namespace string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.namespaceSet {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("namespace already set to %q, cannot change to %q", r.namespace, namespace)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msgs := IsValidPathSegmentName(namespace); len(msgs) != 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("invalid namespace %q: %v", namespace, msgs)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.namespaceSet = true
0000000000000000000000000000000000000000;;		r.namespace = namespace
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceIfScoped is a convenience function to set a namespace if scoped is true
0000000000000000000000000000000000000000;;	func (r *Request) NamespaceIfScoped(namespace string, scoped bool) *Request {
0000000000000000000000000000000000000000;;		if scoped {
0000000000000000000000000000000000000000;;			return r.Namespace(namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AbsPath overwrites an existing path with the segments provided. Trailing slashes are preserved
0000000000000000000000000000000000000000;;	// when a single segment is passed.
0000000000000000000000000000000000000000;;	func (r *Request) AbsPath(segments ...string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.pathPrefix = path.Join(r.baseURL.Path, path.Join(segments...))
0000000000000000000000000000000000000000;;		if len(segments) == 1 && (len(r.baseURL.Path) > 1 || len(segments[0]) > 1) && strings.HasSuffix(segments[0], "/") {
0000000000000000000000000000000000000000;;			// preserve any trailing slashes for legacy behavior
0000000000000000000000000000000000000000;;			r.pathPrefix += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestURI overwrites existing path and parameters with the value of the provided server relative
0000000000000000000000000000000000000000;;	// URI. Some parameters (those in specialParameters) cannot be overwritten.
0000000000000000000000000000000000000000;;	func (r *Request) RequestURI(uri string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		locator, err := url.Parse(uri)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = err
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.pathPrefix = locator.Path
0000000000000000000000000000000000000000;;		if len(locator.Query()) > 0 {
0000000000000000000000000000000000000000;;			if r.params == nil {
0000000000000000000000000000000000000000;;				r.params = make(url.Values)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range locator.Query() {
0000000000000000000000000000000000000000;;				r.params[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// A constant that clients can use to refer in a field selector to the object name field.
0000000000000000000000000000000000000000;;		// Will be automatically emitted as the correct name for the API version.
0000000000000000000000000000000000000000;;		nodeUnschedulable = "spec.unschedulable"
0000000000000000000000000000000000000000;;		objectNameField   = "metadata.name"
0000000000000000000000000000000000000000;;		podHost           = "spec.nodeName"
0000000000000000000000000000000000000000;;		podStatus         = "status.phase"
0000000000000000000000000000000000000000;;		secretType        = "type"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventReason                  = "reason"
0000000000000000000000000000000000000000;;		eventSource                  = "source"
0000000000000000000000000000000000000000;;		eventType                    = "type"
0000000000000000000000000000000000000000;;		eventInvolvedKind            = "involvedObject.kind"
0000000000000000000000000000000000000000;;		eventInvolvedNamespace       = "involvedObject.namespace"
0000000000000000000000000000000000000000;;		eventInvolvedName            = "involvedObject.name"
0000000000000000000000000000000000000000;;		eventInvolvedUID             = "involvedObject.uid"
0000000000000000000000000000000000000000;;		eventInvolvedAPIVersion      = "involvedObject.apiVersion"
0000000000000000000000000000000000000000;;		eventInvolvedResourceVersion = "involvedObject.resourceVersion"
0000000000000000000000000000000000000000;;		eventInvolvedFieldPath       = "involvedObject.fieldPath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientFieldNameToAPIVersionFieldName map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c clientFieldNameToAPIVersionFieldName) filterField(field, value string) (newField, newValue string, err error) {
0000000000000000000000000000000000000000;;		newFieldName, ok := c[field]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("%v - %v - no field mapping defined", field, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newFieldName, value, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resourceTypeToFieldMapping map[string]clientFieldNameToAPIVersionFieldName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r resourceTypeToFieldMapping) filterField(resourceType, field, value string) (newField, newValue string, err error) {
0000000000000000000000000000000000000000;;		fMapping, ok := r[resourceType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("%v - %v - %v - no field mapping defined", resourceType, field, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fMapping.filterField(field, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type versionToResourceToFieldMapping map[schema.GroupVersion]resourceTypeToFieldMapping
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterField transforms the given field/value selector for the given groupVersion and resource
0000000000000000000000000000000000000000;;	func (v versionToResourceToFieldMapping) filterField(groupVersion *schema.GroupVersion, resourceType, field, value string) (newField, newValue string, err error) {
0000000000000000000000000000000000000000;;		rMapping, ok := v[*groupVersion]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// no groupVersion overrides registered, default to identity mapping
0000000000000000000000000000000000000000;;			return field, value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newField, newValue, err = rMapping.filterField(resourceType, field, value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// no groupVersionResource overrides registered, default to identity mapping
0000000000000000000000000000000000000000;;			return field, value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newField, newValue, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fieldMappings = versionToResourceToFieldMapping{
0000000000000000000000000000000000000000;;		v1.SchemeGroupVersion: resourceTypeToFieldMapping{
0000000000000000000000000000000000000000;;			"nodes": clientFieldNameToAPIVersionFieldName{
0000000000000000000000000000000000000000;;				objectNameField:   objectNameField,
0000000000000000000000000000000000000000;;				nodeUnschedulable: nodeUnschedulable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"pods": clientFieldNameToAPIVersionFieldName{
0000000000000000000000000000000000000000;;				objectNameField: objectNameField,
0000000000000000000000000000000000000000;;				podHost:         podHost,
0000000000000000000000000000000000000000;;				podStatus:       podStatus,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"secrets": clientFieldNameToAPIVersionFieldName{
0000000000000000000000000000000000000000;;				secretType: secretType,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"serviceAccounts": clientFieldNameToAPIVersionFieldName{
0000000000000000000000000000000000000000;;				objectNameField: objectNameField,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"endpoints": clientFieldNameToAPIVersionFieldName{
0000000000000000000000000000000000000000;;				objectNameField: objectNameField,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"events": clientFieldNameToAPIVersionFieldName{
0000000000000000000000000000000000000000;;				objectNameField:              objectNameField,
0000000000000000000000000000000000000000;;				eventReason:                  eventReason,
0000000000000000000000000000000000000000;;				eventSource:                  eventSource,
0000000000000000000000000000000000000000;;				eventType:                    eventType,
0000000000000000000000000000000000000000;;				eventInvolvedKind:            eventInvolvedKind,
0000000000000000000000000000000000000000;;				eventInvolvedNamespace:       eventInvolvedNamespace,
0000000000000000000000000000000000000000;;				eventInvolvedName:            eventInvolvedName,
0000000000000000000000000000000000000000;;				eventInvolvedUID:             eventInvolvedUID,
0000000000000000000000000000000000000000;;				eventInvolvedAPIVersion:      eventInvolvedAPIVersion,
0000000000000000000000000000000000000000;;				eventInvolvedResourceVersion: eventInvolvedResourceVersion,
0000000000000000000000000000000000000000;;				eventInvolvedFieldPath:       eventInvolvedFieldPath,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FieldsSelectorParam adds the given selector as a query parameter with the name paramName.
0000000000000000000000000000000000000000;;	func (r *Request) FieldsSelectorParam(s fields.Selector) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Empty() {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s2, err := s.Transform(func(field, value string) (newField, newValue string, err error) {
0000000000000000000000000000000000000000;;			return fieldMappings.filterField(r.content.GroupVersion, r.resource, field, value)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = err
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.setParam(metav1.FieldSelectorQueryParam(r.content.GroupVersion.String()), s2.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelsSelectorParam adds the given selector as a query parameter
0000000000000000000000000000000000000000;;	func (r *Request) LabelsSelectorParam(s labels.Selector) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Empty() {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.setParam(metav1.LabelSelectorQueryParam(r.content.GroupVersion.String()), s.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UintParam creates a query parameter with the given value.
0000000000000000000000000000000000000000;;	func (r *Request) UintParam(paramName string, u uint64) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.setParam(paramName, strconv.FormatUint(u, 10))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Param creates a query parameter with the given string value.
0000000000000000000000000000000000000000;;	func (r *Request) Param(paramName, s string) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.setParam(paramName, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VersionedParams will take the provided object, serialize it to a map[string][]string using the
0000000000000000000000000000000000000000;;	// implicit RESTClient API version and the default parameter codec, and then add those as parameters
0000000000000000000000000000000000000000;;	// to the request. Use this to provide versioned query parameters from client libraries.
0000000000000000000000000000000000000000;;	func (r *Request) VersionedParams(obj runtime.Object, codec runtime.ParameterCodec) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params, err := codec.EncodeParameters(obj, *r.content.GroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = err
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range params {
0000000000000000000000000000000000000000;;			for _, value := range v {
0000000000000000000000000000000000000000;;				// TODO: Move it to setParam method, once we get rid of
0000000000000000000000000000000000000000;;				// FieldSelectorParam & LabelSelectorParam methods.
0000000000000000000000000000000000000000;;				if k == metav1.LabelSelectorQueryParam(r.content.GroupVersion.String()) && value == "" {
0000000000000000000000000000000000000000;;					// Don't set an empty selector for backward compatibility.
0000000000000000000000000000000000000000;;					// Since there is no way to get the difference between empty
0000000000000000000000000000000000000000;;					// and unspecified string, we don't set it to avoid having
0000000000000000000000000000000000000000;;					// labelSelector= param in every request.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if k == metav1.FieldSelectorQueryParam(r.content.GroupVersion.String()) {
0000000000000000000000000000000000000000;;					if len(value) == 0 {
0000000000000000000000000000000000000000;;						// Don't set an empty selector for backward compatibility.
0000000000000000000000000000000000000000;;						// Since there is no way to get the difference between empty
0000000000000000000000000000000000000000;;						// and unspecified string, we don't set it to avoid having
0000000000000000000000000000000000000000;;						// fieldSelector= param in every request.
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// TODO: Filtering should be handled somewhere else.
0000000000000000000000000000000000000000;;					selector, err := fields.ParseSelector(value)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						r.err = fmt.Errorf("unparsable field selector: %v", err)
0000000000000000000000000000000000000000;;						return r
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					filteredSelector, err := selector.Transform(
0000000000000000000000000000000000000000;;						func(field, value string) (newField, newValue string, err error) {
0000000000000000000000000000000000000000;;							return fieldMappings.filterField(r.content.GroupVersion, r.resource, field, value)
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						r.err = fmt.Errorf("untransformable field selector: %v", err)
0000000000000000000000000000000000000000;;						return r
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					value = filteredSelector.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r.setParam(k, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Request) setParam(paramName, value string) *Request {
0000000000000000000000000000000000000000;;		if specialParams.Has(paramName) {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("must set %v through the corresponding function, not directly.", paramName)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.params == nil {
0000000000000000000000000000000000000000;;			r.params = make(url.Values)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.params[paramName] = append(r.params[paramName], value)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Request) SetHeader(key, value string) *Request {
0000000000000000000000000000000000000000;;		if r.headers == nil {
0000000000000000000000000000000000000000;;			r.headers = http.Header{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.headers.Set(key, value)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Timeout makes the request use the given duration as a timeout. Sets the "timeout"
0000000000000000000000000000000000000000;;	// parameter.
0000000000000000000000000000000000000000;;	func (r *Request) Timeout(d time.Duration) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.timeout = d
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Body makes the request use obj as the body. Optional.
0000000000000000000000000000000000000000;;	// If obj is a string, try to read a file of that name.
0000000000000000000000000000000000000000;;	// If obj is a []byte, send it directly.
0000000000000000000000000000000000000000;;	// If obj is an io.Reader, use it directly.
0000000000000000000000000000000000000000;;	// If obj is a runtime.Object, marshal it correctly, and set Content-Type header.
0000000000000000000000000000000000000000;;	// If obj is a runtime.Object and nil, do nothing.
0000000000000000000000000000000000000000;;	// Otherwise, set an error.
0000000000000000000000000000000000000000;;	func (r *Request) Body(obj interface{}) *Request {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadFile(t)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				r.err = err
0000000000000000000000000000000000000000;;				return r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glogBody("Request Body", data)
0000000000000000000000000000000000000000;;			r.body = bytes.NewReader(data)
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			glogBody("Request Body", t)
0000000000000000000000000000000000000000;;			r.body = bytes.NewReader(t)
0000000000000000000000000000000000000000;;		case io.Reader:
0000000000000000000000000000000000000000;;			r.body = t
0000000000000000000000000000000000000000;;		case runtime.Object:
0000000000000000000000000000000000000000;;			// callers may pass typed interface pointers, therefore we must check nil with reflection
0000000000000000000000000000000000000000;;			if reflect.ValueOf(t).IsNil() {
0000000000000000000000000000000000000000;;				return r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(r.serializers.Encoder, t)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				r.err = err
0000000000000000000000000000000000000000;;				return r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glogBody("Request Body", data)
0000000000000000000000000000000000000000;;			r.body = bytes.NewReader(data)
0000000000000000000000000000000000000000;;			r.SetHeader("Content-Type", r.content.ContentType)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("unknown type used for body: %+v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Context adds a context to the request. Contexts are only used for
0000000000000000000000000000000000000000;;	// timeouts, deadlines, and cancellations.
0000000000000000000000000000000000000000;;	func (r *Request) Context(ctx context.Context) *Request {
0000000000000000000000000000000000000000;;		r.ctx = ctx
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URL returns the current working URL.
0000000000000000000000000000000000000000;;	func (r *Request) URL() *url.URL {
0000000000000000000000000000000000000000;;		p := r.pathPrefix
0000000000000000000000000000000000000000;;		if r.namespaceSet && len(r.namespace) > 0 {
0000000000000000000000000000000000000000;;			p = path.Join(p, "namespaces", r.namespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.resource) != 0 {
0000000000000000000000000000000000000000;;			p = path.Join(p, strings.ToLower(r.resource))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Join trims trailing slashes, so preserve r.pathPrefix's trailing slash for backwards compatibility if nothing was changed
0000000000000000000000000000000000000000;;		if len(r.resourceName) != 0 || len(r.subpath) != 0 || len(r.subresource) != 0 {
0000000000000000000000000000000000000000;;			p = path.Join(p, r.resourceName, r.subresource, r.subpath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		finalURL := &url.URL{}
0000000000000000000000000000000000000000;;		if r.baseURL != nil {
0000000000000000000000000000000000000000;;			*finalURL = *r.baseURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		finalURL.Path = p
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		for key, values := range r.params {
0000000000000000000000000000000000000000;;			for _, value := range values {
0000000000000000000000000000000000000000;;				query.Add(key, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// timeout is handled specially here.
0000000000000000000000000000000000000000;;		if r.timeout != 0 {
0000000000000000000000000000000000000000;;			query.Set("timeout", r.timeout.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		finalURL.RawQuery = query.Encode()
0000000000000000000000000000000000000000;;		return finalURL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finalURLTemplate is similar to URL(), but will make all specific parameter values equal
0000000000000000000000000000000000000000;;	// - instead of name or namespace, "{name}" and "{namespace}" will be used, and all query
0000000000000000000000000000000000000000;;	// parameters will be reset. This creates a copy of the request so as not to change the
0000000000000000000000000000000000000000;;	// underyling object.  This means some useful request info (like the types of field
0000000000000000000000000000000000000000;;	// selectors in use) will be lost.
0000000000000000000000000000000000000000;;	// TODO: preserve field selector keys
0000000000000000000000000000000000000000;;	func (r Request) finalURLTemplate() url.URL {
0000000000000000000000000000000000000000;;		if len(r.resourceName) != 0 {
0000000000000000000000000000000000000000;;			r.resourceName = "{name}"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.namespaceSet && len(r.namespace) != 0 {
0000000000000000000000000000000000000000;;			r.namespace = "{namespace}"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newParams := url.Values{}
0000000000000000000000000000000000000000;;		v := []string{"{value}"}
0000000000000000000000000000000000000000;;		for k := range r.params {
0000000000000000000000000000000000000000;;			newParams[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.params = newParams
0000000000000000000000000000000000000000;;		url := r.URL()
0000000000000000000000000000000000000000;;		return *url
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Request) tryThrottle() {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		if r.throttle != nil {
0000000000000000000000000000000000000000;;			r.throttle.Accept()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if latency := time.Since(now); latency > longThrottleLatency {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Throttling request took %v, request: %s:%s", latency, r.verb, r.URL().String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch attempts to begin watching the requested location.
0000000000000000000000000000000000000000;;	// Returns a watch.Interface, or an error.
0000000000000000000000000000000000000000;;	func (r *Request) Watch() (watch.Interface, error) {
0000000000000000000000000000000000000000;;		// We specifically don't want to rate limit watches, so we
0000000000000000000000000000000000000000;;		// don't use r.throttle here.
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.serializers.Framer == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("watching resources is not possible with this client (content-type: %s)", r.content.ContentType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := r.URL().String()
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(r.verb, url, r.body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.ctx != nil {
0000000000000000000000000000000000000000;;			req = req.WithContext(r.ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header = r.headers
0000000000000000000000000000000000000000;;		client := r.client
0000000000000000000000000000000000000000;;		if client == nil {
0000000000000000000000000000000000000000;;			client = http.DefaultClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.backoffMgr.Sleep(r.backoffMgr.CalculateBackoff(r.URL()))
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		updateURLMetrics(r, resp, err)
0000000000000000000000000000000000000000;;		if r.baseURL != nil {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				r.backoffMgr.UpdateBackoff(r.baseURL, err, 0)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.backoffMgr.UpdateBackoff(r.baseURL, err, resp.StatusCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The watch stream mechanism handles many common partial data errors, so closed
0000000000000000000000000000000000000000;;			// connections can be retried in many cases.
0000000000000000000000000000000000000000;;			if net.IsProbableEOF(err) {
0000000000000000000000000000000000000000;;				return watch.NewEmptyWatch(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;			if result := r.transformResponse(resp, req); result.err != nil {
0000000000000000000000000000000000000000;;				return nil, result.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("for request '%+v', got status: %v", url, resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framer := r.serializers.Framer.NewFrameReader(resp.Body)
0000000000000000000000000000000000000000;;		decoder := streaming.NewDecoder(framer, r.serializers.StreamingSerializer)
0000000000000000000000000000000000000000;;		return watch.NewStreamWatcher(restclientwatch.NewDecoder(decoder, r.serializers.Decoder)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateURLMetrics is a convenience function for pushing metrics.
0000000000000000000000000000000000000000;;	// It also handles corner cases for incomplete/invalid request data.
0000000000000000000000000000000000000000;;	func updateURLMetrics(req *Request, resp *http.Response, err error) {
0000000000000000000000000000000000000000;;		url := "none"
0000000000000000000000000000000000000000;;		if req.baseURL != nil {
0000000000000000000000000000000000000000;;			url = req.baseURL.Host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Errors can be arbitrary strings. Unbound label cardinality is not suitable for a metric
0000000000000000000000000000000000000000;;		// system so we just report them as `<error>`.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			metrics.RequestResult.Increment("<error>", req.verb, url)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			//Metrics for failure codes
0000000000000000000000000000000000000000;;			metrics.RequestResult.Increment(strconv.Itoa(resp.StatusCode), req.verb, url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stream formats and executes the request, and offers streaming of the response.
0000000000000000000000000000000000000000;;	// Returns io.ReadCloser which could be used for streaming of the response, or an error
0000000000000000000000000000000000000000;;	// Any non-2xx http status code causes an error.  If we get a non-2xx code, we try to convert the body into an APIStatus object.
0000000000000000000000000000000000000000;;	// If we can, we return that as an error.  Otherwise, we create an error that lists the http status and the content of the response.
0000000000000000000000000000000000000000;;	func (r *Request) Stream() (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.tryThrottle()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := r.URL().String()
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(r.verb, url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.ctx != nil {
0000000000000000000000000000000000000000;;			req = req.WithContext(r.ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header = r.headers
0000000000000000000000000000000000000000;;		client := r.client
0000000000000000000000000000000000000000;;		if client == nil {
0000000000000000000000000000000000000000;;			client = http.DefaultClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.backoffMgr.Sleep(r.backoffMgr.CalculateBackoff(r.URL()))
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		updateURLMetrics(r, resp, err)
0000000000000000000000000000000000000000;;		if r.baseURL != nil {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				r.backoffMgr.UpdateBackoff(r.URL(), err, 0)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.backoffMgr.UpdateBackoff(r.URL(), err, resp.StatusCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case (resp.StatusCode >= 200) && (resp.StatusCode < 300):
0000000000000000000000000000000000000000;;			return resp.Body, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// ensure we close the body before returning the error
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result := r.transformResponse(resp, req)
0000000000000000000000000000000000000000;;			err := result.Error()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("%d while accessing %v: %s", result.statusCode, url, string(result.body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// request connects to the server and invokes the provided function when a server response is
0000000000000000000000000000000000000000;;	// received. It handles retry behavior and up front validation of requests. It will invoke
0000000000000000000000000000000000000000;;	// fn at most once. It will return an error if a problem occurred prior to connecting to the
0000000000000000000000000000000000000000;;	// server - the provided function is responsible for handling server errors.
0000000000000000000000000000000000000000;;	func (r *Request) request(fn func(*http.Request, *http.Response)) error {
0000000000000000000000000000000000000000;;		//Metrics for total request latency
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.RequestLatency.Observe(r.verb, r.finalURLTemplate(), time.Since(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Error in request: %v", r.err)
0000000000000000000000000000000000000000;;			return r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: added to catch programmer errors (invoking operations with an object with an empty namespace)
0000000000000000000000000000000000000000;;		if (r.verb == "GET" || r.verb == "PUT" || r.verb == "DELETE") && r.namespaceSet && len(r.resourceName) > 0 && len(r.namespace) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("an empty namespace may not be set when a resource name is provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (r.verb == "POST") && r.namespaceSet && len(r.namespace) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("an empty namespace may not be set during creation")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := r.client
0000000000000000000000000000000000000000;;		if client == nil {
0000000000000000000000000000000000000000;;			client = http.DefaultClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Right now we make about ten retry attempts if we get a Retry-After response.
0000000000000000000000000000000000000000;;		// TODO: Change to a timeout based approach.
0000000000000000000000000000000000000000;;		maxRetries := 10
0000000000000000000000000000000000000000;;		retries := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			url := r.URL().String()
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(r.verb, url, r.body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.ctx != nil {
0000000000000000000000000000000000000000;;				req = req.WithContext(r.ctx)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header = r.headers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.backoffMgr.Sleep(r.backoffMgr.CalculateBackoff(r.URL()))
0000000000000000000000000000000000000000;;			if retries > 0 {
0000000000000000000000000000000000000000;;				// We are retrying the request that we already send to apiserver
0000000000000000000000000000000000000000;;				// at least once before.
0000000000000000000000000000000000000000;;				// This request should also be throttled with the client-internal throttler.
0000000000000000000000000000000000000000;;				r.tryThrottle()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp, err := client.Do(req)
0000000000000000000000000000000000000000;;			updateURLMetrics(r, resp, err)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				r.backoffMgr.UpdateBackoff(r.URL(), err, 0)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.backoffMgr.UpdateBackoff(r.URL(), err, resp.StatusCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// "Connection reset by peer" is usually a transient error.
0000000000000000000000000000000000000000;;				// Thus in case of "GET" operations, we simply retry it.
0000000000000000000000000000000000000000;;				// We are not automatically retrying "write" operations, as
0000000000000000000000000000000000000000;;				// they are not idempotent.
0000000000000000000000000000000000000000;;				if !net.IsConnectionReset(err) || r.verb != "GET" {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// For the purpose of retry, we set the artificial "retry-after" response.
0000000000000000000000000000000000000000;;				// TODO: Should we clean the original response if it exists?
0000000000000000000000000000000000000000;;				resp = &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: http.StatusInternalServerError,
0000000000000000000000000000000000000000;;					Header:     http.Header{"Retry-After": []string{"1"}},
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader([]byte{})),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			done := func() bool {
0000000000000000000000000000000000000000;;				// Ensure the response body is fully read and closed
0000000000000000000000000000000000000000;;				// before we reconnect, so that we reuse the same TCP
0000000000000000000000000000000000000000;;				// connection.
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					const maxBodySlurpSize = 2 << 10
0000000000000000000000000000000000000000;;					if resp.ContentLength <= maxBodySlurpSize {
0000000000000000000000000000000000000000;;						io.Copy(ioutil.Discard, &io.LimitedReader{R: resp.Body, N: maxBodySlurpSize})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					resp.Body.Close()
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				retries++
0000000000000000000000000000000000000000;;				if seconds, wait := checkWait(resp); wait && retries < maxRetries {
0000000000000000000000000000000000000000;;					if seeker, ok := r.body.(io.Seeker); ok && r.body != nil {
0000000000000000000000000000000000000000;;						_, err := seeker.Seek(0, 0)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							glog.V(4).Infof("Could not retry request, can't Seek() back to beginning of body for %T", r.body)
0000000000000000000000000000000000000000;;							fn(req, resp)
0000000000000000000000000000000000000000;;							return true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Got a Retry-After %s response for attempt %d to %v", seconds, retries, url)
0000000000000000000000000000000000000000;;					r.backoffMgr.Sleep(time.Duration(seconds) * time.Second)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fn(req, resp)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			if done {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do formats and executes the request. Returns a Result object for easy response
0000000000000000000000000000000000000000;;	// processing.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Error type:
0000000000000000000000000000000000000000;;	//  * If the request can't be constructed, or an error happened earlier while building its
0000000000000000000000000000000000000000;;	//    arguments: *RequestConstructionError
0000000000000000000000000000000000000000;;	//  * If the server responds with a status: *errors.StatusError or *errors.UnexpectedObjectError
0000000000000000000000000000000000000000;;	//  * http.Client.Do errors are returned directly.
0000000000000000000000000000000000000000;;	func (r *Request) Do() Result {
0000000000000000000000000000000000000000;;		r.tryThrottle()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result Result
0000000000000000000000000000000000000000;;		err := r.request(func(req *http.Request, resp *http.Response) {
0000000000000000000000000000000000000000;;			result = r.transformResponse(resp, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Result{err: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoRaw executes the request but does not process the response body.
0000000000000000000000000000000000000000;;	func (r *Request) DoRaw() ([]byte, error) {
0000000000000000000000000000000000000000;;		r.tryThrottle()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result Result
0000000000000000000000000000000000000000;;		err := r.request(func(req *http.Request, resp *http.Response) {
0000000000000000000000000000000000000000;;			result.body, result.err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			glogBody("Response Body", result.body)
0000000000000000000000000000000000000000;;			if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusPartialContent {
0000000000000000000000000000000000000000;;				result.err = r.transformUnstructuredResponseError(resp, req, result.body)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.body, result.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transformResponse converts an API response into a structured API object
0000000000000000000000000000000000000000;;	func (r *Request) transformResponse(resp *http.Response, req *http.Request) Result {
0000000000000000000000000000000000000000;;		var body []byte
0000000000000000000000000000000000000000;;		if resp.Body != nil {
0000000000000000000000000000000000000000;;			if data, err := ioutil.ReadAll(resp.Body); err == nil {
0000000000000000000000000000000000000000;;				body = data
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glogBody("Response Body", body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify the content type is accurate
0000000000000000000000000000000000000000;;		contentType := resp.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;		decoder := r.serializers.Decoder
0000000000000000000000000000000000000000;;		if len(contentType) > 0 && (decoder == nil || (len(r.content.ContentType) > 0 && contentType != r.content.ContentType)) {
0000000000000000000000000000000000000000;;			mediaType, params, err := mime.ParseMediaType(contentType)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return Result{err: errors.NewInternalError(err)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			decoder, err = r.serializers.RenegotiatedDecoder(mediaType, params)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// if we fail to negotiate a decoder, treat this as an unstructured error
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case resp.StatusCode == http.StatusSwitchingProtocols:
0000000000000000000000000000000000000000;;					// no-op, we've been upgraded
0000000000000000000000000000000000000000;;				case resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusPartialContent:
0000000000000000000000000000000000000000;;					return Result{err: r.transformUnstructuredResponseError(resp, req, body)}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return Result{
0000000000000000000000000000000000000000;;					body:        body,
0000000000000000000000000000000000000000;;					contentType: contentType,
0000000000000000000000000000000000000000;;					statusCode:  resp.StatusCode,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case resp.StatusCode == http.StatusSwitchingProtocols:
0000000000000000000000000000000000000000;;			// no-op, we've been upgraded
0000000000000000000000000000000000000000;;		case resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusPartialContent:
0000000000000000000000000000000000000000;;			// calculate an unstructured error from the response which the Result object may use if the caller
0000000000000000000000000000000000000000;;			// did not return a structured error.
0000000000000000000000000000000000000000;;			retryAfter, _ := retryAfterSeconds(resp)
0000000000000000000000000000000000000000;;			err := r.newUnstructuredResponseError(body, isTextResponse(resp), resp.StatusCode, req.Method, retryAfter)
0000000000000000000000000000000000000000;;			return Result{
0000000000000000000000000000000000000000;;				body:        body,
0000000000000000000000000000000000000000;;				contentType: contentType,
0000000000000000000000000000000000000000;;				statusCode:  resp.StatusCode,
0000000000000000000000000000000000000000;;				decoder:     decoder,
0000000000000000000000000000000000000000;;				err:         err,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Result{
0000000000000000000000000000000000000000;;			body:        body,
0000000000000000000000000000000000000000;;			contentType: contentType,
0000000000000000000000000000000000000000;;			statusCode:  resp.StatusCode,
0000000000000000000000000000000000000000;;			decoder:     decoder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// glogBody logs a body output that could be either JSON or protobuf. It explicitly guards against
0000000000000000000000000000000000000000;;	// allocating a new string for the body output unless necessary. Uses a simple heuristic to determine
0000000000000000000000000000000000000000;;	// whether the body is printable.
0000000000000000000000000000000000000000;;	func glogBody(prefix string, body []byte) {
0000000000000000000000000000000000000000;;		if glog.V(8) {
0000000000000000000000000000000000000000;;			if bytes.IndexFunc(body, func(r rune) bool {
0000000000000000000000000000000000000000;;				return r < 0x0a
0000000000000000000000000000000000000000;;			}) != -1 {
0000000000000000000000000000000000000000;;				glog.Infof("%s:\n%s", prefix, hex.Dump(body))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("%s: %s", prefix, string(body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxUnstructuredResponseTextBytes is an upper bound on how much output to include in the unstructured error.
0000000000000000000000000000000000000000;;	const maxUnstructuredResponseTextBytes = 2048
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transformUnstructuredResponseError handles an error from the server that is not in a structured form.
0000000000000000000000000000000000000000;;	// It is expected to transform any response that is not recognizable as a clear server sent error from the
0000000000000000000000000000000000000000;;	// K8S API using the information provided with the request. In practice, HTTP proxies and client libraries
0000000000000000000000000000000000000000;;	// introduce a level of uncertainty to the responses returned by servers that in common use result in
0000000000000000000000000000000000000000;;	// unexpected responses. The rough structure is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. Assume the server sends you something sane - JSON + well defined error objects + proper codes
0000000000000000000000000000000000000000;;	//    - this is the happy path
0000000000000000000000000000000000000000;;	//    - when you get this output, trust what the server sends
0000000000000000000000000000000000000000;;	// 2. Guard against empty fields / bodies in received JSON and attempt to cull sufficient info from them to
0000000000000000000000000000000000000000;;	//    generate a reasonable facsimile of the original failure.
0000000000000000000000000000000000000000;;	//    - Be sure to use a distinct error type or flag that allows a client to distinguish between this and error 1 above
0000000000000000000000000000000000000000;;	// 3. Handle true disconnect failures / completely malformed data by moving up to a more generic client error
0000000000000000000000000000000000000000;;	// 4. Distinguish between various connection failures like SSL certificates, timeouts, proxy errors, unexpected
0000000000000000000000000000000000000000;;	//    initial contact, the presence of mismatched body contents from posted content types
0000000000000000000000000000000000000000;;	//    - Give these a separate distinct error type and capture as much as possible of the original message
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: introduce transformation of generic http.Client.Do() errors that separates 4.
0000000000000000000000000000000000000000;;	func (r *Request) transformUnstructuredResponseError(resp *http.Response, req *http.Request, body []byte) error {
0000000000000000000000000000000000000000;;		if body == nil && resp.Body != nil {
0000000000000000000000000000000000000000;;			if data, err := ioutil.ReadAll(&io.LimitedReader{R: resp.Body, N: maxUnstructuredResponseTextBytes}); err == nil {
0000000000000000000000000000000000000000;;				body = data
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		retryAfter, _ := retryAfterSeconds(resp)
0000000000000000000000000000000000000000;;		return r.newUnstructuredResponseError(body, isTextResponse(resp), resp.StatusCode, req.Method, retryAfter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newUnstructuredResponseError instantiates the appropriate generic error for the provided input. It also logs the body.
0000000000000000000000000000000000000000;;	func (r *Request) newUnstructuredResponseError(body []byte, isTextResponse bool, statusCode int, method string, retryAfter int) error {
0000000000000000000000000000000000000000;;		// cap the amount of output we create
0000000000000000000000000000000000000000;;		if len(body) > maxUnstructuredResponseTextBytes {
0000000000000000000000000000000000000000;;			body = body[:maxUnstructuredResponseTextBytes]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		message := "unknown"
0000000000000000000000000000000000000000;;		if isTextResponse {
0000000000000000000000000000000000000000;;			message = strings.TrimSpace(string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var groupResource schema.GroupResource
0000000000000000000000000000000000000000;;		if len(r.resource) > 0 {
0000000000000000000000000000000000000000;;			groupResource.Group = r.content.GroupVersion.Group
0000000000000000000000000000000000000000;;			groupResource.Resource = r.resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.NewGenericServerResponse(
0000000000000000000000000000000000000000;;			statusCode,
0000000000000000000000000000000000000000;;			method,
0000000000000000000000000000000000000000;;			groupResource,
0000000000000000000000000000000000000000;;			r.resourceName,
0000000000000000000000000000000000000000;;			message,
0000000000000000000000000000000000000000;;			retryAfter,
0000000000000000000000000000000000000000;;			true,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTextResponse returns true if the response appears to be a textual media type.
0000000000000000000000000000000000000000;;	func isTextResponse(resp *http.Response) bool {
0000000000000000000000000000000000000000;;		contentType := resp.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;		if len(contentType) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		media, _, err := mime.ParseMediaType(contentType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.HasPrefix(media, "text/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkWait returns true along with a number of seconds if the server instructed us to wait
0000000000000000000000000000000000000000;;	// before retrying.
0000000000000000000000000000000000000000;;	func checkWait(resp *http.Response) (int, bool) {
0000000000000000000000000000000000000000;;		switch r := resp.StatusCode; {
0000000000000000000000000000000000000000;;		// any 500 error code and 429 can trigger a wait
0000000000000000000000000000000000000000;;		case r == errors.StatusTooManyRequests, r >= 500:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, ok := retryAfterSeconds(resp)
0000000000000000000000000000000000000000;;		return i, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// retryAfterSeconds returns the value of the Retry-After header and true, or 0 and false if
0000000000000000000000000000000000000000;;	// the header was missing or not a valid number.
0000000000000000000000000000000000000000;;	func retryAfterSeconds(resp *http.Response) (int, bool) {
0000000000000000000000000000000000000000;;		if h := resp.Header.Get("Retry-After"); len(h) > 0 {
0000000000000000000000000000000000000000;;			if i, err := strconv.Atoi(h); err == nil {
0000000000000000000000000000000000000000;;				return i, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Result contains the result of calling Request.Do().
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		body        []byte
0000000000000000000000000000000000000000;;		contentType string
0000000000000000000000000000000000000000;;		err         error
0000000000000000000000000000000000000000;;		statusCode  int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder runtime.Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw returns the raw result.
0000000000000000000000000000000000000000;;	func (r Result) Raw() ([]byte, error) {
0000000000000000000000000000000000000000;;		return r.body, r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the result as an object, which means it passes through the decoder.
0000000000000000000000000000000000000000;;	// If the returned object is of type Status and has .Status != StatusSuccess, the
0000000000000000000000000000000000000000;;	// additional information in Status will be used to enrich the error.
0000000000000000000000000000000000000000;;	func (r Result) Get() (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			// Check whether the result has a Status object in the body and prefer that.
0000000000000000000000000000000000000000;;			return nil, r.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.decoder == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("serializer for %s doesn't exist", r.contentType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// decode, but if the result is Status return that as an error instead.
0000000000000000000000000000000000000000;;		out, _, err := r.decoder.Decode(r.body, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := out.(type) {
0000000000000000000000000000000000000000;;		case *metav1.Status:
0000000000000000000000000000000000000000;;			// any status besides StatusSuccess is considered an error.
0000000000000000000000000000000000000000;;			if t.Status != metav1.StatusSuccess {
0000000000000000000000000000000000000000;;				return nil, errors.FromObject(t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusCode returns the HTTP status code of the request. (Only valid if no
0000000000000000000000000000000000000000;;	// error was returned.)
0000000000000000000000000000000000000000;;	func (r Result) StatusCode(statusCode *int) Result {
0000000000000000000000000000000000000000;;		*statusCode = r.statusCode
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Into stores the result into obj, if possible. If obj is nil it is ignored.
0000000000000000000000000000000000000000;;	// If the returned object is of type Status and has .Status != StatusSuccess, the
0000000000000000000000000000000000000000;;	// additional information in Status will be used to enrich the error.
0000000000000000000000000000000000000000;;	func (r Result) Into(obj runtime.Object) error {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			// Check whether the result has a Status object in the body and prefer that.
0000000000000000000000000000000000000000;;			return r.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.decoder == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("serializer for %s doesn't exist", r.contentType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.body) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("0-length response")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, _, err := r.decoder.Decode(r.body, nil, obj)
0000000000000000000000000000000000000000;;		if err != nil || out == obj {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if a different object is returned, see if it is Status and avoid double decoding
0000000000000000000000000000000000000000;;		// the object.
0000000000000000000000000000000000000000;;		switch t := out.(type) {
0000000000000000000000000000000000000000;;		case *metav1.Status:
0000000000000000000000000000000000000000;;			// any status besides StatusSuccess is considered an error.
0000000000000000000000000000000000000000;;			if t.Status != metav1.StatusSuccess {
0000000000000000000000000000000000000000;;				return errors.FromObject(t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WasCreated updates the provided bool pointer to whether the server returned
0000000000000000000000000000000000000000;;	// 201 created or a different response.
0000000000000000000000000000000000000000;;	func (r Result) WasCreated(wasCreated *bool) Result {
0000000000000000000000000000000000000000;;		*wasCreated = r.statusCode == http.StatusCreated
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the error executing the request, nil if no error occurred.
0000000000000000000000000000000000000000;;	// If the returned object is of type Status and has Status != StatusSuccess, the
0000000000000000000000000000000000000000;;	// additional information in Status will be used to enrich the error.
0000000000000000000000000000000000000000;;	// See the Request.Do() comment for what errors you might get.
0000000000000000000000000000000000000000;;	func (r Result) Error() error {
0000000000000000000000000000000000000000;;		// if we have received an unexpected server error, and we have a body and decoder, we can try to extract
0000000000000000000000000000000000000000;;		// a Status object.
0000000000000000000000000000000000000000;;		if r.err == nil || !errors.IsUnexpectedServerError(r.err) || len(r.body) == 0 || r.decoder == nil {
0000000000000000000000000000000000000000;;			return r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attempt to convert the body into a Status object
0000000000000000000000000000000000000000;;		// to be backwards compatible with old servers that do not return a version, default to "v1"
0000000000000000000000000000000000000000;;		out, _, err := r.decoder.Decode(r.body, &schema.GroupVersionKind{Version: "v1"}, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("body was not decodable (unable to check for Status): %v", err)
0000000000000000000000000000000000000000;;			return r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := out.(type) {
0000000000000000000000000000000000000000;;		case *metav1.Status:
0000000000000000000000000000000000000000;;			// because we default the kind, we *must* check for StatusFailure
0000000000000000000000000000000000000000;;			if t.Status == metav1.StatusFailure {
0000000000000000000000000000000000000000;;				return errors.FromObject(t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameMayNotBe specifies strings that cannot be used as names specified as path segments (like the REST API or etcd store)
0000000000000000000000000000000000000000;;	var NameMayNotBe = []string{".", ".."}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameMayNotContain specifies substrings that cannot be used in names specified as path segments (like the REST API or etcd store)
0000000000000000000000000000000000000000;;	var NameMayNotContain = []string{"/", "%"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidPathSegmentName validates the name can be safely encoded as a path segment
0000000000000000000000000000000000000000;;	func IsValidPathSegmentName(name string) []string {
0000000000000000000000000000000000000000;;		for _, illegalName := range NameMayNotBe {
0000000000000000000000000000000000000000;;			if name == illegalName {
0000000000000000000000000000000000000000;;				return []string{fmt.Sprintf(`may not be '%s'`, illegalName)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errors []string
0000000000000000000000000000000000000000;;		for _, illegalContent := range NameMayNotContain {
0000000000000000000000000000000000000000;;			if strings.Contains(name, illegalContent) {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Sprintf(`may not contain '%s'`, illegalContent))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidPathSegmentPrefix validates the name can be used as a prefix for a name which will be encoded as a path segment
0000000000000000000000000000000000000000;;	// It does not check for exact matches with disallowed names, since an arbitrary suffix might make the name valid
0000000000000000000000000000000000000000;;	func IsValidPathSegmentPrefix(name string) []string {
0000000000000000000000000000000000000000;;		var errors []string
0000000000000000000000000000000000000000;;		for _, illegalContent := range NameMayNotContain {
0000000000000000000000000000000000000000;;			if strings.Contains(name, illegalContent) {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Sprintf(`may not contain '%s'`, illegalContent))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePathSegmentName validates the name can be safely encoded as a path segment
0000000000000000000000000000000000000000;;	func ValidatePathSegmentName(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		if prefix {
0000000000000000000000000000000000000000;;			return IsValidPathSegmentPrefix(name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return IsValidPathSegmentName(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
