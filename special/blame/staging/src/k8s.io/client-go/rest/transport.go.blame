0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/transport.go[staging/src/k8s.io/client-go/1.4/rest/transport.go][staging/src/k8s.io/client-go/rest/transport.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/transport"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLSConfigFor returns a tls.Config that will provide the transport level security defined
0000000000000000000000000000000000000000;;	// by the provided Config. Will return nil if no transport level security is requested.
0000000000000000000000000000000000000000;;	func TLSConfigFor(config *Config) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		cfg, err := config.TransportConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return transport.TLSConfigFor(cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransportFor returns an http.RoundTripper that will provide the authentication
0000000000000000000000000000000000000000;;	// or transport level security defined by the provided Config. Will return the
0000000000000000000000000000000000000000;;	// default http.DefaultTransport if no special case behavior is needed.
0000000000000000000000000000000000000000;;	func TransportFor(config *Config) (http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		cfg, err := config.TransportConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return transport.New(cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPWrappersForConfig wraps a round tripper with any relevant layered behavior from the
0000000000000000000000000000000000000000;;	// config. Exposed to allow more clients that need HTTP-like behavior but then must hijack
0000000000000000000000000000000000000000;;	// the underlying connection (like WebSocket or HTTP2 clients). Pure HTTP clients should use
0000000000000000000000000000000000000000;;	// the higher level TransportFor or RESTClientFor methods.
0000000000000000000000000000000000000000;;	func HTTPWrappersForConfig(config *Config, rt http.RoundTripper) (http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		cfg, err := config.TransportConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return transport.HTTPWrappersForConfig(cfg, rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransportConfig converts a client config to an appropriate transport config.
0000000000000000000000000000000000000000;;	func (c *Config) TransportConfig() (*transport.Config, error) {
0000000000000000000000000000000000000000;;		wt := c.WrapTransport
0000000000000000000000000000000000000000;;		if c.AuthProvider != nil {
0000000000000000000000000000000000000000;;			provider, err := GetAuthProvider(c.Host, c.AuthProvider, c.AuthConfigPersister)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if wt != nil {
0000000000000000000000000000000000000000;;				previousWT := wt
0000000000000000000000000000000000000000;;				wt = func(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;					return provider.WrapTransport(previousWT(rt))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				wt = provider.WrapTransport
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &transport.Config{
0000000000000000000000000000000000000000;;			UserAgent:     c.UserAgent,
0000000000000000000000000000000000000000;;			Transport:     c.Transport,
0000000000000000000000000000000000000000;;			WrapTransport: wt,
0000000000000000000000000000000000000000;;			TLS: transport.TLSConfig{
0000000000000000000000000000000000000000;;				Insecure:   c.Insecure,
0000000000000000000000000000000000000000;;				ServerName: c.ServerName,
0000000000000000000000000000000000000000;;				CAFile:     c.CAFile,
0000000000000000000000000000000000000000;;				CAData:     c.CAData,
0000000000000000000000000000000000000000;;				CertFile:   c.CertFile,
0000000000000000000000000000000000000000;;				CertData:   c.CertData,
0000000000000000000000000000000000000000;;				KeyFile:    c.KeyFile,
0000000000000000000000000000000000000000;;				KeyData:    c.KeyData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Username:    c.Username,
0000000000000000000000000000000000000000;;			Password:    c.Password,
0000000000000000000000000000000000000000;;			BearerToken: c.BearerToken,
0000000000000000000000000000000000000000;;			Impersonate: transport.ImpersonationConfig{
0000000000000000000000000000000000000000;;				UserName: c.Impersonate.UserName,
0000000000000000000000000000000000000000;;				Groups:   c.Impersonate.Groups,
0000000000000000000000000000000000000000;;				Extra:    c.Impersonate.Extra,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
