0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/urlbackoff_test.go[staging/src/k8s.io/client-go/1.4/rest/urlbackoff_test.go][staging/src/k8s.io/client-go/rest/urlbackoff_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parse(raw string) *url.URL {
0000000000000000000000000000000000000000;;		theUrl, _ := url.Parse(raw)
0000000000000000000000000000000000000000;;		return theUrl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestURLBackoffFunctionalityCollisions(t *testing.T) {
0000000000000000000000000000000000000000;;		myBackoff := &URLBackoff{
0000000000000000000000000000000000000000;;			Backoff: flowcontrol.NewBackOff(1*time.Second, 60*time.Second),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add some noise and make sure backoff for a clean URL is zero.
0000000000000000000000000000000000000000;;		myBackoff.UpdateBackoff(parse("http://100.200.300.400:8080"), nil, 500)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		myBackoff.UpdateBackoff(parse("http://1.2.3.4:8080"), nil, 500)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if myBackoff.CalculateBackoff(parse("http://1.2.3.4:100")) > 0 {
0000000000000000000000000000000000000000;;			t.Errorf("URLs are colliding in the backoff map!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestURLBackoffFunctionality generally tests the URLBackoff wrapper.  We avoid duplicating tests from backoff and request.
0000000000000000000000000000000000000000;;	func TestURLBackoffFunctionality(t *testing.T) {
0000000000000000000000000000000000000000;;		myBackoff := &URLBackoff{
0000000000000000000000000000000000000000;;			Backoff: flowcontrol.NewBackOff(1*time.Second, 60*time.Second),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now test that backoff increases, then recovers.
0000000000000000000000000000000000000000;;		// 200 and 300 should both result in clearing the backoff.
0000000000000000000000000000000000000000;;		// all others like 429 should result in increased backoff.
0000000000000000000000000000000000000000;;		seconds := []int{0,
0000000000000000000000000000000000000000;;			1, 2, 4, 8, 0,
0000000000000000000000000000000000000000;;			1, 2}
0000000000000000000000000000000000000000;;		returnCodes := []int{
0000000000000000000000000000000000000000;;			429, 500, 501, 502, 300,
0000000000000000000000000000000000000000;;			500, 501, 502,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(seconds) != len(returnCodes) {
0000000000000000000000000000000000000000;;			t.Fatalf("responseCode to backoff arrays should be the same length... sanity check failed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, sec := range seconds {
0000000000000000000000000000000000000000;;			backoffSec := myBackoff.CalculateBackoff(parse("http://1.2.3.4:100"))
0000000000000000000000000000000000000000;;			if backoffSec < time.Duration(sec)*time.Second || backoffSec > time.Duration(sec+5)*time.Second {
0000000000000000000000000000000000000000;;				t.Errorf("Backoff out of range %v: %v %v", i, sec, backoffSec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			myBackoff.UpdateBackoff(parse("http://1.2.3.4:100/responseCodeForFuncTest"), nil, returnCodes[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if myBackoff.CalculateBackoff(parse("http://1.2.3.4:100")) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("The final return code %v should have resulted in a backoff ! ", returnCodes[7])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
