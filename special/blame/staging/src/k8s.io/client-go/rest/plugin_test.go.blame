0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/plugin_test.go[staging/src/k8s.io/client-go/1.4/rest/plugin_test.go][staging/src/k8s.io/client-go/rest/plugin_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthPluginWrapTransport(t *testing.T) {
0000000000000000000000000000000000000000;;		if err := RegisterAuthProviderPlugin("pluginA", pluginAProvider); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: failed to register pluginA: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := RegisterAuthProviderPlugin("pluginB", pluginBProvider); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: failed to register pluginB: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := RegisterAuthProviderPlugin("pluginFail", pluginFailProvider); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: failed to register pluginFail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			useWrapTransport bool
0000000000000000000000000000000000000000;;			plugin           string
0000000000000000000000000000000000000000;;			expectErr        bool
0000000000000000000000000000000000000000;;			expectPluginA    bool
0000000000000000000000000000000000000000;;			expectPluginB    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{false, "", false, false, false},
0000000000000000000000000000000000000000;;			{false, "pluginA", false, true, false},
0000000000000000000000000000000000000000;;			{false, "pluginB", false, false, true},
0000000000000000000000000000000000000000;;			{false, "pluginFail", true, false, false},
0000000000000000000000000000000000000000;;			{false, "pluginUnknown", true, false, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			c := Config{}
0000000000000000000000000000000000000000;;			if tc.useWrapTransport {
0000000000000000000000000000000000000000;;				// Specify an existing WrapTransport in the config to make sure that
0000000000000000000000000000000000000000;;				// plugins play nicely.
0000000000000000000000000000000000000000;;				c.WrapTransport = func(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;					return &wrapTransport{rt}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tc.plugin) != 0 {
0000000000000000000000000000000000000000;;				c.AuthProvider = &clientcmdapi.AuthProviderConfig{Name: tc.plugin}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tConfig, err := c.TransportConfig()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Unknown/bad plugins are expected to fail here.
0000000000000000000000000000000000000000;;				if !tc.expectErr {
0000000000000000000000000000000000000000;;					t.Errorf("%d. Did not expect errors loading Auth Plugin: %q. Got: %v", i, tc.plugin, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var fullyWrappedTransport http.RoundTripper
0000000000000000000000000000000000000000;;			fullyWrappedTransport = &emptyTransport{}
0000000000000000000000000000000000000000;;			if tConfig.WrapTransport != nil {
0000000000000000000000000000000000000000;;				fullyWrappedTransport = tConfig.WrapTransport(&emptyTransport{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res, err := fullyWrappedTransport.RoundTrip(&http.Request{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Unexpected error in RoundTrip: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hasWrapTransport := res.Header.Get("wrapTransport") == "Y"
0000000000000000000000000000000000000000;;			hasPluginA := res.Header.Get("pluginA") == "Y"
0000000000000000000000000000000000000000;;			hasPluginB := res.Header.Get("pluginB") == "Y"
0000000000000000000000000000000000000000;;			if hasWrapTransport != tc.useWrapTransport {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Expected Existing config.WrapTransport: %t; Got: %t", i, tc.useWrapTransport, hasWrapTransport)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasPluginA != tc.expectPluginA {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Expected Plugin A: %t; Got: %t", i, tc.expectPluginA, hasPluginA)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasPluginB != tc.expectPluginB {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Expected Plugin B: %t; Got: %t", i, tc.expectPluginB, hasPluginB)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthPluginPersist(t *testing.T) {
0000000000000000000000000000000000000000;;		// register pluginA by a different name so we don't collide across tests.
0000000000000000000000000000000000000000;;		if err := RegisterAuthProviderPlugin("pluginA2", pluginAProvider); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: failed to register pluginA: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := RegisterAuthProviderPlugin("pluginPersist", pluginPersistProvider); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: failed to register pluginPersist: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fooBarConfig := map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			plugin                       string
0000000000000000000000000000000000000000;;			startingConfig               map[string]string
0000000000000000000000000000000000000000;;			expectedConfigAfterLogin     map[string]string
0000000000000000000000000000000000000000;;			expectedConfigAfterRoundTrip map[string]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// non-persisting plugins should work fine without modifying config.
0000000000000000000000000000000000000000;;			{"pluginA2", map[string]string{}, map[string]string{}, map[string]string{}},
0000000000000000000000000000000000000000;;			{"pluginA2", fooBarConfig, fooBarConfig, fooBarConfig},
0000000000000000000000000000000000000000;;			// plugins that persist config should be able to persist when they want.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pluginPersist",
0000000000000000000000000000000000000000;;				map[string]string{},
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"login": "Y",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"login":      "Y",
0000000000000000000000000000000000000000;;					"roundTrips": "1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"pluginPersist",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"login":      "Y",
0000000000000000000000000000000000000000;;					"roundTrips": "123",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"login":      "Y",
0000000000000000000000000000000000000000;;					"roundTrips": "123",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"login":      "Y",
0000000000000000000000000000000000000000;;					"roundTrips": "124",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			cfg := &clientcmdapi.AuthProviderConfig{
0000000000000000000000000000000000000000;;				Name:   tc.plugin,
0000000000000000000000000000000000000000;;				Config: tc.startingConfig,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			persister := &inMemoryPersister{make(map[string]string)}
0000000000000000000000000000000000000000;;			persister.Persist(tc.startingConfig)
0000000000000000000000000000000000000000;;			plugin, err := GetAuthProvider("127.0.0.1", cfg, persister)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Unexpected error: failed to get plugin %q: %v", i, tc.plugin, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := plugin.Login(); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Unexpected error calling Login() w/ plugin %q: %v", i, tc.plugin, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make sure the plugin persisted what we expect after Login().
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(persister.savedConfig, tc.expectedConfigAfterLogin) {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Unexpected persisted config after calling %s.Login(): \nGot:\n%v\nExpected:\n%v",
0000000000000000000000000000000000000000;;					i, tc.plugin, persister.savedConfig, tc.expectedConfigAfterLogin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := plugin.WrapTransport(&emptyTransport{}).RoundTrip(&http.Request{}); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Unexpected error round-tripping w/ plugin %q: %v", i, tc.plugin, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make sure the plugin persisted what we expect after RoundTrip().
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(persister.savedConfig, tc.expectedConfigAfterRoundTrip) {
0000000000000000000000000000000000000000;;				t.Errorf("%d. Unexpected persisted config after calling %s.WrapTransport.RoundTrip(): \nGot:\n%v\nExpected:\n%v",
0000000000000000000000000000000000000000;;					i, tc.plugin, persister.savedConfig, tc.expectedConfigAfterLogin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// emptyTransport provides an empty http.Response with an initialized header
0000000000000000000000000000000000000000;;	// to allow wrapping RoundTrippers to set header values.
0000000000000000000000000000000000000000;;	type emptyTransport struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*emptyTransport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		res := &http.Response{
0000000000000000000000000000000000000000;;			Header: make(map[string][]string),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTransport sets "wrapTransport" = "Y" on the response.
0000000000000000000000000000000000000000;;	type wrapTransport struct {
0000000000000000000000000000000000000000;;		rt http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *wrapTransport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		res, err := w.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.Header.Add("wrapTransport", "Y")
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTransportA sets "pluginA" = "Y" on the response.
0000000000000000000000000000000000000000;;	type wrapTransportA struct {
0000000000000000000000000000000000000000;;		rt http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *wrapTransportA) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		res, err := w.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.Header.Add("pluginA", "Y")
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pluginA struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*pluginA) WrapTransport(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &wrapTransportA{rt}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*pluginA) Login() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pluginAProvider(string, map[string]string, AuthProviderConfigPersister) (AuthProvider, error) {
0000000000000000000000000000000000000000;;		return &pluginA{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTransportB sets "pluginB" = "Y" on the response.
0000000000000000000000000000000000000000;;	type wrapTransportB struct {
0000000000000000000000000000000000000000;;		rt http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *wrapTransportB) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		res, err := w.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.Header.Add("pluginB", "Y")
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pluginB struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*pluginB) WrapTransport(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &wrapTransportB{rt}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*pluginB) Login() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pluginBProvider(string, map[string]string, AuthProviderConfigPersister) (AuthProvider, error) {
0000000000000000000000000000000000000000;;		return &pluginB{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pluginFailProvider simulates a registered AuthPlugin that fails to load.
0000000000000000000000000000000000000000;;	func pluginFailProvider(string, map[string]string, AuthProviderConfigPersister) (AuthProvider, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Failed to load AuthProvider")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type inMemoryPersister struct {
0000000000000000000000000000000000000000;;		savedConfig map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *inMemoryPersister) Persist(config map[string]string) error {
0000000000000000000000000000000000000000;;		i.savedConfig = make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range config {
0000000000000000000000000000000000000000;;			i.savedConfig[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapTransportPersist increments the "roundTrips" entry from the config when
0000000000000000000000000000000000000000;;	// roundTrip is called.
0000000000000000000000000000000000000000;;	type wrapTransportPersist struct {
0000000000000000000000000000000000000000;;		rt        http.RoundTripper
0000000000000000000000000000000000000000;;		config    map[string]string
0000000000000000000000000000000000000000;;		persister AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *wrapTransportPersist) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		roundTrips := 0
0000000000000000000000000000000000000000;;		if rtVal, ok := w.config["roundTrips"]; ok {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			roundTrips, err = strconv.Atoi(rtVal)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		roundTrips++
0000000000000000000000000000000000000000;;		w.config["roundTrips"] = fmt.Sprintf("%d", roundTrips)
0000000000000000000000000000000000000000;;		if err := w.persister.Persist(w.config); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pluginPersist struct {
0000000000000000000000000000000000000000;;		config    map[string]string
0000000000000000000000000000000000000000;;		persister AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pluginPersist) WrapTransport(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &wrapTransportPersist{rt, p.config, p.persister}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Login sets the config entry "login" to "Y".
0000000000000000000000000000000000000000;;	func (p *pluginPersist) Login() error {
0000000000000000000000000000000000000000;;		p.config["login"] = "Y"
0000000000000000000000000000000000000000;;		p.persister.Persist(p.config)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pluginPersistProvider(_ string, config map[string]string, persister AuthProviderConfigPersister) (AuthProvider, error) {
0000000000000000000000000000000000000000;;		return &pluginPersist{config, persister}, nil
0000000000000000000000000000000000000000;;	}
