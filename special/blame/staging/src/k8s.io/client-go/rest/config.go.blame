0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/rest/config.go[staging/src/k8s.io/client-go/1.4/rest/config.go][staging/src/k8s.io/client-go/rest/config.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		gruntime "runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/pkg/version"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultQPS   float32 = 5.0
0000000000000000000000000000000000000000;;		DefaultBurst int     = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config holds the common attributes that can be passed to a Kubernetes client on
0000000000000000000000000000000000000000;;	// initialization.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// Host must be a host string, a host:port pair, or a URL to the base of the apiserver.
0000000000000000000000000000000000000000;;		// If a URL is given then the (optional) Path of that URL represents a prefix that must
0000000000000000000000000000000000000000;;		// be appended to all request URIs used to access the apiserver. This allows a frontend
0000000000000000000000000000000000000000;;		// proxy to easily relocate all of the apiserver endpoints.
0000000000000000000000000000000000000000;;		Host string
0000000000000000000000000000000000000000;;		// APIPath is a sub-path that points to an API root.
0000000000000000000000000000000000000000;;		APIPath string
0000000000000000000000000000000000000000;;		// Prefix is the sub path of the server. If not specified, the client will set
0000000000000000000000000000000000000000;;		// a default value.  Use "/" to indicate the server root should be used
0000000000000000000000000000000000000000;;		Prefix string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ContentConfig contains settings that affect how objects are transformed when
0000000000000000000000000000000000000000;;		// sent to the server.
0000000000000000000000000000000000000000;;		ContentConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Server requires Basic authentication
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;		Password string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Server requires Bearer authentication. This client will not attempt to use
0000000000000000000000000000000000000000;;		// refresh tokens for an OAuth2 flow.
0000000000000000000000000000000000000000;;		// TODO: demonstrate an OAuth2 compatible client.
0000000000000000000000000000000000000000;;		BearerToken string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Impersonate is the configuration that RESTClient will use for impersonation.
0000000000000000000000000000000000000000;;		Impersonate ImpersonationConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Server requires plugin-specified authentication.
0000000000000000000000000000000000000000;;		AuthProvider *clientcmdapi.AuthProviderConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Callback to persist config for AuthProvider.
0000000000000000000000000000000000000000;;		AuthConfigPersister AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSClientConfig contains settings to enable transport layer security
0000000000000000000000000000000000000000;;		TLSClientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserAgent is an optional field that specifies the caller of this request.
0000000000000000000000000000000000000000;;		UserAgent string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Transport may be used for custom HTTP behavior. This attribute may not
0000000000000000000000000000000000000000;;		// be specified with the TLS client certificate options. Use WrapTransport
0000000000000000000000000000000000000000;;		// for most client level operations.
0000000000000000000000000000000000000000;;		Transport http.RoundTripper
0000000000000000000000000000000000000000;;		// WrapTransport will be invoked for custom HTTP behavior after the underlying
0000000000000000000000000000000000000000;;		// transport is initialized (either the transport created from TLSClientConfig,
0000000000000000000000000000000000000000;;		// Transport, or http.DefaultTransport). The config may layer other RoundTrippers
0000000000000000000000000000000000000000;;		// on top of the returned RoundTripper.
0000000000000000000000000000000000000000;;		WrapTransport func(rt http.RoundTripper) http.RoundTripper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// QPS indicates the maximum QPS to the master from this client.
0000000000000000000000000000000000000000;;		// If it's zero, the created RESTClient will use DefaultQPS: 5
0000000000000000000000000000000000000000;;		QPS float32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum burst for throttle.
0000000000000000000000000000000000000000;;		// If it's zero, the created RESTClient will use DefaultBurst: 10.
0000000000000000000000000000000000000000;;		Burst int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rate limiter for limiting connections to the master from this client. If present overwrites QPS/Burst
0000000000000000000000000000000000000000;;		RateLimiter flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The maximum length of time to wait before giving up on a server request. A value of zero means no timeout.
0000000000000000000000000000000000000000;;		Timeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Version forces a specific version to be used (if registered)
0000000000000000000000000000000000000000;;		// Do we need this?
0000000000000000000000000000000000000000;;		// Version string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImpersonationConfig has all the available impersonation options
0000000000000000000000000000000000000000;;	type ImpersonationConfig struct {
0000000000000000000000000000000000000000;;		// UserName is the username to impersonate on each request.
0000000000000000000000000000000000000000;;		UserName string
0000000000000000000000000000000000000000;;		// Groups are the groups to impersonate on each request.
0000000000000000000000000000000000000000;;		Groups []string
0000000000000000000000000000000000000000;;		// Extra is a free-form field which can be used to link some authentication information
0000000000000000000000000000000000000000;;		// to authorization information.  This field allows you to impersonate it.
0000000000000000000000000000000000000000;;		Extra map[string][]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLSClientConfig contains settings to enable transport layer security
0000000000000000000000000000000000000000;;	type TLSClientConfig struct {
0000000000000000000000000000000000000000;;		// Server should be accessed without verifying the TLS certificate. For testing only.
0000000000000000000000000000000000000000;;		Insecure bool
0000000000000000000000000000000000000000;;		// ServerName is passed to the server for SNI and is used in the client to check server
0000000000000000000000000000000000000000;;		// ceritificates against. If ServerName is empty, the hostname used to contact the
0000000000000000000000000000000000000000;;		// server is used.
0000000000000000000000000000000000000000;;		ServerName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Server requires TLS client certificate authentication
0000000000000000000000000000000000000000;;		CertFile string
0000000000000000000000000000000000000000;;		// Server requires TLS client certificate authentication
0000000000000000000000000000000000000000;;		KeyFile string
0000000000000000000000000000000000000000;;		// Trusted root certificates for server
0000000000000000000000000000000000000000;;		CAFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CertData holds PEM-encoded bytes (typically read from a client certificate file).
0000000000000000000000000000000000000000;;		// CertData takes precedence over CertFile
0000000000000000000000000000000000000000;;		CertData []byte
0000000000000000000000000000000000000000;;		// KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
0000000000000000000000000000000000000000;;		// KeyData takes precedence over KeyFile
0000000000000000000000000000000000000000;;		KeyData []byte
0000000000000000000000000000000000000000;;		// CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
0000000000000000000000000000000000000000;;		// CAData takes precedence over CAFile
0000000000000000000000000000000000000000;;		CAData []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContentConfig struct {
0000000000000000000000000000000000000000;;		// AcceptContentTypes specifies the types the client will accept and is optional.
0000000000000000000000000000000000000000;;		// If not set, ContentType will be used to define the Accept header
0000000000000000000000000000000000000000;;		AcceptContentTypes string
0000000000000000000000000000000000000000;;		// ContentType specifies the wire format used to communicate with the server.
0000000000000000000000000000000000000000;;		// This value will be set as the Accept header on requests made to the server, and
0000000000000000000000000000000000000000;;		// as the default content type on any object sent to the server. If not set,
0000000000000000000000000000000000000000;;		// "application/json" is used.
0000000000000000000000000000000000000000;;		ContentType string
0000000000000000000000000000000000000000;;		// GroupVersion is the API version to talk to. Must be provided when initializing
0000000000000000000000000000000000000000;;		// a RESTClient directly. When initializing a Client, will be set with the default
0000000000000000000000000000000000000000;;		// code version.
0000000000000000000000000000000000000000;;		GroupVersion *schema.GroupVersion
0000000000000000000000000000000000000000;;		// NegotiatedSerializer is used for obtaining encoders and decoders for multiple
0000000000000000000000000000000000000000;;		// supported media types.
0000000000000000000000000000000000000000;;		NegotiatedSerializer runtime.NegotiatedSerializer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTClientFor returns a RESTClient that satisfies the requested attributes on a client Config
0000000000000000000000000000000000000000;;	// object. Note that a RESTClient may require fields that are optional when initializing a Client.
0000000000000000000000000000000000000000;;	// A RESTClient created by this method is generic - it expects to operate on an API that follows
0000000000000000000000000000000000000000;;	// the Kubernetes conventions, but may not be the Kubernetes API.
0000000000000000000000000000000000000000;;	func RESTClientFor(config *Config) (*RESTClient, error) {
0000000000000000000000000000000000000000;;		if config.GroupVersion == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("GroupVersion is required when initializing a RESTClient")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.NegotiatedSerializer == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("NegotiatedSerializer is required when initializing a RESTClient")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		qps := config.QPS
0000000000000000000000000000000000000000;;		if config.QPS == 0.0 {
0000000000000000000000000000000000000000;;			qps = DefaultQPS
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		burst := config.Burst
0000000000000000000000000000000000000000;;		if config.Burst == 0 {
0000000000000000000000000000000000000000;;			burst = DefaultBurst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		baseURL, versionedAPIPath, err := defaultServerUrlFor(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport, err := TransportFor(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var httpClient *http.Client
0000000000000000000000000000000000000000;;		if transport != http.DefaultTransport {
0000000000000000000000000000000000000000;;			httpClient = &http.Client{Transport: transport}
0000000000000000000000000000000000000000;;			if config.Timeout > 0 {
0000000000000000000000000000000000000000;;				httpClient.Timeout = config.Timeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewRESTClient(baseURL, versionedAPIPath, config.ContentConfig, qps, burst, config.RateLimiter, httpClient)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnversionedRESTClientFor is the same as RESTClientFor, except that it allows
0000000000000000000000000000000000000000;;	// the config.Version to be empty.
0000000000000000000000000000000000000000;;	func UnversionedRESTClientFor(config *Config) (*RESTClient, error) {
0000000000000000000000000000000000000000;;		if config.NegotiatedSerializer == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("NeogitatedSerializer is required when initializing a RESTClient")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		baseURL, versionedAPIPath, err := defaultServerUrlFor(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transport, err := TransportFor(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var httpClient *http.Client
0000000000000000000000000000000000000000;;		if transport != http.DefaultTransport {
0000000000000000000000000000000000000000;;			httpClient = &http.Client{Transport: transport}
0000000000000000000000000000000000000000;;			if config.Timeout > 0 {
0000000000000000000000000000000000000000;;				httpClient.Timeout = config.Timeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionConfig := config.ContentConfig
0000000000000000000000000000000000000000;;		if versionConfig.GroupVersion == nil {
0000000000000000000000000000000000000000;;			v := metav1.SchemeGroupVersion
0000000000000000000000000000000000000000;;			versionConfig.GroupVersion = &v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewRESTClient(baseURL, versionedAPIPath, versionConfig, config.QPS, config.Burst, config.RateLimiter, httpClient)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetKubernetesDefaults sets default values on the provided client config for accessing the
0000000000000000000000000000000000000000;;	// Kubernetes API or returns an error if any of the defaults are impossible or invalid.
0000000000000000000000000000000000000000;;	func SetKubernetesDefaults(config *Config) error {
0000000000000000000000000000000000000000;;		if len(config.UserAgent) == 0 {
0000000000000000000000000000000000000000;;			config.UserAgent = DefaultKubernetesUserAgent()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adjustCommit returns sufficient significant figures of the commit's git hash.
0000000000000000000000000000000000000000;;	func adjustCommit(c string) string {
0000000000000000000000000000000000000000;;		if len(c) == 0 {
0000000000000000000000000000000000000000;;			return "unknown"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c) > 7 {
0000000000000000000000000000000000000000;;			return c[:7]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adjustVersion strips "alpha", "beta", etc. from version in form
0000000000000000000000000000000000000000;;	// major.minor.patch-[alpha|beta|etc].
0000000000000000000000000000000000000000;;	func adjustVersion(v string) string {
0000000000000000000000000000000000000000;;		if len(v) == 0 {
0000000000000000000000000000000000000000;;			return "unknown"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seg := strings.SplitN(v, "-", 2)
0000000000000000000000000000000000000000;;		return seg[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adjustCommand returns the last component of the
0000000000000000000000000000000000000000;;	// OS-specific command path for use in User-Agent.
0000000000000000000000000000000000000000;;	func adjustCommand(p string) string {
0000000000000000000000000000000000000000;;		// Unlikely, but better than returning "".
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return "unknown"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Base(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildUserAgent builds a User-Agent string from given args.
0000000000000000000000000000000000000000;;	func buildUserAgent(command, version, os, arch, commit string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%s/%s (%s/%s) kubernetes/%s", command, version, os, arch, commit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultKubernetesUserAgent returns a User-Agent string built from static global vars.
0000000000000000000000000000000000000000;;	func DefaultKubernetesUserAgent() string {
0000000000000000000000000000000000000000;;		return buildUserAgent(
0000000000000000000000000000000000000000;;			adjustCommand(os.Args[0]),
0000000000000000000000000000000000000000;;			adjustVersion(version.Get().GitVersion),
0000000000000000000000000000000000000000;;			gruntime.GOOS,
0000000000000000000000000000000000000000;;			gruntime.GOARCH,
0000000000000000000000000000000000000000;;			adjustCommit(version.Get().GitCommit))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InClusterConfig returns a config object which uses the service account
0000000000000000000000000000000000000000;;	// kubernetes gives to pods. It's intended for clients that expect to be
0000000000000000000000000000000000000000;;	// running inside a pod running on kubernetes. It will return an error if
0000000000000000000000000000000000000000;;	// called from a process not running in a kubernetes environment.
0000000000000000000000000000000000000000;;	func InClusterConfig() (*Config, error) {
0000000000000000000000000000000000000000;;		host, port := os.Getenv("KUBERNETES_SERVICE_HOST"), os.Getenv("KUBERNETES_SERVICE_PORT")
0000000000000000000000000000000000000000;;		if len(host) == 0 || len(port) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to load in-cluster configuration, KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT must be defined")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/" + v1.ServiceAccountTokenKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsClientConfig := TLSClientConfig{}
0000000000000000000000000000000000000000;;		rootCAFile := "/var/run/secrets/kubernetes.io/serviceaccount/" + v1.ServiceAccountRootCAKey
0000000000000000000000000000000000000000;;		if _, err := certutil.NewPool(rootCAFile); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Expected to load root CA config from %s, but got err: %v", rootCAFile, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tlsClientConfig.CAFile = rootCAFile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Config{
0000000000000000000000000000000000000000;;			// TODO: switch to using cluster DNS.
0000000000000000000000000000000000000000;;			Host:            "https://" + net.JoinHostPort(host, port),
0000000000000000000000000000000000000000;;			BearerToken:     string(token),
0000000000000000000000000000000000000000;;			TLSClientConfig: tlsClientConfig,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConfigTransportTLS returns true if and only if the provided
0000000000000000000000000000000000000000;;	// config will result in a protected connection to the server when it
0000000000000000000000000000000000000000;;	// is passed to restclient.RESTClientFor().  Use to determine when to
0000000000000000000000000000000000000000;;	// send credentials over the wire.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: the Insecure flag is ignored when testing for this value, so MITM attacks are
0000000000000000000000000000000000000000;;	// still possible.
0000000000000000000000000000000000000000;;	func IsConfigTransportTLS(config Config) bool {
0000000000000000000000000000000000000000;;		baseURL, _, err := defaultServerUrlFor(&config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return baseURL.Scheme == "https"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadTLSFiles copies the data from the CertFile, KeyFile, and CAFile fields into the CertData,
0000000000000000000000000000000000000000;;	// KeyData, and CAFile fields, or returns an error. If no error is returned, all three fields are
0000000000000000000000000000000000000000;;	// either populated or were empty to start.
0000000000000000000000000000000000000000;;	func LoadTLSFiles(c *Config) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		c.CAData, err = dataFromSliceOrFile(c.CAData, c.CAFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.CertData, err = dataFromSliceOrFile(c.CertData, c.CertFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.KeyData, err = dataFromSliceOrFile(c.KeyData, c.KeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dataFromSliceOrFile returns data from the slice (if non-empty), or from the file,
0000000000000000000000000000000000000000;;	// or an error if an error occurred reading the file
0000000000000000000000000000000000000000;;	func dataFromSliceOrFile(data []byte, file string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(data) > 0 {
0000000000000000000000000000000000000000;;			return data, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(file) > 0 {
0000000000000000000000000000000000000000;;			fileData, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []byte{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fileData, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddUserAgent(config *Config, userAgent string) *Config {
0000000000000000000000000000000000000000;;		fullUserAgent := DefaultKubernetesUserAgent() + "/" + userAgent
0000000000000000000000000000000000000000;;		config.UserAgent = fullUserAgent
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnonymousClientConfig returns a copy of the given config with all user credentials (cert/key, bearer token, and username/password) removed
0000000000000000000000000000000000000000;;	func AnonymousClientConfig(config *Config) *Config {
0000000000000000000000000000000000000000;;		// copy only known safe fields
0000000000000000000000000000000000000000;;		return &Config{
0000000000000000000000000000000000000000;;			Host:          config.Host,
0000000000000000000000000000000000000000;;			APIPath:       config.APIPath,
0000000000000000000000000000000000000000;;			Prefix:        config.Prefix,
0000000000000000000000000000000000000000;;			ContentConfig: config.ContentConfig,
0000000000000000000000000000000000000000;;			TLSClientConfig: TLSClientConfig{
0000000000000000000000000000000000000000;;				Insecure:   config.Insecure,
0000000000000000000000000000000000000000;;				ServerName: config.ServerName,
0000000000000000000000000000000000000000;;				CAFile:     config.TLSClientConfig.CAFile,
0000000000000000000000000000000000000000;;				CAData:     config.TLSClientConfig.CAData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RateLimiter:   config.RateLimiter,
0000000000000000000000000000000000000000;;			UserAgent:     config.UserAgent,
0000000000000000000000000000000000000000;;			Transport:     config.Transport,
0000000000000000000000000000000000000000;;			WrapTransport: config.WrapTransport,
0000000000000000000000000000000000000000;;			QPS:           config.QPS,
0000000000000000000000000000000000000000;;			Burst:         config.Burst,
0000000000000000000000000000000000000000;;			Timeout:       config.Timeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
