0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5ee40a77562a993234ecf9608e26cf0424bbc20f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fuzz "github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsConfigTransportTLS(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Config       *Config
0000000000000000000000000000000000000000;;			TransportTLS bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Config:       &Config{},
0000000000000000000000000000000000000000;;				TransportTLS: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Config: &Config{
0000000000000000000000000000000000000000;;					Host: "https://localhost",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				TransportTLS: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Config: &Config{
0000000000000000000000000000000000000000;;					Host: "localhost",
0000000000000000000000000000000000000000;;					TLSClientConfig: TLSClientConfig{
0000000000000000000000000000000000000000;;						CertFile: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				TransportTLS: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Config: &Config{
0000000000000000000000000000000000000000;;					Host: "///:://localhost",
0000000000000000000000000000000000000000;;					TLSClientConfig: TLSClientConfig{
0000000000000000000000000000000000000000;;						CertFile: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				TransportTLS: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Config: &Config{
0000000000000000000000000000000000000000;;					Host: "1.2.3.4:567",
0000000000000000000000000000000000000000;;					TLSClientConfig: TLSClientConfig{
0000000000000000000000000000000000000000;;						Insecure: true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				TransportTLS: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			if err := SetKubernetesDefaults(testCase.Config); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("setting defaults failed for %#v: %v", testCase.Config, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			useTLS := IsConfigTransportTLS(*testCase.Config)
0000000000000000000000000000000000000000;;			if testCase.TransportTLS != useTLS {
0000000000000000000000000000000000000000;;				t.Errorf("expected %v for %#v", testCase.TransportTLS, testCase.Config)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetKubernetesDefaultsUserAgent(t *testing.T) {
0000000000000000000000000000000000000000;;		config := &Config{}
0000000000000000000000000000000000000000;;		if err := SetKubernetesDefaults(config); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(config.UserAgent, "kubernetes/") {
0000000000000000000000000000000000000000;;			t.Errorf("no user agent set: %#v", config)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdjustVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		assert.Equal("1.2.3", adjustVersion("1.2.3-alpha4"))
0000000000000000000000000000000000000000;;		assert.Equal("1.2.3", adjustVersion("1.2.3-alpha"))
0000000000000000000000000000000000000000;;		assert.Equal("1.2.3", adjustVersion("1.2.3"))
0000000000000000000000000000000000000000;;		assert.Equal("unknown", adjustVersion(""))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdjustCommit(t *testing.T) {
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		assert.Equal("1234567", adjustCommit("1234567890"))
0000000000000000000000000000000000000000;;		assert.Equal("123456", adjustCommit("123456"))
0000000000000000000000000000000000000000;;		assert.Equal("unknown", adjustCommit(""))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdjustCommand(t *testing.T) {
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;		assert.Equal("beans", adjustCommand(filepath.Join("home", "bob", "Downloads", "beans")))
0000000000000000000000000000000000000000;;		assert.Equal("beans", adjustCommand(filepath.Join(".", "beans")))
0000000000000000000000000000000000000000;;		assert.Equal("beans", adjustCommand("beans"))
0000000000000000000000000000000000000000;;		assert.Equal("unknown", adjustCommand(""))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBuildUserAgent(t *testing.T) {
0000000000000000000000000000000000000000;;		assert.New(t).Equal(
0000000000000000000000000000000000000000;;			"lynx/nicest (beos/itanium) kubernetes/baaaaaaaaad",
0000000000000000000000000000000000000000;;			buildUserAgent(
0000000000000000000000000000000000000000;;				"lynx", "nicest",
0000000000000000000000000000000000000000;;				"beos", "itanium", "baaaaaaaaad"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function untestable since it doesn't accept arguments.
0000000000000000000000000000000000000000;;	func TestDefaultKubernetesUserAgent(t *testing.T) {
0000000000000000000000000000000000000000;;		assert.New(t).Contains(DefaultKubernetesUserAgent(), "kubernetes")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTClientRequires(t *testing.T) {
0000000000000000000000000000000000000000;;		if _, err := RESTClientFor(&Config{Host: "127.0.0.1", ContentConfig: ContentConfig{NegotiatedSerializer: scheme.Codecs}}); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := RESTClientFor(&Config{Host: "127.0.0.1", ContentConfig: ContentConfig{GroupVersion: &v1.SchemeGroupVersion}}); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := RESTClientFor(&Config{Host: "127.0.0.1", ContentConfig: ContentConfig{GroupVersion: &v1.SchemeGroupVersion, NegotiatedSerializer: scheme.Codecs}}); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeLimiter struct {
0000000000000000000000000000000000000000;;		FakeSaturation float64
0000000000000000000000000000000000000000;;		FakeQPS        float32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeLimiter) TryAccept() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeLimiter) Saturation() float64 {
0000000000000000000000000000000000000000;;		return t.FakeSaturation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeLimiter) QPS() float32 {
0000000000000000000000000000000000000000;;		return t.FakeQPS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeLimiter) Stop() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeLimiter) Accept() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeCodec struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeCodec) Decode([]byte, *schema.GroupVersionKind, runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		return nil, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *fakeCodec) Encode(obj runtime.Object, stream io.Writer) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeRoundTripper struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *fakeRoundTripper) RoundTrip(*http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fakeWrapperFunc = func(http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &fakeRoundTripper{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeNegotiatedSerializer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *fakeNegotiatedSerializer) SupportedMediaTypes() []runtime.SerializerInfo {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *fakeNegotiatedSerializer) EncoderForVersion(serializer runtime.Encoder, gv runtime.GroupVersioner) runtime.Encoder {
0000000000000000000000000000000000000000;;		return &fakeCodec{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *fakeNegotiatedSerializer) DecoderToVersion(serializer runtime.Decoder, gv runtime.GroupVersioner) runtime.Decoder {
0000000000000000000000000000000000000000;;		return &fakeCodec{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAnonymousConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		f := fuzz.New().NilChance(0.0).NumElements(1, 1)
0000000000000000000000000000000000000000;;		f.Funcs(
0000000000000000000000000000000000000000;;			func(r *runtime.Codec, f fuzz.Continue) {
0000000000000000000000000000000000000000;;				codec := &fakeCodec{}
0000000000000000000000000000000000000000;;				f.Fuzz(codec)
0000000000000000000000000000000000000000;;				*r = codec
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(r *http.RoundTripper, f fuzz.Continue) {
0000000000000000000000000000000000000000;;				roundTripper := &fakeRoundTripper{}
0000000000000000000000000000000000000000;;				f.Fuzz(roundTripper)
0000000000000000000000000000000000000000;;				*r = roundTripper
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(fn *func(http.RoundTripper) http.RoundTripper, f fuzz.Continue) {
0000000000000000000000000000000000000000;;				*fn = fakeWrapperFunc
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(r *runtime.NegotiatedSerializer, f fuzz.Continue) {
0000000000000000000000000000000000000000;;				serializer := &fakeNegotiatedSerializer{}
0000000000000000000000000000000000000000;;				f.Fuzz(serializer)
0000000000000000000000000000000000000000;;				*r = serializer
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(r *flowcontrol.RateLimiter, f fuzz.Continue) {
0000000000000000000000000000000000000000;;				limiter := &fakeLimiter{}
0000000000000000000000000000000000000000;;				f.Fuzz(limiter)
0000000000000000000000000000000000000000;;				*r = limiter
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Authentication does not require fuzzer
0000000000000000000000000000000000000000;;			func(r *AuthProviderConfigPersister, f fuzz.Continue) {},
0000000000000000000000000000000000000000;;			func(r *clientcmdapi.AuthProviderConfig, f fuzz.Continue) {
0000000000000000000000000000000000000000;;				r.Config = map[string]string{}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for i := 0; i < 20; i++ {
0000000000000000000000000000000000000000;;			original := &Config{}
0000000000000000000000000000000000000000;;			f.Fuzz(original)
0000000000000000000000000000000000000000;;			actual := AnonymousClientConfig(original)
0000000000000000000000000000000000000000;;			expected := *original
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// this is the list of known security related fields, add to this list if a new field
0000000000000000000000000000000000000000;;			// is added to Config, update AnonymousClientConfig to preserve the field otherwise.
0000000000000000000000000000000000000000;;			expected.Impersonate = ImpersonationConfig{}
0000000000000000000000000000000000000000;;			expected.BearerToken = ""
0000000000000000000000000000000000000000;;			expected.Username = ""
0000000000000000000000000000000000000000;;			expected.Password = ""
0000000000000000000000000000000000000000;;			expected.AuthProvider = nil
0000000000000000000000000000000000000000;;			expected.AuthConfigPersister = nil
0000000000000000000000000000000000000000;;			expected.TLSClientConfig.CertData = nil
0000000000000000000000000000000000000000;;			expected.TLSClientConfig.CertFile = ""
0000000000000000000000000000000000000000;;			expected.TLSClientConfig.KeyData = nil
0000000000000000000000000000000000000000;;			expected.TLSClientConfig.KeyFile = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The DeepEqual cannot handle the func comparison, so we just verify if the
0000000000000000000000000000000000000000;;			// function return the expected object.
0000000000000000000000000000000000000000;;			if actual.WrapTransport == nil || !reflect.DeepEqual(expected.WrapTransport(nil), &fakeRoundTripper{}) {
0000000000000000000000000000000000000000;;				t.Fatalf("AnonymousClientConfig dropped the WrapTransport field")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				actual.WrapTransport = nil
0000000000000000000000000000000000000000;;				expected.WrapTransport = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(*actual, expected) {
0000000000000000000000000000000000000000;;				t.Fatalf("AnonymousClientConfig dropped unexpected fields, identify whether they are security related or not: %s", diff.ObjectGoPrintDiff(expected, actual))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
