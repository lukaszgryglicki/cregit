0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
53dd2db94a5f56ebf4809d36d9d0553a7a39a4f4;staging/src/k8s.io/client-go/1.4/kubernetes/typed/core/v1/event_expansion.go[staging/src/k8s.io/client-go/1.4/kubernetes/typed/core/v1/event_expansion.go][staging/src/k8s.io/client-go/kubernetes/typed/core/v1/event_expansion.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The EventExpansion interface allows manually adding extra methods to the EventInterface.
0000000000000000000000000000000000000000;;	type EventExpansion interface {
0000000000000000000000000000000000000000;;		// CreateWithEventNamespace is the same as a Create, except that it sends the request to the event.Namespace.
0000000000000000000000000000000000000000;;		CreateWithEventNamespace(event *v1.Event) (*v1.Event, error)
0000000000000000000000000000000000000000;;		// UpdateWithEventNamespace is the same as a Update, except that it sends the request to the event.Namespace.
0000000000000000000000000000000000000000;;		UpdateWithEventNamespace(event *v1.Event) (*v1.Event, error)
0000000000000000000000000000000000000000;;		PatchWithEventNamespace(event *v1.Event, data []byte) (*v1.Event, error)
0000000000000000000000000000000000000000;;		// Search finds events about the specified object
0000000000000000000000000000000000000000;;		Search(scheme *runtime.Scheme, objOrRef runtime.Object) (*v1.EventList, error)
0000000000000000000000000000000000000000;;		// Returns the appropriate field selector based on the API version being used to communicate with the server.
0000000000000000000000000000000000000000;;		// The returned field selector can be used with List and Watch to filter desired events.
0000000000000000000000000000000000000000;;		GetFieldSelector(involvedObjectName, involvedObjectNamespace, involvedObjectKind, involvedObjectUID *string) fields.Selector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateWithEventNamespace makes a new event. Returns the copy of the event the server returns,
0000000000000000000000000000000000000000;;	// or an error. The namespace to create the event within is deduced from the
0000000000000000000000000000000000000000;;	// event; it must either match this event client's namespace, or this event
0000000000000000000000000000000000000000;;	// client must have been created with the "" namespace.
0000000000000000000000000000000000000000;;	func (e *events) CreateWithEventNamespace(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		if e.ns != "" && event.Namespace != e.ns {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("can't create an event with namespace '%v' in namespace '%v'", event.Namespace, e.ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := &v1.Event{}
0000000000000000000000000000000000000000;;		err := e.client.Post().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(event.Namespace, len(event.Namespace) > 0).
0000000000000000000000000000000000000000;;			Resource("events").
0000000000000000000000000000000000000000;;			Body(event).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateWithEventNamespace modifies an existing event. It returns the copy of the event that the server returns,
0000000000000000000000000000000000000000;;	// or an error. The namespace and key to update the event within is deduced from the event. The
0000000000000000000000000000000000000000;;	// namespace must either match this event client's namespace, or this event client must have been
0000000000000000000000000000000000000000;;	// created with the "" namespace. Update also requires the ResourceVersion to be set in the event
0000000000000000000000000000000000000000;;	// object.
0000000000000000000000000000000000000000;;	func (e *events) UpdateWithEventNamespace(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		result := &v1.Event{}
0000000000000000000000000000000000000000;;		err := e.client.Put().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(event.Namespace, len(event.Namespace) > 0).
0000000000000000000000000000000000000000;;			Resource("events").
0000000000000000000000000000000000000000;;			Name(event.Name).
0000000000000000000000000000000000000000;;			Body(event).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PatchWithEventNamespace modifies an existing event. It returns the copy of
0000000000000000000000000000000000000000;;	// the event that the server returns, or an error. The namespace and name of the
0000000000000000000000000000000000000000;;	// target event is deduced from the incompleteEvent. The namespace must either
0000000000000000000000000000000000000000;;	// match this event client's namespace, or this event client must have been
0000000000000000000000000000000000000000;;	// created with the "" namespace.
0000000000000000000000000000000000000000;;	func (e *events) PatchWithEventNamespace(incompleteEvent *v1.Event, data []byte) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		if e.ns != "" && incompleteEvent.Namespace != e.ns {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("can't patch an event with namespace '%v' in namespace '%v'", incompleteEvent.Namespace, e.ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := &v1.Event{}
0000000000000000000000000000000000000000;;		err := e.client.Patch(types.StrategicMergePatchType).
0000000000000000000000000000000000000000;;			NamespaceIfScoped(incompleteEvent.Namespace, len(incompleteEvent.Namespace) > 0).
0000000000000000000000000000000000000000;;			Resource("events").
0000000000000000000000000000000000000000;;			Name(incompleteEvent.Name).
0000000000000000000000000000000000000000;;			Body(data).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Search finds events about the specified object. The namespace of the
0000000000000000000000000000000000000000;;	// object must match this event's client namespace unless the event client
0000000000000000000000000000000000000000;;	// was made with the "" namespace.
0000000000000000000000000000000000000000;;	func (e *events) Search(scheme *runtime.Scheme, objOrRef runtime.Object) (*v1.EventList, error) {
0000000000000000000000000000000000000000;;		ref, err := ref.GetReference(scheme, objOrRef)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.ns != "" && ref.Namespace != e.ns {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("won't be able to find any events of namespace '%v' in namespace '%v'", ref.Namespace, e.ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stringRefKind := string(ref.Kind)
0000000000000000000000000000000000000000;;		var refKind *string
0000000000000000000000000000000000000000;;		if stringRefKind != "" {
0000000000000000000000000000000000000000;;			refKind = &stringRefKind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stringRefUID := string(ref.UID)
0000000000000000000000000000000000000000;;		var refUID *string
0000000000000000000000000000000000000000;;		if stringRefUID != "" {
0000000000000000000000000000000000000000;;			refUID = &stringRefUID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fieldSelector := e.GetFieldSelector(&ref.Name, &ref.Namespace, refKind, refUID)
0000000000000000000000000000000000000000;;		return e.List(metav1.ListOptions{FieldSelector: fieldSelector.String()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the appropriate field selector based on the API version being used to communicate with the server.
0000000000000000000000000000000000000000;;	// The returned field selector can be used with List and Watch to filter desired events.
0000000000000000000000000000000000000000;;	func (e *events) GetFieldSelector(involvedObjectName, involvedObjectNamespace, involvedObjectKind, involvedObjectUID *string) fields.Selector {
0000000000000000000000000000000000000000;;		apiVersion := e.client.APIVersion().String()
0000000000000000000000000000000000000000;;		field := fields.Set{}
0000000000000000000000000000000000000000;;		if involvedObjectName != nil {
0000000000000000000000000000000000000000;;			field[GetInvolvedObjectNameFieldLabel(apiVersion)] = *involvedObjectName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if involvedObjectNamespace != nil {
0000000000000000000000000000000000000000;;			field["involvedObject.namespace"] = *involvedObjectNamespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if involvedObjectKind != nil {
0000000000000000000000000000000000000000;;			field["involvedObject.kind"] = *involvedObjectKind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if involvedObjectUID != nil {
0000000000000000000000000000000000000000;;			field["involvedObject.uid"] = *involvedObjectUID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return field.AsSelector()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the appropriate field label to use for name of the involved object as per the given API version.
0000000000000000000000000000000000000000;;	func GetInvolvedObjectNameFieldLabel(version string) string {
0000000000000000000000000000000000000000;;		return "involvedObject.name"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This is a temporary arrangement and will be removed once all clients are moved to use the clientset.
0000000000000000000000000000000000000000;;	type EventSinkImpl struct {
0000000000000000000000000000000000000000;;		Interface EventInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EventSinkImpl) Create(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		return e.Interface.CreateWithEventNamespace(event)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EventSinkImpl) Update(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		return e.Interface.UpdateWithEventNamespace(event)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EventSinkImpl) Patch(event *v1.Event, data []byte) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		return e.Interface.PatchWithEventNamespace(event, data)
0000000000000000000000000000000000000000;;	}
