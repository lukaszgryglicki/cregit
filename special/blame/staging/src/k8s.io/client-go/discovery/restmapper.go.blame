0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/discovery/restmapper.go[staging/src/k8s.io/client-go/1.4/discovery/restmapper.go][staging/src/k8s.io/client-go/discovery/restmapper.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package discovery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIGroupResources is an API group with a mapping of versions to
0000000000000000000000000000000000000000;;	// resources.
0000000000000000000000000000000000000000;;	type APIGroupResources struct {
0000000000000000000000000000000000000000;;		Group metav1.APIGroup
0000000000000000000000000000000000000000;;		// A mapping of version string to a slice of APIResources for
0000000000000000000000000000000000000000;;		// that version.
0000000000000000000000000000000000000000;;		VersionedResources map[string][]metav1.APIResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRESTMapper returns a PriorityRESTMapper based on the discovered
0000000000000000000000000000000000000000;;	// groups and resources passed in.
0000000000000000000000000000000000000000;;	func NewRESTMapper(groupResources []*APIGroupResources, versionInterfaces meta.VersionInterfacesFunc) meta.RESTMapper {
0000000000000000000000000000000000000000;;		unionMapper := meta.MultiRESTMapper{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var groupPriority []string
0000000000000000000000000000000000000000;;		// /v1 is special.  It should always come first
0000000000000000000000000000000000000000;;		resourcePriority := []schema.GroupVersionResource{{Group: "", Version: "v1", Resource: meta.AnyResource}}
0000000000000000000000000000000000000000;;		kindPriority := []schema.GroupVersionKind{{Group: "", Version: "v1", Kind: meta.AnyKind}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, group := range groupResources {
0000000000000000000000000000000000000000;;			groupPriority = append(groupPriority, group.Group.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(group.Group.PreferredVersion.Version) != 0 {
0000000000000000000000000000000000000000;;				preferred := group.Group.PreferredVersion.Version
0000000000000000000000000000000000000000;;				if _, ok := group.VersionedResources[preferred]; ok {
0000000000000000000000000000000000000000;;					resourcePriority = append(resourcePriority, schema.GroupVersionResource{
0000000000000000000000000000000000000000;;						Group:    group.Group.Name,
0000000000000000000000000000000000000000;;						Version:  group.Group.PreferredVersion.Version,
0000000000000000000000000000000000000000;;						Resource: meta.AnyResource,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					kindPriority = append(kindPriority, schema.GroupVersionKind{
0000000000000000000000000000000000000000;;						Group:   group.Group.Name,
0000000000000000000000000000000000000000;;						Version: group.Group.PreferredVersion.Version,
0000000000000000000000000000000000000000;;						Kind:    meta.AnyKind,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, discoveryVersion := range group.Group.Versions {
0000000000000000000000000000000000000000;;				resources, ok := group.VersionedResources[discoveryVersion.Version]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				gv := schema.GroupVersion{Group: group.Group.Name, Version: discoveryVersion.Version}
0000000000000000000000000000000000000000;;				versionMapper := meta.NewDefaultRESTMapper([]schema.GroupVersion{gv}, versionInterfaces)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, resource := range resources {
0000000000000000000000000000000000000000;;					scope := meta.RESTScopeNamespace
0000000000000000000000000000000000000000;;					if !resource.Namespaced {
0000000000000000000000000000000000000000;;						scope = meta.RESTScopeRoot
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					versionMapper.Add(gv.WithKind(resource.Kind), scope)
0000000000000000000000000000000000000000;;					// TODO only do this if it supports listing
0000000000000000000000000000000000000000;;					versionMapper.Add(gv.WithKind(resource.Kind+"List"), scope)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO why is this type not in discovery (at least for "v1")
0000000000000000000000000000000000000000;;				versionMapper.Add(gv.WithKind("List"), meta.RESTScopeRoot)
0000000000000000000000000000000000000000;;				unionMapper = append(unionMapper, versionMapper)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, group := range groupPriority {
0000000000000000000000000000000000000000;;			resourcePriority = append(resourcePriority, schema.GroupVersionResource{
0000000000000000000000000000000000000000;;				Group:    group,
0000000000000000000000000000000000000000;;				Version:  meta.AnyVersion,
0000000000000000000000000000000000000000;;				Resource: meta.AnyResource,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			kindPriority = append(kindPriority, schema.GroupVersionKind{
0000000000000000000000000000000000000000;;				Group:   group,
0000000000000000000000000000000000000000;;				Version: meta.AnyVersion,
0000000000000000000000000000000000000000;;				Kind:    meta.AnyKind,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return meta.PriorityRESTMapper{
0000000000000000000000000000000000000000;;			Delegate:         unionMapper,
0000000000000000000000000000000000000000;;			ResourcePriority: resourcePriority,
0000000000000000000000000000000000000000;;			KindPriority:     kindPriority,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAPIGroupResources uses the provided discovery client to gather
0000000000000000000000000000000000000000;;	// discovery information and populate a slice of APIGroupResources.
0000000000000000000000000000000000000000;;	func GetAPIGroupResources(cl DiscoveryInterface) ([]*APIGroupResources, error) {
0000000000000000000000000000000000000000;;		apiGroups, err := cl.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var result []*APIGroupResources
0000000000000000000000000000000000000000;;		for _, group := range apiGroups.Groups {
0000000000000000000000000000000000000000;;			groupResources := &APIGroupResources{
0000000000000000000000000000000000000000;;				Group:              group,
0000000000000000000000000000000000000000;;				VersionedResources: make(map[string][]metav1.APIResource),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, version := range group.Versions {
0000000000000000000000000000000000000000;;				resources, err := cl.ServerResourcesForGroupVersion(version.GroupVersion)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// continue as best we can
0000000000000000000000000000000000000000;;					// TODO track the errors and update callers to handle partial errors.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				groupResources.VersionedResources[version.Version] = resources.APIResources
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, groupResources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeferredDiscoveryRESTMapper is a RESTMapper that will defer
0000000000000000000000000000000000000000;;	// initialization of the RESTMapper until the first mapping is
0000000000000000000000000000000000000000;;	// requested.
0000000000000000000000000000000000000000;;	type DeferredDiscoveryRESTMapper struct {
0000000000000000000000000000000000000000;;		initMu           sync.Mutex
0000000000000000000000000000000000000000;;		delegate         meta.RESTMapper
0000000000000000000000000000000000000000;;		cl               CachedDiscoveryInterface
0000000000000000000000000000000000000000;;		versionInterface meta.VersionInterfacesFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDeferredDiscoveryRESTMapper returns a
0000000000000000000000000000000000000000;;	// DeferredDiscoveryRESTMapper that will lazily query the provided
0000000000000000000000000000000000000000;;	// client for discovery information to do REST mappings.
0000000000000000000000000000000000000000;;	func NewDeferredDiscoveryRESTMapper(cl CachedDiscoveryInterface, versionInterface meta.VersionInterfacesFunc) *DeferredDiscoveryRESTMapper {
0000000000000000000000000000000000000000;;		return &DeferredDiscoveryRESTMapper{
0000000000000000000000000000000000000000;;			cl:               cl,
0000000000000000000000000000000000000000;;			versionInterface: versionInterface,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) getDelegate() (meta.RESTMapper, error) {
0000000000000000000000000000000000000000;;		d.initMu.Lock()
0000000000000000000000000000000000000000;;		defer d.initMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.delegate != nil {
0000000000000000000000000000000000000000;;			return d.delegate, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groupResources, err := GetAPIGroupResources(d.cl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.delegate = NewRESTMapper(groupResources, d.versionInterface)
0000000000000000000000000000000000000000;;		return d.delegate, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the internally cached Discovery information and will
0000000000000000000000000000000000000000;;	// cause the next mapping request to re-discover.
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) Reset() {
0000000000000000000000000000000000000000;;		glog.V(5).Info("Invalidating discovery information")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.initMu.Lock()
0000000000000000000000000000000000000000;;		defer d.initMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.cl.Invalidate()
0000000000000000000000000000000000000000;;		d.delegate = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindFor takes a partial resource and returns back the single match.
0000000000000000000000000000000000000000;;	// It returns an error if there are multiple matches.
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) KindFor(resource schema.GroupVersionResource) (gvk schema.GroupVersionKind, err error) {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk, err = del.KindFor(resource)
0000000000000000000000000000000000000000;;		if err != nil && !d.cl.Fresh() {
0000000000000000000000000000000000000000;;			d.Reset()
0000000000000000000000000000000000000000;;			gvk, err = d.KindFor(resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindsFor takes a partial resource and returns back the list of
0000000000000000000000000000000000000000;;	// potential kinds in priority order.
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) KindsFor(resource schema.GroupVersionResource) (gvks []schema.GroupVersionKind, err error) {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvks, err = del.KindsFor(resource)
0000000000000000000000000000000000000000;;		if len(gvks) == 0 && !d.cl.Fresh() {
0000000000000000000000000000000000000000;;			d.Reset()
0000000000000000000000000000000000000000;;			gvks, err = d.KindsFor(resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceFor takes a partial resource and returns back the single
0000000000000000000000000000000000000000;;	// match. It returns an error if there are multiple matches.
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) ResourceFor(input schema.GroupVersionResource) (gvr schema.GroupVersionResource, err error) {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionResource{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvr, err = del.ResourceFor(input)
0000000000000000000000000000000000000000;;		if err != nil && !d.cl.Fresh() {
0000000000000000000000000000000000000000;;			d.Reset()
0000000000000000000000000000000000000000;;			gvr, err = d.ResourceFor(input)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcesFor takes a partial resource and returns back the list of
0000000000000000000000000000000000000000;;	// potential resource in priority order.
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) ResourcesFor(input schema.GroupVersionResource) (gvrs []schema.GroupVersionResource, err error) {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvrs, err = del.ResourcesFor(input)
0000000000000000000000000000000000000000;;		if len(gvrs) == 0 && !d.cl.Fresh() {
0000000000000000000000000000000000000000;;			d.Reset()
0000000000000000000000000000000000000000;;			gvrs, err = d.ResourcesFor(input)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMapping identifies a preferred resource mapping for the
0000000000000000000000000000000000000000;;	// provided group kind.
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) RESTMapping(gk schema.GroupKind, versions ...string) (m *meta.RESTMapping, err error) {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m, err = del.RESTMapping(gk, versions...)
0000000000000000000000000000000000000000;;		if err != nil && !d.cl.Fresh() {
0000000000000000000000000000000000000000;;			d.Reset()
0000000000000000000000000000000000000000;;			m, err = d.RESTMapping(gk, versions...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMappings returns the RESTMappings for the provided group kind
0000000000000000000000000000000000000000;;	// in a rough internal preferred order. If no kind is found, it will
0000000000000000000000000000000000000000;;	// return a NoResourceMatchError.
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) RESTMappings(gk schema.GroupKind, versions ...string) (ms []*meta.RESTMapping, err error) {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ms, err = del.RESTMappings(gk, versions...)
0000000000000000000000000000000000000000;;		if len(ms) == 0 && !d.cl.Fresh() {
0000000000000000000000000000000000000000;;			d.Reset()
0000000000000000000000000000000000000000;;			ms, err = d.RESTMappings(gk, versions...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceSingularizer converts a resource name from plural to
0000000000000000000000000000000000000000;;	// singular (e.g., from pods to pod).
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) ResourceSingularizer(resource string) (singular string, err error) {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return resource, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		singular, err = del.ResourceSingularizer(resource)
0000000000000000000000000000000000000000;;		if err != nil && !d.cl.Fresh() {
0000000000000000000000000000000000000000;;			d.Reset()
0000000000000000000000000000000000000000;;			singular, err = d.ResourceSingularizer(resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *DeferredDiscoveryRESTMapper) String() string {
0000000000000000000000000000000000000000;;		del, err := d.getDelegate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("DeferredDiscoveryRESTMapper{%v}", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("DeferredDiscoveryRESTMapper{\n\t%v\n}", del)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make sure it satisfies the interface
0000000000000000000000000000000000000000;;	var _ meta.RESTMapper = &DeferredDiscoveryRESTMapper{}
