0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c64579dfcb0a7da9607fc83cb5808ce2d6ab607c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package discovery_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		uapi "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest/fake"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func objBody(object interface{}) io.ReadCloser {
0000000000000000000000000000000000000000;;		output, err := json.MarshalIndent(object, "", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ioutil.NopCloser(bytes.NewReader([]byte(output)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServerSupportsVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name            string
0000000000000000000000000000000000000000;;			requiredVersion schema.GroupVersion
0000000000000000000000000000000000000000;;			serverVersions  []string
0000000000000000000000000000000000000000;;			expectErr       func(err error) bool
0000000000000000000000000000000000000000;;			sendErr         error
0000000000000000000000000000000000000000;;			statusCode      int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "explicit version supported",
0000000000000000000000000000000000000000;;				requiredVersion: schema.GroupVersion{Version: "v1"},
0000000000000000000000000000000000000000;;				serverVersions:  []string{"/version1", v1.SchemeGroupVersion.String()},
0000000000000000000000000000000000000000;;				statusCode:      http.StatusOK,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "explicit version not supported on server",
0000000000000000000000000000000000000000;;				requiredVersion: schema.GroupVersion{Version: "v1"},
0000000000000000000000000000000000000000;;				serverVersions:  []string{"version1"},
0000000000000000000000000000000000000000;;				expectErr:       func(err error) bool { return strings.Contains(err.Error(), `server does not support API version "v1"`) },
0000000000000000000000000000000000000000;;				statusCode:      http.StatusOK,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "connection refused error",
0000000000000000000000000000000000000000;;				serverVersions: []string{"version1"},
0000000000000000000000000000000000000000;;				sendErr:        errors.New("connection refused"),
0000000000000000000000000000000000000000;;				expectErr:      func(err error) bool { return strings.Contains(err.Error(), "connection refused") },
0000000000000000000000000000000000000000;;				statusCode:     http.StatusOK,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "discovery fails due to 404 Not Found errors and thus serverVersions is empty, use requested GroupVersion",
0000000000000000000000000000000000000000;;				requiredVersion: schema.GroupVersion{Version: "version1"},
0000000000000000000000000000000000000000;;				statusCode:      http.StatusNotFound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			fakeClient := &fake.RESTClient{
0000000000000000000000000000000000000000;;				NegotiatedSerializer: scheme.Codecs,
0000000000000000000000000000000000000000;;				Resp: &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: test.statusCode,
0000000000000000000000000000000000000000;;					Body:       objBody(&uapi.APIVersions{Versions: test.serverVersions}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Client: fake.CreateHTTPClient(func(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;					if test.sendErr != nil {
0000000000000000000000000000000000000000;;						return nil, test.sendErr
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					header := http.Header{}
0000000000000000000000000000000000000000;;					header.Set("Content-Type", runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;					return &http.Response{StatusCode: test.statusCode, Header: header, Body: objBody(&uapi.APIVersions{Versions: test.serverVersions})}, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c := discovery.NewDiscoveryClientForConfigOrDie(&restclient.Config{})
0000000000000000000000000000000000000000;;			c.RESTClient().(*restclient.RESTClient).Client = fakeClient.Client
0000000000000000000000000000000000000000;;			err := discovery.ServerSupportsVersion(c, test.requiredVersion)
0000000000000000000000000000000000000000;;			if err == nil && test.expectErr != nil {
0000000000000000000000000000000000000000;;				t.Errorf("expected error, got nil for [%s].", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if test.expectErr == nil || !test.expectErr(err) {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error for [%s]: %v.", test.name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFilteredBy(t *testing.T) {
0000000000000000000000000000000000000000;;		all := discovery.ResourcePredicateFunc(func(gv string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		none := discovery.ResourcePredicateFunc(func(gv string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		onlyV2 := discovery.ResourcePredicateFunc(func(gv string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;			return strings.HasSuffix(gv, "/v2") || gv == "v2"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		onlyBar := discovery.ResourcePredicateFunc(func(gv string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;			return r.Kind == "Bar"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := []*metav1.APIResourceList{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				GroupVersion: "foo/v1",
0000000000000000000000000000000000000000;;				APIResources: []metav1.APIResource{
0000000000000000000000000000000000000000;;					{Name: "bar", Kind: "Bar"},
0000000000000000000000000000000000000000;;					{Name: "test", Kind: "Test"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				GroupVersion: "foo/v2",
0000000000000000000000000000000000000000;;				APIResources: []metav1.APIResource{
0000000000000000000000000000000000000000;;					{Name: "bar", Kind: "Bar"},
0000000000000000000000000000000000000000;;					{Name: "test", Kind: "Test"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				GroupVersion: "foo/v3",
0000000000000000000000000000000000000000;;				APIResources: []metav1.APIResource{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input             []*metav1.APIResourceList
0000000000000000000000000000000000000000;;			pred              discovery.ResourcePredicate
0000000000000000000000000000000000000000;;			expectedResources []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{nil, all, []string{}},
0000000000000000000000000000000000000000;;			{[]*metav1.APIResourceList{
0000000000000000000000000000000000000000;;				{GroupVersion: "foo/v1"},
0000000000000000000000000000000000000000;;			}, all, []string{}},
0000000000000000000000000000000000000000;;			{foo, all, []string{"foo/v1.bar", "foo/v1.test", "foo/v2.bar", "foo/v2.test"}},
0000000000000000000000000000000000000000;;			{foo, onlyV2, []string{"foo/v2.bar", "foo/v2.test"}},
0000000000000000000000000000000000000000;;			{foo, onlyBar, []string{"foo/v1.bar", "foo/v2.bar"}},
0000000000000000000000000000000000000000;;			{foo, none, []string{}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			filtered := discovery.FilteredBy(test.pred, test.input)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if expected, got := sets.NewString(test.expectedResources...), sets.NewString(stringify(filtered)...); !expected.Equal(got) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected group versions: expected=%v, got=%v", i, test.expectedResources, stringify(filtered))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stringify(rls []*metav1.APIResourceList) []string {
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for _, rl := range rls {
0000000000000000000000000000000000000000;;			for _, r := range rl.APIResources {
0000000000000000000000000000000000000000;;				result = append(result, rl.GroupVersion+"."+r.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(rl.APIResources) == 0 {
0000000000000000000000000000000000000000;;				result = append(result, rl.GroupVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
