0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/discovery/discovery_client.go[staging/src/k8s.io/client-go/1.4/discovery/discovery_client.go][staging/src/k8s.io/client-go/discovery/discovery_client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package discovery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/googleapis/gnostic/OpenAPIv2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultRetries is the number of times a resource discovery is repeated if an api group disappears on the fly (e.g. ThirdPartyResources).
0000000000000000000000000000000000000000;;	const defaultRetries = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiscoveryInterface holds the methods that discover server-supported API groups,
0000000000000000000000000000000000000000;;	// versions and resources.
0000000000000000000000000000000000000000;;	type DiscoveryInterface interface {
0000000000000000000000000000000000000000;;		RESTClient() restclient.Interface
0000000000000000000000000000000000000000;;		ServerGroupsInterface
0000000000000000000000000000000000000000;;		ServerResourcesInterface
0000000000000000000000000000000000000000;;		ServerVersionInterface
0000000000000000000000000000000000000000;;		SwaggerSchemaInterface
0000000000000000000000000000000000000000;;		OpenAPISchemaInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CachedDiscoveryInterface is a DiscoveryInterface with cache invalidation and freshness.
0000000000000000000000000000000000000000;;	type CachedDiscoveryInterface interface {
0000000000000000000000000000000000000000;;		DiscoveryInterface
0000000000000000000000000000000000000000;;		// Fresh is supposed to tell the caller whether or not to retry if the cache
0000000000000000000000000000000000000000;;		// fails to find something (false = retry, true = no need to retry).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO: this needs to be revisited, this interface can't be locked properly
0000000000000000000000000000000000000000;;		// and doesn't make a lot of sense.
0000000000000000000000000000000000000000;;		Fresh() bool
0000000000000000000000000000000000000000;;		// Invalidate enforces that no cached data is used in the future that is older than the current time.
0000000000000000000000000000000000000000;;		Invalidate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerGroupsInterface has methods for obtaining supported groups on the API server
0000000000000000000000000000000000000000;;	type ServerGroupsInterface interface {
0000000000000000000000000000000000000000;;		// ServerGroups returns the supported groups, with information like supported versions and the
0000000000000000000000000000000000000000;;		// preferred version.
0000000000000000000000000000000000000000;;		ServerGroups() (*metav1.APIGroupList, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResourcesInterface has methods for obtaining supported resources on the API server
0000000000000000000000000000000000000000;;	type ServerResourcesInterface interface {
0000000000000000000000000000000000000000;;		// ServerResourcesForGroupVersion returns the supported resources for a group and version.
0000000000000000000000000000000000000000;;		ServerResourcesForGroupVersion(groupVersion string) (*metav1.APIResourceList, error)
0000000000000000000000000000000000000000;;		// ServerResources returns the supported resources for all groups and versions.
0000000000000000000000000000000000000000;;		ServerResources() ([]*metav1.APIResourceList, error)
0000000000000000000000000000000000000000;;		// ServerPreferredResources returns the supported resources with the version preferred by the
0000000000000000000000000000000000000000;;		// server.
0000000000000000000000000000000000000000;;		ServerPreferredResources() ([]*metav1.APIResourceList, error)
0000000000000000000000000000000000000000;;		// ServerPreferredNamespacedResources returns the supported namespaced resources with the
0000000000000000000000000000000000000000;;		// version preferred by the server.
0000000000000000000000000000000000000000;;		ServerPreferredNamespacedResources() ([]*metav1.APIResourceList, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerVersionInterface has a method for retrieving the server's version.
0000000000000000000000000000000000000000;;	type ServerVersionInterface interface {
0000000000000000000000000000000000000000;;		// ServerVersion retrieves and parses the server's version (git version).
0000000000000000000000000000000000000000;;		ServerVersion() (*version.Info, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SwaggerSchemaInterface has a method to retrieve the swagger schema.
0000000000000000000000000000000000000000;;	type SwaggerSchemaInterface interface {
0000000000000000000000000000000000000000;;		// SwaggerSchema retrieves and parses the swagger API schema the server supports.
0000000000000000000000000000000000000000;;		SwaggerSchema(version schema.GroupVersion) (*swagger.ApiDeclaration, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenAPISchemaInterface has a method to retrieve the open API schema.
0000000000000000000000000000000000000000;;	type OpenAPISchemaInterface interface {
0000000000000000000000000000000000000000;;		// OpenAPISchema retrieves and parses the swagger API schema the server supports.
0000000000000000000000000000000000000000;;		OpenAPISchema() (*openapi_v2.Document, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiscoveryClient implements the functions that discover server-supported API groups,
0000000000000000000000000000000000000000;;	// versions and resources.
0000000000000000000000000000000000000000;;	type DiscoveryClient struct {
0000000000000000000000000000000000000000;;		restClient restclient.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LegacyPrefix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert metav1.APIVersions to metav1.APIGroup. APIVersions is used by legacy v1, so
0000000000000000000000000000000000000000;;	// group would be "".
0000000000000000000000000000000000000000;;	func apiVersionsToAPIGroup(apiVersions *metav1.APIVersions) (apiGroup metav1.APIGroup) {
0000000000000000000000000000000000000000;;		groupVersions := []metav1.GroupVersionForDiscovery{}
0000000000000000000000000000000000000000;;		for _, version := range apiVersions.Versions {
0000000000000000000000000000000000000000;;			groupVersion := metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;				GroupVersion: version,
0000000000000000000000000000000000000000;;				Version:      version,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groupVersions = append(groupVersions, groupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiGroup.Versions = groupVersions
0000000000000000000000000000000000000000;;		// There should be only one groupVersion returned at /api
0000000000000000000000000000000000000000;;		apiGroup.PreferredVersion = groupVersions[0]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerGroups returns the supported groups, with information like supported versions and the
0000000000000000000000000000000000000000;;	// preferred version.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) ServerGroups() (apiGroupList *metav1.APIGroupList, err error) {
0000000000000000000000000000000000000000;;		// Get the groupVersions exposed at /api
0000000000000000000000000000000000000000;;		v := &metav1.APIVersions{}
0000000000000000000000000000000000000000;;		err = d.restClient.Get().AbsPath(d.LegacyPrefix).Do().Into(v)
0000000000000000000000000000000000000000;;		apiGroup := metav1.APIGroup{}
0000000000000000000000000000000000000000;;		if err == nil && len(v.Versions) != 0 {
0000000000000000000000000000000000000000;;			apiGroup = apiVersionsToAPIGroup(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) && !errors.IsForbidden(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the groupVersions exposed at /apis
0000000000000000000000000000000000000000;;		apiGroupList = &metav1.APIGroupList{}
0000000000000000000000000000000000000000;;		err = d.restClient.Get().AbsPath("/apis").Do().Into(apiGroupList)
0000000000000000000000000000000000000000;;		if err != nil && !errors.IsNotFound(err) && !errors.IsForbidden(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// to be compatible with a v1.0 server, if it's a 403 or 404, ignore and return whatever we got from /api
0000000000000000000000000000000000000000;;		if err != nil && (errors.IsNotFound(err) || errors.IsForbidden(err)) {
0000000000000000000000000000000000000000;;			apiGroupList = &metav1.APIGroupList{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// append the group retrieved from /api to the list if not empty
0000000000000000000000000000000000000000;;		if len(v.Versions) != 0 {
0000000000000000000000000000000000000000;;			apiGroupList.Groups = append(apiGroupList.Groups, apiGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return apiGroupList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResourcesForGroupVersion returns the supported resources for a group and version.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) ServerResourcesForGroupVersion(groupVersion string) (resources *metav1.APIResourceList, err error) {
0000000000000000000000000000000000000000;;		url := url.URL{}
0000000000000000000000000000000000000000;;		if len(groupVersion) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("groupVersion shouldn't be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(d.LegacyPrefix) > 0 && groupVersion == "v1" {
0000000000000000000000000000000000000000;;			url.Path = d.LegacyPrefix + "/" + groupVersion
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			url.Path = "/apis/" + groupVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resources = &metav1.APIResourceList{
0000000000000000000000000000000000000000;;			GroupVersion: groupVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = d.restClient.Get().AbsPath(url.String()).Do().Into(resources)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// ignore 403 or 404 error to be compatible with an v1.0 server.
0000000000000000000000000000000000000000;;			if groupVersion == "v1" && (errors.IsNotFound(err) || errors.IsForbidden(err)) {
0000000000000000000000000000000000000000;;				return resources, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resources, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serverResources returns the supported resources for all groups and versions.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) serverResources(failEarly bool) ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		apiGroups, err := d.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := []*metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		failedGroups := make(map[schema.GroupVersion]error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, apiGroup := range apiGroups.Groups {
0000000000000000000000000000000000000000;;			for _, version := range apiGroup.Versions {
0000000000000000000000000000000000000000;;				gv := schema.GroupVersion{Group: apiGroup.Name, Version: version.Version}
0000000000000000000000000000000000000000;;				resources, err := d.ServerResourcesForGroupVersion(version.GroupVersion)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// TODO: maybe restrict this to NotFound errors
0000000000000000000000000000000000000000;;					failedGroups[gv] = err
0000000000000000000000000000000000000000;;					if failEarly {
0000000000000000000000000000000000000000;;						return nil, &ErrGroupDiscoveryFailed{Groups: failedGroups}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				result = append(result, resources)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(failedGroups) == 0 {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, &ErrGroupDiscoveryFailed{Groups: failedGroups}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResources returns the supported resources for all groups and versions.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) ServerResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		return withRetries(defaultRetries, d.serverResources)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrGroupDiscoveryFailed is returned if one or more API groups fail to load.
0000000000000000000000000000000000000000;;	type ErrGroupDiscoveryFailed struct {
0000000000000000000000000000000000000000;;		// Groups is a list of the groups that failed to load and the error cause
0000000000000000000000000000000000000000;;		Groups map[schema.GroupVersion]error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements the error interface
0000000000000000000000000000000000000000;;	func (e *ErrGroupDiscoveryFailed) Error() string {
0000000000000000000000000000000000000000;;		var groups []string
0000000000000000000000000000000000000000;;		for k, v := range e.Groups {
0000000000000000000000000000000000000000;;			groups = append(groups, fmt.Sprintf("%s: %v", k, v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(groups)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("unable to retrieve the complete list of server APIs: %s", strings.Join(groups, ", "))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsGroupDiscoveryFailedError returns true if the provided error indicates the server was unable to discover
0000000000000000000000000000000000000000;;	// a complete list of APIs for the client to use.
0000000000000000000000000000000000000000;;	func IsGroupDiscoveryFailedError(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(*ErrGroupDiscoveryFailed)
0000000000000000000000000000000000000000;;		return err != nil && ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serverPreferredResources returns the supported resources with the version preferred by the server.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) serverPreferredResources(failEarly bool) ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		serverGroupList, err := d.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := []*metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		failedGroups := make(map[schema.GroupVersion]error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grVersions := map[schema.GroupResource]string{}                         // selected version of a GroupResource
0000000000000000000000000000000000000000;;		grApiResources := map[schema.GroupResource]*metav1.APIResource{}        // selected APIResource for a GroupResource
0000000000000000000000000000000000000000;;		gvApiResourceLists := map[schema.GroupVersion]*metav1.APIResourceList{} // blueprint for a APIResourceList for later grouping
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, apiGroup := range serverGroupList.Groups {
0000000000000000000000000000000000000000;;			for _, version := range apiGroup.Versions {
0000000000000000000000000000000000000000;;				groupVersion := schema.GroupVersion{Group: apiGroup.Name, Version: version.Version}
0000000000000000000000000000000000000000;;				apiResourceList, err := d.ServerResourcesForGroupVersion(version.GroupVersion)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// TODO: maybe restrict this to NotFound errors
0000000000000000000000000000000000000000;;					failedGroups[groupVersion] = err
0000000000000000000000000000000000000000;;					if failEarly {
0000000000000000000000000000000000000000;;						return nil, &ErrGroupDiscoveryFailed{Groups: failedGroups}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create empty list which is filled later in another loop
0000000000000000000000000000000000000000;;				emptyApiResourceList := metav1.APIResourceList{
0000000000000000000000000000000000000000;;					GroupVersion: version.GroupVersion,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gvApiResourceLists[groupVersion] = &emptyApiResourceList
0000000000000000000000000000000000000000;;				result = append(result, &emptyApiResourceList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := range apiResourceList.APIResources {
0000000000000000000000000000000000000000;;					apiResource := &apiResourceList.APIResources[i]
0000000000000000000000000000000000000000;;					if strings.Contains(apiResource.Name, "/") {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					gv := schema.GroupResource{Group: apiGroup.Name, Resource: apiResource.Name}
0000000000000000000000000000000000000000;;					if _, ok := grApiResources[gv]; ok && version.Version != apiGroup.PreferredVersion.Version {
0000000000000000000000000000000000000000;;						// only override with preferred version
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					grVersions[gv] = version.Version
0000000000000000000000000000000000000000;;					grApiResources[gv] = apiResource
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// group selected APIResources according to GroupVersion into APIResourceLists
0000000000000000000000000000000000000000;;		for groupResource, apiResource := range grApiResources {
0000000000000000000000000000000000000000;;			version := grVersions[groupResource]
0000000000000000000000000000000000000000;;			groupVersion := schema.GroupVersion{Group: groupResource.Group, Version: version}
0000000000000000000000000000000000000000;;			apiResourceList := gvApiResourceLists[groupVersion]
0000000000000000000000000000000000000000;;			apiResourceList.APIResources = append(apiResourceList.APIResources, *apiResource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(failedGroups) == 0 {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, &ErrGroupDiscoveryFailed{Groups: failedGroups}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerPreferredResources returns the supported resources with the version preferred by the
0000000000000000000000000000000000000000;;	// server.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) ServerPreferredResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		return withRetries(defaultRetries, func(retryEarly bool) ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;			return d.serverPreferredResources(retryEarly)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerPreferredNamespacedResources returns the supported namespaced resources with the
0000000000000000000000000000000000000000;;	// version preferred by the server.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) ServerPreferredNamespacedResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		all, err := d.ServerPreferredResources()
0000000000000000000000000000000000000000;;		return FilteredBy(ResourcePredicateFunc(func(groupVersion string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;			return r.Namespaced
0000000000000000000000000000000000000000;;		}), all), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerVersion retrieves and parses the server's version (git version).
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) ServerVersion() (*version.Info, error) {
0000000000000000000000000000000000000000;;		body, err := d.restClient.Get().AbsPath("/version").Do().Raw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var info version.Info
0000000000000000000000000000000000000000;;		err = json.Unmarshal(body, &info)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("got '%s': %v", string(body), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &info, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SwaggerSchema retrieves and parses the swagger API schema the server supports.
0000000000000000000000000000000000000000;;	// TODO: Replace usages with Open API.  Tracked in https://github.com/kubernetes/kubernetes/issues/44589
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) SwaggerSchema(version schema.GroupVersion) (*swagger.ApiDeclaration, error) {
0000000000000000000000000000000000000000;;		if version.Empty() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("groupVersion cannot be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groupList, err := d.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupVersions := metav1.ExtractGroupVersions(groupList)
0000000000000000000000000000000000000000;;		// This check also takes care the case that kubectl is newer than the running endpoint
0000000000000000000000000000000000000000;;		if stringDoesntExistIn(version.String(), groupVersions) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("API version: %v is not supported by the server. Use one of: %v", version, groupVersions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var path string
0000000000000000000000000000000000000000;;		if len(d.LegacyPrefix) > 0 && version == v1.SchemeGroupVersion {
0000000000000000000000000000000000000000;;			path = "/swaggerapi" + d.LegacyPrefix + "/" + version.Version
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			path = "/swaggerapi/apis/" + version.Group + "/" + version.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := d.restClient.Get().AbsPath(path).Do().Raw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var schema swagger.ApiDeclaration
0000000000000000000000000000000000000000;;		err = json.Unmarshal(body, &schema)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("got '%s': %v", string(body), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &schema, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenAPISchema fetches the open api schema using a rest client and parses the proto.
0000000000000000000000000000000000000000;;	func (d *DiscoveryClient) OpenAPISchema() (*openapi_v2.Document, error) {
0000000000000000000000000000000000000000;;		data, err := d.restClient.Get().AbsPath("/swagger-2.0.0.pb-v1").Do().Raw()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		document := &openapi_v2.Document{}
0000000000000000000000000000000000000000;;		err = proto.Unmarshal(data, document)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return document, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withRetries retries the given recovery function in case the groups supported by the server change after ServerGroup() returns.
0000000000000000000000000000000000000000;;	func withRetries(maxRetries int, f func(failEarly bool) ([]*metav1.APIResourceList, error)) ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		var result []*metav1.APIResourceList
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := 0; i < maxRetries; i++ {
0000000000000000000000000000000000000000;;			failEarly := i < maxRetries-1
0000000000000000000000000000000000000000;;			result, err = f(failEarly)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return result, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := err.(*ErrGroupDiscoveryFailed); !ok {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDiscoveryDefaults(config *restclient.Config) error {
0000000000000000000000000000000000000000;;		config.APIPath = ""
0000000000000000000000000000000000000000;;		config.GroupVersion = nil
0000000000000000000000000000000000000000;;		codec := runtime.NoopEncoder{Decoder: scheme.Codecs.UniversalDecoder()}
0000000000000000000000000000000000000000;;		config.NegotiatedSerializer = serializer.NegotiatedSerializerWrapper(runtime.SerializerInfo{Serializer: codec})
0000000000000000000000000000000000000000;;		if len(config.UserAgent) == 0 {
0000000000000000000000000000000000000000;;			config.UserAgent = restclient.DefaultKubernetesUserAgent()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDiscoveryClientForConfig creates a new DiscoveryClient for the given config. This client
0000000000000000000000000000000000000000;;	// can be used to discover supported resources in the API server.
0000000000000000000000000000000000000000;;	func NewDiscoveryClientForConfig(c *restclient.Config) (*DiscoveryClient, error) {
0000000000000000000000000000000000000000;;		config := *c
0000000000000000000000000000000000000000;;		if err := setDiscoveryDefaults(&config); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := restclient.UnversionedRESTClientFor(&config)
0000000000000000000000000000000000000000;;		return &DiscoveryClient{restClient: client, LegacyPrefix: "/api"}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDiscoveryClientForConfig creates a new DiscoveryClient for the given config. If
0000000000000000000000000000000000000000;;	// there is an error, it panics.
0000000000000000000000000000000000000000;;	func NewDiscoveryClientForConfigOrDie(c *restclient.Config) *DiscoveryClient {
0000000000000000000000000000000000000000;;		client, err := NewDiscoveryClientForConfig(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new DiscoveryClient for the given RESTClient.
0000000000000000000000000000000000000000;;	func NewDiscoveryClient(c restclient.Interface) *DiscoveryClient {
0000000000000000000000000000000000000000;;		return &DiscoveryClient{restClient: c, LegacyPrefix: "/api"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stringDoesntExistIn(str string, slice []string) bool {
0000000000000000000000000000000000000000;;		for _, s := range slice {
0000000000000000000000000000000000000000;;			if s == str {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTClient returns a RESTClient that is used to communicate
0000000000000000000000000000000000000000;;	// with API server by this client implementation.
0000000000000000000000000000000000000000;;	func (c *DiscoveryClient) RESTClient() restclient.Interface {
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.restClient
0000000000000000000000000000000000000000;;	}
