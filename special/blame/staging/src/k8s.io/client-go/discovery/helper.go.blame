0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c64579dfcb0a7da9607fc83cb5808ce2d6ab607c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package discovery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		apimachineryversion "k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchesServerVersion queries the server to compares the build version
0000000000000000000000000000000000000000;;	// (git hash) of the client with the server's build version. It returns an error
0000000000000000000000000000000000000000;;	// if it failed to contact the server or if the versions are not an exact match.
0000000000000000000000000000000000000000;;	func MatchesServerVersion(clientVersion apimachineryversion.Info, client DiscoveryInterface) error {
0000000000000000000000000000000000000000;;		sVer, err := client.ServerVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't read version from server: %v\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// GitVersion includes GitCommit and GitTreeState, but best to be safe?
0000000000000000000000000000000000000000;;		if clientVersion.GitVersion != sVer.GitVersion || clientVersion.GitCommit != sVer.GitCommit || clientVersion.GitTreeState != sVer.GitTreeState {
0000000000000000000000000000000000000000;;			return fmt.Errorf("server version (%#v) differs from client version (%#v)!\n", sVer, clientVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerSupportsVersion returns an error if the server doesn't have the required version
0000000000000000000000000000000000000000;;	func ServerSupportsVersion(client DiscoveryInterface, requiredGV schema.GroupVersion) error {
0000000000000000000000000000000000000000;;		groups, err := client.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This is almost always a connection error, and higher level code should treat this as a generic error,
0000000000000000000000000000000000000000;;			// not a negotiation specific error.
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versions := metav1.ExtractGroupVersions(groups)
0000000000000000000000000000000000000000;;		serverVersions := sets.String{}
0000000000000000000000000000000000000000;;		for _, v := range versions {
0000000000000000000000000000000000000000;;			serverVersions.Insert(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if serverVersions.Has(requiredGV.String()) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the server supports no versions, then we should pretend it has the version because of old servers.
0000000000000000000000000000000000000000;;		// This can happen because discovery fails due to 403 Forbidden errors
0000000000000000000000000000000000000000;;		if len(serverVersions) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("server does not support API version %q", requiredGV)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersionResources converts APIResourceLists to the GroupVersionResources.
0000000000000000000000000000000000000000;;	func GroupVersionResources(rls []*metav1.APIResourceList) (map[schema.GroupVersionResource]struct{}, error) {
0000000000000000000000000000000000000000;;		gvrs := map[schema.GroupVersionResource]struct{}{}
0000000000000000000000000000000000000000;;		for _, rl := range rls {
0000000000000000000000000000000000000000;;			gv, err := schema.ParseGroupVersion(rl.GroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range rl.APIResources {
0000000000000000000000000000000000000000;;				gvrs[schema.GroupVersionResource{Group: gv.Group, Version: gv.Version, Resource: rl.APIResources[i].Name}] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gvrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilteredBy filters by the given predicate. Empty APIResourceLists are dropped.
0000000000000000000000000000000000000000;;	func FilteredBy(pred ResourcePredicate, rls []*metav1.APIResourceList) []*metav1.APIResourceList {
0000000000000000000000000000000000000000;;		result := []*metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		for _, rl := range rls {
0000000000000000000000000000000000000000;;			filtered := *rl
0000000000000000000000000000000000000000;;			filtered.APIResources = nil
0000000000000000000000000000000000000000;;			for i := range rl.APIResources {
0000000000000000000000000000000000000000;;				if pred.Match(rl.GroupVersion, &rl.APIResources[i]) {
0000000000000000000000000000000000000000;;					filtered.APIResources = append(filtered.APIResources, rl.APIResources[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filtered.APIResources != nil {
0000000000000000000000000000000000000000;;				result = append(result, &filtered)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourcePredicate interface {
0000000000000000000000000000000000000000;;		Match(groupVersion string, r *metav1.APIResource) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourcePredicateFunc func(groupVersion string, r *metav1.APIResource) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fn ResourcePredicateFunc) Match(groupVersion string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;		return fn(groupVersion, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportsAllVerbs is a predicate matching a resource iff all given verbs are supported.
0000000000000000000000000000000000000000;;	type SupportsAllVerbs struct {
0000000000000000000000000000000000000000;;		Verbs []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p SupportsAllVerbs) Match(groupVersion string, r *metav1.APIResource) bool {
0000000000000000000000000000000000000000;;		return sets.NewString([]string(r.Verbs)...).HasAll(p.Verbs...)
0000000000000000000000000000000000000000;;	}
