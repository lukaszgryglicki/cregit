0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0d544a2842d63ac441f5f1c615cab92a256980ea;pkg/controller/garbagecollector/memcachediscovery/client.go[pkg/controller/garbagecollector/memcachediscovery/client.go][staging/src/k8s.io/client-go/discovery/cached/memcache.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cached
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;		"github.com/googleapis/gnostic/OpenAPIv2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// memCacheClient can Invalidate() to stay up-to-date with discovery
0000000000000000000000000000000000000000;;	// information.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: Switch to a watch interface. Right now it will poll anytime
0000000000000000000000000000000000000000;;	// Invalidate() is called.
0000000000000000000000000000000000000000;;	type memCacheClient struct {
0000000000000000000000000000000000000000;;		delegate discovery.DiscoveryInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock                   sync.RWMutex
0000000000000000000000000000000000000000;;		groupToServerResources map[string]*metav1.APIResourceList
0000000000000000000000000000000000000000;;		groupList              *metav1.APIGroupList
0000000000000000000000000000000000000000;;		cacheValid             bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrCacheEmpty    = errors.New("the cache has not been filled yet")
0000000000000000000000000000000000000000;;		ErrCacheNotFound = errors.New("not found")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ discovery.CachedDiscoveryInterface = &memCacheClient{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResourcesForGroupVersion returns the supported resources for a group and version.
0000000000000000000000000000000000000000;;	func (d *memCacheClient) ServerResourcesForGroupVersion(groupVersion string) (*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		d.lock.RLock()
0000000000000000000000000000000000000000;;		defer d.lock.RUnlock()
0000000000000000000000000000000000000000;;		if !d.cacheValid {
0000000000000000000000000000000000000000;;			return nil, ErrCacheEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cachedVal, ok := d.groupToServerResources[groupVersion]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, ErrCacheNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cachedVal, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResources returns the supported resources for all groups and versions.
0000000000000000000000000000000000000000;;	func (d *memCacheClient) ServerResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		apiGroups, err := d.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupVersions := metav1.ExtractGroupVersions(apiGroups)
0000000000000000000000000000000000000000;;		result := []*metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		for _, groupVersion := range groupVersions {
0000000000000000000000000000000000000000;;			resources, err := d.ServerResourcesForGroupVersion(groupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, resources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *memCacheClient) ServerGroups() (*metav1.APIGroupList, error) {
0000000000000000000000000000000000000000;;		d.lock.RLock()
0000000000000000000000000000000000000000;;		defer d.lock.RUnlock()
0000000000000000000000000000000000000000;;		if d.groupList == nil {
0000000000000000000000000000000000000000;;			return nil, ErrCacheEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.groupList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *memCacheClient) RESTClient() restclient.Interface {
0000000000000000000000000000000000000000;;		return d.delegate.RESTClient()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Should this also be cached? The results seem more likely to be
0000000000000000000000000000000000000000;;	// inconsistent with ServerGroups and ServerResources given the requirement to
0000000000000000000000000000000000000000;;	// actively Invalidate.
0000000000000000000000000000000000000000;;	func (d *memCacheClient) ServerPreferredResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		return d.delegate.ServerPreferredResources()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Should this also be cached? The results seem more likely to be
0000000000000000000000000000000000000000;;	// inconsistent with ServerGroups and ServerResources given the requirement to
0000000000000000000000000000000000000000;;	// actively Invalidate.
0000000000000000000000000000000000000000;;	func (d *memCacheClient) ServerPreferredNamespacedResources() ([]*metav1.APIResourceList, error) {
0000000000000000000000000000000000000000;;		return d.delegate.ServerPreferredNamespacedResources()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *memCacheClient) ServerVersion() (*version.Info, error) {
0000000000000000000000000000000000000000;;		return d.delegate.ServerVersion()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *memCacheClient) SwaggerSchema(version schema.GroupVersion) (*swagger.ApiDeclaration, error) {
0000000000000000000000000000000000000000;;		return d.delegate.SwaggerSchema(version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *memCacheClient) OpenAPISchema() (*openapi_v2.Document, error) {
0000000000000000000000000000000000000000;;		return d.delegate.OpenAPISchema()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *memCacheClient) Fresh() bool {
0000000000000000000000000000000000000000;;		d.lock.RLock()
0000000000000000000000000000000000000000;;		defer d.lock.RUnlock()
0000000000000000000000000000000000000000;;		// Fresh is supposed to tell the caller whether or not to retry if the cache
0000000000000000000000000000000000000000;;		// fails to find something. The idea here is that Invalidate will be called
0000000000000000000000000000000000000000;;		// periodically and therefore we'll always be returning the latest data. (And
0000000000000000000000000000000000000000;;		// in the future we can watch and stay even more up-to-date.) So we only
0000000000000000000000000000000000000000;;		// return false if the cache has never been filled.
0000000000000000000000000000000000000000;;		return d.cacheValid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Invalidate refreshes the cache, blocking calls until the cache has been
0000000000000000000000000000000000000000;;	// refreshed. It would be trivial to make a version that does this in the
0000000000000000000000000000000000000000;;	// background while continuing to respond to requests if needed.
0000000000000000000000000000000000000000;;	func (d *memCacheClient) Invalidate() {
0000000000000000000000000000000000000000;;		d.lock.Lock()
0000000000000000000000000000000000000000;;		defer d.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Could this multiplicative set of calls be replaced by a single call
0000000000000000000000000000000000000000;;		// to ServerResources? If it's possible for more than one resulting
0000000000000000000000000000000000000000;;		// APIResourceList to have the same GroupVersion, the lists would need merged.
0000000000000000000000000000000000000000;;		gl, err := d.delegate.ServerGroups()
0000000000000000000000000000000000000000;;		if err != nil || len(gl.Groups) == 0 {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("couldn't get current server API group list; will keep using cached value. (%v)", err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rl := map[string]*metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		for _, g := range gl.Groups {
0000000000000000000000000000000000000000;;			for _, v := range g.Versions {
0000000000000000000000000000000000000000;;				r, err := d.delegate.ServerResourcesForGroupVersion(v.GroupVersion)
0000000000000000000000000000000000000000;;				if err != nil || len(r.APIResources) == 0 {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("couldn't get resource list for %v: %v", v.GroupVersion, err))
0000000000000000000000000000000000000000;;					if cur, ok := d.groupToServerResources[v.GroupVersion]; ok {
0000000000000000000000000000000000000000;;						// retain the existing list, if we had it.
0000000000000000000000000000000000000000;;						r = cur
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rl[v.GroupVersion] = r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.groupToServerResources, d.groupList = rl, gl
0000000000000000000000000000000000000000;;		d.cacheValid = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMemCacheClient creates a new CachedDiscoveryInterface which caches
0000000000000000000000000000000000000000;;	// discovery information in memory and will stay up-to-date if Invalidate is
0000000000000000000000000000000000000000;;	// called with regularity.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: The client will NOT resort to live lookups on cache misses.
0000000000000000000000000000000000000000;;	func NewMemCacheClient(delegate discovery.DiscoveryInterface) discovery.CachedDiscoveryInterface {
0000000000000000000000000000000000000000;;		return &memCacheClient{
0000000000000000000000000000000000000000;;			delegate:               delegate,
0000000000000000000000000000000000000000;;			groupToServerResources: map[string]*metav1.APIResourceList{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
