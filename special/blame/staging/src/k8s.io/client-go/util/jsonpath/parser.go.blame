0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c409b014ea1f485f8bb92a9a6eadc2cc636553b1;staging/src/k8s.io/client-go/pkg/util/jsonpath/parser.go[staging/src/k8s.io/client-go/pkg/util/jsonpath/parser.go][staging/src/k8s.io/client-go/util/jsonpath/parser.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonpath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const eof = -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		leftDelim  = "{"
0000000000000000000000000000000000000000;;		rightDelim = "}"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parser struct {
0000000000000000000000000000000000000000;;		Name  string
0000000000000000000000000000000000000000;;		Root  *ListNode
0000000000000000000000000000000000000000;;		input string
0000000000000000000000000000000000000000;;		cur   *ListNode
0000000000000000000000000000000000000000;;		pos   int
0000000000000000000000000000000000000000;;		start int
0000000000000000000000000000000000000000;;		width int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrSyntax = errors.New("invalid syntax")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parsed the given text and return a node Parser.
0000000000000000000000000000000000000000;;	// If an error is encountered, parsing stops and an empty
0000000000000000000000000000000000000000;;	// Parser is returned with the error
0000000000000000000000000000000000000000;;	func Parse(name, text string) (*Parser, error) {
0000000000000000000000000000000000000000;;		p := NewParser(name)
0000000000000000000000000000000000000000;;		err := p.Parse(text)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewParser(name string) *Parser {
0000000000000000000000000000000000000000;;		return &Parser{
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseAction parsed the expression inside delimiter
0000000000000000000000000000000000000000;;	func parseAction(name, text string) (*Parser, error) {
0000000000000000000000000000000000000000;;		p, err := Parse(name, fmt.Sprintf("%s%s%s", leftDelim, text, rightDelim))
0000000000000000000000000000000000000000;;		// when error happens, p will be nil, so we need to return here
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return p, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Root = p.Root.Nodes[0].(*ListNode)
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) Parse(text string) error {
0000000000000000000000000000000000000000;;		p.input = text
0000000000000000000000000000000000000000;;		p.Root = newList()
0000000000000000000000000000000000000000;;		p.pos = 0
0000000000000000000000000000000000000000;;		return p.parseText(p.Root)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consumeText return the parsed text since last cosumeText
0000000000000000000000000000000000000000;;	func (p *Parser) consumeText() string {
0000000000000000000000000000000000000000;;		value := p.input[p.start:p.pos]
0000000000000000000000000000000000000000;;		p.start = p.pos
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// next returns the next rune in the input.
0000000000000000000000000000000000000000;;	func (p *Parser) next() rune {
0000000000000000000000000000000000000000;;		if int(p.pos) >= len(p.input) {
0000000000000000000000000000000000000000;;			p.width = 0
0000000000000000000000000000000000000000;;			return eof
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, w := utf8.DecodeRuneInString(p.input[p.pos:])
0000000000000000000000000000000000000000;;		p.width = w
0000000000000000000000000000000000000000;;		p.pos += p.width
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// peek returns but does not consume the next rune in the input.
0000000000000000000000000000000000000000;;	func (p *Parser) peek() rune {
0000000000000000000000000000000000000000;;		r := p.next()
0000000000000000000000000000000000000000;;		p.backup()
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// backup steps back one rune. Can only be called once per call of next.
0000000000000000000000000000000000000000;;	func (p *Parser) backup() {
0000000000000000000000000000000000000000;;		p.pos -= p.width
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseText(cur *ListNode) error {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(p.input[p.pos:], leftDelim) {
0000000000000000000000000000000000000000;;				if p.pos > p.start {
0000000000000000000000000000000000000000;;					cur.append(newText(p.consumeText()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return p.parseLeftDelim(cur)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.next() == eof {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Correctly reached EOF.
0000000000000000000000000000000000000000;;		if p.pos > p.start {
0000000000000000000000000000000000000000;;			cur.append(newText(p.consumeText()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseLeftDelim scans the left delimiter, which is known to be present.
0000000000000000000000000000000000000000;;	func (p *Parser) parseLeftDelim(cur *ListNode) error {
0000000000000000000000000000000000000000;;		p.pos += len(leftDelim)
0000000000000000000000000000000000000000;;		p.consumeText()
0000000000000000000000000000000000000000;;		newNode := newList()
0000000000000000000000000000000000000000;;		cur.append(newNode)
0000000000000000000000000000000000000000;;		cur = newNode
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseInsideAction(cur *ListNode) error {
0000000000000000000000000000000000000000;;		prefixMap := map[string]func(*ListNode) error{
0000000000000000000000000000000000000000;;			rightDelim: p.parseRightDelim,
0000000000000000000000000000000000000000;;			"[?(":      p.parseFilter,
0000000000000000000000000000000000000000;;			"..":       p.parseRecursive,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for prefix, parseFunc := range prefixMap {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(p.input[p.pos:], prefix) {
0000000000000000000000000000000000000000;;				return parseFunc(cur)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch r := p.next(); {
0000000000000000000000000000000000000000;;		case r == eof || isEndOfLine(r):
0000000000000000000000000000000000000000;;			return fmt.Errorf("unclosed action")
0000000000000000000000000000000000000000;;		case r == ' ':
0000000000000000000000000000000000000000;;			p.consumeText()
0000000000000000000000000000000000000000;;		case r == '@' || r == '$': //the current object, just pass it
0000000000000000000000000000000000000000;;			p.consumeText()
0000000000000000000000000000000000000000;;		case r == '[':
0000000000000000000000000000000000000000;;			return p.parseArray(cur)
0000000000000000000000000000000000000000;;		case r == '"' || r == '\'':
0000000000000000000000000000000000000000;;			return p.parseQuote(cur, r)
0000000000000000000000000000000000000000;;		case r == '.':
0000000000000000000000000000000000000000;;			return p.parseField(cur)
0000000000000000000000000000000000000000;;		case r == '+' || r == '-' || unicode.IsDigit(r):
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;			return p.parseNumber(cur)
0000000000000000000000000000000000000000;;		case isAlphaNumeric(r):
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;			return p.parseIdentifier(cur)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unrecognized character in action: %#U", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseRightDelim scans the right delimiter, which is known to be present.
0000000000000000000000000000000000000000;;	func (p *Parser) parseRightDelim(cur *ListNode) error {
0000000000000000000000000000000000000000;;		p.pos += len(rightDelim)
0000000000000000000000000000000000000000;;		p.consumeText()
0000000000000000000000000000000000000000;;		cur = p.Root
0000000000000000000000000000000000000000;;		return p.parseText(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseIdentifier scans build-in keywords, like "range" "end"
0000000000000000000000000000000000000000;;	func (p *Parser) parseIdentifier(cur *ListNode) error {
0000000000000000000000000000000000000000;;		var r rune
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r = p.next()
0000000000000000000000000000000000000000;;			if isTerminator(r) {
0000000000000000000000000000000000000000;;				p.backup()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := p.consumeText()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isBool(value) {
0000000000000000000000000000000000000000;;			v, err := strconv.ParseBool(value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can not parse bool '%s': %s", value, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cur.append(newBool(v))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cur.append(newIdentifier(value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseRecursive scans the recursive desent operator ..
0000000000000000000000000000000000000000;;	func (p *Parser) parseRecursive(cur *ListNode) error {
0000000000000000000000000000000000000000;;		p.pos += len("..")
0000000000000000000000000000000000000000;;		p.consumeText()
0000000000000000000000000000000000000000;;		cur.append(newRecursive())
0000000000000000000000000000000000000000;;		if r := p.peek(); isAlphaNumeric(r) {
0000000000000000000000000000000000000000;;			return p.parseField(cur)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseNumber scans number
0000000000000000000000000000000000000000;;	func (p *Parser) parseNumber(cur *ListNode) error {
0000000000000000000000000000000000000000;;		r := p.peek()
0000000000000000000000000000000000000000;;		if r == '+' || r == '-' {
0000000000000000000000000000000000000000;;			r = p.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r = p.next()
0000000000000000000000000000000000000000;;			if r != '.' && !unicode.IsDigit(r) {
0000000000000000000000000000000000000000;;				p.backup()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := p.consumeText()
0000000000000000000000000000000000000000;;		i, err := strconv.Atoi(value)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			cur.append(newInt(i))
0000000000000000000000000000000000000000;;			return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d, err := strconv.ParseFloat(value, 64)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			cur.append(newFloat(d))
0000000000000000000000000000000000000000;;			return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("cannot parse number %s", value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseArray scans array index selection
0000000000000000000000000000000000000000;;	func (p *Parser) parseArray(cur *ListNode) error {
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch p.next() {
0000000000000000000000000000000000000000;;			case eof, '\n':
0000000000000000000000000000000000000000;;				return fmt.Errorf("unterminated array")
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		text := p.consumeText()
0000000000000000000000000000000000000000;;		text = string(text[1 : len(text)-1])
0000000000000000000000000000000000000000;;		if text == "*" {
0000000000000000000000000000000000000000;;			text = ":"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//union operator
0000000000000000000000000000000000000000;;		strs := strings.Split(text, ",")
0000000000000000000000000000000000000000;;		if len(strs) > 1 {
0000000000000000000000000000000000000000;;			union := []*ListNode{}
0000000000000000000000000000000000000000;;			for _, str := range strs {
0000000000000000000000000000000000000000;;				parser, err := parseAction("union", fmt.Sprintf("[%s]", strings.Trim(str, " ")))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				union = append(union, parser.Root)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cur.append(newUnion(union))
0000000000000000000000000000000000000000;;			return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// dict key
0000000000000000000000000000000000000000;;		reg := regexp.MustCompile(`^'([^']*)'$`)
0000000000000000000000000000000000000000;;		value := reg.FindStringSubmatch(text)
0000000000000000000000000000000000000000;;		if value != nil {
0000000000000000000000000000000000000000;;			parser, err := parseAction("arraydict", fmt.Sprintf(".%s", value[1]))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, node := range parser.Root.Nodes {
0000000000000000000000000000000000000000;;				cur.append(node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//slice operator
0000000000000000000000000000000000000000;;		reg = regexp.MustCompile(`^(-?[\d]*)(:-?[\d]*)?(:[\d]*)?$`)
0000000000000000000000000000000000000000;;		value = reg.FindStringSubmatch(text)
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid array index %s", text)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value = value[1:]
0000000000000000000000000000000000000000;;		params := [3]ParamsEntry{}
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			if value[i] != "" {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					value[i] = value[i][1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i > 0 && value[i] == "" {
0000000000000000000000000000000000000000;;					params[i].Known = false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					params[i].Known = true
0000000000000000000000000000000000000000;;					params[i].Value, err = strconv.Atoi(value[i])
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("array index %s is not a number", value[i])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if i == 1 {
0000000000000000000000000000000000000000;;					params[i].Known = true
0000000000000000000000000000000000000000;;					params[i].Value = params[0].Value + 1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					params[i].Known = false
0000000000000000000000000000000000000000;;					params[i].Value = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cur.append(newArray(params))
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseFilter scans filter inside array selection
0000000000000000000000000000000000000000;;	func (p *Parser) parseFilter(cur *ListNode) error {
0000000000000000000000000000000000000000;;		p.pos += len("[?(")
0000000000000000000000000000000000000000;;		p.consumeText()
0000000000000000000000000000000000000000;;		begin := false
0000000000000000000000000000000000000000;;		end := false
0000000000000000000000000000000000000000;;		var pair rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r := p.next()
0000000000000000000000000000000000000000;;			switch r {
0000000000000000000000000000000000000000;;			case eof, '\n':
0000000000000000000000000000000000000000;;				return fmt.Errorf("unterminated filter")
0000000000000000000000000000000000000000;;			case '"', '\'':
0000000000000000000000000000000000000000;;				if begin == false {
0000000000000000000000000000000000000000;;					//save the paired rune
0000000000000000000000000000000000000000;;					begin = true
0000000000000000000000000000000000000000;;					pair = r
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				//only add when met paired rune
0000000000000000000000000000000000000000;;				if p.input[p.pos-2] != '\\' && r == pair {
0000000000000000000000000000000000000000;;					end = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ')':
0000000000000000000000000000000000000000;;				//in rightParser below quotes only appear zero or once
0000000000000000000000000000000000000000;;				//and must be paired at the beginning and end
0000000000000000000000000000000000000000;;				if begin == end {
0000000000000000000000000000000000000000;;					break Loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.next() != ']' {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unclosed array expect ]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reg := regexp.MustCompile(`^([^!<>=]+)([!<>=]+)(.+?)$`)
0000000000000000000000000000000000000000;;		text := p.consumeText()
0000000000000000000000000000000000000000;;		text = string(text[:len(text)-2])
0000000000000000000000000000000000000000;;		value := reg.FindStringSubmatch(text)
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			parser, err := parseAction("text", text)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cur.append(newFilter(parser.Root, newList(), "exists"))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			leftParser, err := parseAction("left", value[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rightParser, err := parseAction("right", value[3])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cur.append(newFilter(leftParser.Root, rightParser.Root, value[2]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseQuote unquotes string inside double or single quote
0000000000000000000000000000000000000000;;	func (p *Parser) parseQuote(cur *ListNode, end rune) error {
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch p.next() {
0000000000000000000000000000000000000000;;			case eof, '\n':
0000000000000000000000000000000000000000;;				return fmt.Errorf("unterminated quoted string")
0000000000000000000000000000000000000000;;			case end:
0000000000000000000000000000000000000000;;				//if it's not escape break the Loop
0000000000000000000000000000000000000000;;				if p.input[p.pos-2] != '\\' {
0000000000000000000000000000000000000000;;					break Loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := p.consumeText()
0000000000000000000000000000000000000000;;		s, err := UnquoteExtend(value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unquote string %s error %v", value, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cur.append(newText(s))
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseField scans a field until a terminator
0000000000000000000000000000000000000000;;	func (p *Parser) parseField(cur *ListNode) error {
0000000000000000000000000000000000000000;;		p.consumeText()
0000000000000000000000000000000000000000;;		for p.advance() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := p.consumeText()
0000000000000000000000000000000000000000;;		if value == "*" {
0000000000000000000000000000000000000000;;			cur.append(newWildcard())
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cur.append(newField(strings.Replace(value, "\\", "", -1)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.parseInsideAction(cur)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// advance scans until next non-escaped terminator
0000000000000000000000000000000000000000;;	func (p *Parser) advance() bool {
0000000000000000000000000000000000000000;;		r := p.next()
0000000000000000000000000000000000000000;;		if r == '\\' {
0000000000000000000000000000000000000000;;			p.next()
0000000000000000000000000000000000000000;;		} else if isTerminator(r) {
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTerminator reports whether the input is at valid termination character to appear after an identifier.
0000000000000000000000000000000000000000;;	func isTerminator(r rune) bool {
0000000000000000000000000000000000000000;;		if isSpace(r) || isEndOfLine(r) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch r {
0000000000000000000000000000000000000000;;		case eof, '.', ',', '[', ']', '$', '@', '{', '}':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSpace reports whether r is a space character.
0000000000000000000000000000000000000000;;	func isSpace(r rune) bool {
0000000000000000000000000000000000000000;;		return r == ' ' || r == '\t'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isEndOfLine reports whether r is an end-of-line character.
0000000000000000000000000000000000000000;;	func isEndOfLine(r rune) bool {
0000000000000000000000000000000000000000;;		return r == '\r' || r == '\n'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isAlphaNumeric reports whether r is an alphabetic, digit, or underscore.
0000000000000000000000000000000000000000;;	func isAlphaNumeric(r rune) bool {
0000000000000000000000000000000000000000;;		return r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isBool reports whether s is a boolean value.
0000000000000000000000000000000000000000;;	func isBool(s string) bool {
0000000000000000000000000000000000000000;;		return s == "true" || s == "false"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//UnquoteExtend is almost same as strconv.Unquote(), but it support parse single quotes as a string
0000000000000000000000000000000000000000;;	func UnquoteExtend(s string) (string, error) {
0000000000000000000000000000000000000000;;		n := len(s)
0000000000000000000000000000000000000000;;		if n < 2 {
0000000000000000000000000000000000000000;;			return "", ErrSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quote := s[0]
0000000000000000000000000000000000000000;;		if quote != s[n-1] {
0000000000000000000000000000000000000000;;			return "", ErrSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = s[1 : n-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if quote != '"' && quote != '\'' {
0000000000000000000000000000000000000000;;			return "", ErrSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it trivial?  Avoid allocation.
0000000000000000000000000000000000000000;;		if !contains(s, '\\') && !contains(s, quote) {
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var runeTmp [utf8.UTFMax]byte
0000000000000000000000000000000000000000;;		buf := make([]byte, 0, 3*len(s)/2) // Try to avoid more allocations.
0000000000000000000000000000000000000000;;		for len(s) > 0 {
0000000000000000000000000000000000000000;;			c, multibyte, ss, err := strconv.UnquoteChar(s, quote)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = ss
0000000000000000000000000000000000000000;;			if c < utf8.RuneSelf || !multibyte {
0000000000000000000000000000000000000000;;				buf = append(buf, byte(c))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n := utf8.EncodeRune(runeTmp[:], c)
0000000000000000000000000000000000000000;;				buf = append(buf, runeTmp[:n]...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(s string, c byte) bool {
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if s[i] == c {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
