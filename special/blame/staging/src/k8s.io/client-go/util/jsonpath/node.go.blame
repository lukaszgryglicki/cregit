0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c409b014ea1f485f8bb92a9a6eadc2cc636553b1;staging/src/k8s.io/client-go/pkg/util/jsonpath/node.go[staging/src/k8s.io/client-go/pkg/util/jsonpath/node.go][staging/src/k8s.io/client-go/util/jsonpath/node.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonpath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeType identifies the type of a parse tree node.
0000000000000000000000000000000000000000;;	type NodeType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns itself and provides an easy default implementation
0000000000000000000000000000000000000000;;	func (t NodeType) Type() NodeType {
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t NodeType) String() string {
0000000000000000000000000000000000000000;;		return NodeTypeName[t]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NodeText NodeType = iota
0000000000000000000000000000000000000000;;		NodeArray
0000000000000000000000000000000000000000;;		NodeList
0000000000000000000000000000000000000000;;		NodeField
0000000000000000000000000000000000000000;;		NodeIdentifier
0000000000000000000000000000000000000000;;		NodeFilter
0000000000000000000000000000000000000000;;		NodeInt
0000000000000000000000000000000000000000;;		NodeFloat
0000000000000000000000000000000000000000;;		NodeWildcard
0000000000000000000000000000000000000000;;		NodeRecursive
0000000000000000000000000000000000000000;;		NodeUnion
0000000000000000000000000000000000000000;;		NodeBool
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var NodeTypeName = map[NodeType]string{
0000000000000000000000000000000000000000;;		NodeText:       "NodeText",
0000000000000000000000000000000000000000;;		NodeArray:      "NodeArray",
0000000000000000000000000000000000000000;;		NodeList:       "NodeList",
0000000000000000000000000000000000000000;;		NodeField:      "NodeField",
0000000000000000000000000000000000000000;;		NodeIdentifier: "NodeIdentifier",
0000000000000000000000000000000000000000;;		NodeFilter:     "NodeFilter",
0000000000000000000000000000000000000000;;		NodeInt:        "NodeInt",
0000000000000000000000000000000000000000;;		NodeFloat:      "NodeFloat",
0000000000000000000000000000000000000000;;		NodeWildcard:   "NodeWildcard",
0000000000000000000000000000000000000000;;		NodeRecursive:  "NodeRecursive",
0000000000000000000000000000000000000000;;		NodeUnion:      "NodeUnion",
0000000000000000000000000000000000000000;;		NodeBool:       "NodeBool",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Node interface {
0000000000000000000000000000000000000000;;		Type() NodeType
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListNode holds a sequence of nodes.
0000000000000000000000000000000000000000;;	type ListNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Nodes []Node // The element nodes in lexical order.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newList() *ListNode {
0000000000000000000000000000000000000000;;		return &ListNode{NodeType: NodeList}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *ListNode) append(n Node) {
0000000000000000000000000000000000000000;;		l.Nodes = append(l.Nodes, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *ListNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s", l.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TextNode holds plain text.
0000000000000000000000000000000000000000;;	type TextNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Text string // The text; may span newlines.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newText(text string) *TextNode {
0000000000000000000000000000000000000000;;		return &TextNode{NodeType: NodeText, Text: text}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TextNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %s", t.Type(), t.Text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FieldNode holds field of struct
0000000000000000000000000000000000000000;;	type FieldNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newField(value string) *FieldNode {
0000000000000000000000000000000000000000;;		return &FieldNode{NodeType: NodeField, Value: value}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FieldNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %s", f.Type(), f.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IdentifierNode holds an identifier
0000000000000000000000000000000000000000;;	type IdentifierNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newIdentifier(value string) *IdentifierNode {
0000000000000000000000000000000000000000;;		return &IdentifierNode{
0000000000000000000000000000000000000000;;			NodeType: NodeIdentifier,
0000000000000000000000000000000000000000;;			Name:     value,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *IdentifierNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %s", f.Type(), f.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParamsEntry holds param information for ArrayNode
0000000000000000000000000000000000000000;;	type ParamsEntry struct {
0000000000000000000000000000000000000000;;		Value int
0000000000000000000000000000000000000000;;		Known bool //whether the value is known when parse it
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ArrayNode holds start, end, step information for array index selection
0000000000000000000000000000000000000000;;	type ArrayNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Params [3]ParamsEntry //start, end, step
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newArray(params [3]ParamsEntry) *ArrayNode {
0000000000000000000000000000000000000000;;		return &ArrayNode{
0000000000000000000000000000000000000000;;			NodeType: NodeArray,
0000000000000000000000000000000000000000;;			Params:   params,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *ArrayNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %v", a.Type(), a.Params)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterNode holds operand and operator information for filter
0000000000000000000000000000000000000000;;	type FilterNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Left     *ListNode
0000000000000000000000000000000000000000;;		Right    *ListNode
0000000000000000000000000000000000000000;;		Operator string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFilter(left, right *ListNode, operator string) *FilterNode {
0000000000000000000000000000000000000000;;		return &FilterNode{
0000000000000000000000000000000000000000;;			NodeType: NodeFilter,
0000000000000000000000000000000000000000;;			Left:     left,
0000000000000000000000000000000000000000;;			Right:    right,
0000000000000000000000000000000000000000;;			Operator: operator,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FilterNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %s %s %s", f.Type(), f.Left, f.Operator, f.Right)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntNode holds integer value
0000000000000000000000000000000000000000;;	type IntNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Value int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInt(num int) *IntNode {
0000000000000000000000000000000000000000;;		return &IntNode{NodeType: NodeInt, Value: num}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *IntNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %d", i.Type(), i.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FloatNode holds float value
0000000000000000000000000000000000000000;;	type FloatNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Value float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFloat(num float64) *FloatNode {
0000000000000000000000000000000000000000;;		return &FloatNode{NodeType: NodeFloat, Value: num}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *FloatNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %f", i.Type(), i.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WildcardNode means a wildcard
0000000000000000000000000000000000000000;;	type WildcardNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWildcard() *WildcardNode {
0000000000000000000000000000000000000000;;		return &WildcardNode{NodeType: NodeWildcard}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *WildcardNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s", i.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecursiveNode means a recursive descent operator
0000000000000000000000000000000000000000;;	type RecursiveNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRecursive() *RecursiveNode {
0000000000000000000000000000000000000000;;		return &RecursiveNode{NodeType: NodeRecursive}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RecursiveNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s", r.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnionNode is union of ListNode
0000000000000000000000000000000000000000;;	type UnionNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Nodes []*ListNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newUnion(nodes []*ListNode) *UnionNode {
0000000000000000000000000000000000000000;;		return &UnionNode{NodeType: NodeUnion, Nodes: nodes}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnionNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s", u.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolNode holds bool value
0000000000000000000000000000000000000000;;	type BoolNode struct {
0000000000000000000000000000000000000000;;		NodeType
0000000000000000000000000000000000000000;;		Value bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBool(value bool) *BoolNode {
0000000000000000000000000000000000000000;;		return &BoolNode{NodeType: NodeBool, Value: value}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BoolNode) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %t", b.Type(), b.Value)
0000000000000000000000000000000000000000;;	}
