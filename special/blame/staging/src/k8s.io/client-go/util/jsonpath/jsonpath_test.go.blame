0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
884fe0568af7432b15e24074ce4f07f5ee39181e;pkg/util/jsonpath/jsonpath_test.go[pkg/util/jsonpath/jsonpath_test.go][staging/src/k8s.io/client-go/util/jsonpath/jsonpath_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonpath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jsonpathTest struct {
0000000000000000000000000000000000000000;;		name     string
0000000000000000000000000000000000000000;;		template string
0000000000000000000000000000000000000000;;		input    interface{}
0000000000000000000000000000000000000000;;		expect   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testJSONPath(tests []jsonpathTest, allowMissingKeys bool, t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			j := New(test.name)
0000000000000000000000000000000000000000;;			j.AllowMissingKeys(allowMissingKeys)
0000000000000000000000000000000000000000;;			err := j.Parse(test.template)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, parse %s error %v", test.name, test.template, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			err = j.Execute(buf, test.input)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, execute error %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out := buf.String()
0000000000000000000000000000000000000000;;			if out != test.expect {
0000000000000000000000000000000000000000;;				t.Errorf(`in %s, expect to get "%s", got "%s"`, test.name, test.expect, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testJSONPathSortOutput test cases related to map, the results may print in random order
0000000000000000000000000000000000000000;;	func testJSONPathSortOutput(tests []jsonpathTest, t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			j := New(test.name)
0000000000000000000000000000000000000000;;			err := j.Parse(test.template)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, parse %s error %v", test.name, test.template, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			err = j.Execute(buf, test.input)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, execute error %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out := buf.String()
0000000000000000000000000000000000000000;;			//since map is visited in random order, we need to sort the results.
0000000000000000000000000000000000000000;;			sortedOut := strings.Fields(out)
0000000000000000000000000000000000000000;;			sort.Strings(sortedOut)
0000000000000000000000000000000000000000;;			sortedExpect := strings.Fields(test.expect)
0000000000000000000000000000000000000000;;			sort.Strings(sortedExpect)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(sortedOut, sortedExpect) {
0000000000000000000000000000000000000000;;				t.Errorf(`in %s, expect to get "%s", got "%s"`, test.name, test.expect, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testFailJSONPath(tests []jsonpathTest, t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			j := New(test.name)
0000000000000000000000000000000000000000;;			err := j.Parse(test.template)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, parse %s error %v", test.name, test.template, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			err = j.Execute(buf, test.input)
0000000000000000000000000000000000000000;;			var out string
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				out = "nil"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out = err.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out != test.expect {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, expect to get error %q, got %q", test.name, test.expect, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type book struct {
0000000000000000000000000000000000000000;;		Category string
0000000000000000000000000000000000000000;;		Author   string
0000000000000000000000000000000000000000;;		Title    string
0000000000000000000000000000000000000000;;		Price    float32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b book) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("{Category: %s, Author: %s, Title: %s, Price: %v}", b.Category, b.Author, b.Title, b.Price)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bicycle struct {
0000000000000000000000000000000000000000;;		Color string
0000000000000000000000000000000000000000;;		Price float32
0000000000000000000000000000000000000000;;		IsNew bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type empName string
0000000000000000000000000000000000000000;;	type job string
0000000000000000000000000000000000000000;;	type store struct {
0000000000000000000000000000000000000000;;		Book      []book
0000000000000000000000000000000000000000;;		Bicycle   []bicycle
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Labels    map[string]int
0000000000000000000000000000000000000000;;		Employees map[empName]job
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStructInput(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storeData := store{
0000000000000000000000000000000000000000;;			Name: "jsonpath",
0000000000000000000000000000000000000000;;			Book: []book{
0000000000000000000000000000000000000000;;				{"reference", "Nigel Rees", "Sayings of the Centurey", 8.95},
0000000000000000000000000000000000000000;;				{"fiction", "Evelyn Waugh", "Sword of Honour", 12.99},
0000000000000000000000000000000000000000;;				{"fiction", "Herman Melville", "Moby Dick", 8.99},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Bicycle: []bicycle{
0000000000000000000000000000000000000000;;				{"red", 19.95, true},
0000000000000000000000000000000000000000;;				{"green", 20.01, false},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Labels: map[string]int{
0000000000000000000000000000000000000000;;				"engieer":  10,
0000000000000000000000000000000000000000;;				"web/html": 15,
0000000000000000000000000000000000000000;;				"k8s-app":  20,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Employees: map[empName]job{
0000000000000000000000000000000000000000;;				"jason": "manager",
0000000000000000000000000000000000000000;;				"dan":   "clerk",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storeTests := []jsonpathTest{
0000000000000000000000000000000000000000;;			{"plain", "hello jsonpath", nil, "hello jsonpath"},
0000000000000000000000000000000000000000;;			{"recursive", "{..}", []int{1, 2, 3}, "[1 2 3]"},
0000000000000000000000000000000000000000;;			{"filter", "{[?(@<5)]}", []int{2, 6, 3, 7}, "2 3"},
0000000000000000000000000000000000000000;;			{"quote", `{"{"}`, nil, "{"},
0000000000000000000000000000000000000000;;			{"union", "{[1,3,4]}", []int{0, 1, 2, 3, 4}, "1 3 4"},
0000000000000000000000000000000000000000;;			{"array", "{[0:2]}", []string{"Monday", "Tudesday"}, "Monday Tudesday"},
0000000000000000000000000000000000000000;;			{"variable", "hello {.Name}", storeData, "hello jsonpath"},
0000000000000000000000000000000000000000;;			{"dict/", "{$.Labels.web/html}", storeData, "15"},
0000000000000000000000000000000000000000;;			{"dict/", "{$.Employees.jason}", storeData, "manager"},
0000000000000000000000000000000000000000;;			{"dict/", "{$.Employees.dan}", storeData, "clerk"},
0000000000000000000000000000000000000000;;			{"dict-", "{.Labels.k8s-app}", storeData, "20"},
0000000000000000000000000000000000000000;;			{"nest", "{.Bicycle[*].Color}", storeData, "red green"},
0000000000000000000000000000000000000000;;			{"allarray", "{.Book[*].Author}", storeData, "Nigel Rees Evelyn Waugh Herman Melville"},
0000000000000000000000000000000000000000;;			{"allfileds", "{.Bicycle.*}", storeData, "{red 19.95 true} {green 20.01 false}"},
0000000000000000000000000000000000000000;;			{"recurfileds", "{..Price}", storeData, "8.95 12.99 8.99 19.95 20.01"},
0000000000000000000000000000000000000000;;			{"lastarray", "{.Book[-1:]}", storeData,
0000000000000000000000000000000000000000;;				"{Category: fiction, Author: Herman Melville, Title: Moby Dick, Price: 8.99}"},
0000000000000000000000000000000000000000;;			{"recurarray", "{..Book[2]}", storeData,
0000000000000000000000000000000000000000;;				"{Category: fiction, Author: Herman Melville, Title: Moby Dick, Price: 8.99}"},
0000000000000000000000000000000000000000;;			{"bool", "{.Bicycle[?(@.IsNew==true)]}", storeData, "{red 19.95 true}"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testJSONPath(storeTests, false, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		missingKeyTests := []jsonpathTest{
0000000000000000000000000000000000000000;;			{"nonexistent field", "{.hello}", storeData, ""},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testJSONPath(missingKeyTests, true, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failStoreTests := []jsonpathTest{
0000000000000000000000000000000000000000;;			{"invalid identifier", "{hello}", storeData, "unrecognized identifier hello"},
0000000000000000000000000000000000000000;;			{"nonexistent field", "{.hello}", storeData, "hello is not found"},
0000000000000000000000000000000000000000;;			{"invalid array", "{.Labels[0]}", storeData, "map[string]int is not array or slice"},
0000000000000000000000000000000000000000;;			{"invalid filter operator", "{.Book[?(@.Price<>10)]}", storeData, "unrecognized filter operator <>"},
0000000000000000000000000000000000000000;;			{"redundent end", "{range .Labels.*}{@}{end}{end}", storeData, "not in range, nothing to end"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testFailJSONPath(failStoreTests, t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJSONInput(t *testing.T) {
0000000000000000000000000000000000000000;;		var pointsJSON = []byte(`[
0000000000000000000000000000000000000000;;			{"id": "i1", "x":4, "y":-5},
0000000000000000000000000000000000000000;;			{"id": "i2", "x":-2, "y":-5, "z":1},
0000000000000000000000000000000000000000;;			{"id": "i3", "x":  8, "y":  3 },
0000000000000000000000000000000000000000;;			{"id": "i4", "x": -6, "y": -1 },
0000000000000000000000000000000000000000;;			{"id": "i5", "x":  0, "y":  2, "z": 1 },
0000000000000000000000000000000000000000;;			{"id": "i6", "x":  1, "y":  4 }
0000000000000000000000000000000000000000;;		]`)
0000000000000000000000000000000000000000;;		var pointsData interface{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(pointsJSON, &pointsData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pointsTests := []jsonpathTest{
0000000000000000000000000000000000000000;;			{"exists filter", "{[?(@.z)].id}", pointsData, "i2 i5"},
0000000000000000000000000000000000000000;;			{"bracket key", "{[0]['id']}", pointsData, "i1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testJSONPath(pointsTests, false, t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestKubernetes tests some use cases from kubernetes
0000000000000000000000000000000000000000;;	func TestKubernetes(t *testing.T) {
0000000000000000000000000000000000000000;;		var input = []byte(`{
0000000000000000000000000000000000000000;;		  "kind": "List",
0000000000000000000000000000000000000000;;		  "items":[
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;			  "kind":"None",
0000000000000000000000000000000000000000;;			  "metadata":{
0000000000000000000000000000000000000000;;			    "name":"127.0.0.1",
0000000000000000000000000000000000000000;;				"labels":{
0000000000000000000000000000000000000000;;				  "kubernetes.io/hostname":"127.0.0.1"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			  },
0000000000000000000000000000000000000000;;			  "status":{
0000000000000000000000000000000000000000;;				"capacity":{"cpu":"4"},
0000000000000000000000000000000000000000;;				"ready": true,
0000000000000000000000000000000000000000;;				"addresses":[{"type": "LegacyHostIP", "address":"127.0.0.1"}]
0000000000000000000000000000000000000000;;			  }
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;			  "kind":"None",
0000000000000000000000000000000000000000;;			  "metadata":{
0000000000000000000000000000000000000000;;				"name":"127.0.0.2",
0000000000000000000000000000000000000000;;				"labels":{
0000000000000000000000000000000000000000;;				  "kubernetes.io/hostname":"127.0.0.2"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			  },
0000000000000000000000000000000000000000;;			  "status":{
0000000000000000000000000000000000000000;;				"capacity":{"cpu":"8"},
0000000000000000000000000000000000000000;;				"ready": false,
0000000000000000000000000000000000000000;;				"addresses":[
0000000000000000000000000000000000000000;;				  {"type": "LegacyHostIP", "address":"127.0.0.2"},
0000000000000000000000000000000000000000;;				  {"type": "another", "address":"127.0.0.3"}
0000000000000000000000000000000000000000;;				]
0000000000000000000000000000000000000000;;			  }
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		  ],
0000000000000000000000000000000000000000;;		  "users":[
0000000000000000000000000000000000000000;;		    {
0000000000000000000000000000000000000000;;		      "name": "myself",
0000000000000000000000000000000000000000;;		      "user": {}
0000000000000000000000000000000000000000;;		    },
0000000000000000000000000000000000000000;;		    {
0000000000000000000000000000000000000000;;		      "name": "e2e",
0000000000000000000000000000000000000000;;		      "user": {"username": "admin", "password": "secret"}
0000000000000000000000000000000000000000;;		  	}
0000000000000000000000000000000000000000;;		  ]
0000000000000000000000000000000000000000;;		}`)
0000000000000000000000000000000000000000;;		var nodesData interface{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(input, &nodesData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodesTests := []jsonpathTest{
0000000000000000000000000000000000000000;;			{"range item", `{range .items[*]}{.metadata.name}, {end}{.kind}`, nodesData, "127.0.0.1, 127.0.0.2, List"},
0000000000000000000000000000000000000000;;			{"range item with quote", `{range .items[*]}{.metadata.name}{"\t"}{end}`, nodesData, "127.0.0.1\t127.0.0.2\t"},
0000000000000000000000000000000000000000;;			{"range addresss", `{.items[*].status.addresses[*].address}`, nodesData,
0000000000000000000000000000000000000000;;				"127.0.0.1 127.0.0.2 127.0.0.3"},
0000000000000000000000000000000000000000;;			{"double range", `{range .items[*]}{range .status.addresses[*]}{.address}, {end}{end}`, nodesData,
0000000000000000000000000000000000000000;;				"127.0.0.1, 127.0.0.2, 127.0.0.3, "},
0000000000000000000000000000000000000000;;			{"item name", `{.items[*].metadata.name}`, nodesData, "127.0.0.1 127.0.0.2"},
0000000000000000000000000000000000000000;;			{"union nodes capacity", `{.items[*]['metadata.name', 'status.capacity']}`, nodesData,
0000000000000000000000000000000000000000;;				"127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]"},
0000000000000000000000000000000000000000;;			{"range nodes capacity", `{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}`, nodesData,
0000000000000000000000000000000000000000;;				"[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]] "},
0000000000000000000000000000000000000000;;			{"user password", `{.users[?(@.name=="e2e")].user.password}`, &nodesData, "secret"},
0000000000000000000000000000000000000000;;			{"hostname", `{.items[0].metadata.labels.kubernetes\.io/hostname}`, &nodesData, "127.0.0.1"},
0000000000000000000000000000000000000000;;			{"hostname filter", `{.items[?(@.metadata.labels.kubernetes\.io/hostname=="127.0.0.1")].kind}`, &nodesData, "None"},
0000000000000000000000000000000000000000;;			{"bool item", `{.items[?(@..ready==true)].metadata.name}`, &nodesData, "127.0.0.1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testJSONPath(nodesTests, false, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		randomPrintOrderTests := []jsonpathTest{
0000000000000000000000000000000000000000;;			{"recursive name", "{..name}", nodesData, `127.0.0.1 127.0.0.2 myself e2e`},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testJSONPathSortOutput(randomPrintOrderTests, t)
0000000000000000000000000000000000000000;;	}
