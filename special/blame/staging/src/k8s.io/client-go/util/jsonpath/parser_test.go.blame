0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
884fe0568af7432b15e24074ce4f07f5ee39181e;pkg/util/jsonpath/parser_test.go[pkg/util/jsonpath/parser_test.go][staging/src/k8s.io/client-go/util/jsonpath/parser_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonpath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parserTest struct {
0000000000000000000000000000000000000000;;		name        string
0000000000000000000000000000000000000000;;		text        string
0000000000000000000000000000000000000000;;		nodes       []Node
0000000000000000000000000000000000000000;;		shouldError bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var parserTests = []parserTest{
0000000000000000000000000000000000000000;;		{"plain", `hello jsonpath`, []Node{newText("hello jsonpath")}, false},
0000000000000000000000000000000000000000;;		{"variable", `hello {.jsonpath}`,
0000000000000000000000000000000000000000;;			[]Node{newText("hello "), newList(), newField("jsonpath")}, false},
0000000000000000000000000000000000000000;;		{"arrayfiled", `hello {['jsonpath']}`,
0000000000000000000000000000000000000000;;			[]Node{newText("hello "), newList(), newField("jsonpath")}, false},
0000000000000000000000000000000000000000;;		{"quote", `{"{"}`, []Node{newList(), newText("{")}, false},
0000000000000000000000000000000000000000;;		{"array", `{[1:3]}`, []Node{newList(),
0000000000000000000000000000000000000000;;			newArray([3]ParamsEntry{{1, true}, {3, true}, {0, false}})}, false},
0000000000000000000000000000000000000000;;		{"allarray", `{.book[*].author}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newField("book"),
0000000000000000000000000000000000000000;;				newArray([3]ParamsEntry{{0, false}, {0, false}, {0, false}}), newField("author")}, false},
0000000000000000000000000000000000000000;;		{"wildcard", `{.bicycle.*}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newField("bicycle"), newWildcard()}, false},
0000000000000000000000000000000000000000;;		{"filter", `{[?(@.price<3)]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "<"),
0000000000000000000000000000000000000000;;				newList(), newField("price"), newList(), newInt(3)}, false},
0000000000000000000000000000000000000000;;		{"recursive", `{..}`, []Node{newList(), newRecursive()}, false},
0000000000000000000000000000000000000000;;		{"recurField", `{..price}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newRecursive(), newField("price")}, false},
0000000000000000000000000000000000000000;;		{"arraydict", `{['book.price']}`, []Node{newList(),
0000000000000000000000000000000000000000;;			newField("book"), newField("price"),
0000000000000000000000000000000000000000;;		}, false},
0000000000000000000000000000000000000000;;		{"union", `{['bicycle.price', 3, 'book.price']}`, []Node{newList(), newUnion([]*ListNode{}),
0000000000000000000000000000000000000000;;			newList(), newField("bicycle"), newField("price"),
0000000000000000000000000000000000000000;;			newList(), newArray([3]ParamsEntry{{3, true}, {4, true}, {0, false}}),
0000000000000000000000000000000000000000;;			newList(), newField("book"), newField("price"),
0000000000000000000000000000000000000000;;		}, false},
0000000000000000000000000000000000000000;;		{"range", `{range .items}{.name},{end}`, []Node{
0000000000000000000000000000000000000000;;			newList(), newIdentifier("range"), newField("items"),
0000000000000000000000000000000000000000;;			newList(), newField("name"), newText(","),
0000000000000000000000000000000000000000;;			newList(), newIdentifier("end"),
0000000000000000000000000000000000000000;;		}, false},
0000000000000000000000000000000000000000;;		{"malformat input", `{\\\}`, []Node{}, true},
0000000000000000000000000000000000000000;;		{"paired parentheses in quotes", `{[?(@.status.nodeInfo.osImage == "()")]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("status"), newField("nodeInfo"), newField("osImage"), newList(), newText("()")}, false},
0000000000000000000000000000000000000000;;		{"paired parentheses in double quotes and with double quotes escape", `{[?(@.status.nodeInfo.osImage == "(\"\")")]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("status"), newField("nodeInfo"), newField("osImage"), newList(), newText("(\"\")")}, false},
0000000000000000000000000000000000000000;;		{"unregular parentheses in double quotes", `{[?(@.test == "())(")]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("test"), newList(), newText("())(")}, false},
0000000000000000000000000000000000000000;;		{"plain text in single quotes", `{[?(@.status.nodeInfo.osImage == 'Linux')]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("status"), newField("nodeInfo"), newField("osImage"), newList(), newText("Linux")}, false},
0000000000000000000000000000000000000000;;		{"test filter suffix", `{[?(@.status.nodeInfo.osImage == "{[()]}")]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("status"), newField("nodeInfo"), newField("osImage"), newList(), newText("{[()]}")}, false},
0000000000000000000000000000000000000000;;		{"double inside single", `{[?(@.status.nodeInfo.osImage == "''")]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("status"), newField("nodeInfo"), newField("osImage"), newList(), newText("''")}, false},
0000000000000000000000000000000000000000;;		{"single inside double", `{[?(@.status.nodeInfo.osImage == '""')]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("status"), newField("nodeInfo"), newField("osImage"), newList(), newText("\"\"")}, false},
0000000000000000000000000000000000000000;;		{"single containing escaped single", `{[?(@.status.nodeInfo.osImage == '\\\'')]}`,
0000000000000000000000000000000000000000;;			[]Node{newList(), newFilter(newList(), newList(), "=="), newList(), newField("status"), newField("nodeInfo"), newField("osImage"), newList(), newText("\\'")}, false},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func collectNode(nodes []Node, cur Node) []Node {
0000000000000000000000000000000000000000;;		nodes = append(nodes, cur)
0000000000000000000000000000000000000000;;		switch cur.Type() {
0000000000000000000000000000000000000000;;		case NodeList:
0000000000000000000000000000000000000000;;			for _, node := range cur.(*ListNode).Nodes {
0000000000000000000000000000000000000000;;				nodes = collectNode(nodes, node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case NodeFilter:
0000000000000000000000000000000000000000;;			nodes = collectNode(nodes, cur.(*FilterNode).Left)
0000000000000000000000000000000000000000;;			nodes = collectNode(nodes, cur.(*FilterNode).Right)
0000000000000000000000000000000000000000;;		case NodeUnion:
0000000000000000000000000000000000000000;;			for _, node := range cur.(*UnionNode).Nodes {
0000000000000000000000000000000000000000;;				nodes = collectNode(nodes, node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParser(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range parserTests {
0000000000000000000000000000000000000000;;			parser, err := Parse(test.name, test.text)
0000000000000000000000000000000000000000;;			if test.shouldError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected non-error when parsing %s", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("parse %s error %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := collectNode([]Node{}, parser.Root)[1:]
0000000000000000000000000000000000000000;;			if len(result) != len(test.nodes) {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, expect to get %d nodes, got %d nodes", test.name, len(test.nodes), len(result))
0000000000000000000000000000000000000000;;				t.Error(result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, expect := range test.nodes {
0000000000000000000000000000000000000000;;				if result[i].String() != expect.String() {
0000000000000000000000000000000000000000;;					t.Errorf("in %s, %dth node, expect %v, got %v", test.name, i, expect, result[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type failParserTest struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		text string
0000000000000000000000000000000000000000;;		err  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFailParser(t *testing.T) {
0000000000000000000000000000000000000000;;		failParserTests := []failParserTest{
0000000000000000000000000000000000000000;;			{"unclosed action", "{.hello", "unclosed action"},
0000000000000000000000000000000000000000;;			{"unrecognized character", "{*}", "unrecognized character in action: U+002A '*'"},
0000000000000000000000000000000000000000;;			{"invalid number", "{+12.3.0}", "cannot parse number +12.3.0"},
0000000000000000000000000000000000000000;;			{"unterminated array", "{[1}", "unterminated array"},
0000000000000000000000000000000000000000;;			{"invalid index", "{[::-1]}", "invalid array index ::-1"},
0000000000000000000000000000000000000000;;			{"unterminated filter", "{[?(.price]}", "unterminated filter"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range failParserTests {
0000000000000000000000000000000000000000;;			_, err := Parse(test.name, test.text)
0000000000000000000000000000000000000000;;			var out string
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				out = "nil"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out = err.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out != test.err {
0000000000000000000000000000000000000000;;				t.Errorf("in %s, expect to get error %v, got %v", test.name, test.err, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
