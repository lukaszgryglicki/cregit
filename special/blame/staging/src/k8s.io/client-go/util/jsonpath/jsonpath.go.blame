0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c409b014ea1f485f8bb92a9a6eadc2cc636553b1;staging/src/k8s.io/client-go/pkg/util/jsonpath/jsonpath.go[staging/src/k8s.io/client-go/pkg/util/jsonpath/jsonpath.go][staging/src/k8s.io/client-go/util/jsonpath/jsonpath.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonpath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/third_party/forked/golang/template"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JSONPath struct {
0000000000000000000000000000000000000000;;		name       string
0000000000000000000000000000000000000000;;		parser     *Parser
0000000000000000000000000000000000000000;;		stack      [][]reflect.Value //push and pop values in different scopes
0000000000000000000000000000000000000000;;		cur        []reflect.Value   //current scope values
0000000000000000000000000000000000000000;;		beginRange int
0000000000000000000000000000000000000000;;		inRange    int
0000000000000000000000000000000000000000;;		endRange   int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowMissingKeys bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(name string) *JSONPath {
0000000000000000000000000000000000000000;;		return &JSONPath{
0000000000000000000000000000000000000000;;			name:       name,
0000000000000000000000000000000000000000;;			beginRange: 0,
0000000000000000000000000000000000000000;;			inRange:    0,
0000000000000000000000000000000000000000;;			endRange:   0,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowMissingKeys allows a caller to specify whether they want an error if a field or map key
0000000000000000000000000000000000000000;;	// cannot be located, or simply an empty result. The receiver is returned for chaining.
0000000000000000000000000000000000000000;;	func (j *JSONPath) AllowMissingKeys(allow bool) *JSONPath {
0000000000000000000000000000000000000000;;		j.allowMissingKeys = allow
0000000000000000000000000000000000000000;;		return j
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parse the given template, return error
0000000000000000000000000000000000000000;;	func (j *JSONPath) Parse(text string) (err error) {
0000000000000000000000000000000000000000;;		j.parser, err = Parse(j.name, text)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Execute bounds data into template and write the result
0000000000000000000000000000000000000000;;	func (j *JSONPath) Execute(wr io.Writer, data interface{}) error {
0000000000000000000000000000000000000000;;		fullResults, err := j.FindResults(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ix := range fullResults {
0000000000000000000000000000000000000000;;			if err := j.PrintResults(wr, fullResults[ix]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *JSONPath) FindResults(data interface{}) ([][]reflect.Value, error) {
0000000000000000000000000000000000000000;;		if j.parser == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is an incomplete jsonpath template", j.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j.cur = []reflect.Value{reflect.ValueOf(data)}
0000000000000000000000000000000000000000;;		nodes := j.parser.Root.Nodes
0000000000000000000000000000000000000000;;		fullResult := [][]reflect.Value{}
0000000000000000000000000000000000000000;;		for i := 0; i < len(nodes); i++ {
0000000000000000000000000000000000000000;;			node := nodes[i]
0000000000000000000000000000000000000000;;			results, err := j.walk(j.cur, node)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//encounter an end node, break the current block
0000000000000000000000000000000000000000;;			if j.endRange > 0 && j.endRange <= j.inRange {
0000000000000000000000000000000000000000;;				j.endRange -= 1
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//encounter a range node, start a range loop
0000000000000000000000000000000000000000;;			if j.beginRange > 0 {
0000000000000000000000000000000000000000;;				j.beginRange -= 1
0000000000000000000000000000000000000000;;				j.inRange += 1
0000000000000000000000000000000000000000;;				for k, value := range results {
0000000000000000000000000000000000000000;;					j.parser.Root.Nodes = nodes[i+1:]
0000000000000000000000000000000000000000;;					if k == len(results)-1 {
0000000000000000000000000000000000000000;;						j.inRange -= 1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					nextResults, err := j.FindResults(value.Interface())
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fullResult = append(fullResult, nextResults...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fullResult = append(fullResult, results)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fullResult, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintResults write the results into writer
0000000000000000000000000000000000000000;;	func (j *JSONPath) PrintResults(wr io.Writer, results []reflect.Value) error {
0000000000000000000000000000000000000000;;		for i, r := range results {
0000000000000000000000000000000000000000;;			text, err := j.evalToText(r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i != len(results)-1 {
0000000000000000000000000000000000000000;;				text = append(text, ' ')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err = wr.Write(text); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// walk visits tree rooted at the given node in DFS order
0000000000000000000000000000000000000000;;	func (j *JSONPath) walk(value []reflect.Value, node Node) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		switch node := node.(type) {
0000000000000000000000000000000000000000;;		case *ListNode:
0000000000000000000000000000000000000000;;			return j.evalList(value, node)
0000000000000000000000000000000000000000;;		case *TextNode:
0000000000000000000000000000000000000000;;			return []reflect.Value{reflect.ValueOf(node.Text)}, nil
0000000000000000000000000000000000000000;;		case *FieldNode:
0000000000000000000000000000000000000000;;			return j.evalField(value, node)
0000000000000000000000000000000000000000;;		case *ArrayNode:
0000000000000000000000000000000000000000;;			return j.evalArray(value, node)
0000000000000000000000000000000000000000;;		case *FilterNode:
0000000000000000000000000000000000000000;;			return j.evalFilter(value, node)
0000000000000000000000000000000000000000;;		case *IntNode:
0000000000000000000000000000000000000000;;			return j.evalInt(value, node)
0000000000000000000000000000000000000000;;		case *BoolNode:
0000000000000000000000000000000000000000;;			return j.evalBool(value, node)
0000000000000000000000000000000000000000;;		case *FloatNode:
0000000000000000000000000000000000000000;;			return j.evalFloat(value, node)
0000000000000000000000000000000000000000;;		case *WildcardNode:
0000000000000000000000000000000000000000;;			return j.evalWildcard(value, node)
0000000000000000000000000000000000000000;;		case *RecursiveNode:
0000000000000000000000000000000000000000;;			return j.evalRecursive(value, node)
0000000000000000000000000000000000000000;;		case *UnionNode:
0000000000000000000000000000000000000000;;			return j.evalUnion(value, node)
0000000000000000000000000000000000000000;;		case *IdentifierNode:
0000000000000000000000000000000000000000;;			return j.evalIdentifier(value, node)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return value, fmt.Errorf("unexpected Node %v", node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalInt evaluates IntNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalInt(input []reflect.Value, node *IntNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		result := make([]reflect.Value, len(input))
0000000000000000000000000000000000000000;;		for i := range input {
0000000000000000000000000000000000000000;;			result[i] = reflect.ValueOf(node.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalFloat evaluates FloatNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalFloat(input []reflect.Value, node *FloatNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		result := make([]reflect.Value, len(input))
0000000000000000000000000000000000000000;;		for i := range input {
0000000000000000000000000000000000000000;;			result[i] = reflect.ValueOf(node.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalBool evaluates BoolNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalBool(input []reflect.Value, node *BoolNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		result := make([]reflect.Value, len(input))
0000000000000000000000000000000000000000;;		for i := range input {
0000000000000000000000000000000000000000;;			result[i] = reflect.ValueOf(node.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalList evaluates ListNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalList(value []reflect.Value, node *ListNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		curValue := value
0000000000000000000000000000000000000000;;		for _, node := range node.Nodes {
0000000000000000000000000000000000000000;;			curValue, err = j.walk(curValue, node)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return curValue, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return curValue, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalIdentifier evaluates IdentifierNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalIdentifier(input []reflect.Value, node *IdentifierNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		results := []reflect.Value{}
0000000000000000000000000000000000000000;;		switch node.Name {
0000000000000000000000000000000000000000;;		case "range":
0000000000000000000000000000000000000000;;			j.stack = append(j.stack, j.cur)
0000000000000000000000000000000000000000;;			j.beginRange += 1
0000000000000000000000000000000000000000;;			results = input
0000000000000000000000000000000000000000;;		case "end":
0000000000000000000000000000000000000000;;			if j.endRange < j.inRange { //inside a loop, break the current block
0000000000000000000000000000000000000000;;				j.endRange += 1
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// the loop is about to end, pop value and continue the following execution
0000000000000000000000000000000000000000;;			if len(j.stack) > 0 {
0000000000000000000000000000000000000000;;				j.cur, j.stack = j.stack[len(j.stack)-1], j.stack[:len(j.stack)-1]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return results, fmt.Errorf("not in range, nothing to end")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return input, fmt.Errorf("unrecognized identifier %v", node.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalArray evaluates ArrayNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalArray(input []reflect.Value, node *ArrayNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		result := []reflect.Value{}
0000000000000000000000000000000000000000;;		for _, value := range input {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			value, isNil := template.Indirect(value)
0000000000000000000000000000000000000000;;			if isNil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value.Kind() != reflect.Array && value.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;				return input, fmt.Errorf("%v is not array or slice", value.Type())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params := node.Params
0000000000000000000000000000000000000000;;			if !params[0].Known {
0000000000000000000000000000000000000000;;				params[0].Value = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if params[0].Value < 0 {
0000000000000000000000000000000000000000;;				params[0].Value += value.Len()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !params[1].Known {
0000000000000000000000000000000000000000;;				params[1].Value = value.Len()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if params[1].Value < 0 {
0000000000000000000000000000000000000000;;				params[1].Value += value.Len()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sliceLength := value.Len()
0000000000000000000000000000000000000000;;			if params[1].Value != params[0].Value { // if you're requesting zero elements, allow it through.
0000000000000000000000000000000000000000;;				if params[0].Value >= sliceLength {
0000000000000000000000000000000000000000;;					return input, fmt.Errorf("array index out of bounds: index %d, length %d", params[0].Value, sliceLength)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if params[1].Value > sliceLength {
0000000000000000000000000000000000000000;;					return input, fmt.Errorf("array index out of bounds: index %d, length %d", params[1].Value-1, sliceLength)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !params[2].Known {
0000000000000000000000000000000000000000;;				value = value.Slice(params[0].Value, params[1].Value)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value = value.Slice3(params[0].Value, params[1].Value, params[2].Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;				result = append(result, value.Index(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalUnion evaluates UnionNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalUnion(input []reflect.Value, node *UnionNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		result := []reflect.Value{}
0000000000000000000000000000000000000000;;		for _, listNode := range node.Nodes {
0000000000000000000000000000000000000000;;			temp, err := j.evalList(input, listNode)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return input, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, temp...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *JSONPath) findFieldInValue(value *reflect.Value, node *FieldNode) (reflect.Value, error) {
0000000000000000000000000000000000000000;;		t := value.Type()
0000000000000000000000000000000000000000;;		var inlineValue *reflect.Value
0000000000000000000000000000000000000000;;		for ix := 0; ix < t.NumField(); ix++ {
0000000000000000000000000000000000000000;;			f := t.Field(ix)
0000000000000000000000000000000000000000;;			jsonTag := f.Tag.Get("json")
0000000000000000000000000000000000000000;;			parts := strings.Split(jsonTag, ",")
0000000000000000000000000000000000000000;;			if len(parts) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parts[0] == node.Value {
0000000000000000000000000000000000000000;;				return value.Field(ix), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(parts[0]) == 0 {
0000000000000000000000000000000000000000;;				val := value.Field(ix)
0000000000000000000000000000000000000000;;				inlineValue = &val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if inlineValue != nil {
0000000000000000000000000000000000000000;;			if inlineValue.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;				// handle 'inline'
0000000000000000000000000000000000000000;;				match, err := j.findFieldInValue(inlineValue, node)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return reflect.Value{}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if match.IsValid() {
0000000000000000000000000000000000000000;;					return match, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value.FieldByName(node.Value), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalField evaluates field of struct or key of map.
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalField(input []reflect.Value, node *FieldNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		results := []reflect.Value{}
0000000000000000000000000000000000000000;;		// If there's no input, there's no output
0000000000000000000000000000000000000000;;		if len(input) == 0 {
0000000000000000000000000000000000000000;;			return results, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, value := range input {
0000000000000000000000000000000000000000;;			var result reflect.Value
0000000000000000000000000000000000000000;;			value, isNil := template.Indirect(value)
0000000000000000000000000000000000000000;;			if isNil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if value.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if result, err = j.findFieldInValue(&value, node); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if value.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;				mapKeyType := value.Type().Key()
0000000000000000000000000000000000000000;;				nodeValue := reflect.ValueOf(node.Value)
0000000000000000000000000000000000000000;;				// node value type must be convertible to map key type
0000000000000000000000000000000000000000;;				if !nodeValue.Type().ConvertibleTo(mapKeyType) {
0000000000000000000000000000000000000000;;					return results, fmt.Errorf("%s is not convertible to %s", nodeValue, mapKeyType)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = value.MapIndex(nodeValue.Convert(mapKeyType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result.IsValid() {
0000000000000000000000000000000000000000;;				results = append(results, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(results) == 0 {
0000000000000000000000000000000000000000;;			if j.allowMissingKeys {
0000000000000000000000000000000000000000;;				return results, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return results, fmt.Errorf("%s is not found", node.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalWildcard extract all contents of the given value
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalWildcard(input []reflect.Value, node *WildcardNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		results := []reflect.Value{}
0000000000000000000000000000000000000000;;		for _, value := range input {
0000000000000000000000000000000000000000;;			value, isNil := template.Indirect(value)
0000000000000000000000000000000000000000;;			if isNil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kind := value.Kind()
0000000000000000000000000000000000000000;;			if kind == reflect.Struct {
0000000000000000000000000000000000000000;;				for i := 0; i < value.NumField(); i++ {
0000000000000000000000000000000000000000;;					results = append(results, value.Field(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if kind == reflect.Map {
0000000000000000000000000000000000000000;;				for _, key := range value.MapKeys() {
0000000000000000000000000000000000000000;;					results = append(results, value.MapIndex(key))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if kind == reflect.Array || kind == reflect.Slice || kind == reflect.String {
0000000000000000000000000000000000000000;;				for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;					results = append(results, value.Index(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalRecursive visit the given value recursively and push all of them to result
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalRecursive(input []reflect.Value, node *RecursiveNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		result := []reflect.Value{}
0000000000000000000000000000000000000000;;		for _, value := range input {
0000000000000000000000000000000000000000;;			results := []reflect.Value{}
0000000000000000000000000000000000000000;;			value, isNil := template.Indirect(value)
0000000000000000000000000000000000000000;;			if isNil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kind := value.Kind()
0000000000000000000000000000000000000000;;			if kind == reflect.Struct {
0000000000000000000000000000000000000000;;				for i := 0; i < value.NumField(); i++ {
0000000000000000000000000000000000000000;;					results = append(results, value.Field(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if kind == reflect.Map {
0000000000000000000000000000000000000000;;				for _, key := range value.MapKeys() {
0000000000000000000000000000000000000000;;					results = append(results, value.MapIndex(key))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if kind == reflect.Array || kind == reflect.Slice || kind == reflect.String {
0000000000000000000000000000000000000000;;				for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;					results = append(results, value.Index(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(results) != 0 {
0000000000000000000000000000000000000000;;				result = append(result, value)
0000000000000000000000000000000000000000;;				output, err := j.evalRecursive(results, node)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return result, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = append(result, output...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalFilter filter array according to FilterNode
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalFilter(input []reflect.Value, node *FilterNode) ([]reflect.Value, error) {
0000000000000000000000000000000000000000;;		results := []reflect.Value{}
0000000000000000000000000000000000000000;;		for _, value := range input {
0000000000000000000000000000000000000000;;			value, _ = template.Indirect(value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if value.Kind() != reflect.Array && value.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;				return input, fmt.Errorf("%v is not array or slice and cannot be filtered", value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;				temp := []reflect.Value{value.Index(i)}
0000000000000000000000000000000000000000;;				lefts, err := j.evalList(temp, node.Left)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				//case exists
0000000000000000000000000000000000000000;;				if node.Operator == "exists" {
0000000000000000000000000000000000000000;;					if len(lefts) > 0 {
0000000000000000000000000000000000000000;;						results = append(results, value.Index(i))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return input, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var left, right interface{}
0000000000000000000000000000000000000000;;				if len(lefts) != 1 {
0000000000000000000000000000000000000000;;					return input, fmt.Errorf("can only compare one element at a time")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				left = lefts[0].Interface()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rights, err := j.evalList(temp, node.Right)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return input, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(rights) != 1 {
0000000000000000000000000000000000000000;;					return input, fmt.Errorf("can only compare one element at a time")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				right = rights[0].Interface()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pass := false
0000000000000000000000000000000000000000;;				switch node.Operator {
0000000000000000000000000000000000000000;;				case "<":
0000000000000000000000000000000000000000;;					pass, err = template.Less(left, right)
0000000000000000000000000000000000000000;;				case ">":
0000000000000000000000000000000000000000;;					pass, err = template.Greater(left, right)
0000000000000000000000000000000000000000;;				case "==":
0000000000000000000000000000000000000000;;					pass, err = template.Equal(left, right)
0000000000000000000000000000000000000000;;				case "!=":
0000000000000000000000000000000000000000;;					pass, err = template.NotEqual(left, right)
0000000000000000000000000000000000000000;;				case "<=":
0000000000000000000000000000000000000000;;					pass, err = template.LessEqual(left, right)
0000000000000000000000000000000000000000;;				case ">=":
0000000000000000000000000000000000000000;;					pass, err = template.GreaterEqual(left, right)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return results, fmt.Errorf("unrecognized filter operator %s", node.Operator)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return results, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pass {
0000000000000000000000000000000000000000;;					results = append(results, value.Index(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalToText translates reflect value to corresponding text
0000000000000000000000000000000000000000;;	func (j *JSONPath) evalToText(v reflect.Value) ([]byte, error) {
0000000000000000000000000000000000000000;;		iface, ok := template.PrintableValue(v)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("can't print type %s", v.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		fmt.Fprint(&buffer, iface)
0000000000000000000000000000000000000000;;		return buffer.Bytes(), nil
0000000000000000000000000000000000000000;;	}
