0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/pkg/util/flowcontrol/backoff.go[staging/src/k8s.io/client-go/1.4/pkg/util/flowcontrol/backoff.go][staging/src/k8s.io/client-go/util/flowcontrol/backoff.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flowcontrol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/integer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type backoffEntry struct {
0000000000000000000000000000000000000000;;		backoff    time.Duration
0000000000000000000000000000000000000000;;		lastUpdate time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Backoff struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		Clock           clock.Clock
0000000000000000000000000000000000000000;;		defaultDuration time.Duration
0000000000000000000000000000000000000000;;		maxDuration     time.Duration
0000000000000000000000000000000000000000;;		perItemBackoff  map[string]*backoffEntry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeBackOff(initial, max time.Duration, tc *clock.FakeClock) *Backoff {
0000000000000000000000000000000000000000;;		return &Backoff{
0000000000000000000000000000000000000000;;			perItemBackoff:  map[string]*backoffEntry{},
0000000000000000000000000000000000000000;;			Clock:           tc,
0000000000000000000000000000000000000000;;			defaultDuration: initial,
0000000000000000000000000000000000000000;;			maxDuration:     max,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBackOff(initial, max time.Duration) *Backoff {
0000000000000000000000000000000000000000;;		return &Backoff{
0000000000000000000000000000000000000000;;			perItemBackoff:  map[string]*backoffEntry{},
0000000000000000000000000000000000000000;;			Clock:           clock.RealClock{},
0000000000000000000000000000000000000000;;			defaultDuration: initial,
0000000000000000000000000000000000000000;;			maxDuration:     max,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the current backoff Duration
0000000000000000000000000000000000000000;;	func (p *Backoff) Get(id string) time.Duration {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		var delay time.Duration
0000000000000000000000000000000000000000;;		entry, ok := p.perItemBackoff[id]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			delay = entry.backoff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return delay
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// move backoff to the next mark, capping at maxDuration
0000000000000000000000000000000000000000;;	func (p *Backoff) Next(id string, eventTime time.Time) {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		entry, ok := p.perItemBackoff[id]
0000000000000000000000000000000000000000;;		if !ok || hasExpired(eventTime, entry.lastUpdate, p.maxDuration) {
0000000000000000000000000000000000000000;;			entry = p.initEntryUnsafe(id)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			delay := entry.backoff * 2 // exponential
0000000000000000000000000000000000000000;;			entry.backoff = time.Duration(integer.Int64Min(int64(delay), int64(p.maxDuration)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entry.lastUpdate = p.Clock.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset forces clearing of all backoff data for a given key.
0000000000000000000000000000000000000000;;	func (p *Backoff) Reset(id string) {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		delete(p.perItemBackoff, id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns True if the elapsed time since eventTime is smaller than the current backoff window
0000000000000000000000000000000000000000;;	func (p *Backoff) IsInBackOffSince(id string, eventTime time.Time) bool {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		entry, ok := p.perItemBackoff[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasExpired(eventTime, entry.lastUpdate, p.maxDuration) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.Clock.Now().Sub(eventTime) < entry.backoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns True if time since lastupdate is less than the current backoff window.
0000000000000000000000000000000000000000;;	func (p *Backoff) IsInBackOffSinceUpdate(id string, eventTime time.Time) bool {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		entry, ok := p.perItemBackoff[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasExpired(eventTime, entry.lastUpdate, p.maxDuration) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return eventTime.Sub(entry.lastUpdate) < entry.backoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Garbage collect records that have aged past maxDuration. Backoff users are expected
0000000000000000000000000000000000000000;;	// to invoke this periodically.
0000000000000000000000000000000000000000;;	func (p *Backoff) GC() {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		now := p.Clock.Now()
0000000000000000000000000000000000000000;;		for id, entry := range p.perItemBackoff {
0000000000000000000000000000000000000000;;			if now.Sub(entry.lastUpdate) > p.maxDuration*2 {
0000000000000000000000000000000000000000;;				// GC when entry has not been updated for 2*maxDuration
0000000000000000000000000000000000000000;;				delete(p.perItemBackoff, id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Backoff) DeleteEntry(id string) {
0000000000000000000000000000000000000000;;		p.Lock()
0000000000000000000000000000000000000000;;		defer p.Unlock()
0000000000000000000000000000000000000000;;		delete(p.perItemBackoff, id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Take a lock on *Backoff, before calling initEntryUnsafe
0000000000000000000000000000000000000000;;	func (p *Backoff) initEntryUnsafe(id string) *backoffEntry {
0000000000000000000000000000000000000000;;		entry := &backoffEntry{backoff: p.defaultDuration}
0000000000000000000000000000000000000000;;		p.perItemBackoff[id] = entry
0000000000000000000000000000000000000000;;		return entry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// After 2*maxDuration we restart the backoff factor to the beginning
0000000000000000000000000000000000000000;;	func hasExpired(eventTime time.Time, lastUpdate time.Time, maxDuration time.Duration) bool {
0000000000000000000000000000000000000000;;		return eventTime.Sub(lastUpdate) > maxDuration*2 // consider stable if it's ok for twice the maxDuration
0000000000000000000000000000000000000000;;	}
