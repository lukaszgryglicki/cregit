0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
47136f3945aff958c99509decdab350d4be7b2c7;staging/src/k8s.io/client-go/pkg/util/flowcontrol/throttle_test.go[staging/src/k8s.io/client-go/pkg/util/flowcontrol/throttle_test.go][staging/src/k8s.io/client-go/util/flowcontrol/throttle_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flowcontrol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultithreadedThrottling(t *testing.T) {
0000000000000000000000000000000000000000;;		// Bucket with 100QPS and no burst
0000000000000000000000000000000000000000;;		r := NewTokenBucketRateLimiter(100, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// channel to collect 100 tokens
0000000000000000000000000000000000000000;;		taken := make(chan bool, 100)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up goroutines to hammer the throttler
0000000000000000000000000000000000000000;;		startCh := make(chan bool)
0000000000000000000000000000000000000000;;		endCh := make(chan bool)
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				// wait for the starting signal
0000000000000000000000000000000000000000;;				<-startCh
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					// get a token
0000000000000000000000000000000000000000;;					r.Accept()
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					// try to add it to the taken channel
0000000000000000000000000000000000000000;;					case taken <- true:
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					// if taken is full, notify and return
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						endCh <- true
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// record wall time
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		// take the initial capacity so all tokens are the result of refill
0000000000000000000000000000000000000000;;		r.Accept()
0000000000000000000000000000000000000000;;		// start the thundering herd
0000000000000000000000000000000000000000;;		close(startCh)
0000000000000000000000000000000000000000;;		// wait for the first signal that we collected 100 tokens
0000000000000000000000000000000000000000;;		<-endCh
0000000000000000000000000000000000000000;;		// record wall time
0000000000000000000000000000000000000000;;		endTime := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tolerate a 1% clock change because these things happen
0000000000000000000000000000000000000000;;		if duration := endTime.Sub(startTime); duration < (time.Second * 99 / 100) {
0000000000000000000000000000000000000000;;			// We shouldn't be able to get 100 tokens out of the bucket in less than 1 second of wall clock time, no matter what
0000000000000000000000000000000000000000;;			t.Errorf("Expected it to take at least 1 second to get 100 tokens, took %v", duration)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.Logf("Took %v to get 100 tokens", duration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBasicThrottle(t *testing.T) {
0000000000000000000000000000000000000000;;		r := NewTokenBucketRateLimiter(1, 3)
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			if !r.TryAccept() {
0000000000000000000000000000000000000000;;				t.Error("unexpected false accept")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.TryAccept() {
0000000000000000000000000000000000000000;;			t.Error("unexpected true accept")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIncrementThrottle(t *testing.T) {
0000000000000000000000000000000000000000;;		r := NewTokenBucketRateLimiter(1, 1)
0000000000000000000000000000000000000000;;		if !r.TryAccept() {
0000000000000000000000000000000000000000;;			t.Error("unexpected false accept")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.TryAccept() {
0000000000000000000000000000000000000000;;			t.Error("unexpected true accept")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow to refill
0000000000000000000000000000000000000000;;		time.Sleep(2 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !r.TryAccept() {
0000000000000000000000000000000000000000;;			t.Error("unexpected false accept")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestThrottle(t *testing.T) {
0000000000000000000000000000000000000000;;		r := NewTokenBucketRateLimiter(10, 5)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should consume 5 tokens immediately, then
0000000000000000000000000000000000000000;;		// the remaining 11 should take at least 1 second (0.1s each)
0000000000000000000000000000000000000000;;		expectedFinish := time.Now().Add(time.Second * 1)
0000000000000000000000000000000000000000;;		for i := 0; i < 16; i++ {
0000000000000000000000000000000000000000;;			r.Accept()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if time.Now().Before(expectedFinish) {
0000000000000000000000000000000000000000;;			t.Error("rate limit was not respected, finished too early")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRateLimiterSaturation(t *testing.T) {
0000000000000000000000000000000000000000;;		const e = 0.000001
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			capacity int
0000000000000000000000000000000000000000;;			take     int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedSaturation float64
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{1, 1, 1},
0000000000000000000000000000000000000000;;			{10, 3, 0.3},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			rl := NewTokenBucketRateLimiter(1, tt.capacity)
0000000000000000000000000000000000000000;;			for i := 0; i < tt.take; i++ {
0000000000000000000000000000000000000000;;				rl.Accept()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if math.Abs(rl.Saturation()-tt.expectedSaturation) > e {
0000000000000000000000000000000000000000;;				t.Fatalf("#%d: Saturation rate difference isn't within tolerable range\n want=%f, get=%f",
0000000000000000000000000000000000000000;;					i, tt.expectedSaturation, rl.Saturation())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAlwaysFake(t *testing.T) {
0000000000000000000000000000000000000000;;		rl := NewFakeAlwaysRateLimiter()
0000000000000000000000000000000000000000;;		if !rl.TryAccept() {
0000000000000000000000000000000000000000;;			t.Error("TryAccept in AlwaysFake should return true.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If this will block the test will timeout
0000000000000000000000000000000000000000;;		rl.Accept()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNeverFake(t *testing.T) {
0000000000000000000000000000000000000000;;		rl := NewFakeNeverRateLimiter()
0000000000000000000000000000000000000000;;		if rl.TryAccept() {
0000000000000000000000000000000000000000;;			t.Error("TryAccept in NeverFake should return false.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		finished := false
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			rl.Accept()
0000000000000000000000000000000000000000;;			finished = true
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait some time to make sure it never finished.
0000000000000000000000000000000000000000;;		time.Sleep(time.Second)
0000000000000000000000000000000000000000;;		if finished {
0000000000000000000000000000000000000000;;			t.Error("Accept should block forever in NeverFake.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rl.Stop()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		if !finished {
0000000000000000000000000000000000000000;;			t.Error("Stop should make Accept unblock in NeverFake.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
