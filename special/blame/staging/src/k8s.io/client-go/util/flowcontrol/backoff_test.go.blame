0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
47136f3945aff958c99509decdab350d4be7b2c7;staging/src/k8s.io/client-go/pkg/util/flowcontrol/backoff_test.go[staging/src/k8s.io/client-go/pkg/util/flowcontrol/backoff_test.go][staging/src/k8s.io/client-go/util/flowcontrol/backoff_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flowcontrol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSlowBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		id := "_idSlow"
0000000000000000000000000000000000000000;;		tc := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		step := time.Second
0000000000000000000000000000000000000000;;		maxDuration := 50 * step
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := NewFakeBackOff(step, maxDuration, tc)
0000000000000000000000000000000000000000;;		cases := []time.Duration{0, 1, 2, 4, 8, 16, 32, 50, 50, 50}
0000000000000000000000000000000000000000;;		for ix, c := range cases {
0000000000000000000000000000000000000000;;			tc.Step(step)
0000000000000000000000000000000000000000;;			w := b.Get(id)
0000000000000000000000000000000000000000;;			if w != c*step {
0000000000000000000000000000000000000000;;				t.Errorf("input: '%d': expected %s, got %s", ix, c*step, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.Next(id, tc.Now())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//Now confirm that the Reset cancels backoff.
0000000000000000000000000000000000000000;;		b.Next(id, tc.Now())
0000000000000000000000000000000000000000;;		b.Reset(id)
0000000000000000000000000000000000000000;;		if b.Get(id) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Reset didn't clear the backoff.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBackoffReset(t *testing.T) {
0000000000000000000000000000000000000000;;		id := "_idReset"
0000000000000000000000000000000000000000;;		tc := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		step := time.Second
0000000000000000000000000000000000000000;;		maxDuration := step * 5
0000000000000000000000000000000000000000;;		b := NewFakeBackOff(step, maxDuration, tc)
0000000000000000000000000000000000000000;;		startTime := tc.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get to backoff = maxDuration
0000000000000000000000000000000000000000;;		for i := 0; i <= int(maxDuration/step); i++ {
0000000000000000000000000000000000000000;;			tc.Step(step)
0000000000000000000000000000000000000000;;			b.Next(id, tc.Now())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// backoff should be capped at maxDuration
0000000000000000000000000000000000000000;;		if !b.IsInBackOffSince(id, tc.Now()) {
0000000000000000000000000000000000000000;;			t.Errorf("expected to be in Backoff got %s", b.Get(id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastUpdate := tc.Now()
0000000000000000000000000000000000000000;;		tc.Step(2*maxDuration + step) // time += 11s, 11 > 2*maxDuration
0000000000000000000000000000000000000000;;		if b.IsInBackOffSince(id, lastUpdate) {
0000000000000000000000000000000000000000;;			t.Errorf("expected to not be in Backoff after reset (start=%s, now=%s, lastUpdate=%s), got %s", startTime, tc.Now(), lastUpdate, b.Get(id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBackoffHightWaterMark(t *testing.T) {
0000000000000000000000000000000000000000;;		id := "_idHiWaterMark"
0000000000000000000000000000000000000000;;		tc := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		step := time.Second
0000000000000000000000000000000000000000;;		maxDuration := 5 * step
0000000000000000000000000000000000000000;;		b := NewFakeBackOff(step, maxDuration, tc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get to backoff = maxDuration
0000000000000000000000000000000000000000;;		for i := 0; i <= int(maxDuration/step); i++ {
0000000000000000000000000000000000000000;;			tc.Step(step)
0000000000000000000000000000000000000000;;			b.Next(id, tc.Now())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// backoff high watermark expires after 2*maxDuration
0000000000000000000000000000000000000000;;		tc.Step(maxDuration + step)
0000000000000000000000000000000000000000;;		b.Next(id, tc.Now())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b.Get(id) != maxDuration {
0000000000000000000000000000000000000000;;			t.Errorf("expected Backoff to stay at high watermark %s got %s", maxDuration, b.Get(id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBackoffGC(t *testing.T) {
0000000000000000000000000000000000000000;;		id := "_idGC"
0000000000000000000000000000000000000000;;		tc := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		step := time.Second
0000000000000000000000000000000000000000;;		maxDuration := 5 * step
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := NewFakeBackOff(step, maxDuration, tc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i <= int(maxDuration/step); i++ {
0000000000000000000000000000000000000000;;			tc.Step(step)
0000000000000000000000000000000000000000;;			b.Next(id, tc.Now())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lastUpdate := tc.Now()
0000000000000000000000000000000000000000;;		tc.Step(maxDuration + step)
0000000000000000000000000000000000000000;;		b.GC()
0000000000000000000000000000000000000000;;		_, found := b.perItemBackoff[id]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			t.Errorf("expected GC to skip entry, elapsed time=%s maxDuration=%s", tc.Now().Sub(lastUpdate), maxDuration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Step(maxDuration + step)
0000000000000000000000000000000000000000;;		b.GC()
0000000000000000000000000000000000000000;;		r, found := b.perItemBackoff[id]
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			t.Errorf("expected GC of entry after %s got entry %v", tc.Now().Sub(lastUpdate), r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsInBackOffSinceUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		id := "_idIsInBackOffSinceUpdate"
0000000000000000000000000000000000000000;;		tc := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		step := time.Second
0000000000000000000000000000000000000000;;		maxDuration := 10 * step
0000000000000000000000000000000000000000;;		b := NewFakeBackOff(step, maxDuration, tc)
0000000000000000000000000000000000000000;;		startTime := tc.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			tick      time.Duration
0000000000000000000000000000000000000000;;			inBackOff bool
0000000000000000000000000000000000000000;;			value     int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{tick: 0, inBackOff: false, value: 0},
0000000000000000000000000000000000000000;;			{tick: 1, inBackOff: false, value: 1},
0000000000000000000000000000000000000000;;			{tick: 2, inBackOff: true, value: 2},
0000000000000000000000000000000000000000;;			{tick: 3, inBackOff: false, value: 2},
0000000000000000000000000000000000000000;;			{tick: 4, inBackOff: true, value: 4},
0000000000000000000000000000000000000000;;			{tick: 5, inBackOff: true, value: 4},
0000000000000000000000000000000000000000;;			{tick: 6, inBackOff: true, value: 4},
0000000000000000000000000000000000000000;;			{tick: 7, inBackOff: false, value: 4},
0000000000000000000000000000000000000000;;			{tick: 8, inBackOff: true, value: 8},
0000000000000000000000000000000000000000;;			{tick: 9, inBackOff: true, value: 8},
0000000000000000000000000000000000000000;;			{tick: 10, inBackOff: true, value: 8},
0000000000000000000000000000000000000000;;			{tick: 11, inBackOff: true, value: 8},
0000000000000000000000000000000000000000;;			{tick: 12, inBackOff: true, value: 8},
0000000000000000000000000000000000000000;;			{tick: 13, inBackOff: true, value: 8},
0000000000000000000000000000000000000000;;			{tick: 14, inBackOff: true, value: 8},
0000000000000000000000000000000000000000;;			{tick: 15, inBackOff: false, value: 8},
0000000000000000000000000000000000000000;;			{tick: 16, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 17, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 18, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 19, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 20, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 21, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 22, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 23, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 24, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 25, inBackOff: false, value: 10},
0000000000000000000000000000000000000000;;			{tick: 26, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 27, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 28, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 29, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 30, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 31, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 32, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 33, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 34, inBackOff: true, value: 10},
0000000000000000000000000000000000000000;;			{tick: 35, inBackOff: false, value: 10},
0000000000000000000000000000000000000000;;			{tick: 56, inBackOff: false, value: 0},
0000000000000000000000000000000000000000;;			{tick: 57, inBackOff: false, value: 1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range cases {
0000000000000000000000000000000000000000;;			tc.SetTime(startTime.Add(c.tick * step))
0000000000000000000000000000000000000000;;			if c.inBackOff != b.IsInBackOffSinceUpdate(id, tc.Now()) {
0000000000000000000000000000000000000000;;				t.Errorf("expected IsInBackOffSinceUpdate %v got %v at tick %s", c.inBackOff, b.IsInBackOffSinceUpdate(id, tc.Now()), c.tick*step)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.inBackOff && (time.Duration(c.value)*step != b.Get(id)) {
0000000000000000000000000000000000000000;;				t.Errorf("expected backoff value=%s got %s at tick %s", time.Duration(c.value)*step, b.Get(id), c.tick*step)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !c.inBackOff {
0000000000000000000000000000000000000000;;				b.Next(id, tc.Now())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
