0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/pkg/util/flowcontrol/throttle.go[staging/src/k8s.io/client-go/1.4/pkg/util/flowcontrol/throttle.go][staging/src/k8s.io/client-go/util/flowcontrol/throttle.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flowcontrol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/juju/ratelimit"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RateLimiter interface {
0000000000000000000000000000000000000000;;		// TryAccept returns true if a token is taken immediately. Otherwise,
0000000000000000000000000000000000000000;;		// it returns false.
0000000000000000000000000000000000000000;;		TryAccept() bool
0000000000000000000000000000000000000000;;		// Accept returns once a token becomes available.
0000000000000000000000000000000000000000;;		Accept()
0000000000000000000000000000000000000000;;		// Stop stops the rate limiter, subsequent calls to CanAccept will return false
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;		// Saturation returns a percentage number which describes how saturated
0000000000000000000000000000000000000000;;		// this rate limiter is.
0000000000000000000000000000000000000000;;		// Usually we use token bucket rate limiter. In that case,
0000000000000000000000000000000000000000;;		// 1.0 means no tokens are available; 0.0 means we have a full bucket of tokens to use.
0000000000000000000000000000000000000000;;		Saturation() float64
0000000000000000000000000000000000000000;;		// QPS returns QPS of this rate limiter
0000000000000000000000000000000000000000;;		QPS() float32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tokenBucketRateLimiter struct {
0000000000000000000000000000000000000000;;		limiter *ratelimit.Bucket
0000000000000000000000000000000000000000;;		qps     float32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTokenBucketRateLimiter creates a rate limiter which implements a token bucket approach.
0000000000000000000000000000000000000000;;	// The rate limiter allows bursts of up to 'burst' to exceed the QPS, while still maintaining a
0000000000000000000000000000000000000000;;	// smoothed qps rate of 'qps'.
0000000000000000000000000000000000000000;;	// The bucket is initially filled with 'burst' tokens, and refills at a rate of 'qps'.
0000000000000000000000000000000000000000;;	// The maximum number of tokens in the bucket is capped at 'burst'.
0000000000000000000000000000000000000000;;	func NewTokenBucketRateLimiter(qps float32, burst int) RateLimiter {
0000000000000000000000000000000000000000;;		limiter := ratelimit.NewBucketWithRate(float64(qps), int64(burst))
0000000000000000000000000000000000000000;;		return newTokenBucketRateLimiter(limiter, qps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An injectable, mockable clock interface.
0000000000000000000000000000000000000000;;	type Clock interface {
0000000000000000000000000000000000000000;;		ratelimit.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTokenBucketRateLimiterWithClock is identical to NewTokenBucketRateLimiter
0000000000000000000000000000000000000000;;	// but allows an injectable clock, for testing.
0000000000000000000000000000000000000000;;	func NewTokenBucketRateLimiterWithClock(qps float32, burst int, clock Clock) RateLimiter {
0000000000000000000000000000000000000000;;		limiter := ratelimit.NewBucketWithRateAndClock(float64(qps), int64(burst), clock)
0000000000000000000000000000000000000000;;		return newTokenBucketRateLimiter(limiter, qps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTokenBucketRateLimiter(limiter *ratelimit.Bucket, qps float32) RateLimiter {
0000000000000000000000000000000000000000;;		return &tokenBucketRateLimiter{
0000000000000000000000000000000000000000;;			limiter: limiter,
0000000000000000000000000000000000000000;;			qps:     qps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tokenBucketRateLimiter) TryAccept() bool {
0000000000000000000000000000000000000000;;		return t.limiter.TakeAvailable(1) == 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tokenBucketRateLimiter) Saturation() float64 {
0000000000000000000000000000000000000000;;		capacity := t.limiter.Capacity()
0000000000000000000000000000000000000000;;		avail := t.limiter.Available()
0000000000000000000000000000000000000000;;		return float64(capacity-avail) / float64(capacity)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Accept will block until a token becomes available
0000000000000000000000000000000000000000;;	func (t *tokenBucketRateLimiter) Accept() {
0000000000000000000000000000000000000000;;		t.limiter.Wait(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tokenBucketRateLimiter) Stop() {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tokenBucketRateLimiter) QPS() float32 {
0000000000000000000000000000000000000000;;		return t.qps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeAlwaysRateLimiter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeAlwaysRateLimiter() RateLimiter {
0000000000000000000000000000000000000000;;		return &fakeAlwaysRateLimiter{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeAlwaysRateLimiter) TryAccept() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeAlwaysRateLimiter) Saturation() float64 {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeAlwaysRateLimiter) Stop() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeAlwaysRateLimiter) Accept() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeAlwaysRateLimiter) QPS() float32 {
0000000000000000000000000000000000000000;;		return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeNeverRateLimiter struct {
0000000000000000000000000000000000000000;;		wg sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeNeverRateLimiter() RateLimiter {
0000000000000000000000000000000000000000;;		rl := fakeNeverRateLimiter{}
0000000000000000000000000000000000000000;;		rl.wg.Add(1)
0000000000000000000000000000000000000000;;		return &rl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeNeverRateLimiter) TryAccept() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeNeverRateLimiter) Saturation() float64 {
0000000000000000000000000000000000000000;;		return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeNeverRateLimiter) Stop() {
0000000000000000000000000000000000000000;;		t.wg.Done()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeNeverRateLimiter) Accept() {
0000000000000000000000000000000000000000;;		t.wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeNeverRateLimiter) QPS() float32 {
0000000000000000000000000000000000000000;;		return 1
0000000000000000000000000000000000000000;;	}
