0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
045f464607795da45518380ee88ebe92ce67ee70;pkg/util/cert/triple/triple.go[pkg/util/cert/triple/triple.go][staging/src/k8s.io/client-go/util/cert/triple/triple.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package triple generates key-certificate pairs for the
0000000000000000000000000000000000000000;;	// triple (CA, Server, Client).
0000000000000000000000000000000000000000;;	package triple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KeyPair struct {
0000000000000000000000000000000000000000;;		Key  *rsa.PrivateKey
0000000000000000000000000000000000000000;;		Cert *x509.Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCA(name string) (*KeyPair, error) {
0000000000000000000000000000000000000000;;		key, err := certutil.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to create a private key for a new CA: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := certutil.Config{
0000000000000000000000000000000000000000;;			CommonName: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert, err := certutil.NewSelfSignedCACert(config, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to create a self-signed certificate for a new CA: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &KeyPair{
0000000000000000000000000000000000000000;;			Key:  key,
0000000000000000000000000000000000000000;;			Cert: cert,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewServerKeyPair(ca *KeyPair, commonName, svcName, svcNamespace, dnsDomain string, ips, hostnames []string) (*KeyPair, error) {
0000000000000000000000000000000000000000;;		key, err := certutil.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to create a server private key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespacedName := fmt.Sprintf("%s.%s", svcName, svcNamespace)
0000000000000000000000000000000000000000;;		internalAPIServerFQDN := []string{
0000000000000000000000000000000000000000;;			svcName,
0000000000000000000000000000000000000000;;			namespacedName,
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s.svc", namespacedName),
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s.svc.%s", namespacedName, dnsDomain),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		altNames := certutil.AltNames{}
0000000000000000000000000000000000000000;;		for _, ipStr := range ips {
0000000000000000000000000000000000000000;;			ip := net.ParseIP(ipStr)
0000000000000000000000000000000000000000;;			if ip != nil {
0000000000000000000000000000000000000000;;				altNames.IPs = append(altNames.IPs, ip)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		altNames.DNSNames = append(altNames.DNSNames, hostnames...)
0000000000000000000000000000000000000000;;		altNames.DNSNames = append(altNames.DNSNames, internalAPIServerFQDN...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := certutil.Config{
0000000000000000000000000000000000000000;;			CommonName: commonName,
0000000000000000000000000000000000000000;;			AltNames:   altNames,
0000000000000000000000000000000000000000;;			Usages:     []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert, err := certutil.NewSignedCert(config, key, ca.Cert, ca.Key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to sign the server certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &KeyPair{
0000000000000000000000000000000000000000;;			Key:  key,
0000000000000000000000000000000000000000;;			Cert: cert,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClientKeyPair(ca *KeyPair, commonName string, organizations []string) (*KeyPair, error) {
0000000000000000000000000000000000000000;;		key, err := certutil.NewPrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to create a client private key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := certutil.Config{
0000000000000000000000000000000000000000;;			CommonName:   commonName,
0000000000000000000000000000000000000000;;			Organization: organizations,
0000000000000000000000000000000000000000;;			Usages:       []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cert, err := certutil.NewSignedCert(config, key, ca.Cert, ca.Key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to sign the client certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &KeyPair{
0000000000000000000000000000000000000000;;			Key:  key,
0000000000000000000000000000000000000000;;			Cert: cert,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
