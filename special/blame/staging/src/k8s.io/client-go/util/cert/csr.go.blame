0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/pkg/util/cert/csr.go[staging/src/k8s.io/client-go/1.5/pkg/util/cert/csr.go][staging/src/k8s.io/client-go/util/cert/csr.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		cryptorand "crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeCSR generates a PEM-encoded CSR using the supplied private key, subject, and SANs.
0000000000000000000000000000000000000000;;	// All key types that are implemented via crypto.Signer are supported (This includes *rsa.PrivateKey and *ecdsa.PrivateKey.)
0000000000000000000000000000000000000000;;	func MakeCSR(privateKey interface{}, subject *pkix.Name, dnsSANs []string, ipSANs []net.IP) (csr []byte, err error) {
0000000000000000000000000000000000000000;;		template := &x509.CertificateRequest{
0000000000000000000000000000000000000000;;			Subject:     *subject,
0000000000000000000000000000000000000000;;			DNSNames:    dnsSANs,
0000000000000000000000000000000000000000;;			IPAddresses: ipSANs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return MakeCSRFromTemplate(privateKey, template)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeCSRFromTemplate generates a PEM-encoded CSR using the supplied private
0000000000000000000000000000000000000000;;	// key and certificate request as a template. All key types that are
0000000000000000000000000000000000000000;;	// implemented via crypto.Signer are supported (This includes *rsa.PrivateKey
0000000000000000000000000000000000000000;;	// and *ecdsa.PrivateKey.)
0000000000000000000000000000000000000000;;	func MakeCSRFromTemplate(privateKey interface{}, template *x509.CertificateRequest) ([]byte, error) {
0000000000000000000000000000000000000000;;		t := *template
0000000000000000000000000000000000000000;;		t.SignatureAlgorithm = sigType(privateKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csrDER, err := x509.CreateCertificateRequest(cryptorand.Reader, &t, privateKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csrPemBlock := &pem.Block{
0000000000000000000000000000000000000000;;			Type:  CertificateRequestBlockType,
0000000000000000000000000000000000000000;;			Bytes: csrDER,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pem.EncodeToMemory(csrPemBlock), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sigType(privateKey interface{}) x509.SignatureAlgorithm {
0000000000000000000000000000000000000000;;		// Customize the signature for RSA keys, depending on the key size
0000000000000000000000000000000000000000;;		if privateKey, ok := privateKey.(*rsa.PrivateKey); ok {
0000000000000000000000000000000000000000;;			keySize := privateKey.N.BitLen()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case keySize >= 4096:
0000000000000000000000000000000000000000;;				return x509.SHA512WithRSA
0000000000000000000000000000000000000000;;			case keySize >= 3072:
0000000000000000000000000000000000000000;;				return x509.SHA384WithRSA
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return x509.SHA256WithRSA
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x509.UnknownSignatureAlgorithm
0000000000000000000000000000000000000000;;	}
