0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/pkg/util/crypto/crypto.go[staging/src/k8s.io/client-go/1.4/pkg/util/crypto/crypto.go][staging/src/k8s.io/client-go/util/cert/cert.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		cryptorand "crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rsaKeySize   = 2048
0000000000000000000000000000000000000000;;		duration365d = time.Hour * 24 * 365
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config containes the basic fields required for creating a certificate
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		CommonName   string
0000000000000000000000000000000000000000;;		Organization []string
0000000000000000000000000000000000000000;;		AltNames     AltNames
0000000000000000000000000000000000000000;;		Usages       []x509.ExtKeyUsage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AltNames contains the domain names and IP addresses that will be added
0000000000000000000000000000000000000000;;	// to the API Server's x509 certificate SubAltNames field. The values will
0000000000000000000000000000000000000000;;	// be passed directly to the x509.Certificate object.
0000000000000000000000000000000000000000;;	type AltNames struct {
0000000000000000000000000000000000000000;;		DNSNames []string
0000000000000000000000000000000000000000;;		IPs      []net.IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPrivateKey creates an RSA private key
0000000000000000000000000000000000000000;;	func NewPrivateKey() (*rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		return rsa.GenerateKey(cryptorand.Reader, rsaKeySize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSelfSignedCACert creates a CA certificate
0000000000000000000000000000000000000000;;	func NewSelfSignedCACert(cfg Config, key *rsa.PrivateKey) (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		tmpl := x509.Certificate{
0000000000000000000000000000000000000000;;			SerialNumber: new(big.Int).SetInt64(0),
0000000000000000000000000000000000000000;;			Subject: pkix.Name{
0000000000000000000000000000000000000000;;				CommonName:   cfg.CommonName,
0000000000000000000000000000000000000000;;				Organization: cfg.Organization,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NotBefore:             now.UTC(),
0000000000000000000000000000000000000000;;			NotAfter:              now.Add(duration365d * 10).UTC(),
0000000000000000000000000000000000000000;;			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
0000000000000000000000000000000000000000;;			BasicConstraintsValid: true,
0000000000000000000000000000000000000000;;			IsCA: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certDERBytes, err := x509.CreateCertificate(cryptorand.Reader, &tmpl, &tmpl, key.Public(), key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x509.ParseCertificate(certDERBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSignedCert creates a signed certificate using the given CA certificate and key
0000000000000000000000000000000000000000;;	func NewSignedCert(cfg Config, key *rsa.PrivateKey, caCert *x509.Certificate, caKey *rsa.PrivateKey) (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		serial, err := cryptorand.Int(cryptorand.Reader, new(big.Int).SetInt64(math.MaxInt64))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cfg.CommonName) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("must specify a CommonName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cfg.Usages) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("must specify at least one ExtKeyUsage")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certTmpl := x509.Certificate{
0000000000000000000000000000000000000000;;			Subject: pkix.Name{
0000000000000000000000000000000000000000;;				CommonName:   cfg.CommonName,
0000000000000000000000000000000000000000;;				Organization: cfg.Organization,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DNSNames:     cfg.AltNames.DNSNames,
0000000000000000000000000000000000000000;;			IPAddresses:  cfg.AltNames.IPs,
0000000000000000000000000000000000000000;;			SerialNumber: serial,
0000000000000000000000000000000000000000;;			NotBefore:    caCert.NotBefore,
0000000000000000000000000000000000000000;;			NotAfter:     time.Now().Add(duration365d).UTC(),
0000000000000000000000000000000000000000;;			KeyUsage:     x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
0000000000000000000000000000000000000000;;			ExtKeyUsage:  cfg.Usages,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certDERBytes, err := x509.CreateCertificate(cryptorand.Reader, &certTmpl, caCert, key.Public(), caKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x509.ParseCertificate(certDERBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeEllipticPrivateKeyPEM creates an ECDSA private key
0000000000000000000000000000000000000000;;	func MakeEllipticPrivateKeyPEM() ([]byte, error) {
0000000000000000000000000000000000000000;;		privateKey, err := ecdsa.GenerateKey(elliptic.P256(), cryptorand.Reader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		derBytes, err := x509.MarshalECPrivateKey(privateKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateKeyPemBlock := &pem.Block{
0000000000000000000000000000000000000000;;			Type:  ECPrivateKeyBlockType,
0000000000000000000000000000000000000000;;			Bytes: derBytes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pem.EncodeToMemory(privateKeyPemBlock), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateSelfSignedCertKey creates a self-signed certificate and key for the given host.
0000000000000000000000000000000000000000;;	// Host may be an IP or a DNS name
0000000000000000000000000000000000000000;;	// You may also specify additional subject alt names (either ip or dns names) for the certificate
0000000000000000000000000000000000000000;;	func GenerateSelfSignedCertKey(host string, alternateIPs []net.IP, alternateDNS []string) ([]byte, []byte, error) {
0000000000000000000000000000000000000000;;		priv, err := rsa.GenerateKey(cryptorand.Reader, 2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template := x509.Certificate{
0000000000000000000000000000000000000000;;			SerialNumber: big.NewInt(1),
0000000000000000000000000000000000000000;;			Subject: pkix.Name{
0000000000000000000000000000000000000000;;				CommonName: fmt.Sprintf("%s@%d", host, time.Now().Unix()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NotBefore: time.Now(),
0000000000000000000000000000000000000000;;			NotAfter:  time.Now().Add(time.Hour * 24 * 365),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
0000000000000000000000000000000000000000;;			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;			BasicConstraintsValid: true,
0000000000000000000000000000000000000000;;			IsCA: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ip := net.ParseIP(host); ip != nil {
0000000000000000000000000000000000000000;;			template.IPAddresses = append(template.IPAddresses, ip)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			template.DNSNames = append(template.DNSNames, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template.IPAddresses = append(template.IPAddresses, alternateIPs...)
0000000000000000000000000000000000000000;;		template.DNSNames = append(template.DNSNames, alternateDNS...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		derBytes, err := x509.CreateCertificate(cryptorand.Reader, &template, &template, &priv.PublicKey, priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate cert
0000000000000000000000000000000000000000;;		certBuffer := bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := pem.Encode(&certBuffer, &pem.Block{Type: CertificateBlockType, Bytes: derBytes}); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate key
0000000000000000000000000000000000000000;;		keyBuffer := bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := pem.Encode(&keyBuffer, &pem.Block{Type: RSAPrivateKeyBlockType, Bytes: x509.MarshalPKCS1PrivateKey(priv)}); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return certBuffer.Bytes(), keyBuffer.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatBytesCert receives byte array certificate and formats in human-readable format
0000000000000000000000000000000000000000;;	func FormatBytesCert(cert []byte) (string, error) {
0000000000000000000000000000000000000000;;		block, _ := pem.Decode(cert)
0000000000000000000000000000000000000000;;		c, err := x509.ParseCertificate(block.Bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to parse certificate [%v]", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FormatCert(c), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatCert receives certificate and formats in human-readable format
0000000000000000000000000000000000000000;;	func FormatCert(c *x509.Certificate) string {
0000000000000000000000000000000000000000;;		var ips []string
0000000000000000000000000000000000000000;;		for _, ip := range c.IPAddresses {
0000000000000000000000000000000000000000;;			ips = append(ips, ip.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		altNames := append(ips, c.DNSNames...)
0000000000000000000000000000000000000000;;		res := fmt.Sprintf(
0000000000000000000000000000000000000000;;			"Issuer: CN=%s | Subject: CN=%s | CA: %t\n",
0000000000000000000000000000000000000000;;			c.Issuer.CommonName, c.Subject.CommonName, c.IsCA,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		res += fmt.Sprintf("Not before: %s Not After: %s", c.NotBefore, c.NotAfter)
0000000000000000000000000000000000000000;;		if len(altNames) > 0 {
0000000000000000000000000000000000000000;;			res += fmt.Sprintf("\nAlternate Names: %v", altNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
