0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/pkg/util/cert/io.go[staging/src/k8s.io/client-go/1.5/pkg/util/cert/io.go][staging/src/k8s.io/client-go/util/cert/io.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanReadCertAndKey returns true if the certificate and key files already exists,
0000000000000000000000000000000000000000;;	// otherwise returns false. If lost one of cert and key, returns error.
0000000000000000000000000000000000000000;;	func CanReadCertAndKey(certPath, keyPath string) (bool, error) {
0000000000000000000000000000000000000000;;		certReadable := canReadFile(certPath)
0000000000000000000000000000000000000000;;		keyReadable := canReadFile(keyPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if certReadable == false && keyReadable == false {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if certReadable == false {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error reading %s, certificate and key must be supplied as a pair", certPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if keyReadable == false {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error reading %s, certificate and key must be supplied as a pair", keyPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If the file represented by path exists and
0000000000000000000000000000000000000000;;	// readable, returns true otherwise returns false.
0000000000000000000000000000000000000000;;	func canReadFile(path string) bool {
0000000000000000000000000000000000000000;;		f, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteCert writes the pem-encoded certificate data to certPath.
0000000000000000000000000000000000000000;;	// The certificate file will be created with file mode 0644.
0000000000000000000000000000000000000000;;	// If the certificate file already exists, it will be overwritten.
0000000000000000000000000000000000000000;;	// The parent directory of the certPath will be created as needed with file mode 0755.
0000000000000000000000000000000000000000;;	func WriteCert(certPath string, data []byte) error {
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(filepath.Dir(certPath), os.FileMode(0755)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(certPath, data, os.FileMode(0644)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteKey writes the pem-encoded key data to keyPath.
0000000000000000000000000000000000000000;;	// The key file will be created with file mode 0600.
0000000000000000000000000000000000000000;;	// If the key file already exists, it will be overwritten.
0000000000000000000000000000000000000000;;	// The parent directory of the keyPath will be created as needed with file mode 0755.
0000000000000000000000000000000000000000;;	func WriteKey(keyPath string, data []byte) error {
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(filepath.Dir(keyPath), os.FileMode(0755)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(keyPath, data, os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadOrGenerateKeyFile looks for a key in the file at the given path. If it
0000000000000000000000000000000000000000;;	// can't find one, it will generate a new key and store it there.
0000000000000000000000000000000000000000;;	func LoadOrGenerateKeyFile(keyPath string) (data []byte, wasGenerated bool, err error) {
0000000000000000000000000000000000000000;;		loadedData, err := ioutil.ReadFile(keyPath)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return loadedData, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("error loading key from %s: %v", keyPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generatedData, err := MakeEllipticPrivateKeyPEM()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("error generating key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := WriteKey(keyPath, generatedData); err != nil {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("error writing key to %s: %v", keyPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return generatedData, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPool returns an x509.CertPool containing the certificates in the given PEM-encoded file.
0000000000000000000000000000000000000000;;	// Returns an error if the file could not be read, a certificate could not be parsed, or if the file does not contain any certificates
0000000000000000000000000000000000000000;;	func NewPool(filename string) (*x509.CertPool, error) {
0000000000000000000000000000000000000000;;		certs, err := CertsFromFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pool := x509.NewCertPool()
0000000000000000000000000000000000000000;;		for _, cert := range certs {
0000000000000000000000000000000000000000;;			pool.AddCert(cert)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pool, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertsFromFile returns the x509.Certificates contained in the given PEM-encoded file.
0000000000000000000000000000000000000000;;	// Returns an error if the file could not be read, a certificate could not be parsed, or if the file does not contain any certificates
0000000000000000000000000000000000000000;;	func CertsFromFile(file string) ([]*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		pemBlock, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certs, err := ParseCertsPEM(pemBlock)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading %s: %s", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrivateKeyFromFile returns the private key in rsa.PrivateKey or ecdsa.PrivateKey format from a given PEM-encoded file.
0000000000000000000000000000000000000000;;	// Returns an error if the file could not be read or if the private key could not be parsed.
0000000000000000000000000000000000000000;;	func PrivateKeyFromFile(file string) (interface{}, error) {
0000000000000000000000000000000000000000;;		pemBlock, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := ParsePrivateKeyPEM(pemBlock)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading %s: %v", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
