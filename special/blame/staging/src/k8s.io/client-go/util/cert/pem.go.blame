0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/pkg/util/cert/pem.go[staging/src/k8s.io/client-go/1.5/pkg/util/cert/pem.go][staging/src/k8s.io/client-go/util/cert/pem.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ECPrivateKeyBlockType is a possible value for pem.Block.Type.
0000000000000000000000000000000000000000;;		ECPrivateKeyBlockType = "EC PRIVATE KEY"
0000000000000000000000000000000000000000;;		// RSAPrivateKeyBlockType is a possible value for pem.Block.Type.
0000000000000000000000000000000000000000;;		RSAPrivateKeyBlockType = "RSA PRIVATE KEY"
0000000000000000000000000000000000000000;;		// CertificateBlockType is a possible value for pem.Block.Type.
0000000000000000000000000000000000000000;;		CertificateBlockType = "CERTIFICATE"
0000000000000000000000000000000000000000;;		// CertificateRequestBlockType is a possible value for pem.Block.Type.
0000000000000000000000000000000000000000;;		CertificateRequestBlockType = "CERTIFICATE REQUEST"
0000000000000000000000000000000000000000;;		// PrivateKeyBlockType is a possible value for pem.Block.Type.
0000000000000000000000000000000000000000;;		PrivateKeyBlockType = "PRIVATE KEY"
0000000000000000000000000000000000000000;;		// PublicKeyBlockType is a possible value for pem.Block.Type.
0000000000000000000000000000000000000000;;		PublicKeyBlockType = "PUBLIC KEY"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodePublicKeyPEM returns PEM-endcode public data
0000000000000000000000000000000000000000;;	func EncodePublicKeyPEM(key *rsa.PublicKey) ([]byte, error) {
0000000000000000000000000000000000000000;;		der, err := x509.MarshalPKIXPublicKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []byte{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block := pem.Block{
0000000000000000000000000000000000000000;;			Type:  PublicKeyBlockType,
0000000000000000000000000000000000000000;;			Bytes: der,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pem.EncodeToMemory(&block), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodePrivateKeyPEM returns PEM-encoded private key data
0000000000000000000000000000000000000000;;	func EncodePrivateKeyPEM(key *rsa.PrivateKey) []byte {
0000000000000000000000000000000000000000;;		block := pem.Block{
0000000000000000000000000000000000000000;;			Type:  RSAPrivateKeyBlockType,
0000000000000000000000000000000000000000;;			Bytes: x509.MarshalPKCS1PrivateKey(key),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pem.EncodeToMemory(&block)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeCertPEM returns PEM-endcoded certificate data
0000000000000000000000000000000000000000;;	func EncodeCertPEM(cert *x509.Certificate) []byte {
0000000000000000000000000000000000000000;;		block := pem.Block{
0000000000000000000000000000000000000000;;			Type:  CertificateBlockType,
0000000000000000000000000000000000000000;;			Bytes: cert.Raw,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pem.EncodeToMemory(&block)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePrivateKeyPEM returns a private key parsed from a PEM block in the supplied data.
0000000000000000000000000000000000000000;;	// Recognizes PEM blocks for "EC PRIVATE KEY", "RSA PRIVATE KEY", or "PRIVATE KEY"
0000000000000000000000000000000000000000;;	func ParsePrivateKeyPEM(keyData []byte) (interface{}, error) {
0000000000000000000000000000000000000000;;		var privateKeyPemBlock *pem.Block
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			privateKeyPemBlock, keyData = pem.Decode(keyData)
0000000000000000000000000000000000000000;;			if privateKeyPemBlock == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch privateKeyPemBlock.Type {
0000000000000000000000000000000000000000;;			case ECPrivateKeyBlockType:
0000000000000000000000000000000000000000;;				// ECDSA Private Key in ASN.1 format
0000000000000000000000000000000000000000;;				if key, err := x509.ParseECPrivateKey(privateKeyPemBlock.Bytes); err == nil {
0000000000000000000000000000000000000000;;					return key, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case RSAPrivateKeyBlockType:
0000000000000000000000000000000000000000;;				// RSA Private Key in PKCS#1 format
0000000000000000000000000000000000000000;;				if key, err := x509.ParsePKCS1PrivateKey(privateKeyPemBlock.Bytes); err == nil {
0000000000000000000000000000000000000000;;					return key, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case PrivateKeyBlockType:
0000000000000000000000000000000000000000;;				// RSA or ECDSA Private Key in unencrypted PKCS#8 format
0000000000000000000000000000000000000000;;				if key, err := x509.ParsePKCS8PrivateKey(privateKeyPemBlock.Bytes); err == nil {
0000000000000000000000000000000000000000;;					return key, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// tolerate non-key PEM blocks for compatibility with things like "EC PARAMETERS" blocks
0000000000000000000000000000000000000000;;			// originally, only the first PEM block was parsed and expected to be a key block
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we read all the PEM blocks and didn't recognize one
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("data does not contain a valid RSA or ECDSA private key")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCertsPEM returns the x509.Certificates contained in the given PEM-encoded byte array
0000000000000000000000000000000000000000;;	// Returns an error if a certificate could not be parsed, or if the data does not contain any certificates
0000000000000000000000000000000000000000;;	func ParseCertsPEM(pemCerts []byte) ([]*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		ok := false
0000000000000000000000000000000000000000;;		certs := []*x509.Certificate{}
0000000000000000000000000000000000000000;;		for len(pemCerts) > 0 {
0000000000000000000000000000000000000000;;			var block *pem.Block
0000000000000000000000000000000000000000;;			block, pemCerts = pem.Decode(pemCerts)
0000000000000000000000000000000000000000;;			if block == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Only use PEM "CERTIFICATE" blocks without extra headers
0000000000000000000000000000000000000000;;			if block.Type != CertificateBlockType || len(block.Headers) != 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cert, err := x509.ParseCertificate(block.Bytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return certs, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			certs = append(certs, cert)
0000000000000000000000000000000000000000;;			ok = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return certs, errors.New("could not read any certificates")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certs, nil
0000000000000000000000000000000000000000;;	}
