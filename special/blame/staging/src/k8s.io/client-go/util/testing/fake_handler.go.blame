0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/pkg/util/testing/fake_handler.go[staging/src/k8s.io/client-go/1.4/pkg/util/testing/fake_handler.go][staging/src/k8s.io/client-go/util/testing/fake_handler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestInterface is a simple interface providing Errorf, to make injection for
0000000000000000000000000000000000000000;;	// testing easier (insert 'yo dawg' meme here).
0000000000000000000000000000000000000000;;	type TestInterface interface {
0000000000000000000000000000000000000000;;		Errorf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Logf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogInterface is a simple interface to allow injection of Logf to report serving errors.
0000000000000000000000000000000000000000;;	type LogInterface interface {
0000000000000000000000000000000000000000;;		Logf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeHandler is to assist in testing HTTP requests. Notice that FakeHandler is
0000000000000000000000000000000000000000;;	// not thread safe and you must not direct traffic to except for the request
0000000000000000000000000000000000000000;;	// you want to test. You can do this by hiding it in an http.ServeMux.
0000000000000000000000000000000000000000;;	type FakeHandler struct {
0000000000000000000000000000000000000000;;		RequestReceived *http.Request
0000000000000000000000000000000000000000;;		RequestBody     string
0000000000000000000000000000000000000000;;		StatusCode      int
0000000000000000000000000000000000000000;;		ResponseBody    string
0000000000000000000000000000000000000000;;		// For logging - you can use a *testing.T
0000000000000000000000000000000000000000;;		// This will keep log messages associated with the test.
0000000000000000000000000000000000000000;;		T LogInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enforce "only one use" constraint.
0000000000000000000000000000000000000000;;		lock           sync.Mutex
0000000000000000000000000000000000000000;;		requestCount   int
0000000000000000000000000000000000000000;;		hasBeenChecked bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SkipRequestFn func(verb string, url url.URL) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeHandler) SetResponseBody(responseBody string) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.ResponseBody = responseBody
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeHandler) ServeHTTP(response http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.SkipRequestFn != nil && f.SkipRequestFn(request.Method, *request.URL) {
0000000000000000000000000000000000000000;;			response.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			response.WriteHeader(f.StatusCode)
0000000000000000000000000000000000000000;;			response.Write([]byte(f.ResponseBody))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.requestCount++
0000000000000000000000000000000000000000;;		if f.hasBeenChecked {
0000000000000000000000000000000000000000;;			panic("got request after having been validated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.RequestReceived = request
0000000000000000000000000000000000000000;;		response.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		response.WriteHeader(f.StatusCode)
0000000000000000000000000000000000000000;;		response.Write([]byte(f.ResponseBody))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bodyReceived, err := ioutil.ReadAll(request.Body)
0000000000000000000000000000000000000000;;		if err != nil && f.T != nil {
0000000000000000000000000000000000000000;;			f.T.Logf("Received read error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.RequestBody = string(bodyReceived)
0000000000000000000000000000000000000000;;		if f.T != nil {
0000000000000000000000000000000000000000;;			f.T.Logf("request body: %s", f.RequestBody)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeHandler) ValidateRequestCount(t TestInterface, count int) bool {
0000000000000000000000000000000000000000;;		ok := true
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		if f.requestCount != count {
0000000000000000000000000000000000000000;;			ok = false
0000000000000000000000000000000000000000;;			t.Errorf("Expected %d call, but got %d. Only the last call is recorded and checked.", count, f.requestCount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.hasBeenChecked = true
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateRequest verifies that FakeHandler received a request with expected path, method, and body.
0000000000000000000000000000000000000000;;	func (f *FakeHandler) ValidateRequest(t TestInterface, expectedPath, expectedMethod string, body *string) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		if f.requestCount != 1 {
0000000000000000000000000000000000000000;;			t.Logf("Expected 1 call, but got %v. Only the last call is recorded and checked.", f.requestCount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.hasBeenChecked = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectURL, err := url.Parse(expectedPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Couldn't parse %v as a URL.", expectedPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.RequestReceived == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected nil request received for %s", expectedPath)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.RequestReceived.URL.Path != expectURL.Path {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected request path for request %#v, received: %q, expected: %q", f.RequestReceived, f.RequestReceived.URL.Path, expectURL.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := expectURL.Query(), f.RequestReceived.URL.Query(); !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected query for request %#v, received: %q, expected: %q", f.RequestReceived, a, e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.RequestReceived.Method != expectedMethod {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected method: %q, expected: %q", f.RequestReceived.Method, expectedMethod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if body != nil {
0000000000000000000000000000000000000000;;			if *body != f.RequestBody {
0000000000000000000000000000000000000000;;				t.Errorf("Received body:\n%s\n Doesn't match expected body:\n%s", f.RequestBody, *body)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
