0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8cc7fc1ea163434e99fa8953e74f2cc45b08b166;pkg/util/workqueue/queue.go[pkg/util/workqueue/queue.go][staging/src/k8s.io/client-go/util/workqueue/queue.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workqueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		Add(item interface{})
0000000000000000000000000000000000000000;;		Len() int
0000000000000000000000000000000000000000;;		Get() (item interface{}, shutdown bool)
0000000000000000000000000000000000000000;;		Done(item interface{})
0000000000000000000000000000000000000000;;		ShutDown()
0000000000000000000000000000000000000000;;		ShuttingDown() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New constructs a new work queue (see the package comment).
0000000000000000000000000000000000000000;;	func New() *Type {
0000000000000000000000000000000000000000;;		return NewNamed("")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamed(name string) *Type {
0000000000000000000000000000000000000000;;		return &Type{
0000000000000000000000000000000000000000;;			dirty:      set{},
0000000000000000000000000000000000000000;;			processing: set{},
0000000000000000000000000000000000000000;;			cond:       sync.NewCond(&sync.Mutex{}),
0000000000000000000000000000000000000000;;			metrics:    newQueueMetrics(name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type is a work queue (see the package comment).
0000000000000000000000000000000000000000;;	type Type struct {
0000000000000000000000000000000000000000;;		// queue defines the order in which we will work on items. Every
0000000000000000000000000000000000000000;;		// element of queue should be in the dirty set and not in the
0000000000000000000000000000000000000000;;		// processing set.
0000000000000000000000000000000000000000;;		queue []t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// dirty defines all of the items that need to be processed.
0000000000000000000000000000000000000000;;		dirty set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Things that are currently being processed are in the processing set.
0000000000000000000000000000000000000000;;		// These things may be simultaneously in the dirty set. When we finish
0000000000000000000000000000000000000000;;		// processing something and remove it from this set, we'll check if
0000000000000000000000000000000000000000;;		// it's in the dirty set, and if so, add it to the queue.
0000000000000000000000000000000000000000;;		processing set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cond *sync.Cond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shuttingDown bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metrics queueMetrics
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type empty struct{}
0000000000000000000000000000000000000000;;	type t interface{}
0000000000000000000000000000000000000000;;	type set map[t]empty
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s set) has(item t) bool {
0000000000000000000000000000000000000000;;		_, exists := s[item]
0000000000000000000000000000000000000000;;		return exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s set) insert(item t) {
0000000000000000000000000000000000000000;;		s[item] = empty{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s set) delete(item t) {
0000000000000000000000000000000000000000;;		delete(s, item)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add marks item as needing processing.
0000000000000000000000000000000000000000;;	func (q *Type) Add(item interface{}) {
0000000000000000000000000000000000000000;;		q.cond.L.Lock()
0000000000000000000000000000000000000000;;		defer q.cond.L.Unlock()
0000000000000000000000000000000000000000;;		if q.shuttingDown {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if q.dirty.has(item) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.metrics.add(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.dirty.insert(item)
0000000000000000000000000000000000000000;;		if q.processing.has(item) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.queue = append(q.queue, item)
0000000000000000000000000000000000000000;;		q.cond.Signal()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the current queue length, for informational purposes only. You
0000000000000000000000000000000000000000;;	// shouldn't e.g. gate a call to Add() or Get() on Len() being a particular
0000000000000000000000000000000000000000;;	// value, that can't be synchronized properly.
0000000000000000000000000000000000000000;;	func (q *Type) Len() int {
0000000000000000000000000000000000000000;;		q.cond.L.Lock()
0000000000000000000000000000000000000000;;		defer q.cond.L.Unlock()
0000000000000000000000000000000000000000;;		return len(q.queue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get blocks until it can return an item to be processed. If shutdown = true,
0000000000000000000000000000000000000000;;	// the caller should end their goroutine. You must call Done with item when you
0000000000000000000000000000000000000000;;	// have finished processing it.
0000000000000000000000000000000000000000;;	func (q *Type) Get() (item interface{}, shutdown bool) {
0000000000000000000000000000000000000000;;		q.cond.L.Lock()
0000000000000000000000000000000000000000;;		defer q.cond.L.Unlock()
0000000000000000000000000000000000000000;;		for len(q.queue) == 0 && !q.shuttingDown {
0000000000000000000000000000000000000000;;			q.cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(q.queue) == 0 {
0000000000000000000000000000000000000000;;			// We must be shutting down.
0000000000000000000000000000000000000000;;			return nil, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item, q.queue = q.queue[0], q.queue[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.metrics.get(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.processing.insert(item)
0000000000000000000000000000000000000000;;		q.dirty.delete(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return item, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Done marks item as done processing, and if it has been marked as dirty again
0000000000000000000000000000000000000000;;	// while it was being processed, it will be re-added to the queue for
0000000000000000000000000000000000000000;;	// re-processing.
0000000000000000000000000000000000000000;;	func (q *Type) Done(item interface{}) {
0000000000000000000000000000000000000000;;		q.cond.L.Lock()
0000000000000000000000000000000000000000;;		defer q.cond.L.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.metrics.done(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.processing.delete(item)
0000000000000000000000000000000000000000;;		if q.dirty.has(item) {
0000000000000000000000000000000000000000;;			q.queue = append(q.queue, item)
0000000000000000000000000000000000000000;;			q.cond.Signal()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShutDown will cause q to ignore all new items added to it. As soon as the
0000000000000000000000000000000000000000;;	// worker goroutines have drained the existing items in the queue, they will be
0000000000000000000000000000000000000000;;	// instructed to exit.
0000000000000000000000000000000000000000;;	func (q *Type) ShutDown() {
0000000000000000000000000000000000000000;;		q.cond.L.Lock()
0000000000000000000000000000000000000000;;		defer q.cond.L.Unlock()
0000000000000000000000000000000000000000;;		q.shuttingDown = true
0000000000000000000000000000000000000000;;		q.cond.Broadcast()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *Type) ShuttingDown() bool {
0000000000000000000000000000000000000000;;		q.cond.L.Lock()
0000000000000000000000000000000000000000;;		defer q.cond.L.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return q.shuttingDown
0000000000000000000000000000000000000000;;	}
