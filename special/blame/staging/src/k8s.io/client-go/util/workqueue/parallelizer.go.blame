0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
25100c623f8c975bec0a85040d8bfabd23bec534;pkg/util/workqueue/parallelizer.go[pkg/util/workqueue/parallelizer.go][staging/src/k8s.io/client-go/util/workqueue/parallelizer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workqueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DoWorkPieceFunc func(piece int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parallelize is a very simple framework that allow for parallelizing
0000000000000000000000000000000000000000;;	// N independent pieces of work.
0000000000000000000000000000000000000000;;	func Parallelize(workers, pieces int, doWorkPiece DoWorkPieceFunc) {
0000000000000000000000000000000000000000;;		toProcess := make(chan int, pieces)
0000000000000000000000000000000000000000;;		for i := 0; i < pieces; i++ {
0000000000000000000000000000000000000000;;			toProcess <- i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(toProcess)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pieces < workers {
0000000000000000000000000000000000000000;;			workers = pieces
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(workers)
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				for piece := range toProcess {
0000000000000000000000000000000000000000;;					doWorkPiece(piece)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
