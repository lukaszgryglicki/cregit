0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
78ad84e741275d54e88876c95bbd2230cf64afe9;pkg/util/workqueue/metrics.go[pkg/util/workqueue/metrics.go][staging/src/k8s.io/client-go/util/workqueue/metrics.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workqueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file provides abstractions for setting the provider (e.g., prometheus)
0000000000000000000000000000000000000000;;	// of metrics.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type queueMetrics interface {
0000000000000000000000000000000000000000;;		add(item t)
0000000000000000000000000000000000000000;;		get(item t)
0000000000000000000000000000000000000000;;		done(item t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GaugeMetric represents a single numerical value that can arbitrarily go up
0000000000000000000000000000000000000000;;	// and down.
0000000000000000000000000000000000000000;;	type GaugeMetric interface {
0000000000000000000000000000000000000000;;		Inc()
0000000000000000000000000000000000000000;;		Dec()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CounterMetric represents a single numerical value that only ever
0000000000000000000000000000000000000000;;	// goes up.
0000000000000000000000000000000000000000;;	type CounterMetric interface {
0000000000000000000000000000000000000000;;		Inc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SummaryMetric captures individual observations.
0000000000000000000000000000000000000000;;	type SummaryMetric interface {
0000000000000000000000000000000000000000;;		Observe(float64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noopMetric struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (noopMetric) Inc()            {}
0000000000000000000000000000000000000000;;	func (noopMetric) Dec()            {}
0000000000000000000000000000000000000000;;	func (noopMetric) Observe(float64) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultQueueMetrics struct {
0000000000000000000000000000000000000000;;		// current depth of a workqueue
0000000000000000000000000000000000000000;;		depth GaugeMetric
0000000000000000000000000000000000000000;;		// total number of adds handled by a workqueue
0000000000000000000000000000000000000000;;		adds CounterMetric
0000000000000000000000000000000000000000;;		// how long an item stays in a workqueue
0000000000000000000000000000000000000000;;		latency SummaryMetric
0000000000000000000000000000000000000000;;		// how long processing an item from a workqueue takes
0000000000000000000000000000000000000000;;		workDuration         SummaryMetric
0000000000000000000000000000000000000000;;		addTimes             map[t]time.Time
0000000000000000000000000000000000000000;;		processingStartTimes map[t]time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *defaultQueueMetrics) add(item t) {
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.adds.Inc()
0000000000000000000000000000000000000000;;		m.depth.Inc()
0000000000000000000000000000000000000000;;		if _, exists := m.addTimes[item]; !exists {
0000000000000000000000000000000000000000;;			m.addTimes[item] = time.Now()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *defaultQueueMetrics) get(item t) {
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.depth.Dec()
0000000000000000000000000000000000000000;;		m.processingStartTimes[item] = time.Now()
0000000000000000000000000000000000000000;;		if startTime, exists := m.addTimes[item]; exists {
0000000000000000000000000000000000000000;;			m.latency.Observe(sinceInMicroseconds(startTime))
0000000000000000000000000000000000000000;;			delete(m.addTimes, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *defaultQueueMetrics) done(item t) {
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if startTime, exists := m.processingStartTimes[item]; exists {
0000000000000000000000000000000000000000;;			m.workDuration.Observe(sinceInMicroseconds(startTime))
0000000000000000000000000000000000000000;;			delete(m.processingStartTimes, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the time since the specified start in microseconds.
0000000000000000000000000000000000000000;;	func sinceInMicroseconds(start time.Time) float64 {
0000000000000000000000000000000000000000;;		return float64(time.Since(start).Nanoseconds() / time.Microsecond.Nanoseconds())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type retryMetrics interface {
0000000000000000000000000000000000000000;;		retry()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultRetryMetrics struct {
0000000000000000000000000000000000000000;;		retries CounterMetric
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *defaultRetryMetrics) retry() {
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.retries.Inc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetricsProvider generates various metrics used by the queue.
0000000000000000000000000000000000000000;;	type MetricsProvider interface {
0000000000000000000000000000000000000000;;		NewDepthMetric(name string) GaugeMetric
0000000000000000000000000000000000000000;;		NewAddsMetric(name string) CounterMetric
0000000000000000000000000000000000000000;;		NewLatencyMetric(name string) SummaryMetric
0000000000000000000000000000000000000000;;		NewWorkDurationMetric(name string) SummaryMetric
0000000000000000000000000000000000000000;;		NewRetriesMetric(name string) CounterMetric
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noopMetricsProvider struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noopMetricsProvider) NewDepthMetric(name string) GaugeMetric {
0000000000000000000000000000000000000000;;		return noopMetric{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noopMetricsProvider) NewAddsMetric(name string) CounterMetric {
0000000000000000000000000000000000000000;;		return noopMetric{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noopMetricsProvider) NewLatencyMetric(name string) SummaryMetric {
0000000000000000000000000000000000000000;;		return noopMetric{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noopMetricsProvider) NewWorkDurationMetric(name string) SummaryMetric {
0000000000000000000000000000000000000000;;		return noopMetric{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noopMetricsProvider) NewRetriesMetric(name string) CounterMetric {
0000000000000000000000000000000000000000;;		return noopMetric{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var metricsFactory = struct {
0000000000000000000000000000000000000000;;		metricsProvider MetricsProvider
0000000000000000000000000000000000000000;;		setProviders    sync.Once
0000000000000000000000000000000000000000;;	}{
0000000000000000000000000000000000000000;;		metricsProvider: noopMetricsProvider{},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newQueueMetrics(name string) queueMetrics {
0000000000000000000000000000000000000000;;		var ret *defaultQueueMetrics
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &defaultQueueMetrics{
0000000000000000000000000000000000000000;;			depth:                metricsFactory.metricsProvider.NewDepthMetric(name),
0000000000000000000000000000000000000000;;			adds:                 metricsFactory.metricsProvider.NewAddsMetric(name),
0000000000000000000000000000000000000000;;			latency:              metricsFactory.metricsProvider.NewLatencyMetric(name),
0000000000000000000000000000000000000000;;			workDuration:         metricsFactory.metricsProvider.NewWorkDurationMetric(name),
0000000000000000000000000000000000000000;;			addTimes:             map[t]time.Time{},
0000000000000000000000000000000000000000;;			processingStartTimes: map[t]time.Time{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRetryMetrics(name string) retryMetrics {
0000000000000000000000000000000000000000;;		var ret *defaultRetryMetrics
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &defaultRetryMetrics{
0000000000000000000000000000000000000000;;			retries: metricsFactory.metricsProvider.NewRetriesMetric(name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetProvider sets the metrics provider of the metricsFactory.
0000000000000000000000000000000000000000;;	func SetProvider(metricsProvider MetricsProvider) {
0000000000000000000000000000000000000000;;		metricsFactory.setProviders.Do(func() {
0000000000000000000000000000000000000000;;			metricsFactory.metricsProvider = metricsProvider
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
