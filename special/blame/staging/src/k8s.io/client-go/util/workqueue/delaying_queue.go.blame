0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c7d4feeb4183c2c7eb0931bc1f999eea00cc2f0f;pkg/util/workqueue/delaying_queue.go[pkg/util/workqueue/delaying_queue.go][staging/src/k8s.io/client-go/util/workqueue/delaying_queue.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workqueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/heap"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelayingInterface is an Interface that can Add an item at a later time. This makes it easier to
0000000000000000000000000000000000000000;;	// requeue items after failures without ending up in a hot-loop.
0000000000000000000000000000000000000000;;	type DelayingInterface interface {
0000000000000000000000000000000000000000;;		Interface
0000000000000000000000000000000000000000;;		// AddAfter adds an item to the workqueue after the indicated duration has passed
0000000000000000000000000000000000000000;;		AddAfter(item interface{}, duration time.Duration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDelayingQueue constructs a new workqueue with delayed queuing ability
0000000000000000000000000000000000000000;;	func NewDelayingQueue() DelayingInterface {
0000000000000000000000000000000000000000;;		return newDelayingQueue(clock.RealClock{}, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedDelayingQueue(name string) DelayingInterface {
0000000000000000000000000000000000000000;;		return newDelayingQueue(clock.RealClock{}, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDelayingQueue(clock clock.Clock, name string) DelayingInterface {
0000000000000000000000000000000000000000;;		ret := &delayingType{
0000000000000000000000000000000000000000;;			Interface:       NewNamed(name),
0000000000000000000000000000000000000000;;			clock:           clock,
0000000000000000000000000000000000000000;;			heartbeat:       clock.Tick(maxWait),
0000000000000000000000000000000000000000;;			stopCh:          make(chan struct{}),
0000000000000000000000000000000000000000;;			waitingForAddCh: make(chan *waitFor, 1000),
0000000000000000000000000000000000000000;;			metrics:         newRetryMetrics(name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go ret.waitingLoop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delayingType wraps an Interface and provides delayed re-enquing
0000000000000000000000000000000000000000;;	type delayingType struct {
0000000000000000000000000000000000000000;;		Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clock tracks time for delayed firing
0000000000000000000000000000000000000000;;		clock clock.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stopCh lets us signal a shutdown to the waiting loop
0000000000000000000000000000000000000000;;		stopCh chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// heartbeat ensures we wait no more than maxWait before firing
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO: replace with Ticker (and add to clock) so this can be cleaned up.
0000000000000000000000000000000000000000;;		// clock.Tick will leak.
0000000000000000000000000000000000000000;;		heartbeat <-chan time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// waitingForAddCh is a buffered channel that feeds waitingForAdd
0000000000000000000000000000000000000000;;		waitingForAddCh chan *waitFor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// metrics counts the number of retries
0000000000000000000000000000000000000000;;		metrics retryMetrics
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitFor holds the data to add and the time it should be added
0000000000000000000000000000000000000000;;	type waitFor struct {
0000000000000000000000000000000000000000;;		data    t
0000000000000000000000000000000000000000;;		readyAt time.Time
0000000000000000000000000000000000000000;;		// index in the priority queue (heap)
0000000000000000000000000000000000000000;;		index int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForPriorityQueue implements a priority queue for waitFor items.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// waitForPriorityQueue implements heap.Interface. The item occuring next in
0000000000000000000000000000000000000000;;	// time (i.e., the item with the smallest readyAt) is at the root (index 0).
0000000000000000000000000000000000000000;;	// Peek returns this minimum item at index 0. Pop returns the minimum item after
0000000000000000000000000000000000000000;;	// it has been removed from the queue and placed at index Len()-1 by
0000000000000000000000000000000000000000;;	// container/heap. Push adds an item at index Len(), and container/heap
0000000000000000000000000000000000000000;;	// percolates it into the correct location.
0000000000000000000000000000000000000000;;	type waitForPriorityQueue []*waitFor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pq waitForPriorityQueue) Len() int {
0000000000000000000000000000000000000000;;		return len(pq)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (pq waitForPriorityQueue) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return pq[i].readyAt.Before(pq[j].readyAt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (pq waitForPriorityQueue) Swap(i, j int) {
0000000000000000000000000000000000000000;;		pq[i], pq[j] = pq[j], pq[i]
0000000000000000000000000000000000000000;;		pq[i].index = i
0000000000000000000000000000000000000000;;		pq[j].index = j
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Push adds an item to the queue. Push should not be called directly; instead,
0000000000000000000000000000000000000000;;	// use `heap.Push`.
0000000000000000000000000000000000000000;;	func (pq *waitForPriorityQueue) Push(x interface{}) {
0000000000000000000000000000000000000000;;		n := len(*pq)
0000000000000000000000000000000000000000;;		item := x.(*waitFor)
0000000000000000000000000000000000000000;;		item.index = n
0000000000000000000000000000000000000000;;		*pq = append(*pq, item)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pop removes an item from the queue. Pop should not be called directly;
0000000000000000000000000000000000000000;;	// instead, use `heap.Pop`.
0000000000000000000000000000000000000000;;	func (pq *waitForPriorityQueue) Pop() interface{} {
0000000000000000000000000000000000000000;;		n := len(*pq)
0000000000000000000000000000000000000000;;		item := (*pq)[n-1]
0000000000000000000000000000000000000000;;		item.index = -1
0000000000000000000000000000000000000000;;		*pq = (*pq)[0:(n - 1)]
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Peek returns the item at the beginning of the queue, without removing the
0000000000000000000000000000000000000000;;	// item or otherwise mutating the queue. It is safe to call directly.
0000000000000000000000000000000000000000;;	func (pq waitForPriorityQueue) Peek() interface{} {
0000000000000000000000000000000000000000;;		return pq[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShutDown gives a way to shut off this queue
0000000000000000000000000000000000000000;;	func (q *delayingType) ShutDown() {
0000000000000000000000000000000000000000;;		q.Interface.ShutDown()
0000000000000000000000000000000000000000;;		close(q.stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddAfter adds the given item to the work queue after the given delay
0000000000000000000000000000000000000000;;	func (q *delayingType) AddAfter(item interface{}, duration time.Duration) {
0000000000000000000000000000000000000000;;		// don't add if we're already shutting down
0000000000000000000000000000000000000000;;		if q.ShuttingDown() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.metrics.retry()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// immediately add things with no delay
0000000000000000000000000000000000000000;;		if duration <= 0 {
0000000000000000000000000000000000000000;;			q.Add(item)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-q.stopCh:
0000000000000000000000000000000000000000;;			// unblock if ShutDown() is called
0000000000000000000000000000000000000000;;		case q.waitingForAddCh <- &waitFor{data: item, readyAt: q.clock.Now().Add(duration)}:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxWait keeps a max bound on the wait time. It's just insurance against weird things happening.
0000000000000000000000000000000000000000;;	// Checking the queue every 10 seconds isn't expensive and we know that we'll never end up with an
0000000000000000000000000000000000000000;;	// expired item sitting for more than 10 seconds.
0000000000000000000000000000000000000000;;	const maxWait = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitingLoop runs until the workqueue is shutdown and keeps a check on the list of items to be added.
0000000000000000000000000000000000000000;;	func (q *delayingType) waitingLoop() {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a placeholder channel to use when there are no items in our list
0000000000000000000000000000000000000000;;		never := make(<-chan time.Time)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitingForQueue := &waitForPriorityQueue{}
0000000000000000000000000000000000000000;;		heap.Init(waitingForQueue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitingEntryByData := map[t]*waitFor{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if q.Interface.ShuttingDown() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			now := q.clock.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add ready entries
0000000000000000000000000000000000000000;;			for waitingForQueue.Len() > 0 {
0000000000000000000000000000000000000000;;				entry := waitingForQueue.Peek().(*waitFor)
0000000000000000000000000000000000000000;;				if entry.readyAt.After(now) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				entry = heap.Pop(waitingForQueue).(*waitFor)
0000000000000000000000000000000000000000;;				q.Add(entry.data)
0000000000000000000000000000000000000000;;				delete(waitingEntryByData, entry.data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set up a wait for the first item's readyAt (if one exists)
0000000000000000000000000000000000000000;;			nextReadyAt := never
0000000000000000000000000000000000000000;;			if waitingForQueue.Len() > 0 {
0000000000000000000000000000000000000000;;				entry := waitingForQueue.Peek().(*waitFor)
0000000000000000000000000000000000000000;;				nextReadyAt = q.clock.After(entry.readyAt.Sub(now))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-q.stopCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case <-q.heartbeat:
0000000000000000000000000000000000000000;;				// continue the loop, which will add ready items
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case <-nextReadyAt:
0000000000000000000000000000000000000000;;				// continue the loop, which will add ready items
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case waitEntry := <-q.waitingForAddCh:
0000000000000000000000000000000000000000;;				if waitEntry.readyAt.After(q.clock.Now()) {
0000000000000000000000000000000000000000;;					insert(waitingForQueue, waitingEntryByData, waitEntry)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					q.Add(waitEntry.data)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				drained := false
0000000000000000000000000000000000000000;;				for !drained {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case waitEntry := <-q.waitingForAddCh:
0000000000000000000000000000000000000000;;						if waitEntry.readyAt.After(q.clock.Now()) {
0000000000000000000000000000000000000000;;							insert(waitingForQueue, waitingEntryByData, waitEntry)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							q.Add(waitEntry.data)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						drained = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insert adds the entry to the priority queue, or updates the readyAt if it already exists in the queue
0000000000000000000000000000000000000000;;	func insert(q *waitForPriorityQueue, knownEntries map[t]*waitFor, entry *waitFor) {
0000000000000000000000000000000000000000;;		// if the entry already exists, update the time only if it would cause the item to be queued sooner
0000000000000000000000000000000000000000;;		existing, exists := knownEntries[entry.data]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			if existing.readyAt.After(entry.readyAt) {
0000000000000000000000000000000000000000;;				existing.readyAt = entry.readyAt
0000000000000000000000000000000000000000;;				heap.Fix(q, existing.index)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		heap.Push(q, entry)
0000000000000000000000000000000000000000;;		knownEntries[entry.data] = entry
0000000000000000000000000000000000000000;;	}
