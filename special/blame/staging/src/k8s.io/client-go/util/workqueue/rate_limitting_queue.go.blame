0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
10b3103818e7b548da55dfd39e7c754cc250626d;pkg/util/workqueue/rate_limitting_queue.go[pkg/util/workqueue/rate_limitting_queue.go][staging/src/k8s.io/client-go/util/workqueue/rate_limitting_queue.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workqueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RateLimitingInterface is an interface that rate limits items being added to the queue.
0000000000000000000000000000000000000000;;	type RateLimitingInterface interface {
0000000000000000000000000000000000000000;;		DelayingInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AddRateLimited adds an item to the workqueue after the rate limiter says its ok
0000000000000000000000000000000000000000;;		AddRateLimited(item interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Forget indicates that an item is finished being retried.  Doesn't matter whether its for perm failing
0000000000000000000000000000000000000000;;		// or for success, we'll stop the rate limiter from tracking it.  This only clears the `rateLimiter`, you
0000000000000000000000000000000000000000;;		// still have to call `Done` on the queue.
0000000000000000000000000000000000000000;;		Forget(item interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NumRequeues returns back how many times the item was requeued
0000000000000000000000000000000000000000;;		NumRequeues(item interface{}) int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRateLimitingQueue constructs a new workqueue with rateLimited queuing ability
0000000000000000000000000000000000000000;;	// Remember to call Forget!  If you don't, you may end up tracking failures forever.
0000000000000000000000000000000000000000;;	func NewRateLimitingQueue(rateLimiter RateLimiter) RateLimitingInterface {
0000000000000000000000000000000000000000;;		return &rateLimitingType{
0000000000000000000000000000000000000000;;			DelayingInterface: NewDelayingQueue(),
0000000000000000000000000000000000000000;;			rateLimiter:       rateLimiter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedRateLimitingQueue(rateLimiter RateLimiter, name string) RateLimitingInterface {
0000000000000000000000000000000000000000;;		return &rateLimitingType{
0000000000000000000000000000000000000000;;			DelayingInterface: NewNamedDelayingQueue(name),
0000000000000000000000000000000000000000;;			rateLimiter:       rateLimiter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rateLimitingType wraps an Interface and provides rateLimited re-enquing
0000000000000000000000000000000000000000;;	type rateLimitingType struct {
0000000000000000000000000000000000000000;;		DelayingInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rateLimiter RateLimiter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddRateLimited AddAfter's the item based on the time when the rate limiter says its ok
0000000000000000000000000000000000000000;;	func (q *rateLimitingType) AddRateLimited(item interface{}) {
0000000000000000000000000000000000000000;;		q.DelayingInterface.AddAfter(item, q.rateLimiter.When(item))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *rateLimitingType) NumRequeues(item interface{}) int {
0000000000000000000000000000000000000000;;		return q.rateLimiter.NumRequeues(item)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *rateLimitingType) Forget(item interface{}) {
0000000000000000000000000000000000000000;;		q.rateLimiter.Forget(item)
0000000000000000000000000000000000000000;;	}
