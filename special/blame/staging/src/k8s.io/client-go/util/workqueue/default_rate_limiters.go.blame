0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
10b3103818e7b548da55dfd39e7c754cc250626d;pkg/util/workqueue/default_rate_limiters.go[pkg/util/workqueue/default_rate_limiters.go][staging/src/k8s.io/client-go/util/workqueue/default_rate_limiters.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package workqueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/juju/ratelimit"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RateLimiter interface {
0000000000000000000000000000000000000000;;		// When gets an item and gets to decide how long that item should wait
0000000000000000000000000000000000000000;;		When(item interface{}) time.Duration
0000000000000000000000000000000000000000;;		// Forget indicates that an item is finished being retried.  Doesn't matter whether its for perm failing
0000000000000000000000000000000000000000;;		// or for success, we'll stop tracking it
0000000000000000000000000000000000000000;;		Forget(item interface{})
0000000000000000000000000000000000000000;;		// NumRequeues returns back how many failures the item has had
0000000000000000000000000000000000000000;;		NumRequeues(item interface{}) int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultControllerRateLimiter is a no-arg constructor for a default rate limiter for a workqueue.  It has
0000000000000000000000000000000000000000;;	// both overall and per-item rate limitting.  The overall is a token bucket and the per-item is exponential
0000000000000000000000000000000000000000;;	func DefaultControllerRateLimiter() RateLimiter {
0000000000000000000000000000000000000000;;		return NewMaxOfRateLimiter(
0000000000000000000000000000000000000000;;			NewItemExponentialFailureRateLimiter(5*time.Millisecond, 1000*time.Second),
0000000000000000000000000000000000000000;;			// 10 qps, 100 bucket size.  This is only for retry speed and its only the overall factor (not per item)
0000000000000000000000000000000000000000;;			&BucketRateLimiter{Bucket: ratelimit.NewBucketWithRate(float64(10), int64(100))},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BucketRateLimiter adapts a standard bucket to the workqueue ratelimiter API
0000000000000000000000000000000000000000;;	type BucketRateLimiter struct {
0000000000000000000000000000000000000000;;		*ratelimit.Bucket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ RateLimiter = &BucketRateLimiter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *BucketRateLimiter) When(item interface{}) time.Duration {
0000000000000000000000000000000000000000;;		return r.Bucket.Take(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *BucketRateLimiter) NumRequeues(item interface{}) int {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *BucketRateLimiter) Forget(item interface{}) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ItemExponentialFailureRateLimiter does a simple baseDelay*10^<num-failures> limit
0000000000000000000000000000000000000000;;	// dealing with max failures and expiration are up to the caller
0000000000000000000000000000000000000000;;	type ItemExponentialFailureRateLimiter struct {
0000000000000000000000000000000000000000;;		failuresLock sync.Mutex
0000000000000000000000000000000000000000;;		failures     map[interface{}]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		baseDelay time.Duration
0000000000000000000000000000000000000000;;		maxDelay  time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ RateLimiter = &ItemExponentialFailureRateLimiter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewItemExponentialFailureRateLimiter(baseDelay time.Duration, maxDelay time.Duration) RateLimiter {
0000000000000000000000000000000000000000;;		return &ItemExponentialFailureRateLimiter{
0000000000000000000000000000000000000000;;			failures:  map[interface{}]int{},
0000000000000000000000000000000000000000;;			baseDelay: baseDelay,
0000000000000000000000000000000000000000;;			maxDelay:  maxDelay,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultItemBasedRateLimiter() RateLimiter {
0000000000000000000000000000000000000000;;		return NewItemExponentialFailureRateLimiter(time.Millisecond, 1000*time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ItemExponentialFailureRateLimiter) When(item interface{}) time.Duration {
0000000000000000000000000000000000000000;;		r.failuresLock.Lock()
0000000000000000000000000000000000000000;;		defer r.failuresLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exp := r.failures[item]
0000000000000000000000000000000000000000;;		r.failures[item] = r.failures[item] + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The backoff is capped such that 'calculated' value never overflows.
0000000000000000000000000000000000000000;;		backoff := float64(r.baseDelay.Nanoseconds()) * math.Pow(2, float64(exp))
0000000000000000000000000000000000000000;;		if backoff > math.MaxInt64 {
0000000000000000000000000000000000000000;;			return r.maxDelay
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		calculated := time.Duration(backoff)
0000000000000000000000000000000000000000;;		if calculated > r.maxDelay {
0000000000000000000000000000000000000000;;			return r.maxDelay
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return calculated
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ItemExponentialFailureRateLimiter) NumRequeues(item interface{}) int {
0000000000000000000000000000000000000000;;		r.failuresLock.Lock()
0000000000000000000000000000000000000000;;		defer r.failuresLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.failures[item]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ItemExponentialFailureRateLimiter) Forget(item interface{}) {
0000000000000000000000000000000000000000;;		r.failuresLock.Lock()
0000000000000000000000000000000000000000;;		defer r.failuresLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(r.failures, item)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ItemFastSlowRateLimiter does a quick retry for a certain number of attempts, then a slow retry after that
0000000000000000000000000000000000000000;;	type ItemFastSlowRateLimiter struct {
0000000000000000000000000000000000000000;;		failuresLock sync.Mutex
0000000000000000000000000000000000000000;;		failures     map[interface{}]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxFastAttempts int
0000000000000000000000000000000000000000;;		fastDelay       time.Duration
0000000000000000000000000000000000000000;;		slowDelay       time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ RateLimiter = &ItemFastSlowRateLimiter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewItemFastSlowRateLimiter(fastDelay, slowDelay time.Duration, maxFastAttempts int) RateLimiter {
0000000000000000000000000000000000000000;;		return &ItemFastSlowRateLimiter{
0000000000000000000000000000000000000000;;			failures:        map[interface{}]int{},
0000000000000000000000000000000000000000;;			fastDelay:       fastDelay,
0000000000000000000000000000000000000000;;			slowDelay:       slowDelay,
0000000000000000000000000000000000000000;;			maxFastAttempts: maxFastAttempts,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ItemFastSlowRateLimiter) When(item interface{}) time.Duration {
0000000000000000000000000000000000000000;;		r.failuresLock.Lock()
0000000000000000000000000000000000000000;;		defer r.failuresLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.failures[item] = r.failures[item] + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.failures[item] <= r.maxFastAttempts {
0000000000000000000000000000000000000000;;			return r.fastDelay
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.slowDelay
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ItemFastSlowRateLimiter) NumRequeues(item interface{}) int {
0000000000000000000000000000000000000000;;		r.failuresLock.Lock()
0000000000000000000000000000000000000000;;		defer r.failuresLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.failures[item]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ItemFastSlowRateLimiter) Forget(item interface{}) {
0000000000000000000000000000000000000000;;		r.failuresLock.Lock()
0000000000000000000000000000000000000000;;		defer r.failuresLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(r.failures, item)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxOfRateLimiter calls every RateLimiter and returns the worst case response
0000000000000000000000000000000000000000;;	// When used with a token bucket limiter, the burst could be apparently exceeded in cases where particular items
0000000000000000000000000000000000000000;;	// were separately delayed a longer time.
0000000000000000000000000000000000000000;;	type MaxOfRateLimiter struct {
0000000000000000000000000000000000000000;;		limiters []RateLimiter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *MaxOfRateLimiter) When(item interface{}) time.Duration {
0000000000000000000000000000000000000000;;		ret := time.Duration(0)
0000000000000000000000000000000000000000;;		for _, limiter := range r.limiters {
0000000000000000000000000000000000000000;;			curr := limiter.When(item)
0000000000000000000000000000000000000000;;			if curr > ret {
0000000000000000000000000000000000000000;;				ret = curr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMaxOfRateLimiter(limiters ...RateLimiter) RateLimiter {
0000000000000000000000000000000000000000;;		return &MaxOfRateLimiter{limiters: limiters}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *MaxOfRateLimiter) NumRequeues(item interface{}) int {
0000000000000000000000000000000000000000;;		ret := 0
0000000000000000000000000000000000000000;;		for _, limiter := range r.limiters {
0000000000000000000000000000000000000000;;			curr := limiter.NumRequeues(item)
0000000000000000000000000000000000000000;;			if curr > ret {
0000000000000000000000000000000000000000;;				ret = curr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *MaxOfRateLimiter) Forget(item interface{}) {
0000000000000000000000000000000000000000;;		for _, limiter := range r.limiters {
0000000000000000000000000000000000000000;;			limiter.Forget(item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
