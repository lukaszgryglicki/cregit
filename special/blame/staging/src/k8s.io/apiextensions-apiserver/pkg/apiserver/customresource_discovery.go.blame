0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
478925937fcc89575869a3591897a08b1c355070;staging/src/k8s.io/kube-apiextensions-server/pkg/apiserver/customresource_discovery.go[staging/src/k8s.io/kube-apiextensions-server/pkg/apiserver/customresource_discovery.go][staging/src/k8s.io/apiextensions-apiserver/pkg/apiserver/customresource_discovery.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/discovery"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type versionDiscoveryHandler struct {
0000000000000000000000000000000000000000;;		// TODO, writing is infrequent, optimize this
0000000000000000000000000000000000000000;;		discoveryLock sync.RWMutex
0000000000000000000000000000000000000000;;		discovery     map[schema.GroupVersion]*discovery.APIVersionHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delegate http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *versionDiscoveryHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		pathParts := splitPath(req.URL.Path)
0000000000000000000000000000000000000000;;		// only match /apis/<group>/<version>
0000000000000000000000000000000000000000;;		if len(pathParts) != 3 || pathParts[0] != "apis" {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		discovery, ok := r.getDiscovery(schema.GroupVersion{Group: pathParts[1], Version: pathParts[2]})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discovery.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *versionDiscoveryHandler) getDiscovery(gv schema.GroupVersion) (*discovery.APIVersionHandler, bool) {
0000000000000000000000000000000000000000;;		r.discoveryLock.RLock()
0000000000000000000000000000000000000000;;		defer r.discoveryLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, ok := r.discovery[gv]
0000000000000000000000000000000000000000;;		return ret, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *versionDiscoveryHandler) setDiscovery(gv schema.GroupVersion, discovery *discovery.APIVersionHandler) {
0000000000000000000000000000000000000000;;		r.discoveryLock.Lock()
0000000000000000000000000000000000000000;;		defer r.discoveryLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.discovery[gv] = discovery
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *versionDiscoveryHandler) unsetDiscovery(gv schema.GroupVersion) {
0000000000000000000000000000000000000000;;		r.discoveryLock.Lock()
0000000000000000000000000000000000000000;;		defer r.discoveryLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(r.discovery, gv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type groupDiscoveryHandler struct {
0000000000000000000000000000000000000000;;		// TODO, writing is infrequent, optimize this
0000000000000000000000000000000000000000;;		discoveryLock sync.RWMutex
0000000000000000000000000000000000000000;;		discovery     map[string]*discovery.APIGroupHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delegate http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *groupDiscoveryHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		pathParts := splitPath(req.URL.Path)
0000000000000000000000000000000000000000;;		// only match /apis/<group>
0000000000000000000000000000000000000000;;		if len(pathParts) != 2 || pathParts[0] != "apis" {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		discovery, ok := r.getDiscovery(pathParts[1])
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discovery.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *groupDiscoveryHandler) getDiscovery(group string) (*discovery.APIGroupHandler, bool) {
0000000000000000000000000000000000000000;;		r.discoveryLock.RLock()
0000000000000000000000000000000000000000;;		defer r.discoveryLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, ok := r.discovery[group]
0000000000000000000000000000000000000000;;		return ret, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *groupDiscoveryHandler) setDiscovery(group string, discovery *discovery.APIGroupHandler) {
0000000000000000000000000000000000000000;;		r.discoveryLock.Lock()
0000000000000000000000000000000000000000;;		defer r.discoveryLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.discovery[group] = discovery
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *groupDiscoveryHandler) unsetDiscovery(group string) {
0000000000000000000000000000000000000000;;		r.discoveryLock.Lock()
0000000000000000000000000000000000000000;;		defer r.discoveryLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(r.discovery, group)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitPath returns the segments for a URL path.
0000000000000000000000000000000000000000;;	func splitPath(path string) []string {
0000000000000000000000000000000000000000;;		path = strings.Trim(path, "/")
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Split(path, "/")
0000000000000000000000000000000000000000;;	}
