0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
478925937fcc89575869a3591897a08b1c355070;staging/src/k8s.io/kube-apiextensions-server/pkg/apiserver/customresource_handler.go[staging/src/k8s.io/kube-apiextensions-server/pkg/apiserver/customresource_handler.go][staging/src/k8s.io/apiextensions-apiserver/pkg/apiserver/customresource_handler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/versioning"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers"
0000000000000000000000000000000000000000;;		apirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
0000000000000000000000000000000000000000;;		listers "k8s.io/apiextensions-apiserver/pkg/client/listers/apiextensions/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/controller/finalizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/registry/customresource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// crdHandler serves the `/apis` endpoint.
0000000000000000000000000000000000000000;;	// This is registered as a filter so that it never collides with any explictly registered endpoints
0000000000000000000000000000000000000000;;	type crdHandler struct {
0000000000000000000000000000000000000000;;		versionDiscoveryHandler *versionDiscoveryHandler
0000000000000000000000000000000000000000;;		groupDiscoveryHandler   *groupDiscoveryHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		customStorageLock sync.Mutex
0000000000000000000000000000000000000000;;		// customStorage contains a crdStorageMap
0000000000000000000000000000000000000000;;		customStorage atomic.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestContextMapper apirequest.RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdLister listers.CustomResourceDefinitionLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delegate          http.Handler
0000000000000000000000000000000000000000;;		restOptionsGetter generic.RESTOptionsGetter
0000000000000000000000000000000000000000;;		admission         admission.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// crdInfo stores enough information to serve the storage for the custom resource
0000000000000000000000000000000000000000;;	type crdInfo struct {
0000000000000000000000000000000000000000;;		storage      *customresource.REST
0000000000000000000000000000000000000000;;		requestScope handlers.RequestScope
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// crdStorageMap goes from customresourcedefinition to its storage
0000000000000000000000000000000000000000;;	type crdStorageMap map[types.UID]*crdInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCustomResourceDefinitionHandler(
0000000000000000000000000000000000000000;;		versionDiscoveryHandler *versionDiscoveryHandler,
0000000000000000000000000000000000000000;;		groupDiscoveryHandler *groupDiscoveryHandler,
0000000000000000000000000000000000000000;;		requestContextMapper apirequest.RequestContextMapper,
0000000000000000000000000000000000000000;;		crdLister listers.CustomResourceDefinitionLister,
0000000000000000000000000000000000000000;;		delegate http.Handler,
0000000000000000000000000000000000000000;;		restOptionsGetter generic.RESTOptionsGetter,
0000000000000000000000000000000000000000;;		admission admission.Interface) *crdHandler {
0000000000000000000000000000000000000000;;		ret := &crdHandler{
0000000000000000000000000000000000000000;;			versionDiscoveryHandler: versionDiscoveryHandler,
0000000000000000000000000000000000000000;;			groupDiscoveryHandler:   groupDiscoveryHandler,
0000000000000000000000000000000000000000;;			customStorage:           atomic.Value{},
0000000000000000000000000000000000000000;;			requestContextMapper:    requestContextMapper,
0000000000000000000000000000000000000000;;			crdLister:               crdLister,
0000000000000000000000000000000000000000;;			delegate:                delegate,
0000000000000000000000000000000000000000;;			restOptionsGetter:       restOptionsGetter,
0000000000000000000000000000000000000000;;			admission:               admission,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret.customStorage.Store(crdStorageMap{})
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *crdHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		ctx, ok := r.requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// programmer error
0000000000000000000000000000000000000000;;			panic("missing context")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestInfo, ok := apirequest.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// programmer error
0000000000000000000000000000000000000000;;			panic("missing requestInfo")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !requestInfo.IsResourceRequest {
0000000000000000000000000000000000000000;;			pathParts := splitPath(requestInfo.Path)
0000000000000000000000000000000000000000;;			// only match /apis/<group>/<version>
0000000000000000000000000000000000000000;;			// only registered under /apis
0000000000000000000000000000000000000000;;			if len(pathParts) == 3 {
0000000000000000000000000000000000000000;;				r.versionDiscoveryHandler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// only match /apis/<group>
0000000000000000000000000000000000000000;;			if len(pathParts) == 2 {
0000000000000000000000000000000000000000;;				r.groupDiscoveryHandler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdName := requestInfo.Resource + "." + requestInfo.APIGroup
0000000000000000000000000000000000000000;;		crd, err := r.crdLister.Get(crdName)
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if crd.Spec.Version != requestInfo.APIVersion {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiextensions.IsCRDConditionTrue(crd, apiextensions.Established) {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(requestInfo.Subresource) > 0 {
0000000000000000000000000000000000000000;;			http.NotFound(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		terminating := apiextensions.IsCRDConditionTrue(crd, apiextensions.Terminating)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdInfo := r.getServingInfoFor(crd)
0000000000000000000000000000000000000000;;		storage := crdInfo.storage
0000000000000000000000000000000000000000;;		requestScope := crdInfo.requestScope
0000000000000000000000000000000000000000;;		minRequestTimeout := 1 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch requestInfo.Verb {
0000000000000000000000000000000000000000;;		case "get":
0000000000000000000000000000000000000000;;			handler := handlers.GetResource(storage, storage, requestScope)
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "list":
0000000000000000000000000000000000000000;;			forceWatch := false
0000000000000000000000000000000000000000;;			handler := handlers.ListResource(storage, storage, requestScope, forceWatch, minRequestTimeout)
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "watch":
0000000000000000000000000000000000000000;;			forceWatch := true
0000000000000000000000000000000000000000;;			handler := handlers.ListResource(storage, storage, requestScope, forceWatch, minRequestTimeout)
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "create":
0000000000000000000000000000000000000000;;			if terminating {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("%v not allowed while CustomResourceDefinition is terminating", requestInfo.Verb), http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler := handlers.CreateResource(storage, requestScope, discovery.NewUnstructuredObjectTyper(nil), r.admission)
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "update":
0000000000000000000000000000000000000000;;			if terminating {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("%v not allowed while CustomResourceDefinition is terminating", requestInfo.Verb), http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler := handlers.UpdateResource(storage, requestScope, discovery.NewUnstructuredObjectTyper(nil), r.admission)
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "patch":
0000000000000000000000000000000000000000;;			if terminating {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("%v not allowed while CustomResourceDefinition is terminating", requestInfo.Verb), http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler := handlers.PatchResource(storage, requestScope, r.admission, unstructured.UnstructuredObjectConverter{})
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "delete":
0000000000000000000000000000000000000000;;			allowsOptions := true
0000000000000000000000000000000000000000;;			handler := handlers.DeleteResource(storage, allowsOptions, requestScope, r.admission)
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "deletecollection":
0000000000000000000000000000000000000000;;			checkBody := true
0000000000000000000000000000000000000000;;			handler := handlers.DeleteCollection(storage, checkBody, requestScope, r.admission)
0000000000000000000000000000000000000000;;			handler(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("unhandled verb %q", requestInfo.Verb), http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeDeadStorage removes REST storage that isn't being used
0000000000000000000000000000000000000000;;	func (r *crdHandler) removeDeadStorage() {
0000000000000000000000000000000000000000;;		// these don't have to be live.  A snapshot is fine
0000000000000000000000000000000000000000;;		// if we wrongly delete, that's ok.  The rest storage will be recreated on the next request
0000000000000000000000000000000000000000;;		// if we wrongly miss one, that's ok.  We'll get it next time
0000000000000000000000000000000000000000;;		storageMap := r.customStorage.Load().(crdStorageMap)
0000000000000000000000000000000000000000;;		allCustomResourceDefinitions, err := r.crdLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for uid := range storageMap {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, crd := range allCustomResourceDefinitions {
0000000000000000000000000000000000000000;;				if crd.UID == uid {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				delete(storageMap, uid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.customStorageLock.Lock()
0000000000000000000000000000000000000000;;		defer r.customStorageLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.customStorage.Store(storageMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCustomResourceListerCollectionDeleter returns the ListerCollectionDeleter for
0000000000000000000000000000000000000000;;	// the given uid, or nil if one does not exist.
0000000000000000000000000000000000000000;;	func (r *crdHandler) GetCustomResourceListerCollectionDeleter(crd *apiextensions.CustomResourceDefinition) finalizer.ListerCollectionDeleter {
0000000000000000000000000000000000000000;;		info := r.getServingInfoFor(crd)
0000000000000000000000000000000000000000;;		return info.storage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *crdHandler) getServingInfoFor(crd *apiextensions.CustomResourceDefinition) *crdInfo {
0000000000000000000000000000000000000000;;		storageMap := r.customStorage.Load().(crdStorageMap)
0000000000000000000000000000000000000000;;		ret, ok := storageMap[crd.UID]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.customStorageLock.Lock()
0000000000000000000000000000000000000000;;		defer r.customStorageLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, ok = storageMap[crd.UID]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In addition to Unstructured objects (Custom Resources), we also may sometimes need to
0000000000000000000000000000000000000000;;		// decode unversioned Options objects, so we delegate to parameterScheme for such types.
0000000000000000000000000000000000000000;;		parameterScheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		parameterScheme.AddUnversionedTypes(schema.GroupVersion{Group: crd.Spec.Group, Version: crd.Spec.Version},
0000000000000000000000000000000000000000;;			&metav1.ListOptions{},
0000000000000000000000000000000000000000;;			&metav1.ExportOptions{},
0000000000000000000000000000000000000000;;			&metav1.GetOptions{},
0000000000000000000000000000000000000000;;			&metav1.DeleteOptions{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		parameterScheme.AddGeneratedDeepCopyFuncs(metav1.GetGeneratedDeepCopyFuncs()...)
0000000000000000000000000000000000000000;;		parameterCodec := runtime.NewParameterCodec(parameterScheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kind := schema.GroupVersionKind{Group: crd.Spec.Group, Version: crd.Spec.Version, Kind: crd.Spec.Names.Kind}
0000000000000000000000000000000000000000;;		typer := unstructuredObjectTyper{
0000000000000000000000000000000000000000;;			delegate:          parameterScheme,
0000000000000000000000000000000000000000;;			unstructuredTyper: discovery.NewUnstructuredObjectTyper(nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		creator := unstructuredCreator{}
0000000000000000000000000000000000000000;;		storage := customresource.NewREST(
0000000000000000000000000000000000000000;;			schema.GroupResource{Group: crd.Spec.Group, Resource: crd.Spec.Names.Plural},
0000000000000000000000000000000000000000;;			schema.GroupVersionKind{Group: crd.Spec.Group, Version: crd.Spec.Version, Kind: crd.Spec.Names.ListKind},
0000000000000000000000000000000000000000;;			UnstructuredCopier{},
0000000000000000000000000000000000000000;;			customresource.NewStrategy(
0000000000000000000000000000000000000000;;				typer,
0000000000000000000000000000000000000000;;				crd.Spec.Scope == apiextensions.NamespaceScoped,
0000000000000000000000000000000000000000;;				kind,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			r.restOptionsGetter,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfLinkPrefix := ""
0000000000000000000000000000000000000000;;		switch crd.Spec.Scope {
0000000000000000000000000000000000000000;;		case apiextensions.ClusterScoped:
0000000000000000000000000000000000000000;;			selfLinkPrefix = "/" + path.Join("apis", crd.Spec.Group, crd.Spec.Version) + "/"
0000000000000000000000000000000000000000;;		case apiextensions.NamespaceScoped:
0000000000000000000000000000000000000000;;			selfLinkPrefix = "/" + path.Join("apis", crd.Spec.Group, crd.Spec.Version, "namespaces") + "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestScope := handlers.RequestScope{
0000000000000000000000000000000000000000;;			Namer: handlers.ContextBasedNaming{
0000000000000000000000000000000000000000;;				GetContext: func(req *http.Request) apirequest.Context {
0000000000000000000000000000000000000000;;					ret, _ := r.requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;					return ret
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SelfLinker:         meta.NewAccessor(),
0000000000000000000000000000000000000000;;				ClusterScoped:      crd.Spec.Scope == apiextensions.ClusterScoped,
0000000000000000000000000000000000000000;;				SelfLinkPathPrefix: selfLinkPrefix,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ContextFunc: func(req *http.Request) apirequest.Context {
0000000000000000000000000000000000000000;;				ret, _ := r.requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;				return ret
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Serializer:     unstructuredNegotiatedSerializer{typer: typer, creator: creator},
0000000000000000000000000000000000000000;;			ParameterCodec: parameterCodec,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Creater:         creator,
0000000000000000000000000000000000000000;;			Convertor:       unstructured.UnstructuredObjectConverter{},
0000000000000000000000000000000000000000;;			Defaulter:       unstructuredDefaulter{parameterScheme},
0000000000000000000000000000000000000000;;			Copier:          UnstructuredCopier{},
0000000000000000000000000000000000000000;;			Typer:           typer,
0000000000000000000000000000000000000000;;			UnsafeConvertor: unstructured.UnstructuredObjectConverter{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Resource:    schema.GroupVersionResource{Group: crd.Spec.Group, Version: crd.Spec.Version, Resource: crd.Spec.Names.Plural},
0000000000000000000000000000000000000000;;			Kind:        kind,
0000000000000000000000000000000000000000;;			Subresource: "",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			MetaGroupVersion: metav1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret = &crdInfo{
0000000000000000000000000000000000000000;;			storage:      storage,
0000000000000000000000000000000000000000;;			requestScope: requestScope,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storageMap[crd.UID] = ret
0000000000000000000000000000000000000000;;		r.customStorage.Store(storageMap)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unstructuredNegotiatedSerializer struct {
0000000000000000000000000000000000000000;;		typer   runtime.ObjectTyper
0000000000000000000000000000000000000000;;		creator runtime.ObjectCreater
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s unstructuredNegotiatedSerializer) SupportedMediaTypes() []runtime.SerializerInfo {
0000000000000000000000000000000000000000;;		return []runtime.SerializerInfo{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				MediaType:        "application/json",
0000000000000000000000000000000000000000;;				EncodesAsText:    true,
0000000000000000000000000000000000000000;;				Serializer:       json.NewSerializer(json.DefaultMetaFactory, s.creator, s.typer, false),
0000000000000000000000000000000000000000;;				PrettySerializer: json.NewSerializer(json.DefaultMetaFactory, s.creator, s.typer, true),
0000000000000000000000000000000000000000;;				StreamSerializer: &runtime.StreamSerializerInfo{
0000000000000000000000000000000000000000;;					EncodesAsText: true,
0000000000000000000000000000000000000000;;					Serializer:    json.NewSerializer(json.DefaultMetaFactory, s.creator, s.typer, false),
0000000000000000000000000000000000000000;;					Framer:        json.Framer,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s unstructuredNegotiatedSerializer) EncoderForVersion(serializer runtime.Encoder, gv runtime.GroupVersioner) runtime.Encoder {
0000000000000000000000000000000000000000;;		return versioning.NewDefaultingCodecForScheme(Scheme, crEncoderInstance, nil, gv, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s unstructuredNegotiatedSerializer) DecoderToVersion(serializer runtime.Decoder, gv runtime.GroupVersioner) runtime.Decoder {
0000000000000000000000000000000000000000;;		return unstructuredDecoder{delegate: Codecs.DecoderToVersion(serializer, gv)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unstructuredDecoder struct {
0000000000000000000000000000000000000000;;		delegate runtime.Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d unstructuredDecoder) Decode(data []byte, defaults *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		// Delegate for things other than Unstructured.
0000000000000000000000000000000000000000;;		if _, ok := into.(runtime.Unstructured); !ok && into != nil {
0000000000000000000000000000000000000000;;			return d.delegate.Decode(data, defaults, into)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unstructured.UnstructuredJSONScheme.Decode(data, defaults, into)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unstructuredObjectTyper struct {
0000000000000000000000000000000000000000;;		delegate          runtime.ObjectTyper
0000000000000000000000000000000000000000;;		unstructuredTyper runtime.ObjectTyper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t unstructuredObjectTyper) ObjectKinds(obj runtime.Object) ([]schema.GroupVersionKind, bool, error) {
0000000000000000000000000000000000000000;;		// Delegate for things other than Unstructured.
0000000000000000000000000000000000000000;;		if _, ok := obj.(runtime.Unstructured); !ok {
0000000000000000000000000000000000000000;;			return t.delegate.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.unstructuredTyper.ObjectKinds(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t unstructuredObjectTyper) Recognizes(gvk schema.GroupVersionKind) bool {
0000000000000000000000000000000000000000;;		return t.delegate.Recognizes(gvk) || t.unstructuredTyper.Recognizes(gvk)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var crEncoderInstance = crEncoder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// crEncoder *usually* encodes using the unstructured.UnstructuredJSONScheme, but if the type is Status or WatchEvent
0000000000000000000000000000000000000000;;	// it will serialize them out using the converting codec.
0000000000000000000000000000000000000000;;	type crEncoder struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (crEncoder) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *metav1.Status, *metav1.WatchEvent:
0000000000000000000000000000000000000000;;			for _, info := range Codecs.SupportedMediaTypes() {
0000000000000000000000000000000000000000;;				// we are always json
0000000000000000000000000000000000000000;;				if info.MediaType == "application/json" {
0000000000000000000000000000000000000000;;					return info.Serializer.Encode(obj, w)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to find json serializer for %T", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unstructured.UnstructuredJSONScheme.Encode(obj, w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unstructuredCreator struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c unstructuredCreator) New(kind schema.GroupVersionKind) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		ret := &unstructured.Unstructured{}
0000000000000000000000000000000000000000;;		ret.SetGroupVersionKind(kind)
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UnstructuredCopier struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (UnstructuredCopier) Copy(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if _, ok := obj.(runtime.Unstructured); !ok {
0000000000000000000000000000000000000000;;			// Callers should not use this UnstructuredCopier for things other than Unstructured.
0000000000000000000000000000000000000000;;			// If they do, the copy they get back will become Unstructured, which can lead to
0000000000000000000000000000000000000000;;			// difficult-to-debug errors downstream. To make such errors more obvious,
0000000000000000000000000000000000000000;;			// we explicitly reject anything that isn't Unstructured.
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("UnstructuredCopier can't copy type %T", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// serialize and deserialize to ensure a clean copy
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		err := unstructured.UnstructuredJSONScheme.Encode(obj, buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := &unstructured.Unstructured{}
0000000000000000000000000000000000000000;;		result, _, err := unstructured.UnstructuredJSONScheme.Decode(buf.Bytes(), nil, out)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unstructuredDefaulter struct {
0000000000000000000000000000000000000000;;		delegate runtime.ObjectDefaulter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d unstructuredDefaulter) Default(in runtime.Object) {
0000000000000000000000000000000000000000;;		// Delegate for things other than Unstructured.
0000000000000000000000000000000000000000;;		if _, ok := in.(runtime.Unstructured); !ok {
0000000000000000000000000000000000000000;;			d.delegate.Default(in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CRDRESTOptionsGetter struct {
0000000000000000000000000000000000000000;;		StorageConfig           storagebackend.Config
0000000000000000000000000000000000000000;;		StoragePrefix           string
0000000000000000000000000000000000000000;;		EnableWatchCache        bool
0000000000000000000000000000000000000000;;		DefaultWatchCacheSize   int
0000000000000000000000000000000000000000;;		EnableGarbageCollection bool
0000000000000000000000000000000000000000;;		DeleteCollectionWorkers int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t CRDRESTOptionsGetter) GetRESTOptions(resource schema.GroupResource) (generic.RESTOptions, error) {
0000000000000000000000000000000000000000;;		ret := generic.RESTOptions{
0000000000000000000000000000000000000000;;			StorageConfig:           &t.StorageConfig,
0000000000000000000000000000000000000000;;			Decorator:               generic.UndecoratedStorage,
0000000000000000000000000000000000000000;;			EnableGarbageCollection: t.EnableGarbageCollection,
0000000000000000000000000000000000000000;;			DeleteCollectionWorkers: t.DeleteCollectionWorkers,
0000000000000000000000000000000000000000;;			ResourcePrefix:          resource.Group + "/" + resource.Resource,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.EnableWatchCache {
0000000000000000000000000000000000000000;;			ret.Decorator = genericregistry.StorageWithCacher(t.DefaultWatchCacheSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
