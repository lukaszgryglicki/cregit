0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
5e7ba88435211b6b448ab330b995393899c40600;staging/src/k8s.io/kube-apiextensions-server/pkg/controller/status/naming_controller.go[staging/src/k8s.io/kube-apiextensions-server/pkg/controller/status/naming_controller.go][staging/src/k8s.io/apiextensions-apiserver/pkg/controller/status/naming_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
0000000000000000000000000000000000000000;;		client "k8s.io/apiextensions-apiserver/pkg/client/clientset/internalclientset/typed/apiextensions/internalversion"
0000000000000000000000000000000000000000;;		informers "k8s.io/apiextensions-apiserver/pkg/client/informers/internalversion/apiextensions/internalversion"
0000000000000000000000000000000000000000;;		listers "k8s.io/apiextensions-apiserver/pkg/client/listers/apiextensions/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cloner = conversion.NewCloner()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This controller is reserving names. To avoid conflicts, be sure to run only one instance of the worker at a time.
0000000000000000000000000000000000000000;;	// This could eventually be lifted, but starting simple.
0000000000000000000000000000000000000000;;	type NamingConditionController struct {
0000000000000000000000000000000000000000;;		crdClient client.CustomResourceDefinitionsGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdLister listers.CustomResourceDefinitionLister
0000000000000000000000000000000000000000;;		crdSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		// crdMutationCache backs our lister and keeps track of committed updates to avoid racy
0000000000000000000000000000000000000000;;		// write/lookup cycles.  It's got 100 slots by default, so it unlikely to overrun
0000000000000000000000000000000000000000;;		// TODO to revisit this if naming conflicts are found to occur in the wild
0000000000000000000000000000000000000000;;		crdMutationCache cache.MutationCache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To allow injection for testing.
0000000000000000000000000000000000000000;;		syncFn func(key string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamingConditionController(
0000000000000000000000000000000000000000;;		crdInformer informers.CustomResourceDefinitionInformer,
0000000000000000000000000000000000000000;;		crdClient client.CustomResourceDefinitionsGetter,
0000000000000000000000000000000000000000;;	) *NamingConditionController {
0000000000000000000000000000000000000000;;		c := &NamingConditionController{
0000000000000000000000000000000000000000;;			crdClient: crdClient,
0000000000000000000000000000000000000000;;			crdLister: crdInformer.Lister(),
0000000000000000000000000000000000000000;;			crdSynced: crdInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			queue:     workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "CustomResourceDefinition-NamingConditionController"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerIndexer := crdInformer.Informer().GetIndexer()
0000000000000000000000000000000000000000;;		c.crdMutationCache = cache.NewIntegerResourceVersionMutationCache(informerIndexer, informerIndexer, 60*time.Second, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    c.addCustomResourceDefinition,
0000000000000000000000000000000000000000;;			UpdateFunc: c.updateCustomResourceDefinition,
0000000000000000000000000000000000000000;;			DeleteFunc: c.deleteCustomResourceDefinition,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.syncFn = c.sync
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) getAcceptedNamesForGroup(group string) (allResources sets.String, allKinds sets.String) {
0000000000000000000000000000000000000000;;		allResources = sets.String{}
0000000000000000000000000000000000000000;;		allKinds = sets.String{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list, err := c.crdLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, curr := range list {
0000000000000000000000000000000000000000;;			if curr.Spec.Group != group {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// for each item here, see if we have a mutation cache entry that is more recent
0000000000000000000000000000000000000000;;			// this makes sure that if we tight loop on update and run, our mutation cache will show
0000000000000000000000000000000000000000;;			// us the version of the objects we just updated to.
0000000000000000000000000000000000000000;;			item := curr
0000000000000000000000000000000000000000;;			obj, exists, err := c.crdMutationCache.GetByKey(curr.Name)
0000000000000000000000000000000000000000;;			if exists && err == nil {
0000000000000000000000000000000000000000;;				item = obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allResources.Insert(item.Status.AcceptedNames.Plural)
0000000000000000000000000000000000000000;;			allResources.Insert(item.Status.AcceptedNames.Singular)
0000000000000000000000000000000000000000;;			allResources.Insert(item.Status.AcceptedNames.ShortNames...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allKinds.Insert(item.Status.AcceptedNames.Kind)
0000000000000000000000000000000000000000;;			allKinds.Insert(item.Status.AcceptedNames.ListKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allResources, allKinds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) calculateNamesAndConditions(in *apiextensions.CustomResourceDefinition) (apiextensions.CustomResourceDefinitionNames, apiextensions.CustomResourceDefinitionCondition, apiextensions.CustomResourceDefinitionCondition) {
0000000000000000000000000000000000000000;;		// Get the names that have already been claimed
0000000000000000000000000000000000000000;;		allResources, allKinds := c.getAcceptedNamesForGroup(in.Spec.Group)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namesAcceptedCondition := apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;			Type:   apiextensions.NamesAccepted,
0000000000000000000000000000000000000000;;			Status: apiextensions.ConditionUnknown,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestedNames := in.Spec.Names
0000000000000000000000000000000000000000;;		acceptedNames := in.Status.AcceptedNames
0000000000000000000000000000000000000000;;		newNames := in.Status.AcceptedNames
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check each name for mismatches.  If there's a mismatch between spec and status, then try to deconflict.
0000000000000000000000000000000000000000;;		// Continue on errors so that the status is the best match possible
0000000000000000000000000000000000000000;;		if err := equalToAcceptedOrFresh(requestedNames.Plural, acceptedNames.Plural, allResources); err != nil {
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Status = apiextensions.ConditionFalse
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Reason = "PluralConflict"
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Message = err.Error()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			newNames.Plural = requestedNames.Plural
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := equalToAcceptedOrFresh(requestedNames.Singular, acceptedNames.Singular, allResources); err != nil {
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Status = apiextensions.ConditionFalse
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Reason = "SingularConflict"
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Message = err.Error()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			newNames.Singular = requestedNames.Singular
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(requestedNames.ShortNames, acceptedNames.ShortNames) {
0000000000000000000000000000000000000000;;			errs := []error{}
0000000000000000000000000000000000000000;;			existingShortNames := sets.NewString(acceptedNames.ShortNames...)
0000000000000000000000000000000000000000;;			for _, shortName := range requestedNames.ShortNames {
0000000000000000000000000000000000000000;;				// if the shortname is already ours, then we're fine
0000000000000000000000000000000000000000;;				if existingShortNames.Has(shortName) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := equalToAcceptedOrFresh(shortName, "", allResources); err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := utilerrors.NewAggregate(errs); err != nil {
0000000000000000000000000000000000000000;;				namesAcceptedCondition.Status = apiextensions.ConditionFalse
0000000000000000000000000000000000000000;;				namesAcceptedCondition.Reason = "ShortNamesConflict"
0000000000000000000000000000000000000000;;				namesAcceptedCondition.Message = err.Error()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newNames.ShortNames = requestedNames.ShortNames
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := equalToAcceptedOrFresh(requestedNames.Kind, acceptedNames.Kind, allKinds); err != nil {
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Status = apiextensions.ConditionFalse
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Reason = "KindConflict"
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Message = err.Error()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			newNames.Kind = requestedNames.Kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := equalToAcceptedOrFresh(requestedNames.ListKind, acceptedNames.ListKind, allKinds); err != nil {
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Status = apiextensions.ConditionFalse
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Reason = "ListKindConflict"
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Message = err.Error()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			newNames.ListKind = requestedNames.ListKind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we haven't changed the condition, then our names must be good.
0000000000000000000000000000000000000000;;		if namesAcceptedCondition.Status == apiextensions.ConditionUnknown {
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Status = apiextensions.ConditionTrue
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Reason = "NoConflicts"
0000000000000000000000000000000000000000;;			namesAcceptedCondition.Message = "no conflicts found"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set EstablishedCondition to true if all names are accepted. Never set it back to false.
0000000000000000000000000000000000000000;;		establishedCondition := apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;			Type:               apiextensions.Established,
0000000000000000000000000000000000000000;;			Status:             apiextensions.ConditionFalse,
0000000000000000000000000000000000000000;;			Reason:             "NotAccepted",
0000000000000000000000000000000000000000;;			Message:            "not all names are accepted",
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.NewTime(time.Now()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if old := apiextensions.FindCRDCondition(in, apiextensions.Established); old != nil {
0000000000000000000000000000000000000000;;			establishedCondition = *old
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if establishedCondition.Status != apiextensions.ConditionTrue && namesAcceptedCondition.Status == apiextensions.ConditionTrue {
0000000000000000000000000000000000000000;;			establishedCondition = apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;				Type:               apiextensions.Established,
0000000000000000000000000000000000000000;;				Status:             apiextensions.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason:             "InitialNamesAccepted",
0000000000000000000000000000000000000000;;				Message:            "the initial names have been accepted",
0000000000000000000000000000000000000000;;				LastTransitionTime: metav1.NewTime(time.Now()),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newNames, namesAcceptedCondition, establishedCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalToAcceptedOrFresh(requestedName, acceptedName string, usedNames sets.String) error {
0000000000000000000000000000000000000000;;		if requestedName == acceptedName {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !usedNames.Has(requestedName) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("%q is already in use", requestedName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) sync(key string) error {
0000000000000000000000000000000000000000;;		inCustomResourceDefinition, err := c.crdLister.Get(key)
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			// CRD was deleted and has freed its names.
0000000000000000000000000000000000000000;;			// Reconsider all other CRDs in the same group.
0000000000000000000000000000000000000000;;			if err := c.requeueAllOtherGroupCRDs(key); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		acceptedNames, namingCondition, establishedCondition := c.calculateNamesAndConditions(inCustomResourceDefinition)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nothing to do if accepted names and NamesAccepted condition didn't change
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(inCustomResourceDefinition.Status.AcceptedNames, acceptedNames) &&
0000000000000000000000000000000000000000;;			apiextensions.IsCRDConditionEquivalent(&namingCondition, apiextensions.FindCRDCondition(inCustomResourceDefinition, apiextensions.NamesAccepted)) &&
0000000000000000000000000000000000000000;;			apiextensions.IsCRDConditionEquivalent(&establishedCondition, apiextensions.FindCRDCondition(inCustomResourceDefinition, apiextensions.Established)) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crd := &apiextensions.CustomResourceDefinition{}
0000000000000000000000000000000000000000;;		if err := apiextensions.DeepCopy_apiextensions_CustomResourceDefinition(inCustomResourceDefinition, crd, cloner); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crd.Status.AcceptedNames = acceptedNames
0000000000000000000000000000000000000000;;		apiextensions.SetCRDCondition(crd, namingCondition)
0000000000000000000000000000000000000000;;		apiextensions.SetCRDCondition(crd, establishedCondition)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedObj, err := c.crdClient.CustomResourceDefinitions().UpdateStatus(crd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the update was successful, go ahead and add the entry to the mutation cache
0000000000000000000000000000000000000000;;		c.crdMutationCache.Mutation(updatedObj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we updated our status, so we may be releasing a name.  When this happens, we need to rekick everything in our group
0000000000000000000000000000000000000000;;		// if we fail to rekick, just return as normal.  We'll get everything on a resync
0000000000000000000000000000000000000000;;		if err := c.requeueAllOtherGroupCRDs(key); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer c.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting NamingConditionController")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down NamingConditionController")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cache.WaitForCacheSync(stopCh, c.crdSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only start one worker thread since its a slow moving API and the naming conflict resolution bits aren't thread-safe
0000000000000000000000000000000000000000;;		go wait.Until(c.runWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) runWorker() {
0000000000000000000000000000000000000000;;		for c.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := c.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer c.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.syncFn(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			c.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("%v failed with: %v", key, err))
0000000000000000000000000000000000000000;;		c.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) enqueue(obj *apiextensions.CustomResourceDefinition) {
0000000000000000000000000000000000000000;;		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %#v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) addCustomResourceDefinition(obj interface{}) {
0000000000000000000000000000000000000000;;		castObj := obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Adding %s", castObj.Name)
0000000000000000000000000000000000000000;;		c.enqueue(castObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) updateCustomResourceDefinition(obj, _ interface{}) {
0000000000000000000000000000000000000000;;		castObj := obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Updating %s", castObj.Name)
0000000000000000000000000000000000000000;;		c.enqueue(castObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) deleteCustomResourceDefinition(obj interface{}) {
0000000000000000000000000000000000000000;;		castObj, ok := obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get object from tombstone %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			castObj, ok = tombstone.Obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Tombstone contained object that is not expected %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Deleting %q", castObj.Name)
0000000000000000000000000000000000000000;;		c.enqueue(castObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *NamingConditionController) requeueAllOtherGroupCRDs(name string) error {
0000000000000000000000000000000000000000;;		pluralGroup := strings.SplitN(name, ".", 2)
0000000000000000000000000000000000000000;;		list, err := c.crdLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, curr := range list {
0000000000000000000000000000000000000000;;			if curr.Spec.Group == pluralGroup[1] && curr.Name != name {
0000000000000000000000000000000000000000;;				c.queue.Add(curr.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
