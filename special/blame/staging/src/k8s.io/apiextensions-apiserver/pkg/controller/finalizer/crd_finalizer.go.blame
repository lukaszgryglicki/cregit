0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6fdfaa00d90dd24a01d8a4428a463ae663d27284;staging/src/k8s.io/kube-apiextensions-server/pkg/controller/finalizer/crd_finalizer.go[staging/src/k8s.io/kube-apiextensions-server/pkg/controller/finalizer/crd_finalizer.go][staging/src/k8s.io/apiextensions-apiserver/pkg/controller/finalizer/crd_finalizer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package finalizer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
0000000000000000000000000000000000000000;;		client "k8s.io/apiextensions-apiserver/pkg/client/clientset/internalclientset/typed/apiextensions/internalversion"
0000000000000000000000000000000000000000;;		informers "k8s.io/apiextensions-apiserver/pkg/client/informers/internalversion/apiextensions/internalversion"
0000000000000000000000000000000000000000;;		listers "k8s.io/apiextensions-apiserver/pkg/client/listers/apiextensions/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cloner = conversion.NewCloner()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CRDFinalizer is a controller that finalizes the CRD by deleting all the CRs associated with it.
0000000000000000000000000000000000000000;;	type CRDFinalizer struct {
0000000000000000000000000000000000000000;;		crdClient      client.CustomResourceDefinitionsGetter
0000000000000000000000000000000000000000;;		crClientGetter CRClientGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdLister listers.CustomResourceDefinitionLister
0000000000000000000000000000000000000000;;		crdSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To allow injection for testing.
0000000000000000000000000000000000000000;;		syncFn func(key string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListerCollectionDeleter combines rest.Lister and rest.CollectionDeleter.
0000000000000000000000000000000000000000;;	type ListerCollectionDeleter interface {
0000000000000000000000000000000000000000;;		rest.Lister
0000000000000000000000000000000000000000;;		rest.CollectionDeleter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CRClientGetter knows how to get a ListerCollectionDeleter for a given CRD UID.
0000000000000000000000000000000000000000;;	type CRClientGetter interface {
0000000000000000000000000000000000000000;;		// GetCustomResourceListerCollectionDeleter gets the ListerCollectionDeleter for the given CRD
0000000000000000000000000000000000000000;;		// UID.
0000000000000000000000000000000000000000;;		GetCustomResourceListerCollectionDeleter(crd *apiextensions.CustomResourceDefinition) ListerCollectionDeleter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCRDFinalizer creates a new CRDFinalizer.
0000000000000000000000000000000000000000;;	func NewCRDFinalizer(
0000000000000000000000000000000000000000;;		crdInformer informers.CustomResourceDefinitionInformer,
0000000000000000000000000000000000000000;;		crdClient client.CustomResourceDefinitionsGetter,
0000000000000000000000000000000000000000;;		crClientGetter CRClientGetter,
0000000000000000000000000000000000000000;;	) *CRDFinalizer {
0000000000000000000000000000000000000000;;		c := &CRDFinalizer{
0000000000000000000000000000000000000000;;			crdClient:      crdClient,
0000000000000000000000000000000000000000;;			crdLister:      crdInformer.Lister(),
0000000000000000000000000000000000000000;;			crdSynced:      crdInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			crClientGetter: crClientGetter,
0000000000000000000000000000000000000000;;			queue:          workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "CustomResourceDefinition-CRDFinalizer"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    c.addCustomResourceDefinition,
0000000000000000000000000000000000000000;;			UpdateFunc: c.updateCustomResourceDefinition,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.syncFn = c.sync
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) sync(key string) error {
0000000000000000000000000000000000000000;;		cachedCRD, err := c.crdLister.Get(key)
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no work to do
0000000000000000000000000000000000000000;;		if cachedCRD.DeletionTimestamp.IsZero() || !apiextensions.CRDHasFinalizer(cachedCRD, apiextensions.CustomResourceCleanupFinalizer) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crd := &apiextensions.CustomResourceDefinition{}
0000000000000000000000000000000000000000;;		if err := apiextensions.DeepCopy_apiextensions_CustomResourceDefinition(cachedCRD, crd, cloner); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update the status condition.  This cleanup could take a while.
0000000000000000000000000000000000000000;;		apiextensions.SetCRDCondition(crd, apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;			Type:    apiextensions.Terminating,
0000000000000000000000000000000000000000;;			Status:  apiextensions.ConditionTrue,
0000000000000000000000000000000000000000;;			Reason:  "InstanceDeletionInProgress",
0000000000000000000000000000000000000000;;			Message: "CustomResource deletion is in progress",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		crd, err = c.crdClient.CustomResourceDefinitions().UpdateStatus(crd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we can start deleting items.  We should use the REST API to ensure that all normal admission runs.
0000000000000000000000000000000000000000;;		// Since we control the endpoints, we know that delete collection works. No need to delete if not established.
0000000000000000000000000000000000000000;;		if apiextensions.IsCRDConditionTrue(crd, apiextensions.Established) {
0000000000000000000000000000000000000000;;			cond, deleteErr := c.deleteInstances(crd)
0000000000000000000000000000000000000000;;			apiextensions.SetCRDCondition(crd, cond)
0000000000000000000000000000000000000000;;			if deleteErr != nil {
0000000000000000000000000000000000000000;;				crd, err = c.crdClient.CustomResourceDefinitions().UpdateStatus(crd)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return deleteErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			apiextensions.SetCRDCondition(crd, apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;				Type:    apiextensions.Terminating,
0000000000000000000000000000000000000000;;				Status:  apiextensions.ConditionFalse,
0000000000000000000000000000000000000000;;				Reason:  "NeverEstablished",
0000000000000000000000000000000000000000;;				Message: "resource was never established",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiextensions.CRDRemoveFinalizer(crd, apiextensions.CustomResourceCleanupFinalizer)
0000000000000000000000000000000000000000;;		crd, err = c.crdClient.CustomResourceDefinitions().UpdateStatus(crd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// and now issue another delete, which should clean it all up if no finalizers remain or no-op if they do
0000000000000000000000000000000000000000;;		return c.crdClient.CustomResourceDefinitions().Delete(crd.Name, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) deleteInstances(crd *apiextensions.CustomResourceDefinition) (apiextensions.CustomResourceDefinitionCondition, error) {
0000000000000000000000000000000000000000;;		// Now we can start deleting items. While it would be ideal to use a REST API client, doing so
0000000000000000000000000000000000000000;;		// could incorrectly delete a ThirdPartyResource with the same URL as the CustomResource, so we go
0000000000000000000000000000000000000000;;		// directly to the storage instead. Since we control the storage, we know that delete collection works.
0000000000000000000000000000000000000000;;		crClient := c.crClientGetter.GetCustomResourceListerCollectionDeleter(crd)
0000000000000000000000000000000000000000;;		if crClient == nil {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("unable to find a custom resource client for %s.%s", crd.Status.AcceptedNames.Plural, crd.Spec.Group)
0000000000000000000000000000000000000000;;			return apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;				Type:    apiextensions.Terminating,
0000000000000000000000000000000000000000;;				Status:  apiextensions.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason:  "InstanceDeletionFailed",
0000000000000000000000000000000000000000;;				Message: fmt.Sprintf("could not list instances: %v", err),
0000000000000000000000000000000000000000;;			}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewContext()
0000000000000000000000000000000000000000;;		allResources, err := crClient.List(ctx, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;				Type:    apiextensions.Terminating,
0000000000000000000000000000000000000000;;				Status:  apiextensions.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason:  "InstanceDeletionFailed",
0000000000000000000000000000000000000000;;				Message: fmt.Sprintf("could not list instances: %v", err),
0000000000000000000000000000000000000000;;			}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deletedNamespaces := sets.String{}
0000000000000000000000000000000000000000;;		deleteErrors := []error{}
0000000000000000000000000000000000000000;;		for _, item := range allResources.(*unstructured.UnstructuredList).Items {
0000000000000000000000000000000000000000;;			metadata, err := meta.Accessor(&item)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if deletedNamespaces.Has(metadata.GetNamespace()) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// don't retry deleting the same namespace
0000000000000000000000000000000000000000;;			deletedNamespaces.Insert(metadata.GetNamespace())
0000000000000000000000000000000000000000;;			nsCtx := genericapirequest.WithNamespace(ctx, metadata.GetNamespace())
0000000000000000000000000000000000000000;;			if _, err := crClient.DeleteCollection(nsCtx, nil, nil); err != nil {
0000000000000000000000000000000000000000;;				deleteErrors = append(deleteErrors, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deleteError := utilerrors.NewAggregate(deleteErrors); deleteError != nil {
0000000000000000000000000000000000000000;;			return apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;				Type:    apiextensions.Terminating,
0000000000000000000000000000000000000000;;				Status:  apiextensions.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason:  "InstanceDeletionFailed",
0000000000000000000000000000000000000000;;				Message: fmt.Sprintf("could not issue all deletes: %v", deleteError),
0000000000000000000000000000000000000000;;			}, deleteError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now we need to wait until all the resources are deleted.  Start with a simple poll before we do anything fancy.
0000000000000000000000000000000000000000;;		// TODO not all servers are synchronized on caches.  It is possible for a stale one to still be creating things.
0000000000000000000000000000000000000000;;		// Once we have a mechanism for servers to indicate their states, we should check that for concurrence.
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(5*time.Second, 1*time.Minute, func() (bool, error) {
0000000000000000000000000000000000000000;;			listObj, err := crClient.List(ctx, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(listObj.(*unstructured.UnstructuredList).Items) == 0 {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("%s.%s waiting for %d items to be removed", crd.Status.AcceptedNames.Plural, crd.Spec.Group, len(listObj.(*unstructured.UnstructuredList).Items))
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;				Type:    apiextensions.Terminating,
0000000000000000000000000000000000000000;;				Status:  apiextensions.ConditionTrue,
0000000000000000000000000000000000000000;;				Reason:  "InstanceDeletionCheck",
0000000000000000000000000000000000000000;;				Message: fmt.Sprintf("could not confirm zero CustomResources remaining: %v", err),
0000000000000000000000000000000000000000;;			}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return apiextensions.CustomResourceDefinitionCondition{
0000000000000000000000000000000000000000;;			Type:    apiextensions.Terminating,
0000000000000000000000000000000000000000;;			Status:  apiextensions.ConditionFalse,
0000000000000000000000000000000000000000;;			Reason:  "InstanceDeletionCompleted",
0000000000000000000000000000000000000000;;			Message: "removed all instances",
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) Run(workers int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer c.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting CRDFinalizer")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down CRDFinalizer")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cache.WaitForCacheSync(stopCh, c.crdSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < workers; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(c.runWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) runWorker() {
0000000000000000000000000000000000000000;;		for c.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := c.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer c.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.syncFn(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			c.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("%v failed with: %v", key, err))
0000000000000000000000000000000000000000;;		c.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) enqueue(obj *apiextensions.CustomResourceDefinition) {
0000000000000000000000000000000000000000;;		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't get key for object %#v: %v", obj, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) addCustomResourceDefinition(obj interface{}) {
0000000000000000000000000000000000000000;;		castObj := obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;		// only queue deleted things
0000000000000000000000000000000000000000;;		if !castObj.DeletionTimestamp.IsZero() && apiextensions.CRDHasFinalizer(castObj, apiextensions.CustomResourceCleanupFinalizer) {
0000000000000000000000000000000000000000;;			c.enqueue(castObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CRDFinalizer) updateCustomResourceDefinition(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		oldCRD := oldObj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;		newCRD := newObj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;		// only queue deleted things that haven't been finalized by us
0000000000000000000000000000000000000000;;		if newCRD.DeletionTimestamp.IsZero() || !apiextensions.CRDHasFinalizer(newCRD, apiextensions.CustomResourceCleanupFinalizer) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always requeue resyncs just in case
0000000000000000000000000000000000000000;;		if oldCRD.ResourceVersion == newCRD.ResourceVersion {
0000000000000000000000000000000000000000;;			c.enqueue(newCRD)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the only difference is in the terminating condition, then there's no reason to requeue here.  This controller
0000000000000000000000000000000000000000;;		// is likely to be the originator, so requeuing would hot-loop us.  Failures are requeued by the workqueue directly.
0000000000000000000000000000000000000000;;		// This is a low traffic and scale resource, so the copy is terrible.  It's not good, so better ideas
0000000000000000000000000000000000000000;;		// are welcome.
0000000000000000000000000000000000000000;;		oldCopy := &apiextensions.CustomResourceDefinition{}
0000000000000000000000000000000000000000;;		if err := apiextensions.DeepCopy_apiextensions_CustomResourceDefinition(oldCRD, oldCopy, cloner); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			c.enqueue(newCRD)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newCopy := &apiextensions.CustomResourceDefinition{}
0000000000000000000000000000000000000000;;		if err := apiextensions.DeepCopy_apiextensions_CustomResourceDefinition(newCRD, newCopy, cloner); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			c.enqueue(newCRD)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldCopy.ResourceVersion = ""
0000000000000000000000000000000000000000;;		newCopy.ResourceVersion = ""
0000000000000000000000000000000000000000;;		apiextensions.RemoveCRDCondition(oldCopy, apiextensions.Terminating)
0000000000000000000000000000000000000000;;		apiextensions.RemoveCRDCondition(newCopy, apiextensions.Terminating)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(oldCopy, newCopy) {
0000000000000000000000000000000000000000;;			c.enqueue(newCRD)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
