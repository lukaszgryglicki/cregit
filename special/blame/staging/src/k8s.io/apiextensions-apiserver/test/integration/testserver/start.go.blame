0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
ebd01e8e95ce705fb582413d551bed7c9d666b08;staging/src/k8s.io/kube-apiextensions-server/test/integration/testserver/start.go[staging/src/k8s.io/kube-apiextensions-server/test/integration/testserver/start.go][staging/src/k8s.io/apiextensions-apiserver/test/integration/testserver/start.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extensionsapiserver "k8s.io/apiextensions-apiserver/pkg/apiserver"
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/cmd/server"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizerfactory"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultServerConfig() (*extensionsapiserver.Config, error) {
0000000000000000000000000000000000000000;;		port, err := FindFreeLocalPort()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := server.NewCustomResourceDefinitionsServerOptions(os.Stdout, os.Stderr)
0000000000000000000000000000000000000000;;		options.RecommendedOptions.Audit.LogOptions.Path = "-"
0000000000000000000000000000000000000000;;		options.RecommendedOptions.SecureServing.BindPort = port
0000000000000000000000000000000000000000;;		options.RecommendedOptions.Authentication.SkipInClusterLookup = true
0000000000000000000000000000000000000000;;		options.RecommendedOptions.SecureServing.BindAddress = net.ParseIP("127.0.0.1")
0000000000000000000000000000000000000000;;		etcdURL, ok := os.LookupEnv("KUBE_INTEGRATION_ETCD_URL")
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			etcdURL = "http://127.0.0.1:2379"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options.RecommendedOptions.Etcd.StorageConfig.ServerList = []string{etcdURL}
0000000000000000000000000000000000000000;;		options.RecommendedOptions.Etcd.StorageConfig.Prefix = uuid.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO stop copying this
0000000000000000000000000000000000000000;;		// because there isn't currently a way to disable authentication or authorization from options
0000000000000000000000000000000000000000;;		// explode options.Config here
0000000000000000000000000000000000000000;;		genericConfig := genericapiserver.NewConfig(extensionsapiserver.Codecs)
0000000000000000000000000000000000000000;;		genericConfig.Authenticator = nil
0000000000000000000000000000000000000000;;		genericConfig.Authorizer = authorizerfactory.NewAlwaysAllowAuthorizer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := options.RecommendedOptions.SecureServing.MaybeDefaultWithSelfSignedCerts("localhost", nil, []net.IP{net.ParseIP("127.0.0.1")}); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating self-signed certificates: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RecommendedOptions.Etcd.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RecommendedOptions.SecureServing.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RecommendedOptions.Audit.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := options.RecommendedOptions.Features.ApplyTo(genericConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		customResourceDefinitionRESTOptionsGetter := extensionsapiserver.CRDRESTOptionsGetter{
0000000000000000000000000000000000000000;;			StorageConfig:           options.RecommendedOptions.Etcd.StorageConfig,
0000000000000000000000000000000000000000;;			StoragePrefix:           options.RecommendedOptions.Etcd.StorageConfig.Prefix,
0000000000000000000000000000000000000000;;			EnableWatchCache:        options.RecommendedOptions.Etcd.EnableWatchCache,
0000000000000000000000000000000000000000;;			DefaultWatchCacheSize:   options.RecommendedOptions.Etcd.DefaultWatchCacheSize,
0000000000000000000000000000000000000000;;			EnableGarbageCollection: options.RecommendedOptions.Etcd.EnableGarbageCollection,
0000000000000000000000000000000000000000;;			DeleteCollectionWorkers: options.RecommendedOptions.Etcd.DeleteCollectionWorkers,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		customResourceDefinitionRESTOptionsGetter.StorageConfig.Codec = unstructured.UnstructuredJSONScheme
0000000000000000000000000000000000000000;;		customResourceDefinitionRESTOptionsGetter.StorageConfig.Copier = extensionsapiserver.UnstructuredCopier{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := &extensionsapiserver.Config{
0000000000000000000000000000000000000000;;			GenericConfig:        genericConfig,
0000000000000000000000000000000000000000;;			CRDRESTOptionsGetter: customResourceDefinitionRESTOptionsGetter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StartServer(config *extensionsapiserver.Config) (chan struct{}, clientset.Interface, dynamic.ClientPool, error) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		server, err := config.Complete().New(genericapiserver.EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			err := server.GenericAPIServer.PrepareRun().Run(stopCh)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				close(stopCh)
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until the server is healthy
0000000000000000000000000000000000000000;;		err = wait.PollImmediate(30*time.Millisecond, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			healthClient, err := clientset.NewForConfig(server.GenericAPIServer.LoopbackClientConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			healthResult := healthClient.Discovery().RESTClient().Get().AbsPath("/healthz").Do()
0000000000000000000000000000000000000000;;			if healthResult.Error() != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rawHealth, err := healthResult.Raw()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if string(rawHealth) != "ok" {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiExtensionsClient, err := clientset.NewForConfig(server.GenericAPIServer.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			close(stopCh)
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bytes, _ := apiExtensionsClient.Discovery().RESTClient().Get().AbsPath("/apis/apiextensions.k8s.io/v1beta1").DoRaw()
0000000000000000000000000000000000000000;;		fmt.Print(string(bytes))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stopCh, apiExtensionsClient, dynamic.NewDynamicClientPool(server.GenericAPIServer.LoopbackClientConfig), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StartDefaultServer() (chan struct{}, clientset.Interface, dynamic.ClientPool, error) {
0000000000000000000000000000000000000000;;		config, err := DefaultServerConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return StartServer(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindFreeLocalPort returns the number of an available port number on
0000000000000000000000000000000000000000;;	// the loopback interface.  Useful for determining the port to launch
0000000000000000000000000000000000000000;;	// a server on.  Error handling required - there is a non-zero chance
0000000000000000000000000000000000000000;;	// that the returned port number will be bound by another process
0000000000000000000000000000000000000000;;	// after this function returns.
0000000000000000000000000000000000000000;;	func FindFreeLocalPort() (int, error) {
0000000000000000000000000000000000000000;;		l, err := net.Listen("tcp", ":0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer l.Close()
0000000000000000000000000000000000000000;;		_, portStr, err := net.SplitHostPort(l.Addr().String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port, err := strconv.Atoi(portStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return port, nil
0000000000000000000000000000000000000000;;	}
