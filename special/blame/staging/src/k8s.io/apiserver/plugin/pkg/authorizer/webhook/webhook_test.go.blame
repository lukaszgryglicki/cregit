0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
394c380f34ab4af4adf1f6d112d2f1ea3a21a47d;plugin/pkg/auth/authorizer/webhook/webhook_test.go[plugin/pkg/auth/authorizer/webhook/webhook_test.go][staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/authorization/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd/api/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFromConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		dir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := struct {
0000000000000000000000000000000000000000;;			CA   string
0000000000000000000000000000000000000000;;			Cert string
0000000000000000000000000000000000000000;;			Key  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			CA:   filepath.Join(dir, "ca.pem"),
0000000000000000000000000000000000000000;;			Cert: filepath.Join(dir, "clientcert.pem"),
0000000000000000000000000000000000000000;;			Key:  filepath.Join(dir, "clientkey.pem"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;			data []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{data.CA, caCert},
0000000000000000000000000000000000000000;;			{data.Cert, clientCert},
0000000000000000000000000000000000000000;;			{data.Key, clientKey},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			if err := ioutil.WriteFile(file.name, file.data, 0400); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			msg        string
0000000000000000000000000000000000000000;;			configTmpl string
0000000000000000000000000000000000000000;;			wantErr    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "a single cluster and single user",
0000000000000000000000000000000000000000;;				configTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://authz.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a cluster
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "multiple clusters with no context",
0000000000000000000000000000000000000000;;				configTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://authz.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: a bad certificate path
0000000000000000000000000000000000000000;;	    server: https://authz.example.com
0000000000000000000000000000000000000000;;	  name: barfoo
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a name
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "multiple clusters with a context",
0000000000000000000000000000000000000000;;				configTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: a bad certificate path
0000000000000000000000000000000000000000;;	    server: https://authz.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://authz.example.com
0000000000000000000000000000000000000000;;	  name: barfoo
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a name
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- name: default
0000000000000000000000000000000000000000;;	  context:
0000000000000000000000000000000000000000;;	    cluster: barfoo
0000000000000000000000000000000000000000;;	    user: a name
0000000000000000000000000000000000000000;;	current-context: default
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				msg: "cluster with bad certificate path specified",
0000000000000000000000000000000000000000;;				configTmpl: `
0000000000000000000000000000000000000000;;	clusters:
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: a bad certificate path
0000000000000000000000000000000000000000;;	    server: https://authz.example.com
0000000000000000000000000000000000000000;;	  name: foobar
0000000000000000000000000000000000000000;;	- cluster:
0000000000000000000000000000000000000000;;	    certificate-authority: {{ .CA }}
0000000000000000000000000000000000000000;;	    server: https://authz.example.com
0000000000000000000000000000000000000000;;	  name: barfoo
0000000000000000000000000000000000000000;;	users:
0000000000000000000000000000000000000000;;	- name: a name
0000000000000000000000000000000000000000;;	  user:
0000000000000000000000000000000000000000;;	    client-certificate: {{ .Cert }}
0000000000000000000000000000000000000000;;	    client-key: {{ .Key }}
0000000000000000000000000000000000000000;;	contexts:
0000000000000000000000000000000000000000;;	- name: default
0000000000000000000000000000000000000000;;	  context:
0000000000000000000000000000000000000000;;	    cluster: foobar
0000000000000000000000000000000000000000;;	    user: a name
0000000000000000000000000000000000000000;;	current-context: default
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			err := func() error {
0000000000000000000000000000000000000000;;				tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p := tempfile.Name()
0000000000000000000000000000000000000000;;				defer os.Remove(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tmpl, err := template.New("test").Parse(tt.configTmpl)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to parse test template: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := tmpl.Execute(tempfile, data); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to execute test template: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Create a new authorizer
0000000000000000000000000000000000000000;;				sarClient, err := subjectAccessReviewInterfaceFromKubeconfig(p)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error building sar client: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = newWithBackoff(sarClient, 0, 0, 0)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			if err != nil && !tt.wantErr {
0000000000000000000000000000000000000000;;				t.Errorf("failed to load plugin from config %q: %v", tt.msg, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && tt.wantErr {
0000000000000000000000000000000000000000;;				t.Errorf("wanted an error when loading config, did not get one: %q", tt.msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service mocks a remote service.
0000000000000000000000000000000000000000;;	type Service interface {
0000000000000000000000000000000000000000;;		Review(*v1beta1.SubjectAccessReview)
0000000000000000000000000000000000000000;;		HTTPStatusCode() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTestServer wraps a Service as an httptest.Server.
0000000000000000000000000000000000000000;;	func NewTestServer(s Service, cert, key, caCert []byte) (*httptest.Server, error) {
0000000000000000000000000000000000000000;;		const webhookPath = "/testserver"
0000000000000000000000000000000000000000;;		var tlsConfig *tls.Config
0000000000000000000000000000000000000000;;		if cert != nil {
0000000000000000000000000000000000000000;;			cert, err := tls.X509KeyPair(cert, key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig = &tls.Config{Certificates: []tls.Certificate{cert}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if caCert != nil {
0000000000000000000000000000000000000000;;			rootCAs := x509.NewCertPool()
0000000000000000000000000000000000000000;;			rootCAs.AppendCertsFromPEM(caCert)
0000000000000000000000000000000000000000;;			if tlsConfig == nil {
0000000000000000000000000000000000000000;;				tlsConfig = &tls.Config{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.ClientCAs = rootCAs
0000000000000000000000000000000000000000;;			tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serveHTTP := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			if r.Method != "POST" {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("unexpected method: %v", r.Method), http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.URL.Path != webhookPath {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("unexpected path: %v", r.URL.Path), http.StatusNotFound)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var review v1beta1.SubjectAccessReview
0000000000000000000000000000000000000000;;			bodyData, _ := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(bodyData, &review); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("failed to decode body: %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ensure we received the serialized review as expected
0000000000000000000000000000000000000000;;			if review.APIVersion != "authorization.k8s.io/v1beta1" {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("wrong api version: %s", string(bodyData)), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// once we have a successful request, always call the review to record that we were called
0000000000000000000000000000000000000000;;			s.Review(&review)
0000000000000000000000000000000000000000;;			if s.HTTPStatusCode() < 200 || s.HTTPStatusCode() >= 300 {
0000000000000000000000000000000000000000;;				http.Error(w, "HTTP Error", s.HTTPStatusCode())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			type status struct {
0000000000000000000000000000000000000000;;				Allowed         bool   `json:"allowed"`
0000000000000000000000000000000000000000;;				Reason          string `json:"reason"`
0000000000000000000000000000000000000000;;				EvaluationError string `json:"evaluationError"`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp := struct {
0000000000000000000000000000000000000000;;				APIVersion string `json:"apiVersion"`
0000000000000000000000000000000000000000;;				Status     status `json:"status"`
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				APIVersion: v1beta1.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;				Status:     status{review.Status.Allowed, review.Status.Reason, review.Status.EvaluationError},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewUnstartedServer(http.HandlerFunc(serveHTTP))
0000000000000000000000000000000000000000;;		server.TLS = tlsConfig
0000000000000000000000000000000000000000;;		server.StartTLS()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adjust the path to point to our custom path
0000000000000000000000000000000000000000;;		serverURL, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		serverURL.Path = webhookPath
0000000000000000000000000000000000000000;;		server.URL = serverURL.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A service that can be set to allow all or deny all authorization requests.
0000000000000000000000000000000000000000;;	type mockService struct {
0000000000000000000000000000000000000000;;		allow      bool
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;		called     int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mockService) Review(r *v1beta1.SubjectAccessReview) {
0000000000000000000000000000000000000000;;		m.called++
0000000000000000000000000000000000000000;;		r.Status.Allowed = m.allow
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (m *mockService) Allow()              { m.allow = true }
0000000000000000000000000000000000000000;;	func (m *mockService) Deny()               { m.allow = false }
0000000000000000000000000000000000000000;;	func (m *mockService) HTTPStatusCode() int { return m.statusCode }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAuthorizer creates a temporary kubeconfig file from the provided arguments and attempts to load
0000000000000000000000000000000000000000;;	// a new WebhookAuthorizer from it.
0000000000000000000000000000000000000000;;	func newAuthorizer(callbackURL string, clientCert, clientKey, ca []byte, cacheTime time.Duration) (*WebhookAuthorizer, error) {
0000000000000000000000000000000000000000;;		tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := tempfile.Name()
0000000000000000000000000000000000000000;;		defer os.Remove(p)
0000000000000000000000000000000000000000;;		config := v1.Config{
0000000000000000000000000000000000000000;;			Clusters: []v1.NamedCluster{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{Server: callbackURL, CertificateAuthorityData: ca},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			AuthInfos: []v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{ClientCertificateData: clientCert, ClientKeyData: clientKey},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.NewEncoder(tempfile).Encode(config); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sarClient, err := subjectAccessReviewInterfaceFromKubeconfig(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error building sar client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newWithBackoff(sarClient, cacheTime, cacheTime, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTLSConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test                            string
0000000000000000000000000000000000000000;;			clientCert, clientKey, clientCA []byte
0000000000000000000000000000000000000000;;			serverCert, serverKey, serverCA []byte
0000000000000000000000000000000000000000;;			wantAuth, wantErr               bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "TLS setup between client and server",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: caCert,
0000000000000000000000000000000000000000;;				wantAuth: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not require client auth",
0000000000000000000000000000000000000000;;				clientCA:   caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				wantAuth: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not require client auth, client provides it",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				wantAuth: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Client does not trust server",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not trust client",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: badCACert,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Plugin does not support insecure configurations.
0000000000000000000000000000000000000000;;				test:    "Server is using insecure connection",
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				service := new(mockService)
0000000000000000000000000000000000000000;;				service.statusCode = 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server, err := NewTestServer(service, tt.serverCert, tt.serverKey, tt.serverCA)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create server: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wh, err := newAuthorizer(server.URL, tt.clientCert, tt.clientKey, tt.clientCA, 0)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create client: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				attr := authorizer.AttributesRecord{User: &user.DefaultInfo{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Allow all and see if we get an error.
0000000000000000000000000000000000000000;;				service.Allow()
0000000000000000000000000000000000000000;;				authorized, _, err := wh.Authorize(attr)
0000000000000000000000000000000000000000;;				if tt.wantAuth {
0000000000000000000000000000000000000000;;					if !authorized {
0000000000000000000000000000000000000000;;						t.Errorf("expected successful authorization")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if authorized {
0000000000000000000000000000000000000000;;						t.Errorf("expected failed authorization")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tt.wantErr {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected error making authorization request: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to authorize with AllowAll policy: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				service.Deny()
0000000000000000000000000000000000000000;;				if authorized, _, _ := wh.Authorize(attr); authorized {
0000000000000000000000000000000000000000;;					t.Errorf("%s: incorrectly authorized with DenyAll policy", tt.test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recorderService records all access review requests.
0000000000000000000000000000000000000000;;	type recorderService struct {
0000000000000000000000000000000000000000;;		last v1beta1.SubjectAccessReview
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rec *recorderService) Review(r *v1beta1.SubjectAccessReview) {
0000000000000000000000000000000000000000;;		rec.last = v1beta1.SubjectAccessReview{}
0000000000000000000000000000000000000000;;		rec.last = *r
0000000000000000000000000000000000000000;;		r.Status.Allowed = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rec *recorderService) Last() (v1beta1.SubjectAccessReview, error) {
0000000000000000000000000000000000000000;;		return rec.last, rec.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rec *recorderService) HTTPStatusCode() int { return 200 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWebhook(t *testing.T) {
0000000000000000000000000000000000000000;;		serv := new(recorderService)
0000000000000000000000000000000000000000;;		s, err := NewTestServer(serv, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wh, err := newAuthorizer(s.URL, clientCert, clientKey, caCert, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expTypeMeta := metav1.TypeMeta{
0000000000000000000000000000000000000000;;			APIVersion: "authorization.k8s.io/v1beta1",
0000000000000000000000000000000000000000;;			Kind:       "SubjectAccessReview",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			attr authorizer.Attributes
0000000000000000000000000000000000000000;;			want v1beta1.SubjectAccessReview
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				attr: authorizer.AttributesRecord{User: &user.DefaultInfo{}},
0000000000000000000000000000000000000000;;				want: v1beta1.SubjectAccessReview{
0000000000000000000000000000000000000000;;					TypeMeta: expTypeMeta,
0000000000000000000000000000000000000000;;					Spec: v1beta1.SubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;						NonResourceAttributes: &v1beta1.NonResourceAttributes{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				attr: authorizer.AttributesRecord{User: &user.DefaultInfo{Name: "jane"}},
0000000000000000000000000000000000000000;;				want: v1beta1.SubjectAccessReview{
0000000000000000000000000000000000000000;;					TypeMeta: expTypeMeta,
0000000000000000000000000000000000000000;;					Spec: v1beta1.SubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;						User: "jane",
0000000000000000000000000000000000000000;;						NonResourceAttributes: &v1beta1.NonResourceAttributes{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				attr: authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;					User: &user.DefaultInfo{
0000000000000000000000000000000000000000;;						Name:   "jane",
0000000000000000000000000000000000000000;;						UID:    "1",
0000000000000000000000000000000000000000;;						Groups: []string{"group1", "group2"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Verb:            "GET",
0000000000000000000000000000000000000000;;					Namespace:       "kittensandponies",
0000000000000000000000000000000000000000;;					APIGroup:        "group3",
0000000000000000000000000000000000000000;;					APIVersion:      "v7beta3",
0000000000000000000000000000000000000000;;					Resource:        "pods",
0000000000000000000000000000000000000000;;					Subresource:     "proxy",
0000000000000000000000000000000000000000;;					Name:            "my-pod",
0000000000000000000000000000000000000000;;					ResourceRequest: true,
0000000000000000000000000000000000000000;;					Path:            "/foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				want: v1beta1.SubjectAccessReview{
0000000000000000000000000000000000000000;;					TypeMeta: expTypeMeta,
0000000000000000000000000000000000000000;;					Spec: v1beta1.SubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;						User:   "jane",
0000000000000000000000000000000000000000;;						Groups: []string{"group1", "group2"},
0000000000000000000000000000000000000000;;						ResourceAttributes: &v1beta1.ResourceAttributes{
0000000000000000000000000000000000000000;;							Verb:        "GET",
0000000000000000000000000000000000000000;;							Namespace:   "kittensandponies",
0000000000000000000000000000000000000000;;							Group:       "group3",
0000000000000000000000000000000000000000;;							Version:     "v7beta3",
0000000000000000000000000000000000000000;;							Resource:    "pods",
0000000000000000000000000000000000000000;;							Subresource: "proxy",
0000000000000000000000000000000000000000;;							Name:        "my-pod",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			authorized, _, err := wh.Authorize(tt.attr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !authorized {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: authorization failed", i)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gotAttr, err := serv.Last()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: failed to deserialize webhook request: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(gotAttr, tt.want) {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: got != want:\n%s", i, diff.ObjectGoPrintDiff(gotAttr, tt.want))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type webhookCacheTestCase struct {
0000000000000000000000000000000000000000;;		attr authorizer.AttributesRecord
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allow      bool
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedErr        bool
0000000000000000000000000000000000000000;;		expectedAuthorized bool
0000000000000000000000000000000000000000;;		expectedCalls      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testWebhookCacheCases(t *testing.T, serv *mockService, wh *WebhookAuthorizer, tests []webhookCacheTestCase) {
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			serv.called = 0
0000000000000000000000000000000000000000;;			serv.allow = test.allow
0000000000000000000000000000000000000000;;			serv.statusCode = test.statusCode
0000000000000000000000000000000000000000;;			authorized, _, err := wh.Authorize(test.attr)
0000000000000000000000000000000000000000;;			if test.expectedErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Expected error", i)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if !test.expectedErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectedAuthorized != authorized {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected authorized=%v, got %v", i, test.expectedAuthorized, authorized)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectedCalls != serv.called {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %d calls, got %d", i, test.expectedCalls, serv.called)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestWebhookCache verifies that error responses from the server are not
0000000000000000000000000000000000000000;;	// cached, but successful responses are.
0000000000000000000000000000000000000000;;	func TestWebhookCache(t *testing.T) {
0000000000000000000000000000000000000000;;		serv := new(mockService)
0000000000000000000000000000000000000000;;		s, err := NewTestServer(serv, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create an authorizer that caches successful responses "forever" (100 days).
0000000000000000000000000000000000000000;;		wh, err := newAuthorizer(s.URL, clientCert, clientKey, caCert, 2400*time.Hour)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aliceAttr := authorizer.AttributesRecord{User: &user.DefaultInfo{Name: "alice"}}
0000000000000000000000000000000000000000;;		bobAttr := authorizer.AttributesRecord{User: &user.DefaultInfo{Name: "bob"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []webhookCacheTestCase{
0000000000000000000000000000000000000000;;			// server error and 429's retry
0000000000000000000000000000000000000000;;			{attr: aliceAttr, allow: false, statusCode: 500, expectedErr: true, expectedAuthorized: false, expectedCalls: 5},
0000000000000000000000000000000000000000;;			{attr: aliceAttr, allow: false, statusCode: 429, expectedErr: true, expectedAuthorized: false, expectedCalls: 5},
0000000000000000000000000000000000000000;;			// regular errors return errors but do not retry
0000000000000000000000000000000000000000;;			{attr: aliceAttr, allow: false, statusCode: 404, expectedErr: true, expectedAuthorized: false, expectedCalls: 1},
0000000000000000000000000000000000000000;;			{attr: aliceAttr, allow: false, statusCode: 403, expectedErr: true, expectedAuthorized: false, expectedCalls: 1},
0000000000000000000000000000000000000000;;			{attr: aliceAttr, allow: false, statusCode: 401, expectedErr: true, expectedAuthorized: false, expectedCalls: 1},
0000000000000000000000000000000000000000;;			// successful responses are cached
0000000000000000000000000000000000000000;;			{attr: aliceAttr, allow: true, statusCode: 200, expectedErr: false, expectedAuthorized: true, expectedCalls: 1},
0000000000000000000000000000000000000000;;			// later requests within the cache window don't hit the backend
0000000000000000000000000000000000000000;;			{attr: aliceAttr, allow: false, statusCode: 500, expectedErr: false, expectedAuthorized: true, expectedCalls: 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// a request with different attributes doesn't hit the cache
0000000000000000000000000000000000000000;;			{attr: bobAttr, allow: false, statusCode: 500, expectedErr: true, expectedAuthorized: false, expectedCalls: 5},
0000000000000000000000000000000000000000;;			// successful response for other attributes is cached
0000000000000000000000000000000000000000;;			{attr: bobAttr, allow: true, statusCode: 200, expectedErr: false, expectedAuthorized: true, expectedCalls: 1},
0000000000000000000000000000000000000000;;			// later requests within the cache window don't hit the backend
0000000000000000000000000000000000000000;;			{attr: bobAttr, allow: false, statusCode: 500, expectedErr: false, expectedAuthorized: true, expectedCalls: 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testWebhookCacheCases(t, serv, wh, tests)
0000000000000000000000000000000000000000;;	}
