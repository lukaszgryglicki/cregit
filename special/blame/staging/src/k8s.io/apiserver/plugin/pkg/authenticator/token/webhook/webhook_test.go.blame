0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
cfdd6d58641bf8042b29b9853e521513e4dd2e23;plugin/pkg/auth/authenticator/token/webhook/webhook_test.go[plugin/pkg/auth/authenticator/token/webhook/webhook_test.go][staging/src/k8s.io/apiserver/plugin/pkg/authenticator/token/webhook/webhook_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/authentication/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd/api/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service mocks a remote authentication service.
0000000000000000000000000000000000000000;;	type Service interface {
0000000000000000000000000000000000000000;;		// Review looks at the TokenReviewSpec and provides an authentication
0000000000000000000000000000000000000000;;		// response in the TokenReviewStatus.
0000000000000000000000000000000000000000;;		Review(*v1beta1.TokenReview)
0000000000000000000000000000000000000000;;		HTTPStatusCode() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTestServer wraps a Service as an httptest.Server.
0000000000000000000000000000000000000000;;	func NewTestServer(s Service, cert, key, caCert []byte) (*httptest.Server, error) {
0000000000000000000000000000000000000000;;		const webhookPath = "/testserver"
0000000000000000000000000000000000000000;;		var tlsConfig *tls.Config
0000000000000000000000000000000000000000;;		if cert != nil {
0000000000000000000000000000000000000000;;			cert, err := tls.X509KeyPair(cert, key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig = &tls.Config{Certificates: []tls.Certificate{cert}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if caCert != nil {
0000000000000000000000000000000000000000;;			rootCAs := x509.NewCertPool()
0000000000000000000000000000000000000000;;			rootCAs.AppendCertsFromPEM(caCert)
0000000000000000000000000000000000000000;;			if tlsConfig == nil {
0000000000000000000000000000000000000000;;				tlsConfig = &tls.Config{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.ClientCAs = rootCAs
0000000000000000000000000000000000000000;;			tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serveHTTP := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			if r.Method != "POST" {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("unexpected method: %v", r.Method), http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.URL.Path != webhookPath {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("unexpected path: %v", r.URL.Path), http.StatusNotFound)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var review v1beta1.TokenReview
0000000000000000000000000000000000000000;;			bodyData, _ := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(bodyData, &review); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("failed to decode body: %v", err), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ensure we received the serialized tokenreview as expected
0000000000000000000000000000000000000000;;			if review.APIVersion != "authentication.k8s.io/v1beta1" {
0000000000000000000000000000000000000000;;				http.Error(w, fmt.Sprintf("wrong api version: %s", string(bodyData)), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// once we have a successful request, always call the review to record that we were called
0000000000000000000000000000000000000000;;			s.Review(&review)
0000000000000000000000000000000000000000;;			if s.HTTPStatusCode() < 200 || s.HTTPStatusCode() >= 300 {
0000000000000000000000000000000000000000;;				http.Error(w, "HTTP Error", s.HTTPStatusCode())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			type userInfo struct {
0000000000000000000000000000000000000000;;				Username string              `json:"username"`
0000000000000000000000000000000000000000;;				UID      string              `json:"uid"`
0000000000000000000000000000000000000000;;				Groups   []string            `json:"groups"`
0000000000000000000000000000000000000000;;				Extra    map[string][]string `json:"extra"`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			type status struct {
0000000000000000000000000000000000000000;;				Authenticated bool     `json:"authenticated"`
0000000000000000000000000000000000000000;;				User          userInfo `json:"user"`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var extra map[string][]string
0000000000000000000000000000000000000000;;			if review.Status.User.Extra != nil {
0000000000000000000000000000000000000000;;				extra = map[string][]string{}
0000000000000000000000000000000000000000;;				for k, v := range review.Status.User.Extra {
0000000000000000000000000000000000000000;;					extra[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp := struct {
0000000000000000000000000000000000000000;;				Kind       string `json:"kind"`
0000000000000000000000000000000000000000;;				APIVersion string `json:"apiVersion"`
0000000000000000000000000000000000000000;;				Status     status `json:"status"`
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				Kind:       "TokenReview",
0000000000000000000000000000000000000000;;				APIVersion: v1beta1.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;				Status: status{
0000000000000000000000000000000000000000;;					review.Status.Authenticated,
0000000000000000000000000000000000000000;;					userInfo{
0000000000000000000000000000000000000000;;						Username: review.Status.User.Username,
0000000000000000000000000000000000000000;;						UID:      review.Status.User.UID,
0000000000000000000000000000000000000000;;						Groups:   review.Status.User.Groups,
0000000000000000000000000000000000000000;;						Extra:    extra,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			json.NewEncoder(w).Encode(resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewUnstartedServer(http.HandlerFunc(serveHTTP))
0000000000000000000000000000000000000000;;		server.TLS = tlsConfig
0000000000000000000000000000000000000000;;		server.StartTLS()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adjust the path to point to our custom path
0000000000000000000000000000000000000000;;		serverURL, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		serverURL.Path = webhookPath
0000000000000000000000000000000000000000;;		server.URL = serverURL.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A service that can be set to say yes or no to authentication requests.
0000000000000000000000000000000000000000;;	type mockService struct {
0000000000000000000000000000000000000000;;		allow      bool
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;		called     int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mockService) Review(r *v1beta1.TokenReview) {
0000000000000000000000000000000000000000;;		m.called++
0000000000000000000000000000000000000000;;		r.Status.Authenticated = m.allow
0000000000000000000000000000000000000000;;		if m.allow {
0000000000000000000000000000000000000000;;			r.Status.User.Username = "realHooman@email.com"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (m *mockService) Allow()              { m.allow = true }
0000000000000000000000000000000000000000;;	func (m *mockService) Deny()               { m.allow = false }
0000000000000000000000000000000000000000;;	func (m *mockService) HTTPStatusCode() int { return m.statusCode }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTokenAuthenticator creates a temporary kubeconfig file from the provided
0000000000000000000000000000000000000000;;	// arguments and attempts to load a new WebhookTokenAuthenticator from it.
0000000000000000000000000000000000000000;;	func newTokenAuthenticator(serverURL string, clientCert, clientKey, ca []byte, cacheTime time.Duration) (*WebhookTokenAuthenticator, error) {
0000000000000000000000000000000000000000;;		tempfile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := tempfile.Name()
0000000000000000000000000000000000000000;;		defer os.Remove(p)
0000000000000000000000000000000000000000;;		config := v1.Config{
0000000000000000000000000000000000000000;;			Clusters: []v1.NamedCluster{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{Server: serverURL, CertificateAuthorityData: ca},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			AuthInfos: []v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{ClientCertificateData: clientCert, ClientKeyData: clientKey},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.NewEncoder(tempfile).Encode(config); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := tokenReviewInterfaceFromKubeconfig(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newWithBackoff(c, cacheTime, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTLSConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test                            string
0000000000000000000000000000000000000000;;			clientCert, clientKey, clientCA []byte
0000000000000000000000000000000000000000;;			serverCert, serverKey, serverCA []byte
0000000000000000000000000000000000000000;;			wantErr                         bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "TLS setup between client and server",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: caCert,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not require client auth",
0000000000000000000000000000000000000000;;				clientCA:   caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not require client auth, client provides it",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Client does not trust server",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "Server does not trust client",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: badCACert,
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Plugin does not support insecure configurations.
0000000000000000000000000000000000000000;;				test:    "Server is using insecure connection",
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				service := new(mockService)
0000000000000000000000000000000000000000;;				service.statusCode = 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				server, err := NewTestServer(service, tt.serverCert, tt.serverKey, tt.serverCA)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create server: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wh, err := newTokenAuthenticator(server.URL, tt.clientCert, tt.clientKey, tt.clientCA, 0)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create client: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Allow all and see if we get an error.
0000000000000000000000000000000000000000;;				service.Allow()
0000000000000000000000000000000000000000;;				_, authenticated, err := wh.AuthenticateToken("t0k3n")
0000000000000000000000000000000000000000;;				if tt.wantErr {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("expected error making authorization request: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !authenticated {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to authenticate token", tt.test)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				service.Deny()
0000000000000000000000000000000000000000;;				_, authenticated, err = wh.AuthenticateToken("t0k3n")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpectedly failed AuthenticateToken", tt.test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if authenticated {
0000000000000000000000000000000000000000;;					t.Errorf("%s: incorrectly authenticated token", tt.test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recorderService records all token review requests, and responds with the
0000000000000000000000000000000000000000;;	// provided TokenReviewStatus.
0000000000000000000000000000000000000000;;	type recorderService struct {
0000000000000000000000000000000000000000;;		lastRequest v1beta1.TokenReview
0000000000000000000000000000000000000000;;		response    v1beta1.TokenReviewStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rec *recorderService) Review(r *v1beta1.TokenReview) {
0000000000000000000000000000000000000000;;		rec.lastRequest = *r
0000000000000000000000000000000000000000;;		r.Status = rec.response
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rec *recorderService) HTTPStatusCode() int { return 200 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWebhookTokenAuthenticator(t *testing.T) {
0000000000000000000000000000000000000000;;		serv := &recorderService{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := NewTestServer(serv, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wh, err := newTokenAuthenticator(s.URL, clientCert, clientKey, caCert, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expTypeMeta := metav1.TypeMeta{
0000000000000000000000000000000000000000;;			APIVersion: "authentication.k8s.io/v1beta1",
0000000000000000000000000000000000000000;;			Kind:       "TokenReview",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			serverResponse        v1beta1.TokenReviewStatus
0000000000000000000000000000000000000000;;			expectedAuthenticated bool
0000000000000000000000000000000000000000;;			expectedUser          *user.DefaultInfo
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Successful response should pass through all user info.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverResponse: v1beta1.TokenReviewStatus{
0000000000000000000000000000000000000000;;					Authenticated: true,
0000000000000000000000000000000000000000;;					User: v1beta1.UserInfo{
0000000000000000000000000000000000000000;;						Username: "somebody",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedAuthenticated: true,
0000000000000000000000000000000000000000;;				expectedUser: &user.DefaultInfo{
0000000000000000000000000000000000000000;;					Name: "somebody",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverResponse: v1beta1.TokenReviewStatus{
0000000000000000000000000000000000000000;;					Authenticated: true,
0000000000000000000000000000000000000000;;					User: v1beta1.UserInfo{
0000000000000000000000000000000000000000;;						Username: "person@place.com",
0000000000000000000000000000000000000000;;						UID:      "abcd-1234",
0000000000000000000000000000000000000000;;						Groups:   []string{"stuff-dev", "main-eng"},
0000000000000000000000000000000000000000;;						Extra:    map[string]v1beta1.ExtraValue{"foo": {"bar", "baz"}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedAuthenticated: true,
0000000000000000000000000000000000000000;;				expectedUser: &user.DefaultInfo{
0000000000000000000000000000000000000000;;					Name:   "person@place.com",
0000000000000000000000000000000000000000;;					UID:    "abcd-1234",
0000000000000000000000000000000000000000;;					Groups: []string{"stuff-dev", "main-eng"},
0000000000000000000000000000000000000000;;					Extra:  map[string][]string{"foo": {"bar", "baz"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Unauthenticated shouldn't even include extra provided info.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverResponse: v1beta1.TokenReviewStatus{
0000000000000000000000000000000000000000;;					Authenticated: false,
0000000000000000000000000000000000000000;;					User: v1beta1.UserInfo{
0000000000000000000000000000000000000000;;						Username: "garbage",
0000000000000000000000000000000000000000;;						UID:      "abcd-1234",
0000000000000000000000000000000000000000;;						Groups:   []string{"not-actually-used"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedAuthenticated: false,
0000000000000000000000000000000000000000;;				expectedUser:          nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serverResponse: v1beta1.TokenReviewStatus{
0000000000000000000000000000000000000000;;					Authenticated: false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedAuthenticated: false,
0000000000000000000000000000000000000000;;				expectedUser:          nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token := "my-s3cr3t-t0ken"
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			serv.response = tt.serverResponse
0000000000000000000000000000000000000000;;			user, authenticated, err := wh.AuthenticateToken(token)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: authentication failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if serv.lastRequest.Spec.Token != token {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: Server did not see correct token. Got %q, expected %q.",
0000000000000000000000000000000000000000;;					i, serv.lastRequest.Spec.Token, token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(serv.lastRequest.TypeMeta, expTypeMeta) {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: Server did not see correct TypeMeta. Got %v, expected %v",
0000000000000000000000000000000000000000;;					i, serv.lastRequest.TypeMeta, expTypeMeta)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if authenticated != tt.expectedAuthenticated {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: Plugin returned incorrect authentication response. Got %t, expected %t.",
0000000000000000000000000000000000000000;;					i, authenticated, tt.expectedAuthenticated)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if user != nil && tt.expectedUser != nil && !reflect.DeepEqual(user, tt.expectedUser) {
0000000000000000000000000000000000000000;;				t.Errorf("case %d: Plugin returned incorrect user. Got %#v, expected %#v",
0000000000000000000000000000000000000000;;					i, user, tt.expectedUser)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authenticationUserInfo v1beta1.UserInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *authenticationUserInfo) GetName() string     { return a.Username }
0000000000000000000000000000000000000000;;	func (a *authenticationUserInfo) GetUID() string      { return a.UID }
0000000000000000000000000000000000000000;;	func (a *authenticationUserInfo) GetGroups() []string { return a.Groups }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *authenticationUserInfo) GetExtra() map[string][]string {
0000000000000000000000000000000000000000;;		if a.Extra == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := map[string][]string{}
0000000000000000000000000000000000000000;;		for k, v := range a.Extra {
0000000000000000000000000000000000000000;;			ret[k] = []string(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure v1beta1.UserInfo contains the fields necessary to implement the
0000000000000000000000000000000000000000;;	// user.Info interface.
0000000000000000000000000000000000000000;;	var _ user.Info = (*authenticationUserInfo)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestWebhookCache verifies that error responses from the server are not
0000000000000000000000000000000000000000;;	// cached, but successful responses are. It also ensures that the webhook
0000000000000000000000000000000000000000;;	// call is retried on 429 and 500+ errors
0000000000000000000000000000000000000000;;	func TestWebhookCacheAndRetry(t *testing.T) {
0000000000000000000000000000000000000000;;		serv := new(mockService)
0000000000000000000000000000000000000000;;		s, err := NewTestServer(serv, serverCert, serverKey, caCert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create an authenticator that caches successful responses "forever" (100 days).
0000000000000000000000000000000000000000;;		wh, err := newTokenAuthenticator(s.URL, clientCert, clientKey, caCert, 2400*time.Hour)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			description string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			token string
0000000000000000000000000000000000000000;;			allow bool
0000000000000000000000000000000000000000;;			code  int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;			expectOk    bool
0000000000000000000000000000000000000000;;			expectCalls int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "t0k3n, 500 error, retries and fails",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "t0k3n",
0000000000000000000000000000000000000000;;				allow: false,
0000000000000000000000000000000000000000;;				code:  500,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				expectOk:    false,
0000000000000000000000000000000000000000;;				expectCalls: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "t0k3n, 404 error, fails (but no retry)",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "t0k3n",
0000000000000000000000000000000000000000;;				allow: false,
0000000000000000000000000000000000000000;;				code:  404,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				expectOk:    false,
0000000000000000000000000000000000000000;;				expectCalls: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "t0k3n, 200 response, allowed, succeeds with a single call",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "t0k3n",
0000000000000000000000000000000000000000;;				allow: true,
0000000000000000000000000000000000000000;;				code:  200,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;				expectOk:    true,
0000000000000000000000000000000000000000;;				expectCalls: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "t0k3n, 500 response, disallowed, but never called because previous 200 response was cached",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "t0k3n",
0000000000000000000000000000000000000000;;				allow: false,
0000000000000000000000000000000000000000;;				code:  500,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;				expectOk:    true,
0000000000000000000000000000000000000000;;				expectCalls: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "an0th3r_t0k3n, 500 response, disallowed, should be called again with retries",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "an0th3r_t0k3n",
0000000000000000000000000000000000000000;;				allow: false,
0000000000000000000000000000000000000000;;				code:  500,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				expectOk:    false,
0000000000000000000000000000000000000000;;				expectCalls: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "an0th3r_t0k3n, 429 response, disallowed, should be called again with retries",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "an0th3r_t0k3n",
0000000000000000000000000000000000000000;;				allow: false,
0000000000000000000000000000000000000000;;				code:  429,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;				expectOk:    false,
0000000000000000000000000000000000000000;;				expectCalls: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "an0th3r_t0k3n, 200 response, allowed, succeeds with a single call",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "an0th3r_t0k3n",
0000000000000000000000000000000000000000;;				allow: true,
0000000000000000000000000000000000000000;;				code:  200,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;				expectOk:    true,
0000000000000000000000000000000000000000;;				expectCalls: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "an0th3r_t0k3n, 500 response, disallowed, but never called because previous 200 response was cached",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token: "an0th3r_t0k3n",
0000000000000000000000000000000000000000;;				allow: false,
0000000000000000000000000000000000000000;;				code:  500,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;				expectOk:    true,
0000000000000000000000000000000000000000;;				expectCalls: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testcase := range testcases {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				serv.allow = testcase.allow
0000000000000000000000000000000000000000;;				serv.statusCode = testcase.code
0000000000000000000000000000000000000000;;				serv.called = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, ok, err := wh.AuthenticateToken(testcase.token)
0000000000000000000000000000000000000000;;				hasError := err != nil
0000000000000000000000000000000000000000;;				if hasError != testcase.expectError {
0000000000000000000000000000000000000000;;					t.Log(testcase.description)
0000000000000000000000000000000000000000;;					t.Errorf("Webhook returned HTTP %d, expected error=%v, but got error %v", testcase.code, testcase.expectError, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if serv.called != testcase.expectCalls {
0000000000000000000000000000000000000000;;					t.Log(testcase.description)
0000000000000000000000000000000000000000;;					t.Errorf("Expected %d calls, got %d", testcase.expectCalls, serv.called)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ok != testcase.expectOk {
0000000000000000000000000000000000000000;;					t.Log(testcase.description)
0000000000000000000000000000000000000000;;					t.Errorf("Expected ok=%v, got %v", testcase.expectOk, ok)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
