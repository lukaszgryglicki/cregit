0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8d85cab1a495402b5f42f965766052c33c79a1d4;plugin/pkg/auth/authenticator/token/oidc/oidc.go[plugin/pkg/auth/authenticator/token/oidc/oidc.go][staging/src/k8s.io/apiserver/plugin/pkg/authenticator/token/oidc/oidc.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	oidc implements the authenticator.Token interface using the OpenID Connect protocol.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := oidc.OIDCOptions{
0000000000000000000000000000000000000000;;			IssuerURL:     "https://accounts.google.com",
0000000000000000000000000000000000000000;;			ClientID:      os.Getenv("GOOGLE_CLIENT_ID"),
0000000000000000000000000000000000000000;;			UsernameClaim: "email",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tokenAuthenticator, err := oidc.New(config)
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package oidc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/jose"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/oidc"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCOptions struct {
0000000000000000000000000000000000000000;;		// IssuerURL is the URL the provider signs ID Tokens as. This will be the "iss"
0000000000000000000000000000000000000000;;		// field of all tokens produced by the provider and is used for configuration
0000000000000000000000000000000000000000;;		// discovery.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The URL is usually the provider's URL without a path, for example
0000000000000000000000000000000000000000;;		// "https://accounts.google.com" or "https://login.salesforce.com".
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The provider must implement configuration discovery.
0000000000000000000000000000000000000000;;		// See: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig
0000000000000000000000000000000000000000;;		IssuerURL string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClientID the JWT must be issued for, the "sub" field. This plugin only trusts a single
0000000000000000000000000000000000000000;;		// client to ensure the plugin can be used with public providers.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The plugin supports the "authorized party" OpenID Connect claim, which allows
0000000000000000000000000000000000000000;;		// specialized providers to issue tokens to a client for a different client.
0000000000000000000000000000000000000000;;		// See: https://openid.net/specs/openid-connect-core-1_0.html#IDToken
0000000000000000000000000000000000000000;;		ClientID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path to a PEM encoded root certificate of the provider.
0000000000000000000000000000000000000000;;		CAFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UsernameClaim is the JWT field to use as the user's username.
0000000000000000000000000000000000000000;;		UsernameClaim string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GroupsClaim, if specified, causes the OIDCAuthenticator to try to populate the user's
0000000000000000000000000000000000000000;;		// groups with an ID Token field. If the GrouppClaim field is present in an ID Token the value
0000000000000000000000000000000000000000;;		// must be a string or list of strings.
0000000000000000000000000000000000000000;;		GroupsClaim string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCAuthenticator struct {
0000000000000000000000000000000000000000;;		issuerURL string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trustedClientID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usernameClaim string
0000000000000000000000000000000000000000;;		groupsClaim   string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		httpClient *http.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Contains an *oidc.Client. Do not access directly. Use client() method.
0000000000000000000000000000000000000000;;		oidcClient atomic.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Guards the close method and is used to lock during initialization and closing.
0000000000000000000000000000000000000000;;		mu    sync.Mutex
0000000000000000000000000000000000000000;;		close func() // May be nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a token authenticator which validates OpenID Connect ID Tokens.
0000000000000000000000000000000000000000;;	func New(opts OIDCOptions) (*OIDCAuthenticator, error) {
0000000000000000000000000000000000000000;;		url, err := url.Parse(opts.IssuerURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if url.Scheme != "https" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("'oidc-issuer-url' (%q) has invalid scheme (%q), require 'https'", opts.IssuerURL, url.Scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.UsernameClaim == "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("no username claim provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var roots *x509.CertPool
0000000000000000000000000000000000000000;;		if opts.CAFile != "" {
0000000000000000000000000000000000000000;;			roots, err = certutil.NewPool(opts.CAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to read the CA file: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Info("OIDC: No x509 certificates provided, will use host's root CA set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copied from http.DefaultTransport.
0000000000000000000000000000000000000000;;		tr := net.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			// According to golang's doc, if RootCAs is nil,
0000000000000000000000000000000000000000;;			// TLS uses the host's root CA set.
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{RootCAs: roots},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticator := &OIDCAuthenticator{
0000000000000000000000000000000000000000;;			issuerURL:       opts.IssuerURL,
0000000000000000000000000000000000000000;;			trustedClientID: opts.ClientID,
0000000000000000000000000000000000000000;;			usernameClaim:   opts.UsernameClaim,
0000000000000000000000000000000000000000;;			groupsClaim:     opts.GroupsClaim,
0000000000000000000000000000000000000000;;			httpClient:      &http.Client{Transport: tr},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attempt to initialize the authenticator asynchronously.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Ignore errors instead of returning it since the OpenID Connect provider might not be
0000000000000000000000000000000000000000;;		// available yet, for instance if it's running on the cluster and needs the API server
0000000000000000000000000000000000000000;;		// to come up first. Errors will be logged within the client() method.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			authenticator.client()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return authenticator, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close stops all goroutines used by the authenticator.
0000000000000000000000000000000000000000;;	func (a *OIDCAuthenticator) Close() {
0000000000000000000000000000000000000000;;		a.mu.Lock()
0000000000000000000000000000000000000000;;		defer a.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.close != nil {
0000000000000000000000000000000000000000;;			a.close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *OIDCAuthenticator) client() (*oidc.Client, error) {
0000000000000000000000000000000000000000;;		// Fast check to see if client has already been initialized.
0000000000000000000000000000000000000000;;		if client := a.oidcClient.Load(); client != nil {
0000000000000000000000000000000000000000;;			return client.(*oidc.Client), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Acquire lock, then recheck initialization.
0000000000000000000000000000000000000000;;		a.mu.Lock()
0000000000000000000000000000000000000000;;		defer a.mu.Unlock()
0000000000000000000000000000000000000000;;		if client := a.oidcClient.Load(); client != nil {
0000000000000000000000000000000000000000;;			return client.(*oidc.Client), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to initialize client.
0000000000000000000000000000000000000000;;		providerConfig, err := oidc.FetchProviderConfig(a.httpClient, a.issuerURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("oidc authenticator: failed to fetch provider discovery data: %v", err)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("fetch provider config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig := oidc.ClientConfig{
0000000000000000000000000000000000000000;;			HTTPClient:     a.httpClient,
0000000000000000000000000000000000000000;;			Credentials:    oidc.ClientCredentials{ID: a.trustedClientID},
0000000000000000000000000000000000000000;;			ProviderConfig: providerConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := oidc.NewClient(clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("oidc authenticator: failed to create client: %v", err)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("create client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SyncProviderConfig will start a goroutine to periodically synchronize the provider config.
0000000000000000000000000000000000000000;;		// The synchronization interval is set by the expiration length of the config, and has a minimum
0000000000000000000000000000000000000000;;		// and maximum threshold.
0000000000000000000000000000000000000000;;		stop := client.SyncProviderConfig(a.issuerURL)
0000000000000000000000000000000000000000;;		a.oidcClient.Store(client)
0000000000000000000000000000000000000000;;		a.close = func() {
0000000000000000000000000000000000000000;;			// This assumes the stop is an unbuffered channel.
0000000000000000000000000000000000000000;;			// So instead of closing the channel, we send am empty struct here.
0000000000000000000000000000000000000000;;			// This guarantees that when this function returns, there is no flying requests,
0000000000000000000000000000000000000000;;			// because a send to an unbuffered channel happens after the receive from the channel.
0000000000000000000000000000000000000000;;			stop <- struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthenticateToken decodes and verifies an ID Token using the OIDC client, if the verification succeeds,
0000000000000000000000000000000000000000;;	// then it will extract the user info from the JWT claims.
0000000000000000000000000000000000000000;;	func (a *OIDCAuthenticator) AuthenticateToken(value string) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		jwt, err := jose.ParseJWT(value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := a.client()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := client.VerifyJWT(jwt); err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claims, err := jwt.Claims()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim, ok, err := claims.StringClaim(a.usernameClaim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("cannot find %q in JWT claims", a.usernameClaim)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var username string
0000000000000000000000000000000000000000;;		switch a.usernameClaim {
0000000000000000000000000000000000000000;;		case "email":
0000000000000000000000000000000000000000;;			verified, ok := claims["email_verified"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("'email_verified' claim not present")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			emailVerified, ok := verified.(bool)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// OpenID Connect spec defines 'email_verified' as a boolean. For now, be a pain and error if
0000000000000000000000000000000000000000;;				// it's a different type. If there are enough misbehaving providers we can relax this latter.
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// See: https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("malformed claim 'email_verified', expected boolean got %T", verified)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !emailVerified {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("email not verified")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			username = claim
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// For all other cases, use issuerURL + claim as the user name.
0000000000000000000000000000000000000000;;			username = fmt.Sprintf("%s#%s", a.issuerURL, claim)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(yifan): Add UID, also populate the issuer to upper layer.
0000000000000000000000000000000000000000;;		info := &user.DefaultInfo{Name: username}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.groupsClaim != "" {
0000000000000000000000000000000000000000;;			groups, found, err := claims.StringsClaim(a.groupsClaim)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Groups type is present but is not an array of strings, try to decode as a string.
0000000000000000000000000000000000000000;;				group, _, err := claims.StringClaim(a.groupsClaim)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Custom claim is present, but isn't an array of strings or a string.
0000000000000000000000000000000000000000;;					return nil, false, fmt.Errorf("custom group claim contains invalid type: %T", claims[a.groupsClaim])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				info.Groups = []string{group}
0000000000000000000000000000000000000000;;			} else if found {
0000000000000000000000000000000000000000;;				info.Groups = groups
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return info, true, nil
0000000000000000000000000000000000000000;;	}
