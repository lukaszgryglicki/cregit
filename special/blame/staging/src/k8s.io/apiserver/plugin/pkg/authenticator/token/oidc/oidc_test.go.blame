0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1707ee13a4202cdff267a3158e531c2a1a2b6957;plugin/pkg/auth/authenticator/token/oidc/oidc_test.go[plugin/pkg/auth/authenticator/token/oidc/oidc_test.go][staging/src/k8s.io/apiserver/plugin/pkg/authenticator/token/oidc/oidc_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package oidc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/jose"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/oidc"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		oidctesting "k8s.io/apiserver/plugin/pkg/authenticator/token/oidc/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateToken(t *testing.T, op *oidctesting.OIDCProvider, iss, sub, aud string, usernameClaim, value, groupsClaim string, groups interface{}, iat, exp time.Time, emailVerified bool) string {
0000000000000000000000000000000000000000;;		claims := oidc.NewClaims(iss, sub, aud, iat, exp)
0000000000000000000000000000000000000000;;		claims.Add(usernameClaim, value)
0000000000000000000000000000000000000000;;		if groups != nil && groupsClaim != "" {
0000000000000000000000000000000000000000;;			claims.Add(groupsClaim, groups)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		claims.Add("email_verified", emailVerified)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signer := op.PrivKey.Signer()
0000000000000000000000000000000000000000;;		jwt, err := jose.NewSignedJWT(claims, signer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Cannot generate token: %v", err)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return jwt.Encode()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateTokenWithUnverifiedEmail(t *testing.T, op *oidctesting.OIDCProvider, iss, sub, aud string, email string) string {
0000000000000000000000000000000000000000;;		return generateToken(t, op, iss, sub, aud, "email", email, "", nil, time.Now(), time.Now().Add(time.Hour), false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateGoodToken(t *testing.T, op *oidctesting.OIDCProvider, iss, sub, aud string, usernameClaim, value, groupsClaim string, groups interface{}) string {
0000000000000000000000000000000000000000;;		return generateToken(t, op, iss, sub, aud, usernameClaim, value, groupsClaim, groups, time.Now(), time.Now().Add(time.Hour), true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateMalformedToken(t *testing.T, op *oidctesting.OIDCProvider, iss, sub, aud string, usernameClaim, value, groupsClaim string, groups interface{}) string {
0000000000000000000000000000000000000000;;		return generateToken(t, op, iss, sub, aud, usernameClaim, value, groupsClaim, groups, time.Now(), time.Now().Add(time.Hour), true) + "randombits"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateExpiredToken(t *testing.T, op *oidctesting.OIDCProvider, iss, sub, aud string, usernameClaim, value, groupsClaim string, groups interface{}) string {
0000000000000000000000000000000000000000;;		return generateToken(t, op, iss, sub, aud, usernameClaim, value, groupsClaim, groups, time.Now().Add(-2*time.Hour), time.Now().Add(-1*time.Hour), true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTLSConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		// Verify the cert/key pair works.
0000000000000000000000000000000000000000;;		cert1 := path.Join(os.TempDir(), "oidc-cert-1")
0000000000000000000000000000000000000000;;		key1 := path.Join(os.TempDir(), "oidc-key-1")
0000000000000000000000000000000000000000;;		cert2 := path.Join(os.TempDir(), "oidc-cert-2")
0000000000000000000000000000000000000000;;		key2 := path.Join(os.TempDir(), "oidc-key-2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer os.Remove(cert1)
0000000000000000000000000000000000000000;;		defer os.Remove(key1)
0000000000000000000000000000000000000000;;		defer os.Remove(cert2)
0000000000000000000000000000000000000000;;		defer os.Remove(key2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oidctesting.GenerateSelfSignedCert(t, "127.0.0.1", cert1, key1)
0000000000000000000000000000000000000000;;		oidctesting.GenerateSelfSignedCert(t, "127.0.0.1", cert2, key2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			testCase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverCertFile string
0000000000000000000000000000000000000000;;			serverKeyFile  string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			trustedCertFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wantErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testCase:       "provider using untrusted custom cert",
0000000000000000000000000000000000000000;;				serverCertFile: cert1,
0000000000000000000000000000000000000000;;				serverKeyFile:  key1,
0000000000000000000000000000000000000000;;				wantErr:        true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testCase:        "provider using untrusted cert",
0000000000000000000000000000000000000000;;				serverCertFile:  cert1,
0000000000000000000000000000000000000000;;				serverKeyFile:   key1,
0000000000000000000000000000000000000000;;				trustedCertFile: cert2,
0000000000000000000000000000000000000000;;				wantErr:         true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				testCase:        "provider using trusted cert",
0000000000000000000000000000000000000000;;				serverCertFile:  cert1,
0000000000000000000000000000000000000000;;				serverKeyFile:   key1,
0000000000000000000000000000000000000000;;				trustedCertFile: cert1,
0000000000000000000000000000000000000000;;				wantErr:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				op := oidctesting.NewOIDCProvider(t, "")
0000000000000000000000000000000000000000;;				srv, err := op.ServeTLSWithKeyPair(tc.serverCertFile, tc.serverKeyFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: %v", tc.testCase, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer srv.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				issuer := srv.URL
0000000000000000000000000000000000000000;;				clientID := "client-foo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				options := OIDCOptions{
0000000000000000000000000000000000000000;;					IssuerURL:     srv.URL,
0000000000000000000000000000000000000000;;					ClientID:      clientID,
0000000000000000000000000000000000000000;;					CAFile:        tc.trustedCertFile,
0000000000000000000000000000000000000000;;					UsernameClaim: "email",
0000000000000000000000000000000000000000;;					GroupsClaim:   "groups",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				authenticator, err := New(options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to initialize authenticator: %v", tc.testCase, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer authenticator.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				email := "user-1@example.com"
0000000000000000000000000000000000000000;;				groups := []string{"group1", "group2"}
0000000000000000000000000000000000000000;;				sort.Strings(groups)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token := generateGoodToken(t, op, issuer, "user-1", clientID, "email", email, "groups", groups)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Because this authenticator behaves differently for subsequent requests, run these
0000000000000000000000000000000000000000;;				// tests multiple times (but expect the same result).
0000000000000000000000000000000000000000;;				for i := 1; i < 4; i++ {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					user, ok, err := authenticator.AuthenticateToken(token)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if !tc.wantErr {
0000000000000000000000000000000000000000;;							t.Errorf("%s (req #%d): failed to authenticate token: %v", tc.testCase, i, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if tc.wantErr {
0000000000000000000000000000000000000000;;						t.Errorf("%s (req #%d): expected error authenticating", tc.testCase, i)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t.Errorf("%s (req #%d): did not get user or error", tc.testCase, i)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if gotUsername := user.GetName(); email != gotUsername {
0000000000000000000000000000000000000000;;						t.Errorf("%s (req #%d): GetName() expected=%q got %q", tc.testCase, i, email, gotUsername)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					gotGroups := user.GetGroups()
0000000000000000000000000000000000000000;;					sort.Strings(gotGroups)
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(gotGroups, groups) {
0000000000000000000000000000000000000000;;						t.Errorf("%s (req #%d): GetGroups() expected=%q got %q", tc.testCase, i, groups, gotGroups)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOIDCAuthentication(t *testing.T) {
0000000000000000000000000000000000000000;;		cert := path.Join(os.TempDir(), "oidc-cert")
0000000000000000000000000000000000000000;;		key := path.Join(os.TempDir(), "oidc-key")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer os.Remove(cert)
0000000000000000000000000000000000000000;;		defer os.Remove(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oidctesting.GenerateSelfSignedCert(t, "127.0.0.1", cert, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure all tests pass when the issuer is not at a base URL.
0000000000000000000000000000000000000000;;		for _, path := range []string{"", "/path/with/trailing/slash/"} {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a TLS server and a client.
0000000000000000000000000000000000000000;;			op := oidctesting.NewOIDCProvider(t, path)
0000000000000000000000000000000000000000;;			srv, err := op.ServeTLSWithKeyPair(cert, key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Cannot start server: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer srv.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tests := []struct {
0000000000000000000000000000000000000000;;				userClaim   string
0000000000000000000000000000000000000000;;				groupsClaim string
0000000000000000000000000000000000000000;;				token       string
0000000000000000000000000000000000000000;;				userInfo    user.Info
0000000000000000000000000000000000000000;;				verified    bool
0000000000000000000000000000000000000000;;				err         string
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					"sub",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, srv.URL, "client-foo", "client-foo", "sub", "user-foo", "", nil),
0000000000000000000000000000000000000000;;					&user.DefaultInfo{Name: fmt.Sprintf("%s#%s", srv.URL, "user-foo")},
0000000000000000000000000000000000000000;;					true,
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Use user defined claim (email here).
0000000000000000000000000000000000000000;;					"email",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, srv.URL, "client-foo", "client-foo", "email", "foo@example.com", "", nil),
0000000000000000000000000000000000000000;;					&user.DefaultInfo{Name: "foo@example.com"},
0000000000000000000000000000000000000000;;					true,
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Use user defined claim (email here).
0000000000000000000000000000000000000000;;					"email",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, srv.URL, "client-foo", "client-foo", "email", "foo@example.com", "groups", []string{"group1", "group2"}),
0000000000000000000000000000000000000000;;					&user.DefaultInfo{Name: "foo@example.com"},
0000000000000000000000000000000000000000;;					true,
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Use user defined claim (email here).
0000000000000000000000000000000000000000;;					"email",
0000000000000000000000000000000000000000;;					"groups",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, srv.URL, "client-foo", "client-foo", "email", "foo@example.com", "groups", []string{"group1", "group2"}),
0000000000000000000000000000000000000000;;					&user.DefaultInfo{Name: "foo@example.com", Groups: []string{"group1", "group2"}},
0000000000000000000000000000000000000000;;					true,
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Group claim is a string rather than an array. Map that string to a single group.
0000000000000000000000000000000000000000;;					"email",
0000000000000000000000000000000000000000;;					"groups",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, srv.URL, "client-foo", "client-foo", "email", "foo@example.com", "groups", "group1"),
0000000000000000000000000000000000000000;;					&user.DefaultInfo{Name: "foo@example.com", Groups: []string{"group1"}},
0000000000000000000000000000000000000000;;					true,
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Group claim is not a string or array of strings. Throw out this as invalid.
0000000000000000000000000000000000000000;;					"email",
0000000000000000000000000000000000000000;;					"groups",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, srv.URL, "client-foo", "client-foo", "email", "foo@example.com", "groups", 1),
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;					false,
0000000000000000000000000000000000000000;;					"custom group claim contains invalid type: float64",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Email not verified
0000000000000000000000000000000000000000;;					"email",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateTokenWithUnverifiedEmail(t, op, srv.URL, "client-foo", "client-foo", "foo@example.com"),
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;					false,
0000000000000000000000000000000000000000;;					"email not verified",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					"sub",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateMalformedToken(t, op, srv.URL, "client-foo", "client-foo", "sub", "user-foo", "", nil),
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;					false,
0000000000000000000000000000000000000000;;					"oidc: unable to verify JWT signature: no matching keys",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Invalid 'aud'.
0000000000000000000000000000000000000000;;					"sub",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, srv.URL, "client-foo", "client-bar", "sub", "user-foo", "", nil),
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;					false,
0000000000000000000000000000000000000000;;					"oidc: JWT claims invalid: invalid claims, 'aud' claim and 'client_id' do not match",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// Invalid issuer.
0000000000000000000000000000000000000000;;					"sub",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateGoodToken(t, op, "http://foo-bar.com", "client-foo", "client-foo", "sub", "user-foo", "", nil),
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;					false,
0000000000000000000000000000000000000000;;					"oidc: JWT claims invalid: invalid claim value: 'iss'.",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					"sub",
0000000000000000000000000000000000000000;;					"",
0000000000000000000000000000000000000000;;					generateExpiredToken(t, op, srv.URL, "client-foo", "client-foo", "sub", "user-foo", "", nil),
0000000000000000000000000000000000000000;;					nil,
0000000000000000000000000000000000000000;;					false,
0000000000000000000000000000000000000000;;					"oidc: JWT claims invalid: token is expired",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, tt := range tests {
0000000000000000000000000000000000000000;;				client, err := New(OIDCOptions{srv.URL, "client-foo", cert, tt.userClaim, tt.groupsClaim})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				user, result, err := client.AuthenticateToken(tt.token)
0000000000000000000000000000000000000000;;				if tt.err != "" {
0000000000000000000000000000000000000000;;					if !strings.HasPrefix(err.Error(), tt.err) {
0000000000000000000000000000000000000000;;						t.Errorf("#%d: Expecting: %v..., but got: %v", i, tt.err, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("#%d: Unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(tt.verified, result) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: Expecting: %v, but got: %v", i, tt.verified, result)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(tt.userInfo, user) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: Expecting: %v, but got: %v", i, tt.userInfo, user)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				client.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
