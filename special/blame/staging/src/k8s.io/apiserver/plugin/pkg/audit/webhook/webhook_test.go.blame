0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
620b8240db3e28807eba9eaf682194ac638c69e8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		stdjson "encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/json"
0000000000000000000000000000000000000000;;		auditinternal "k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;		auditv1alpha1 "k8s.io/apiserver/pkg/apis/audit/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd/api/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newWebhookHandler returns a handler which recieves webhook events and decodes the
0000000000000000000000000000000000000000;;	// request body. The caller passes a callback which is called on each webhook POST.
0000000000000000000000000000000000000000;;	func newWebhookHandler(t *testing.T, cb func(events *auditv1alpha1.EventList)) http.Handler {
0000000000000000000000000000000000000000;;		s := json.NewSerializer(json.DefaultMetaFactory, audit.Scheme, audit.Scheme, false)
0000000000000000000000000000000000000000;;		return &testWebhookHandler{
0000000000000000000000000000000000000000;;			t:          t,
0000000000000000000000000000000000000000;;			onEvents:   cb,
0000000000000000000000000000000000000000;;			serializer: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testWebhookHandler struct {
0000000000000000000000000000000000000000;;		t *testing.T
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		onEvents func(events *auditv1alpha1.EventList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializer runtime.Serializer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *testWebhookHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		err := func() error {
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("read webhook request body: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj, _, err := t.serializer.Decode(body, nil, &auditv1alpha1.EventList{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("decode request body: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list, ok := obj.(*auditv1alpha1.EventList)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("expected *v1alpha1.EventList got %T", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.onEvents(list)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			io.WriteString(w, "{}")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// In a goroutine, can't call Fatal.
0000000000000000000000000000000000000000;;		assert.NoError(t.t, err, "failed to read request body")
0000000000000000000000000000000000000000;;		http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestBlockingWebhook(t *testing.T, endpoint string) *blockingBackend {
0000000000000000000000000000000000000000;;		return newWebhook(t, endpoint, ModeBlocking).(*blockingBackend)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestBatchWebhook(t *testing.T, endpoint string) *batchBackend {
0000000000000000000000000000000000000000;;		return newWebhook(t, endpoint, ModeBatch).(*batchBackend)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWebhook(t *testing.T, endpoint string, mode string) audit.Backend {
0000000000000000000000000000000000000000;;		config := v1.Config{
0000000000000000000000000000000000000000;;			Clusters: []v1.NamedCluster{
0000000000000000000000000000000000000000;;				{Cluster: v1.Cluster{Server: endpoint, InsecureSkipTLSVerify: true}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "k8s_audit_webhook_test_")
0000000000000000000000000000000000000000;;		require.NoError(t, err, "creating temp file")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			f.Close()
0000000000000000000000000000000000000000;;			os.Remove(f.Name())
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE(ericchiang): Do we need to use a proper serializer?
0000000000000000000000000000000000000000;;		require.NoError(t, stdjson.NewEncoder(f).Encode(config), "writing kubeconfig")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend, err := NewBackend(f.Name(), mode)
0000000000000000000000000000000000000000;;		require.NoError(t, err, "initializing backend")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return backend
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWebhook(t *testing.T) {
0000000000000000000000000000000000000000;;		gotEvents := false
0000000000000000000000000000000000000000;;		defer func() { require.True(t, gotEvents, "no events received") }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := httptest.NewServer(newWebhookHandler(t, func(events *auditv1alpha1.EventList) {
0000000000000000000000000000000000000000;;			gotEvents = true
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend := newTestBlockingWebhook(t, s.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure this doesn't return a serialization error.
0000000000000000000000000000000000000000;;		event := &auditinternal.Event{}
0000000000000000000000000000000000000000;;		require.NoError(t, backend.processEvents(event), "failed to send events")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForEmptyBuffer indicates when the sendBatchEvents method has read from the
0000000000000000000000000000000000000000;;	// existing buffer. This lets test coordinate closing a timer and stop channel
0000000000000000000000000000000000000000;;	// until the for loop has read from the buffer.
0000000000000000000000000000000000000000;;	func waitForEmptyBuffer(b *batchBackend) {
0000000000000000000000000000000000000000;;		for len(b.buffer) != 0 {
0000000000000000000000000000000000000000;;			time.Sleep(time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBatchWebhookMaxEvents(t *testing.T) {
0000000000000000000000000000000000000000;;		nRest := 10
0000000000000000000000000000000000000000;;		events := make([]*auditinternal.Event, defaultBatchMaxSize+nRest) // greater than max size.
0000000000000000000000000000000000000000;;		for i := range events {
0000000000000000000000000000000000000000;;			events[i] = &auditinternal.Event{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got := make(chan int, 2)
0000000000000000000000000000000000000000;;		s := httptest.NewServer(newWebhookHandler(t, func(events *auditv1alpha1.EventList) {
0000000000000000000000000000000000000000;;			got <- len(events.Items)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend := newTestBatchWebhook(t, s.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend.ProcessEvents(events...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		timer := make(chan time.Time, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend.sendBatchEvents(stopCh, timer)
0000000000000000000000000000000000000000;;		require.Equal(t, defaultBatchMaxSize, <-got, "did not get batch max size")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			waitForEmptyBuffer(backend) // wait for the buffer to empty
0000000000000000000000000000000000000000;;			timer <- time.Now()         // Trigger the wait timeout
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend.sendBatchEvents(stopCh, timer)
0000000000000000000000000000000000000000;;		require.Equal(t, nRest, <-got, "failed to get the rest of the events")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBatchWebhookStopCh(t *testing.T) {
0000000000000000000000000000000000000000;;		events := make([]*auditinternal.Event, 1) // less than max size.
0000000000000000000000000000000000000000;;		for i := range events {
0000000000000000000000000000000000000000;;			events[i] = &auditinternal.Event{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := len(events)
0000000000000000000000000000000000000000;;		got := make(chan int, 2)
0000000000000000000000000000000000000000;;		s := httptest.NewServer(newWebhookHandler(t, func(events *auditv1alpha1.EventList) {
0000000000000000000000000000000000000000;;			got <- len(events.Items)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend := newTestBatchWebhook(t, s.URL)
0000000000000000000000000000000000000000;;		backend.ProcessEvents(events...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		timer := make(chan time.Time)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			waitForEmptyBuffer(backend)
0000000000000000000000000000000000000000;;			close(stopCh) // stop channel has stopped
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		backend.sendBatchEvents(stopCh, timer)
0000000000000000000000000000000000000000;;		require.Equal(t, expected, <-got, "get queued events after timer expires")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBatchWebhookEmptyBuffer(t *testing.T) {
0000000000000000000000000000000000000000;;		events := make([]*auditinternal.Event, 1) // less than max size.
0000000000000000000000000000000000000000;;		for i := range events {
0000000000000000000000000000000000000000;;			events[i] = &auditinternal.Event{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := len(events)
0000000000000000000000000000000000000000;;		got := make(chan int, 2)
0000000000000000000000000000000000000000;;		s := httptest.NewServer(newWebhookHandler(t, func(events *auditv1alpha1.EventList) {
0000000000000000000000000000000000000000;;			got <- len(events.Items)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend := newTestBatchWebhook(t, s.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		timer := make(chan time.Time, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timer <- time.Now() // Timer is done.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Buffer is empty, no events have been queued. This should exit but send no events.
0000000000000000000000000000000000000000;;		backend.sendBatchEvents(stopCh, timer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send additional events after the sendBatchEvents has been called.
0000000000000000000000000000000000000000;;		backend.ProcessEvents(events...)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			waitForEmptyBuffer(backend)
0000000000000000000000000000000000000000;;			timer <- time.Now()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend.sendBatchEvents(stopCh, timer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we didn't get a POST with zero events.
0000000000000000000000000000000000000000;;		require.Equal(t, expected, <-got, "expected one event")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBatchBufferFull(t *testing.T) {
0000000000000000000000000000000000000000;;		events := make([]*auditinternal.Event, defaultBatchBufferSize+1) // More than buffered size
0000000000000000000000000000000000000000;;		for i := range events {
0000000000000000000000000000000000000000;;			events[i] = &auditinternal.Event{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := httptest.NewServer(newWebhookHandler(t, func(events *auditv1alpha1.EventList) {
0000000000000000000000000000000000000000;;			// Do nothing.
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend := newTestBatchWebhook(t, s.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure this doesn't block.
0000000000000000000000000000000000000000;;		backend.ProcessEvents(events...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBatchRun(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Divisable by max batch size so we don't have to wait for a minute for
0000000000000000000000000000000000000000;;		// the test to finish.
0000000000000000000000000000000000000000;;		events := make([]*auditinternal.Event, defaultBatchMaxSize*3)
0000000000000000000000000000000000000000;;		for i := range events {
0000000000000000000000000000000000000000;;			events[i] = &auditinternal.Event{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got := new(int64)
0000000000000000000000000000000000000000;;		want := len(events)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := new(sync.WaitGroup)
0000000000000000000000000000000000000000;;		wg.Add(want)
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;			// When the expected number of events have been received, close the channel.
0000000000000000000000000000000000000000;;			close(done)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := httptest.NewServer(newWebhookHandler(t, func(events *auditv1alpha1.EventList) {
0000000000000000000000000000000000000000;;			atomic.AddInt64(got, int64(len(events.Items)))
0000000000000000000000000000000000000000;;			wg.Add(-len(events.Items))
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend := newTestBatchWebhook(t, s.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test the Run codepath. E.g. that the spawned goroutines behave correctly.
0000000000000000000000000000000000000000;;		backend.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend.ProcessEvents(events...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;			// Received all the events.
0000000000000000000000000000000000000000;;		case <-time.After(2 * time.Minute):
0000000000000000000000000000000000000000;;			t.Errorf("expected %d events got %d", want, atomic.LoadInt64(got))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBatchConcurrentRequests(t *testing.T) {
0000000000000000000000000000000000000000;;		events := make([]*auditinternal.Event, defaultBatchBufferSize) // Don't drop events
0000000000000000000000000000000000000000;;		for i := range events {
0000000000000000000000000000000000000000;;			events[i] = &auditinternal.Event{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := new(sync.WaitGroup)
0000000000000000000000000000000000000000;;		wg.Add(len(events))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := httptest.NewServer(newWebhookHandler(t, func(events *auditv1alpha1.EventList) {
0000000000000000000000000000000000000000;;			wg.Add(-len(events.Items))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Since the webhook makes concurrent requests, blocking on the webhook response
0000000000000000000000000000000000000000;;			// shouldn't block the webhook from sending more events.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Wait for all responses to be received before sending the response.
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend := newTestBatchWebhook(t, s.URL)
0000000000000000000000000000000000000000;;		backend.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backend.ProcessEvents(events...)
0000000000000000000000000000000000000000;;		// Wait for the webhook to receive all events.
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
