0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
cfdd6d58641bf8042b29b9853e521513e4dd2e23;plugin/pkg/auth/authenticator/token/webhook/webhook.go[plugin/pkg/auth/authenticator/token/webhook/webhook.go][staging/src/k8s.io/apiserver/plugin/pkg/authenticator/token/webhook/webhook.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package webhook implements the authenticator.Token interface using HTTP webhooks.
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authentication "k8s.io/api/authentication/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/cache"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/webhook"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		authenticationclient "k8s.io/client-go/kubernetes/typed/authentication/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		groupVersions = []schema.GroupVersion{authentication.SchemeGroupVersion}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const retryBackoff = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure WebhookTokenAuthenticator implements the authenticator.Token interface.
0000000000000000000000000000000000000000;;	var _ authenticator.Token = (*WebhookTokenAuthenticator)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WebhookTokenAuthenticator struct {
0000000000000000000000000000000000000000;;		tokenReview    authenticationclient.TokenReviewInterface
0000000000000000000000000000000000000000;;		responseCache  *cache.LRUExpireCache
0000000000000000000000000000000000000000;;		ttl            time.Duration
0000000000000000000000000000000000000000;;		initialBackoff time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromInterface creates a webhook authenticator using the given tokenReview client
0000000000000000000000000000000000000000;;	func NewFromInterface(tokenReview authenticationclient.TokenReviewInterface, ttl time.Duration) (*WebhookTokenAuthenticator, error) {
0000000000000000000000000000000000000000;;		return newWithBackoff(tokenReview, ttl, retryBackoff)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new WebhookTokenAuthenticator from the provided kubeconfig file.
0000000000000000000000000000000000000000;;	func New(kubeConfigFile string, ttl time.Duration) (*WebhookTokenAuthenticator, error) {
0000000000000000000000000000000000000000;;		tokenReview, err := tokenReviewInterfaceFromKubeconfig(kubeConfigFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newWithBackoff(tokenReview, ttl, retryBackoff)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newWithBackoff allows tests to skip the sleep.
0000000000000000000000000000000000000000;;	func newWithBackoff(tokenReview authenticationclient.TokenReviewInterface, ttl, initialBackoff time.Duration) (*WebhookTokenAuthenticator, error) {
0000000000000000000000000000000000000000;;		return &WebhookTokenAuthenticator{tokenReview, cache.NewLRUExpireCache(1024), ttl, initialBackoff}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthenticateToken implements the authenticator.Token interface.
0000000000000000000000000000000000000000;;	func (w *WebhookTokenAuthenticator) AuthenticateToken(token string) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		r := &authentication.TokenReview{
0000000000000000000000000000000000000000;;			Spec: authentication.TokenReviewSpec{Token: token},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if entry, ok := w.responseCache.Get(r.Spec); ok {
0000000000000000000000000000000000000000;;			r.Status = entry.(authentication.TokenReviewStatus)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				result *authentication.TokenReview
0000000000000000000000000000000000000000;;				err    error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			webhook.WithExponentialBackoff(w.initialBackoff, func() error {
0000000000000000000000000000000000000000;;				result, err = w.tokenReview.Create(r)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Status = result.Status
0000000000000000000000000000000000000000;;			w.responseCache.Add(r.Spec, result.Status, w.ttl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.Status.Authenticated {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var extra map[string][]string
0000000000000000000000000000000000000000;;		if r.Status.User.Extra != nil {
0000000000000000000000000000000000000000;;			extra = map[string][]string{}
0000000000000000000000000000000000000000;;			for k, v := range r.Status.User.Extra {
0000000000000000000000000000000000000000;;				extra[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name:   r.Status.User.Username,
0000000000000000000000000000000000000000;;			UID:    r.Status.User.UID,
0000000000000000000000000000000000000000;;			Groups: r.Status.User.Groups,
0000000000000000000000000000000000000000;;			Extra:  extra,
0000000000000000000000000000000000000000;;		}, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NOTE: client-go doesn't provide a registry. client-go does registers the
0000000000000000000000000000000000000000;;	// authentication/v1beta1. We construct a registry that acknowledges
0000000000000000000000000000000000000000;;	// authentication/v1beta1 as an enabled version to pass a check enforced in
0000000000000000000000000000000000000000;;	// NewGenericWebhook.
0000000000000000000000000000000000000000;;	var registry = registered.NewOrDie("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		registry.RegisterVersions(groupVersions)
0000000000000000000000000000000000000000;;		if err := registry.EnableVersions(groupVersions...); err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to enable version %v", groupVersions))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenReviewInterfaceFromKubeconfig builds a client from the specified kubeconfig file,
0000000000000000000000000000000000000000;;	// and returns a TokenReviewInterface that uses that client. Note that the client submits TokenReview
0000000000000000000000000000000000000000;;	// requests to the exact path specified in the kubeconfig file, so arbitrary non-API servers can be targeted.
0000000000000000000000000000000000000000;;	func tokenReviewInterfaceFromKubeconfig(kubeConfigFile string) (authenticationclient.TokenReviewInterface, error) {
0000000000000000000000000000000000000000;;		gw, err := webhook.NewGenericWebhook(registry, scheme.Codecs, kubeConfigFile, groupVersions, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &tokenReviewClient{gw}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tokenReviewClient struct {
0000000000000000000000000000000000000000;;		w *webhook.GenericWebhook
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *tokenReviewClient) Create(tokenReview *authentication.TokenReview) (*authentication.TokenReview, error) {
0000000000000000000000000000000000000000;;		result := &authentication.TokenReview{}
0000000000000000000000000000000000000000;;		err := t.w.RestClient.Post().Body(tokenReview).Do().Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
