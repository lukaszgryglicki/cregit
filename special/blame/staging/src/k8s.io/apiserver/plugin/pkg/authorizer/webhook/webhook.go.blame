0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
394c380f34ab4af4adf1f6d112d2f1ea3a21a47d;plugin/pkg/auth/authorizer/webhook/webhook.go[plugin/pkg/auth/authorizer/webhook/webhook.go][staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package webhook implements the authorizer.Authorizer interface using HTTP webhooks.
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authorization "k8s.io/api/authorization/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/cache"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/webhook"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		authorizationclient "k8s.io/client-go/kubernetes/typed/authorization/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		groupVersions = []schema.GroupVersion{authorization.SchemeGroupVersion}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const retryBackoff = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure Webhook implements the authorizer.Authorizer interface.
0000000000000000000000000000000000000000;;	var _ authorizer.Authorizer = (*WebhookAuthorizer)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WebhookAuthorizer struct {
0000000000000000000000000000000000000000;;		subjectAccessReview authorizationclient.SubjectAccessReviewInterface
0000000000000000000000000000000000000000;;		responseCache       *cache.LRUExpireCache
0000000000000000000000000000000000000000;;		authorizedTTL       time.Duration
0000000000000000000000000000000000000000;;		unauthorizedTTL     time.Duration
0000000000000000000000000000000000000000;;		initialBackoff      time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromInterface creates a WebhookAuthorizer using the given subjectAccessReview client
0000000000000000000000000000000000000000;;	func NewFromInterface(subjectAccessReview authorizationclient.SubjectAccessReviewInterface, authorizedTTL, unauthorizedTTL time.Duration) (*WebhookAuthorizer, error) {
0000000000000000000000000000000000000000;;		return newWithBackoff(subjectAccessReview, authorizedTTL, unauthorizedTTL, retryBackoff)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new WebhookAuthorizer from the provided kubeconfig file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The config's cluster field is used to refer to the remote service, user refers to the returned authorizer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     # clusters refers to the remote service.
0000000000000000000000000000000000000000;;	//     clusters:
0000000000000000000000000000000000000000;;	//     - name: name-of-remote-authz-service
0000000000000000000000000000000000000000;;	//       cluster:
0000000000000000000000000000000000000000;;	//         certificate-authority: /path/to/ca.pem      # CA for verifying the remote service.
0000000000000000000000000000000000000000;;	//         server: https://authz.example.com/authorize # URL of remote service to query. Must use 'https'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     # users refers to the API server's webhook configuration.
0000000000000000000000000000000000000000;;	//     users:
0000000000000000000000000000000000000000;;	//     - name: name-of-api-server
0000000000000000000000000000000000000000;;	//       user:
0000000000000000000000000000000000000000;;	//         client-certificate: /path/to/cert.pem # cert for the webhook plugin to use
0000000000000000000000000000000000000000;;	//         client-key: /path/to/key.pem          # key matching the cert
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For additional HTTP configuration, refer to the kubeconfig documentation
0000000000000000000000000000000000000000;;	// https://kubernetes.io/docs/user-guide/kubeconfig-file/.
0000000000000000000000000000000000000000;;	func New(kubeConfigFile string, authorizedTTL, unauthorizedTTL time.Duration) (*WebhookAuthorizer, error) {
0000000000000000000000000000000000000000;;		subjectAccessReview, err := subjectAccessReviewInterfaceFromKubeconfig(kubeConfigFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newWithBackoff(subjectAccessReview, authorizedTTL, unauthorizedTTL, retryBackoff)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newWithBackoff allows tests to skip the sleep.
0000000000000000000000000000000000000000;;	func newWithBackoff(subjectAccessReview authorizationclient.SubjectAccessReviewInterface, authorizedTTL, unauthorizedTTL, initialBackoff time.Duration) (*WebhookAuthorizer, error) {
0000000000000000000000000000000000000000;;		return &WebhookAuthorizer{
0000000000000000000000000000000000000000;;			subjectAccessReview: subjectAccessReview,
0000000000000000000000000000000000000000;;			responseCache:       cache.NewLRUExpireCache(1024),
0000000000000000000000000000000000000000;;			authorizedTTL:       authorizedTTL,
0000000000000000000000000000000000000000;;			unauthorizedTTL:     unauthorizedTTL,
0000000000000000000000000000000000000000;;			initialBackoff:      initialBackoff,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Authorize makes a REST request to the remote service describing the attempted action as a JSON
0000000000000000000000000000000000000000;;	// serialized api.authorization.v1beta1.SubjectAccessReview object. An example request body is
0000000000000000000000000000000000000000;;	// provided bellow.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     {
0000000000000000000000000000000000000000;;	//       "apiVersion": "authorization.k8s.io/v1beta1",
0000000000000000000000000000000000000000;;	//       "kind": "SubjectAccessReview",
0000000000000000000000000000000000000000;;	//       "spec": {
0000000000000000000000000000000000000000;;	//         "resourceAttributes": {
0000000000000000000000000000000000000000;;	//           "namespace": "kittensandponies",
0000000000000000000000000000000000000000;;	//           "verb": "GET",
0000000000000000000000000000000000000000;;	//           "group": "group3",
0000000000000000000000000000000000000000;;	//           "resource": "pods"
0000000000000000000000000000000000000000;;	//         },
0000000000000000000000000000000000000000;;	//         "user": "jane",
0000000000000000000000000000000000000000;;	//         "group": [
0000000000000000000000000000000000000000;;	//           "group1",
0000000000000000000000000000000000000000;;	//           "group2"
0000000000000000000000000000000000000000;;	//         ]
0000000000000000000000000000000000000000;;	//       }
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The remote service is expected to fill the SubjectAccessReviewStatus field to either allow or
0000000000000000000000000000000000000000;;	// disallow access. A permissive response would return:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     {
0000000000000000000000000000000000000000;;	//       "apiVersion": "authorization.k8s.io/v1beta1",
0000000000000000000000000000000000000000;;	//       "kind": "SubjectAccessReview",
0000000000000000000000000000000000000000;;	//       "status": {
0000000000000000000000000000000000000000;;	//         "allowed": true
0000000000000000000000000000000000000000;;	//       }
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To disallow access, the remote service would return:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     {
0000000000000000000000000000000000000000;;	//       "apiVersion": "authorization.k8s.io/v1beta1",
0000000000000000000000000000000000000000;;	//       "kind": "SubjectAccessReview",
0000000000000000000000000000000000000000;;	//       "status": {
0000000000000000000000000000000000000000;;	//         "allowed": false,
0000000000000000000000000000000000000000;;	//         "reason": "user does not have read access to the namespace"
0000000000000000000000000000000000000000;;	//       }
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (w *WebhookAuthorizer) Authorize(attr authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;		r := &authorization.SubjectAccessReview{}
0000000000000000000000000000000000000000;;		if user := attr.GetUser(); user != nil {
0000000000000000000000000000000000000000;;			r.Spec = authorization.SubjectAccessReviewSpec{
0000000000000000000000000000000000000000;;				User:   user.GetName(),
0000000000000000000000000000000000000000;;				Groups: user.GetGroups(),
0000000000000000000000000000000000000000;;				Extra:  convertToSARExtra(user.GetExtra()),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if attr.IsResourceRequest() {
0000000000000000000000000000000000000000;;			r.Spec.ResourceAttributes = &authorization.ResourceAttributes{
0000000000000000000000000000000000000000;;				Namespace:   attr.GetNamespace(),
0000000000000000000000000000000000000000;;				Verb:        attr.GetVerb(),
0000000000000000000000000000000000000000;;				Group:       attr.GetAPIGroup(),
0000000000000000000000000000000000000000;;				Version:     attr.GetAPIVersion(),
0000000000000000000000000000000000000000;;				Resource:    attr.GetResource(),
0000000000000000000000000000000000000000;;				Subresource: attr.GetSubresource(),
0000000000000000000000000000000000000000;;				Name:        attr.GetName(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.Spec.NonResourceAttributes = &authorization.NonResourceAttributes{
0000000000000000000000000000000000000000;;				Path: attr.GetPath(),
0000000000000000000000000000000000000000;;				Verb: attr.GetVerb(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := json.Marshal(r.Spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if entry, ok := w.responseCache.Get(string(key)); ok {
0000000000000000000000000000000000000000;;			r.Status = entry.(authorization.SubjectAccessReviewStatus)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				result *authorization.SubjectAccessReview
0000000000000000000000000000000000000000;;				err    error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			webhook.WithExponentialBackoff(w.initialBackoff, func() error {
0000000000000000000000000000000000000000;;				result, err = w.subjectAccessReview.Create(r)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// An error here indicates bad configuration or an outage. Log for debugging.
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to make webhook authorizer request: %v", err)
0000000000000000000000000000000000000000;;				return false, "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Status = result.Status
0000000000000000000000000000000000000000;;			if r.Status.Allowed {
0000000000000000000000000000000000000000;;				w.responseCache.Add(string(key), r.Status, w.authorizedTTL)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.responseCache.Add(string(key), r.Status, w.unauthorizedTTL)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.Status.Allowed, r.Status.Reason, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertToSARExtra(extra map[string][]string) map[string]authorization.ExtraValue {
0000000000000000000000000000000000000000;;		if extra == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := map[string]authorization.ExtraValue{}
0000000000000000000000000000000000000000;;		for k, v := range extra {
0000000000000000000000000000000000000000;;			ret[k] = authorization.ExtraValue(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NOTE: client-go doesn't provide a registry. client-go does registers the
0000000000000000000000000000000000000000;;	// authorization/v1beta1. We construct a registry that acknowledges
0000000000000000000000000000000000000000;;	// authorization/v1beta1 as an enabled version to pass a check enforced in
0000000000000000000000000000000000000000;;	// NewGenericWebhook.
0000000000000000000000000000000000000000;;	var registry = registered.NewOrDie("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		registry.RegisterVersions(groupVersions)
0000000000000000000000000000000000000000;;		if err := registry.EnableVersions(groupVersions...); err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to enable version %v", groupVersions))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// subjectAccessReviewInterfaceFromKubeconfig builds a client from the specified kubeconfig file,
0000000000000000000000000000000000000000;;	// and returns a SubjectAccessReviewInterface that uses that client. Note that the client submits SubjectAccessReview
0000000000000000000000000000000000000000;;	// requests to the exact path specified in the kubeconfig file, so arbitrary non-API servers can be targeted.
0000000000000000000000000000000000000000;;	func subjectAccessReviewInterfaceFromKubeconfig(kubeConfigFile string) (authorizationclient.SubjectAccessReviewInterface, error) {
0000000000000000000000000000000000000000;;		gw, err := webhook.NewGenericWebhook(registry, scheme.Codecs, kubeConfigFile, groupVersions, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &subjectAccessReviewClient{gw}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subjectAccessReviewClient struct {
0000000000000000000000000000000000000000;;		w *webhook.GenericWebhook
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *subjectAccessReviewClient) Create(subjectAccessReview *authorization.SubjectAccessReview) (*authorization.SubjectAccessReview, error) {
0000000000000000000000000000000000000000;;		result := &authorization.SubjectAccessReview{}
0000000000000000000000000000000000000000;;		err := t.w.RestClient.Post().Body(subjectAccessReview).Do().Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
