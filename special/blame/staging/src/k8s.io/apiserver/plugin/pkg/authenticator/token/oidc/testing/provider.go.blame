0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d67f67dec8669bacc40516cb535220d5191fdaaa;plugin/pkg/auth/authenticator/token/oidc/testing/provider.go[plugin/pkg/auth/authenticator/token/oidc/testing/provider.go][staging/src/k8s.io/apiserver/plugin/pkg/authenticator/token/oidc/testing/provider.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/jose"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/key"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/oidc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewOIDCProvider provides a bare minimum OIDC IdP Server useful for testing.
0000000000000000000000000000000000000000;;	func NewOIDCProvider(t *testing.T, issuerPath string) *OIDCProvider {
0000000000000000000000000000000000000000;;		privKey, err := key.GeneratePrivateKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Cannot create OIDC Provider: %v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		op := &OIDCProvider{
0000000000000000000000000000000000000000;;			Mux:        http.NewServeMux(),
0000000000000000000000000000000000000000;;			PrivKey:    privKey,
0000000000000000000000000000000000000000;;			issuerPath: issuerPath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		op.Mux.HandleFunc(path.Join(issuerPath, "/.well-known/openid-configuration"), op.handleConfig)
0000000000000000000000000000000000000000;;		op.Mux.HandleFunc(path.Join(issuerPath, "/keys"), op.handleKeys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return op
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCProvider struct {
0000000000000000000000000000000000000000;;		Mux        *http.ServeMux
0000000000000000000000000000000000000000;;		PCFG       oidc.ProviderConfig
0000000000000000000000000000000000000000;;		PrivKey    *key.PrivateKey
0000000000000000000000000000000000000000;;		issuerPath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (op *OIDCProvider) ServeTLSWithKeyPair(cert, key string) (*httptest.Server, error) {
0000000000000000000000000000000000000000;;		srv := httptest.NewUnstartedServer(op.Mux)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srv.TLS = &tls.Config{Certificates: make([]tls.Certificate, 1)}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		srv.TLS.Certificates[0], err = tls.LoadX509KeyPair(cert, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Cannot load cert/key pair: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv.StartTLS()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The issuer's URL is extended by an optional path. This ensures that the plugin can
0000000000000000000000000000000000000000;;		// handle issuers that use a non-root path for discovery (see kubernetes/kubernetes#29749).
0000000000000000000000000000000000000000;;		srv.URL = srv.URL + op.issuerPath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u, err := url.Parse(srv.URL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pathFor := func(p string) *url.URL {
0000000000000000000000000000000000000000;;			u2 := *u // Shallow copy.
0000000000000000000000000000000000000000;;			u2.Path = path.Join(u2.Path, p)
0000000000000000000000000000000000000000;;			return &u2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		op.PCFG = oidc.ProviderConfig{
0000000000000000000000000000000000000000;;			Issuer:                  u,
0000000000000000000000000000000000000000;;			AuthEndpoint:            pathFor("/auth"),
0000000000000000000000000000000000000000;;			TokenEndpoint:           pathFor("/token"),
0000000000000000000000000000000000000000;;			KeysEndpoint:            pathFor("/keys"),
0000000000000000000000000000000000000000;;			ResponseTypesSupported:  []string{"code"},
0000000000000000000000000000000000000000;;			SubjectTypesSupported:   []string{"public"},
0000000000000000000000000000000000000000;;			IDTokenSigningAlgValues: []string{"RS256"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return srv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (op *OIDCProvider) handleConfig(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(&op.PCFG)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (op *OIDCProvider) handleKeys(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		keys := struct {
0000000000000000000000000000000000000000;;			Keys []jose.JWK `json:"keys"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Keys: []jose.JWK{op.PrivKey.JWK()},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(keys)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Cache-Control", fmt.Sprintf("public, max-age=%d", int(time.Hour.Seconds())))
0000000000000000000000000000000000000000;;		w.Header().Set("Expires", time.Now().Add(time.Hour).Format(time.RFC1123))
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateSelfSignedCert generates a self-signed cert/key pairs and writes to the certPath/keyPath.
0000000000000000000000000000000000000000;;	// This method is mostly identical to crypto.GenerateSelfSignedCert except for the 'IsCA' and 'KeyUsage'
0000000000000000000000000000000000000000;;	// in the certificate template. (Maybe we can merge these two methods).
0000000000000000000000000000000000000000;;	func GenerateSelfSignedCert(t *testing.T, host, certPath, keyPath string) {
0000000000000000000000000000000000000000;;		priv, err := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template := x509.Certificate{
0000000000000000000000000000000000000000;;			SerialNumber: big.NewInt(1),
0000000000000000000000000000000000000000;;			Subject: pkix.Name{
0000000000000000000000000000000000000000;;				CommonName: fmt.Sprintf("%s@%d", host, time.Now().Unix()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NotBefore: time.Now(),
0000000000000000000000000000000000000000;;			NotAfter:  time.Now().Add(time.Hour * 24 * 365),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
0000000000000000000000000000000000000000;;			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;			BasicConstraintsValid: true,
0000000000000000000000000000000000000000;;			IsCA: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ip := net.ParseIP(host); ip != nil {
0000000000000000000000000000000000000000;;			template.IPAddresses = append(template.IPAddresses, ip)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			template.DNSNames = append(template.DNSNames, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate cert
0000000000000000000000000000000000000000;;		certBuffer := bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := pem.Encode(&certBuffer, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate key
0000000000000000000000000000000000000000;;		keyBuffer := bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := pem.Encode(&keyBuffer, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write cert
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(filepath.Dir(certPath), os.FileMode(0755)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(certPath, certBuffer.Bytes(), os.FileMode(0644)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write key
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(filepath.Dir(keyPath), os.FileMode(0755)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(keyPath, keyBuffer.Bytes(), os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
