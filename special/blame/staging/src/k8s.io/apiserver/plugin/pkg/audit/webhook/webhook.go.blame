0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
620b8240db3e28807eba9eaf682194ac638c69e8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package webhook implements the audit.Backend interface using HTTP webhooks.
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/announced"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		auditinternal "k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/audit/install"
0000000000000000000000000000000000000000;;		auditv1alpha1 "k8s.io/apiserver/pkg/apis/audit/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/webhook"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ModeBatch indicates that the webhook should buffer audit events
0000000000000000000000000000000000000000;;		// internally, sending batch updates either once a certain number of
0000000000000000000000000000000000000000;;		// events have been received or a certain amount of time has passed.
0000000000000000000000000000000000000000;;		ModeBatch = "batch"
0000000000000000000000000000000000000000;;		// ModeBlocking causes the webhook to block on every attempt to process
0000000000000000000000000000000000000000;;		// a set of events. This causes requests to the API server to wait for a
0000000000000000000000000000000000000000;;		// round trip to the external audit service before sending a response.
0000000000000000000000000000000000000000;;		ModeBlocking = "blocking"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowedModes is the modes known by this webhook.
0000000000000000000000000000000000000000;;	var AllowedModes = []string{
0000000000000000000000000000000000000000;;		ModeBatch,
0000000000000000000000000000000000000000;;		ModeBlocking,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Default configuration values for ModeBatch.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(ericchiang): Make these value configurable. Maybe through a
0000000000000000000000000000000000000000;;		// kubeconfig extension?
0000000000000000000000000000000000000000;;		defaultBatchBufferSize = 1000        // Buffer up to 1000 events before blocking.
0000000000000000000000000000000000000000;;		defaultBatchMaxSize    = 100         // Only send 100 events at a time.
0000000000000000000000000000000000000000;;		defaultBatchMaxWait    = time.Minute // Send events at least once a minute.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The plugin name reported in error metrics.
0000000000000000000000000000000000000000;;	const pluginName = "webhook"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBackend returns an audit backend that sends events over HTTP to an external service.
0000000000000000000000000000000000000000;;	// The mode indicates the caching behavior of the webhook. Either blocking (ModeBlocking)
0000000000000000000000000000000000000000;;	// or buffered with batch POSTs (ModeBatch).
0000000000000000000000000000000000000000;;	func NewBackend(kubeConfigFile string, mode string) (audit.Backend, error) {
0000000000000000000000000000000000000000;;		switch mode {
0000000000000000000000000000000000000000;;		case ModeBatch:
0000000000000000000000000000000000000000;;			return newBatchWebhook(kubeConfigFile)
0000000000000000000000000000000000000000;;		case ModeBlocking:
0000000000000000000000000000000000000000;;			return newBlockingWebhook(kubeConfigFile)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("webhook mode %q is not in list of known modes (%s)",
0000000000000000000000000000000000000000;;				mode, strings.Join(AllowedModes, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// NOTE: Copied from other webhook implementations
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Can we make these passable to NewGenericWebhook?
0000000000000000000000000000000000000000;;		groupFactoryRegistry = make(announced.APIGroupFactoryRegistry)
0000000000000000000000000000000000000000;;		groupVersions        = []schema.GroupVersion{auditv1alpha1.SchemeGroupVersion}
0000000000000000000000000000000000000000;;		registry             = registered.NewOrDie("")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		registry.RegisterVersions(groupVersions)
0000000000000000000000000000000000000000;;		if err := registry.EnableVersions(groupVersions...); err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("failed to enable version %v", groupVersions))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		install.Install(groupFactoryRegistry, registry, audit.Scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadWebhook(configFile string) (*webhook.GenericWebhook, error) {
0000000000000000000000000000000000000000;;		return webhook.NewGenericWebhook(registry, audit.Codecs, configFile, groupVersions, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBlockingWebhook(configFile string) (*blockingBackend, error) {
0000000000000000000000000000000000000000;;		w, err := loadWebhook(configFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &blockingBackend{w}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type blockingBackend struct {
0000000000000000000000000000000000000000;;		w *webhook.GenericWebhook
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *blockingBackend) Run(stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *blockingBackend) ProcessEvents(ev ...*auditinternal.Event) {
0000000000000000000000000000000000000000;;		if err := b.processEvents(ev...); err != nil {
0000000000000000000000000000000000000000;;			audit.HandlePluginError(pluginName, err, ev...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *blockingBackend) processEvents(ev ...*auditinternal.Event) error {
0000000000000000000000000000000000000000;;		var list auditinternal.EventList
0000000000000000000000000000000000000000;;		for _, e := range ev {
0000000000000000000000000000000000000000;;			list.Items = append(list.Items, *e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// NOTE: No exponential backoff because this is the blocking webhook
0000000000000000000000000000000000000000;;		// mode. Any attempts to retry will block API server requests.
0000000000000000000000000000000000000000;;		return b.w.RestClient.Post().Body(&list).Do().Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBatchWebhook(configFile string) (*batchBackend, error) {
0000000000000000000000000000000000000000;;		w, err := loadWebhook(configFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := conversion.NewCloner()
0000000000000000000000000000000000000000;;		for _, f := range metav1.GetGeneratedDeepCopyFuncs() {
0000000000000000000000000000000000000000;;			if err := c.RegisterGeneratedDeepCopyFunc(f); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("registering meta deep copy method: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, f := range auditinternal.GetGeneratedDeepCopyFuncs() {
0000000000000000000000000000000000000000;;			if err := c.RegisterGeneratedDeepCopyFunc(f); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("registering audit deep copy method: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &batchBackend{
0000000000000000000000000000000000000000;;			w:            w,
0000000000000000000000000000000000000000;;			buffer:       make(chan *auditinternal.Event, defaultBatchBufferSize),
0000000000000000000000000000000000000000;;			maxBatchSize: defaultBatchMaxSize,
0000000000000000000000000000000000000000;;			maxBatchWait: defaultBatchMaxWait,
0000000000000000000000000000000000000000;;			cloner:       c,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type batchBackend struct {
0000000000000000000000000000000000000000;;		w *webhook.GenericWebhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cloner is used to deep copy events as they are buffered.
0000000000000000000000000000000000000000;;		cloner *conversion.Cloner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Channel to buffer events in memory before sending them on the webhook.
0000000000000000000000000000000000000000;;		buffer chan *auditinternal.Event
0000000000000000000000000000000000000000;;		// Maximum number of events that can be sent at once.
0000000000000000000000000000000000000000;;		maxBatchSize int
0000000000000000000000000000000000000000;;		// Amount of time to wait after sending events before force sending another set.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Receiving maxBatchSize events will always trigger a send, regardless of
0000000000000000000000000000000000000000;;		// if this amount of time has been reached.
0000000000000000000000000000000000000000;;		maxBatchWait time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *batchBackend) Run(stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		f := func() {
0000000000000000000000000000000000000000;;			// Recover from any panics caused by this method so a panic in the
0000000000000000000000000000000000000000;;			// goroutine can't bring down the main routine.
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t := time.NewTimer(b.maxBatchWait)
0000000000000000000000000000000000000000;;			defer t.Stop() // Release ticker resources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b.sendBatchEvents(stopCh, t.C)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				f()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-stopCh:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendBatchEvents attempts to batch some number of events to the backend. It POSTs events
0000000000000000000000000000000000000000;;	// in a goroutine and logging any error encountered during the POST.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following things can cause sendBatchEvents to exit:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * Some maximum number of events are received.
0000000000000000000000000000000000000000;;	//   * Timer has passed, all queued events are sent.
0000000000000000000000000000000000000000;;	//   * StopCh is closed, all queued events are sent.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (b *batchBackend) sendBatchEvents(stopCh <-chan struct{}, timer <-chan time.Time) {
0000000000000000000000000000000000000000;;		var events []auditinternal.Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	L:
0000000000000000000000000000000000000000;;		for i := 0; i < b.maxBatchSize; i++ {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case ev := <-b.buffer:
0000000000000000000000000000000000000000;;				events = append(events, *ev)
0000000000000000000000000000000000000000;;			case <-timer:
0000000000000000000000000000000000000000;;				// Timer has expired. Send whatever events are in the queue.
0000000000000000000000000000000000000000;;				break L
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				// Webhook has shut down. Send the last events.
0000000000000000000000000000000000000000;;				break L
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(events) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list := auditinternal.EventList{Items: events}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// Execute the webhook POST in a goroutine to keep it from blocking.
0000000000000000000000000000000000000000;;			// This lets the webhook continue to drain the queue immediatly.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := webhook.WithExponentialBackoff(0, func() error {
0000000000000000000000000000000000000000;;				return b.w.RestClient.Post().Body(&list).Do().Error()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				impacted := make([]*auditinternal.Event, len(events))
0000000000000000000000000000000000000000;;				for i := range events {
0000000000000000000000000000000000000000;;					impacted[i] = &events[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				audit.HandlePluginError(pluginName, err, impacted...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *batchBackend) ProcessEvents(ev ...*auditinternal.Event) {
0000000000000000000000000000000000000000;;		for i, e := range ev {
0000000000000000000000000000000000000000;;			// Per the audit.Backend interface these events are reused after being
0000000000000000000000000000000000000000;;			// sent to the Sink. Deep copy and send the copy to the queue.
0000000000000000000000000000000000000000;;			event := new(auditinternal.Event)
0000000000000000000000000000000000000000;;			if err := auditinternal.DeepCopy_audit_Event(e, event, b.cloner); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("failed to clone audit event: %v: %#v", err, e)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case b.buffer <- event:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				audit.HandlePluginError(pluginName, fmt.Errorf("audit webhook queue blocked"), ev[i:]...)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
