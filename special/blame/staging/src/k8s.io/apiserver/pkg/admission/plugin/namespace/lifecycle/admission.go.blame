0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
3f099cd43246053823a5a9ba8f6a059eb0989e3d;plugin/pkg/admission/namespace/lifecycle/admission.go[plugin/pkg/admission/namespace/lifecycle/admission.go][staging/src/k8s.io/apiserver/pkg/admission/plugin/namespace/lifecycle/admission.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package lifecycle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilcache "k8s.io/apimachinery/pkg/util/cache"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission/initializer"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		corelisters "k8s.io/client-go/listers/core/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Name of admission plug-in
0000000000000000000000000000000000000000;;		PluginName = "NamespaceLifecycle"
0000000000000000000000000000000000000000;;		// how long a namespace stays in the force live lookup cache before expiration.
0000000000000000000000000000000000000000;;		forceLiveLookupTTL = 30 * time.Second
0000000000000000000000000000000000000000;;		// how long to wait for a missing namespace before re-checking the cache (and then doing a live lookup)
0000000000000000000000000000000000000000;;		// this accomplishes two things:
0000000000000000000000000000000000000000;;		// 1. It allows a watch-fed cache time to observe a namespace creation event
0000000000000000000000000000000000000000;;		// 2. It allows time for a namespace creation to distribute to members of a storage cluster,
0000000000000000000000000000000000000000;;		//    so the live lookup has a better chance of succeeding even if it isn't performed against the leader.
0000000000000000000000000000000000000000;;		missingNamespaceWait = 50 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin
0000000000000000000000000000000000000000;;	func Register(plugins *admission.Plugins) {
0000000000000000000000000000000000000000;;		plugins.Register(PluginName, func(config io.Reader) (admission.Interface, error) {
0000000000000000000000000000000000000000;;			return NewLifecycle(sets.NewString(metav1.NamespaceDefault, metav1.NamespaceSystem, metav1.NamespacePublic))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lifecycle is an implementation of admission.Interface.
0000000000000000000000000000000000000000;;	// It enforces life-cycle constraints around a Namespace depending on its Phase
0000000000000000000000000000000000000000;;	type lifecycle struct {
0000000000000000000000000000000000000000;;		*admission.Handler
0000000000000000000000000000000000000000;;		client             kubernetes.Interface
0000000000000000000000000000000000000000;;		immortalNamespaces sets.String
0000000000000000000000000000000000000000;;		namespaceLister    corelisters.NamespaceLister
0000000000000000000000000000000000000000;;		// forceLiveLookupCache holds a list of entries for namespaces that we have a strong reason to believe are stale in our local cache.
0000000000000000000000000000000000000000;;		// if a namespace is in this cache, then we will ignore our local state and always fetch latest from api server.
0000000000000000000000000000000000000000;;		forceLiveLookupCache *utilcache.LRUExpireCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type forceLiveLookupEntry struct {
0000000000000000000000000000000000000000;;		expiry time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = initializer.WantsExternalKubeInformerFactory(&lifecycle{})
0000000000000000000000000000000000000000;;	var _ = initializer.WantsExternalKubeClientSet(&lifecycle{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeNamespaceKey(namespace string) *v1.Namespace {
0000000000000000000000000000000000000000;;		return &v1.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      namespace,
0000000000000000000000000000000000000000;;				Namespace: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lifecycle) Admit(a admission.Attributes) error {
0000000000000000000000000000000000000000;;		// prevent deletion of immortal namespaces
0000000000000000000000000000000000000000;;		if a.GetOperation() == admission.Delete && a.GetKind().GroupKind() == v1.SchemeGroupVersion.WithKind("Namespace").GroupKind() && l.immortalNamespaces.Has(a.GetName()) {
0000000000000000000000000000000000000000;;			return errors.NewForbidden(a.GetResource().GroupResource(), a.GetName(), fmt.Errorf("this namespace may not be deleted"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we're here, then we've already passed authentication, so we're allowed to do what we're trying to do
0000000000000000000000000000000000000000;;		// if we're here, then the API server has found a route, which means that if we have a non-empty namespace
0000000000000000000000000000000000000000;;		// its a namespaced resource.
0000000000000000000000000000000000000000;;		if len(a.GetNamespace()) == 0 || a.GetKind().GroupKind() == v1.SchemeGroupVersion.WithKind("Namespace").GroupKind() {
0000000000000000000000000000000000000000;;			// if a namespace is deleted, we want to prevent all further creates into it
0000000000000000000000000000000000000000;;			// while it is undergoing termination.  to reduce incidences where the cache
0000000000000000000000000000000000000000;;			// is slow to update, we add the namespace into a force live lookup list to ensure
0000000000000000000000000000000000000000;;			// we are not looking at stale state.
0000000000000000000000000000000000000000;;			if a.GetOperation() == admission.Delete {
0000000000000000000000000000000000000000;;				l.forceLiveLookupCache.Add(a.GetName(), true, forceLiveLookupTTL)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always allow access review checks.  Returning status about the namespace would be leaking information
0000000000000000000000000000000000000000;;		if isAccessReview(a) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need to wait for our caches to warm
0000000000000000000000000000000000000000;;		if !l.WaitForReady() {
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("not yet ready to handle request"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			exists bool
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace, err := l.namespaceLister.Get(a.GetNamespace())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			exists = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !exists && a.GetOperation() == admission.Create {
0000000000000000000000000000000000000000;;			// give the cache time to observe the namespace before rejecting a create.
0000000000000000000000000000000000000000;;			// this helps when creating a namespace and immediately creating objects within it.
0000000000000000000000000000000000000000;;			time.Sleep(missingNamespaceWait)
0000000000000000000000000000000000000000;;			namespace, err = l.namespaceLister.Get(a.GetNamespace())
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				// no-op
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				exists = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exists {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("found %s in cache after waiting", a.GetNamespace())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// forceLiveLookup if true will skip looking at local cache state and instead always make a live call to server.
0000000000000000000000000000000000000000;;		forceLiveLookup := false
0000000000000000000000000000000000000000;;		if _, ok := l.forceLiveLookupCache.Get(a.GetNamespace()); ok {
0000000000000000000000000000000000000000;;			// we think the namespace was marked for deletion, but our current local cache says otherwise, we will force a live lookup.
0000000000000000000000000000000000000000;;			forceLiveLookup = exists && namespace.Status.Phase == v1.NamespaceActive
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// refuse to operate on non-existent namespaces
0000000000000000000000000000000000000000;;		if !exists || forceLiveLookup {
0000000000000000000000000000000000000000;;			// as a last resort, make a call directly to storage
0000000000000000000000000000000000000000;;			namespace, err = l.client.Core().Namespaces().Get(a.GetNamespace(), metav1.GetOptions{})
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case errors.IsNotFound(err):
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("found %s via storage lookup", a.GetNamespace())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure that we're not trying to create objects in terminating namespaces
0000000000000000000000000000000000000000;;		if a.GetOperation() == admission.Create {
0000000000000000000000000000000000000000;;			if namespace.Status.Phase != v1.NamespaceTerminating {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: This should probably not be a 403
0000000000000000000000000000000000000000;;			return admission.NewForbidden(a, fmt.Errorf("unable to create new content in namespace %s because it is being terminated.", a.GetNamespace()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLifecycle creates a new namespace lifecycle admission control handler
0000000000000000000000000000000000000000;;	func NewLifecycle(immortalNamespaces sets.String) (admission.Interface, error) {
0000000000000000000000000000000000000000;;		return newLifecycleWithClock(immortalNamespaces, clock.RealClock{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLifecycleWithClock(immortalNamespaces sets.String, clock utilcache.Clock) (admission.Interface, error) {
0000000000000000000000000000000000000000;;		forceLiveLookupCache := utilcache.NewLRUExpireCacheWithClock(100, clock)
0000000000000000000000000000000000000000;;		return &lifecycle{
0000000000000000000000000000000000000000;;			Handler:              admission.NewHandler(admission.Create, admission.Update, admission.Delete),
0000000000000000000000000000000000000000;;			immortalNamespaces:   immortalNamespaces,
0000000000000000000000000000000000000000;;			forceLiveLookupCache: forceLiveLookupCache,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lifecycle) SetExternalKubeInformerFactory(f informers.SharedInformerFactory) {
0000000000000000000000000000000000000000;;		namespaceInformer := f.Core().V1().Namespaces()
0000000000000000000000000000000000000000;;		l.namespaceLister = namespaceInformer.Lister()
0000000000000000000000000000000000000000;;		l.SetReadyFunc(namespaceInformer.Informer().HasSynced)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lifecycle) SetExternalKubeClientSet(client kubernetes.Interface) {
0000000000000000000000000000000000000000;;		l.client = client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lifecycle) Validate() error {
0000000000000000000000000000000000000000;;		if l.namespaceLister == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing namespaceLister")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.client == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// accessReviewResources are resources which give a view into permissions in a namespace.  Users must be allowed to create these
0000000000000000000000000000000000000000;;	// resources because returning "not found" errors allows someone to search for the "people I'm going to fire in 2017" namespace.
0000000000000000000000000000000000000000;;	var accessReviewResources = map[schema.GroupResource]bool{
0000000000000000000000000000000000000000;;		{Group: "authorization.k8s.io", Resource: "localsubjectaccessreviews"}: true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isAccessReview(a admission.Attributes) bool {
0000000000000000000000000000000000000000;;		return accessReviewResources[a.GetResource().GroupResource()]
0000000000000000000000000000000000000000;;	}
