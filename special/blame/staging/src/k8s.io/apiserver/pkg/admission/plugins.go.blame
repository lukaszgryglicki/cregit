0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
45fb76a09e08545a2832d788e4834004315e297e;pkg/admission/plugins.go[pkg/admission/plugins.go][staging/src/k8s.io/apiserver/pkg/admission/plugins.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package admission
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Factory is a function that returns an Interface for admission decisions.
0000000000000000000000000000000000000000;;	// The config parameter provides an io.Reader handler to the factory in
0000000000000000000000000000000000000000;;	// order to load specific configurations. If no configuration is provided
0000000000000000000000000000000000000000;;	// the parameter is nil.
0000000000000000000000000000000000000000;;	type Factory func(config io.Reader) (Interface, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Plugins struct {
0000000000000000000000000000000000000000;;		lock     sync.Mutex
0000000000000000000000000000000000000000;;		registry map[string]Factory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All registered admission options.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// PluginEnabledFn checks whether a plugin is enabled.  By default, if you ask about it, it's enabled.
0000000000000000000000000000000000000000;;		PluginEnabledFn = func(name string, config io.Reader) bool {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PluginEnabledFunc is a function type that can provide an external check on whether an admission plugin may be enabled
0000000000000000000000000000000000000000;;	type PluginEnabledFunc func(name string, config io.Reader) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Registered enumerates the names of all registered plugins.
0000000000000000000000000000000000000000;;	func (ps *Plugins) Registered() []string {
0000000000000000000000000000000000000000;;		ps.lock.Lock()
0000000000000000000000000000000000000000;;		defer ps.lock.Unlock()
0000000000000000000000000000000000000000;;		keys := []string{}
0000000000000000000000000000000000000000;;		for k := range ps.registry {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers a plugin Factory by name. This
0000000000000000000000000000000000000000;;	// is expected to happen during app startup.
0000000000000000000000000000000000000000;;	func (ps *Plugins) Register(name string, plugin Factory) {
0000000000000000000000000000000000000000;;		ps.lock.Lock()
0000000000000000000000000000000000000000;;		defer ps.lock.Unlock()
0000000000000000000000000000000000000000;;		_, found := ps.registry[name]
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			glog.Fatalf("Admission plugin %q was registered twice", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ps.registry == nil {
0000000000000000000000000000000000000000;;			ps.registry = map[string]Factory{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Registered admission plugin %q", name)
0000000000000000000000000000000000000000;;		ps.registry[name] = plugin
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPlugin creates an instance of the named plugin.  It returns `false` if the
0000000000000000000000000000000000000000;;	// the name is not known. The error is returned only when the named provider was
0000000000000000000000000000000000000000;;	// known but failed to initialize.  The config parameter specifies the io.Reader
0000000000000000000000000000000000000000;;	// handler of the configuration file for the cloud provider, or nil for no configuration.
0000000000000000000000000000000000000000;;	func (ps *Plugins) getPlugin(name string, config io.Reader) (Interface, bool, error) {
0000000000000000000000000000000000000000;;		ps.lock.Lock()
0000000000000000000000000000000000000000;;		defer ps.lock.Unlock()
0000000000000000000000000000000000000000;;		f, found := ps.registry[name]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config1, config2, err := splitStream(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !PluginEnabledFn(name, config1) {
0000000000000000000000000000000000000000;;			return nil, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, err := f(config2)
0000000000000000000000000000000000000000;;		return ret, true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitStream reads the stream bytes and constructs two copies of it.
0000000000000000000000000000000000000000;;	func splitStream(config io.Reader) (io.Reader, io.Reader, error) {
0000000000000000000000000000000000000000;;		if config == nil || reflect.ValueOf(config).IsNil() {
0000000000000000000000000000000000000000;;			return nil, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configBytes, err := ioutil.ReadAll(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return bytes.NewBuffer(configBytes), bytes.NewBuffer(configBytes), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromPlugins returns an admission.Interface that will enforce admission control decisions of all
0000000000000000000000000000000000000000;;	// the given plugins.
0000000000000000000000000000000000000000;;	func (ps *Plugins) NewFromPlugins(pluginNames []string, configProvider ConfigProvider, pluginInitializer PluginInitializer) (Interface, error) {
0000000000000000000000000000000000000000;;		plugins := []Interface{}
0000000000000000000000000000000000000000;;		for _, pluginName := range pluginNames {
0000000000000000000000000000000000000000;;			pluginConfig, err := configProvider.ConfigFor(pluginName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			plugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if plugin != nil {
0000000000000000000000000000000000000000;;				plugins = append(plugins, plugin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return chainAdmissionHandler(plugins), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitPlugin creates an instance of the named interface.
0000000000000000000000000000000000000000;;	func (ps *Plugins) InitPlugin(name string, config io.Reader, pluginInitializer PluginInitializer) (Interface, error) {
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			glog.Info("No admission plugin specified.")
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin, found, err := ps.getPlugin(name, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Couldn't init admission plugin %q: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unknown admission plugin: %s", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pluginInitializer.Initialize(plugin)
0000000000000000000000000000000000000000;;		// ensure that plugins have been properly initialized
0000000000000000000000000000000000000000;;		if err := Validate(plugin); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plugin, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate will call the Validate function in each plugin if they implement
0000000000000000000000000000000000000000;;	// the Validator interface.
0000000000000000000000000000000000000000;;	func Validate(plugin Interface) error {
0000000000000000000000000000000000000000;;		if validater, ok := plugin.(Validator); ok {
0000000000000000000000000000000000000000;;			err := validater.Validate()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PluginInitializers []PluginInitializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pp PluginInitializers) Initialize(plugin Interface) {
0000000000000000000000000000000000000000;;		for _, p := range pp {
0000000000000000000000000000000000000000;;			p.Initialize(plugin)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
