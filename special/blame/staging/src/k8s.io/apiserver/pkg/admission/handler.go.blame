0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
21badd08536b0f5a90f776b15151bb1658dabd5f;pkg/admission/handler.go[pkg/admission/handler.go][staging/src/k8s.io/apiserver/pkg/admission/handler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package admission
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// timeToWaitForReady is the amount of time to wait to let an admission controller to be ready to satisfy a request.
0000000000000000000000000000000000000000;;		// this is useful when admission controllers need to warm their caches before letting requests through.
0000000000000000000000000000000000000000;;		timeToWaitForReady = 10 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadyFunc is a function that returns true if the admission controller is ready to handle requests.
0000000000000000000000000000000000000000;;	type ReadyFunc func() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler is a base for admission control handlers that
0000000000000000000000000000000000000000;;	// support a predefined set of operations
0000000000000000000000000000000000000000;;	type Handler struct {
0000000000000000000000000000000000000000;;		operations sets.String
0000000000000000000000000000000000000000;;		readyFunc  ReadyFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handles returns true for methods that this handler supports
0000000000000000000000000000000000000000;;	func (h *Handler) Handles(operation Operation) bool {
0000000000000000000000000000000000000000;;		return h.operations.Has(string(operation))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHandler creates a new base handler that handles the passed
0000000000000000000000000000000000000000;;	// in operations
0000000000000000000000000000000000000000;;	func NewHandler(ops ...Operation) *Handler {
0000000000000000000000000000000000000000;;		operations := sets.NewString()
0000000000000000000000000000000000000000;;		for _, op := range ops {
0000000000000000000000000000000000000000;;			operations.Insert(string(op))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Handler{
0000000000000000000000000000000000000000;;			operations: operations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReadyFunc allows late registration of a ReadyFunc to know if the handler is ready to process requests.
0000000000000000000000000000000000000000;;	func (h *Handler) SetReadyFunc(readyFunc ReadyFunc) {
0000000000000000000000000000000000000000;;		h.readyFunc = readyFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForReady will wait for the readyFunc (if registered) to return ready, and in case of timeout, will return false.
0000000000000000000000000000000000000000;;	func (h *Handler) WaitForReady() bool {
0000000000000000000000000000000000000000;;		// there is no ready func configured, so we return immediately
0000000000000000000000000000000000000000;;		if h.readyFunc == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h.waitForReadyInternal(time.After(timeToWaitForReady))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *Handler) waitForReadyInternal(timeout <-chan time.Time) bool {
0000000000000000000000000000000000000000;;		// there is no configured ready func, so return immediately
0000000000000000000000000000000000000000;;		if h.readyFunc == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for !h.readyFunc() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(100 * time.Millisecond):
0000000000000000000000000000000000000000;;			case <-timeout:
0000000000000000000000000000000000000000;;				return h.readyFunc()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
