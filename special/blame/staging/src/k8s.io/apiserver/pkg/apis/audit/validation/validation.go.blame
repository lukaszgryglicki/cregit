0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
a7319ac0b5b58130f54b3bb52fa9e005a464b861;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidatePolicy(policy *audit.Policy) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		rulePath := field.NewPath("rules")
0000000000000000000000000000000000000000;;		for i, rule := range policy.Rules {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validatePolicyRule(rule, rulePath.Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePolicyRule(rule audit.PolicyRule, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateLevel(rule.Level, fldPath.Child("level"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateNonResourceURLs(rule.NonResourceURLs, fldPath.Child("nonResourceURLs"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateResources(rule.Resources, fldPath.Child("resources"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rule.NonResourceURLs) > 0 {
0000000000000000000000000000000000000000;;			if len(rule.Resources) > 0 || len(rule.Namespaces) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("nonResourceURLs"), rule.NonResourceURLs, "rules cannot apply to both regular resources and non-resource URLs"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var validLevels = []string{
0000000000000000000000000000000000000000;;		string(audit.LevelNone),
0000000000000000000000000000000000000000;;		string(audit.LevelMetadata),
0000000000000000000000000000000000000000;;		string(audit.LevelRequest),
0000000000000000000000000000000000000000;;		string(audit.LevelRequestResponse),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateLevel(level audit.Level, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		switch level {
0000000000000000000000000000000000000000;;		case audit.LevelNone, audit.LevelMetadata, audit.LevelRequest, audit.LevelRequestResponse:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			return field.ErrorList{field.Required(fldPath, "")}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return field.ErrorList{field.NotSupported(fldPath, level, validLevels)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateNonResourceURLs(urls []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		for i, url := range urls {
0000000000000000000000000000000000000000;;			if url == "*" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(url, "/") {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Index(i), url, "non-resource URL rules must begin with a '/' character"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if url != "" && strings.ContainsRune(url[:len(url)-1], '*') {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Index(i), url, "non-resource URL wildcards '*' must be the final character of the rule"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateResources(groupResources []audit.GroupResources, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		for _, groupResource := range groupResources {
0000000000000000000000000000000000000000;;			// The empty string represents the core API group.
0000000000000000000000000000000000000000;;			if len(groupResource.Group) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Group names must be lower case and be valid DNS subdomains.
0000000000000000000000000000000000000000;;			// reference: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md
0000000000000000000000000000000000000000;;			// an error is returned for group name like rbac.authorization.k8s.io/v1beta1
0000000000000000000000000000000000000000;;			// rbac.authorization.k8s.io is the valid one
0000000000000000000000000000000000000000;;			if msgs := validation.NameIsDNSSubdomain(groupResource.Group, false); len(msgs) != 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("group"), groupResource.Group, strings.Join(msgs, ",")))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
