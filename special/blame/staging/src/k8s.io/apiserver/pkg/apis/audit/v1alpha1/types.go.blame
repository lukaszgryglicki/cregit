0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
1500cef1333d1aa5067fb76f8413c9717e1054c4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1alpha1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		authnv1 "k8s.io/api/authentication/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header keys used by the audit system.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Header to hold the audit ID as the request is propagated through the serving hierarchy. The
0000000000000000000000000000000000000000;;		// Audit-ID header should be set by the first server to receive the request (e.g. the federation
0000000000000000000000000000000000000000;;		// server or kube-aggregator).
0000000000000000000000000000000000000000;;		HeaderAuditID = "Audit-ID"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Level defines the amount of information logged during auditing
0000000000000000000000000000000000000000;;	type Level string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid audit levels
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// LevelNone disables auditing
0000000000000000000000000000000000000000;;		LevelNone Level = "None"
0000000000000000000000000000000000000000;;		// LevelMetadata provides the basic level of auditing.
0000000000000000000000000000000000000000;;		LevelMetadata Level = "Metadata"
0000000000000000000000000000000000000000;;		// LevelRequest provides Metadata level of auditing, and additionally
0000000000000000000000000000000000000000;;		// logs the request object (does not apply for non-resource requests).
0000000000000000000000000000000000000000;;		LevelRequest Level = "Request"
0000000000000000000000000000000000000000;;		// LevelRequestResponse provides Request level of auditing, and additionally
0000000000000000000000000000000000000000;;		// logs the response object (does not apply for non-resource requests).
0000000000000000000000000000000000000000;;		LevelRequestResponse Level = "RequestResponse"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stage defines the stages in request handling that audit events may be generated.
0000000000000000000000000000000000000000;;	type Stage string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid audit stages.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The stage for events generated as soon as the audit handler receives the request, and before it
0000000000000000000000000000000000000000;;		// is delegated down the handler chain.
0000000000000000000000000000000000000000;;		StageRequestReceived = "RequestReceived"
0000000000000000000000000000000000000000;;		// The stage for events generated once the response headers are sent, but before the response body
0000000000000000000000000000000000000000;;		// is sent. This stage is only generated for long-running requests (e.g. watch).
0000000000000000000000000000000000000000;;		StageResponseStarted = "ResponseStarted"
0000000000000000000000000000000000000000;;		// The stage for events generated once the response body has been completed, and no more bytes
0000000000000000000000000000000000000000;;		// will be sent.
0000000000000000000000000000000000000000;;		StageResponseComplete = "ResponseComplete"
0000000000000000000000000000000000000000;;		// The stage for events generated when a panic occured.
0000000000000000000000000000000000000000;;		StagePanic = "Panic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event captures all the information that can be included in an API audit log.
0000000000000000000000000000000000000000;;	type Event struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// ObjectMeta is included for interoperability with API infrastructure.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuditLevel at which event was generated
0000000000000000000000000000000000000000;;		Level Level `json:"level" protobuf:"bytes,2,opt,name=level,casttype=Level"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time the request reached the apiserver.
0000000000000000000000000000000000000000;;		Timestamp metav1.Time `json:"timestamp" protobuf:"bytes,3,opt,name=timestamp"`
0000000000000000000000000000000000000000;;		// Unique audit ID, generated for each request.
0000000000000000000000000000000000000000;;		AuditID types.UID `json:"auditID" protobuf:"bytes,4,opt,name=auditID,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;		// Stage of the request handling when this event instance was generated.
0000000000000000000000000000000000000000;;		Stage Stage `json:"stage" protobuf:"bytes,5,opt,name=stage,casttype=Stage"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequestURI is the request URI as sent by the client to a server.
0000000000000000000000000000000000000000;;		RequestURI string `json:"requestURI" protobuf:"bytes,6,opt,name=requestURI"`
0000000000000000000000000000000000000000;;		// Verb is the kubernetes verb associated with the request.
0000000000000000000000000000000000000000;;		// For non-resource requests, this is the lower-cased HTTP method.
0000000000000000000000000000000000000000;;		Verb string `json:"verb" protobuf:"bytes,7,opt,name=verb"`
0000000000000000000000000000000000000000;;		// Authenticated user information.
0000000000000000000000000000000000000000;;		User authnv1.UserInfo `json:"user" protobuf:"bytes,8,opt,name=user"`
0000000000000000000000000000000000000000;;		// Impersonated user information.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ImpersonatedUser *authnv1.UserInfo `json:"impersonatedUser,omitempty" protobuf:"bytes,9,opt,name=impersonatedUser"`
0000000000000000000000000000000000000000;;		// Source IPs, from where the request originated and intermediate proxies.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SourceIPs []string `json:"sourceIPs,omitempty" protobuf:"bytes,10,rep,name=sourceIPs"`
0000000000000000000000000000000000000000;;		// Object reference this request is targeted at.
0000000000000000000000000000000000000000;;		// Does not apply for List-type requests, or non-resource requests.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObjectRef *ObjectReference `json:"objectRef,omitempty" protobuf:"bytes,11,opt,name=objectRef"`
0000000000000000000000000000000000000000;;		// The response status, populated even when the ResponseObject is not a Status type.
0000000000000000000000000000000000000000;;		// For successful responses, this will only include the Code and StatusSuccess.
0000000000000000000000000000000000000000;;		// For non-status type error responses, this will be auto-populated with the error Message.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResponseStatus *metav1.Status `json:"responseStatus,omitempty" protobuf:"bytes,12,opt,name=responseStatus"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// API object from the request, in JSON format. The RequestObject is recorded as-is in the request
0000000000000000000000000000000000000000;;		// (possibly re-encoded as JSON), prior to version conversion, defaulting, admission or
0000000000000000000000000000000000000000;;		// merging. It is an external versioned object type, and may not be a valid object on its own.
0000000000000000000000000000000000000000;;		// Omitted for non-resource requests.  Only logged at Request Level and higher.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequestObject *runtime.Unknown `json:"requestObject,omitempty" protobuf:"bytes,13,opt,name=requestObject"`
0000000000000000000000000000000000000000;;		// API object returned in the response, in JSON. The ResponseObject is recorded after conversion
0000000000000000000000000000000000000000;;		// to the external type, and serialized as JSON.  Omitted for non-resource requests.  Only logged
0000000000000000000000000000000000000000;;		// at Response Level.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResponseObject *runtime.Unknown `json:"responseObject,omitempty" protobuf:"bytes,14,opt,name=responseObject"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventList is a list of audit Events.
0000000000000000000000000000000000000000;;	type EventList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Event `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Policy defines the configuration of audit logging, and the rules for how different request
0000000000000000000000000000000000000000;;	// categories are logged.
0000000000000000000000000000000000000000;;	type Policy struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// ObjectMeta is included for interoperability with API infrastructure.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rules specify the audit Level a request should be recorded at.
0000000000000000000000000000000000000000;;		// A request may match multiple rules, in which case the FIRST matching rule is used.
0000000000000000000000000000000000000000;;		// The default audit level is None, but can be overridden by a catch-all rule at the end of the list.
0000000000000000000000000000000000000000;;		// PolicyRules are strictly ordered.
0000000000000000000000000000000000000000;;		Rules []PolicyRule `json:"rules" protobuf:"bytes,2,rep,name=rules"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PolicyList is a list of audit Policies.
0000000000000000000000000000000000000000;;	type PolicyList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Policy `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PolicyRule maps requests based off metadata to an audit Level.
0000000000000000000000000000000000000000;;	// Requests must match the rules of every field (an intersection of rules).
0000000000000000000000000000000000000000;;	type PolicyRule struct {
0000000000000000000000000000000000000000;;		// The Level that requests matching this rule are recorded at.
0000000000000000000000000000000000000000;;		Level Level `json:"level" protobuf:"bytes,1,opt,name=level,casttype=Level"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The users (by authenticated user name) this rule applies to.
0000000000000000000000000000000000000000;;		// An empty list implies every user.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Users []string `json:"users,omitempty" protobuf:"bytes,2,rep,name=users"`
0000000000000000000000000000000000000000;;		// The user groups this rule applies to. A user is considered matching
0000000000000000000000000000000000000000;;		// if it is a member of any of the UserGroups.
0000000000000000000000000000000000000000;;		// An empty list implies every user group.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UserGroups []string `json:"userGroups,omitempty" protobuf:"bytes,3,rep,name=userGroups"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The verbs that match this rule.
0000000000000000000000000000000000000000;;		// An empty list implies every verb.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Verbs []string `json:"verbs,omitempty" protobuf:"bytes,4,rep,name=verbs"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rules can apply to API resources (such as "pods" or "secrets"),
0000000000000000000000000000000000000000;;		// non-resource URL paths (such as "/api"), or neither, but not both.
0000000000000000000000000000000000000000;;		// If neither is specified, the rule is treated as a default for all URLs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Resources that this rule matches. An empty list implies all kinds in all API groups.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resources []GroupResources `json:"resources,omitempty" protobuf:"bytes,5,rep,name=resources"`
0000000000000000000000000000000000000000;;		// Namespaces that this rule matches.
0000000000000000000000000000000000000000;;		// The empty string "" matches non-namespaced resources.
0000000000000000000000000000000000000000;;		// An empty list implies every namespace.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespaces []string `json:"namespaces,omitempty" protobuf:"bytes,6,rep,name=namespaces"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NonResourceURLs is a set of URL paths that should be audited.
0000000000000000000000000000000000000000;;		// *s are allowed, but only as the full, final step in the path.
0000000000000000000000000000000000000000;;		// Examples:
0000000000000000000000000000000000000000;;		//  "/metrics" - Log requests for apiserver metrics
0000000000000000000000000000000000000000;;		//  "/healthz*" - Log all health checks
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NonResourceURLs []string `json:"nonResourceURLs,omitempty" protobuf:"bytes,7,rep,name=nonResourceURLs"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupResources represents resource kinds in an API group.
0000000000000000000000000000000000000000;;	type GroupResources struct {
0000000000000000000000000000000000000000;;		// Group is the name of the API group that contains the resources.
0000000000000000000000000000000000000000;;		// The empty string represents the core API group.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Group string `json:"group,omitempty" protobuf:"bytes,1,opt,name=group"`
0000000000000000000000000000000000000000;;		// Resources is a list of resources within the API group.
0000000000000000000000000000000000000000;;		// Any empty list implies every resource kind in the API group.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resources []string `json:"resources,omitempty" protobuf:"bytes,2,rep,name=resources"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectReference contains enough information to let you inspect or modify the referred object.
0000000000000000000000000000000000000000;;	type ObjectReference struct {
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resource string `json:"resource,omitempty" protobuf:"bytes,1,opt,name=resource"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespace string `json:"namespace,omitempty" protobuf:"bytes,2,opt,name=namespace"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,3,opt,name=name"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID types.UID `json:"uid,omitempty" protobuf:"bytes,4,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIVersion string `json:"apiVersion,omitempty" protobuf:"bytes,5,opt,name=apiVersion"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Subresource string `json:"subresource,omitempty" protobuf:"bytes,7,opt,name=subresource"`
0000000000000000000000000000000000000000;;	}
