0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
bed262fc88165928f843276fce085c6ee57d7300;pkg/apiserver/proxy.go[pkg/apiserver/proxy.go][staging/src/k8s.io/apiserver/pkg/endpoints/handlers/proxy.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package handlers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		proxyutil "k8s.io/apimachinery/pkg/util/proxy"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/metrics"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/httplog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyHandler provides a http.Handler which will proxy traffic to locations
0000000000000000000000000000000000000000;;	// specified by items implementing Redirector.
0000000000000000000000000000000000000000;;	type ProxyHandler struct {
0000000000000000000000000000000000000000;;		Prefix     string
0000000000000000000000000000000000000000;;		Storage    map[string]rest.Storage
0000000000000000000000000000000000000000;;		Serializer runtime.NegotiatedSerializer
0000000000000000000000000000000000000000;;		Mapper     request.RequestContextMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ProxyHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		proxyHandlerTraceID := rand.Int63()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var verb string
0000000000000000000000000000000000000000;;		var apiResource, subresource string
0000000000000000000000000000000000000000;;		var httpCode int
0000000000000000000000000000000000000000;;		reqStart := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.Monitor(
0000000000000000000000000000000000000000;;				verb, apiResource, subresource,
0000000000000000000000000000000000000000;;				net.GetHTTPClient(req),
0000000000000000000000000000000000000000;;				w.Header().Get("Content-Type"),
0000000000000000000000000000000000000000;;				httpCode, reqStart,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, ok := r.Mapper.Get(req)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			responsewriters.InternalError(w, req, errors.New("Error getting request context"))
0000000000000000000000000000000000000000;;			httpCode = http.StatusInternalServerError
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			responsewriters.InternalError(w, req, errors.New("Error getting RequestInfo from context"))
0000000000000000000000000000000000000000;;			httpCode = http.StatusInternalServerError
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !requestInfo.IsResourceRequest {
0000000000000000000000000000000000000000;;			responsewriters.NotFound(w, req)
0000000000000000000000000000000000000000;;			httpCode = http.StatusNotFound
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		verb = requestInfo.Verb
0000000000000000000000000000000000000000;;		namespace, resource, subresource, parts := requestInfo.Namespace, requestInfo.Resource, requestInfo.Subresource, requestInfo.Parts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;		if len(parts) < 2 {
0000000000000000000000000000000000000000;;			responsewriters.NotFound(w, req)
0000000000000000000000000000000000000000;;			httpCode = http.StatusNotFound
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id := parts[1]
0000000000000000000000000000000000000000;;		remainder := ""
0000000000000000000000000000000000000000;;		if len(parts) > 2 {
0000000000000000000000000000000000000000;;			proxyParts := parts[2:]
0000000000000000000000000000000000000000;;			remainder = strings.Join(proxyParts, "/")
0000000000000000000000000000000000000000;;			if strings.HasSuffix(req.URL.Path, "/") {
0000000000000000000000000000000000000000;;				// The original path had a trailing slash, which has been stripped
0000000000000000000000000000000000000000;;				// by KindAndNamespace(). We should add it back because some
0000000000000000000000000000000000000000;;				// servers (like etcd) require it.
0000000000000000000000000000000000000000;;				remainder = remainder + "/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage, ok := r.Storage[resource]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			httplog.LogOf(req, w).Addf("'%v' has no storage object", resource)
0000000000000000000000000000000000000000;;			responsewriters.NotFound(w, req)
0000000000000000000000000000000000000000;;			httpCode = http.StatusNotFound
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiResource = resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gv := schema.GroupVersion{Group: requestInfo.APIGroup, Version: requestInfo.APIVersion}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		redirector, ok := storage.(rest.Redirector)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			httplog.LogOf(req, w).Addf("'%v' is not a redirector", resource)
0000000000000000000000000000000000000000;;			httpCode = responsewriters.ErrorNegotiated(ctx, apierrors.NewMethodNotSupported(schema.GroupResource{Resource: resource}, "proxy"), r.Serializer, gv, w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		location, roundTripper, err := redirector.ResourceLocation(ctx, id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			httplog.LogOf(req, w).Addf("Error getting ResourceLocation: %v", err)
0000000000000000000000000000000000000000;;			httpCode = responsewriters.ErrorNegotiated(ctx, err, r.Serializer, gv, w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if location == nil {
0000000000000000000000000000000000000000;;			httplog.LogOf(req, w).Addf("ResourceLocation for %v returned nil", id)
0000000000000000000000000000000000000000;;			responsewriters.NotFound(w, req)
0000000000000000000000000000000000000000;;			httpCode = http.StatusNotFound
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if roundTripper != nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("[%x: %v] using transport %T...", proxyHandlerTraceID, req.URL, roundTripper)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default to http
0000000000000000000000000000000000000000;;		if location.Scheme == "" {
0000000000000000000000000000000000000000;;			location.Scheme = "http"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add the subpath
0000000000000000000000000000000000000000;;		if len(remainder) > 0 {
0000000000000000000000000000000000000000;;			location.Path = singleJoiningSlash(location.Path, remainder)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Start with anything returned from the storage, and add the original request's parameters
0000000000000000000000000000000000000000;;		values := location.Query()
0000000000000000000000000000000000000000;;		for k, vs := range req.URL.Query() {
0000000000000000000000000000000000000000;;			for _, v := range vs {
0000000000000000000000000000000000000000;;				values.Add(k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		location.RawQuery = values.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WithContext creates a shallow clone of the request with the new context.
0000000000000000000000000000000000000000;;		newReq := req.WithContext(context.Background())
0000000000000000000000000000000000000000;;		newReq.Header = net.CloneHeader(req.Header)
0000000000000000000000000000000000000000;;		newReq.URL = location
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO convert this entire proxy to an UpgradeAwareProxy similar to
0000000000000000000000000000000000000000;;		// https://github.com/openshift/origin/blob/master/pkg/util/httpproxy/upgradeawareproxy.go.
0000000000000000000000000000000000000000;;		// That proxy needs to be modified to support multiple backends, not just 1.
0000000000000000000000000000000000000000;;		if r.tryUpgrade(ctx, w, req, newReq, location, roundTripper, gv) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Redirect requests of the form "/{resource}/{name}" to "/{resource}/{name}/"
0000000000000000000000000000000000000000;;		// This is essentially a hack for http://issue.k8s.io/4958.
0000000000000000000000000000000000000000;;		// Note: Keep this code after tryUpgrade to not break that flow.
0000000000000000000000000000000000000000;;		if len(parts) == 2 && !strings.HasSuffix(req.URL.Path, "/") {
0000000000000000000000000000000000000000;;			var queryPart string
0000000000000000000000000000000000000000;;			if len(req.URL.RawQuery) > 0 {
0000000000000000000000000000000000000000;;				queryPart = "?" + req.URL.RawQuery
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Location", req.URL.Path+"/"+queryPart)
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusMovedPermanently)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		glog.V(4).Infof("[%x] Beginning proxy %s...", proxyHandlerTraceID, req.URL)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("[%x] Proxy %v finished %v.", proxyHandlerTraceID, req.URL, time.Now().Sub(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy := httputil.NewSingleHostReverseProxy(&url.URL{Scheme: location.Scheme, Host: location.Host})
0000000000000000000000000000000000000000;;		alreadyRewriting := false
0000000000000000000000000000000000000000;;		if roundTripper != nil {
0000000000000000000000000000000000000000;;			_, alreadyRewriting = roundTripper.(*proxyutil.Transport)
0000000000000000000000000000000000000000;;			glog.V(5).Infof("[%x] Not making a rewriting transport for proxy %s...", proxyHandlerTraceID, req.URL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !alreadyRewriting {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("[%x] making a transport for proxy %s...", proxyHandlerTraceID, req.URL)
0000000000000000000000000000000000000000;;			prepend := path.Join(r.Prefix, resource, id)
0000000000000000000000000000000000000000;;			if len(namespace) > 0 {
0000000000000000000000000000000000000000;;				prepend = path.Join(r.Prefix, "namespaces", namespace, resource, id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pTransport := &proxyutil.Transport{
0000000000000000000000000000000000000000;;				Scheme:       req.URL.Scheme,
0000000000000000000000000000000000000000;;				Host:         req.URL.Host,
0000000000000000000000000000000000000000;;				PathPrepend:  prepend,
0000000000000000000000000000000000000000;;				RoundTripper: roundTripper,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			roundTripper = pTransport
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxy.Transport = roundTripper
0000000000000000000000000000000000000000;;		proxy.FlushInterval = 200 * time.Millisecond
0000000000000000000000000000000000000000;;		proxy.ServeHTTP(w, newReq)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryUpgrade returns true if the request was handled.
0000000000000000000000000000000000000000;;	func (r *ProxyHandler) tryUpgrade(ctx request.Context, w http.ResponseWriter, req, newReq *http.Request, location *url.URL, transport http.RoundTripper, gv schema.GroupVersion) bool {
0000000000000000000000000000000000000000;;		if !httpstream.IsUpgradeRequest(req) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only append X-Forwarded-For in the upgrade path, since httputil.NewSingleHostReverseProxy
0000000000000000000000000000000000000000;;		// handles this in the non-upgrade path.
0000000000000000000000000000000000000000;;		net.AppendForwardedForHeader(newReq)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backendConn, err := proxyutil.DialURL(location, transport)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			responsewriters.ErrorNegotiated(ctx, err, r.Serializer, gv, w, req)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer backendConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO should we use _ (a bufio.ReadWriter) instead of requestHijackedConn
0000000000000000000000000000000000000000;;		// when copying between the client and the backend? Docker doesn't when they
0000000000000000000000000000000000000000;;		// hijack, just for reference...
0000000000000000000000000000000000000000;;		requestHijackedConn, _, err := w.(http.Hijacker).Hijack()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			responsewriters.ErrorNegotiated(ctx, err, r.Serializer, gv, w, req)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer requestHijackedConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = newReq.Write(backendConn); err != nil {
0000000000000000000000000000000000000000;;			responsewriters.ErrorNegotiated(ctx, err, r.Serializer, gv, w, req)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := make(chan struct{}, 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			_, err := io.Copy(backendConn, requestHijackedConn)
0000000000000000000000000000000000000000;;			if err != nil && !strings.Contains(err.Error(), "use of closed network connection") {
0000000000000000000000000000000000000000;;				glog.Errorf("Error proxying data from client to backend: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			done <- struct{}{}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			_, err := io.Copy(requestHijackedConn, backendConn)
0000000000000000000000000000000000000000;;			if err != nil && !strings.Contains(err.Error(), "use of closed network connection") {
0000000000000000000000000000000000000000;;				glog.Errorf("Error proxying data from backend to client: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			done <- struct{}{}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-done
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// borrowed from net/http/httputil/reverseproxy.go
0000000000000000000000000000000000000000;;	func singleJoiningSlash(a, b string) string {
0000000000000000000000000000000000000000;;		aslash := strings.HasSuffix(a, "/")
0000000000000000000000000000000000000000;;		bslash := strings.HasPrefix(b, "/")
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case aslash && bslash:
0000000000000000000000000000000000000000;;			return a + b[1:]
0000000000000000000000000000000000000000;;		case !aslash && !bslash:
0000000000000000000000000000000000000000;;			return a + "/" + b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a + b
0000000000000000000000000000000000000000;;	}
