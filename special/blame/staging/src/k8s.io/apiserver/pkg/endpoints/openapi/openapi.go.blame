0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0592e6d18450c84c496f528a5201134c60966d1d;pkg/apiserver/openapi/openapi.go[pkg/apiserver/openapi/openapi.go][staging/src/k8s.io/apiserver/pkg/endpoints/openapi/openapi.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful "github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/trie"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var verbs = trie.New([]string{"get", "log", "read", "replace", "patch", "delete", "deletecollection", "watch", "connect", "proxy", "list", "create", "patch"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		extensionGVK = "x-kubernetes-group-version-kind"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToValidOperationID makes an string a valid op ID (e.g. removing punctuations and whitespaces and make it camel case)
0000000000000000000000000000000000000000;;	func ToValidOperationID(s string, capitalizeFirstLetter bool) string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		capitalize := capitalizeFirstLetter
0000000000000000000000000000000000000000;;		for i, r := range s {
0000000000000000000000000000000000000000;;			if unicode.IsLetter(r) || r == '_' || (i != 0 && unicode.IsDigit(r)) {
0000000000000000000000000000000000000000;;				if capitalize {
0000000000000000000000000000000000000000;;					buffer.WriteRune(unicode.ToUpper(r))
0000000000000000000000000000000000000000;;					capitalize = false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					buffer.WriteRune(r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				capitalize = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetOperationIDAndTags returns a customize operation ID and a list of tags for kubernetes API server's OpenAPI spec to prevent duplicate IDs.
0000000000000000000000000000000000000000;;	func GetOperationIDAndTags(r *restful.Route) (string, []string, error) {
0000000000000000000000000000000000000000;;		op := r.Operation
0000000000000000000000000000000000000000;;		path := r.Path
0000000000000000000000000000000000000000;;		var tags []string
0000000000000000000000000000000000000000;;		// TODO: This is hacky, figure out where this name conflict is created and fix it at the root.
0000000000000000000000000000000000000000;;		if strings.HasPrefix(path, "/apis/extensions/v1beta1/namespaces/{namespace}/") && strings.HasSuffix(op, "ScaleScale") {
0000000000000000000000000000000000000000;;			op = op[:len(op)-10] + strings.Title(strings.Split(path[48:], "/")[0]) + "Scale"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prefix, exists := verbs.GetPrefix(op)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return op, tags, fmt.Errorf("operation names should start with a verb. Cannot determine operation verb from %v", op)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		op = op[len(prefix):]
0000000000000000000000000000000000000000;;		parts := strings.Split(strings.Trim(path, "/"), "/")
0000000000000000000000000000000000000000;;		// Assume /api is /apis/core, remove this when we actually server /api/... on /apis/core/...
0000000000000000000000000000000000000000;;		if len(parts) >= 1 && parts[0] == "api" {
0000000000000000000000000000000000000000;;			parts = append([]string{"apis", "core"}, parts[1:]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(parts) >= 2 && parts[0] == "apis" {
0000000000000000000000000000000000000000;;			trimmed := strings.TrimSuffix(parts[1], ".k8s.io")
0000000000000000000000000000000000000000;;			prefix = prefix + ToValidOperationID(trimmed, prefix != "")
0000000000000000000000000000000000000000;;			tag := ToValidOperationID(trimmed, false)
0000000000000000000000000000000000000000;;			if len(parts) > 2 {
0000000000000000000000000000000000000000;;				prefix = prefix + ToValidOperationID(parts[2], prefix != "")
0000000000000000000000000000000000000000;;				tag = tag + "_" + ToValidOperationID(parts[2], false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tags = append(tags, tag)
0000000000000000000000000000000000000000;;		} else if len(parts) >= 1 {
0000000000000000000000000000000000000000;;			tags = append(tags, ToValidOperationID(parts[0], false))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return prefix + ToValidOperationID(op, prefix != ""), tags, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type groupVersionKinds []v1.GroupVersionKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s groupVersionKinds) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s groupVersionKinds) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s groupVersionKinds) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if s[i].Group == s[j].Group {
0000000000000000000000000000000000000000;;			if s[i].Version == s[j].Version {
0000000000000000000000000000000000000000;;				return s[i].Kind < s[j].Kind
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s[i].Version < s[j].Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s[i].Group < s[j].Group
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefinitionNamer is the type to customize OpenAPI definition name.
0000000000000000000000000000000000000000;;	type DefinitionNamer struct {
0000000000000000000000000000000000000000;;		typeGroupVersionKinds map[string]groupVersionKinds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gvkConvert(gvk schema.GroupVersionKind) v1.GroupVersionKind {
0000000000000000000000000000000000000000;;		return v1.GroupVersionKind{
0000000000000000000000000000000000000000;;			Group:   gvk.Group,
0000000000000000000000000000000000000000;;			Version: gvk.Version,
0000000000000000000000000000000000000000;;			Kind:    gvk.Kind,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func friendlyName(name string) string {
0000000000000000000000000000000000000000;;		nameParts := strings.Split(name, "/")
0000000000000000000000000000000000000000;;		// Reverse first part. e.g., io.k8s... instead of k8s.io...
0000000000000000000000000000000000000000;;		if len(nameParts) > 0 && strings.Contains(nameParts[0], ".") {
0000000000000000000000000000000000000000;;			parts := strings.Split(nameParts[0], ".")
0000000000000000000000000000000000000000;;			for i, j := 0, len(parts)-1; i < j; i, j = i+1, j-1 {
0000000000000000000000000000000000000000;;				parts[i], parts[j] = parts[j], parts[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nameParts[0] = strings.Join(parts, ".")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(nameParts, ".")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func typeName(t reflect.Type) string {
0000000000000000000000000000000000000000;;		path := t.PkgPath()
0000000000000000000000000000000000000000;;		if strings.Contains(path, "/vendor/") {
0000000000000000000000000000000000000000;;			path = path[strings.Index(path, "/vendor/")+len("/vendor/"):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s.%s", path, t.Name())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefinitionNamer constructs a new DefinitionNamer to be used to customize OpenAPI spec.
0000000000000000000000000000000000000000;;	func NewDefinitionNamer(s *runtime.Scheme) DefinitionNamer {
0000000000000000000000000000000000000000;;		ret := DefinitionNamer{
0000000000000000000000000000000000000000;;			typeGroupVersionKinds: map[string]groupVersionKinds{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for gvk, rtype := range s.AllKnownTypes() {
0000000000000000000000000000000000000000;;			ret.typeGroupVersionKinds[typeName(rtype)] = append(ret.typeGroupVersionKinds[typeName(rtype)], gvkConvert(gvk))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, gvk := range ret.typeGroupVersionKinds {
0000000000000000000000000000000000000000;;			sort.Sort(gvk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDefinitionName returns the name and tags for a given definition
0000000000000000000000000000000000000000;;	func (d *DefinitionNamer) GetDefinitionName(name string) (string, spec.Extensions) {
0000000000000000000000000000000000000000;;		if groupVersionKinds, ok := d.typeGroupVersionKinds[name]; ok {
0000000000000000000000000000000000000000;;			return friendlyName(name), spec.Extensions{
0000000000000000000000000000000000000000;;				extensionGVK: []v1.GroupVersionKind(groupVersionKinds),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return friendlyName(name), nil
0000000000000000000000000000000000000000;;	}
