0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
4758c092ffc994084db024935ddb1a284f3be5c5;pkg/apiserver/negotiate.go[pkg/apiserver/negotiate.go][staging/src/k8s.io/apiserver/pkg/endpoints/handlers/negotiation/negotiate.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package negotiation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"bitbucket.org/ww/goautoneg"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MediaTypesForSerializer returns a list of media and stream media types for the server.
0000000000000000000000000000000000000000;;	func MediaTypesForSerializer(ns runtime.NegotiatedSerializer) (mediaTypes, streamMediaTypes []string) {
0000000000000000000000000000000000000000;;		for _, info := range ns.SupportedMediaTypes() {
0000000000000000000000000000000000000000;;			mediaTypes = append(mediaTypes, info.MediaType)
0000000000000000000000000000000000000000;;			if info.StreamSerializer != nil {
0000000000000000000000000000000000000000;;				// stream=watch is the existing mime-type parameter for watch
0000000000000000000000000000000000000000;;				streamMediaTypes = append(streamMediaTypes, info.MediaType+";stream=watch")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mediaTypes, streamMediaTypes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NegotiateOutputMediaType(req *http.Request, ns runtime.NegotiatedSerializer, restrictions EndpointRestrictions) (MediaTypeOptions, runtime.SerializerInfo, error) {
0000000000000000000000000000000000000000;;		mediaType, ok := NegotiateMediaTypeOptions(req.Header.Get("Accept"), AcceptedMediaTypesForEndpoint(ns), restrictions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			supported, _ := MediaTypesForSerializer(ns)
0000000000000000000000000000000000000000;;			return mediaType, runtime.SerializerInfo{}, NewNotAcceptableError(supported)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: move into resthandler
0000000000000000000000000000000000000000;;		info := mediaType.Accepted.Serializer
0000000000000000000000000000000000000000;;		if (mediaType.Pretty || isPrettyPrint(req)) && info.PrettySerializer != nil {
0000000000000000000000000000000000000000;;			info.Serializer = info.PrettySerializer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mediaType, info, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NegotiateOutputSerializer(req *http.Request, ns runtime.NegotiatedSerializer) (runtime.SerializerInfo, error) {
0000000000000000000000000000000000000000;;		_, info, err := NegotiateOutputMediaType(req, ns, DefaultEndpointRestrictions)
0000000000000000000000000000000000000000;;		return info, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NegotiateOutputStreamSerializer(req *http.Request, ns runtime.NegotiatedSerializer) (runtime.SerializerInfo, error) {
0000000000000000000000000000000000000000;;		mediaType, ok := NegotiateMediaTypeOptions(req.Header.Get("Accept"), AcceptedMediaTypesForEndpoint(ns), DefaultEndpointRestrictions)
0000000000000000000000000000000000000000;;		if !ok || mediaType.Accepted.Serializer.StreamSerializer == nil {
0000000000000000000000000000000000000000;;			_, supported := MediaTypesForSerializer(ns)
0000000000000000000000000000000000000000;;			return runtime.SerializerInfo{}, NewNotAcceptableError(supported)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mediaType.Accepted.Serializer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NegotiateInputSerializer(req *http.Request, ns runtime.NegotiatedSerializer) (runtime.SerializerInfo, error) {
0000000000000000000000000000000000000000;;		mediaTypes := ns.SupportedMediaTypes()
0000000000000000000000000000000000000000;;		mediaType := req.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;		if len(mediaType) == 0 {
0000000000000000000000000000000000000000;;			mediaType = mediaTypes[0].MediaType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mediaType, _, err := mime.ParseMediaType(mediaType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			_, supported := MediaTypesForSerializer(ns)
0000000000000000000000000000000000000000;;			return runtime.SerializerInfo{}, NewUnsupportedMediaTypeError(supported)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, info := range mediaTypes {
0000000000000000000000000000000000000000;;			if info.MediaType != mediaType {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return info, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, supported := MediaTypesForSerializer(ns)
0000000000000000000000000000000000000000;;		return runtime.SerializerInfo{}, NewUnsupportedMediaTypeError(supported)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPrettyPrint returns true if the "pretty" query parameter is true or if the User-Agent
0000000000000000000000000000000000000000;;	// matches known "human" clients.
0000000000000000000000000000000000000000;;	func isPrettyPrint(req *http.Request) bool {
0000000000000000000000000000000000000000;;		// DEPRECATED: should be part of the content type
0000000000000000000000000000000000000000;;		if req.URL != nil {
0000000000000000000000000000000000000000;;			pp := req.URL.Query().Get("pretty")
0000000000000000000000000000000000000000;;			if len(pp) > 0 {
0000000000000000000000000000000000000000;;				pretty, _ := strconv.ParseBool(pp)
0000000000000000000000000000000000000000;;				return pretty
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		userAgent := req.UserAgent()
0000000000000000000000000000000000000000;;		// This covers basic all browers and cli http tools
0000000000000000000000000000000000000000;;		if strings.HasPrefix(userAgent, "curl") || strings.HasPrefix(userAgent, "Wget") || strings.HasPrefix(userAgent, "Mozilla/5.0") {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// negotiate the most appropriate content type given the accept header and a list of
0000000000000000000000000000000000000000;;	// alternatives.
0000000000000000000000000000000000000000;;	func negotiate(header string, alternatives []string) (goautoneg.Accept, bool) {
0000000000000000000000000000000000000000;;		alternates := make([][]string, 0, len(alternatives))
0000000000000000000000000000000000000000;;		for _, alternate := range alternatives {
0000000000000000000000000000000000000000;;			alternates = append(alternates, strings.SplitN(alternate, "/", 2))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, clause := range goautoneg.ParseAccept(header) {
0000000000000000000000000000000000000000;;			for _, alternate := range alternates {
0000000000000000000000000000000000000000;;				if clause.Type == alternate[0] && clause.SubType == alternate[1] {
0000000000000000000000000000000000000000;;					return clause, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if clause.Type == alternate[0] && clause.SubType == "*" {
0000000000000000000000000000000000000000;;					clause.SubType = alternate[1]
0000000000000000000000000000000000000000;;					return clause, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if clause.Type == "*" && clause.SubType == "*" {
0000000000000000000000000000000000000000;;					clause.Type = alternate[0]
0000000000000000000000000000000000000000;;					clause.SubType = alternate[1]
0000000000000000000000000000000000000000;;					return clause, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return goautoneg.Accept{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointRestrictions is an interface that allows content-type negotiation
0000000000000000000000000000000000000000;;	// to verify server support for specific options
0000000000000000000000000000000000000000;;	type EndpointRestrictions interface {
0000000000000000000000000000000000000000;;		// AllowsConversion should return true if the specified group version kind
0000000000000000000000000000000000000000;;		// is an allowed target object.
0000000000000000000000000000000000000000;;		AllowsConversion(schema.GroupVersionKind) bool
0000000000000000000000000000000000000000;;		// AllowsServerVersion should return true if the specified version is valid
0000000000000000000000000000000000000000;;		// for the server group.
0000000000000000000000000000000000000000;;		AllowsServerVersion(version string) bool
0000000000000000000000000000000000000000;;		// AllowsStreamSchema should return true if the specified stream schema is
0000000000000000000000000000000000000000;;		// valid for the server group.
0000000000000000000000000000000000000000;;		AllowsStreamSchema(schema string) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DefaultEndpointRestrictions = emptyEndpointRestrictions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type emptyEndpointRestrictions struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (emptyEndpointRestrictions) AllowsConversion(schema.GroupVersionKind) bool { return false }
0000000000000000000000000000000000000000;;	func (emptyEndpointRestrictions) AllowsServerVersion(string) bool               { return false }
0000000000000000000000000000000000000000;;	func (emptyEndpointRestrictions) AllowsStreamSchema(s string) bool              { return s == "watch" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AcceptedMediaType contains information about a valid media type that the
0000000000000000000000000000000000000000;;	// server can serialize.
0000000000000000000000000000000000000000;;	type AcceptedMediaType struct {
0000000000000000000000000000000000000000;;		// Type is the first part of the media type ("application")
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;		// SubType is the second part of the media type ("json")
0000000000000000000000000000000000000000;;		SubType string
0000000000000000000000000000000000000000;;		// Serializer is the serialization info this object accepts
0000000000000000000000000000000000000000;;		Serializer runtime.SerializerInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MediaTypeOptions describes information for a given media type that may alter
0000000000000000000000000000000000000000;;	// the server response
0000000000000000000000000000000000000000;;	type MediaTypeOptions struct {
0000000000000000000000000000000000000000;;		// pretty is true if the requested representation should be formatted for human
0000000000000000000000000000000000000000;;		// viewing
0000000000000000000000000000000000000000;;		Pretty bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stream, if set, indicates that a streaming protocol variant of this encoding
0000000000000000000000000000000000000000;;		// is desired. The only currently supported value is watch which returns versioned
0000000000000000000000000000000000000000;;		// events. In the future, this may refer to other stream protocols.
0000000000000000000000000000000000000000;;		Stream string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// convert is a request to alter the type of object returned by the server from the
0000000000000000000000000000000000000000;;		// normal response
0000000000000000000000000000000000000000;;		Convert *schema.GroupVersionKind
0000000000000000000000000000000000000000;;		// useServerVersion is an optional version for the server group
0000000000000000000000000000000000000000;;		UseServerVersion string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// export is true if the representation requested should exclude fields the server
0000000000000000000000000000000000000000;;		// has set
0000000000000000000000000000000000000000;;		Export bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unrecognized is a list of all unrecognized keys
0000000000000000000000000000000000000000;;		Unrecognized []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the accepted media type from the client
0000000000000000000000000000000000000000;;		Accepted *AcceptedMediaType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// acceptMediaTypeOptions returns an options object that matches the provided media type params. If
0000000000000000000000000000000000000000;;	// it returns false, the provided options are not allowed and the media type must be skipped.  These
0000000000000000000000000000000000000000;;	// parameters are unversioned and may not be changed.
0000000000000000000000000000000000000000;;	func acceptMediaTypeOptions(params map[string]string, accepts *AcceptedMediaType, endpoint EndpointRestrictions) (MediaTypeOptions, bool) {
0000000000000000000000000000000000000000;;		var options MediaTypeOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// extract all known parameters
0000000000000000000000000000000000000000;;		for k, v := range params {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// controls transformation of the object when returned
0000000000000000000000000000000000000000;;			case "as":
0000000000000000000000000000000000000000;;				if options.Convert == nil {
0000000000000000000000000000000000000000;;					options.Convert = &schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				options.Convert.Kind = v
0000000000000000000000000000000000000000;;			case "g":
0000000000000000000000000000000000000000;;				if options.Convert == nil {
0000000000000000000000000000000000000000;;					options.Convert = &schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				options.Convert.Group = v
0000000000000000000000000000000000000000;;			case "v":
0000000000000000000000000000000000000000;;				if options.Convert == nil {
0000000000000000000000000000000000000000;;					options.Convert = &schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				options.Convert.Version = v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// controls the streaming schema
0000000000000000000000000000000000000000;;			case "stream":
0000000000000000000000000000000000000000;;				if len(v) > 0 && (accepts.Serializer.StreamSerializer == nil || !endpoint.AllowsStreamSchema(v)) {
0000000000000000000000000000000000000000;;					return MediaTypeOptions{}, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				options.Stream = v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// controls the version of the server API group used
0000000000000000000000000000000000000000;;			// for generic output
0000000000000000000000000000000000000000;;			case "sv":
0000000000000000000000000000000000000000;;				if len(v) > 0 && !endpoint.AllowsServerVersion(v) {
0000000000000000000000000000000000000000;;					return MediaTypeOptions{}, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				options.UseServerVersion = v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if specified, the server should transform the returned
0000000000000000000000000000000000000000;;			// output and remove fields that are always server specified,
0000000000000000000000000000000000000000;;			// or which fit the default behavior.
0000000000000000000000000000000000000000;;			case "export":
0000000000000000000000000000000000000000;;				options.Export = v == "1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if specified, the pretty serializer will be used
0000000000000000000000000000000000000000;;			case "pretty":
0000000000000000000000000000000000000000;;				options.Pretty = v == "1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				options.Unrecognized = append(options.Unrecognized, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.Convert != nil && !endpoint.AllowsConversion(*options.Convert) {
0000000000000000000000000000000000000000;;			return MediaTypeOptions{}, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options.Accepted = accepts
0000000000000000000000000000000000000000;;		return options, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NegotiateMediaTypeOptions returns the most appropriate content type given the accept header and
0000000000000000000000000000000000000000;;	// a list of alternatives along with the accepted media type parameters.
0000000000000000000000000000000000000000;;	func NegotiateMediaTypeOptions(header string, accepted []AcceptedMediaType, endpoint EndpointRestrictions) (MediaTypeOptions, bool) {
0000000000000000000000000000000000000000;;		if len(header) == 0 && len(accepted) > 0 {
0000000000000000000000000000000000000000;;			return MediaTypeOptions{
0000000000000000000000000000000000000000;;				Accepted: &accepted[0],
0000000000000000000000000000000000000000;;			}, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clauses := goautoneg.ParseAccept(header)
0000000000000000000000000000000000000000;;		for _, clause := range clauses {
0000000000000000000000000000000000000000;;			for i := range accepted {
0000000000000000000000000000000000000000;;				accepts := &accepted[i]
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case clause.Type == accepts.Type && clause.SubType == accepts.SubType,
0000000000000000000000000000000000000000;;					clause.Type == accepts.Type && clause.SubType == "*",
0000000000000000000000000000000000000000;;					clause.Type == "*" && clause.SubType == "*":
0000000000000000000000000000000000000000;;					// TODO: should we prefer the first type with no unrecognized options?  Do we need to ignore unrecognized
0000000000000000000000000000000000000000;;					// parameters.
0000000000000000000000000000000000000000;;					return acceptMediaTypeOptions(clause.Params, accepts, endpoint)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return MediaTypeOptions{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AcceptedMediaTypesForEndpoint returns an array of structs that are used to efficiently check which
0000000000000000000000000000000000000000;;	// allowed media types the server exposes.
0000000000000000000000000000000000000000;;	func AcceptedMediaTypesForEndpoint(ns runtime.NegotiatedSerializer) []AcceptedMediaType {
0000000000000000000000000000000000000000;;		var acceptedMediaTypes []AcceptedMediaType
0000000000000000000000000000000000000000;;		for _, info := range ns.SupportedMediaTypes() {
0000000000000000000000000000000000000000;;			segments := strings.SplitN(info.MediaType, "/", 2)
0000000000000000000000000000000000000000;;			if len(segments) == 1 {
0000000000000000000000000000000000000000;;				segments = append(segments, "*")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t := AcceptedMediaType{
0000000000000000000000000000000000000000;;				Type:       segments[0],
0000000000000000000000000000000000000000;;				SubType:    segments[1],
0000000000000000000000000000000000000000;;				Serializer: info,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			acceptedMediaTypes = append(acceptedMediaTypes, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return acceptedMediaTypes
0000000000000000000000000000000000000000;;	}
