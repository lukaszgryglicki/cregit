0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
e428f2e7a6c6c7214567e4b04df4b5c98a6ae7fc;pkg/api/requestcontext.go[pkg/api/requestcontext.go][staging/src/k8s.io/apiserver/pkg/endpoints/request/requestcontext.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LongRunningRequestCheck is a predicate which is true for long-running http requests.
0000000000000000000000000000000000000000;;	type LongRunningRequestCheck func(r *http.Request, requestInfo *RequestInfo) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestContextMapper keeps track of the context associated with a particular request
0000000000000000000000000000000000000000;;	type RequestContextMapper interface {
0000000000000000000000000000000000000000;;		// Get returns the context associated with the given request (if any), and true if the request has an associated context, and false if it does not.
0000000000000000000000000000000000000000;;		Get(req *http.Request) (Context, bool)
0000000000000000000000000000000000000000;;		// Update maps the request to the given context. If no context was previously associated with the request, an error is returned.
0000000000000000000000000000000000000000;;		// Update should only be called with a descendant context of the previously associated context.
0000000000000000000000000000000000000000;;		// Updating to an unrelated context may return an error in the future.
0000000000000000000000000000000000000000;;		// The context associated with a request should only be updated by a limited set of callers.
0000000000000000000000000000000000000000;;		// Valid examples include the authentication layer, or an audit/tracing layer.
0000000000000000000000000000000000000000;;		Update(req *http.Request, context Context) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type requestContextMap struct {
0000000000000000000000000000000000000000;;		contexts map[*http.Request]Context
0000000000000000000000000000000000000000;;		lock     sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRequestContextMapper returns a new RequestContextMapper.
0000000000000000000000000000000000000000;;	// The returned mapper must be added as a request filter using NewRequestContextFilter.
0000000000000000000000000000000000000000;;	func NewRequestContextMapper() RequestContextMapper {
0000000000000000000000000000000000000000;;		return &requestContextMap{
0000000000000000000000000000000000000000;;			contexts: make(map[*http.Request]Context),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the context associated with the given request (if any), and true if the request has an associated context, and false if it does not.
0000000000000000000000000000000000000000;;	// Get will only return a valid context when called from inside the filter chain set up by NewRequestContextFilter()
0000000000000000000000000000000000000000;;	func (c *requestContextMap) Get(req *http.Request) (Context, bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		context, ok := c.contexts[req]
0000000000000000000000000000000000000000;;		return context, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update maps the request to the given context.
0000000000000000000000000000000000000000;;	// If no context was previously associated with the request, an error is returned and the context is ignored.
0000000000000000000000000000000000000000;;	func (c *requestContextMap) Update(req *http.Request, context Context) error {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		if _, ok := c.contexts[req]; !ok {
0000000000000000000000000000000000000000;;			return errors.New("No context associated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: ensure the new context is a descendant of the existing one
0000000000000000000000000000000000000000;;		c.contexts[req] = context
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init maps the request to the given context and returns true if there was no context associated with the request already.
0000000000000000000000000000000000000000;;	// if a context was already associated with the request, it ignores the given context and returns false.
0000000000000000000000000000000000000000;;	// init is intentionally unexported to ensure that all init calls are paired with a remove after a request is handled
0000000000000000000000000000000000000000;;	func (c *requestContextMap) init(req *http.Request, context Context) bool {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		if _, exists := c.contexts[req]; exists {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.contexts[req] = context
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remove is intentionally unexported to ensure that the context is not removed until a request is handled
0000000000000000000000000000000000000000;;	func (c *requestContextMap) remove(req *http.Request) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		delete(c.contexts, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithRequestContext ensures there is a Context object associated with the request before calling the passed handler.
0000000000000000000000000000000000000000;;	// After the passed handler runs, the context is cleaned up.
0000000000000000000000000000000000000000;;	func WithRequestContext(handler http.Handler, mapper RequestContextMapper) http.Handler {
0000000000000000000000000000000000000000;;		rcMap, ok := mapper.(*requestContextMap)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Fatal("Unknown RequestContextMapper implementation.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			if rcMap.init(req, NewContext()) {
0000000000000000000000000000000000000000;;				// If we were the ones to successfully initialize, pair with a remove
0000000000000000000000000000000000000000;;				defer rcMap.remove(req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if there are no contexts registered, or an error if it could not be determined. Intended for use by tests.
0000000000000000000000000000000000000000;;	func IsEmpty(requestsToContexts RequestContextMapper) (bool, error) {
0000000000000000000000000000000000000000;;		if requestsToContexts, ok := requestsToContexts.(*requestContextMap); ok {
0000000000000000000000000000000000000000;;			return len(requestsToContexts.contexts) == 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, errors.New("Unknown RequestContextMapper implementation")
0000000000000000000000000000000000000000;;	}
