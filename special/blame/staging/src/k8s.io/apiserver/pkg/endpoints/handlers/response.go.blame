0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f796bba9076deebf7d76f8c3cd7b806a11d01fe8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package handlers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		metav1alpha1 "k8s.io/apimachinery/pkg/apis/meta/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/negotiation"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transformResponseObject takes an object loaded from storage and performs any necessary transformations.
0000000000000000000000000000000000000000;;	// Will write the complete response object.
0000000000000000000000000000000000000000;;	func transformResponseObject(ctx request.Context, scope RequestScope, req *http.Request, w http.ResponseWriter, statusCode int, result runtime.Object) {
0000000000000000000000000000000000000000;;		// TODO: fetch the media type much earlier in request processing and pass it into this method.
0000000000000000000000000000000000000000;;		mediaType, _, err := negotiation.NegotiateOutputMediaType(req, scope.Serializer, &scope)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			status := responsewriters.ErrorToAPIStatus(err)
0000000000000000000000000000000000000000;;			responsewriters.WriteRawJSON(int(status.Code), status, w)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If conversion was allowed by the scope, perform it before writing the response
0000000000000000000000000000000000000000;;		if target := mediaType.Convert; target != nil {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case target.Kind == "PartialObjectMetadata" && target.GroupVersion() == metav1alpha1.SchemeGroupVersion:
0000000000000000000000000000000000000000;;				if meta.IsListType(result) {
0000000000000000000000000000000000000000;;					// TODO: this should be calculated earlier
0000000000000000000000000000000000000000;;					err = newNotAcceptableError(fmt.Sprintf("you requested PartialObjectMetadata, but the requested object is a list (%T)", result))
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m, err := meta.Accessor(result)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				partial := meta.AsPartialObjectMetadata(m)
0000000000000000000000000000000000000000;;				partial.GetObjectKind().SetGroupVersionKind(metav1alpha1.SchemeGroupVersion.WithKind("PartialObjectMetadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// renegotiate under the internal version
0000000000000000000000000000000000000000;;				_, info, err := negotiation.NegotiateOutputMediaType(req, metainternalversion.Codecs, &scope)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				encoder := metainternalversion.Codecs.EncoderForVersion(info.Serializer, metav1alpha1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;				responsewriters.SerializeObject(info.MediaType, encoder, w, req, statusCode, partial)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case target.Kind == "PartialObjectMetadataList" && target.GroupVersion() == metav1alpha1.SchemeGroupVersion:
0000000000000000000000000000000000000000;;				if !meta.IsListType(result) {
0000000000000000000000000000000000000000;;					// TODO: this should be calculated earlier
0000000000000000000000000000000000000000;;					err = newNotAcceptableError(fmt.Sprintf("you requested PartialObjectMetadataList, but the requested object is not a list (%T)", result))
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				list := &metav1alpha1.PartialObjectMetadataList{}
0000000000000000000000000000000000000000;;				err := meta.EachListItem(result, func(obj runtime.Object) error {
0000000000000000000000000000000000000000;;					m, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					partial := meta.AsPartialObjectMetadata(m)
0000000000000000000000000000000000000000;;					partial.GetObjectKind().SetGroupVersionKind(metav1alpha1.SchemeGroupVersion.WithKind("PartialObjectMetadata"))
0000000000000000000000000000000000000000;;					list.Items = append(list.Items, partial)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// renegotiate under the internal version
0000000000000000000000000000000000000000;;				_, info, err := negotiation.NegotiateOutputMediaType(req, metainternalversion.Codecs, &scope)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				encoder := metainternalversion.Codecs.EncoderForVersion(info.Serializer, metav1alpha1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;				responsewriters.SerializeObject(info.MediaType, encoder, w, req, statusCode, list)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case target.Kind == "Table" && target.GroupVersion() == metav1alpha1.SchemeGroupVersion:
0000000000000000000000000000000000000000;;				// TODO: relax the version abstraction
0000000000000000000000000000000000000000;;				// TODO: skip if this is a status response (delete without body)?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				opts := &metav1alpha1.TableOptions{}
0000000000000000000000000000000000000000;;				if err := metav1alpha1.ParameterCodec.DecodeParameters(req.URL.Query(), metav1alpha1.SchemeGroupVersion, opts); err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				table, err := scope.TableConvertor.ConvertToTable(ctx, result, opts)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := range table.Rows {
0000000000000000000000000000000000000000;;					item := &table.Rows[i]
0000000000000000000000000000000000000000;;					switch opts.IncludeObject {
0000000000000000000000000000000000000000;;					case metav1alpha1.IncludeObject:
0000000000000000000000000000000000000000;;						item.Object.Object, err = scope.Convertor.ConvertToVersion(item.Object.Object, scope.Kind.GroupVersion())
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							scope.err(err, w, req)
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					// TODO: rely on defaulting for the value here?
0000000000000000000000000000000000000000;;					case metav1alpha1.IncludeMetadata, "":
0000000000000000000000000000000000000000;;						m, err := meta.Accessor(item.Object.Object)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							scope.err(err, w, req)
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// TODO: turn this into an internal type and do conversion in order to get object kind automatically set?
0000000000000000000000000000000000000000;;						partial := meta.AsPartialObjectMetadata(m)
0000000000000000000000000000000000000000;;						partial.GetObjectKind().SetGroupVersionKind(metav1alpha1.SchemeGroupVersion.WithKind("PartialObjectMetadata"))
0000000000000000000000000000000000000000;;						item.Object.Object = partial
0000000000000000000000000000000000000000;;					case metav1alpha1.IncludeNone:
0000000000000000000000000000000000000000;;						item.Object.Object = nil
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// TODO: move this to validation on the table options?
0000000000000000000000000000000000000000;;						err = errors.NewBadRequest(fmt.Sprintf("unrecognized includeObject value: %q", opts.IncludeObject))
0000000000000000000000000000000000000000;;						scope.err(err, w, req)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// renegotiate under the internal version
0000000000000000000000000000000000000000;;				_, info, err := negotiation.NegotiateOutputMediaType(req, metainternalversion.Codecs, &scope)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				encoder := metainternalversion.Codecs.EncoderForVersion(info.Serializer, metav1alpha1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;				responsewriters.SerializeObject(info.MediaType, encoder, w, req, statusCode, table)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// this block should only be hit if scope AllowsConversion is incorrect
0000000000000000000000000000000000000000;;				accepted, _ := negotiation.MediaTypesForSerializer(metainternalversion.Codecs)
0000000000000000000000000000000000000000;;				err := negotiation.NewNotAcceptableError(accepted)
0000000000000000000000000000000000000000;;				status := responsewriters.ErrorToAPIStatus(err)
0000000000000000000000000000000000000000;;				responsewriters.WriteRawJSON(int(status.Code), status, w)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		responsewriters.WriteObject(ctx, statusCode, scope.Kind.GroupVersion(), scope.Serializer, result, w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errNotAcceptable indicates Accept negotiation has failed
0000000000000000000000000000000000000000;;	type errNotAcceptable struct {
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newNotAcceptableError(message string) error {
0000000000000000000000000000000000000000;;		return errNotAcceptable{message}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e errNotAcceptable) Error() string {
0000000000000000000000000000000000000000;;		return e.message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e errNotAcceptable) Status() metav1.Status {
0000000000000000000000000000000000000000;;		return metav1.Status{
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:    http.StatusNotAcceptable,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReason("NotAcceptable"),
0000000000000000000000000000000000000000;;			Message: e.Error(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
