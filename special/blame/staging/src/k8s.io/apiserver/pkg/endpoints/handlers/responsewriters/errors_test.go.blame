0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
08d114d4043ca0532760f0d254c1aea625d54998;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package responsewriters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestErrors(t *testing.T) {
0000000000000000000000000000000000000000;;		internalError := errors.New("ARGH")
0000000000000000000000000000000000000000;;		fns := map[string]func(http.ResponseWriter, *http.Request){
0000000000000000000000000000000000000000;;			"BadGatewayError": BadGatewayError,
0000000000000000000000000000000000000000;;			"NotFound":        NotFound,
0000000000000000000000000000000000000000;;			"InternalError": func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				InternalError(w, req, internalError)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			fn       string
0000000000000000000000000000000000000000;;			uri      string
0000000000000000000000000000000000000000;;			expected string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"BadGatewayError", "/get", `Bad Gateway: "/get"`},
0000000000000000000000000000000000000000;;			{"BadGatewayError", "/<script>", `Bad Gateway: "/&lt;script&gt;"`},
0000000000000000000000000000000000000000;;			{"NotFound", "/get", `Not Found: "/get"`},
0000000000000000000000000000000000000000;;			{"NotFound", "/<script&>", `Not Found: "/&lt;script&amp;&gt;"`},
0000000000000000000000000000000000000000;;			{"InternalError", "/get", `Internal Server Error: "/get": ARGH`},
0000000000000000000000000000000000000000;;			{"InternalError", "/<script>", `Internal Server Error: "/&lt;script&gt;": ARGH`},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range cases {
0000000000000000000000000000000000000000;;			observer := httptest.NewRecorder()
0000000000000000000000000000000000000000;;			fns[test.fn](observer, &http.Request{RequestURI: test.uri})
0000000000000000000000000000000000000000;;			result := string(observer.Body.Bytes())
0000000000000000000000000000000000000000;;			if result != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s(..., %q) != %q, got %q", test.fn, test.uri, test.expected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestForbidden(t *testing.T) {
0000000000000000000000000000000000000000;;		u := &user.DefaultInfo{Name: "NAME"}
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			expected    string
0000000000000000000000000000000000000000;;			attributes  authorizer.Attributes
0000000000000000000000000000000000000000;;			reason      string
0000000000000000000000000000000000000000;;			contentType string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{`{"metadata":{},"status":"Failure","message":" \"\" is forbidden: User \"NAME\" cannot GET path \"/whatever\".","reason":"Forbidden","details":{},"code":403}
0000000000000000000000000000000000000000;;	`, authorizer.AttributesRecord{User: u, Verb: "GET", Path: "/whatever"}, "", "application/json"},
0000000000000000000000000000000000000000;;			{`{"metadata":{},"status":"Failure","message":" \"\" is forbidden: User \"NAME\" cannot GET path \"/\u0026lt;script\u0026gt;\".","reason":"Forbidden","details":{},"code":403}
0000000000000000000000000000000000000000;;	`, authorizer.AttributesRecord{User: u, Verb: "GET", Path: "/<script>"}, "", "application/json"},
0000000000000000000000000000000000000000;;			{`{"metadata":{},"status":"Failure","message":"pod \"\" is forbidden: User \"NAME\" cannot GET pod at the cluster scope.","reason":"Forbidden","details":{"kind":"pod"},"code":403}
0000000000000000000000000000000000000000;;	`, authorizer.AttributesRecord{User: u, Verb: "GET", Resource: "pod", ResourceRequest: true}, "", "application/json"},
0000000000000000000000000000000000000000;;			{`{"metadata":{},"status":"Failure","message":"pod.v2 \"\" is forbidden: User \"NAME\" cannot GET pod.v2/quota in the namespace \"test\".","reason":"Forbidden","details":{"group":"v2","kind":"pod"},"code":403}
0000000000000000000000000000000000000000;;	`, authorizer.AttributesRecord{User: u, Verb: "GET", Namespace: "test", APIGroup: "v2", Resource: "pod", Subresource: "quota", ResourceRequest: true}, "", "application/json"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range cases {
0000000000000000000000000000000000000000;;			observer := httptest.NewRecorder()
0000000000000000000000000000000000000000;;			scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;			negotiatedSerializer := serializer.DirectCodecFactory{CodecFactory: serializer.NewCodecFactory(scheme)}
0000000000000000000000000000000000000000;;			Forbidden(request.NewDefaultContext(), test.attributes, observer, &http.Request{}, test.reason, negotiatedSerializer)
0000000000000000000000000000000000000000;;			result := string(observer.Body.Bytes())
0000000000000000000000000000000000000000;;			if result != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("Forbidden response body(%#v...) != %#v, got %#v", test.attributes, test.expected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resultType := observer.HeaderMap.Get("Content-Type")
0000000000000000000000000000000000000000;;			if resultType != test.contentType {
0000000000000000000000000000000000000000;;				t.Errorf("Forbidden content type(%#v...) != %#v, got %#v", test.attributes, test.expected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
