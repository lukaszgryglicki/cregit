0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5ad25b94f6b622ff688d168460fd582bc5447bca;pkg/apiserver/audit/audit.go[pkg/apiserver/audit/audit.go][staging/src/k8s.io/apiserver/pkg/endpoints/filters/audit.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		auditinternal "k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit/policy"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithAudit decorates a http.Handler with audit logging information for all the
0000000000000000000000000000000000000000;;	// requests coming to the server. Audit level is decided according to requests'
0000000000000000000000000000000000000000;;	// attributes and audit policy. Logs are emitted to the audit sink to
0000000000000000000000000000000000000000;;	// process events. If sink or audit policy is nil, no decoration takes place.
0000000000000000000000000000000000000000;;	func WithAudit(handler http.Handler, requestContextMapper request.RequestContextMapper, sink audit.Sink, policy policy.Checker, longRunningCheck request.LongRunningRequestCheck) http.Handler {
0000000000000000000000000000000000000000;;		if sink == nil || policy == nil {
0000000000000000000000000000000000000000;;			return handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			ctx, ok := requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("no context found for request"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attribs, err := GetAuthorizerAttributes(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("failed to GetAuthorizerAttributes: %v", err))
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("failed to parse request"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			level := policy.Level(attribs)
0000000000000000000000000000000000000000;;			audit.ObservePolicyLevel(level)
0000000000000000000000000000000000000000;;			if level == auditinternal.LevelNone {
0000000000000000000000000000000000000000;;				// Don't audit.
0000000000000000000000000000000000000000;;				handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ev, err := audit.NewEventFromRequest(req, level, attribs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("failed to complete audit event from request: %v", err))
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("failed to update context"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx = request.WithAuditEvent(ctx, ev)
0000000000000000000000000000000000000000;;			if err := requestContextMapper.Update(req, ctx); err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("failed to attach audit event to the context: %v", err))
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("failed to update context"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ev.Stage = auditinternal.StageRequestReceived
0000000000000000000000000000000000000000;;			processEvent(sink, ev)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// intercept the status code
0000000000000000000000000000000000000000;;			var longRunningSink audit.Sink
0000000000000000000000000000000000000000;;			if longRunningCheck != nil {
0000000000000000000000000000000000000000;;				ri, _ := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;				if longRunningCheck(req, ri) {
0000000000000000000000000000000000000000;;					longRunningSink = sink
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			respWriter := decorateResponseWriter(w, ev, longRunningSink)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// send audit event when we leave this func, either via a panic or cleanly. In the case of long
0000000000000000000000000000000000000000;;			// running requests, this will be the second audit event.
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if r := recover(); r != nil {
0000000000000000000000000000000000000000;;					defer panic(r)
0000000000000000000000000000000000000000;;					ev.Stage = auditinternal.StagePanic
0000000000000000000000000000000000000000;;					ev.ResponseStatus = &metav1.Status{
0000000000000000000000000000000000000000;;						Code:    http.StatusInternalServerError,
0000000000000000000000000000000000000000;;						Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;						Reason:  metav1.StatusReasonInternalError,
0000000000000000000000000000000000000000;;						Message: fmt.Sprintf("APIServer panic'd: %v", r),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					processEvent(sink, ev)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if no StageResponseStarted event was sent b/c neither a status code nor a body was sent, fake it here
0000000000000000000000000000000000000000;;				fakedSuccessStatus := &metav1.Status{
0000000000000000000000000000000000000000;;					Code:    http.StatusOK,
0000000000000000000000000000000000000000;;					Status:  metav1.StatusSuccess,
0000000000000000000000000000000000000000;;					Message: "Connection closed early",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ev.ResponseStatus == nil && longRunningSink != nil {
0000000000000000000000000000000000000000;;					ev.ResponseStatus = fakedSuccessStatus
0000000000000000000000000000000000000000;;					ev.Stage = auditinternal.StageResponseStarted
0000000000000000000000000000000000000000;;					processEvent(longRunningSink, ev)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ev.Stage = auditinternal.StageResponseComplete
0000000000000000000000000000000000000000;;				if ev.ResponseStatus == nil {
0000000000000000000000000000000000000000;;					ev.ResponseStatus = fakedSuccessStatus
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				processEvent(sink, ev)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			handler.ServeHTTP(respWriter, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func processEvent(sink audit.Sink, ev *auditinternal.Event) {
0000000000000000000000000000000000000000;;		audit.ObserveEvent()
0000000000000000000000000000000000000000;;		sink.ProcessEvents(ev)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decorateResponseWriter(responseWriter http.ResponseWriter, ev *auditinternal.Event, sink audit.Sink) http.ResponseWriter {
0000000000000000000000000000000000000000;;		delegate := &auditResponseWriter{
0000000000000000000000000000000000000000;;			ResponseWriter: responseWriter,
0000000000000000000000000000000000000000;;			event:          ev,
0000000000000000000000000000000000000000;;			sink:           sink,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if the ResponseWriter we're wrapping is the fancy one we need
0000000000000000000000000000000000000000;;		// or if the basic is sufficient
0000000000000000000000000000000000000000;;		_, cn := responseWriter.(http.CloseNotifier)
0000000000000000000000000000000000000000;;		_, fl := responseWriter.(http.Flusher)
0000000000000000000000000000000000000000;;		_, hj := responseWriter.(http.Hijacker)
0000000000000000000000000000000000000000;;		if cn && fl && hj {
0000000000000000000000000000000000000000;;			return &fancyResponseWriterDelegator{delegate}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return delegate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ http.ResponseWriter = &auditResponseWriter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// auditResponseWriter intercepts WriteHeader, sets it in the event. If the sink is set, it will
0000000000000000000000000000000000000000;;	// create immediately an event (for long running requests).
0000000000000000000000000000000000000000;;	type auditResponseWriter struct {
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;		event *auditinternal.Event
0000000000000000000000000000000000000000;;		once  sync.Once
0000000000000000000000000000000000000000;;		sink  audit.Sink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *auditResponseWriter) processCode(code int) {
0000000000000000000000000000000000000000;;		a.once.Do(func() {
0000000000000000000000000000000000000000;;			if a.event.ResponseStatus == nil {
0000000000000000000000000000000000000000;;				a.event.ResponseStatus = &metav1.Status{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.event.ResponseStatus.Code = int32(code)
0000000000000000000000000000000000000000;;			a.event.Stage = auditinternal.StageResponseStarted
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if a.sink != nil {
0000000000000000000000000000000000000000;;				processEvent(a.sink, a.event)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *auditResponseWriter) Write(bs []byte) (int, error) {
0000000000000000000000000000000000000000;;		a.processCode(http.StatusOK) // the Go library calls WriteHeader internally if no code was written yet. But this will go unnoticed for us
0000000000000000000000000000000000000000;;		return a.ResponseWriter.Write(bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *auditResponseWriter) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		a.processCode(code)
0000000000000000000000000000000000000000;;		a.ResponseWriter.WriteHeader(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fancyResponseWriterDelegator implements http.CloseNotifier, http.Flusher and
0000000000000000000000000000000000000000;;	// http.Hijacker which are needed to make certain http operation (e.g. watch, rsh, etc)
0000000000000000000000000000000000000000;;	// working.
0000000000000000000000000000000000000000;;	type fancyResponseWriterDelegator struct {
0000000000000000000000000000000000000000;;		*auditResponseWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyResponseWriterDelegator) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return f.ResponseWriter.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyResponseWriterDelegator) Flush() {
0000000000000000000000000000000000000000;;		f.ResponseWriter.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyResponseWriterDelegator) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		// fake a response status before protocol switch happens
0000000000000000000000000000000000000000;;		f.processCode(http.StatusSwitchingProtocols)
0000000000000000000000000000000000000000;;		return f.ResponseWriter.(http.Hijacker).Hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ http.CloseNotifier = &fancyResponseWriterDelegator{}
0000000000000000000000000000000000000000;;	var _ http.Flusher = &fancyResponseWriterDelegator{}
0000000000000000000000000000000000000000;;	var _ http.Hijacker = &fancyResponseWriterDelegator{}
