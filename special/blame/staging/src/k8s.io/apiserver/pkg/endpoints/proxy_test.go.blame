0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
bed262fc88165928f843276fce085c6ee57d7300;pkg/apiserver/proxy_test.go[pkg/apiserver/proxy_test.go][staging/src/k8s.io/apiserver/pkg/endpoints/proxy_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package endpoints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyRequestContentLengthAndTransferEncoding(t *testing.T) {
0000000000000000000000000000000000000000;;		chunk := func(data []byte) []byte {
0000000000000000000000000000000000000000;;			out := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			chunker := httputil.NewChunkedWriter(out)
0000000000000000000000000000000000000000;;			for _, b := range data {
0000000000000000000000000000000000000000;;				if _, err := chunker.Write([]byte{b}); err != nil {
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chunker.Close()
0000000000000000000000000000000000000000;;			out.Write([]byte("\r\n"))
0000000000000000000000000000000000000000;;			return out.Bytes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zip := func(data []byte) []byte {
0000000000000000000000000000000000000000;;			out := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			zipper := gzip.NewWriter(out)
0000000000000000000000000000000000000000;;			if _, err := zipper.Write(data); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zipper.Close()
0000000000000000000000000000000000000000;;			return out.Bytes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sampleData := []byte("abcde")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := map[string]struct {
0000000000000000000000000000000000000000;;			reqHeaders http.Header
0000000000000000000000000000000000000000;;			reqBody    []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedHeaders http.Header
0000000000000000000000000000000000000000;;			expectedBody    []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"content-length": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length": []string{"5"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: sampleData,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{"5"},
0000000000000000000000000000000000000000;;					"Content-Encoding":  nil, // none set
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // none set
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: sampleData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"content-length + identity transfer-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{"5"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": []string{"identity"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: sampleData,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{"5"},
0000000000000000000000000000000000000000;;					"Content-Encoding":  nil, // none set
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // gets removed
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: sampleData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"content-length + gzip content-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":   []string{strconv.Itoa(len(zip(sampleData)))},
0000000000000000000000000000000000000000;;					"Content-Encoding": []string{"gzip"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: zip(sampleData),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{strconv.Itoa(len(zip(sampleData)))},
0000000000000000000000000000000000000000;;					"Content-Encoding":  []string{"gzip"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // none set
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: zip(sampleData),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"chunked transfer-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Transfer-Encoding": []string{"chunked"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: chunk(sampleData),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    nil, // none set
0000000000000000000000000000000000000000;;					"Content-Encoding":  nil, // none set
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // Transfer-Encoding gets removed
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: sampleData, // sample data is unchunked
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"chunked transfer-encoding + gzip content-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Encoding":  []string{"gzip"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": []string{"chunked"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: chunk(zip(sampleData)),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    nil, // none set
0000000000000000000000000000000000000000;;					"Content-Encoding":  []string{"gzip"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // gets removed
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: zip(sampleData), // sample data is unchunked, but content-encoding is preserved
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// "Transfer-Encoding: gzip" is not supported by go
0000000000000000000000000000000000000000;;			// See http/transfer.go#fixTransferEncoding (https://golang.org/src/net/http/transfer.go#L427)
0000000000000000000000000000000000000000;;			// Once it is supported, this test case should succeed
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// "gzip+chunked transfer-encoding": {
0000000000000000000000000000000000000000;;			// 	reqHeaders: http.Header{
0000000000000000000000000000000000000000;;			// 		"Transfer-Encoding": []string{"chunked,gzip"},
0000000000000000000000000000000000000000;;			// 	},
0000000000000000000000000000000000000000;;			// 	reqBody: chunk(zip(sampleData)),
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// 	expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;			// 		"Content-Length":    nil, // no content-length headers
0000000000000000000000000000000000000000;;			// 		"Transfer-Encoding": nil, // Transfer-Encoding gets removed
0000000000000000000000000000000000000000;;			// 	},
0000000000000000000000000000000000000000;;			// 	expectedBody: sampleData,
0000000000000000000000000000000000000000;;			// },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		successfulResponse := "backend passed tests"
0000000000000000000000000000000000000000;;		for k, item := range table {
0000000000000000000000000000000000000000;;			// Start the downstream server
0000000000000000000000000000000000000000;;			downstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				// Verify headers
0000000000000000000000000000000000000000;;				for header, v := range item.expectedHeaders {
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(v, req.Header[header]) {
0000000000000000000000000000000000000000;;						t.Errorf("%s: Expected headers for %s to be %v, got %v", k, header, v, req.Header[header])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Read body
0000000000000000000000000000000000000000;;				body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				req.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Verify length
0000000000000000000000000000000000000000;;				if req.ContentLength > 0 && req.ContentLength != int64(len(body)) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: ContentLength was %d, len(data) was %d", k, req.ContentLength, len(body))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Verify content
0000000000000000000000000000000000000000;;				if !bytes.Equal(item.expectedBody, body) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: Expected %q, got %q", k, string(item.expectedBody), string(body))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Write successful response
0000000000000000000000000000000000000000;;				w.Write([]byte(successfulResponse))
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;			defer downstreamServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Start the proxy server
0000000000000000000000000000000000000000;;			serverURL, _ := url.Parse(downstreamServer.URL)
0000000000000000000000000000000000000000;;			simpleStorage := &SimpleRESTStorage{
0000000000000000000000000000000000000000;;				errors:                    map[string]error{},
0000000000000000000000000000000000000000;;				resourceLocation:          serverURL,
0000000000000000000000000000000000000000;;				expectedResourceNamespace: "default",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			namespaceHandler := handleNamespaced(map[string]rest.Storage{"foo": simpleStorage})
0000000000000000000000000000000000000000;;			server := newTestServer(namespaceHandler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Dial the proxy server
0000000000000000000000000000000000000000;;			conn, err := net.Dial(server.Listener.Addr().Network(), server.Listener.Addr().String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add standard http 1.1 headers
0000000000000000000000000000000000000000;;			if item.reqHeaders == nil {
0000000000000000000000000000000000000000;;				item.reqHeaders = http.Header{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			item.reqHeaders.Add("Connection", "close")
0000000000000000000000000000000000000000;;			item.reqHeaders.Add("Host", server.Listener.Addr().String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We directly write to the connection to bypass the Go library's manipulation of the Request.Header.
0000000000000000000000000000000000000000;;			// Write the request headers
0000000000000000000000000000000000000000;;			post := fmt.Sprintf("POST /%s/%s/%s/proxy/namespaces/default/foo/id/some/dir HTTP/1.1\r\n", prefix, newGroupVersion.Group, newGroupVersion.Version)
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprint(conn, post); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for header, values := range item.reqHeaders {
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					if _, err := fmt.Fprintf(conn, "%s: %s\r\n", header, value); err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Header separator
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprint(conn, "\r\n"); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Body
0000000000000000000000000000000000000000;;			if _, err := conn.Write(item.reqBody); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read response
0000000000000000000000000000000000000000;;			response, err := ioutil.ReadAll(conn)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(string(response), successfulResponse) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get successful response: %s", k, string(response))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxy(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			method          string
0000000000000000000000000000000000000000;;			path            string
0000000000000000000000000000000000000000;;			reqBody         string
0000000000000000000000000000000000000000;;			respBody        string
0000000000000000000000000000000000000000;;			respContentType string
0000000000000000000000000000000000000000;;			reqNamespace    string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"GET", "/some/dir", "", "answer", "text/css", "default"},
0000000000000000000000000000000000000000;;			{"GET", "/some/dir", "", "<html><head></head><body>answer</body></html>", "text/html", "default"},
0000000000000000000000000000000000000000;;			{"POST", "/some/other/dir", "question", "answer", "text/css", "default"},
0000000000000000000000000000000000000000;;			{"PUT", "/some/dir/id", "different question", "answer", "text/css", "default"},
0000000000000000000000000000000000000000;;			{"DELETE", "/some/dir/id", "", "ok", "text/css", "default"},
0000000000000000000000000000000000000000;;			{"GET", "/some/dir/id", "", "answer", "text/css", "other"},
0000000000000000000000000000000000000000;;			{"GET", "/trailing/slash/", "", "answer", "text/css", "default"},
0000000000000000000000000000000000000000;;			{"GET", "/", "", "answer", "text/css", "default"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			downstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				gotBody, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v - unexpected error %v", item.method, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.reqBody, string(gotBody); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v - expected %v, got %v", item.method, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.path, req.URL.Path; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v - expected %v, got %v", item.method, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", item.respContentType)
0000000000000000000000000000000000000000;;				var out io.Writer = w
0000000000000000000000000000000000000000;;				if strings.Contains(req.Header.Get("Accept-Encoding"), "gzip") {
0000000000000000000000000000000000000000;;					// The proxier can ask for gzip'd data; we need to provide it with that
0000000000000000000000000000000000000000;;					// in order to test our processing of that data.
0000000000000000000000000000000000000000;;					w.Header().Set("Content-Encoding", "gzip")
0000000000000000000000000000000000000000;;					gzw := gzip.NewWriter(w)
0000000000000000000000000000000000000000;;					out = gzw
0000000000000000000000000000000000000000;;					defer gzw.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprint(out, item.respBody)
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;			defer downstreamServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverURL, _ := url.Parse(downstreamServer.URL)
0000000000000000000000000000000000000000;;			simpleStorage := &SimpleRESTStorage{
0000000000000000000000000000000000000000;;				errors:                    map[string]error{},
0000000000000000000000000000000000000000;;				resourceLocation:          serverURL,
0000000000000000000000000000000000000000;;				expectedResourceNamespace: item.reqNamespace,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespaceHandler := handleNamespaced(map[string]rest.Storage{"foo": simpleStorage})
0000000000000000000000000000000000000000;;			namespaceServer := newTestServer(namespaceHandler)
0000000000000000000000000000000000000000;;			defer namespaceServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// test each supported URL pattern for finding the redirection resource in the proxy in a particular namespace
0000000000000000000000000000000000000000;;			serverPatterns := []struct {
0000000000000000000000000000000000000000;;				server           *httptest.Server
0000000000000000000000000000000000000000;;				proxyTestPattern string
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				{namespaceServer, "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/proxy/namespaces/" + item.reqNamespace + "/foo/id" + item.path},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, serverPattern := range serverPatterns {
0000000000000000000000000000000000000000;;				server := serverPattern.server
0000000000000000000000000000000000000000;;				proxyTestPattern := serverPattern.proxyTestPattern
0000000000000000000000000000000000000000;;				req, err := http.NewRequest(
0000000000000000000000000000000000000000;;					item.method,
0000000000000000000000000000000000000000;;					server.URL+proxyTestPattern,
0000000000000000000000000000000000000000;;					strings.NewReader(item.reqBody),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v - unexpected error %v", item.method, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v - unexpected error %v", item.method, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gotResp, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v - unexpected error %v", item.method, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resp.Body.Close()
0000000000000000000000000000000000000000;;				if e, a := item.respBody, string(gotResp); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v - expected %v, got %v. url: %#v", item.method, e, a, req.URL)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyUpgrade(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		localhostPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;		if !localhostPool.AppendCertsFromPEM(localhostCert) {
0000000000000000000000000000000000000000;;			t.Errorf("error setting up localhostCert pool")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := map[string]struct {
0000000000000000000000000000000000000000;;			ServerFunc     func(http.Handler) *httptest.Server
0000000000000000000000000000000000000000;;			ProxyTransport http.RoundTripper
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"http": {
0000000000000000000000000000000000000000;;				ServerFunc:     httptest.NewServer,
0000000000000000000000000000000000000000;;				ProxyTransport: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"https (invalid hostname + InsecureSkipVerify)": {
0000000000000000000000000000000000000000;;				ServerFunc: func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(exampleCert, exampleKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (invalid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ProxyTransport: utilnet.SetTransportDefaults(&http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"https (valid hostname + RootCAs)": {
0000000000000000000000000000000000000000;;				ServerFunc: func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(localhostCert, localhostKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (valid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ProxyTransport: utilnet.SetTransportDefaults(&http.Transport{TLSClientConfig: &tls.Config{RootCAs: localhostPool}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"https (valid hostname + RootCAs + custom dialer)": {
0000000000000000000000000000000000000000;;				ServerFunc: func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(localhostCert, localhostKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (valid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ProxyTransport: utilnet.SetTransportDefaults(&http.Transport{Dial: net.Dial, TLSClientConfig: &tls.Config{RootCAs: localhostPool}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, tc := range testcases {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			backendServer := tc.ServerFunc(websocket.Handler(func(ws *websocket.Conn) {
0000000000000000000000000000000000000000;;				defer ws.Close()
0000000000000000000000000000000000000000;;				body := make([]byte, 5)
0000000000000000000000000000000000000000;;				ws.Read(body)
0000000000000000000000000000000000000000;;				ws.Write([]byte("hello " + string(body)))
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;			defer backendServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverURL, _ := url.Parse(backendServer.URL)
0000000000000000000000000000000000000000;;			simpleStorage := &SimpleRESTStorage{
0000000000000000000000000000000000000000;;				errors:                    map[string]error{},
0000000000000000000000000000000000000000;;				resourceLocation:          serverURL,
0000000000000000000000000000000000000000;;				resourceLocationTransport: tc.ProxyTransport,
0000000000000000000000000000000000000000;;				expectedResourceNamespace: "myns",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespaceHandler := handleNamespaced(map[string]rest.Storage{"foo": simpleStorage})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			server := newTestServer(namespaceHandler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ws, err := websocket.Dial("ws://"+server.Listener.Addr().String()+"/"+prefix+"/"+newGroupVersion.Group+"/"+newGroupVersion.Version+"/proxy/namespaces/myns/foo/123", "", "http://127.0.0.1/")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: websocket dial err: %s", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := ws.Write([]byte("world")); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: write err: %s", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			response := make([]byte, 20)
0000000000000000000000000000000000000000;;			n, err := ws.Read(response)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: read err: %s", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := "hello world", string(response[0:n]); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected '%#v', got '%#v'", k, e, a)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRedirectOnMissingTrailingSlash(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			// The requested path
0000000000000000000000000000000000000000;;			path string
0000000000000000000000000000000000000000;;			// The path requested on the proxy server.
0000000000000000000000000000000000000000;;			proxyServerPath string
0000000000000000000000000000000000000000;;			// query string
0000000000000000000000000000000000000000;;			query string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"/trailing/slash/", "/trailing/slash/", ""},
0000000000000000000000000000000000000000;;			{"/", "/", "test1=value1&test2=value2"},
0000000000000000000000000000000000000000;;			// "/" should be added at the end.
0000000000000000000000000000000000000000;;			{"", "/", "test1=value1&test2=value2"},
0000000000000000000000000000000000000000;;			// "/" should not be added at a non-root path.
0000000000000000000000000000000000000000;;			{"/some/path", "/some/path", ""},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			downstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				if req.URL.Path != item.proxyServerPath {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected request on path: %s, expected path: %s, item: %v", req.URL.Path, item.proxyServerPath, item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if req.URL.RawQuery != item.query {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected query on url: %s, expected: %s", req.URL.RawQuery, item.query)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;			defer downstreamServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverURL, _ := url.Parse(downstreamServer.URL)
0000000000000000000000000000000000000000;;			simpleStorage := &SimpleRESTStorage{
0000000000000000000000000000000000000000;;				errors:                    map[string]error{},
0000000000000000000000000000000000000000;;				resourceLocation:          serverURL,
0000000000000000000000000000000000000000;;				expectedResourceNamespace: "ns",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			handler := handleNamespaced(map[string]rest.Storage{"foo": simpleStorage})
0000000000000000000000000000000000000000;;			server := newTestServer(handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			proxyTestPattern := "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/proxy/namespaces/ns/foo/id" + item.path
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(
0000000000000000000000000000000000000000;;				"GET",
0000000000000000000000000000000000000000;;				server.URL+proxyTestPattern+"?"+item.query,
0000000000000000000000000000000000000000;;				strings.NewReader(""),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Note: We are using a default client here, that follows redirects.
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected errorCode: %v, expected: 200. Response: %v, item: %v", resp.StatusCode, resp, item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exampleCert was generated from crypto/tls/generate_cert.go with the following command:
0000000000000000000000000000000000000000;;	//    go run generate_cert.go  --rsa-bits 512 --host example.com --ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
0000000000000000000000000000000000000000;;	var exampleCert = []byte(`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIIBdzCCASGgAwIBAgIRAOVTAdPnfbS5V85mfS90TfIwDQYJKoZIhvcNAQELBQAw
0000000000000000000000000000000000000000;;	EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
0000000000000000000000000000000000000000;;	MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzBcMA0GCSqGSIb3DQEBAQUAA0sAMEgC
0000000000000000000000000000000000000000;;	QQCoVSqeu8TBvF+70T7Jm4340YQNhds6IxjRoifenYodAO1dnKGrcbF266DJGunh
0000000000000000000000000000000000000000;;	nIjQH7B12tduhl0fLK4Ezf7/AgMBAAGjUDBOMA4GA1UdDwEB/wQEAwICpDATBgNV
0000000000000000000000000000000000000000;;	HSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MBYGA1UdEQQPMA2CC2V4
0000000000000000000000000000000000000000;;	YW1wbGUuY29tMA0GCSqGSIb3DQEBCwUAA0EAk1kVa5uZ/AzwYDVcS9bpM/czwjjV
0000000000000000000000000000000000000000;;	xq3VeSCfmNa2uNjbFvodmCRwZOHUvipAMGCUCV6j5vMrJ8eMj8tCQ36W9A==
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var exampleKey = []byte(`-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBOgIBAAJBAKhVKp67xMG8X7vRPsmbjfjRhA2F2zojGNGiJ96dih0A7V2coatx
0000000000000000000000000000000000000000;;	sXbroMka6eGciNAfsHXa126GXR8srgTN/v8CAwEAAQJASdzdD7vKsUwMIejGCUb1
0000000000000000000000000000000000000000;;	fAnLTPfAY3lFCa+CmR89nE22dAoRDv+5RbnBsZ58BazPNJHrsVPRlfXB3OQmSQr0
0000000000000000000000000000000000000000;;	SQIhANoJhs+xOJE/i8nJv0uAbzKyiD1YkvRkta0GpUOULyAVAiEAxaQus3E/SuqD
0000000000000000000000000000000000000000;;	P7y5NeJnE7X6XkyC35zrsJRkz7orE8MCIHdDjsI8pjyNDeGqwUCDWE/a6DrmIDwe
0000000000000000000000000000000000000000;;	emHSqMN2YvChAiEAnxLCM9NWaenOsaIoP+J1rDuvw+4499nJKVqGuVrSCRkCIEqK
0000000000000000000000000000000000000000;;	4KSchPMc3x8M/uhw9oWTtKFmjA/PPh0FsWCdKrEy
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// localhostCert was generated from crypto/tls/generate_cert.go with the following command:
0000000000000000000000000000000000000000;;	//     go run generate_cert.go  --rsa-bits 512 --host 127.0.0.1,::1,example.com --ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
0000000000000000000000000000000000000000;;	var localhostCert = []byte(`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIIBjzCCATmgAwIBAgIRAKpi2WmTcFrVjxrl5n5YDUEwDQYJKoZIhvcNAQELBQAw
0000000000000000000000000000000000000000;;	EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
0000000000000000000000000000000000000000;;	MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzBcMA0GCSqGSIb3DQEBAQUAA0sAMEgC
0000000000000000000000000000000000000000;;	QQC9fEbRszP3t14Gr4oahV7zFObBI4TfA5i7YnlMXeLinb7MnvT4bkfOJzE6zktn
0000000000000000000000000000000000000000;;	59zP7UiHs3l4YOuqrjiwM413AgMBAAGjaDBmMA4GA1UdDwEB/wQEAwICpDATBgNV
0000000000000000000000000000000000000000;;	HSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MC4GA1UdEQQnMCWCC2V4
0000000000000000000000000000000000000000;;	YW1wbGUuY29thwR/AAABhxAAAAAAAAAAAAAAAAAAAAABMA0GCSqGSIb3DQEBCwUA
0000000000000000000000000000000000000000;;	A0EAUsVE6KMnza/ZbodLlyeMzdo7EM/5nb5ywyOxgIOCf0OOLHsPS9ueGLQX9HEG
0000000000000000000000000000000000000000;;	//yjTXuhNcUugExIjM/AIwAZPQ==
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// localhostKey is the private key for localhostCert.
0000000000000000000000000000000000000000;;	var localhostKey = []byte(`-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBOwIBAAJBAL18RtGzM/e3XgavihqFXvMU5sEjhN8DmLtieUxd4uKdvsye9Phu
0000000000000000000000000000000000000000;;	R84nMTrOS2fn3M/tSIezeXhg66quOLAzjXcCAwEAAQJBAKcRxH9wuglYLBdI/0OT
0000000000000000000000000000000000000000;;	BLzfWPZCEw1vZmMR2FF1Fm8nkNOVDPleeVGTWoOEcYYlQbpTmkGSxJ6ya+hqRi6x
0000000000000000000000000000000000000000;;	goECIQDx3+X49fwpL6B5qpJIJMyZBSCuMhH4B7JevhGGFENi3wIhAMiNJN5Q3UkL
0000000000000000000000000000000000000000;;	IuSvv03kaPR5XVQ99/UeEetUgGvBcABpAiBJSBzVITIVCGkGc7d+RCf49KTCIklv
0000000000000000000000000000000000000000;;	bGWObufAR8Ni4QIgWpILjW8dkGg8GOUZ0zaNA6Nvt6TIv2UWGJ4v5PoV98kCIQDx
0000000000000000000000000000000000000000;;	rIiZs5QbKdycsv9gQJzwQAogC8o04X3Zz3dsoX+h4A==
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
