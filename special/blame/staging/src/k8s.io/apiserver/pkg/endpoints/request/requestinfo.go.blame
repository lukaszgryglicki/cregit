0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
b1a13a8ab8dca00133402aa39aa64366374b64d3;pkg/apiserver/handlers.go[pkg/apiserver/handlers.go][staging/src/k8s.io/apiserver/pkg/endpoints/request/requestinfo.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestInfo holds information parsed from the http.Request
0000000000000000000000000000000000000000;;	type RequestInfo struct {
0000000000000000000000000000000000000000;;		// IsResourceRequest indicates whether or not the request is for an API resource or subresource
0000000000000000000000000000000000000000;;		IsResourceRequest bool
0000000000000000000000000000000000000000;;		// Path is the URL path of the request
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		// Verb is the kube verb associated with the request for API requests, not the http verb.  This includes things like list and watch.
0000000000000000000000000000000000000000;;		// for non-resource requests, this is the lowercase http verb
0000000000000000000000000000000000000000;;		Verb string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		APIPrefix  string
0000000000000000000000000000000000000000;;		APIGroup   string
0000000000000000000000000000000000000000;;		APIVersion string
0000000000000000000000000000000000000000;;		Namespace  string
0000000000000000000000000000000000000000;;		// Resource is the name of the resource being requested.  This is not the kind.  For example: pods
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;		// Subresource is the name of the subresource being requested.  This is a different resource, scoped to the parent resource, but it may have a different kind.
0000000000000000000000000000000000000000;;		// For instance, /pods has the resource "pods" and the kind "Pod", while /pods/foo/status has the resource "pods", the sub resource "status", and the kind "Pod"
0000000000000000000000000000000000000000;;		// (because status operates on pods). The binding resource for a pod though may be /pods/foo/binding, which has resource "pods", subresource "binding", and kind "Binding".
0000000000000000000000000000000000000000;;		Subresource string
0000000000000000000000000000000000000000;;		// Name is empty for some verbs, but if the request directly indicates a name (not in body content) then this field is filled in.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Parts are the path parts for the request, always starting with /{resource}/{name}
0000000000000000000000000000000000000000;;		Parts []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// specialVerbs contains just strings which are used in REST paths for special actions that don't fall under the normal
0000000000000000000000000000000000000000;;	// CRUDdy GET/POST/PUT/DELETE actions on REST objects.
0000000000000000000000000000000000000000;;	// TODO: find a way to keep this up to date automatically.  Maybe dynamically populate list as handlers added to
0000000000000000000000000000000000000000;;	// master's Mux.
0000000000000000000000000000000000000000;;	var specialVerbs = sets.NewString("proxy", "watch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// specialVerbsNoSubresources contains root verbs which do not allow subresources
0000000000000000000000000000000000000000;;	var specialVerbsNoSubresources = sets.NewString("proxy")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namespaceSubresources contains subresources of namespace
0000000000000000000000000000000000000000;;	// this list allows the parser to distinguish between a namespace subresource, and a namespaced resource
0000000000000000000000000000000000000000;;	var namespaceSubresources = sets.NewString("status", "finalize")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceSubResourcesForTest exports namespaceSubresources for testing in pkg/master/master_test.go, so we never drift
0000000000000000000000000000000000000000;;	var NamespaceSubResourcesForTest = sets.NewString(namespaceSubresources.List()...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RequestInfoFactory struct {
0000000000000000000000000000000000000000;;		APIPrefixes          sets.String // without leading and trailing slashes
0000000000000000000000000000000000000000;;		GrouplessAPIPrefixes sets.String // without leading and trailing slashes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO write an integration test against the swagger doc to test the RequestInfo and match up behavior to responses
0000000000000000000000000000000000000000;;	// NewRequestInfo returns the information from the http request.  If error is not nil, RequestInfo holds the information as best it is known before the failure
0000000000000000000000000000000000000000;;	// It handles both resource and non-resource requests and fills in all the pertinent information for each.
0000000000000000000000000000000000000000;;	// Valid Inputs:
0000000000000000000000000000000000000000;;	// Resource paths
0000000000000000000000000000000000000000;;	// /apis/{api-group}/{version}/namespaces
0000000000000000000000000000000000000000;;	// /api/{version}/namespaces
0000000000000000000000000000000000000000;;	// /api/{version}/namespaces/{namespace}
0000000000000000000000000000000000000000;;	// /api/{version}/namespaces/{namespace}/{resource}
0000000000000000000000000000000000000000;;	// /api/{version}/namespaces/{namespace}/{resource}/{resourceName}
0000000000000000000000000000000000000000;;	// /api/{version}/{resource}
0000000000000000000000000000000000000000;;	// /api/{version}/{resource}/{resourceName}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Special verbs without subresources:
0000000000000000000000000000000000000000;;	// /api/{version}/proxy/{resource}/{resourceName}
0000000000000000000000000000000000000000;;	// /api/{version}/proxy/namespaces/{namespace}/{resource}/{resourceName}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Special verbs with subresources:
0000000000000000000000000000000000000000;;	// /api/{version}/watch/{resource}
0000000000000000000000000000000000000000;;	// /api/{version}/watch/namespaces/{namespace}/{resource}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NonResource paths
0000000000000000000000000000000000000000;;	// /apis/{api-group}/{version}
0000000000000000000000000000000000000000;;	// /apis/{api-group}
0000000000000000000000000000000000000000;;	// /apis
0000000000000000000000000000000000000000;;	// /api/{version}
0000000000000000000000000000000000000000;;	// /api
0000000000000000000000000000000000000000;;	// /healthz
0000000000000000000000000000000000000000;;	// /
0000000000000000000000000000000000000000;;	func (r *RequestInfoFactory) NewRequestInfo(req *http.Request) (*RequestInfo, error) {
0000000000000000000000000000000000000000;;		// start with a non-resource request until proven otherwise
0000000000000000000000000000000000000000;;		requestInfo := RequestInfo{
0000000000000000000000000000000000000000;;			IsResourceRequest: false,
0000000000000000000000000000000000000000;;			Path:              req.URL.Path,
0000000000000000000000000000000000000000;;			Verb:              strings.ToLower(req.Method),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentParts := splitPath(req.URL.Path)
0000000000000000000000000000000000000000;;		if len(currentParts) < 3 {
0000000000000000000000000000000000000000;;			// return a non-resource request
0000000000000000000000000000000000000000;;			return &requestInfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !r.APIPrefixes.Has(currentParts[0]) {
0000000000000000000000000000000000000000;;			// return a non-resource request
0000000000000000000000000000000000000000;;			return &requestInfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestInfo.APIPrefix = currentParts[0]
0000000000000000000000000000000000000000;;		currentParts = currentParts[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !r.GrouplessAPIPrefixes.Has(requestInfo.APIPrefix) {
0000000000000000000000000000000000000000;;			// one part (APIPrefix) has already been consumed, so this is actually "do we have four parts?"
0000000000000000000000000000000000000000;;			if len(currentParts) < 3 {
0000000000000000000000000000000000000000;;				// return a non-resource request
0000000000000000000000000000000000000000;;				return &requestInfo, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestInfo.APIGroup = currentParts[0]
0000000000000000000000000000000000000000;;			currentParts = currentParts[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestInfo.IsResourceRequest = true
0000000000000000000000000000000000000000;;		requestInfo.APIVersion = currentParts[0]
0000000000000000000000000000000000000000;;		currentParts = currentParts[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle input of form /{specialVerb}/*
0000000000000000000000000000000000000000;;		if specialVerbs.Has(currentParts[0]) {
0000000000000000000000000000000000000000;;			if len(currentParts) < 2 {
0000000000000000000000000000000000000000;;				return &requestInfo, fmt.Errorf("unable to determine kind and namespace from url, %v", req.URL)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestInfo.Verb = currentParts[0]
0000000000000000000000000000000000000000;;			currentParts = currentParts[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			switch req.Method {
0000000000000000000000000000000000000000;;			case "POST":
0000000000000000000000000000000000000000;;				requestInfo.Verb = "create"
0000000000000000000000000000000000000000;;			case "GET", "HEAD":
0000000000000000000000000000000000000000;;				requestInfo.Verb = "get"
0000000000000000000000000000000000000000;;			case "PUT":
0000000000000000000000000000000000000000;;				requestInfo.Verb = "update"
0000000000000000000000000000000000000000;;			case "PATCH":
0000000000000000000000000000000000000000;;				requestInfo.Verb = "patch"
0000000000000000000000000000000000000000;;			case "DELETE":
0000000000000000000000000000000000000000;;				requestInfo.Verb = "delete"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				requestInfo.Verb = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// URL forms: /namespaces/{namespace}/{kind}/*, where parts are adjusted to be relative to kind
0000000000000000000000000000000000000000;;		if currentParts[0] == "namespaces" {
0000000000000000000000000000000000000000;;			if len(currentParts) > 1 {
0000000000000000000000000000000000000000;;				requestInfo.Namespace = currentParts[1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if there is another step after the namespace name and it is not a known namespace subresource
0000000000000000000000000000000000000000;;				// move currentParts to include it as a resource in its own right
0000000000000000000000000000000000000000;;				if len(currentParts) > 2 && !namespaceSubresources.Has(currentParts[2]) {
0000000000000000000000000000000000000000;;					currentParts = currentParts[2:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requestInfo.Namespace = "" // TODO(sttts): solve import cycle when using metav1.NamespaceNone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parsing successful, so we now know the proper value for .Parts
0000000000000000000000000000000000000000;;		requestInfo.Parts = currentParts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parts look like: resource/resourceName/subresource/other/stuff/we/don't/interpret
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(requestInfo.Parts) >= 3 && !specialVerbsNoSubresources.Has(requestInfo.Verb):
0000000000000000000000000000000000000000;;			requestInfo.Subresource = requestInfo.Parts[2]
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case len(requestInfo.Parts) >= 2:
0000000000000000000000000000000000000000;;			requestInfo.Name = requestInfo.Parts[1]
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case len(requestInfo.Parts) >= 1:
0000000000000000000000000000000000000000;;			requestInfo.Resource = requestInfo.Parts[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if there's no name on the request and we thought it was a get before, then the actual verb is a list or a watch
0000000000000000000000000000000000000000;;		if len(requestInfo.Name) == 0 && requestInfo.Verb == "get" {
0000000000000000000000000000000000000000;;			// Assumes v1.ListOptions
0000000000000000000000000000000000000000;;			// Any query value that is not 0 or false is considered true
0000000000000000000000000000000000000000;;			// see apimachinery/pkg/runtime/conversion.go Convert_Slice_string_To_bool
0000000000000000000000000000000000000000;;			if values := req.URL.Query()["watch"]; len(values) > 0 {
0000000000000000000000000000000000000000;;				switch strings.ToLower(values[0]) {
0000000000000000000000000000000000000000;;				case "false", "0":
0000000000000000000000000000000000000000;;					requestInfo.Verb = "list"
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					requestInfo.Verb = "watch"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				requestInfo.Verb = "list"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if there's no name on the request and we thought it was a delete before, then the actual verb is deletecollection
0000000000000000000000000000000000000000;;		if len(requestInfo.Name) == 0 && requestInfo.Verb == "delete" {
0000000000000000000000000000000000000000;;			requestInfo.Verb = "deletecollection"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &requestInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type requestInfoKeyType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestInfoKey is the RequestInfo key for the context. It's of private type here. Because
0000000000000000000000000000000000000000;;	// keys are interfaces and interfaces are equal when the type and the value is equal, this
0000000000000000000000000000000000000000;;	// does not conflict with the keys defined in pkg/api.
0000000000000000000000000000000000000000;;	const requestInfoKey requestInfoKeyType = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithRequestInfo returns a copy of parent in which the request info value is set
0000000000000000000000000000000000000000;;	func WithRequestInfo(parent Context, info *RequestInfo) Context {
0000000000000000000000000000000000000000;;		return WithValue(parent, requestInfoKey, info)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestInfoFrom returns the value of the RequestInfo key on the ctx
0000000000000000000000000000000000000000;;	func RequestInfoFrom(ctx Context) (*RequestInfo, bool) {
0000000000000000000000000000000000000000;;		info, ok := ctx.Value(requestInfoKey).(*RequestInfo)
0000000000000000000000000000000000000000;;		return info, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitPath returns the segments for a URL path.
0000000000000000000000000000000000000000;;	func splitPath(path string) []string {
0000000000000000000000000000000000000000;;		path = strings.Trim(path, "/")
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Split(path, "/")
0000000000000000000000000000000000000000;;	}
