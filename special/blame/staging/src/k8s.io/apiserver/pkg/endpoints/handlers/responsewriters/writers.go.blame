0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
06699f6bbe14a867aaaecd86af05add5cf06668e;pkg/apiserver/handlers/responsewriters/writers.go[pkg/apiserver/handlers/responsewriters/writers.go][staging/src/k8s.io/apiserver/pkg/endpoints/handlers/responsewriters/writers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package responsewriters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/negotiation"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/flushwriter"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/wsstream"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteObject renders a returned runtime.Object to the response as a stream or an encoded object. If the object
0000000000000000000000000000000000000000;;	// returned by the response implements rest.ResourceStreamer that interface will be used to render the
0000000000000000000000000000000000000000;;	// response. The Accept header and current API version will be passed in, and the output will be copied
0000000000000000000000000000000000000000;;	// directly to the response body. If content type is returned it is used, otherwise the content type will
0000000000000000000000000000000000000000;;	// be "application/octet-stream". All other objects are sent to standard JSON serialization.
0000000000000000000000000000000000000000;;	func WriteObject(ctx request.Context, statusCode int, gv schema.GroupVersion, s runtime.NegotiatedSerializer, object runtime.Object, w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		stream, ok := object.(rest.ResourceStreamer)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			StreamObject(ctx, statusCode, gv, s, stream, w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		WriteObjectNegotiated(ctx, s, gv, w, req, statusCode, object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamObject performs input stream negotiation from a ResourceStreamer and writes that to the response.
0000000000000000000000000000000000000000;;	// If the client requests a websocket upgrade, negotiate for a websocket reader protocol (because many
0000000000000000000000000000000000000000;;	// browser clients cannot easily handle binary streaming protocols).
0000000000000000000000000000000000000000;;	func StreamObject(ctx request.Context, statusCode int, gv schema.GroupVersion, s runtime.NegotiatedSerializer, stream rest.ResourceStreamer, w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		out, flush, contentType, err := stream.InputStream(gv.String(), req.Header.Get("Accept"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorNegotiated(ctx, err, s, gv, w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out == nil {
0000000000000000000000000000000000000000;;			// No output provided - return StatusNoContent
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusNoContent)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer out.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if wsstream.IsWebSocketRequest(req) {
0000000000000000000000000000000000000000;;			r := wsstream.NewReader(out, true, wsstream.NewDefaultReaderProtocols())
0000000000000000000000000000000000000000;;			if err := r.Copy(w, req); err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("error encountered while streaming results via websocket: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(contentType) == 0 {
0000000000000000000000000000000000000000;;			contentType = "application/octet-stream"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", contentType)
0000000000000000000000000000000000000000;;		w.WriteHeader(statusCode)
0000000000000000000000000000000000000000;;		writer := w.(io.Writer)
0000000000000000000000000000000000000000;;		if flush {
0000000000000000000000000000000000000000;;			writer = flushwriter.Wrap(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		io.Copy(writer, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializeObject renders an object in the content type negotiated by the client using the provided encoder.
0000000000000000000000000000000000000000;;	// The context is optional and can be nil.
0000000000000000000000000000000000000000;;	func SerializeObject(mediaType string, encoder runtime.Encoder, w http.ResponseWriter, req *http.Request, statusCode int, object runtime.Object) {
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", mediaType)
0000000000000000000000000000000000000000;;		w.WriteHeader(statusCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := encoder.Encode(object, w); err != nil {
0000000000000000000000000000000000000000;;			errorJSONFatal(err, encoder, w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteObjectNegotiated renders an object in the content type negotiated by the client.
0000000000000000000000000000000000000000;;	// The context is optional and can be nil.
0000000000000000000000000000000000000000;;	func WriteObjectNegotiated(ctx request.Context, s runtime.NegotiatedSerializer, gv schema.GroupVersion, w http.ResponseWriter, req *http.Request, statusCode int, object runtime.Object) {
0000000000000000000000000000000000000000;;		serializer, err := negotiation.NegotiateOutputSerializer(req, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			status := ErrorToAPIStatus(err)
0000000000000000000000000000000000000000;;			WriteRawJSON(int(status.Code), status, w)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ae := request.AuditEventFrom(ctx); ae != nil {
0000000000000000000000000000000000000000;;			audit.LogResponseObject(ae, object, gv, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoder := s.EncoderForVersion(serializer.Serializer, gv)
0000000000000000000000000000000000000000;;		SerializeObject(serializer.MediaType, encoder, w, req, statusCode, object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorNegotiated renders an error to the response. Returns the HTTP status code of the error.
0000000000000000000000000000000000000000;;	// The context is optional and may be nil.
0000000000000000000000000000000000000000;;	func ErrorNegotiated(ctx request.Context, err error, s runtime.NegotiatedSerializer, gv schema.GroupVersion, w http.ResponseWriter, req *http.Request) int {
0000000000000000000000000000000000000000;;		status := ErrorToAPIStatus(err)
0000000000000000000000000000000000000000;;		code := int(status.Code)
0000000000000000000000000000000000000000;;		// when writing an error, check to see if the status indicates a retry after period
0000000000000000000000000000000000000000;;		if status.Details != nil && status.Details.RetryAfterSeconds > 0 {
0000000000000000000000000000000000000000;;			delay := strconv.Itoa(int(status.Details.RetryAfterSeconds))
0000000000000000000000000000000000000000;;			w.Header().Set("Retry-After", delay)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if code == http.StatusNoContent {
0000000000000000000000000000000000000000;;			w.WriteHeader(code)
0000000000000000000000000000000000000000;;			return code
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		WriteObjectNegotiated(ctx, s, gv, w, req, code, status)
0000000000000000000000000000000000000000;;		return code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errorJSONFatal renders an error to the response, and if codec fails will render plaintext.
0000000000000000000000000000000000000000;;	// Returns the HTTP status code of the error.
0000000000000000000000000000000000000000;;	func errorJSONFatal(err error, codec runtime.Encoder, w http.ResponseWriter) int {
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("apiserver was unable to write a JSON response: %v", err))
0000000000000000000000000000000000000000;;		status := ErrorToAPIStatus(err)
0000000000000000000000000000000000000000;;		code := int(status.Code)
0000000000000000000000000000000000000000;;		output, err := runtime.Encode(codec, status)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			w.WriteHeader(code)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%s: %s", status.Reason, status.Message)
0000000000000000000000000000000000000000;;			return code
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.WriteHeader(code)
0000000000000000000000000000000000000000;;		w.Write(output)
0000000000000000000000000000000000000000;;		return code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteRawJSON writes a non-API object in JSON.
0000000000000000000000000000000000000000;;	func WriteRawJSON(statusCode int, object interface{}, w http.ResponseWriter) {
0000000000000000000000000000000000000000;;		output, err := json.MarshalIndent(object, "", "  ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.WriteHeader(statusCode)
0000000000000000000000000000000000000000;;		w.Write(output)
0000000000000000000000000000000000000000;;	}
