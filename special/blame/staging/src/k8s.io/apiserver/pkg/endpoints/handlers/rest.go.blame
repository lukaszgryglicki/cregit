0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
42daa62a2ee7711b0b7065182a4155d58cdfb128;pkg/apiserver/resthandler.go[pkg/apiserver/resthandler.go][staging/src/k8s.io/apiserver/pkg/endpoints/handlers/rest.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package handlers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		metav1alpha1 "k8s.io/apimachinery/pkg/apis/meta/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/mergepatch"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/negotiation"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		utiltrace "k8s.io/apiserver/pkg/util/trace"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestScope encapsulates common fields across all RESTful handler methods.
0000000000000000000000000000000000000000;;	type RequestScope struct {
0000000000000000000000000000000000000000;;		Namer ScopeNamer
0000000000000000000000000000000000000000;;		ContextFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Serializer runtime.NegotiatedSerializer
0000000000000000000000000000000000000000;;		runtime.ParameterCodec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Creater         runtime.ObjectCreater
0000000000000000000000000000000000000000;;		Convertor       runtime.ObjectConvertor
0000000000000000000000000000000000000000;;		Defaulter       runtime.ObjectDefaulter
0000000000000000000000000000000000000000;;		Copier          runtime.ObjectCopier
0000000000000000000000000000000000000000;;		Typer           runtime.ObjectTyper
0000000000000000000000000000000000000000;;		UnsafeConvertor runtime.ObjectConvertor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TableConvertor rest.TableConvertor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Resource    schema.GroupVersionResource
0000000000000000000000000000000000000000;;		Kind        schema.GroupVersionKind
0000000000000000000000000000000000000000;;		Subresource string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		MetaGroupVersion schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (scope *RequestScope) err(err error, w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;		responsewriters.ErrorNegotiated(ctx, err, scope.Serializer, scope.Kind.GroupVersion(), w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (scope *RequestScope) AllowsConversion(gvk schema.GroupVersionKind) bool {
0000000000000000000000000000000000000000;;		// TODO: this is temporary, replace with an abstraction calculated at endpoint installation time
0000000000000000000000000000000000000000;;		if gvk.GroupVersion() == metav1alpha1.SchemeGroupVersion {
0000000000000000000000000000000000000000;;			switch gvk.Kind {
0000000000000000000000000000000000000000;;			case "Table":
0000000000000000000000000000000000000000;;				return scope.TableConvertor != nil
0000000000000000000000000000000000000000;;			case "PartialObjectMetadata", "PartialObjectMetadataList":
0000000000000000000000000000000000000000;;				// TODO: should delineate between lists and non-list endpoints
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (scope *RequestScope) AllowsServerVersion(version string) bool {
0000000000000000000000000000000000000000;;		return version == scope.MetaGroupVersion.Version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (scope *RequestScope) AllowsStreamSchema(s string) bool {
0000000000000000000000000000000000000000;;		return s == "watch"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getterFunc performs a get request with the given context and object name. The request
0000000000000000000000000000000000000000;;	// may be used to deserialize an options object to pass to the getter.
0000000000000000000000000000000000000000;;	type getterFunc func(ctx request.Context, name string, req *http.Request, trace *utiltrace.Trace) (runtime.Object, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxRetryWhenPatchConflicts is the maximum number of conflicts retry during a patch operation before returning failure
0000000000000000000000000000000000000000;;	const MaxRetryWhenPatchConflicts = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourceHandler is an HTTP handler function for get requests. It delegates to the
0000000000000000000000000000000000000000;;	// passed-in getterFunc to perform the actual get.
0000000000000000000000000000000000000000;;	func getResourceHandler(scope RequestScope, getter getterFunc) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			trace := utiltrace.New("Get " + req.URL.Path)
0000000000000000000000000000000000000000;;			defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace, name, err := scope.Namer.Name(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result, err := getter(ctx, name, req, trace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				scope.err(fmt.Errorf("missing requestInfo"), w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := setSelfLink(result, requestInfo, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			trace.Step("About to write a response")
0000000000000000000000000000000000000000;;			transformResponseObject(ctx, scope, req, w, http.StatusOK, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResource returns a function that handles retrieving a single resource from a rest.Storage object.
0000000000000000000000000000000000000000;;	func GetResource(r rest.Getter, e rest.Exporter, scope RequestScope) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return getResourceHandler(scope,
0000000000000000000000000000000000000000;;			func(ctx request.Context, name string, req *http.Request, trace *utiltrace.Trace) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				// check for export
0000000000000000000000000000000000000000;;				options := metav1.GetOptions{}
0000000000000000000000000000000000000000;;				if values := req.URL.Query(); len(values) > 0 {
0000000000000000000000000000000000000000;;					exports := metav1.ExportOptions{}
0000000000000000000000000000000000000000;;					if err := metainternalversion.ParameterCodec.DecodeParameters(values, scope.MetaGroupVersion, &exports); err != nil {
0000000000000000000000000000000000000000;;						err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if exports.Export {
0000000000000000000000000000000000000000;;						if e == nil {
0000000000000000000000000000000000000000;;							return nil, errors.NewBadRequest(fmt.Sprintf("export of %q is not supported", scope.Resource.Resource))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return e.Export(ctx, name, exports)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := metainternalversion.ParameterCodec.DecodeParameters(values, scope.MetaGroupVersion, &options); err != nil {
0000000000000000000000000000000000000000;;						err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if trace != nil {
0000000000000000000000000000000000000000;;					trace.Step("About to Get from storage")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return r.Get(ctx, name, &options)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResourceWithOptions returns a function that handles retrieving a single resource from a rest.Storage object.
0000000000000000000000000000000000000000;;	func GetResourceWithOptions(r rest.GetterWithOptions, scope RequestScope, isSubresource bool) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return getResourceHandler(scope,
0000000000000000000000000000000000000000;;			func(ctx request.Context, name string, req *http.Request, trace *utiltrace.Trace) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				opts, subpath, subpathKey := r.NewGetOptions()
0000000000000000000000000000000000000000;;				trace.Step("About to process Get options")
0000000000000000000000000000000000000000;;				if err := getRequestOptions(req, scope, opts, subpath, subpathKey, isSubresource); err != nil {
0000000000000000000000000000000000000000;;					err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if trace != nil {
0000000000000000000000000000000000000000;;					trace.Step("About to Get from storage")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return r.Get(ctx, name, opts)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRequestOptions parses out options and can include path information.  The path information shouldn't include the subresource.
0000000000000000000000000000000000000000;;	func getRequestOptions(req *http.Request, scope RequestScope, into runtime.Object, subpath bool, subpathKey string, isSubresource bool) error {
0000000000000000000000000000000000000000;;		if into == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		query := req.URL.Query()
0000000000000000000000000000000000000000;;		if subpath {
0000000000000000000000000000000000000000;;			newQuery := make(url.Values)
0000000000000000000000000000000000000000;;			for k, v := range query {
0000000000000000000000000000000000000000;;				newQuery[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			requestInfo, _ := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			startingIndex := 2
0000000000000000000000000000000000000000;;			if isSubresource {
0000000000000000000000000000000000000000;;				startingIndex = 3
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newQuery[subpathKey] = []string{strings.Join(requestInfo.Parts[startingIndex:], "/")}
0000000000000000000000000000000000000000;;			query = newQuery
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scope.ParameterCodec.DecodeParameters(query, scope.Kind.GroupVersion(), into)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectResource returns a function that handles a connect request on a rest.Storage object.
0000000000000000000000000000000000000000;;	func ConnectResource(connecter rest.Connecter, scope RequestScope, admit admission.Interface, restPath string, isSubresource bool) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			namespace, name, err := scope.Namer.Name(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;			opts, subpath, subpathKey := connecter.NewConnectOptions()
0000000000000000000000000000000000000000;;			if err := getRequestOptions(req, scope, opts, subpath, subpathKey, isSubresource); err != nil {
0000000000000000000000000000000000000000;;				err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if admit.Handles(admission.Connect) {
0000000000000000000000000000000000000000;;				connectRequest := &rest.ConnectRequest{
0000000000000000000000000000000000000000;;					Name:         name,
0000000000000000000000000000000000000000;;					Options:      opts,
0000000000000000000000000000000000000000;;					ResourcePath: restPath,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				userInfo, _ := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = admit.Admit(admission.NewAttributesRecord(connectRequest, nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Connect, userInfo))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler, err := connecter.Connect(ctx, name, opts, &responder{scope: scope, req: req, w: w})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// responder implements rest.Responder for assisting a connector in writing objects or errors.
0000000000000000000000000000000000000000;;	type responder struct {
0000000000000000000000000000000000000000;;		scope RequestScope
0000000000000000000000000000000000000000;;		req   *http.Request
0000000000000000000000000000000000000000;;		w     http.ResponseWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responder) Object(statusCode int, obj runtime.Object) {
0000000000000000000000000000000000000000;;		ctx := r.scope.ContextFunc(r.req)
0000000000000000000000000000000000000000;;		responsewriters.WriteObject(ctx, statusCode, r.scope.Kind.GroupVersion(), r.scope.Serializer, obj, r.w, r.req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responder) Error(err error) {
0000000000000000000000000000000000000000;;		r.scope.err(err, r.w, r.req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ListResource(r rest.Lister, rw rest.Watcher, scope RequestScope, forceWatch bool, minRequestTimeout time.Duration) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			// For performance tracking purposes.
0000000000000000000000000000000000000000;;			trace := utiltrace.New("List " + req.URL.Path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace, err := scope.Namer.Namespace(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Watches for single objects are routed to this function.
0000000000000000000000000000000000000000;;			// Treat a /name parameter the same as a field selector entry.
0000000000000000000000000000000000000000;;			hasName := true
0000000000000000000000000000000000000000;;			_, name, err := scope.Namer.Name(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				hasName = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts := metainternalversion.ListOptions{}
0000000000000000000000000000000000000000;;			if err := metainternalversion.ParameterCodec.DecodeParameters(req.URL.Query(), scope.MetaGroupVersion, &opts); err != nil {
0000000000000000000000000000000000000000;;				err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// transform fields
0000000000000000000000000000000000000000;;			// TODO: DecodeParametersInto should do this.
0000000000000000000000000000000000000000;;			if opts.FieldSelector != nil {
0000000000000000000000000000000000000000;;				fn := func(label, value string) (newLabel, newValue string, err error) {
0000000000000000000000000000000000000000;;					return scope.Convertor.ConvertFieldLabel(scope.Kind.GroupVersion().String(), scope.Kind.Kind, label, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if opts.FieldSelector, err = opts.FieldSelector.Transform(fn); err != nil {
0000000000000000000000000000000000000000;;					// TODO: allow bad request to set field causes based on query parameters
0000000000000000000000000000000000000000;;					err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hasName {
0000000000000000000000000000000000000000;;				// metadata.name is the canonical internal name.
0000000000000000000000000000000000000000;;				// SelectionPredicate will notice that this is
0000000000000000000000000000000000000000;;				// a request for a single object and optimize the
0000000000000000000000000000000000000000;;				// storage query accordingly.
0000000000000000000000000000000000000000;;				nameSelector := fields.OneTermEqualSelector("metadata.name", name)
0000000000000000000000000000000000000000;;				if opts.FieldSelector != nil && !opts.FieldSelector.Empty() {
0000000000000000000000000000000000000000;;					// It doesn't make sense to ask for both a name
0000000000000000000000000000000000000000;;					// and a field selector, since just the name is
0000000000000000000000000000000000000000;;					// sufficient to narrow down the request to a
0000000000000000000000000000000000000000;;					// single object.
0000000000000000000000000000000000000000;;					scope.err(errors.NewBadRequest("both a name and a field selector provided; please provide one or the other."), w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				opts.FieldSelector = nameSelector
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if opts.Watch || forceWatch {
0000000000000000000000000000000000000000;;				if rw == nil {
0000000000000000000000000000000000000000;;					scope.err(errors.NewMethodNotSupported(scope.Resource.GroupResource(), "watch"), w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO: Currently we explicitly ignore ?timeout= and use only ?timeoutSeconds=.
0000000000000000000000000000000000000000;;				timeout := time.Duration(0)
0000000000000000000000000000000000000000;;				if opts.TimeoutSeconds != nil {
0000000000000000000000000000000000000000;;					timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if timeout == 0 && minRequestTimeout > 0 {
0000000000000000000000000000000000000000;;					timeout = time.Duration(float64(minRequestTimeout) * (rand.Float64() + 1.0))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Starting watch for %s, rv=%s labels=%s fields=%s timeout=%s", req.URL.Path, opts.ResourceVersion, opts.LabelSelector, opts.FieldSelector, timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				watcher, err := rw.Watch(ctx, &opts)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				serveWatch(watcher, scope, req, w, timeout)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Log only long List requests (ignore Watch).
0000000000000000000000000000000000000000;;			defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;			trace.Step("About to List from storage")
0000000000000000000000000000000000000000;;			result, err := r.List(ctx, &opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Listing from storage done")
0000000000000000000000000000000000000000;;			numberOfItems, err := setListSelfLink(result, ctx, req, scope.Namer)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Self-linking done")
0000000000000000000000000000000000000000;;			// Ensure empty lists return a non-nil items slice
0000000000000000000000000000000000000000;;			if numberOfItems == 0 && meta.IsListType(result) {
0000000000000000000000000000000000000000;;				if err := meta.SetList(result, []runtime.Object{}); err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transformResponseObject(ctx, scope, req, w, http.StatusOK, result)
0000000000000000000000000000000000000000;;			trace.Step(fmt.Sprintf("Writing http response done (%d items)", numberOfItems))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createHandler(r rest.NamedCreater, scope RequestScope, typer runtime.ObjectTyper, admit admission.Interface, includeName bool) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			// For performance tracking purposes.
0000000000000000000000000000000000000000;;			trace := utiltrace.New("Create " + req.URL.Path)
0000000000000000000000000000000000000000;;			defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: we either want to remove timeout or document it (if we document, move timeout out of this function and declare it in api_installer)
0000000000000000000000000000000000000000;;			timeout := parseTimeout(req.URL.Query().Get("timeout"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				namespace, name string
0000000000000000000000000000000000000000;;				err             error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if includeName {
0000000000000000000000000000000000000000;;				namespace, name, err = scope.Namer.Name(req)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				namespace, err = scope.Namer.Namespace(req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gv := scope.Kind.GroupVersion()
0000000000000000000000000000000000000000;;			s, err := negotiation.NegotiateInputSerializer(req, scope.Serializer)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			decoder := scope.Serializer.DecoderToVersion(s.Serializer, schema.GroupVersion{Group: gv.Group, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			body, err := readBody(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defaultGVK := scope.Kind
0000000000000000000000000000000000000000;;			original := r.New()
0000000000000000000000000000000000000000;;			trace.Step("About to convert to expected version")
0000000000000000000000000000000000000000;;			obj, gvk, err := decoder.Decode(body, &defaultGVK, original)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = transformDecodeError(typer, err, original, gvk, body)
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gvk.GroupVersion() != gv {
0000000000000000000000000000000000000000;;				err = errors.NewBadRequest(fmt.Sprintf("the API version in the data (%s) does not match the expected API version (%v)", gvk.GroupVersion().String(), gv.String()))
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Conversion done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ae := request.AuditEventFrom(ctx)
0000000000000000000000000000000000000000;;			audit.LogRequestObject(ae, obj, scope.Resource, scope.Subresource, scope.Serializer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if admit != nil && admit.Handles(admission.Create) {
0000000000000000000000000000000000000000;;				userInfo, _ := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = admit.Admit(admission.NewAttributesRecord(obj, nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Create, userInfo))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: replace with content type negotiation?
0000000000000000000000000000000000000000;;			includeUninitialized := req.URL.Query().Get("includeUninitialized") == "1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			trace.Step("About to store object in database")
0000000000000000000000000000000000000000;;			result, err := finishRequest(timeout, func() (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return r.Create(ctx, name, obj, includeUninitialized)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Object stored in database")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				scope.err(fmt.Errorf("missing requestInfo"), w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := setSelfLink(result, requestInfo, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Self-link added")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the object is partially initialized, always indicate it via StatusAccepted
0000000000000000000000000000000000000000;;			code := http.StatusCreated
0000000000000000000000000000000000000000;;			if accessor, err := meta.Accessor(result); err == nil {
0000000000000000000000000000000000000000;;				if accessor.GetInitializers() != nil {
0000000000000000000000000000000000000000;;					code = http.StatusAccepted
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			status, ok := result.(*metav1.Status)
0000000000000000000000000000000000000000;;			if ok && err == nil && status.Code == 0 {
0000000000000000000000000000000000000000;;				status.Code = int32(code)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transformResponseObject(ctx, scope, req, w, code, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateNamedResource returns a function that will handle a resource creation with name.
0000000000000000000000000000000000000000;;	func CreateNamedResource(r rest.NamedCreater, scope RequestScope, typer runtime.ObjectTyper, admit admission.Interface) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return createHandler(r, scope, typer, admit, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateResource returns a function that will handle a resource creation.
0000000000000000000000000000000000000000;;	func CreateResource(r rest.Creater, scope RequestScope, typer runtime.ObjectTyper, admit admission.Interface) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return createHandler(&namedCreaterAdapter{r}, scope, typer, admit, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type namedCreaterAdapter struct {
0000000000000000000000000000000000000000;;		rest.Creater
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *namedCreaterAdapter) Create(ctx request.Context, name string, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return c.Creater.Create(ctx, obj, includeUninitialized)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PatchResource returns a function that will handle a resource patch
0000000000000000000000000000000000000000;;	// TODO: Eventually PatchResource should just use GuaranteedUpdate and this routine should be a bit cleaner
0000000000000000000000000000000000000000;;	func PatchResource(r rest.Patcher, scope RequestScope, admit admission.Interface, converter runtime.ObjectConvertor) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			// TODO: we either want to remove timeout or document it (if we
0000000000000000000000000000000000000000;;			// document, move timeout out of this function and declare it in
0000000000000000000000000000000000000000;;			// api_installer)
0000000000000000000000000000000000000000;;			timeout := parseTimeout(req.URL.Query().Get("timeout"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace, name, err := scope.Namer.Name(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			versionedObj, err := converter.ConvertToVersion(r.New(), scope.Kind.GroupVersion())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: handle this in negotiation
0000000000000000000000000000000000000000;;			contentType := req.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;			// Remove "; charset=" if included in header.
0000000000000000000000000000000000000000;;			if idx := strings.Index(contentType, ";"); idx > 0 {
0000000000000000000000000000000000000000;;				contentType = contentType[:idx]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchType := types.PatchType(contentType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			patchJS, err := readBody(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ae := request.AuditEventFrom(ctx)
0000000000000000000000000000000000000000;;			audit.LogRequestPatch(ae, patchJS)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s, ok := runtime.SerializerInfoForMediaType(scope.Serializer.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				scope.err(fmt.Errorf("no serializer defined for JSON"), w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gv := scope.Kind.GroupVersion()
0000000000000000000000000000000000000000;;			codec := runtime.NewCodec(
0000000000000000000000000000000000000000;;				scope.Serializer.EncoderForVersion(s.Serializer, gv),
0000000000000000000000000000000000000000;;				scope.Serializer.DecoderToVersion(s.Serializer, schema.GroupVersion{Group: gv.Group, Version: runtime.APIVersionInternal}),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			updateAdmit := func(updatedObject runtime.Object, currentObject runtime.Object) error {
0000000000000000000000000000000000000000;;				if admit != nil && admit.Handles(admission.Update) {
0000000000000000000000000000000000000000;;					userInfo, _ := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;					return admit.Admit(admission.NewAttributesRecord(updatedObject, currentObject, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Update, userInfo))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result, err := patchResource(ctx, updateAdmit, timeout, versionedObj, r, name, patchType, patchJS,
0000000000000000000000000000000000000000;;				scope.Namer, scope.Copier, scope.Creater, scope.Defaulter, scope.UnsafeConvertor, scope.Kind, scope.Resource, codec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				scope.err(fmt.Errorf("missing requestInfo"), w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := setSelfLink(result, requestInfo, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transformResponseObject(ctx, scope, req, w, http.StatusOK, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateAdmissionFunc func(updatedObject runtime.Object, currentObject runtime.Object) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// patchResource divides PatchResource for easier unit testing
0000000000000000000000000000000000000000;;	func patchResource(
0000000000000000000000000000000000000000;;		ctx request.Context,
0000000000000000000000000000000000000000;;		admit updateAdmissionFunc,
0000000000000000000000000000000000000000;;		timeout time.Duration,
0000000000000000000000000000000000000000;;		versionedObj runtime.Object,
0000000000000000000000000000000000000000;;		patcher rest.Patcher,
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		patchType types.PatchType,
0000000000000000000000000000000000000000;;		patchJS []byte,
0000000000000000000000000000000000000000;;		namer ScopeNamer,
0000000000000000000000000000000000000000;;		copier runtime.ObjectCopier,
0000000000000000000000000000000000000000;;		creater runtime.ObjectCreater,
0000000000000000000000000000000000000000;;		defaulter runtime.ObjectDefaulter,
0000000000000000000000000000000000000000;;		unsafeConvertor runtime.ObjectConvertor,
0000000000000000000000000000000000000000;;		kind schema.GroupVersionKind,
0000000000000000000000000000000000000000;;		resource schema.GroupVersionResource,
0000000000000000000000000000000000000000;;		codec runtime.Codec,
0000000000000000000000000000000000000000;;	) (runtime.Object, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace := request.NamespaceValue(ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			originalObjJS           []byte
0000000000000000000000000000000000000000;;			originalPatchedObjJS    []byte
0000000000000000000000000000000000000000;;			originalObjMap          map[string]interface{}
0000000000000000000000000000000000000000;;			getOriginalPatchMap     func() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;			lastConflictErr         error
0000000000000000000000000000000000000000;;			originalResourceVersion string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// applyPatch is called every time GuaranteedUpdate asks for the updated object,
0000000000000000000000000000000000000000;;		// and is given the currently persisted object as input.
0000000000000000000000000000000000000000;;		applyPatch := func(_ request.Context, _, currentObject runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;			// Make sure we actually have a persisted currentObject
0000000000000000000000000000000000000000;;			if hasUID, err := hasUID(currentObject); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			} else if !hasUID {
0000000000000000000000000000000000000000;;				return nil, errors.NewNotFound(resource.GroupResource(), name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			currentResourceVersion := ""
0000000000000000000000000000000000000000;;			if currentMetadata, err := meta.Accessor(currentObject); err == nil {
0000000000000000000000000000000000000000;;				currentResourceVersion = currentMetadata.GetResourceVersion()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case originalObjJS == nil && originalObjMap == nil:
0000000000000000000000000000000000000000;;				// first time through,
0000000000000000000000000000000000000000;;				// 1. apply the patch
0000000000000000000000000000000000000000;;				// 2. save the original and patched to detect whether there were conflicting changes on retries
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				originalResourceVersion = currentResourceVersion
0000000000000000000000000000000000000000;;				objToUpdate := patcher.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// For performance reasons, in case of strategicpatch, we avoid json
0000000000000000000000000000000000000000;;				// marshaling and unmarshaling and operate just on map[string]interface{}.
0000000000000000000000000000000000000000;;				// In case of other patch types, we still have to operate on JSON
0000000000000000000000000000000000000000;;				// representations.
0000000000000000000000000000000000000000;;				switch patchType {
0000000000000000000000000000000000000000;;				case types.JSONPatchType, types.MergePatchType:
0000000000000000000000000000000000000000;;					originalJS, patchedJS, err := patchObjectJSON(patchType, codec, currentObject, patchJS, objToUpdate, versionedObj)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					originalObjJS, originalPatchedObjJS = originalJS, patchedJS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Make a getter that can return a fresh strategic patch map if needed for conflict retries
0000000000000000000000000000000000000000;;					// We have to rebuild it each time we need it, because the map gets mutated when being applied
0000000000000000000000000000000000000000;;					var originalPatchBytes []byte
0000000000000000000000000000000000000000;;					getOriginalPatchMap = func() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;						if originalPatchBytes == nil {
0000000000000000000000000000000000000000;;							// Compute once
0000000000000000000000000000000000000000;;							originalPatchBytes, err = strategicpatch.CreateTwoWayMergePatch(originalObjJS, originalPatchedObjJS, versionedObj)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return nil, err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// Return a fresh map every time
0000000000000000000000000000000000000000;;						originalPatchMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;						if err := json.Unmarshal(originalPatchBytes, &originalPatchMap); err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return originalPatchMap, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case types.StrategicMergePatchType:
0000000000000000000000000000000000000000;;					// Since the patch is applied on versioned objects, we need to convert the
0000000000000000000000000000000000000000;;					// current object to versioned representation first.
0000000000000000000000000000000000000000;;					currentVersionedObject, err := unsafeConvertor.ConvertToVersion(currentObject, kind.GroupVersion())
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					versionedObjToUpdate, err := creater.New(kind)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Capture the original object map and patch for possible retries.
0000000000000000000000000000000000000000;;					originalMap, err := unstructured.DefaultConverter.ToUnstructured(currentVersionedObject)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := strategicPatchObject(codec, defaulter, currentVersionedObject, patchJS, versionedObjToUpdate, versionedObj); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Convert the object back to unversioned.
0000000000000000000000000000000000000000;;					gvk := kind.GroupKind().WithVersion(runtime.APIVersionInternal)
0000000000000000000000000000000000000000;;					unversionedObjToUpdate, err := unsafeConvertor.ConvertToVersion(versionedObjToUpdate, gvk.GroupVersion())
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					objToUpdate = unversionedObjToUpdate
0000000000000000000000000000000000000000;;					// Store unstructured representation for possible retries.
0000000000000000000000000000000000000000;;					originalObjMap = originalMap
0000000000000000000000000000000000000000;;					// Make a getter that can return a fresh strategic patch map if needed for conflict retries
0000000000000000000000000000000000000000;;					// We have to rebuild it each time we need it, because the map gets mutated when being applied
0000000000000000000000000000000000000000;;					getOriginalPatchMap = func() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;						patchMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;						if err := json.Unmarshal(patchJS, &patchMap); err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return patchMap, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := checkName(objToUpdate, name, namespace, namer); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return objToUpdate, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// on a conflict,
0000000000000000000000000000000000000000;;				// 1. build a strategic merge patch from originalJS and the patchedJS.  Different patch types can
0000000000000000000000000000000000000000;;				//    be specified, but a strategic merge patch should be expressive enough handle them.  Build the
0000000000000000000000000000000000000000;;				//    patch with this type to handle those cases.
0000000000000000000000000000000000000000;;				// 2. build a strategic merge patch from originalJS and the currentJS
0000000000000000000000000000000000000000;;				// 3. ensure no conflicts between the two patches
0000000000000000000000000000000000000000;;				// 4. apply the #1 patch to the currentJS object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Since the patch is applied on versioned objects, we need to convert the
0000000000000000000000000000000000000000;;				// current object to versioned representation first.
0000000000000000000000000000000000000000;;				currentVersionedObject, err := unsafeConvertor.ConvertToVersion(currentObject, kind.GroupVersion())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				currentObjMap, err := unstructured.DefaultConverter.ToUnstructured(currentVersionedObject)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var currentPatchMap map[string]interface{}
0000000000000000000000000000000000000000;;				if originalObjMap != nil {
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					currentPatchMap, err = strategicpatch.CreateTwoWayMergeMapPatch(originalObjMap, currentObjMap, versionedObj)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Compute current patch.
0000000000000000000000000000000000000000;;					currentObjJS, err := runtime.Encode(codec, currentObject)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					currentPatch, err := strategicpatch.CreateTwoWayMergePatch(originalObjJS, currentObjJS, versionedObj)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					currentPatchMap = make(map[string]interface{})
0000000000000000000000000000000000000000;;					if err := json.Unmarshal(currentPatch, &currentPatchMap); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Get a fresh copy of the original strategic patch each time through, since applying it mutates the map
0000000000000000000000000000000000000000;;				originalPatchMap, err := getOriginalPatchMap()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				hasConflicts, err := mergepatch.HasConflicts(originalPatchMap, currentPatchMap)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if hasConflicts {
0000000000000000000000000000000000000000;;					diff1, _ := json.Marshal(currentPatchMap)
0000000000000000000000000000000000000000;;					diff2, _ := json.Marshal(originalPatchMap)
0000000000000000000000000000000000000000;;					patchDiffErr := fmt.Errorf("there is a meaningful conflict (firstResourceVersion: %q, currentResourceVersion: %q):\n diff1=%v\n, diff2=%v\n", originalResourceVersion, currentResourceVersion, string(diff1), string(diff2))
0000000000000000000000000000000000000000;;					glog.V(4).Infof("patchResource failed for resource %s, because there is a meaningful conflict(firstResourceVersion: %q, currentResourceVersion: %q):\n diff1=%v\n, diff2=%v\n", name, originalResourceVersion, currentResourceVersion, string(diff1), string(diff2))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Return the last conflict error we got if we have one
0000000000000000000000000000000000000000;;					if lastConflictErr != nil {
0000000000000000000000000000000000000000;;						return nil, lastConflictErr
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Otherwise manufacture one of our own
0000000000000000000000000000000000000000;;					return nil, errors.NewConflict(resource.GroupResource(), name, patchDiffErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				versionedObjToUpdate, err := creater.New(kind)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := applyPatchToObject(codec, defaulter, currentObjMap, originalPatchMap, versionedObjToUpdate, versionedObj); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Convert the object back to unversioned.
0000000000000000000000000000000000000000;;				gvk := kind.GroupKind().WithVersion(runtime.APIVersionInternal)
0000000000000000000000000000000000000000;;				objToUpdate, err := unsafeConvertor.ConvertToVersion(versionedObjToUpdate, gvk.GroupVersion())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return objToUpdate, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// applyAdmission is called every time GuaranteedUpdate asks for the updated object,
0000000000000000000000000000000000000000;;		// and is given the currently persisted object and the patched object as input.
0000000000000000000000000000000000000000;;		applyAdmission := func(ctx request.Context, patchedObject runtime.Object, currentObject runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;			return patchedObject, admit(patchedObject, currentObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedObjectInfo := rest.DefaultUpdatedObjectInfo(nil, copier, applyPatch, applyAdmission)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return finishRequest(timeout, func() (runtime.Object, error) {
0000000000000000000000000000000000000000;;			updateObject, _, updateErr := patcher.Update(ctx, name, updatedObjectInfo)
0000000000000000000000000000000000000000;;			for i := 0; i < MaxRetryWhenPatchConflicts && (errors.IsConflict(updateErr)); i++ {
0000000000000000000000000000000000000000;;				lastConflictErr = updateErr
0000000000000000000000000000000000000000;;				updateObject, _, updateErr = patcher.Update(ctx, name, updatedObjectInfo)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return updateObject, updateErr
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateResource returns a function that will handle a resource update
0000000000000000000000000000000000000000;;	func UpdateResource(r rest.Updater, scope RequestScope, typer runtime.ObjectTyper, admit admission.Interface) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			// For performance tracking purposes.
0000000000000000000000000000000000000000;;			trace := utiltrace.New("Update " + req.URL.Path)
0000000000000000000000000000000000000000;;			defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: we either want to remove timeout or document it (if we document, move timeout out of this function and declare it in api_installer)
0000000000000000000000000000000000000000;;			timeout := parseTimeout(req.URL.Query().Get("timeout"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace, name, err := scope.Namer.Name(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			body, err := readBody(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s, err := negotiation.NegotiateInputSerializer(req, scope.Serializer)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defaultGVK := scope.Kind
0000000000000000000000000000000000000000;;			original := r.New()
0000000000000000000000000000000000000000;;			trace.Step("About to convert to expected version")
0000000000000000000000000000000000000000;;			decoder := scope.Serializer.DecoderToVersion(s.Serializer, schema.GroupVersion{Group: defaultGVK.Group, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;			obj, gvk, err := decoder.Decode(body, &defaultGVK, original)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = transformDecodeError(typer, err, original, gvk, body)
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gvk.GroupVersion() != defaultGVK.GroupVersion() {
0000000000000000000000000000000000000000;;				err = errors.NewBadRequest(fmt.Sprintf("the API version in the data (%s) does not match the expected API version (%s)", gvk.GroupVersion(), defaultGVK.GroupVersion()))
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Conversion done")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ae := request.AuditEventFrom(ctx)
0000000000000000000000000000000000000000;;			audit.LogRequestObject(ae, obj, scope.Resource, scope.Subresource, scope.Serializer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := checkName(obj, name, namespace, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var transformers []rest.TransformFunc
0000000000000000000000000000000000000000;;			if admit != nil && admit.Handles(admission.Update) {
0000000000000000000000000000000000000000;;				transformers = append(transformers, func(ctx request.Context, newObj, oldObj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					userInfo, _ := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;					return newObj, admit.Admit(admission.NewAttributesRecord(newObj, oldObj, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Update, userInfo))
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			trace.Step("About to store object in database")
0000000000000000000000000000000000000000;;			wasCreated := false
0000000000000000000000000000000000000000;;			result, err := finishRequest(timeout, func() (runtime.Object, error) {
0000000000000000000000000000000000000000;;				obj, created, err := r.Update(ctx, name, rest.DefaultUpdatedObjectInfo(obj, scope.Copier, transformers...))
0000000000000000000000000000000000000000;;				wasCreated = created
0000000000000000000000000000000000000000;;				return obj, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Object stored in database")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				scope.err(fmt.Errorf("missing requestInfo"), w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := setSelfLink(result, requestInfo, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Self-link added")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status := http.StatusOK
0000000000000000000000000000000000000000;;			if wasCreated {
0000000000000000000000000000000000000000;;				status = http.StatusCreated
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transformResponseObject(ctx, scope, req, w, status, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteResource returns a function that will handle a resource deletion
0000000000000000000000000000000000000000;;	func DeleteResource(r rest.GracefulDeleter, allowsOptions bool, scope RequestScope, admit admission.Interface) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			// For performance tracking purposes.
0000000000000000000000000000000000000000;;			trace := utiltrace.New("Delete " + req.URL.Path)
0000000000000000000000000000000000000000;;			defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: we either want to remove timeout or document it (if we document, move timeout out of this function and declare it in api_installer)
0000000000000000000000000000000000000000;;			timeout := parseTimeout(req.URL.Query().Get("timeout"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace, name, err := scope.Namer.Name(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			options := &metav1.DeleteOptions{}
0000000000000000000000000000000000000000;;			if allowsOptions {
0000000000000000000000000000000000000000;;				body, err := readBody(req)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(body) > 0 {
0000000000000000000000000000000000000000;;					s, err := negotiation.NegotiateInputSerializer(req, metainternalversion.Codecs)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						scope.err(err, w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// For backwards compatibility, we need to allow existing clients to submit per group DeleteOptions
0000000000000000000000000000000000000000;;					// It is also allowed to pass a body with meta.k8s.io/v1.DeleteOptions
0000000000000000000000000000000000000000;;					defaultGVK := scope.MetaGroupVersion.WithKind("DeleteOptions")
0000000000000000000000000000000000000000;;					obj, _, err := metainternalversion.Codecs.DecoderToVersion(s.Serializer, defaultGVK.GroupVersion()).Decode(body, &defaultGVK, options)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						scope.err(err, w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if obj != options {
0000000000000000000000000000000000000000;;						scope.err(fmt.Errorf("decoded object cannot be converted to DeleteOptions"), w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ae := request.AuditEventFrom(ctx)
0000000000000000000000000000000000000000;;					audit.LogRequestObject(ae, obj, scope.Resource, scope.Subresource, scope.Serializer)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if values := req.URL.Query(); len(values) > 0 {
0000000000000000000000000000000000000000;;						if err := metainternalversion.ParameterCodec.DecodeParameters(values, scope.MetaGroupVersion, options); err != nil {
0000000000000000000000000000000000000000;;							err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;							scope.err(err, w, req)
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if admit != nil && admit.Handles(admission.Delete) {
0000000000000000000000000000000000000000;;				userInfo, _ := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = admit.Admit(admission.NewAttributesRecord(nil, nil, scope.Kind, namespace, name, scope.Resource, scope.Subresource, admission.Delete, userInfo))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			trace.Step("About to delete object from database")
0000000000000000000000000000000000000000;;			wasDeleted := true
0000000000000000000000000000000000000000;;			result, err := finishRequest(timeout, func() (runtime.Object, error) {
0000000000000000000000000000000000000000;;				obj, deleted, err := r.Delete(ctx, name, options)
0000000000000000000000000000000000000000;;				wasDeleted = deleted
0000000000000000000000000000000000000000;;				return obj, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Object deleted from database")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status := http.StatusOK
0000000000000000000000000000000000000000;;			// Return http.StatusAccepted if the resource was not deleted immediately and
0000000000000000000000000000000000000000;;			// user requested cascading deletion by setting OrphanDependents=false.
0000000000000000000000000000000000000000;;			// Note: We want to do this always if resource was not deleted immediately, but
0000000000000000000000000000000000000000;;			// that will break existing clients.
0000000000000000000000000000000000000000;;			// Other cases where resource is not instantly deleted are: namespace deletion
0000000000000000000000000000000000000000;;			// and pod graceful deletion.
0000000000000000000000000000000000000000;;			if !wasDeleted && options.OrphanDependents != nil && *options.OrphanDependents == false {
0000000000000000000000000000000000000000;;				status = http.StatusAccepted
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if the rest.Deleter returns a nil object, fill out a status. Callers may return a valid
0000000000000000000000000000000000000000;;			// object with the response.
0000000000000000000000000000000000000000;;			if result == nil {
0000000000000000000000000000000000000000;;				result = &metav1.Status{
0000000000000000000000000000000000000000;;					Status: metav1.StatusSuccess,
0000000000000000000000000000000000000000;;					Code:   int32(status),
0000000000000000000000000000000000000000;;					Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;						Name: name,
0000000000000000000000000000000000000000;;						Kind: scope.Kind.Kind,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// when a non-status response is returned, set the self link
0000000000000000000000000000000000000000;;				requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					scope.err(fmt.Errorf("missing requestInfo"), w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := result.(*metav1.Status); !ok {
0000000000000000000000000000000000000000;;					if err := setSelfLink(result, requestInfo, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;						scope.err(err, w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transformResponseObject(ctx, scope, req, w, status, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteCollection returns a function that will handle a collection deletion
0000000000000000000000000000000000000000;;	func DeleteCollection(r rest.CollectionDeleter, checkBody bool, scope RequestScope, admit admission.Interface) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			// TODO: we either want to remove timeout or document it (if we document, move timeout out of this function and declare it in api_installer)
0000000000000000000000000000000000000000;;			timeout := parseTimeout(req.URL.Query().Get("timeout"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			namespace, err := scope.Namer.Namespace(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;			ctx = request.WithNamespace(ctx, namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if admit != nil && admit.Handles(admission.Delete) {
0000000000000000000000000000000000000000;;				userInfo, _ := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = admit.Admit(admission.NewAttributesRecord(nil, nil, scope.Kind, namespace, "", scope.Resource, scope.Subresource, admission.Delete, userInfo))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			listOptions := metainternalversion.ListOptions{}
0000000000000000000000000000000000000000;;			if err := metainternalversion.ParameterCodec.DecodeParameters(req.URL.Query(), scope.MetaGroupVersion, &listOptions); err != nil {
0000000000000000000000000000000000000000;;				err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// transform fields
0000000000000000000000000000000000000000;;			// TODO: DecodeParametersInto should do this.
0000000000000000000000000000000000000000;;			if listOptions.FieldSelector != nil {
0000000000000000000000000000000000000000;;				fn := func(label, value string) (newLabel, newValue string, err error) {
0000000000000000000000000000000000000000;;					return scope.Convertor.ConvertFieldLabel(scope.Kind.GroupVersion().String(), scope.Kind.Kind, label, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if listOptions.FieldSelector, err = listOptions.FieldSelector.Transform(fn); err != nil {
0000000000000000000000000000000000000000;;					// TODO: allow bad request to set field causes based on query parameters
0000000000000000000000000000000000000000;;					err = errors.NewBadRequest(err.Error())
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			options := &metav1.DeleteOptions{}
0000000000000000000000000000000000000000;;			if checkBody {
0000000000000000000000000000000000000000;;				body, err := readBody(req)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					scope.err(err, w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(body) > 0 {
0000000000000000000000000000000000000000;;					s, err := negotiation.NegotiateInputSerializer(req, scope.Serializer)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						scope.err(err, w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defaultGVK := scope.Kind.GroupVersion().WithKind("DeleteOptions")
0000000000000000000000000000000000000000;;					obj, _, err := scope.Serializer.DecoderToVersion(s.Serializer, defaultGVK.GroupVersion()).Decode(body, &defaultGVK, options)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						scope.err(err, w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if obj != options {
0000000000000000000000000000000000000000;;						scope.err(fmt.Errorf("decoded object cannot be converted to DeleteOptions"), w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ae := request.AuditEventFrom(ctx)
0000000000000000000000000000000000000000;;					audit.LogRequestObject(ae, obj, scope.Resource, scope.Subresource, scope.Serializer)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result, err := finishRequest(timeout, func() (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return r.DeleteCollection(ctx, options, &listOptions)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				scope.err(err, w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if the rest.Deleter returns a nil object, fill out a status. Callers may return a valid
0000000000000000000000000000000000000000;;			// object with the response.
0000000000000000000000000000000000000000;;			if result == nil {
0000000000000000000000000000000000000000;;				result = &metav1.Status{
0000000000000000000000000000000000000000;;					Status: metav1.StatusSuccess,
0000000000000000000000000000000000000000;;					Code:   http.StatusOK,
0000000000000000000000000000000000000000;;					Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;						Kind: scope.Kind.Kind,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// when a non-status response is returned, set the self link
0000000000000000000000000000000000000000;;				if _, ok := result.(*metav1.Status); !ok {
0000000000000000000000000000000000000000;;					if _, err := setListSelfLink(result, ctx, req, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;						scope.err(err, w, req)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transformResponseObject(ctx, scope, req, w, http.StatusOK, result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resultFunc is a function that returns a rest result and can be run in a goroutine
0000000000000000000000000000000000000000;;	type resultFunc func() (runtime.Object, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finishRequest makes a given resultFunc asynchronous and handles errors returned by the response.
0000000000000000000000000000000000000000;;	// An api.Status object with status != success is considered an "error", which interrupts the normal response flow.
0000000000000000000000000000000000000000;;	func finishRequest(timeout time.Duration, fn resultFunc) (result runtime.Object, err error) {
0000000000000000000000000000000000000000;;		// these channels need to be buffered to prevent the goroutine below from hanging indefinitely
0000000000000000000000000000000000000000;;		// when the select statement reads something other than the one the goroutine sends on.
0000000000000000000000000000000000000000;;		ch := make(chan runtime.Object, 1)
0000000000000000000000000000000000000000;;		errCh := make(chan error, 1)
0000000000000000000000000000000000000000;;		panicCh := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// panics don't cross goroutine boundaries, so we have to handle ourselves
0000000000000000000000000000000000000000;;			defer utilruntime.HandleCrash(func(panicReason interface{}) {
0000000000000000000000000000000000000000;;				// Propagate to parent goroutine
0000000000000000000000000000000000000000;;				panicCh <- panicReason
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if result, err := fn(); err != nil {
0000000000000000000000000000000000000000;;				errCh <- err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ch <- result
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case result = <-ch:
0000000000000000000000000000000000000000;;			if status, ok := result.(*metav1.Status); ok {
0000000000000000000000000000000000000000;;				if status.Status != metav1.StatusSuccess {
0000000000000000000000000000000000000000;;					return nil, errors.FromObject(status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		case err = <-errCh:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		case p := <-panicCh:
0000000000000000000000000000000000000000;;			panic(p)
0000000000000000000000000000000000000000;;		case <-time.After(timeout):
0000000000000000000000000000000000000000;;			return nil, errors.NewTimeoutError("request did not complete within allowed duration", 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transformDecodeError adds additional information when a decode fails.
0000000000000000000000000000000000000000;;	func transformDecodeError(typer runtime.ObjectTyper, baseErr error, into runtime.Object, gvk *schema.GroupVersionKind, body []byte) error {
0000000000000000000000000000000000000000;;		objGVKs, _, err := typer.ObjectKinds(into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objGVK := objGVKs[0]
0000000000000000000000000000000000000000;;		if gvk != nil && len(gvk.Kind) > 0 {
0000000000000000000000000000000000000000;;			return errors.NewBadRequest(fmt.Sprintf("%s in version %q cannot be handled as a %s: %v", gvk.Kind, gvk.Version, objGVK.Kind, baseErr))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		summary := summarizeData(body, 30)
0000000000000000000000000000000000000000;;		return errors.NewBadRequest(fmt.Sprintf("the object provided is unrecognized (must be of type %s): %v (%s)", objGVK.Kind, baseErr, summary))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setSelfLink sets the self link of an object (or the child items in a list) to the base URL of the request
0000000000000000000000000000000000000000;;	// plus the path and query generated by the provided linkFunc
0000000000000000000000000000000000000000;;	func setSelfLink(obj runtime.Object, requestInfo *request.RequestInfo, namer ScopeNamer) error {
0000000000000000000000000000000000000000;;		// TODO: SelfLink generation should return a full URL?
0000000000000000000000000000000000000000;;		uri, err := namer.GenerateLink(requestInfo, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return namer.SetSelfLink(obj, uri)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasUID(obj runtime.Object) (bool, error) {
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, errors.NewInternalError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(accessor.GetUID()) == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkName checks the provided name against the request
0000000000000000000000000000000000000000;;	func checkName(obj runtime.Object, name, namespace string, namer ScopeNamer) error {
0000000000000000000000000000000000000000;;		objNamespace, objName, err := namer.ObjectName(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return errors.NewBadRequest(fmt.Sprintf(
0000000000000000000000000000000000000000;;				"the name of the object (%s based on URL) was undeterminable: %v", name, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if objName != name {
0000000000000000000000000000000000000000;;			return errors.NewBadRequest(fmt.Sprintf(
0000000000000000000000000000000000000000;;				"the name of the object (%s) does not match the name on the URL (%s)", objName, name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(namespace) > 0 {
0000000000000000000000000000000000000000;;			if len(objNamespace) > 0 && objNamespace != namespace {
0000000000000000000000000000000000000000;;				return errors.NewBadRequest(fmt.Sprintf(
0000000000000000000000000000000000000000;;					"the namespace of the object (%s) does not match the namespace on the request (%s)", objNamespace, namespace))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setListSelfLink sets the self link of a list to the base URL, then sets the self links
0000000000000000000000000000000000000000;;	// on all child objects returned. Returns the number of items in the list.
0000000000000000000000000000000000000000;;	func setListSelfLink(obj runtime.Object, ctx request.Context, req *http.Request, namer ScopeNamer) (int, error) {
0000000000000000000000000000000000000000;;		if !meta.IsListType(obj) {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri, err := namer.GenerateListLink(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := namer.SetSelfLink(obj, uri); err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Unable to set self link on object: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("missing requestInfo")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		err = meta.EachListItem(obj, func(obj runtime.Object) error {
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			return setSelfLink(obj, requestInfo, namer)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return count, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func summarizeData(data []byte, maxLength int) string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(data) == 0:
0000000000000000000000000000000000000000;;			return "<empty>"
0000000000000000000000000000000000000000;;		case data[0] == '{':
0000000000000000000000000000000000000000;;			if len(data) > maxLength {
0000000000000000000000000000000000000000;;				return string(data[:maxLength]) + " ..."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string(data)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if len(data) > maxLength {
0000000000000000000000000000000000000000;;				return hex.EncodeToString(data[:maxLength]) + " ..."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return hex.EncodeToString(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readBody(req *http.Request) ([]byte, error) {
0000000000000000000000000000000000000000;;		defer req.Body.Close()
0000000000000000000000000000000000000000;;		return ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseTimeout(str string) time.Duration {
0000000000000000000000000000000000000000;;		if str != "" {
0000000000000000000000000000000000000000;;			timeout, err := time.ParseDuration(str)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return timeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to parse %q: %v", str, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 30 * time.Second
0000000000000000000000000000000000000000;;	}
