0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d5e03522341ab0e7e8d60aea1becc5264b752c3a;pkg/genericapiserver/api/handlers/patch.go[pkg/genericapiserver/api/handlers/patch.go][staging/src/k8s.io/apiserver/pkg/endpoints/handlers/patch.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package handlers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// patchObjectJSON patches the <originalObject> with <patchJS> and stores
0000000000000000000000000000000000000000;;	// the result in <objToUpdate>.
0000000000000000000000000000000000000000;;	// Currently it also returns the original and patched objects serialized to
0000000000000000000000000000000000000000;;	// JSONs (this may not be needed once we can apply patches at the
0000000000000000000000000000000000000000;;	// map[string]interface{} level).
0000000000000000000000000000000000000000;;	func patchObjectJSON(
0000000000000000000000000000000000000000;;		patchType types.PatchType,
0000000000000000000000000000000000000000;;		codec runtime.Codec,
0000000000000000000000000000000000000000;;		originalObject runtime.Object,
0000000000000000000000000000000000000000;;		patchJS []byte,
0000000000000000000000000000000000000000;;		objToUpdate runtime.Object,
0000000000000000000000000000000000000000;;		versionedObj runtime.Object,
0000000000000000000000000000000000000000;;	) (originalObjJS []byte, patchedObjJS []byte, retErr error) {
0000000000000000000000000000000000000000;;		js, err := runtime.Encode(codec, originalObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		originalObjJS = js
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch patchType {
0000000000000000000000000000000000000000;;		case types.JSONPatchType:
0000000000000000000000000000000000000000;;			patchObj, err := jsonpatch.DecodePatch(patchJS)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if patchedObjJS, err = patchObj.Apply(originalObjJS); err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.MergePatchType:
0000000000000000000000000000000000000000;;			if patchedObjJS, err = jsonpatch.MergePatch(originalObjJS, patchJS); err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.StrategicMergePatchType:
0000000000000000000000000000000000000000;;			if patchedObjJS, err = strategicpatch.StrategicMergePatch(originalObjJS, patchJS, versionedObj); err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// only here as a safety net - go-restful filters content-type
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("unknown Content-Type header for patch: %v", patchType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, patchedObjJS, objToUpdate); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// strategicPatchObject applies a strategic merge patch of <patchJS> to
0000000000000000000000000000000000000000;;	// <originalObject> and stores the result in <objToUpdate>.
0000000000000000000000000000000000000000;;	// It additionally returns the map[string]interface{} representation of the
0000000000000000000000000000000000000000;;	// <originalObject> and <patchJS>.
0000000000000000000000000000000000000000;;	// NOTE: Both <originalObject> and <objToUpdate> are supposed to be versioned.
0000000000000000000000000000000000000000;;	func strategicPatchObject(
0000000000000000000000000000000000000000;;		codec runtime.Codec,
0000000000000000000000000000000000000000;;		defaulter runtime.ObjectDefaulter,
0000000000000000000000000000000000000000;;		originalObject runtime.Object,
0000000000000000000000000000000000000000;;		patchJS []byte,
0000000000000000000000000000000000000000;;		objToUpdate runtime.Object,
0000000000000000000000000000000000000000;;		versionedObj runtime.Object,
0000000000000000000000000000000000000000;;	) error {
0000000000000000000000000000000000000000;;		originalObjMap, err := unstructured.DefaultConverter.ToUnstructured(originalObject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(patchJS, &patchMap); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := applyPatchToObject(codec, defaulter, originalObjMap, patchMap, objToUpdate, versionedObj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyPatchToObject applies a strategic merge patch of <patchMap> to
0000000000000000000000000000000000000000;;	// <originalMap> and stores the result in <objToUpdate>.
0000000000000000000000000000000000000000;;	// NOTE: <objToUpdate> must be a versioned object.
0000000000000000000000000000000000000000;;	func applyPatchToObject(
0000000000000000000000000000000000000000;;		codec runtime.Codec,
0000000000000000000000000000000000000000;;		defaulter runtime.ObjectDefaulter,
0000000000000000000000000000000000000000;;		originalMap map[string]interface{},
0000000000000000000000000000000000000000;;		patchMap map[string]interface{},
0000000000000000000000000000000000000000;;		objToUpdate runtime.Object,
0000000000000000000000000000000000000000;;		versionedObj runtime.Object,
0000000000000000000000000000000000000000;;	) error {
0000000000000000000000000000000000000000;;		patchedObjMap, err := strategicpatch.StrategicMergeMapPatch(originalMap, patchMap, versionedObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rather than serialize the patched map to JSON, then decode it to an object, we go directly from a map to an object
0000000000000000000000000000000000000000;;		if err := unstructured.DefaultConverter.FromUnstructured(patchedObjMap, objToUpdate); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Decoding from JSON to a versioned object would apply defaults, so we do the same here
0000000000000000000000000000000000000000;;		defaulter.Default(objToUpdate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
