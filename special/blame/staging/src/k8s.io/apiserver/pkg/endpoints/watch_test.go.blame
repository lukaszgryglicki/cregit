0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
59b364beac7300fe1d44d59d6bc25cb7b38ef36c;pkg/apiserver/watch_test.go[pkg/apiserver/watch_test.go][staging/src/k8s.io/apiserver/pkg/endpoints/watch_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package endpoints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/streaming"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		example "k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apiserver/pkg/endpoints/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchJSON defines the expected JSON wire equivalent of watch.Event
0000000000000000000000000000000000000000;;	type watchJSON struct {
0000000000000000000000000000000000000000;;		Type   watch.EventType `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		Object json.RawMessage `json:"object,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// roundTripOrDie round trips an object to get defaults set.
0000000000000000000000000000000000000000;;	func roundTripOrDie(codec runtime.Codec, object runtime.Object) runtime.Object {
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(codec, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var watchTestTable = []struct {
0000000000000000000000000000000000000000;;		t   watch.EventType
0000000000000000000000000000000000000000;;		obj runtime.Object
0000000000000000000000000000000000000000;;	}{
0000000000000000000000000000000000000000;;		{watch.Added, &apitesting.Simple{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}},
0000000000000000000000000000000000000000;;		{watch.Modified, &apitesting.Simple{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}},
0000000000000000000000000000000000000000;;		{watch.Deleted, &apitesting.Simple{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podWatchTestTable() []struct {
0000000000000000000000000000000000000000;;		t   watch.EventType
0000000000000000000000000000000000000000;;		obj runtime.Object
0000000000000000000000000000000000000000;;	} {
0000000000000000000000000000000000000000;;		// creaze lazily here in a func because podWatchTestTable can only be used after all types are registered.
0000000000000000000000000000000000000000;;		return []struct {
0000000000000000000000000000000000000000;;			t   watch.EventType
0000000000000000000000000000000000000000;;			obj runtime.Object
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{watch.Added, roundTripOrDie(codec, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})},
0000000000000000000000000000000000000000;;			{watch.Modified, roundTripOrDie(codec, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}})},
0000000000000000000000000000000000000000;;			{watch.Deleted, roundTripOrDie(codec, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}})},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchWebsocket(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		_ = rest.Watcher(simpleStorage) // Give compile error if this doesn't work.
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Scheme = "ws" // Required by websocket, though the server never sees it.
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws, err := websocket.Dial(dest.String(), "", "http://localhost")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		try := func(action watch.EventType, object runtime.Object) {
0000000000000000000000000000000000000000;;			// Send
0000000000000000000000000000000000000000;;			simpleStorage.fakeWatch.Action(action, object)
0000000000000000000000000000000000000000;;			// Test receive
0000000000000000000000000000000000000000;;			var got watchJSON
0000000000000000000000000000000000000000;;			err := websocket.JSON.Receive(ws, &got)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if got.Type != action {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected type: %v", got.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gotObj, err := runtime.Decode(codec, got.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Decode error: %v\n%v", err, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := object, gotObj; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range watchTestTable {
0000000000000000000000000000000000000000;;			try(item.t, item.obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage.fakeWatch.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var got watchJSON
0000000000000000000000000000000000000000;;		err = websocket.JSON.Receive(ws, &got)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchWebsocketClientClose(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		_ = rest.Watcher(simpleStorage) // Give compile error if this doesn't work.
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Scheme = "ws" // Required by websocket, though the server never sees it.
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws, err := websocket.Dial(dest.String(), "", "http://localhost")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		try := func(action watch.EventType, object runtime.Object) {
0000000000000000000000000000000000000000;;			// Send
0000000000000000000000000000000000000000;;			simpleStorage.fakeWatch.Action(action, object)
0000000000000000000000000000000000000000;;			// Test receive
0000000000000000000000000000000000000000;;			var got watchJSON
0000000000000000000000000000000000000000;;			err := websocket.JSON.Receive(ws, &got)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if got.Type != action {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected type: %v", got.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gotObj, err := runtime.Decode(codec, got.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Decode error: %v\n%v", err, got)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := object, gotObj; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send/receive should work
0000000000000000000000000000000000000000;;		for _, item := range watchTestTable {
0000000000000000000000000000000000000000;;			try(item.t, item.obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sending normal data should be ignored
0000000000000000000000000000000000000000;;		websocket.JSON.Send(ws, map[string]interface{}{"test": "data"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send/receive should still work
0000000000000000000000000000000000000000;;		for _, item := range watchTestTable {
0000000000000000000000000000000000000000;;			try(item.t, item.obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Client requests a close
0000000000000000000000000000000000000000;;		ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case data, ok := <-simpleStorage.fakeWatch.ResultChan():
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				t.Errorf("expected a closed result channel, but got watch result %#v", data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(5 * time.Second):
0000000000000000000000000000000000000000;;			t.Errorf("watcher did not close when client closed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var got watchJSON
0000000000000000000000000000000000000000;;		err = websocket.JSON.Receive(ws, &got)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchRead(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		_ = rest.Watcher(simpleStorage) // Give compile error if this doesn't work.
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = "watch=1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		connectHTTP := func(accept string) (io.ReadCloser, string) {
0000000000000000000000000000000000000000;;			client := http.Client{}
0000000000000000000000000000000000000000;;			request, err := http.NewRequest("GET", dest.String(), nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			request.Header.Add("Accept", accept)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			response, err := client.Do(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				b, _ := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected response for accept: %q: %#v\n%s", accept, response, string(b))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return response.Body, response.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		connectWebSocket := func(accept string) (io.ReadCloser, string) {
0000000000000000000000000000000000000000;;			dest := *dest
0000000000000000000000000000000000000000;;			dest.Scheme = "ws" // Required by websocket, though the server never sees it.
0000000000000000000000000000000000000000;;			config, err := websocket.NewConfig(dest.String(), "http://localhost")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.Header.Add("Accept", accept)
0000000000000000000000000000000000000000;;			ws, err := websocket.DialConfig(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ws, "__default__"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Accept              string
0000000000000000000000000000000000000000;;			ExpectedContentType string
0000000000000000000000000000000000000000;;			MediaType           string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Accept:              "application/json",
0000000000000000000000000000000000000000;;				ExpectedContentType: "application/json",
0000000000000000000000000000000000000000;;				MediaType:           "application/json",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Accept:              "application/json;stream=watch",
0000000000000000000000000000000000000000;;				ExpectedContentType: "application/json", // legacy behavior
0000000000000000000000000000000000000000;;				MediaType:           "application/json",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// TODO: yaml stream serialization requires that RawExtension.MarshalJSON
0000000000000000000000000000000000000000;;			// be able to understand nested encoding (since yaml calls json.Marshal
0000000000000000000000000000000000000000;;			// rather than yaml.Marshal, which results in the raw bytes being in yaml).
0000000000000000000000000000000000000000;;			/*{
0000000000000000000000000000000000000000;;				Accept:              "application/yaml",
0000000000000000000000000000000000000000;;				ExpectedContentType: "application/yaml;stream=watch",
0000000000000000000000000000000000000000;;				MediaType:           "application/yaml",
0000000000000000000000000000000000000000;;			},*/
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Accept:              "application/vnd.kubernetes.protobuf",
0000000000000000000000000000000000000000;;				ExpectedContentType: "application/vnd.kubernetes.protobuf;stream=watch",
0000000000000000000000000000000000000000;;				MediaType:           "application/vnd.kubernetes.protobuf",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Accept:              "application/vnd.kubernetes.protobuf;stream=watch",
0000000000000000000000000000000000000000;;				ExpectedContentType: "application/vnd.kubernetes.protobuf;stream=watch",
0000000000000000000000000000000000000000;;				MediaType:           "application/vnd.kubernetes.protobuf",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		protocols := []struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			selfFraming bool
0000000000000000000000000000000000000000;;			fn          func(string) (io.ReadCloser, string)
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{name: "http", fn: connectHTTP},
0000000000000000000000000000000000000000;;			{name: "websocket", selfFraming: true, fn: connectWebSocket},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, protocol := range protocols {
0000000000000000000000000000000000000000;;			for _, test := range testCases {
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					info, ok := runtime.SerializerInfoForMediaType(codecs.SupportedMediaTypes(), test.MediaType)
0000000000000000000000000000000000000000;;					if !ok || info.StreamSerializer == nil {
0000000000000000000000000000000000000000;;						t.Fatal(info)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					streamSerializer := info.StreamSerializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					r, contentType := protocol.fn(test.Accept)
0000000000000000000000000000000000000000;;					defer r.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if contentType != "__default__" && contentType != test.ExpectedContentType {
0000000000000000000000000000000000000000;;						t.Errorf("Unexpected content type: %#v", contentType)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					objectCodec := codecs.DecoderToVersion(info.Serializer, testInternalGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var fr io.ReadCloser = r
0000000000000000000000000000000000000000;;					if !protocol.selfFraming {
0000000000000000000000000000000000000000;;						fr = streamSerializer.Framer.NewFrameReader(r)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					d := streaming.NewDecoder(fr, streamSerializer.Serializer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var w *watch.FakeWatcher
0000000000000000000000000000000000000000;;					for w == nil {
0000000000000000000000000000000000000000;;						w = simpleStorage.Watcher()
0000000000000000000000000000000000000000;;						time.Sleep(time.Millisecond)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for i, item := range podWatchTestTable() {
0000000000000000000000000000000000000000;;						action, object := item.t, item.obj
0000000000000000000000000000000000000000;;						name := fmt.Sprintf("%s-%s-%d", protocol.name, test.MediaType, i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Send
0000000000000000000000000000000000000000;;						w.Action(action, object)
0000000000000000000000000000000000000000;;						// Test receive
0000000000000000000000000000000000000000;;						var got metav1.WatchEvent
0000000000000000000000000000000000000000;;						_, _, err := d.Decode(nil, &got)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: Unexpected error: %v", name, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if got.Type != string(action) {
0000000000000000000000000000000000000000;;							t.Errorf("%s: Unexpected type: %v", name, got.Type)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						gotObj, err := runtime.Decode(objectCodec, got.Object.Raw)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: Decode error: %v", name, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if e, a := object, gotObj; !apiequality.Semantic.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;							t.Errorf("%s: different: %s", name, diff.ObjectDiff(e, a))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var got metav1.WatchEvent
0000000000000000000000000000000000000000;;					_, _, err := d.Decode(nil, &got)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("Unexpected non-error")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchHTTPAccept(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("GET", dest.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request.Header.Set("Accept", "application/XYZ")
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: once this is fixed, this test will change
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusNotAcceptable {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchParamParsing(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simples":     simpleStorage,
0000000000000000000000000000000000000000;;			"simpleroots": simpleStorage,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootPath := "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		namespacedPath := "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/namespaces/other/simpleroots"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			path            string
0000000000000000000000000000000000000000;;			rawQuery        string
0000000000000000000000000000000000000000;;			resourceVersion string
0000000000000000000000000000000000000000;;			labelSelector   string
0000000000000000000000000000000000000000;;			fieldSelector   string
0000000000000000000000000000000000000000;;			namespace       string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:            rootPath,
0000000000000000000000000000000000000000;;				rawQuery:        "resourceVersion=1234",
0000000000000000000000000000000000000000;;				resourceVersion: "1234",
0000000000000000000000000000000000000000;;				labelSelector:   "",
0000000000000000000000000000000000000000;;				fieldSelector:   "",
0000000000000000000000000000000000000000;;				namespace:       metav1.NamespaceAll,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				path:            rootPath,
0000000000000000000000000000000000000000;;				rawQuery:        "resourceVersion=314159&fieldSelector=Host%3D&labelSelector=name%3Dfoo",
0000000000000000000000000000000000000000;;				resourceVersion: "314159",
0000000000000000000000000000000000000000;;				labelSelector:   "name=foo",
0000000000000000000000000000000000000000;;				fieldSelector:   "Host=",
0000000000000000000000000000000000000000;;				namespace:       metav1.NamespaceAll,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				path:            rootPath,
0000000000000000000000000000000000000000;;				rawQuery:        "fieldSelector=id%3dfoo&resourceVersion=1492",
0000000000000000000000000000000000000000;;				resourceVersion: "1492",
0000000000000000000000000000000000000000;;				labelSelector:   "",
0000000000000000000000000000000000000000;;				fieldSelector:   "id=foo",
0000000000000000000000000000000000000000;;				namespace:       metav1.NamespaceAll,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				path:            rootPath,
0000000000000000000000000000000000000000;;				rawQuery:        "",
0000000000000000000000000000000000000000;;				resourceVersion: "",
0000000000000000000000000000000000000000;;				labelSelector:   "",
0000000000000000000000000000000000000000;;				fieldSelector:   "",
0000000000000000000000000000000000000000;;				namespace:       metav1.NamespaceAll,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				path:            namespacedPath,
0000000000000000000000000000000000000000;;				rawQuery:        "resourceVersion=1234",
0000000000000000000000000000000000000000;;				resourceVersion: "1234",
0000000000000000000000000000000000000000;;				labelSelector:   "",
0000000000000000000000000000000000000000;;				fieldSelector:   "",
0000000000000000000000000000000000000000;;				namespace:       "other",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				path:            namespacedPath,
0000000000000000000000000000000000000000;;				rawQuery:        "resourceVersion=314159&fieldSelector=Host%3D&labelSelector=name%3Dfoo",
0000000000000000000000000000000000000000;;				resourceVersion: "314159",
0000000000000000000000000000000000000000;;				labelSelector:   "name=foo",
0000000000000000000000000000000000000000;;				fieldSelector:   "Host=",
0000000000000000000000000000000000000000;;				namespace:       "other",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				path:            namespacedPath,
0000000000000000000000000000000000000000;;				rawQuery:        "fieldSelector=id%3dfoo&resourceVersion=1492",
0000000000000000000000000000000000000000;;				resourceVersion: "1492",
0000000000000000000000000000000000000000;;				labelSelector:   "",
0000000000000000000000000000000000000000;;				fieldSelector:   "id=foo",
0000000000000000000000000000000000000000;;				namespace:       "other",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				path:            namespacedPath,
0000000000000000000000000000000000000000;;				rawQuery:        "",
0000000000000000000000000000000000000000;;				resourceVersion: "",
0000000000000000000000000000000000000000;;				labelSelector:   "",
0000000000000000000000000000000000000000;;				fieldSelector:   "",
0000000000000000000000000000000000000000;;				namespace:       "other",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			simpleStorage.requestedLabelSelector = labels.Everything()
0000000000000000000000000000000000000000;;			simpleStorage.requestedFieldSelector = fields.Everything()
0000000000000000000000000000000000000000;;			simpleStorage.requestedResourceVersion = "5" // Prove this is set in all cases
0000000000000000000000000000000000000000;;			simpleStorage.requestedResourceNamespace = ""
0000000000000000000000000000000000000000;;			dest.Path = item.path
0000000000000000000000000000000000000000;;			dest.RawQuery = item.rawQuery
0000000000000000000000000000000000000000;;			resp, err := http.Get(dest.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", item.rawQuery, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;			if e, a := item.namespace, simpleStorage.requestedResourceNamespace; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", item.rawQuery, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.resourceVersion, simpleStorage.requestedResourceVersion; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", item.rawQuery, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.labelSelector, simpleStorage.requestedLabelSelector.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", item.rawQuery, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.fieldSelector, simpleStorage.requestedFieldSelector.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", item.rawQuery, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchProtocolSelection(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		defer server.CloseClientConnections()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			isWebsocket bool
0000000000000000000000000000000000000000;;			connHeader  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{true, "Upgrade"},
0000000000000000000000000000000000000000;;			{true, "keep-alive, Upgrade"},
0000000000000000000000000000000000000000;;			{true, "upgrade"},
0000000000000000000000000000000000000000;;			{false, "keep-alive"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			request, err := http.NewRequest("GET", dest.String(), nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			request.Header.Set("Connection", item.connHeader)
0000000000000000000000000000000000000000;;			request.Header.Set("Upgrade", "websocket")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			response, err := client.Do(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The requests recognized as websocket requests based on connection
0000000000000000000000000000000000000000;;			// and upgrade headers will not also have the necessary Sec-Websocket-*
0000000000000000000000000000000000000000;;			// headers so it is expected to throw a 400
0000000000000000000000000000000000000000;;			if item.isWebsocket && response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !item.isWebsocket && response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeTimeoutFactory struct {
0000000000000000000000000000000000000000;;		timeoutCh chan time.Time
0000000000000000000000000000000000000000;;		done      chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *fakeTimeoutFactory) TimeoutCh() (<-chan time.Time, func() bool) {
0000000000000000000000000000000000000000;;		return t.timeoutCh, func() bool {
0000000000000000000000000000000000000000;;			defer close(t.done)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchHTTPTimeout(t *testing.T) {
0000000000000000000000000000000000000000;;		watcher := watch.NewFake()
0000000000000000000000000000000000000000;;		timeoutCh := make(chan time.Time)
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, ok := runtime.SerializerInfoForMediaType(codecs.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		if !ok || info.StreamSerializer == nil {
0000000000000000000000000000000000000000;;			t.Fatal(info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serializer := info.StreamSerializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup a new watchserver
0000000000000000000000000000000000000000;;		watchServer := &handlers.WatchServer{
0000000000000000000000000000000000000000;;			Watching: watcher,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			MediaType:       "testcase/json",
0000000000000000000000000000000000000000;;			Framer:          serializer.Framer,
0000000000000000000000000000000000000000;;			Encoder:         newCodec,
0000000000000000000000000000000000000000;;			EmbeddedEncoder: newCodec,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Fixup:          func(obj runtime.Object) {},
0000000000000000000000000000000000000000;;			TimeoutFactory: &fakeTimeoutFactory{timeoutCh, done},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			watchServer.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup a client
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(s.URL)
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/simple"
0000000000000000000000000000000000000000;;		dest.RawQuery = "watch=true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest("GET", dest.String(), nil)
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		watcher.Add(&apitesting.Simple{TypeMeta: metav1.TypeMeta{APIVersion: newGroupVersion.String()}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we can actually watch an endpoint
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(resp.Body)
0000000000000000000000000000000000000000;;		var got watchJSON
0000000000000000000000000000000000000000;;		err = decoder.Decode(&got)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Timeout and check for leaks
0000000000000000000000000000000000000000;;		close(timeoutCh)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;			if !watcher.Stopped {
0000000000000000000000000000000000000000;;				t.Errorf("Leaked watch on timeout")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("Failed to stop watcher after %s of timeout signal", wait.ForeverTestTimeout.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we can't receive any more events through the timeout watch
0000000000000000000000000000000000000000;;		err = decoder.Decode(&got)
0000000000000000000000000000000000000000;;		if err != io.EOF {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkWatchHTTP measures the cost of serving a watch.
0000000000000000000000000000000000000000;;	func BenchmarkWatchHTTP(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("GET", dest.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			b.Fatalf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer response.Body.Close()
0000000000000000000000000000000000000000;;			if _, err := io.Copy(ioutil.Discard, response.Body); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions := []watch.EventType{watch.Added, watch.Modified, watch.Deleted}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			simpleStorage.fakeWatch.Action(actions[i%len(actions)], &items[i%len(items)])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage.fakeWatch.Stop()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkWatchWebsocket measures the cost of serving a watch.
0000000000000000000000000000000000000000;;	func BenchmarkWatchWebsocket(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Scheme = "ws" // Required by websocket, though the server never sees it.
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws, err := websocket.Dial(dest.String(), "", "http://localhost")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer ws.Close()
0000000000000000000000000000000000000000;;			if _, err := io.Copy(ioutil.Discard, ws); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions := []watch.EventType{watch.Added, watch.Modified, watch.Deleted}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			simpleStorage.fakeWatch.Action(actions[i%len(actions)], &items[i%len(items)])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage.fakeWatch.Stop()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkWatchProtobuf measures the cost of serving a watch.
0000000000000000000000000000000000000000;;	func BenchmarkWatchProtobuf(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/watch/simples"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("GET", dest.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request.Header.Set("Accept", "application/vnd.kubernetes.protobuf")
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			body, _ := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;			b.Fatalf("Unexpected response %#v\n%s", response, body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer response.Body.Close()
0000000000000000000000000000000000000000;;			if _, err := io.Copy(ioutil.Discard, response.Body); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actions := []watch.EventType{watch.Added, watch.Modified, watch.Deleted}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			simpleStorage.fakeWatch.Action(actions[i%len(actions)], &items[i%len(items)])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage.fakeWatch.Stop()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
