0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
8219ab6bca57826e5661ea96ff278e8367b102cf;pkg/auth/handlers/handlers.go[pkg/auth/handlers/handlers.go][staging/src/k8s.io/apiserver/pkg/endpoints/filters/authentication.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		authenticatedUserCounter = prometheus.NewCounterVec(
0000000000000000000000000000000000000000;;			prometheus.CounterOpts{
0000000000000000000000000000000000000000;;				Name: "authenticated_user_requests",
0000000000000000000000000000000000000000;;				Help: "Counter of authenticated requests broken out by username.",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			[]string{"username"},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		prometheus.MustRegister(authenticatedUserCounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithAuthentication creates an http handler that tries to authenticate the given request as a user, and then
0000000000000000000000000000000000000000;;	// stores any such user found onto the provided context for the request. If authentication fails or returns an error
0000000000000000000000000000000000000000;;	// the failed handler is used. On success, "Authorization" header is removed from the request and handler
0000000000000000000000000000000000000000;;	// is invoked to serve the request.
0000000000000000000000000000000000000000;;	func WithAuthentication(handler http.Handler, mapper genericapirequest.RequestContextMapper, auth authenticator.Request, failed http.Handler) http.Handler {
0000000000000000000000000000000000000000;;		if auth == nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Authentication is disabled")
0000000000000000000000000000000000000000;;			return handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return genericapirequest.WithRequestContext(
0000000000000000000000000000000000000000;;			http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				user, ok, err := auth.AuthenticateRequest(req)
0000000000000000000000000000000000000000;;				if err != nil || !ok {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("Unable to authenticate the request due to an error: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					failed.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// authorization header is not required anymore in case of a successful authentication.
0000000000000000000000000000000000000000;;				req.Header.Del("Authorization")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ctx, ok := mapper.Get(req); ok {
0000000000000000000000000000000000000000;;					mapper.Update(req, genericapirequest.WithUser(ctx, user))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				authenticatedUserCounter.WithLabelValues(compressUsername(user.GetName())).Inc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			mapper,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Unauthorized(requestContextMapper request.RequestContextMapper, s runtime.NegotiatedSerializer, supportsBasicAuth bool) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			if supportsBasicAuth {
0000000000000000000000000000000000000000;;				w.Header().Set("WWW-Authenticate", `Basic realm="kubernetes-master"`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx, ok := requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("no context found for request"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestInfo, found := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("no RequestInfo found in the context"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gv := schema.GroupVersion{Group: requestInfo.APIGroup, Version: requestInfo.APIVersion}
0000000000000000000000000000000000000000;;			responsewriters.ErrorNegotiated(ctx, apierrors.NewUnauthorized("Unauthorized"), s, gv, w, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compressUsername maps all possible usernames onto a small set of categories
0000000000000000000000000000000000000000;;	// of usernames. This is done both to limit the cardinality of the
0000000000000000000000000000000000000000;;	// authorized_user_requests metric, and to avoid pushing actual usernames in the
0000000000000000000000000000000000000000;;	// metric.
0000000000000000000000000000000000000000;;	func compressUsername(username string) string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// Known internal identities.
0000000000000000000000000000000000000000;;		case username == "admin" ||
0000000000000000000000000000000000000000;;			username == "client" ||
0000000000000000000000000000000000000000;;			username == "kube_proxy" ||
0000000000000000000000000000000000000000;;			username == "kubelet" ||
0000000000000000000000000000000000000000;;			username == "system:serviceaccount:kube-system:default":
0000000000000000000000000000000000000000;;			return username
0000000000000000000000000000000000000000;;		// Probably an email address.
0000000000000000000000000000000000000000;;		case strings.Contains(username, "@"):
0000000000000000000000000000000000000000;;			return "email_id"
0000000000000000000000000000000000000000;;		// Anything else (custom service accounts, custom external identities, etc.)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "other"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
