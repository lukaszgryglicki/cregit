0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
562f8c88c74b3ca9193b5447ba460f136f8e64ae;pkg/apiserver/api_installer.go[pkg/apiserver/api_installer.go][staging/src/k8s.io/apiserver/pkg/endpoints/installer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package endpoints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		gpath "path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful "github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/negotiation"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/metrics"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		genericfilters "k8s.io/apiserver/pkg/server/filters"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ROUTE_META_GVK    = "x-kubernetes-group-version-kind"
0000000000000000000000000000000000000000;;		ROUTE_META_ACTION = "x-kubernetes-action"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type APIInstaller struct {
0000000000000000000000000000000000000000;;		group                        *APIGroupVersion
0000000000000000000000000000000000000000;;		prefix                       string // Path prefix where API resources are to be registered.
0000000000000000000000000000000000000000;;		minRequestTimeout            time.Duration
0000000000000000000000000000000000000000;;		enableAPIResponseCompression bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Struct capturing information about an action ("GET", "POST", "WATCH", "PROXY", etc).
0000000000000000000000000000000000000000;;	type action struct {
0000000000000000000000000000000000000000;;		Verb          string               // Verb identifying the action ("GET", "POST", "WATCH", "PROXY", etc).
0000000000000000000000000000000000000000;;		Path          string               // The path of the action
0000000000000000000000000000000000000000;;		Params        []*restful.Parameter // List of parameters associated with the action.
0000000000000000000000000000000000000000;;		Namer         handlers.ScopeNamer
0000000000000000000000000000000000000000;;		AllNamespaces bool // true iff the action is namespaced but works on aggregate result for all namespaces
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An interface to see if an object supports swagger documentation as a method
0000000000000000000000000000000000000000;;	type documentable interface {
0000000000000000000000000000000000000000;;		SwaggerDoc() map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toDiscoveryKubeVerb maps an action.Verb to the logical kube verb, used for discovery
0000000000000000000000000000000000000000;;	var toDiscoveryKubeVerb = map[string]string{
0000000000000000000000000000000000000000;;		"CONNECT":          "", // do not list in discovery.
0000000000000000000000000000000000000000;;		"DELETE":           "delete",
0000000000000000000000000000000000000000;;		"DELETECOLLECTION": "deletecollection",
0000000000000000000000000000000000000000;;		"GET":              "get",
0000000000000000000000000000000000000000;;		"LIST":             "list",
0000000000000000000000000000000000000000;;		"PATCH":            "patch",
0000000000000000000000000000000000000000;;		"POST":             "create",
0000000000000000000000000000000000000000;;		"PROXY":            "proxy",
0000000000000000000000000000000000000000;;		"PUT":              "update",
0000000000000000000000000000000000000000;;		"WATCH":            "watch",
0000000000000000000000000000000000000000;;		"WATCHLIST":        "watch",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Installs handlers for API resources.
0000000000000000000000000000000000000000;;	func (a *APIInstaller) Install(ws *restful.WebService) (apiResources []metav1.APIResource, errors []error) {
0000000000000000000000000000000000000000;;		errors = make([]error, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyHandler := (&handlers.ProxyHandler{
0000000000000000000000000000000000000000;;			Prefix:     a.prefix + "/proxy/",
0000000000000000000000000000000000000000;;			Storage:    a.group.Storage,
0000000000000000000000000000000000000000;;			Serializer: a.group.Serializer,
0000000000000000000000000000000000000000;;			Mapper:     a.group.Context,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register the paths in a deterministic (sorted) order to get a deterministic swagger spec.
0000000000000000000000000000000000000000;;		paths := make([]string, len(a.group.Storage))
0000000000000000000000000000000000000000;;		var i int = 0
0000000000000000000000000000000000000000;;		for path := range a.group.Storage {
0000000000000000000000000000000000000000;;			paths[i] = path
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(paths)
0000000000000000000000000000000000000000;;		for _, path := range paths {
0000000000000000000000000000000000000000;;			apiResource, err := a.registerResourceHandlers(path, a.group.Storage[path], ws, proxyHandler)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, fmt.Errorf("error in registering resource: %s, %v", path, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if apiResource != nil {
0000000000000000000000000000000000000000;;				apiResources = append(apiResources, *apiResource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return apiResources, errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWebService creates a new restful webservice with the api installer's prefix and version.
0000000000000000000000000000000000000000;;	func (a *APIInstaller) NewWebService() *restful.WebService {
0000000000000000000000000000000000000000;;		ws := new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.Path(a.prefix)
0000000000000000000000000000000000000000;;		// a.prefix contains "prefix/group/version"
0000000000000000000000000000000000000000;;		ws.Doc("API at " + a.prefix)
0000000000000000000000000000000000000000;;		// Backwards compatibility, we accepted objects with empty content-type at V1.
0000000000000000000000000000000000000000;;		// If we stop using go-restful, we can default empty content-type to application/json on an
0000000000000000000000000000000000000000;;		// endpoint by endpoint basis
0000000000000000000000000000000000000000;;		ws.Consumes("*/*")
0000000000000000000000000000000000000000;;		mediaTypes, streamMediaTypes := negotiation.MediaTypesForSerializer(a.group.Serializer)
0000000000000000000000000000000000000000;;		ws.Produces(append(mediaTypes, streamMediaTypes...)...)
0000000000000000000000000000000000000000;;		ws.ApiVersion(a.group.GroupVersion.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ws
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getResourceKind returns the external group version kind registered for the given storage
0000000000000000000000000000000000000000;;	// object. If the storage object is a subresource and has an override supplied for it, it returns
0000000000000000000000000000000000000000;;	// the group version kind supplied in the override.
0000000000000000000000000000000000000000;;	func (a *APIInstaller) getResourceKind(path string, storage rest.Storage) (schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		if fqKindToRegister, ok := a.group.SubresourceGroupVersionKind[path]; ok {
0000000000000000000000000000000000000000;;			return fqKindToRegister, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		object := storage.New()
0000000000000000000000000000000000000000;;		fqKinds, _, err := a.group.Typer.ObjectKinds(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a given go type can have multiple potential fully qualified kinds.  Find the one that corresponds with the group
0000000000000000000000000000000000000000;;		// we're trying to register here
0000000000000000000000000000000000000000;;		fqKindToRegister := schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		for _, fqKind := range fqKinds {
0000000000000000000000000000000000000000;;			if fqKind.Group == a.group.GroupVersion.Group {
0000000000000000000000000000000000000000;;				fqKindToRegister = a.group.GroupVersion.WithKind(fqKind.Kind)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: keep rid of extensions api group dependency here
0000000000000000000000000000000000000000;;			// This keeps it doing what it was doing before, but it doesn't feel right.
0000000000000000000000000000000000000000;;			if fqKind.Group == "extensions" && fqKind.Kind == "ThirdPartyResourceData" {
0000000000000000000000000000000000000000;;				fqKindToRegister = a.group.GroupVersion.WithKind(fqKind.Kind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fqKindToRegister.Empty() {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}, fmt.Errorf("unable to locate fully qualified kind for %v: found %v when registering for %v", reflect.TypeOf(object), fqKinds, a.group.GroupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fqKindToRegister, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// restMapping returns rest mapper for the resource.
0000000000000000000000000000000000000000;;	// Example REST paths that this mapper maps.
0000000000000000000000000000000000000000;;	// 1. Resource only, no subresource:
0000000000000000000000000000000000000000;;	//      Resource Type:    batch/v1.Job (input args: resource = "jobs")
0000000000000000000000000000000000000000;;	//      REST path:        /apis/batch/v1/namespaces/{namespace}/job/{name}
0000000000000000000000000000000000000000;;	// 2. Subresource and its parent belong to different API groups and/or versions:
0000000000000000000000000000000000000000;;	//      Resource Type:    extensions/v1beta1.ReplicaSet (input args: resource = "replicasets")
0000000000000000000000000000000000000000;;	//      Subresource Type: autoscaling/v1.Scale
0000000000000000000000000000000000000000;;	//      REST path:        /apis/extensions/v1beta1/namespaces/{namespace}/replicaset/{name}/scale
0000000000000000000000000000000000000000;;	func (a *APIInstaller) restMapping(resource string) (*meta.RESTMapping, error) {
0000000000000000000000000000000000000000;;		// subresources must have parent resources, and follow the namespacing rules of their parent.
0000000000000000000000000000000000000000;;		// So get the storage of the resource (which is the parent resource in case of subresources)
0000000000000000000000000000000000000000;;		storage, ok := a.group.Storage[resource]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to locate the storage object for resource: %s", resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fqKindToRegister, err := a.getResourceKind(resource, storage)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to locate fully qualified kind for mapper resource %s: %v", resource, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.group.Mapper.RESTMapping(fqKindToRegister.GroupKind(), fqKindToRegister.Version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *APIInstaller) registerResourceHandlers(path string, storage rest.Storage, ws *restful.WebService, proxyHandler http.Handler) (*metav1.APIResource, error) {
0000000000000000000000000000000000000000;;		admit := a.group.Admit
0000000000000000000000000000000000000000;;		context := a.group.Context
0000000000000000000000000000000000000000;;		if context == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%v missing Context", a.group.GroupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optionsExternalVersion := a.group.GroupVersion
0000000000000000000000000000000000000000;;		if a.group.OptionsExternalVersion != nil {
0000000000000000000000000000000000000000;;			optionsExternalVersion = *a.group.OptionsExternalVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resource, subresource, err := splitSubresource(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping, err := a.restMapping(resource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fqKindToRegister, err := a.getResourceKind(path, storage)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionedPtr, err := a.group.Creater.New(fqKindToRegister)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultVersionedObject := indirectArbitraryPointer(versionedPtr)
0000000000000000000000000000000000000000;;		kind := fqKindToRegister.Kind
0000000000000000000000000000000000000000;;		hasSubresource := len(subresource) > 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// what verbs are supported by the storage, used to know what verbs we support per path
0000000000000000000000000000000000000000;;		creater, isCreater := storage.(rest.Creater)
0000000000000000000000000000000000000000;;		namedCreater, isNamedCreater := storage.(rest.NamedCreater)
0000000000000000000000000000000000000000;;		lister, isLister := storage.(rest.Lister)
0000000000000000000000000000000000000000;;		getter, isGetter := storage.(rest.Getter)
0000000000000000000000000000000000000000;;		getterWithOptions, isGetterWithOptions := storage.(rest.GetterWithOptions)
0000000000000000000000000000000000000000;;		deleter, isDeleter := storage.(rest.Deleter)
0000000000000000000000000000000000000000;;		gracefulDeleter, isGracefulDeleter := storage.(rest.GracefulDeleter)
0000000000000000000000000000000000000000;;		collectionDeleter, isCollectionDeleter := storage.(rest.CollectionDeleter)
0000000000000000000000000000000000000000;;		updater, isUpdater := storage.(rest.Updater)
0000000000000000000000000000000000000000;;		patcher, isPatcher := storage.(rest.Patcher)
0000000000000000000000000000000000000000;;		watcher, isWatcher := storage.(rest.Watcher)
0000000000000000000000000000000000000000;;		_, isRedirector := storage.(rest.Redirector)
0000000000000000000000000000000000000000;;		connecter, isConnecter := storage.(rest.Connecter)
0000000000000000000000000000000000000000;;		storageMeta, isMetadata := storage.(rest.StorageMetadata)
0000000000000000000000000000000000000000;;		if !isMetadata {
0000000000000000000000000000000000000000;;			storageMeta = defaultStorageMetadata{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exporter, isExporter := storage.(rest.Exporter)
0000000000000000000000000000000000000000;;		if !isExporter {
0000000000000000000000000000000000000000;;			exporter = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionedExportOptions, err := a.group.Creater.New(optionsExternalVersion.WithKind("ExportOptions"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isNamedCreater {
0000000000000000000000000000000000000000;;			isCreater = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var versionedList interface{}
0000000000000000000000000000000000000000;;		if isLister {
0000000000000000000000000000000000000000;;			list := lister.NewList()
0000000000000000000000000000000000000000;;			listGVKs, _, err := a.group.Typer.ObjectKinds(list)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			versionedListPtr, err := a.group.Creater.New(a.group.GroupVersion.WithKind(listGVKs[0].Kind))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			versionedList = indirectArbitraryPointer(versionedListPtr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionedListOptions, err := a.group.Creater.New(optionsExternalVersion.WithKind("ListOptions"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var versionedDeleteOptions runtime.Object
0000000000000000000000000000000000000000;;		var versionedDeleterObject interface{}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isGracefulDeleter:
0000000000000000000000000000000000000000;;			versionedDeleteOptions, err = a.group.Creater.New(optionsExternalVersion.WithKind("DeleteOptions"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			versionedDeleterObject = indirectArbitraryPointer(versionedDeleteOptions)
0000000000000000000000000000000000000000;;			isDeleter = true
0000000000000000000000000000000000000000;;		case isDeleter:
0000000000000000000000000000000000000000;;			gracefulDeleter = rest.GracefulDeleteAdapter{Deleter: deleter}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionedStatusPtr, err := a.group.Creater.New(optionsExternalVersion.WithKind("Status"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionedStatus := indirectArbitraryPointer(versionedStatusPtr)
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			getOptions             runtime.Object
0000000000000000000000000000000000000000;;			versionedGetOptions    runtime.Object
0000000000000000000000000000000000000000;;			getOptionsInternalKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;			getSubpath             bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if isGetterWithOptions {
0000000000000000000000000000000000000000;;			getOptions, getSubpath, _ = getterWithOptions.NewGetOptions()
0000000000000000000000000000000000000000;;			getOptionsInternalKinds, _, err := a.group.Typer.ObjectKinds(getOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			getOptionsInternalKind = getOptionsInternalKinds[0]
0000000000000000000000000000000000000000;;			versionedGetOptions, err = a.group.Creater.New(optionsExternalVersion.WithKind(getOptionsInternalKind.Kind))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			isGetter = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var versionedWatchEvent interface{}
0000000000000000000000000000000000000000;;		if isWatcher {
0000000000000000000000000000000000000000;;			versionedWatchEventPtr, err := a.group.Creater.New(a.group.GroupVersion.WithKind("WatchEvent"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			versionedWatchEvent = indirectArbitraryPointer(versionedWatchEventPtr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			connectOptions             runtime.Object
0000000000000000000000000000000000000000;;			versionedConnectOptions    runtime.Object
0000000000000000000000000000000000000000;;			connectOptionsInternalKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;			connectSubpath             bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if isConnecter {
0000000000000000000000000000000000000000;;			connectOptions, connectSubpath, _ = connecter.NewConnectOptions()
0000000000000000000000000000000000000000;;			if connectOptions != nil {
0000000000000000000000000000000000000000;;				connectOptionsInternalKinds, _, err := a.group.Typer.ObjectKinds(connectOptions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				connectOptionsInternalKind = connectOptionsInternalKinds[0]
0000000000000000000000000000000000000000;;				versionedConnectOptions, err = a.group.Creater.New(optionsExternalVersion.WithKind(connectOptionsInternalKind.Kind))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ctxFn handlers.ContextFunc
0000000000000000000000000000000000000000;;		ctxFn = func(req *http.Request) request.Context {
0000000000000000000000000000000000000000;;			if ctx, ok := context.Get(req); ok {
0000000000000000000000000000000000000000;;				return request.WithUserAgent(ctx, req.Header.Get("User-Agent"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return request.WithUserAgent(request.NewContext(), req.Header.Get("User-Agent"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowWatchList := isWatcher && isLister // watching on lists is allowed only for kinds that support both watch and list.
0000000000000000000000000000000000000000;;		scope := mapping.Scope
0000000000000000000000000000000000000000;;		nameParam := ws.PathParameter("name", "name of the "+kind).DataType("string")
0000000000000000000000000000000000000000;;		pathParam := ws.PathParameter("path", "path to the resource").DataType("string")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := []*restful.Parameter{}
0000000000000000000000000000000000000000;;		actions := []action{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resourceKind string
0000000000000000000000000000000000000000;;		kindProvider, ok := storage.(rest.KindProvider)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			resourceKind = kindProvider.Kind()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			resourceKind = kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var shortNames []string
0000000000000000000000000000000000000000;;		shortNamesProvider, ok := storage.(rest.ShortNamesProvider)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			shortNames = shortNamesProvider.ShortNames()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tableProvider, _ := storage.(rest.TableConvertor)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var categories []string
0000000000000000000000000000000000000000;;		categoriesProvider, ok := storage.(rest.CategoriesProvider)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			categories = categoriesProvider.Categories()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var apiResource metav1.APIResource
0000000000000000000000000000000000000000;;		// Get the list of actions for the given scope.
0000000000000000000000000000000000000000;;		switch scope.Name() {
0000000000000000000000000000000000000000;;		case meta.RESTScopeNameRoot:
0000000000000000000000000000000000000000;;			// Handle non-namespace scoped resources like nodes.
0000000000000000000000000000000000000000;;			resourcePath := resource
0000000000000000000000000000000000000000;;			resourceParams := params
0000000000000000000000000000000000000000;;			itemPath := resourcePath + "/{name}"
0000000000000000000000000000000000000000;;			nameParams := append(params, nameParam)
0000000000000000000000000000000000000000;;			proxyParams := append(nameParams, pathParam)
0000000000000000000000000000000000000000;;			suffix := ""
0000000000000000000000000000000000000000;;			if hasSubresource {
0000000000000000000000000000000000000000;;				suffix = "/" + subresource
0000000000000000000000000000000000000000;;				itemPath = itemPath + suffix
0000000000000000000000000000000000000000;;				resourcePath = itemPath
0000000000000000000000000000000000000000;;				resourceParams = nameParams
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			apiResource.Name = path
0000000000000000000000000000000000000000;;			apiResource.Namespaced = false
0000000000000000000000000000000000000000;;			apiResource.Kind = resourceKind
0000000000000000000000000000000000000000;;			namer := handlers.ContextBasedNaming{
0000000000000000000000000000000000000000;;				GetContext:         ctxFn,
0000000000000000000000000000000000000000;;				SelfLinker:         a.group.Linker,
0000000000000000000000000000000000000000;;				ClusterScoped:      true,
0000000000000000000000000000000000000000;;				SelfLinkPathPrefix: gpath.Join(a.prefix, resource) + "/",
0000000000000000000000000000000000000000;;				SelfLinkPathSuffix: suffix,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Handler for standard REST verbs (GET, PUT, POST and DELETE).
0000000000000000000000000000000000000000;;			// Add actions at the resource path: /api/apiVersion/resource
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"LIST", resourcePath, resourceParams, namer, false}, isLister)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"POST", resourcePath, resourceParams, namer, false}, isCreater)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"DELETECOLLECTION", resourcePath, resourceParams, namer, false}, isCollectionDeleter)
0000000000000000000000000000000000000000;;			// DEPRECATED
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"WATCHLIST", "watch/" + resourcePath, resourceParams, namer, false}, allowWatchList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add actions at the item path: /api/apiVersion/resource/{name}
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"GET", itemPath, nameParams, namer, false}, isGetter)
0000000000000000000000000000000000000000;;			if getSubpath {
0000000000000000000000000000000000000000;;				actions = appendIf(actions, action{"GET", itemPath + "/{path:*}", proxyParams, namer, false}, isGetter)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PUT", itemPath, nameParams, namer, false}, isUpdater)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PATCH", itemPath, nameParams, namer, false}, isPatcher)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"DELETE", itemPath, nameParams, namer, false}, isDeleter)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"WATCH", "watch/" + itemPath, nameParams, namer, false}, isWatcher)
0000000000000000000000000000000000000000;;			// We add "proxy" subresource to remove the need for the generic top level prefix proxy.
0000000000000000000000000000000000000000;;			// The generic top level prefix proxy is deprecated in v1.2, and will be removed in 1.3, or 1.4 at the latest.
0000000000000000000000000000000000000000;;			// TODO: DEPRECATED in v1.2.
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PROXY", "proxy/" + itemPath + "/{path:*}", proxyParams, namer, false}, isRedirector)
0000000000000000000000000000000000000000;;			// TODO: DEPRECATED in v1.2.
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PROXY", "proxy/" + itemPath, nameParams, namer, false}, isRedirector)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"CONNECT", itemPath, nameParams, namer, false}, isConnecter)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"CONNECT", itemPath + "/{path:*}", proxyParams, namer, false}, isConnecter && connectSubpath)
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case meta.RESTScopeNameNamespace:
0000000000000000000000000000000000000000;;			// Handler for standard REST verbs (GET, PUT, POST and DELETE).
0000000000000000000000000000000000000000;;			namespaceParam := ws.PathParameter(scope.ArgumentName(), scope.ParamDescription()).DataType("string")
0000000000000000000000000000000000000000;;			namespacedPath := scope.ParamName() + "/{" + scope.ArgumentName() + "}/" + resource
0000000000000000000000000000000000000000;;			namespaceParams := []*restful.Parameter{namespaceParam}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resourcePath := namespacedPath
0000000000000000000000000000000000000000;;			resourceParams := namespaceParams
0000000000000000000000000000000000000000;;			itemPath := namespacedPath + "/{name}"
0000000000000000000000000000000000000000;;			nameParams := append(namespaceParams, nameParam)
0000000000000000000000000000000000000000;;			proxyParams := append(nameParams, pathParam)
0000000000000000000000000000000000000000;;			itemPathSuffix := ""
0000000000000000000000000000000000000000;;			if hasSubresource {
0000000000000000000000000000000000000000;;				itemPathSuffix = "/" + subresource
0000000000000000000000000000000000000000;;				itemPath = itemPath + itemPathSuffix
0000000000000000000000000000000000000000;;				resourcePath = itemPath
0000000000000000000000000000000000000000;;				resourceParams = nameParams
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			apiResource.Name = path
0000000000000000000000000000000000000000;;			apiResource.Namespaced = true
0000000000000000000000000000000000000000;;			apiResource.Kind = resourceKind
0000000000000000000000000000000000000000;;			namer := handlers.ContextBasedNaming{
0000000000000000000000000000000000000000;;				GetContext:         ctxFn,
0000000000000000000000000000000000000000;;				SelfLinker:         a.group.Linker,
0000000000000000000000000000000000000000;;				ClusterScoped:      false,
0000000000000000000000000000000000000000;;				SelfLinkPathPrefix: gpath.Join(a.prefix, scope.ParamName()) + "/",
0000000000000000000000000000000000000000;;				SelfLinkPathSuffix: itemPathSuffix,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"LIST", resourcePath, resourceParams, namer, false}, isLister)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"POST", resourcePath, resourceParams, namer, false}, isCreater)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"DELETECOLLECTION", resourcePath, resourceParams, namer, false}, isCollectionDeleter)
0000000000000000000000000000000000000000;;			// DEPRECATED
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"WATCHLIST", "watch/" + resourcePath, resourceParams, namer, false}, allowWatchList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"GET", itemPath, nameParams, namer, false}, isGetter)
0000000000000000000000000000000000000000;;			if getSubpath {
0000000000000000000000000000000000000000;;				actions = appendIf(actions, action{"GET", itemPath + "/{path:*}", proxyParams, namer, false}, isGetter)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PUT", itemPath, nameParams, namer, false}, isUpdater)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PATCH", itemPath, nameParams, namer, false}, isPatcher)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"DELETE", itemPath, nameParams, namer, false}, isDeleter)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"WATCH", "watch/" + itemPath, nameParams, namer, false}, isWatcher)
0000000000000000000000000000000000000000;;			// We add "proxy" subresource to remove the need for the generic top level prefix proxy.
0000000000000000000000000000000000000000;;			// The generic top level prefix proxy is deprecated in v1.2, and will be removed in 1.3, or 1.4 at the latest.
0000000000000000000000000000000000000000;;			// TODO: DEPRECATED in v1.2.
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PROXY", "proxy/" + itemPath + "/{path:*}", proxyParams, namer, false}, isRedirector)
0000000000000000000000000000000000000000;;			// TODO: DEPRECATED in v1.2.
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"PROXY", "proxy/" + itemPath, nameParams, namer, false}, isRedirector)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"CONNECT", itemPath, nameParams, namer, false}, isConnecter)
0000000000000000000000000000000000000000;;			actions = appendIf(actions, action{"CONNECT", itemPath + "/{path:*}", proxyParams, namer, false}, isConnecter && connectSubpath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// list or post across namespace.
0000000000000000000000000000000000000000;;			// For ex: LIST all pods in all namespaces by sending a LIST request at /api/apiVersion/pods.
0000000000000000000000000000000000000000;;			// TODO: more strongly type whether a resource allows these actions on "all namespaces" (bulk delete)
0000000000000000000000000000000000000000;;			if !hasSubresource {
0000000000000000000000000000000000000000;;				actions = appendIf(actions, action{"LIST", resource, params, namer, true}, isLister)
0000000000000000000000000000000000000000;;				actions = appendIf(actions, action{"WATCHLIST", "watch/" + resource, params, namer, true}, allowWatchList)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported restscope: %s", scope.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create Routes for the actions.
0000000000000000000000000000000000000000;;		// TODO: Add status documentation using Returns()
0000000000000000000000000000000000000000;;		// Errors (see api/errors/errors.go as well as go-restful router):
0000000000000000000000000000000000000000;;		// http.StatusNotFound, http.StatusMethodNotAllowed,
0000000000000000000000000000000000000000;;		// http.StatusUnsupportedMediaType, http.StatusNotAcceptable,
0000000000000000000000000000000000000000;;		// http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden,
0000000000000000000000000000000000000000;;		// http.StatusRequestTimeout, http.StatusConflict, http.StatusPreconditionFailed,
0000000000000000000000000000000000000000;;		// 422 (StatusUnprocessableEntity), http.StatusInternalServerError,
0000000000000000000000000000000000000000;;		// http.StatusServiceUnavailable
0000000000000000000000000000000000000000;;		// and api error codes
0000000000000000000000000000000000000000;;		// Note that if we specify a versioned Status object here, we may need to
0000000000000000000000000000000000000000;;		// create one for the tests, also
0000000000000000000000000000000000000000;;		// Success:
0000000000000000000000000000000000000000;;		// http.StatusOK, http.StatusCreated, http.StatusAccepted, http.StatusNoContent
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// test/integration/auth_test.go is currently the most comprehensive status code test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mediaTypes, streamMediaTypes := negotiation.MediaTypesForSerializer(a.group.Serializer)
0000000000000000000000000000000000000000;;		allMediaTypes := append(mediaTypes, streamMediaTypes...)
0000000000000000000000000000000000000000;;		ws.Produces(allMediaTypes...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeVerbs := map[string]struct{}{}
0000000000000000000000000000000000000000;;		reqScope := handlers.RequestScope{
0000000000000000000000000000000000000000;;			ContextFunc:     ctxFn,
0000000000000000000000000000000000000000;;			Serializer:      a.group.Serializer,
0000000000000000000000000000000000000000;;			ParameterCodec:  a.group.ParameterCodec,
0000000000000000000000000000000000000000;;			Creater:         a.group.Creater,
0000000000000000000000000000000000000000;;			Convertor:       a.group.Convertor,
0000000000000000000000000000000000000000;;			Copier:          a.group.Copier,
0000000000000000000000000000000000000000;;			Defaulter:       a.group.Defaulter,
0000000000000000000000000000000000000000;;			Typer:           a.group.Typer,
0000000000000000000000000000000000000000;;			UnsafeConvertor: a.group.UnsafeConvertor,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: Check for the interface on storage
0000000000000000000000000000000000000000;;			TableConvertor: tableProvider,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: This seems wrong for cross-group subresources. It makes an assumption that a subresource and its parent are in the same group version. Revisit this.
0000000000000000000000000000000000000000;;			Resource:    a.group.GroupVersion.WithResource(resource),
0000000000000000000000000000000000000000;;			Subresource: subresource,
0000000000000000000000000000000000000000;;			Kind:        fqKindToRegister,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			MetaGroupVersion: metav1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.group.MetaGroupVersion != nil {
0000000000000000000000000000000000000000;;			reqScope.MetaGroupVersion = *a.group.MetaGroupVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, action := range actions {
0000000000000000000000000000000000000000;;			versionedObject := storageMeta.ProducesObject(action.Verb)
0000000000000000000000000000000000000000;;			if versionedObject == nil {
0000000000000000000000000000000000000000;;				versionedObject = defaultVersionedObject
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reqScope.Namer = action.Namer
0000000000000000000000000000000000000000;;			namespaced := ""
0000000000000000000000000000000000000000;;			if apiResource.Namespaced {
0000000000000000000000000000000000000000;;				namespaced = "Namespaced"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			operationSuffix := ""
0000000000000000000000000000000000000000;;			if strings.HasSuffix(action.Path, "/{path:*}") {
0000000000000000000000000000000000000000;;				operationSuffix = operationSuffix + "WithPath"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if action.AllNamespaces {
0000000000000000000000000000000000000000;;				operationSuffix = operationSuffix + "ForAllNamespaces"
0000000000000000000000000000000000000000;;				namespaced = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if kubeVerb, found := toDiscoveryKubeVerb[action.Verb]; found {
0000000000000000000000000000000000000000;;				if len(kubeVerb) != 0 {
0000000000000000000000000000000000000000;;					kubeVerbs[kubeVerb] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unknown action verb for discovery: %s", action.Verb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			routes := []*restful.RouteBuilder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch action.Verb {
0000000000000000000000000000000000000000;;			case "GET": // Get a resource.
0000000000000000000000000000000000000000;;				var handler restful.RouteFunction
0000000000000000000000000000000000000000;;				if isGetterWithOptions {
0000000000000000000000000000000000000000;;					handler = restfulGetResourceWithOptions(getterWithOptions, reqScope, hasSubresource)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					handler = restfulGetResource(getter, exporter, reqScope)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler = metrics.InstrumentRouteFunc(action.Verb, resource, subresource, handler)
0000000000000000000000000000000000000000;;				if a.enableAPIResponseCompression {
0000000000000000000000000000000000000000;;					handler = genericfilters.RestfulWithCompression(handler, a.group.Context)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				doc := "read the specified " + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "read " + subresource + " of the specified " + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				route := ws.GET(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("read"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedObject).
0000000000000000000000000000000000000000;;					Writes(versionedObject)
0000000000000000000000000000000000000000;;				if isGetterWithOptions {
0000000000000000000000000000000000000000;;					if err := addObjectParams(ws, route, versionedGetOptions); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isExporter {
0000000000000000000000000000000000000000;;					if err := addObjectParams(ws, route, versionedExportOptions); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			case "LIST": // List all resources of a kind.
0000000000000000000000000000000000000000;;				doc := "list objects of kind " + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "list " + subresource + " of objects of kind " + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulListResource(lister, watcher, reqScope, false, a.minRequestTimeout))
0000000000000000000000000000000000000000;;				if a.enableAPIResponseCompression {
0000000000000000000000000000000000000000;;					handler = genericfilters.RestfulWithCompression(handler, a.group.Context)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				route := ws.GET(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("list"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(append(storageMeta.ProducesMIMETypes(action.Verb), allMediaTypes...)...).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedList).
0000000000000000000000000000000000000000;;					Writes(versionedList)
0000000000000000000000000000000000000000;;				if err := addObjectParams(ws, route, versionedListOptions); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case isLister && isWatcher:
0000000000000000000000000000000000000000;;					doc := "list or watch objects of kind " + kind
0000000000000000000000000000000000000000;;					if hasSubresource {
0000000000000000000000000000000000000000;;						doc = "list or watch " + subresource + " of objects of kind " + kind
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					route.Doc(doc)
0000000000000000000000000000000000000000;;				case isWatcher:
0000000000000000000000000000000000000000;;					doc := "watch objects of kind " + kind
0000000000000000000000000000000000000000;;					if hasSubresource {
0000000000000000000000000000000000000000;;						doc = "watch " + subresource + "of objects of kind " + kind
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					route.Doc(doc)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			case "PUT": // Update a resource.
0000000000000000000000000000000000000000;;				doc := "replace the specified " + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "replace " + subresource + " of the specified " + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulUpdateResource(updater, reqScope, a.group.Typer, admit))
0000000000000000000000000000000000000000;;				route := ws.PUT(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("replace"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedObject).
0000000000000000000000000000000000000000;;					Reads(versionedObject).
0000000000000000000000000000000000000000;;					Writes(versionedObject)
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			case "PATCH": // Partially update a resource
0000000000000000000000000000000000000000;;				doc := "partially update the specified " + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "partially update " + subresource + " of the specified " + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulPatchResource(patcher, reqScope, admit, mapping.ObjectConvertor))
0000000000000000000000000000000000000000;;				route := ws.PATCH(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Consumes(string(types.JSONPatchType), string(types.MergePatchType), string(types.StrategicMergePatchType)).
0000000000000000000000000000000000000000;;					Operation("patch"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedObject).
0000000000000000000000000000000000000000;;					Reads(metav1.Patch{}).
0000000000000000000000000000000000000000;;					Writes(versionedObject)
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			case "POST": // Create a resource.
0000000000000000000000000000000000000000;;				var handler restful.RouteFunction
0000000000000000000000000000000000000000;;				if isNamedCreater {
0000000000000000000000000000000000000000;;					handler = restfulCreateNamedResource(namedCreater, reqScope, a.group.Typer, admit)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					handler = restfulCreateResource(creater, reqScope, a.group.Typer, admit)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler = metrics.InstrumentRouteFunc(action.Verb, resource, subresource, handler)
0000000000000000000000000000000000000000;;				article := getArticleForNoun(kind, " ")
0000000000000000000000000000000000000000;;				doc := "create" + article + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "create " + subresource + " of" + article + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				route := ws.POST(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("create"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedObject).
0000000000000000000000000000000000000000;;					Reads(versionedObject).
0000000000000000000000000000000000000000;;					Writes(versionedObject)
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			case "DELETE": // Delete a resource.
0000000000000000000000000000000000000000;;				article := getArticleForNoun(kind, " ")
0000000000000000000000000000000000000000;;				doc := "delete" + article + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "delete " + subresource + " of" + article + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulDeleteResource(gracefulDeleter, isGracefulDeleter, reqScope, admit))
0000000000000000000000000000000000000000;;				route := ws.DELETE(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("delete"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
0000000000000000000000000000000000000000;;					Writes(versionedStatus).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedStatus)
0000000000000000000000000000000000000000;;				if isGracefulDeleter {
0000000000000000000000000000000000000000;;					route.Reads(versionedDeleterObject)
0000000000000000000000000000000000000000;;					if err := addObjectParams(ws, route, versionedDeleteOptions); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			case "DELETECOLLECTION":
0000000000000000000000000000000000000000;;				doc := "delete collection of " + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "delete collection of " + subresource + " of a " + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulDeleteCollection(collectionDeleter, isCollectionDeleter, reqScope, admit))
0000000000000000000000000000000000000000;;				route := ws.DELETE(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("deletecollection"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
0000000000000000000000000000000000000000;;					Writes(versionedStatus).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedStatus)
0000000000000000000000000000000000000000;;				if err := addObjectParams(ws, route, versionedListOptions); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			// TODO: deprecated
0000000000000000000000000000000000000000;;			case "WATCH": // Watch a resource.
0000000000000000000000000000000000000000;;				doc := "watch changes to an object of kind " + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "watch changes to " + subresource + " of an object of kind " + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulListResource(lister, watcher, reqScope, true, a.minRequestTimeout))
0000000000000000000000000000000000000000;;				route := ws.GET(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("watch"+namespaced+kind+strings.Title(subresource)+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(allMediaTypes...).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedWatchEvent).
0000000000000000000000000000000000000000;;					Writes(versionedWatchEvent)
0000000000000000000000000000000000000000;;				if err := addObjectParams(ws, route, versionedListOptions); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			// TODO: deprecated
0000000000000000000000000000000000000000;;			case "WATCHLIST": // Watch all resources of a kind.
0000000000000000000000000000000000000000;;				doc := "watch individual changes to a list of " + kind
0000000000000000000000000000000000000000;;				if hasSubresource {
0000000000000000000000000000000000000000;;					doc = "watch individual changes to a list of " + subresource + " of " + kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulListResource(lister, watcher, reqScope, true, a.minRequestTimeout))
0000000000000000000000000000000000000000;;				route := ws.GET(action.Path).To(handler).
0000000000000000000000000000000000000000;;					Doc(doc).
0000000000000000000000000000000000000000;;					Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
0000000000000000000000000000000000000000;;					Operation("watch"+namespaced+kind+strings.Title(subresource)+"List"+operationSuffix).
0000000000000000000000000000000000000000;;					Produces(allMediaTypes...).
0000000000000000000000000000000000000000;;					Returns(http.StatusOK, "OK", versionedWatchEvent).
0000000000000000000000000000000000000000;;					Writes(versionedWatchEvent)
0000000000000000000000000000000000000000;;				if err := addObjectParams(ws, route, versionedListOptions); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addParams(route, action.Params)
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;			// We add "proxy" subresource to remove the need for the generic top level prefix proxy.
0000000000000000000000000000000000000000;;			// The generic top level prefix proxy is deprecated in v1.2, and will be removed in 1.3, or 1.4 at the latest.
0000000000000000000000000000000000000000;;			// TODO: DEPRECATED in v1.2.
0000000000000000000000000000000000000000;;			case "PROXY": // Proxy requests to a resource.
0000000000000000000000000000000000000000;;				// Accept all methods as per http://issue.k8s.io/3996
0000000000000000000000000000000000000000;;				routes = append(routes, buildProxyRoute(ws, "GET", a.prefix, action.Path, proxyHandler, namespaced, kind, resource, subresource, hasSubresource, action.Params, operationSuffix))
0000000000000000000000000000000000000000;;				routes = append(routes, buildProxyRoute(ws, "PUT", a.prefix, action.Path, proxyHandler, namespaced, kind, resource, subresource, hasSubresource, action.Params, operationSuffix))
0000000000000000000000000000000000000000;;				routes = append(routes, buildProxyRoute(ws, "POST", a.prefix, action.Path, proxyHandler, namespaced, kind, resource, subresource, hasSubresource, action.Params, operationSuffix))
0000000000000000000000000000000000000000;;				routes = append(routes, buildProxyRoute(ws, "PATCH", a.prefix, action.Path, proxyHandler, namespaced, kind, resource, subresource, hasSubresource, action.Params, operationSuffix))
0000000000000000000000000000000000000000;;				routes = append(routes, buildProxyRoute(ws, "DELETE", a.prefix, action.Path, proxyHandler, namespaced, kind, resource, subresource, hasSubresource, action.Params, operationSuffix))
0000000000000000000000000000000000000000;;				routes = append(routes, buildProxyRoute(ws, "HEAD", a.prefix, action.Path, proxyHandler, namespaced, kind, resource, subresource, hasSubresource, action.Params, operationSuffix))
0000000000000000000000000000000000000000;;				routes = append(routes, buildProxyRoute(ws, "OPTIONS", a.prefix, action.Path, proxyHandler, namespaced, kind, resource, subresource, hasSubresource, action.Params, operationSuffix))
0000000000000000000000000000000000000000;;			case "CONNECT":
0000000000000000000000000000000000000000;;				for _, method := range connecter.ConnectMethods() {
0000000000000000000000000000000000000000;;					doc := "connect " + method + " requests to " + kind
0000000000000000000000000000000000000000;;					if hasSubresource {
0000000000000000000000000000000000000000;;						doc = "connect " + method + " requests to " + subresource + " of " + kind
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					handler := metrics.InstrumentRouteFunc(action.Verb, resource, subresource, restfulConnectResource(connecter, reqScope, admit, path, hasSubresource))
0000000000000000000000000000000000000000;;					route := ws.Method(method).Path(action.Path).
0000000000000000000000000000000000000000;;						To(handler).
0000000000000000000000000000000000000000;;						Doc(doc).
0000000000000000000000000000000000000000;;						Operation("connect" + strings.Title(strings.ToLower(method)) + namespaced + kind + strings.Title(subresource) + operationSuffix).
0000000000000000000000000000000000000000;;						Produces("*/*").
0000000000000000000000000000000000000000;;						Consumes("*/*").
0000000000000000000000000000000000000000;;						Writes("string")
0000000000000000000000000000000000000000;;					if versionedConnectOptions != nil {
0000000000000000000000000000000000000000;;						if err := addObjectParams(ws, route, versionedConnectOptions); err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					addParams(route, action.Params)
0000000000000000000000000000000000000000;;					routes = append(routes, route)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unrecognized action verb: %s", action.Verb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, route := range routes {
0000000000000000000000000000000000000000;;				route.Metadata(ROUTE_META_GVK, metav1.GroupVersionKind{
0000000000000000000000000000000000000000;;					Group:   reqScope.Kind.Group,
0000000000000000000000000000000000000000;;					Version: reqScope.Kind.Version,
0000000000000000000000000000000000000000;;					Kind:    reqScope.Kind.Kind,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				route.Metadata(ROUTE_META_ACTION, strings.ToLower(action.Verb))
0000000000000000000000000000000000000000;;				ws.Route(route)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Note: update GetAuthorizerAttributes() when adding a custom handler.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiResource.Verbs = make([]string, 0, len(kubeVerbs))
0000000000000000000000000000000000000000;;		for kubeVerb := range kubeVerbs {
0000000000000000000000000000000000000000;;			apiResource.Verbs = append(apiResource.Verbs, kubeVerb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(apiResource.Verbs)
0000000000000000000000000000000000000000;;		apiResource.ShortNames = shortNames
0000000000000000000000000000000000000000;;		apiResource.Categories = categories
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &apiResource, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This magic incantation returns *ptrToObject for an arbitrary pointer
0000000000000000000000000000000000000000;;	func indirectArbitraryPointer(ptrToObject interface{}) interface{} {
0000000000000000000000000000000000000000;;		return reflect.Indirect(reflect.ValueOf(ptrToObject)).Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendIf(actions []action, a action, shouldAppend bool) []action {
0000000000000000000000000000000000000000;;		if shouldAppend {
0000000000000000000000000000000000000000;;			actions = append(actions, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return actions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wraps a http.Handler function inside a restful.RouteFunction
0000000000000000000000000000000000000000;;	func routeFunction(handler http.Handler) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(restReq *restful.Request, restResp *restful.Response) {
0000000000000000000000000000000000000000;;			handler.ServeHTTP(restResp.ResponseWriter, restReq.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildProxyRoute(ws *restful.WebService, method string, prefix string, path string, proxyHandler http.Handler, namespaced, kind, resource, subresource string, hasSubresource bool, params []*restful.Parameter, operationSuffix string) *restful.RouteBuilder {
0000000000000000000000000000000000000000;;		doc := "proxy " + method + " requests to " + kind
0000000000000000000000000000000000000000;;		if hasSubresource {
0000000000000000000000000000000000000000;;			doc = "proxy " + method + " requests to " + subresource + " of " + kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := metrics.InstrumentRouteFunc("PROXY", resource, subresource, routeFunction(proxyHandler))
0000000000000000000000000000000000000000;;		proxyRoute := ws.Method(method).Path(path).To(handler).
0000000000000000000000000000000000000000;;			Doc(doc).
0000000000000000000000000000000000000000;;			Operation("proxy" + strings.Title(method) + namespaced + kind + strings.Title(subresource) + operationSuffix).
0000000000000000000000000000000000000000;;			Produces("*/*").
0000000000000000000000000000000000000000;;			Consumes("*/*").
0000000000000000000000000000000000000000;;			Writes("string")
0000000000000000000000000000000000000000;;		addParams(proxyRoute, params)
0000000000000000000000000000000000000000;;		return proxyRoute
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addParams(route *restful.RouteBuilder, params []*restful.Parameter) {
0000000000000000000000000000000000000000;;		for _, param := range params {
0000000000000000000000000000000000000000;;			route.Param(param)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addObjectParams converts a runtime.Object into a set of go-restful Param() definitions on the route.
0000000000000000000000000000000000000000;;	// The object must be a pointer to a struct; only fields at the top level of the struct that are not
0000000000000000000000000000000000000000;;	// themselves interfaces or structs are used; only fields with a json tag that is non empty (the standard
0000000000000000000000000000000000000000;;	// Go JSON behavior for omitting a field) become query parameters. The name of the query parameter is
0000000000000000000000000000000000000000;;	// the JSON field name. If a description struct tag is set on the field, that description is used on the
0000000000000000000000000000000000000000;;	// query parameter. In essence, it converts a standard JSON top level object into a query param schema.
0000000000000000000000000000000000000000;;	func addObjectParams(ws *restful.WebService, route *restful.RouteBuilder, obj interface{}) error {
0000000000000000000000000000000000000000;;		sv, err := conversion.EnforcePtr(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st := sv.Type()
0000000000000000000000000000000000000000;;		switch st.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < st.NumField(); i++ {
0000000000000000000000000000000000000000;;				name := st.Field(i).Name
0000000000000000000000000000000000000000;;				sf, ok := st.FieldByName(name)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch sf.Type.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Interface, reflect.Struct:
0000000000000000000000000000000000000000;;				case reflect.Ptr:
0000000000000000000000000000000000000000;;					// TODO: This is a hack to let metav1.Time through. This needs to be fixed in a more generic way eventually. bug #36191
0000000000000000000000000000000000000000;;					if (sf.Type.Elem().Kind() == reflect.Interface || sf.Type.Elem().Kind() == reflect.Struct) && strings.TrimPrefix(sf.Type.String(), "*") != "metav1.Time" {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					jsonTag := sf.Tag.Get("json")
0000000000000000000000000000000000000000;;					if len(jsonTag) == 0 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					jsonName := strings.SplitN(jsonTag, ",", 2)[0]
0000000000000000000000000000000000000000;;					if len(jsonName) == 0 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var desc string
0000000000000000000000000000000000000000;;					if docable, ok := obj.(documentable); ok {
0000000000000000000000000000000000000000;;						desc = docable.SwaggerDoc()[jsonName]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					route.Param(ws.QueryParameter(jsonName, desc).DataType(typeToJSON(sf.Type.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: this is incomplete, expand as needed.
0000000000000000000000000000000000000000;;	// Convert the name of a golang type to the name of a JSON type
0000000000000000000000000000000000000000;;	func typeToJSON(typeName string) string {
0000000000000000000000000000000000000000;;		switch typeName {
0000000000000000000000000000000000000000;;		case "bool", "*bool":
0000000000000000000000000000000000000000;;			return "boolean"
0000000000000000000000000000000000000000;;		case "uint8", "*uint8", "int", "*int", "int32", "*int32", "int64", "*int64", "uint32", "*uint32", "uint64", "*uint64":
0000000000000000000000000000000000000000;;			return "integer"
0000000000000000000000000000000000000000;;		case "float64", "*float64", "float32", "*float32":
0000000000000000000000000000000000000000;;			return "number"
0000000000000000000000000000000000000000;;		case "metav1.Time", "*metav1.Time":
0000000000000000000000000000000000000000;;			return "string"
0000000000000000000000000000000000000000;;		case "byte", "*byte":
0000000000000000000000000000000000000000;;			return "string"
0000000000000000000000000000000000000000;;		case "v1.DeletionPropagation", "*v1.DeletionPropagation":
0000000000000000000000000000000000000000;;			return "string"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Fix these when go-restful supports a way to specify an array query param:
0000000000000000000000000000000000000000;;		// https://github.com/emicklei/go-restful/issues/225
0000000000000000000000000000000000000000;;		case "[]string", "[]*string":
0000000000000000000000000000000000000000;;			return "string"
0000000000000000000000000000000000000000;;		case "[]int32", "[]*int32":
0000000000000000000000000000000000000000;;			return "integer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return typeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultStorageMetadata provides default answers to rest.StorageMetadata.
0000000000000000000000000000000000000000;;	type defaultStorageMetadata struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultStorageMetadata implements rest.StorageMetadata
0000000000000000000000000000000000000000;;	var _ rest.StorageMetadata = defaultStorageMetadata{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (defaultStorageMetadata) ProducesMIMETypes(verb string) []string {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (defaultStorageMetadata) ProducesObject(verb string) interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitSubresource checks if the given storage path is the path of a subresource and returns
0000000000000000000000000000000000000000;;	// the resource and subresource components.
0000000000000000000000000000000000000000;;	func splitSubresource(path string) (string, string, error) {
0000000000000000000000000000000000000000;;		var resource, subresource string
0000000000000000000000000000000000000000;;		switch parts := strings.Split(path, "/"); len(parts) {
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			resource, subresource = parts[0], parts[1]
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			resource = parts[0]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// TODO: support deeper paths
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("api_installer allows only one or two segment paths (resource or resource/subresource)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resource, subresource, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getArticleForNoun returns the article needed for the given noun.
0000000000000000000000000000000000000000;;	func getArticleForNoun(noun string, padding string) string {
0000000000000000000000000000000000000000;;		if noun[len(noun)-2:] != "ss" && noun[len(noun)-1:] == "s" {
0000000000000000000000000000000000000000;;			// Plurals don't have an article.
0000000000000000000000000000000000000000;;			// Don't catch words like class
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v", padding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		article := "a"
0000000000000000000000000000000000000000;;		if isVowel(rune(noun[0])) {
0000000000000000000000000000000000000000;;			article = "an"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%s%s", padding, article, padding)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isVowel returns true if the rune is a vowel (case insensitive).
0000000000000000000000000000000000000000;;	func isVowel(c rune) bool {
0000000000000000000000000000000000000000;;		vowels := []rune{'a', 'e', 'i', 'o', 'u'}
0000000000000000000000000000000000000000;;		for _, value := range vowels {
0000000000000000000000000000000000000000;;			if value == unicode.ToLower(c) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulListResource(r rest.Lister, rw rest.Watcher, scope handlers.RequestScope, forceWatch bool, minRequestTimeout time.Duration) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.ListResource(r, rw, scope, forceWatch, minRequestTimeout)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulCreateNamedResource(r rest.NamedCreater, scope handlers.RequestScope, typer runtime.ObjectTyper, admit admission.Interface) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.CreateNamedResource(r, scope, typer, admit)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulCreateResource(r rest.Creater, scope handlers.RequestScope, typer runtime.ObjectTyper, admit admission.Interface) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.CreateResource(r, scope, typer, admit)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulDeleteResource(r rest.GracefulDeleter, allowsOptions bool, scope handlers.RequestScope, admit admission.Interface) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.DeleteResource(r, allowsOptions, scope, admit)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulDeleteCollection(r rest.CollectionDeleter, checkBody bool, scope handlers.RequestScope, admit admission.Interface) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.DeleteCollection(r, checkBody, scope, admit)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulUpdateResource(r rest.Updater, scope handlers.RequestScope, typer runtime.ObjectTyper, admit admission.Interface) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.UpdateResource(r, scope, typer, admit)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulPatchResource(r rest.Patcher, scope handlers.RequestScope, admit admission.Interface, converter runtime.ObjectConvertor) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.PatchResource(r, scope, admit, converter)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulGetResource(r rest.Getter, e rest.Exporter, scope handlers.RequestScope) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.GetResource(r, e, scope)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulGetResourceWithOptions(r rest.GetterWithOptions, scope handlers.RequestScope, isSubresource bool) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.GetResourceWithOptions(r, scope, isSubresource)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restfulConnectResource(connecter rest.Connecter, scope handlers.RequestScope, admit admission.Interface, restPath string, isSubresource bool) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return func(req *restful.Request, res *restful.Response) {
0000000000000000000000000000000000000000;;			handlers.ConnectResource(connecter, scope, admit, restPath, isSubresource)(res.ResponseWriter, req.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
