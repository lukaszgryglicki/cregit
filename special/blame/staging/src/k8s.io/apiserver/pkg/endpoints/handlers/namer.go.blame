0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f14186b1023ed114f97aad506abdd9aa2dc91723;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package handlers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContextFunc returns a Context given a request - a context must be returned
0000000000000000000000000000000000000000;;	type ContextFunc func(req *http.Request) request.Context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScopeNamer handles accessing names from requests and objects
0000000000000000000000000000000000000000;;	type ScopeNamer interface {
0000000000000000000000000000000000000000;;		// Namespace returns the appropriate namespace value from the request (may be empty) or an
0000000000000000000000000000000000000000;;		// error.
0000000000000000000000000000000000000000;;		Namespace(req *http.Request) (namespace string, err error)
0000000000000000000000000000000000000000;;		// Name returns the name from the request, and an optional namespace value if this is a namespace
0000000000000000000000000000000000000000;;		// scoped call. An error is returned if the name is not available.
0000000000000000000000000000000000000000;;		Name(req *http.Request) (namespace, name string, err error)
0000000000000000000000000000000000000000;;		// ObjectName returns the namespace and name from an object if they exist, or an error if the object
0000000000000000000000000000000000000000;;		// does not support names.
0000000000000000000000000000000000000000;;		ObjectName(obj runtime.Object) (namespace, name string, err error)
0000000000000000000000000000000000000000;;		// SetSelfLink sets the provided URL onto the object. The method should return nil if the object
0000000000000000000000000000000000000000;;		// does not support selfLinks.
0000000000000000000000000000000000000000;;		SetSelfLink(obj runtime.Object, url string) error
0000000000000000000000000000000000000000;;		// GenerateLink creates an encoded URI for a given runtime object that represents the canonical path
0000000000000000000000000000000000000000;;		// and query.
0000000000000000000000000000000000000000;;		GenerateLink(requestInfo *request.RequestInfo, obj runtime.Object) (uri string, err error)
0000000000000000000000000000000000000000;;		// GenerateListLink creates an encoded URI for a list that represents the canonical path and query.
0000000000000000000000000000000000000000;;		GenerateListLink(req *http.Request) (uri string, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContextBasedNaming struct {
0000000000000000000000000000000000000000;;		GetContext    ContextFunc
0000000000000000000000000000000000000000;;		SelfLinker    runtime.SelfLinker
0000000000000000000000000000000000000000;;		ClusterScoped bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SelfLinkPathPrefix string
0000000000000000000000000000000000000000;;		SelfLinkPathSuffix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContextBasedNaming implements ScopeNamer
0000000000000000000000000000000000000000;;	var _ ScopeNamer = ContextBasedNaming{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ContextBasedNaming) SetSelfLink(obj runtime.Object, url string) error {
0000000000000000000000000000000000000000;;		return n.SelfLinker.SetSelfLink(obj, url)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ContextBasedNaming) Namespace(req *http.Request) (namespace string, err error) {
0000000000000000000000000000000000000000;;		requestInfo, ok := request.RequestInfoFrom(n.GetContext(req))
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("missing requestInfo")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return requestInfo.Namespace, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ContextBasedNaming) Name(req *http.Request) (namespace, name string, err error) {
0000000000000000000000000000000000000000;;		requestInfo, ok := request.RequestInfoFrom(n.GetContext(req))
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("missing requestInfo")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ns, err := n.Namespace(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(requestInfo.Name) == 0 {
0000000000000000000000000000000000000000;;			return "", "", errEmptyName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ns, requestInfo.Name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ContextBasedNaming) GenerateLink(requestInfo *request.RequestInfo, obj runtime.Object) (uri string, err error) {
0000000000000000000000000000000000000000;;		namespace, name, err := n.ObjectName(obj)
0000000000000000000000000000000000000000;;		if err == errEmptyName && len(requestInfo.Name) > 0 {
0000000000000000000000000000000000000000;;			name = requestInfo.Name
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(namespace) == 0 && len(requestInfo.Namespace) > 0 {
0000000000000000000000000000000000000000;;			namespace = requestInfo.Namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n.ClusterScoped {
0000000000000000000000000000000000000000;;			return n.SelfLinkPathPrefix + url.QueryEscape(name) + n.SelfLinkPathSuffix, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n.SelfLinkPathPrefix +
0000000000000000000000000000000000000000;;				url.QueryEscape(namespace) +
0000000000000000000000000000000000000000;;				"/" + url.QueryEscape(requestInfo.Resource) + "/" +
0000000000000000000000000000000000000000;;				url.QueryEscape(name) +
0000000000000000000000000000000000000000;;				n.SelfLinkPathSuffix,
0000000000000000000000000000000000000000;;			nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ContextBasedNaming) GenerateListLink(req *http.Request) (uri string, err error) {
0000000000000000000000000000000000000000;;		if len(req.URL.RawPath) > 0 {
0000000000000000000000000000000000000000;;			return req.URL.RawPath, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return req.URL.EscapedPath(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ContextBasedNaming) ObjectName(obj runtime.Object) (namespace, name string, err error) {
0000000000000000000000000000000000000000;;		name, err = n.SelfLinker.Name(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return "", "", errEmptyName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namespace, err = n.SelfLinker.Namespace(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return namespace, name, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errEmptyName is returned when API requests do not fill the name section of the path.
0000000000000000000000000000000000000000;;	var errEmptyName = errors.NewBadRequest("name must be provided")
