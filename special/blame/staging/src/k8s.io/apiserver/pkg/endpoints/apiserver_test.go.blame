0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;pkg/apiserver/api_server_test.go[pkg/apiserver/api_server_test.go][staging/src/k8s.io/apiserver/pkg/endpoints/apiserver_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package endpoints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		metav1alpha1 "k8s.io/apimachinery/pkg/apis/meta/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		auditinternal "k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplefuzzer "k8s.io/apiserver/pkg/apis/example/fuzzer"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		auditpolicy "k8s.io/apiserver/pkg/audit/policy"
0000000000000000000000000000000000000000;;		genericapifilters "k8s.io/apiserver/pkg/endpoints/filters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		genericapitesting "k8s.io/apiserver/pkg/endpoints/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/filters"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alwaysAdmit is an implementation of admission.Interface which always says yes to an admit request.
0000000000000000000000000000000000000000;;	// It is useful in tests and when using kubernetes in an open manner.
0000000000000000000000000000000000000000;;	type alwaysAdmit struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (alwaysAdmit) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (alwaysAdmit) Handles(operation admission.Operation) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type alwaysDeny struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (alwaysDeny) Admit(a admission.Attributes) (err error) {
0000000000000000000000000000000000000000;;		return admission.NewForbidden(a, errors.New("Admission control is denying all modifications"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (alwaysDeny) Handles(operation admission.Operation) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This creates fake API versions, similar to api/latest.go.
0000000000000000000000000000000000000000;;	var testAPIGroup = "test.group"
0000000000000000000000000000000000000000;;	var testAPIGroup2 = "test.group2"
0000000000000000000000000000000000000000;;	var testInternalGroupVersion = schema.GroupVersion{Group: testAPIGroup, Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;	var testGroupVersion = schema.GroupVersion{Group: testAPIGroup, Version: "version"}
0000000000000000000000000000000000000000;;	var newGroupVersion = schema.GroupVersion{Group: testAPIGroup, Version: "version2"}
0000000000000000000000000000000000000000;;	var testGroup2Version = schema.GroupVersion{Group: testAPIGroup2, Version: "version"}
0000000000000000000000000000000000000000;;	var testInternalGroup2Version = schema.GroupVersion{Group: testAPIGroup2, Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;	var prefix = "apis"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var grouplessGroupVersion = schema.GroupVersion{Group: "", Version: "v1"}
0000000000000000000000000000000000000000;;	var grouplessInternalGroupVersion = schema.GroupVersion{Group: "", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;	var grouplessPrefix = "api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var groupVersions = []schema.GroupVersion{grouplessGroupVersion, testGroupVersion, newGroupVersion}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var scheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;	var codecs = serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var codec = codecs.LegacyCodec(groupVersions...)
0000000000000000000000000000000000000000;;	var testCodec = codecs.LegacyCodec(testGroupVersion)
0000000000000000000000000000000000000000;;	var newCodec = codecs.LegacyCodec(newGroupVersion)
0000000000000000000000000000000000000000;;	var parameterCodec = runtime.NewParameterCodec(scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var accessor = meta.NewAccessor()
0000000000000000000000000000000000000000;;	var selfLinker runtime.SelfLinker = accessor
0000000000000000000000000000000000000000;;	var mapper, namespaceMapper meta.RESTMapper // The mappers with namespace and with legacy namespace scopes.
0000000000000000000000000000000000000000;;	var admissionControl admission.Interface
0000000000000000000000000000000000000000;;	var requestContextMapper request.RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, metav1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unnamed core group
0000000000000000000000000000000000000000;;		scheme.AddUnversionedTypes(grouplessGroupVersion, &metav1.Status{})
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, grouplessGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		example.AddToScheme(scheme)
0000000000000000000000000000000000000000;;		examplev1.AddToScheme(scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func interfacesFor(version schema.GroupVersion) (*meta.VersionInterfaces, error) {
0000000000000000000000000000000000000000;;		switch version {
0000000000000000000000000000000000000000;;		case testGroupVersion:
0000000000000000000000000000000000000000;;			return &meta.VersionInterfaces{
0000000000000000000000000000000000000000;;				ObjectConvertor:  scheme,
0000000000000000000000000000000000000000;;				MetadataAccessor: accessor,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case newGroupVersion:
0000000000000000000000000000000000000000;;			return &meta.VersionInterfaces{
0000000000000000000000000000000000000000;;				ObjectConvertor:  scheme,
0000000000000000000000000000000000000000;;				MetadataAccessor: accessor,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case grouplessGroupVersion:
0000000000000000000000000000000000000000;;			return &meta.VersionInterfaces{
0000000000000000000000000000000000000000;;				ObjectConvertor:  scheme,
0000000000000000000000000000000000000000;;				MetadataAccessor: accessor,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case testGroup2Version:
0000000000000000000000000000000000000000;;			return &meta.VersionInterfaces{
0000000000000000000000000000000000000000;;				ObjectConvertor:  scheme,
0000000000000000000000000000000000000000;;				MetadataAccessor: accessor,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported storage version: %s (valid: %v)", version, groupVersions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMapper() *meta.DefaultRESTMapper {
0000000000000000000000000000000000000000;;		return meta.NewDefaultRESTMapper([]schema.GroupVersion{testGroupVersion, newGroupVersion}, interfacesFor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addGrouplessTypes() {
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(grouplessGroupVersion,
0000000000000000000000000000000000000000;;			&genericapitesting.Simple{}, &genericapitesting.SimpleList{}, &metav1.ListOptions{}, &metav1.ExportOptions{},
0000000000000000000000000000000000000000;;			&metav1.DeleteOptions{}, &genericapitesting.SimpleGetOptions{}, &genericapitesting.SimpleRoot{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(grouplessInternalGroupVersion,
0000000000000000000000000000000000000000;;			&genericapitesting.Simple{}, &genericapitesting.SimpleList{}, &metav1.ExportOptions{},
0000000000000000000000000000000000000000;;			&genericapitesting.SimpleGetOptions{}, &genericapitesting.SimpleRoot{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTestTypes() {
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(testGroupVersion,
0000000000000000000000000000000000000000;;			&genericapitesting.Simple{}, &genericapitesting.SimpleList{}, &metav1.ExportOptions{},
0000000000000000000000000000000000000000;;			&metav1.DeleteOptions{}, &genericapitesting.SimpleGetOptions{}, &genericapitesting.SimpleRoot{},
0000000000000000000000000000000000000000;;			&genericapitesting.SimpleXGSubresource{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(testGroupVersion, &examplev1.Pod{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(testInternalGroupVersion,
0000000000000000000000000000000000000000;;			&genericapitesting.Simple{}, &genericapitesting.SimpleList{}, &metav1.ExportOptions{},
0000000000000000000000000000000000000000;;			&genericapitesting.SimpleGetOptions{}, &genericapitesting.SimpleRoot{},
0000000000000000000000000000000000000000;;			&genericapitesting.SimpleXGSubresource{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(testInternalGroupVersion, &example.Pod{})
0000000000000000000000000000000000000000;;		// Register SimpleXGSubresource in both testGroupVersion and testGroup2Version, and also their
0000000000000000000000000000000000000000;;		// their corresponding internal versions, to verify that the desired group version object is
0000000000000000000000000000000000000000;;		// served in the tests.
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(testGroup2Version, &genericapitesting.SimpleXGSubresource{}, &metav1.ExportOptions{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(testInternalGroup2Version, &genericapitesting.SimpleXGSubresource{}, &metav1.ExportOptions{})
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, testGroupVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addNewTestTypes() {
0000000000000000000000000000000000000000;;		scheme.AddKnownTypes(newGroupVersion,
0000000000000000000000000000000000000000;;			&genericapitesting.Simple{}, &genericapitesting.SimpleList{}, &metav1.ExportOptions{},
0000000000000000000000000000000000000000;;			&metav1.DeleteOptions{}, &genericapitesting.SimpleGetOptions{}, &genericapitesting.SimpleRoot{},
0000000000000000000000000000000000000000;;			&examplev1.Pod{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, newGroupVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Certain API objects are returned regardless of the contents of storage:
0000000000000000000000000000000000000000;;		// api.Status is returned in errors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addGrouplessTypes()
0000000000000000000000000000000000000000;;		addTestTypes()
0000000000000000000000000000000000000000;;		addNewTestTypes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsMapper := newMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// enumerate all supported versions, get the kinds, and register with
0000000000000000000000000000000000000000;;		// the mapper how to address our resources
0000000000000000000000000000000000000000;;		for _, gv := range groupVersions {
0000000000000000000000000000000000000000;;			for kind := range scheme.KnownTypes(gv) {
0000000000000000000000000000000000000000;;				gvk := gv.WithKind(kind)
0000000000000000000000000000000000000000;;				root := bool(kind == "SimpleRoot")
0000000000000000000000000000000000000000;;				if root {
0000000000000000000000000000000000000000;;					nsMapper.Add(gvk, meta.RESTScopeRoot)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					nsMapper.Add(gvk, meta.RESTScopeNamespace)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper = nsMapper
0000000000000000000000000000000000000000;;		namespaceMapper = nsMapper
0000000000000000000000000000000000000000;;		admissionControl = alwaysAdmit{}
0000000000000000000000000000000000000000;;		requestContextMapper = request.NewRequestContextMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme.AddFieldLabelConversionFunc(grouplessGroupVersion.String(), "Simple",
0000000000000000000000000000000000000000;;			func(label, value string) (string, string, error) {
0000000000000000000000000000000000000000;;				return label, value, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		scheme.AddFieldLabelConversionFunc(testGroupVersion.String(), "Simple",
0000000000000000000000000000000000000000;;			func(label, value string) (string, string, error) {
0000000000000000000000000000000000000000;;				return label, value, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		scheme.AddFieldLabelConversionFunc(newGroupVersion.String(), "Simple",
0000000000000000000000000000000000000000;;			func(label, value string) (string, string, error) {
0000000000000000000000000000000000000000;;				return label, value, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultAPIServer exposes nested objects for testability.
0000000000000000000000000000000000000000;;	type defaultAPIServer struct {
0000000000000000000000000000000000000000;;		http.Handler
0000000000000000000000000000000000000000;;		container *restful.Container
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// uses the default settings
0000000000000000000000000000000000000000;;	func handle(storage map[string]rest.Storage) http.Handler {
0000000000000000000000000000000000000000;;		return handleInternal(storage, admissionControl, selfLinker, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tests with a deny admission controller
0000000000000000000000000000000000000000;;	func handleDeny(storage map[string]rest.Storage) http.Handler {
0000000000000000000000000000000000000000;;		return handleInternal(storage, alwaysDeny{}, selfLinker, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tests using the new namespace scope mechanism
0000000000000000000000000000000000000000;;	func handleNamespaced(storage map[string]rest.Storage) http.Handler {
0000000000000000000000000000000000000000;;		return handleInternal(storage, admissionControl, selfLinker, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tests using a custom self linker
0000000000000000000000000000000000000000;;	func handleLinker(storage map[string]rest.Storage, selfLinker runtime.SelfLinker) http.Handler {
0000000000000000000000000000000000000000;;		return handleInternal(storage, admissionControl, selfLinker, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleInternal(storage map[string]rest.Storage, admissionControl admission.Interface, selfLinker runtime.SelfLinker, auditSink audit.Sink) http.Handler {
0000000000000000000000000000000000000000;;		container := restful.NewContainer()
0000000000000000000000000000000000000000;;		container.Router(restful.CurlyRouter{})
0000000000000000000000000000000000000000;;		mux := container.ServeMux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template := APIGroupVersion{
0000000000000000000000000000000000000000;;			Storage: storage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Creater:   scheme,
0000000000000000000000000000000000000000;;			Convertor: scheme,
0000000000000000000000000000000000000000;;			Copier:    scheme,
0000000000000000000000000000000000000000;;			Defaulter: scheme,
0000000000000000000000000000000000000000;;			Typer:     scheme,
0000000000000000000000000000000000000000;;			Linker:    selfLinker,
0000000000000000000000000000000000000000;;			Mapper:    namespaceMapper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ParameterCodec: parameterCodec,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Admit:   admissionControl,
0000000000000000000000000000000000000000;;			Context: requestContextMapper,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// groupless v1 version
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			group := template
0000000000000000000000000000000000000000;;			group.Root = "/" + grouplessPrefix
0000000000000000000000000000000000000000;;			group.GroupVersion = grouplessGroupVersion
0000000000000000000000000000000000000000;;			group.OptionsExternalVersion = &grouplessGroupVersion
0000000000000000000000000000000000000000;;			group.Serializer = codecs
0000000000000000000000000000000000000000;;			if err := (&group).InstallREST(container); err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("unable to install container %s: %v", group.GroupVersion, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// group version 1
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			group := template
0000000000000000000000000000000000000000;;			group.Root = "/" + prefix
0000000000000000000000000000000000000000;;			group.GroupVersion = testGroupVersion
0000000000000000000000000000000000000000;;			group.OptionsExternalVersion = &testGroupVersion
0000000000000000000000000000000000000000;;			group.Serializer = codecs
0000000000000000000000000000000000000000;;			if err := (&group).InstallREST(container); err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("unable to install container %s: %v", group.GroupVersion, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// group version 2
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			group := template
0000000000000000000000000000000000000000;;			group.Root = "/" + prefix
0000000000000000000000000000000000000000;;			group.GroupVersion = newGroupVersion
0000000000000000000000000000000000000000;;			group.OptionsExternalVersion = &newGroupVersion
0000000000000000000000000000000000000000;;			group.Serializer = codecs
0000000000000000000000000000000000000000;;			if err := (&group).InstallREST(container); err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("unable to install container %s: %v", group.GroupVersion, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := genericapifilters.WithAudit(mux, requestContextMapper, auditSink, auditpolicy.FakeChecker(auditinternal.LevelRequestResponse), func(r *http.Request, requestInfo *request.RequestInfo) bool {
0000000000000000000000000000000000000000;;			// simplified long-running check
0000000000000000000000000000000000000000;;			return requestInfo.Verb == "watch" || requestInfo.Verb == "proxy"
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithRequestInfo(handler, testRequestInfoResolver(), requestContextMapper)
0000000000000000000000000000000000000000;;		handler = request.WithRequestContext(handler, requestContextMapper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &defaultAPIServer{handler, container}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testRequestInfoResolver() *request.RequestInfoFactory {
0000000000000000000000000000000000000000;;		return &request.RequestInfoFactory{
0000000000000000000000000000000000000000;;			APIPrefixes:          sets.NewString("api", "apis"),
0000000000000000000000000000000000000000;;			GrouplessAPIPrefixes: sets.NewString("api"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSimpleSetupRight(t *testing.T) {
0000000000000000000000000000000000000000;;		s := &genericapitesting.Simple{ObjectMeta: metav1.ObjectMeta{Name: "aName"}}
0000000000000000000000000000000000000000;;		wire, err := runtime.Encode(codec, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s2, err := runtime.Decode(codec, wire)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(s, s2) {
0000000000000000000000000000000000000000;;			t.Fatalf("encode/decode broken:\n%#v\n%#v\n", s, s2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSimpleOptionsSetupRight(t *testing.T) {
0000000000000000000000000000000000000000;;		s := &genericapitesting.SimpleGetOptions{}
0000000000000000000000000000000000000000;;		wire, err := runtime.Encode(codec, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s2, err := runtime.Decode(codec, wire)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(s, s2) {
0000000000000000000000000000000000000000;;			t.Fatalf("encode/decode broken:\n%#v\n%#v\n", s, s2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SimpleRESTStorage struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errors map[string]error
0000000000000000000000000000000000000000;;		list   []genericapitesting.Simple
0000000000000000000000000000000000000000;;		item   genericapitesting.Simple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updated *genericapitesting.Simple
0000000000000000000000000000000000000000;;		created *genericapitesting.Simple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream *SimpleStream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleted       string
0000000000000000000000000000000000000000;;		deleteOptions *metav1.DeleteOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualNamespace  string
0000000000000000000000000000000000000000;;		namespacePresent bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These are set when Watch is called
0000000000000000000000000000000000000000;;		fakeWatch                  *watch.FakeWatcher
0000000000000000000000000000000000000000;;		requestedLabelSelector     labels.Selector
0000000000000000000000000000000000000000;;		requestedFieldSelector     fields.Selector
0000000000000000000000000000000000000000;;		requestedUninitialized     bool
0000000000000000000000000000000000000000;;		requestedResourceVersion   string
0000000000000000000000000000000000000000;;		requestedResourceNamespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The id requested, and location to return for ResourceLocation
0000000000000000000000000000000000000000;;		requestedResourceLocationID string
0000000000000000000000000000000000000000;;		resourceLocation            *url.URL
0000000000000000000000000000000000000000;;		resourceLocationTransport   http.RoundTripper
0000000000000000000000000000000000000000;;		expectedResourceNamespace   string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If non-nil, called inside the WorkFunc when answering update, delete, create.
0000000000000000000000000000000000000000;;		// obj receives the original input to the update, delete, or create call.
0000000000000000000000000000000000000000;;		injectedFunction func(obj runtime.Object) (returnObj runtime.Object, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) Export(ctx request.Context, name string, opts metav1.ExportOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		obj, err := storage.Get(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s, ok := obj.(*genericapitesting.Simple)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected object")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set a marker to verify the method was called
0000000000000000000000000000000000000000;;		s.Other = "exported"
0000000000000000000000000000000000000000;;		return obj, storage.errors["export"]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) ConvertToTable(ctx request.Context, obj runtime.Object, tableOptions runtime.Object) (*metav1alpha1.Table, error) {
0000000000000000000000000000000000000000;;		return rest.NewDefaultTableConvertor(schema.GroupResource{Resource: "simple"}).ConvertToTable(ctx, obj, tableOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) List(ctx request.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		result := &genericapitesting.SimpleList{
0000000000000000000000000000000000000000;;			Items: storage.list,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.requestedLabelSelector = labels.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.LabelSelector != nil {
0000000000000000000000000000000000000000;;			storage.requestedLabelSelector = options.LabelSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.requestedFieldSelector = fields.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.FieldSelector != nil {
0000000000000000000000000000000000000000;;			storage.requestedFieldSelector = options.FieldSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.requestedUninitialized = options.IncludeUninitialized
0000000000000000000000000000000000000000;;		return result, storage.errors["list"]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SimpleStream struct {
0000000000000000000000000000000000000000;;		version     string
0000000000000000000000000000000000000000;;		accept      string
0000000000000000000000000000000000000000;;		contentType string
0000000000000000000000000000000000000000;;		err         error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SimpleStream) Close() error {
0000000000000000000000000000000000000000;;		s.closed = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *SimpleStream) GetObjectKind() schema.ObjectKind { return schema.EmptyObjectKind }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SimpleStream) InputStream(version, accept string) (io.ReadCloser, bool, string, error) {
0000000000000000000000000000000000000000;;		s.version = version
0000000000000000000000000000000000000000;;		s.accept = accept
0000000000000000000000000000000000000000;;		return s, false, s.contentType, s.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OutputConnect struct {
0000000000000000000000000000000000000000;;		response string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *OutputConnect) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		w.Write([]byte(h.response))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) Get(ctx request.Context, id string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		if id == "binary" {
0000000000000000000000000000000000000000;;			return storage.stream, storage.errors["get"]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copied, err := scheme.Copy(&storage.item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copied, storage.errors["get"]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) checkContext(ctx request.Context) {
0000000000000000000000000000000000000000;;		storage.actualNamespace, storage.namespacePresent = request.NamespaceFrom(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) Delete(ctx request.Context, id string, options *metav1.DeleteOptions) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		storage.deleted = id
0000000000000000000000000000000000000000;;		storage.deleteOptions = options
0000000000000000000000000000000000000000;;		if err := storage.errors["delete"]; err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var obj runtime.Object = &metav1.Status{Status: metav1.StatusSuccess}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if storage.injectedFunction != nil {
0000000000000000000000000000000000000000;;			obj, err = storage.injectedFunction(&genericapitesting.Simple{ObjectMeta: metav1.ObjectMeta{Name: id}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &genericapitesting.Simple{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) NewList() runtime.Object {
0000000000000000000000000000000000000000;;		return &genericapitesting.SimpleList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) Create(ctx request.Context, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		storage.created = obj.(*genericapitesting.Simple)
0000000000000000000000000000000000000000;;		if err := storage.errors["create"]; err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if storage.injectedFunction != nil {
0000000000000000000000000000000000000000;;			obj, err = storage.injectedFunction(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) Update(ctx request.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		obj, err := objInfo.UpdatedObject(ctx, &storage.item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.updated = obj.(*genericapitesting.Simple)
0000000000000000000000000000000000000000;;		if err := storage.errors["update"]; err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if storage.injectedFunction != nil {
0000000000000000000000000000000000000000;;			obj, err = storage.injectedFunction(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement ResourceWatcher.
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) Watch(ctx request.Context, options *metainternalversion.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		storage.lock.Lock()
0000000000000000000000000000000000000000;;		defer storage.lock.Unlock()
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		storage.requestedLabelSelector = labels.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.LabelSelector != nil {
0000000000000000000000000000000000000000;;			storage.requestedLabelSelector = options.LabelSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.requestedFieldSelector = fields.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.FieldSelector != nil {
0000000000000000000000000000000000000000;;			storage.requestedFieldSelector = options.FieldSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.requestedResourceVersion = ""
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			storage.requestedResourceVersion = options.ResourceVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.requestedResourceNamespace = request.NamespaceValue(ctx)
0000000000000000000000000000000000000000;;		if err := storage.errors["watch"]; err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.fakeWatch = watch.NewFake()
0000000000000000000000000000000000000000;;		return storage.fakeWatch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) Watcher() *watch.FakeWatcher {
0000000000000000000000000000000000000000;;		storage.lock.Lock()
0000000000000000000000000000000000000000;;		defer storage.lock.Unlock()
0000000000000000000000000000000000000000;;		return storage.fakeWatch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Redirector.
0000000000000000000000000000000000000000;;	var _ = rest.Redirector(&SimpleRESTStorage{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Redirector.
0000000000000000000000000000000000000000;;	func (storage *SimpleRESTStorage) ResourceLocation(ctx request.Context, id string) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		// validate that the namespace context on the request matches the expected input
0000000000000000000000000000000000000000;;		storage.requestedResourceNamespace = request.NamespaceValue(ctx)
0000000000000000000000000000000000000000;;		if storage.expectedResourceNamespace != storage.requestedResourceNamespace {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("Expected request namespace %s, but got namespace %s", storage.expectedResourceNamespace, storage.requestedResourceNamespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage.requestedResourceLocationID = id
0000000000000000000000000000000000000000;;		if err := storage.errors["resourceLocation"]; err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make a copy so the internal URL never gets mutated
0000000000000000000000000000000000000000;;		locationCopy := *storage.resourceLocation
0000000000000000000000000000000000000000;;		return &locationCopy, storage.resourceLocationTransport, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Connecter
0000000000000000000000000000000000000000;;	type ConnecterRESTStorage struct {
0000000000000000000000000000000000000000;;		connectHandler http.Handler
0000000000000000000000000000000000000000;;		handlerFunc    func() http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emptyConnectOptions    runtime.Object
0000000000000000000000000000000000000000;;		receivedConnectOptions runtime.Object
0000000000000000000000000000000000000000;;		receivedID             string
0000000000000000000000000000000000000000;;		receivedResponder      rest.Responder
0000000000000000000000000000000000000000;;		takesPath              string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Connecter
0000000000000000000000000000000000000000;;	var _ = rest.Connecter(&ConnecterRESTStorage{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ConnecterRESTStorage) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &genericapitesting.Simple{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ConnecterRESTStorage) Connect(ctx request.Context, id string, options runtime.Object, responder rest.Responder) (http.Handler, error) {
0000000000000000000000000000000000000000;;		s.receivedConnectOptions = options
0000000000000000000000000000000000000000;;		s.receivedID = id
0000000000000000000000000000000000000000;;		s.receivedResponder = responder
0000000000000000000000000000000000000000;;		if s.handlerFunc != nil {
0000000000000000000000000000000000000000;;			return s.handlerFunc(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.connectHandler, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ConnecterRESTStorage) ConnectMethods() []string {
0000000000000000000000000000000000000000;;		return []string{"GET", "POST", "PUT", "DELETE"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ConnecterRESTStorage) NewConnectOptions() (runtime.Object, bool, string) {
0000000000000000000000000000000000000000;;		if len(s.takesPath) > 0 {
0000000000000000000000000000000000000000;;			return s.emptyConnectOptions, true, s.takesPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.emptyConnectOptions, false, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LegacyRESTStorage struct {
0000000000000000000000000000000000000000;;		*SimpleRESTStorage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage LegacyRESTStorage) Delete(ctx request.Context, id string) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		obj, _, err := storage.SimpleRESTStorage.Delete(ctx, id, nil)
0000000000000000000000000000000000000000;;		return obj, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MetadataRESTStorage struct {
0000000000000000000000000000000000000000;;		*SimpleRESTStorage
0000000000000000000000000000000000000000;;		types []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MetadataRESTStorage) ProducesMIMETypes(method string) []string {
0000000000000000000000000000000000000000;;		return m.types
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MetadataRESTStorage) ProducesObject(verb string) interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ rest.StorageMetadata = &MetadataRESTStorage{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GetWithOptionsRESTStorage struct {
0000000000000000000000000000000000000000;;		*SimpleRESTStorage
0000000000000000000000000000000000000000;;		optionsReceived runtime.Object
0000000000000000000000000000000000000000;;		takesPath       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *GetWithOptionsRESTStorage) Get(ctx request.Context, name string, options runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if _, ok := options.(*genericapitesting.SimpleGetOptions); !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected options object: %#v", options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.optionsReceived = options
0000000000000000000000000000000000000000;;		return r.SimpleRESTStorage.Get(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *GetWithOptionsRESTStorage) NewGetOptions() (runtime.Object, bool, string) {
0000000000000000000000000000000000000000;;		if len(r.takesPath) > 0 {
0000000000000000000000000000000000000000;;			return &genericapitesting.SimpleGetOptions{}, true, r.takesPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &genericapitesting.SimpleGetOptions{}, false, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ rest.GetterWithOptions = &GetWithOptionsRESTStorage{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GetWithOptionsRootRESTStorage struct {
0000000000000000000000000000000000000000;;		*SimpleTypedStorage
0000000000000000000000000000000000000000;;		optionsReceived runtime.Object
0000000000000000000000000000000000000000;;		takesPath       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *GetWithOptionsRootRESTStorage) Get(ctx request.Context, name string, options runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if _, ok := options.(*genericapitesting.SimpleGetOptions); !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unexpected options object: %#v", options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.optionsReceived = options
0000000000000000000000000000000000000000;;		return r.SimpleTypedStorage.Get(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *GetWithOptionsRootRESTStorage) NewGetOptions() (runtime.Object, bool, string) {
0000000000000000000000000000000000000000;;		if len(r.takesPath) > 0 {
0000000000000000000000000000000000000000;;			return &genericapitesting.SimpleGetOptions{}, true, r.takesPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &genericapitesting.SimpleGetOptions{}, false, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ rest.GetterWithOptions = &GetWithOptionsRootRESTStorage{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamedCreaterRESTStorage struct {
0000000000000000000000000000000000000000;;		*SimpleRESTStorage
0000000000000000000000000000000000000000;;		createdName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *NamedCreaterRESTStorage) Create(ctx request.Context, name string, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		storage.created = obj.(*genericapitesting.Simple)
0000000000000000000000000000000000000000;;		storage.createdName = name
0000000000000000000000000000000000000000;;		if err := storage.errors["create"]; err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if storage.injectedFunction != nil {
0000000000000000000000000000000000000000;;			obj, err = storage.injectedFunction(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SimpleTypedStorage struct {
0000000000000000000000000000000000000000;;		errors   map[string]error
0000000000000000000000000000000000000000;;		item     runtime.Object
0000000000000000000000000000000000000000;;		baseType runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualNamespace  string
0000000000000000000000000000000000000000;;		namespacePresent bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleTypedStorage) New() runtime.Object {
0000000000000000000000000000000000000000;;		return storage.baseType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleTypedStorage) Get(ctx request.Context, id string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		storage.checkContext(ctx)
0000000000000000000000000000000000000000;;		copied, err := scheme.Copy(storage.item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copied, storage.errors["get"]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleTypedStorage) checkContext(ctx request.Context) {
0000000000000000000000000000000000000000;;		storage.actualNamespace, storage.namespacePresent = request.NamespaceFrom(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bodyOrDie(response *http.Response) string {
0000000000000000000000000000000000000000;;		defer response.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractBody(response *http.Response, object runtime.Object) (string, error) {
0000000000000000000000000000000000000000;;		return extractBodyDecoder(response, object, codec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractBodyDecoder(response *http.Response, object runtime.Object, decoder runtime.Decoder) (string, error) {
0000000000000000000000000000000000000000;;		defer response.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return string(body), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(body), runtime.DecodeInto(decoder, body, object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractBodyObject(response *http.Response, decoder runtime.Decoder) (runtime.Object, string, error) {
0000000000000000000000000000000000000000;;		defer response.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, string(body), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(decoder, body)
0000000000000000000000000000000000000000;;		return obj, string(body), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNotFound(t *testing.T) {
0000000000000000000000000000000000000000;;		type T struct {
0000000000000000000000000000000000000000;;			Method string
0000000000000000000000000000000000000000;;			Path   string
0000000000000000000000000000000000000000;;			Status int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cases := map[string]T{
0000000000000000000000000000000000000000;;			// Positive checks to make sure everything is wired correctly
0000000000000000000000000000000000000000;;			"groupless GET root":       {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simpleroots", http.StatusOK},
0000000000000000000000000000000000000000;;			"groupless GET namespaced": {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples", http.StatusOK},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"groupless GET long prefix": {"GET", "/" + grouplessPrefix + "/", http.StatusNotFound},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"groupless root PATCH method":                 {"PATCH", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simpleroots", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless root GET missing storage":          {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/blah", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless root GET with extra segment":       {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simpleroots/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless root DELETE without extra segment": {"DELETE", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simpleroots", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless root DELETE with extra segment":    {"DELETE", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simpleroots/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless root PUT without extra segment":    {"PUT", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simpleroots", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless root PUT with extra segment":       {"PUT", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simpleroots/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless root watch missing storage":        {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/watch/", http.StatusInternalServerError},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"groupless namespaced PATCH method":                 {"PATCH", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless namespaced GET long prefix":              {"GET", "/" + grouplessPrefix + "/", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless namespaced GET missing storage":          {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/blah", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless namespaced GET with extra segment":       {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless namespaced POST with extra segment":      {"POST", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples/bar", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless namespaced DELETE without extra segment": {"DELETE", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless namespaced DELETE with extra segment":    {"DELETE", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless namespaced PUT without extra segment":    {"PUT", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless namespaced PUT with extra segment":       {"PUT", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless namespaced watch missing storage":        {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/watch/", http.StatusInternalServerError},
0000000000000000000000000000000000000000;;			"groupless namespaced watch with bad method":        {"POST", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/watch/namespaces/ns/simples/bar", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"groupless namespaced watch param with bad method":  {"POST", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/ns/simples/bar?watch=true", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Positive checks to make sure everything is wired correctly
0000000000000000000000000000000000000000;;			"GET root": {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots", http.StatusOK},
0000000000000000000000000000000000000000;;			// TODO: JTL: "GET root item":       {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots/bar", http.StatusOK},
0000000000000000000000000000000000000000;;			"GET namespaced": {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples", http.StatusOK},
0000000000000000000000000000000000000000;;			// TODO: JTL: "GET namespaced item": {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples/bar", http.StatusOK},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"GET long prefix": {"GET", "/" + prefix + "/", http.StatusNotFound},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"root PATCH method":           {"PATCH", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"root GET missing storage":    {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/blah", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"root GET with extra segment": {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			// TODO: JTL: "root POST with extra segment":      {"POST", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots/bar", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"root DELETE without extra segment": {"DELETE", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"root DELETE with extra segment":    {"DELETE", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"root PUT without extra segment":    {"PUT", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"root PUT with extra segment":       {"PUT", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simpleroots/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"root watch missing storage":        {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/", http.StatusInternalServerError},
0000000000000000000000000000000000000000;;			// TODO: JTL: "root watch with bad method":        {"POST", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/simpleroot/bar", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"namespaced PATCH method":                 {"PATCH", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"namespaced GET long prefix":              {"GET", "/" + prefix + "/", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"namespaced GET missing storage":          {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/blah", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"namespaced GET with extra segment":       {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"namespaced POST with extra segment":      {"POST", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples/bar", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"namespaced DELETE without extra segment": {"DELETE", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"namespaced DELETE with extra segment":    {"DELETE", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"namespaced PUT without extra segment":    {"PUT", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"namespaced PUT with extra segment":       {"PUT", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples/bar/baz", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"namespaced watch missing storage":        {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/", http.StatusInternalServerError},
0000000000000000000000000000000000000000;;			"namespaced watch with bad method":        {"POST", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/namespaces/ns/simples/bar", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;			"namespaced watch param with bad method":  {"POST", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/ns/simples/bar?watch=true", http.StatusMethodNotAllowed},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simples":     &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simpleroots": &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		for k, v := range cases {
0000000000000000000000000000000000000000;;			request, err := http.NewRequest(v.Method, server.URL+v.Path, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			response, err := client.Do(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if response.StatusCode != v.Status {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %d for %s (%s), Got %#v", v.Status, v.Method, k, response)
0000000000000000000000000000000000000000;;				t.Errorf("MAPPER: %v", mapper)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UnimplementedRESTStorage struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (UnimplementedRESTStorage) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &genericapitesting.Simple{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestUnimplementedRESTStorage ensures that if a rest.Storage does not implement a given
0000000000000000000000000000000000000000;;	// method, that it is literally not registered with the server.  In the past,
0000000000000000000000000000000000000000;;	// we registered everything, and returned method not supported if it didn't support
0000000000000000000000000000000000000000;;	// a verb.  Now we literally do not register a storage if it does not implement anything.
0000000000000000000000000000000000000000;;	// TODO: in future, we should update proxy/redirect
0000000000000000000000000000000000000000;;	func TestUnimplementedRESTStorage(t *testing.T) {
0000000000000000000000000000000000000000;;		type T struct {
0000000000000000000000000000000000000000;;			Method  string
0000000000000000000000000000000000000000;;			Path    string
0000000000000000000000000000000000000000;;			ErrCode int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cases := map[string]T{
0000000000000000000000000000000000000000;;			"groupless GET object":    {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless GET list":      {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/foo", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless POST list":     {"POST", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/foo", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless PUT object":    {"PUT", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless DELETE object": {"DELETE", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless watch list":    {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/watch/foo", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless watch object":  {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/watch/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"groupless proxy object":  {"GET", "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/proxy/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"GET object":    {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"GET list":      {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/foo", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"POST list":     {"POST", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/foo", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"PUT object":    {"PUT", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"DELETE object": {"DELETE", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"watch list":    {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/foo", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"watch object":  {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/watch/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;			"proxy object":  {"GET", "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/proxy/foo/bar", http.StatusNotFound},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"foo": UnimplementedRESTStorage{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		for k, v := range cases {
0000000000000000000000000000000000000000;;			request, err := http.NewRequest(v.Method, server.URL+v.Path, bytes.NewReader([]byte(`{"kind":"Simple","apiVersion":"version"}`)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			response, err := client.Do(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer response.Body.Close()
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if response.StatusCode != v.ErrCode {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %d for %s, Got %s", k, v.ErrCode, v.Method, string(data))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestList(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			url       string
0000000000000000000000000000000000000000;;			namespace string
0000000000000000000000000000000000000000;;			selfLink  string
0000000000000000000000000000000000000000;;			legacy    bool
0000000000000000000000000000000000000000;;			label     string
0000000000000000000000000000000000000000;;			field     string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Groupless API
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// legacy namespace param is ignored
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple?namespace=",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple?namespace=other",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple?namespace=other&labelSelector=a%3Db&fieldSelector=c%3Dd",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;				label:     "a=b",
0000000000000000000000000000000000000000;;				field:     "c=d",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// legacy api version is honored
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple?labelSelector=a%3Db&fieldSelector=c%3Dd",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;				label:     "a=b",
0000000000000000000000000000000000000000;;				field:     "c=d",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// list items across all namespaces
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// list items in a namespace in the path
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;				namespace: "default",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple?labelSelector=a%3Db&fieldSelector=c%3Dd",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				label:     "a=b",
0000000000000000000000000000000000000000;;				field:     "c=d",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// list items across all namespaces
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Group API
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// legacy namespace param is ignored
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple?namespace=",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple?namespace=other",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple?namespace=other&labelSelector=a%3Db&fieldSelector=c%3Dd",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;				label:     "a=b",
0000000000000000000000000000000000000000;;				field:     "c=d",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// legacy api version is honored
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/other/simple?labelSelector=a%3Db&fieldSelector=c%3Dd",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;				label:     "a=b",
0000000000000000000000000000000000000000;;				field:     "c=d",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// list items across all namespaces
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				legacy:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// list items in a namespace in the path
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;				namespace: "default",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/other/simple?labelSelector=a%3Db&fieldSelector=c%3Dd",
0000000000000000000000000000000000000000;;				namespace: "other",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/other/simple",
0000000000000000000000000000000000000000;;				label:     "a=b",
0000000000000000000000000000000000000000;;				field:     "c=d",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// list items across all namespaces
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:       "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;				namespace: "",
0000000000000000000000000000000000000000;;				selfLink:  "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/simple",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;			simpleStorage := SimpleRESTStorage{expectedResourceNamespace: testCase.namespace}
0000000000000000000000000000000000000000;;			storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;			selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;				t:           t,
0000000000000000000000000000000000000000;;				namespace:   testCase.namespace,
0000000000000000000000000000000000000000;;				expectedSet: testCase.selfLink,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var handler = handleInternal(storage, admissionControl, selfLinker, nil)
0000000000000000000000000000000000000000;;			server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err := http.Get(server.URL + testCase.url)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected status: %d from url %s, Expected: %d, %#v", i, resp.StatusCode, testCase.url, http.StatusOK, resp)
0000000000000000000000000000000000000000;;				body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Logf("%d: body: %s", i, string(body))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: future, restore get links
0000000000000000000000000000000000000000;;			if !selfLinker.called {
0000000000000000000000000000000000000000;;				t.Errorf("%d: never set self link", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !simpleStorage.namespacePresent {
0000000000000000000000000000000000000000;;				t.Errorf("%d: namespace not set", i)
0000000000000000000000000000000000000000;;			} else if simpleStorage.actualNamespace != testCase.namespace {
0000000000000000000000000000000000000000;;				t.Errorf("%d: %q unexpected resource namespace: %s", i, testCase.url, simpleStorage.actualNamespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if simpleStorage.requestedLabelSelector == nil || simpleStorage.requestedLabelSelector.String() != testCase.label {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected label selector: expected=%v got=%v", i, testCase.label, simpleStorage.requestedLabelSelector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if simpleStorage.requestedFieldSelector == nil || simpleStorage.requestedFieldSelector.String() != testCase.field {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected field selector: expected=%v got=%v", i, testCase.field, simpleStorage.requestedFieldSelector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestsWithInvalidQuery(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storage["simple"] = &SimpleRESTStorage{expectedResourceNamespace: "default"}
0000000000000000000000000000000000000000;;		storage["withoptions"] = GetWithOptionsRESTStorage{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var handler = handleInternal(storage, admissionControl, selfLinker, nil)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range []struct {
0000000000000000000000000000000000000000;;			postfix string
0000000000000000000000000000000000000000;;			method  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"/simple?labelSelector=<invalid>", http.MethodGet},
0000000000000000000000000000000000000000;;			{"/simple/foo?gracePeriodSeconds=<invalid>", http.MethodDelete},
0000000000000000000000000000000000000000;;			// {"/simple?labelSelector=<value>", http.MethodDelete}, TODO: implement DeleteCollection in  SimpleRESTStorage
0000000000000000000000000000000000000000;;			// {"/simple/foo?export=<invalid>", http.MethodGet}, TODO: there is no invalid bool in conversion. Should we be more strict?
0000000000000000000000000000000000000000;;			// {"/simple/foo?resourceVersion=<invalid>", http.MethodGet}, TODO: there is no invalid resourceVersion. Should we be more strict?
0000000000000000000000000000000000000000;;			// {"/withoptions?labelSelector=<invalid>", http.MethodGet}, TODO: SimpleGetOptions is always valid. Add more validation that can fail.
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			baseURL := server.URL + "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/default"
0000000000000000000000000000000000000000;;			url := baseURL + test.postfix
0000000000000000000000000000000000000000;;			r, err := http.NewRequest(test.method, url, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected status: %d from url %s, Expected: %d, %#v", i, resp.StatusCode, url, http.StatusBadRequest, resp)
0000000000000000000000000000000000000000;;				body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Logf("%d: body: %s", i, string(body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListCompression(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			url            string
0000000000000000000000000000000000000000;;			namespace      string
0000000000000000000000000000000000000000;;			selfLink       string
0000000000000000000000000000000000000000;;			legacy         bool
0000000000000000000000000000000000000000;;			label          string
0000000000000000000000000000000000000000;;			field          string
0000000000000000000000000000000000000000;;			acceptEncoding string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// list items in a namespace in the path
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:            "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;				namespace:      "default",
0000000000000000000000000000000000000000;;				selfLink:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;				acceptEncoding: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:            "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;				namespace:      "default",
0000000000000000000000000000000000000000;;				selfLink:       "/" + grouplessPrefix + "/" + grouplessGroupVersion.Version + "/namespaces/default/simple",
0000000000000000000000000000000000000000;;				acceptEncoding: "gzip",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;			simpleStorage := SimpleRESTStorage{expectedResourceNamespace: testCase.namespace}
0000000000000000000000000000000000000000;;			storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;			selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;				t:           t,
0000000000000000000000000000000000000000;;				namespace:   testCase.namespace,
0000000000000000000000000000000000000000;;				expectedSet: testCase.selfLink,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var handler = handleInternal(storage, admissionControl, selfLinker, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestContextMapper = request.NewRequestContextMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			handler = filters.WithCompression(handler, requestContextMapper)
0000000000000000000000000000000000000000;;			handler = genericapifilters.WithRequestInfo(handler, newTestRequestInfoResolver(), requestContextMapper)
0000000000000000000000000000000000000000;;			handler = request.WithRequestContext(handler, requestContextMapper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			req, err := http.NewRequest("GET", server.URL+testCase.url, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// It's necessary to manually set Accept-Encoding here
0000000000000000000000000000000000000000;;			// to prevent http.DefaultClient from automatically
0000000000000000000000000000000000000000;;			// decoding responses
0000000000000000000000000000000000000000;;			req.Header.Set("Accept-Encoding", testCase.acceptEncoding)
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected status: %d from url %s, Expected: %d, %#v", i, resp.StatusCode, testCase.url, http.StatusOK, resp)
0000000000000000000000000000000000000000;;				body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Logf("%d: body: %s", i, string(body))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: future, restore get links
0000000000000000000000000000000000000000;;			if !selfLinker.called {
0000000000000000000000000000000000000000;;				t.Errorf("%d: never set self link", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !simpleStorage.namespacePresent {
0000000000000000000000000000000000000000;;				t.Errorf("%d: namespace not set", i)
0000000000000000000000000000000000000000;;			} else if simpleStorage.actualNamespace != testCase.namespace {
0000000000000000000000000000000000000000;;				t.Errorf("%d: %q unexpected resource namespace: %s", i, testCase.url, simpleStorage.actualNamespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if simpleStorage.requestedLabelSelector == nil || simpleStorage.requestedLabelSelector.String() != testCase.label {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected label selector: %v", i, simpleStorage.requestedLabelSelector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if simpleStorage.requestedFieldSelector == nil || simpleStorage.requestedFieldSelector.String() != testCase.field {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected field selector: %v", i, simpleStorage.requestedFieldSelector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var decoder *json.Decoder
0000000000000000000000000000000000000000;;			if testCase.acceptEncoding == "gzip" {
0000000000000000000000000000000000000000;;				gzipReader, err := gzip.NewReader(resp.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error creating gzip reader: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				decoder = json.NewDecoder(gzipReader)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				decoder = json.NewDecoder(resp.Body)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var itemOut genericapitesting.SimpleList
0000000000000000000000000000000000000000;;			err = decoder.Decode(&itemOut)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("failed to read response body as SimpleList: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLogs(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("GET", server.URL+"/logs", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("Data: %s", string(body))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestErrorList(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			errors: map[string]error{"list": fmt.Errorf("test Error")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusInternalServerError {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status: %d, Expected: %d, %#v", resp.StatusCode, http.StatusInternalServerError, resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNonEmptyList(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			list: []genericapitesting.Simple{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "something", Namespace: "other"},
0000000000000000000000000000000000000000;;					Other:      "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status: %d, Expected: %d, %#v", resp.StatusCode, http.StatusOK, resp)
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("Data: %s", string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var listOut genericapitesting.SimpleList
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &listOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Log(body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(listOut.Items) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response: %#v", listOut)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if listOut.Items[0].Other != simpleStorage.list[0].Other {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, %s", listOut.Items[0], string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if listOut.SelfLink != "/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/simple" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected list self link: %#v", listOut)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedSelfLink := "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/other/simple/something"
0000000000000000000000000000000000000000;;		if listOut.Items[0].ObjectMeta.SelfLink != expectedSelfLink {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, %s", listOut.Items[0].ObjectMeta.SelfLink, expectedSelfLink)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelfLinkSkipsEmptyName(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			list: []genericapitesting.Simple{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Namespace: "other"},
0000000000000000000000000000000000000000;;					Other:      "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status: %d, Expected: %d, %#v", resp.StatusCode, http.StatusOK, resp)
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("Data: %s", string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var listOut genericapitesting.SimpleList
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &listOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(listOut.Items) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response: %#v", listOut)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if listOut.Items[0].Other != simpleStorage.list[0].Other {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, %s", listOut.Items[0], string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if listOut.SelfLink != "/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/simple" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected list self link: %#v", listOut)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedSelfLink := ""
0000000000000000000000000000000000000000;;		if listOut.Items[0].ObjectMeta.SelfLink != expectedSelfLink {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, %s", listOut.Items[0].ObjectMeta.SelfLink, expectedSelfLink)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRootSelfLink(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := GetWithOptionsRootRESTStorage{
0000000000000000000000000000000000000000;;			SimpleTypedStorage: &SimpleTypedStorage{
0000000000000000000000000000000000000000;;				baseType: &genericapitesting.SimpleRoot{}, // a root scoped type
0000000000000000000000000000000000000000;;				item: &genericapitesting.SimpleRoot{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;					Other:      "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			takesPath: "atAPath",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		storage["simple/sub"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			url      string
0000000000000000000000000000000000000000;;			selfLink string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:      server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple/foo",
0000000000000000000000000000000000000000;;				selfLink: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple/foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				url:      server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple/foo/sub",
0000000000000000000000000000000000000000;;				selfLink: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/simple/foo/sub",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			resp, err := http.Get(test.url)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected status: %d, Expected: %d, %#v", resp.StatusCode, http.StatusOK, resp)
0000000000000000000000000000000000000000;;				body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Logf("Data: %s", string(body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var out genericapitesting.SimpleRoot
0000000000000000000000000000000000000000;;			if _, err := extractBody(resp, &out); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if out.SelfLink != test.selfLink {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected self link: %#v", out.SelfLink)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMetadata(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := &MetadataRESTStorage{&SimpleRESTStorage{}, []string{"text/plain"}}
0000000000000000000000000000000000000000;;		h := handle(map[string]rest.Storage{"simple": simpleStorage})
0000000000000000000000000000000000000000;;		ws := h.(*defaultAPIServer).container.RegisteredWebServices()
0000000000000000000000000000000000000000;;		if len(ws) == 0 {
0000000000000000000000000000000000000000;;			t.Fatal("no web services registered")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matches := map[string]int{}
0000000000000000000000000000000000000000;;		for _, w := range ws {
0000000000000000000000000000000000000000;;			for _, r := range w.Routes() {
0000000000000000000000000000000000000000;;				s := strings.Join(r.Produces, ",")
0000000000000000000000000000000000000000;;				i := matches[s]
0000000000000000000000000000000000000000;;				matches[s] = i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if matches["text/plain,application/json,application/yaml,application/vnd.kubernetes.protobuf"] == 0 ||
0000000000000000000000000000000000000000;;			matches["application/json,application/yaml,application/vnd.kubernetes.protobuf,application/json;stream=watch,application/vnd.kubernetes.protobuf;stream=watch"] == 0 ||
0000000000000000000000000000000000000000;;			matches["application/json,application/yaml,application/vnd.kubernetes.protobuf"] == 0 ||
0000000000000000000000000000000000000000;;			matches["*/*"] == 0 ||
0000000000000000000000000000000000000000;;			len(matches) != 5 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected mime types: %v", matches)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExport(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					ResourceVersion:   "1234",
0000000000000000000000000000000000000000;;					CreationTimestamp: metav1.NewTime(time.Unix(10, 10)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Other: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id",
0000000000000000000000000000000000000000;;			name:        "id",
0000000000000000000000000000000000000000;;			namespace:   "default",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id?export=true")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			data, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %#v\n%s\n", resp, string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if itemOut.Name != simpleStorage.item.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simpleStorage.item, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if itemOut.Other != "exported" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: exported, saw: %s", itemOut.Other)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGet(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;				Other: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id",
0000000000000000000000000000000000000000;;			name:        "id",
0000000000000000000000000000000000000000;;			namespace:   "default",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if itemOut.Name != simpleStorage.item.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simpleStorage.item, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetCompression(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;				Other: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id",
0000000000000000000000000000000000000000;;			name:        "id",
0000000000000000000000000000000000000000;;			namespace:   "default",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestContextMapper = request.NewRequestContextMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		handler = filters.WithCompression(handler, requestContextMapper)
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithRequestInfo(handler, newTestRequestInfoResolver(), requestContextMapper)
0000000000000000000000000000000000000000;;		handler = request.WithRequestContext(handler, requestContextMapper)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			acceptEncoding string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{acceptEncoding: ""},
0000000000000000000000000000000000000000;;			{acceptEncoding: "gzip"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			req, err := http.NewRequest("GET", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/id", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error cretaing request: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// It's necessary to manually set Accept-Encoding here
0000000000000000000000000000000000000000;;			// to prevent http.DefaultClient from automatically
0000000000000000000000000000000000000000;;			// decoding responses
0000000000000000000000000000000000000000;;			req.Header.Set("Accept-Encoding", test.acceptEncoding)
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var decoder *json.Decoder
0000000000000000000000000000000000000000;;			if test.acceptEncoding == "gzip" {
0000000000000000000000000000000000000000;;				gzipReader, err := gzip.NewReader(resp.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error creating gzip reader: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				decoder = json.NewDecoder(gzipReader)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				decoder = json.NewDecoder(resp.Body)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;			err = decoder.Decode(&itemOut)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error reading body: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if itemOut.Name != simpleStorage.item.Name {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simpleStorage.item, string(body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !selfLinker.called {
0000000000000000000000000000000000000000;;				t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetUninitialized(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			list: []genericapitesting.Simple{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Initializers: &metav1.Initializers{
0000000000000000000000000000000000000000;;							Pending: []metav1.Initializer{{Name: "test"}},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Other: "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:              t,
0000000000000000000000000000000000000000;;			expectedSet:    "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id",
0000000000000000000000000000000000000000;;			alternativeSet: sets.NewString("/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple"),
0000000000000000000000000000000000000000;;			name:           "id",
0000000000000000000000000000000000000000;;			namespace:      "default",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple?includeUninitialized=true")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.SimpleList
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(itemOut.Items) != 1 || itemOut.Items[0].Other != "foo" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simpleStorage.item, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !simpleStorage.requestedUninitialized {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't set correct flag")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPretty(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;				Other: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id",
0000000000000000000000000000000000000000;;			name:        "id",
0000000000000000000000000000000000000000;;			namespace:   "default",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			accept    string
0000000000000000000000000000000000000000;;			userAgent string
0000000000000000000000000000000000000000;;			params    url.Values
0000000000000000000000000000000000000000;;			pretty    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{accept: runtime.ContentTypeJSON},
0000000000000000000000000000000000000000;;			{accept: runtime.ContentTypeJSON + ";pretty=0"},
0000000000000000000000000000000000000000;;			{accept: runtime.ContentTypeJSON, userAgent: "kubectl"},
0000000000000000000000000000000000000000;;			{accept: runtime.ContentTypeJSON, params: url.Values{"pretty": {"0"}}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{pretty: true, accept: runtime.ContentTypeJSON, userAgent: "curl"},
0000000000000000000000000000000000000000;;			{pretty: true, accept: runtime.ContentTypeJSON, userAgent: "Mozilla/5.0"},
0000000000000000000000000000000000000000;;			{pretty: true, accept: runtime.ContentTypeJSON, userAgent: "Wget"},
0000000000000000000000000000000000000000;;			{pretty: true, accept: runtime.ContentTypeJSON + ";pretty=1"},
0000000000000000000000000000000000000000;;			{pretty: true, accept: runtime.ContentTypeJSON, params: url.Values{"pretty": {"1"}}},
0000000000000000000000000000000000000000;;			{pretty: true, accept: runtime.ContentTypeJSON, params: url.Values{"pretty": {"true"}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			u, err := url.Parse(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			u.RawQuery = test.params.Encode()
0000000000000000000000000000000000000000;;			req := &http.Request{Method: "GET", URL: u}
0000000000000000000000000000000000000000;;			req.Header = http.Header{}
0000000000000000000000000000000000000000;;			req.Header.Set("Accept", test.accept)
0000000000000000000000000000000000000000;;			req.Header.Set("User-Agent", test.userAgent)
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;			body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// to get stable ordering we need to use a go type
0000000000000000000000000000000000000000;;			unstructured := genericapitesting.Simple{}
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(body), &unstructured); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var expect string
0000000000000000000000000000000000000000;;			if test.pretty {
0000000000000000000000000000000000000000;;				out, err := json.MarshalIndent(unstructured, "", "  ")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expect = string(out)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out, err := json.Marshal(unstructured)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expect = string(out) + "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if expect != body {
0000000000000000000000000000000000000000;;				t.Errorf("%d: body did not match expected:\n%s\n%s", i, body, expect)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetTable(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		obj := genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo1", Namespace: "ns1", CreationTimestamp: now, UID: types.UID("abcdef0123")},
0000000000000000000000000000000000000000;;			Other:      "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: obj,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id",
0000000000000000000000000000000000000000;;			name:        "id",
0000000000000000000000000000000000000000;;			namespace:   "default",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := meta.Accessor(&obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		partial := meta.AsPartialObjectMetadata(m)
0000000000000000000000000000000000000000;;		partial.GetObjectKind().SetGroupVersionKind(metav1alpha1.SchemeGroupVersion.WithKind("PartialObjectMetadata"))
0000000000000000000000000000000000000000;;		encodedBody, err := runtime.Encode(metainternalversion.Codecs.LegacyCodec(metav1alpha1.SchemeGroupVersion), partial)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the codec includes a trailing newline that is not present during decode
0000000000000000000000000000000000000000;;		encodedBody = bytes.TrimSpace(encodedBody)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metaDoc := metav1.ObjectMeta{}.SwaggerDoc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			accept     string
0000000000000000000000000000000000000000;;			params     url.Values
0000000000000000000000000000000000000000;;			pretty     bool
0000000000000000000000000000000000000000;;			expected   *metav1alpha1.Table
0000000000000000000000000000000000000000;;			statusCode int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				accept:     runtime.ContentTypeJSON + ";as=Table;v=v1;g=meta.k8s.io",
0000000000000000000000000000000000000000;;				statusCode: http.StatusNotAcceptable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				accept: runtime.ContentTypeJSON + ";as=Table;v=v1alpha1;g=meta.k8s.io",
0000000000000000000000000000000000000000;;				expected: &metav1alpha1.Table{
0000000000000000000000000000000000000000;;					TypeMeta: metav1.TypeMeta{Kind: "Table", APIVersion: "meta.k8s.io/v1alpha1"},
0000000000000000000000000000000000000000;;					ColumnDefinitions: []metav1alpha1.TableColumnDefinition{
0000000000000000000000000000000000000000;;						{Name: "Name", Type: "string", Description: metaDoc["name"]},
0000000000000000000000000000000000000000;;						{Name: "Created At", Type: "date", Description: metaDoc["creationTimestamp"]},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Rows: []metav1alpha1.TableRow{
0000000000000000000000000000000000000000;;						{Cells: []interface{}{"foo1", now.Time.UTC().Format(time.RFC3339)}, Object: runtime.RawExtension{Raw: encodedBody}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			u, err := url.Parse(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			u.RawQuery = test.params.Encode()
0000000000000000000000000000000000000000;;			req := &http.Request{Method: "GET", URL: u}
0000000000000000000000000000000000000000;;			req.Header = http.Header{}
0000000000000000000000000000000000000000;;			req.Header.Set("Accept", test.accept)
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.statusCode != 0 {
0000000000000000000000000000000000000000;;				if resp.StatusCode != test.statusCode {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var itemOut metav1alpha1.Table
0000000000000000000000000000000000000000;;			if _, err = extractBody(resp, &itemOut); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expected, &itemOut) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: did not match: %s", i, diff.ObjectReflectDiff(test.expected, &itemOut))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetPartialObjectMetadata(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Time{metav1.Now().Rfc3339Copy().Local()}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "foo1", Namespace: "ns1", CreationTimestamp: now, UID: types.UID("abcdef0123")},
0000000000000000000000000000000000000000;;				Other:      "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			list: []genericapitesting.Simple{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo1", Namespace: "ns1", CreationTimestamp: now, UID: types.UID("newer")},
0000000000000000000000000000000000000000;;					Other:      "foo",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo2", Namespace: "ns2", CreationTimestamp: now, UID: types.UID("older")},
0000000000000000000000000000000000000000;;					Other:      "bar",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:              t,
0000000000000000000000000000000000000000;;			expectedSet:    "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id",
0000000000000000000000000000000000000000;;			alternativeSet: sets.NewString("/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple"),
0000000000000000000000000000000000000000;;			name:           "id",
0000000000000000000000000000000000000000;;			namespace:      "default",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			accept     string
0000000000000000000000000000000000000000;;			params     url.Values
0000000000000000000000000000000000000000;;			pretty     bool
0000000000000000000000000000000000000000;;			list       bool
0000000000000000000000000000000000000000;;			expected   runtime.Object
0000000000000000000000000000000000000000;;			expectKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;			statusCode int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				accept:     runtime.ContentTypeJSON + ";as=PartialObjectMetadata;v=v1;g=meta.k8s.io",
0000000000000000000000000000000000000000;;				statusCode: http.StatusNotAcceptable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				list:       true,
0000000000000000000000000000000000000000;;				accept:     runtime.ContentTypeJSON + ";as=PartialObjectMetadata;v=v1alpha1;g=meta.k8s.io",
0000000000000000000000000000000000000000;;				statusCode: http.StatusNotAcceptable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				accept:     runtime.ContentTypeJSON + ";as=PartialObjectMetadataList;v=v1alpha1;g=meta.k8s.io",
0000000000000000000000000000000000000000;;				statusCode: http.StatusNotAcceptable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				accept: runtime.ContentTypeJSON + ";as=PartialObjectMetadata;v=v1alpha1;g=meta.k8s.io",
0000000000000000000000000000000000000000;;				expected: &metav1alpha1.PartialObjectMetadata{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{Name: "foo1", Namespace: "ns1", CreationTimestamp: now, UID: types.UID("abcdef0123")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectKind: schema.GroupVersionKind{Kind: "PartialObjectMetadata", Group: "meta.k8s.io", Version: "v1alpha1"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				list:   true,
0000000000000000000000000000000000000000;;				accept: runtime.ContentTypeJSON + ";as=PartialObjectMetadataList;v=v1alpha1;g=meta.k8s.io",
0000000000000000000000000000000000000000;;				expected: &metav1alpha1.PartialObjectMetadataList{
0000000000000000000000000000000000000000;;					Items: []*metav1alpha1.PartialObjectMetadata{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							TypeMeta:   metav1.TypeMeta{APIVersion: "meta.k8s.io/v1alpha1", Kind: "PartialObjectMetadata"},
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{Name: "foo1", Namespace: "ns1", CreationTimestamp: now, UID: types.UID("newer")},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							TypeMeta:   metav1.TypeMeta{APIVersion: "meta.k8s.io/v1alpha1", Kind: "PartialObjectMetadata"},
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{Name: "foo2", Namespace: "ns2", CreationTimestamp: now, UID: types.UID("older")},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectKind: schema.GroupVersionKind{Kind: "PartialObjectMetadataList", Group: "meta.k8s.io", Version: "v1alpha1"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			suffix := "/namespaces/default/simple/id"
0000000000000000000000000000000000000000;;			if test.list {
0000000000000000000000000000000000000000;;				suffix = "/namespaces/default/simple"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			u, err := url.Parse(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + suffix)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			u.RawQuery = test.params.Encode()
0000000000000000000000000000000000000000;;			req := &http.Request{Method: "GET", URL: u}
0000000000000000000000000000000000000000;;			req.Header = http.Header{}
0000000000000000000000000000000000000000;;			req.Header.Set("Accept", test.accept)
0000000000000000000000000000000000000000;;			resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.statusCode != 0 {
0000000000000000000000000000000000000000;;				if resp.StatusCode != test.statusCode {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected response: %#v", i, resp)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("%d: invalid status: %#v\n%s", i, resp, bodyOrDie(resp))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			itemOut, body, err := extractBodyObject(resp, metainternalversion.Codecs.LegacyCodec(metav1alpha1.SchemeGroupVersion))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expected, itemOut) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: did not match: %s", i, diff.ObjectReflectDiff(test.expected, itemOut))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj := &unstructured.Unstructured{}
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(body), obj); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if obj.GetObjectKind().GroupVersionKind() != test.expectKind {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected kind: %#v", i, obj.GetObjectKind().GroupVersionKind())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetBinary(t *testing.T) {
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			stream: &SimpleStream{
0000000000000000000000000000000000000000;;				contentType: "text/plain",
0000000000000000000000000000000000000000;;				Reader:      bytes.NewBufferString("response data"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stream := simpleStorage.stream
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handle(map[string]rest.Storage{"simple": &simpleStorage}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/binary", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "text/other, */*")
0000000000000000000000000000000000000000;;		resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stream.closed || stream.version != testGroupVersion.String() || stream.accept != "text/other, */*" ||
0000000000000000000000000000000000000000;;			resp.Header.Get("Content-Type") != stream.contentType || string(body) != "response data" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected stream: %#v", stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateSimpleGetOptionsParams(t *testing.T, route *restful.Route) {
0000000000000000000000000000000000000000;;		// Validate name and description
0000000000000000000000000000000000000000;;		expectedParams := map[string]string{
0000000000000000000000000000000000000000;;			"param1":  "description for param1",
0000000000000000000000000000000000000000;;			"param2":  "description for param2",
0000000000000000000000000000000000000000;;			"atAPath": "",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range route.ParameterDocs {
0000000000000000000000000000000000000000;;			data := p.Data()
0000000000000000000000000000000000000000;;			if desc, exists := expectedParams[data.Name]; exists {
0000000000000000000000000000000000000000;;				if desc != data.Description {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected description for parameter %s: %s\n", data.Name, data.Description)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(expectedParams, data.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(expectedParams) > 0 {
0000000000000000000000000000000000000000;;			t.Errorf("did not find all expected parameters: %#v", expectedParams)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetWithOptionsRouteParams(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := GetWithOptionsRESTStorage{
0000000000000000000000000000000000000000;;			SimpleRESTStorage: &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		ws := handler.(*defaultAPIServer).container.RegisteredWebServices()
0000000000000000000000000000000000000000;;		if len(ws) == 0 {
0000000000000000000000000000000000000000;;			t.Fatal("no web services registered")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		routes := ws[0].Routes()
0000000000000000000000000000000000000000;;		for i := range routes {
0000000000000000000000000000000000000000;;			if routes[i].Method == "GET" && routes[i].Operation == "readNamespacedSimple" {
0000000000000000000000000000000000000000;;				validateSimpleGetOptionsParams(t, &routes[i])
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetWithOptions(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name         string
0000000000000000000000000000000000000000;;			rootScoped   bool
0000000000000000000000000000000000000000;;			requestURL   string
0000000000000000000000000000000000000000;;			expectedPath string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "basic",
0000000000000000000000000000000000000000;;				requestURL:   "/namespaces/default/simple/id?param1=test1&param2=test2",
0000000000000000000000000000000000000000;;				expectedPath: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "with path",
0000000000000000000000000000000000000000;;				requestURL:   "/namespaces/default/simple/id/a/different/path?param1=test1&param2=test2",
0000000000000000000000000000000000000000;;				expectedPath: "a/different/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "as subresource",
0000000000000000000000000000000000000000;;				requestURL:   "/namespaces/default/simple/id/subresource/another/different/path?param1=test1&param2=test2",
0000000000000000000000000000000000000000;;				expectedPath: "another/different/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "cluster-scoped basic",
0000000000000000000000000000000000000000;;				rootScoped:   true,
0000000000000000000000000000000000000000;;				requestURL:   "/simple/id?param1=test1&param2=test2",
0000000000000000000000000000000000000000;;				expectedPath: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "cluster-scoped basic with path",
0000000000000000000000000000000000000000;;				rootScoped:   true,
0000000000000000000000000000000000000000;;				requestURL:   "/simple/id/a/cluster/path?param1=test1&param2=test2",
0000000000000000000000000000000000000000;;				expectedPath: "a/cluster/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "cluster-scoped basic as subresource",
0000000000000000000000000000000000000000;;				rootScoped:   true,
0000000000000000000000000000000000000000;;				requestURL:   "/simple/id/subresource/another/cluster/path?param1=test1&param2=test2",
0000000000000000000000000000000000000000;;				expectedPath: "another/cluster/path",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			simpleStorage := GetWithOptionsRESTStorage{
0000000000000000000000000000000000000000;;				SimpleRESTStorage: &SimpleRESTStorage{
0000000000000000000000000000000000000000;;					item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;						Other: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				takesPath: "atAPath",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			simpleRootStorage := GetWithOptionsRootRESTStorage{
0000000000000000000000000000000000000000;;				SimpleTypedStorage: &SimpleTypedStorage{
0000000000000000000000000000000000000000;;					baseType: &genericapitesting.SimpleRoot{}, // a root scoped type
0000000000000000000000000000000000000000;;					item: &genericapitesting.SimpleRoot{
0000000000000000000000000000000000000000;;						Other: "foo",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				takesPath: "atAPath",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;			if test.rootScoped {
0000000000000000000000000000000000000000;;				storage["simple"] = &simpleRootStorage
0000000000000000000000000000000000000000;;				storage["simple/subresource"] = &simpleRootStorage
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;				storage["simple/subresource"] = &simpleStorage
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handler := handle(storage)
0000000000000000000000000000000000000000;;			server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + test.requestURL)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected response: %#v", test.name, resp)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;			body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if itemOut.Name != simpleStorage.item.Name {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected data: %#v, expected %#v (%s)", test.name, itemOut, simpleStorage.item, string(body))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var opts *genericapitesting.SimpleGetOptions
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			if test.rootScoped {
0000000000000000000000000000000000000000;;				opts, ok = simpleRootStorage.optionsReceived.(*genericapitesting.SimpleGetOptions)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				opts, ok = simpleStorage.optionsReceived.(*genericapitesting.SimpleGetOptions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected options object received: %#v", test.name, simpleStorage.optionsReceived)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.Param1 != "test1" || opts.Param2 != "test2" {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not receive expected options: %#v", test.name, opts)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if opts.Path != test.expectedPath {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Unexpected path value. Expected: %s. Actual: %s.", test.name, test.expectedPath, opts.Path)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAlternateSelfLink(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;				Other: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/test/simple/id",
0000000000000000000000000000000000000000;;			name:        "id",
0000000000000000000000000000000000000000;;			namespace:   "test",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/test/simple/id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if itemOut.Name != simpleStorage.item.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simpleStorage.item, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetNamespaceSelfLink(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.Simple{
0000000000000000000000000000000000000000;;				Other: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/foo/simple/id",
0000000000000000000000000000000000000000;;			name:        "id",
0000000000000000000000000000000000000000;;			namespace:   "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleInternal(storage, admissionControl, selfLinker, nil)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/foo/simple/id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if itemOut.Name != simpleStorage.item.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simpleStorage.item, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetMissing(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			errors: map[string]error{"get": apierrs.NewNotFound(schema.GroupResource{Resource: "simples"}, "id")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusNotFound {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetRetryAfter(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			errors: map[string]error{"get": apierrs.NewServerTimeout(schema.GroupResource{Resource: "simples"}, "id", 2)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusInternalServerError {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.Header.Get("Retry-After") != "2" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected Retry-After header: %v", resp.Header)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnect(t *testing.T) {
0000000000000000000000000000000000000000;;		responseText := "Hello World"
0000000000000000000000000000000000000000;;		itemID := "theID"
0000000000000000000000000000000000000000;;		connectStorage := &ConnecterRESTStorage{
0000000000000000000000000000000000000000;;			connectHandler: &OutputConnect{
0000000000000000000000000000000000000000;;				response: responseText,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":         &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/connect": connectStorage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + itemID + "/connect")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if connectStorage.receivedID != itemID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected item id. Expected: %s. Actual: %s.", itemID, connectStorage.receivedID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(body) != responseText {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response. Expected: %s. Actual: %s.", responseText, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnectResponderObject(t *testing.T) {
0000000000000000000000000000000000000000;;		itemID := "theID"
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{Other: "foo"}
0000000000000000000000000000000000000000;;		connectStorage := &ConnecterRESTStorage{}
0000000000000000000000000000000000000000;;		connectStorage.handlerFunc = func() http.Handler {
0000000000000000000000000000000000000000;;			return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				connectStorage.receivedResponder.Object(http.StatusCreated, simple)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":         &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/connect": connectStorage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + itemID + "/connect")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusCreated {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if connectStorage.receivedID != itemID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected item id. Expected: %s. Actual: %s.", itemID, connectStorage.receivedID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(codec, body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(obj, simple) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnectResponderError(t *testing.T) {
0000000000000000000000000000000000000000;;		itemID := "theID"
0000000000000000000000000000000000000000;;		connectStorage := &ConnecterRESTStorage{}
0000000000000000000000000000000000000000;;		connectStorage.handlerFunc = func() http.Handler {
0000000000000000000000000000000000000000;;			return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				connectStorage.receivedResponder.Error(apierrs.NewForbidden(schema.GroupResource{Resource: "simples"}, itemID, errors.New("you are terminated")))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":         &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/connect": connectStorage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + itemID + "/connect")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if connectStorage.receivedID != itemID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected item id. Expected: %s. Actual: %s.", itemID, connectStorage.receivedID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(codec, body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj.(*metav1.Status).Code != http.StatusForbidden {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnectWithOptionsRouteParams(t *testing.T) {
0000000000000000000000000000000000000000;;		connectStorage := &ConnecterRESTStorage{
0000000000000000000000000000000000000000;;			connectHandler:      &OutputConnect{},
0000000000000000000000000000000000000000;;			emptyConnectOptions: &genericapitesting.SimpleGetOptions{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":         &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/connect": connectStorage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		ws := handler.(*defaultAPIServer).container.RegisteredWebServices()
0000000000000000000000000000000000000000;;		if len(ws) == 0 {
0000000000000000000000000000000000000000;;			t.Fatal("no web services registered")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		routes := ws[0].Routes()
0000000000000000000000000000000000000000;;		for i := range routes {
0000000000000000000000000000000000000000;;			switch routes[i].Operation {
0000000000000000000000000000000000000000;;			case "connectGetNamespacedSimpleConnect":
0000000000000000000000000000000000000000;;			case "connectPostNamespacedSimpleConnect":
0000000000000000000000000000000000000000;;			case "connectPutNamespacedSimpleConnect":
0000000000000000000000000000000000000000;;			case "connectDeleteNamespacedSimpleConnect":
0000000000000000000000000000000000000000;;				validateSimpleGetOptionsParams(t, &routes[i])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnectWithOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		responseText := "Hello World"
0000000000000000000000000000000000000000;;		itemID := "theID"
0000000000000000000000000000000000000000;;		connectStorage := &ConnecterRESTStorage{
0000000000000000000000000000000000000000;;			connectHandler: &OutputConnect{
0000000000000000000000000000000000000000;;				response: responseText,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			emptyConnectOptions: &genericapitesting.SimpleGetOptions{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":         &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/connect": connectStorage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + itemID + "/connect?param1=value1&param2=value2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if connectStorage.receivedID != itemID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected item id. Expected: %s. Actual: %s.", itemID, connectStorage.receivedID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(body) != responseText {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response. Expected: %s. Actual: %s.", responseText, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if connectStorage.receivedResponder == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected responder")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts, ok := connectStorage.receivedConnectOptions.(*genericapitesting.SimpleGetOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected options type: %#v", connectStorage.receivedConnectOptions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Param1 != "value1" && opts.Param2 != "value2" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected options value: %#v", opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnectWithOptionsAndPath(t *testing.T) {
0000000000000000000000000000000000000000;;		responseText := "Hello World"
0000000000000000000000000000000000000000;;		itemID := "theID"
0000000000000000000000000000000000000000;;		testPath := "a/b/c/def"
0000000000000000000000000000000000000000;;		connectStorage := &ConnecterRESTStorage{
0000000000000000000000000000000000000000;;			connectHandler: &OutputConnect{
0000000000000000000000000000000000000000;;				response: responseText,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			emptyConnectOptions: &genericapitesting.SimpleGetOptions{},
0000000000000000000000000000000000000000;;			takesPath:           "atAPath",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":         &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/connect": connectStorage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + itemID + "/connect/" + testPath + "?param1=value1&param2=value2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if connectStorage.receivedID != itemID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected item id. Expected: %s. Actual: %s.", itemID, connectStorage.receivedID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(body) != responseText {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response. Expected: %s. Actual: %s.", responseText, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts, ok := connectStorage.receivedConnectOptions.(*genericapitesting.SimpleGetOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected options type: %#v", connectStorage.receivedConnectOptions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Param1 != "value1" && opts.Param2 != "value2" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected options value: %#v", opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Path != testPath {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected path value. Expected: %s. Actual: %s.", testPath, opts.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, nil)
0000000000000000000000000000000000000000;;		res, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleted != ID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected delete: %s, expected %s", simpleStorage.deleted, ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteWithOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grace := int64(300)
0000000000000000000000000000000000000000;;		item := &metav1.DeleteOptions{
0000000000000000000000000000000000000000;;			GracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(codec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		res, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %s %#v", request.URL, res)
0000000000000000000000000000000000000000;;			s, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf(string(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleted != ID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected delete: %s, expected %s", simpleStorage.deleted, ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage.deleteOptions.GetObjectKind().SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(simpleStorage.deleteOptions, item) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected delete options: %s", diff.ObjectDiff(simpleStorage.deleteOptions, item))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteWithOptionsQuery(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grace := int64(300)
0000000000000000000000000000000000000000;;		item := &metav1.DeleteOptions{
0000000000000000000000000000000000000000;;			GracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID+"?gracePeriodSeconds="+strconv.FormatInt(grace, 10), nil)
0000000000000000000000000000000000000000;;		res, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %s %#v", request.URL, res)
0000000000000000000000000000000000000000;;			s, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf(string(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleted != ID {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected delete: %s, expected %s", simpleStorage.deleted, ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage.deleteOptions.GetObjectKind().SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(simpleStorage.deleteOptions, item) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected delete options: %s", diff.ObjectDiff(simpleStorage.deleteOptions, item))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteWithOptionsQueryAndBody(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grace := int64(300)
0000000000000000000000000000000000000000;;		item := &metav1.DeleteOptions{
0000000000000000000000000000000000000000;;			GracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(codec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID+"?gracePeriodSeconds="+strconv.FormatInt(grace+10, 10), bytes.NewReader(body))
0000000000000000000000000000000000000000;;		res, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %s %#v", request.URL, res)
0000000000000000000000000000000000000000;;			s, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf(string(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleted != ID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected delete: %s, expected %s", simpleStorage.deleted, ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage.deleteOptions.GetObjectKind().SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(simpleStorage.deleteOptions, item) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected delete options: %s", diff.ObjectDiff(simpleStorage.deleteOptions, item))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLegacyDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = LegacyRESTStorage{&simpleStorage}
0000000000000000000000000000000000000000;;		var _ rest.Deleter = storage["simple"].(LegacyRESTStorage)
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, nil)
0000000000000000000000000000000000000000;;		res, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleted != ID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected delete: %s, expected %s", simpleStorage.deleted, ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleteOptions != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected delete options: %#v", simpleStorage.deleteOptions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLegacyDeleteIgnoresOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = LegacyRESTStorage{&simpleStorage}
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := metav1.NewDeleteOptions(300)
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(codec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		res, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %#v", res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleted != ID {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected delete: %s, expected %s", simpleStorage.deleted, ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simpleStorage.deleteOptions != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected delete options: %#v", simpleStorage.deleteOptions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteInvokesAdmissionControl(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleDeny(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, nil)
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteMissing(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			errors: map[string]error{"delete": apierrs.NewNotFound(schema.GroupResource{Resource: "simples"}, ID)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("DELETE", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, nil)
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusNotFound {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatch(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ID,
0000000000000000000000000000000000000000;;				Namespace: "", // update should allow the client to send an empty namespace
0000000000000000000000000000000000000000;;				UID:       "uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{item: *item}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + ID,
0000000000000000000000000000000000000000;;			name:        ID,
0000000000000000000000000000000000000000;;			namespace:   metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PATCH", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader([]byte(`{"labels":{"foo":"bar"}}`)))
0000000000000000000000000000000000000000;;		request.Header.Set("Content-Type", "application/merge-patch+json; charset=UTF-8")
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dump, _ := httputil.DumpResponse(response, true)
0000000000000000000000000000000000000000;;		t.Log(string(dump))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if simpleStorage.updated == nil || simpleStorage.updated.Labels["foo"] != "bar" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected update value %#v, expected %#v.", simpleStorage.updated, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPatchRequiresMatchingName(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ID,
0000000000000000000000000000000000000000;;				Namespace: "", // update should allow the client to send an empty namespace
0000000000000000000000000000000000000000;;				UID:       "uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{item: *item}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PATCH", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader([]byte(`{"metadata":{"name":"idbar"}}`)))
0000000000000000000000000000000000000000;;		request.Header.Set("Content-Type", "application/merge-patch+json")
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + ID,
0000000000000000000000000000000000000000;;			name:        ID,
0000000000000000000000000000000000000000;;			namespace:   metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ID,
0000000000000000000000000000000000000000;;				Namespace: "", // update should allow the client to send an empty namespace
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(testCodec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The following cases will fail, so die now
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dump, _ := httputil.DumpResponse(response, true)
0000000000000000000000000000000000000000;;		t.Log(string(dump))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if simpleStorage.updated == nil || simpleStorage.updated.Name != item.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected update value %#v, expected %#v.", simpleStorage.updated, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateInvokesAdmissionControl(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handleDeny(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ID,
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(testCodec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The following cases will fail, so die now
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dump, _ := httputil.DumpResponse(response, true)
0000000000000000000000000000000000000000;;		t.Log(string(dump))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateRequiresMatchingName(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(testCodec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The following cases will fail, so die now
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;			dump, _ := httputil.DumpResponse(response, true)
0000000000000000000000000000000000000000;;			t.Log(string(dump))
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateAllowsMissingNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: ID,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(testCodec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The following cases will fail, so die now
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dump, _ := httputil.DumpResponse(response, true)
0000000000000000000000000000000000000000;;		t.Log(string(dump))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// when the object name and namespace can't be retrieved, don't update.  It isn't safe.
0000000000000000000000000000000000000000;;	func TestUpdateDisallowsMismatchedNamespaceOnError(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:   t,
0000000000000000000000000000000000000000;;			err: fmt.Errorf("test error"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handleLinker(storage, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ID,
0000000000000000000000000000000000000000;;				Namespace: "other", // does not match request
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(testCodec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The following cases will fail, so die now
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dump, _ := httputil.DumpResponse(response, true)
0000000000000000000000000000000000000000;;		t.Log(string(dump))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if simpleStorage.updated != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected update value %#v.", simpleStorage.updated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("self link ignored")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdatePreventsMismatchedNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ID,
0000000000000000000000000000000000000000;;				Namespace: "other",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(testCodec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The following cases will fail, so die now
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateMissing(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		ID := "id"
0000000000000000000000000000000000000000;;		simpleStorage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			errors: map[string]error{"update": apierrs.NewNotFound(schema.GroupResource{Resource: "simples"}, ID)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage["simple"] = &simpleStorage
0000000000000000000000000000000000000000;;		handler := handle(storage)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ID,
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := runtime.Encode(testCodec, item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+ID, bytes.NewReader(body))
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusNotFound {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateNotFound(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple": &SimpleRESTStorage{
0000000000000000000000000000000000000000;;				// storage.Create can fail with not found error in theory.
0000000000000000000000000000000000000000;;				// See http://pr.k8s.io/486#discussion_r15037092.
0000000000000000000000000000000000000000;;				errors: map[string]error{"create": apierrs.NewNotFound(schema.GroupResource{Resource: "simples"}, "id")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{Other: "foo"}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusNotFound {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateChecksDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simple": &SimpleRESTStorage{}})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &example.Pod{}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		} else if !strings.Contains(string(b), "cannot be handled as a Simple") {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %s", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestUpdateREST tests that you can add new rest implementations to a pre-existing
0000000000000000000000000000000000000000;;	// web service.
0000000000000000000000000000000000000000;;	func TestUpdateREST(t *testing.T) {
0000000000000000000000000000000000000000;;		makeGroup := func(storage map[string]rest.Storage) *APIGroupVersion {
0000000000000000000000000000000000000000;;			return &APIGroupVersion{
0000000000000000000000000000000000000000;;				Storage:   storage,
0000000000000000000000000000000000000000;;				Root:      "/" + prefix,
0000000000000000000000000000000000000000;;				Creater:   scheme,
0000000000000000000000000000000000000000;;				Convertor: scheme,
0000000000000000000000000000000000000000;;				Copier:    scheme,
0000000000000000000000000000000000000000;;				Defaulter: scheme,
0000000000000000000000000000000000000000;;				Typer:     scheme,
0000000000000000000000000000000000000000;;				Linker:    selfLinker,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Admit:   admissionControl,
0000000000000000000000000000000000000000;;				Context: requestContextMapper,
0000000000000000000000000000000000000000;;				Mapper:  namespaceMapper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				GroupVersion:           newGroupVersion,
0000000000000000000000000000000000000000;;				OptionsExternalVersion: &newGroupVersion,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Serializer:     codecs,
0000000000000000000000000000000000000000;;				ParameterCodec: parameterCodec,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		makeStorage := func(paths ...string) map[string]rest.Storage {
0000000000000000000000000000000000000000;;			storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;			for _, s := range paths {
0000000000000000000000000000000000000000;;				storage[s] = &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return storage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testREST := func(t *testing.T, container *restful.Container, barCode int) {
0000000000000000000000000000000000000000;;			handler := genericapifilters.WithRequestInfo(container, newTestRequestInfoResolver(), requestContextMapper)
0000000000000000000000000000000000000000;;			handler = request.WithRequestContext(handler, requestContextMapper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w := httptest.NewRecorder()
0000000000000000000000000000000000000000;;			handler.ServeHTTP(w, &http.Request{Method: "GET", URL: &url.URL{Path: "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/test/foo/test"}})
0000000000000000000000000000000000000000;;			if w.Code != http.StatusOK {
0000000000000000000000000000000000000000;;				t.Fatalf("expected OK: %#v", w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w = httptest.NewRecorder()
0000000000000000000000000000000000000000;;			handler.ServeHTTP(w, &http.Request{Method: "GET", URL: &url.URL{Path: "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/test/bar/test"}})
0000000000000000000000000000000000000000;;			if w.Code != barCode {
0000000000000000000000000000000000000000;;				t.Errorf("expected response code %d for GET to bar but received %d", barCode, w.Code)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storage1 := makeStorage("foo")
0000000000000000000000000000000000000000;;		group1 := makeGroup(storage1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storage2 := makeStorage("bar")
0000000000000000000000000000000000000000;;		group2 := makeGroup(storage2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		container := restful.NewContainer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// install group1.  Ensure that
0000000000000000000000000000000000000000;;		// 1. Foo storage is accessible
0000000000000000000000000000000000000000;;		// 2. Bar storage is not accessible
0000000000000000000000000000000000000000;;		if err := group1.InstallREST(container); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testREST(t, container, http.StatusNotFound)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update with group2.  Ensure that
0000000000000000000000000000000000000000;;		// 1.  Foo storage is still accessible
0000000000000000000000000000000000000000;;		// 2.  Bar storage is now accessible
0000000000000000000000000000000000000000;;		if err := group2.UpdateREST(container); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testREST(t, container, http.StatusOK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to update a group that does not have an existing webservice with a matching prefix
0000000000000000000000000000000000000000;;		// should not affect the existing registered webservice
0000000000000000000000000000000000000000;;		invalidGroup := makeGroup(storage1)
0000000000000000000000000000000000000000;;		invalidGroup.Root = "bad"
0000000000000000000000000000000000000000;;		if err := invalidGroup.UpdateREST(container); err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected an error from UpdateREST when updating a non-existing prefix but got none")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testREST(t, container, http.StatusOK)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParentResourceIsRequired(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := &SimpleTypedStorage{
0000000000000000000000000000000000000000;;			baseType: &genericapitesting.SimpleRoot{}, // a root scoped type
0000000000000000000000000000000000000000;;			item:     &genericapitesting.SimpleRoot{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		group := &APIGroupVersion{
0000000000000000000000000000000000000000;;			Storage: map[string]rest.Storage{
0000000000000000000000000000000000000000;;				"simple/sub": storage,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Root:      "/" + prefix,
0000000000000000000000000000000000000000;;			Creater:   scheme,
0000000000000000000000000000000000000000;;			Convertor: scheme,
0000000000000000000000000000000000000000;;			Copier:    scheme,
0000000000000000000000000000000000000000;;			Defaulter: scheme,
0000000000000000000000000000000000000000;;			Typer:     scheme,
0000000000000000000000000000000000000000;;			Linker:    selfLinker,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Admit:   admissionControl,
0000000000000000000000000000000000000000;;			Context: requestContextMapper,
0000000000000000000000000000000000000000;;			Mapper:  namespaceMapper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			GroupVersion:           newGroupVersion,
0000000000000000000000000000000000000000;;			OptionsExternalVersion: &newGroupVersion,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Serializer:     codecs,
0000000000000000000000000000000000000000;;			ParameterCodec: parameterCodec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		container := restful.NewContainer()
0000000000000000000000000000000000000000;;		if err := group.InstallREST(container); err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storage = &SimpleTypedStorage{
0000000000000000000000000000000000000000;;			baseType: &genericapitesting.SimpleRoot{}, // a root scoped type
0000000000000000000000000000000000000000;;			item:     &genericapitesting.SimpleRoot{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		group = &APIGroupVersion{
0000000000000000000000000000000000000000;;			Storage: map[string]rest.Storage{
0000000000000000000000000000000000000000;;				"simple":     &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;				"simple/sub": storage,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Root:      "/" + prefix,
0000000000000000000000000000000000000000;;			Creater:   scheme,
0000000000000000000000000000000000000000;;			Convertor: scheme,
0000000000000000000000000000000000000000;;			Copier:    scheme,
0000000000000000000000000000000000000000;;			Defaulter: scheme,
0000000000000000000000000000000000000000;;			Typer:     scheme,
0000000000000000000000000000000000000000;;			Linker:    selfLinker,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Admit:   admissionControl,
0000000000000000000000000000000000000000;;			Context: requestContextMapper,
0000000000000000000000000000000000000000;;			Mapper:  namespaceMapper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			GroupVersion:           newGroupVersion,
0000000000000000000000000000000000000000;;			OptionsExternalVersion: &newGroupVersion,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Serializer:     codecs,
0000000000000000000000000000000000000000;;			ParameterCodec: parameterCodec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		container = restful.NewContainer()
0000000000000000000000000000000000000000;;		if err := group.InstallREST(container); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := genericapifilters.WithRequestInfo(container, newTestRequestInfoResolver(), requestContextMapper)
0000000000000000000000000000000000000000;;		handler = request.WithRequestContext(handler, requestContextMapper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// resource is NOT registered in the root scope
0000000000000000000000000000000000000000;;		w := httptest.NewRecorder()
0000000000000000000000000000000000000000;;		handler.ServeHTTP(w, &http.Request{Method: "GET", URL: &url.URL{Path: "/" + prefix + "/simple/test/sub"}})
0000000000000000000000000000000000000000;;		if w.Code != http.StatusNotFound {
0000000000000000000000000000000000000000;;			t.Errorf("expected not found: %#v", w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// resource is registered in the namespace scope
0000000000000000000000000000000000000000;;		w = httptest.NewRecorder()
0000000000000000000000000000000000000000;;		handler.ServeHTTP(w, &http.Request{Method: "GET", URL: &url.URL{Path: "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/test/simple/test/sub"}})
0000000000000000000000000000000000000000;;		if w.Code != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("expected OK: %#v", w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if storage.actualNamespace != "test" {
0000000000000000000000000000000000000000;;			t.Errorf("namespace should be set %#v", storage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateWithName(t *testing.T) {
0000000000000000000000000000000000000000;;		pathName := "helloworld"
0000000000000000000000000000000000000000;;		storage := &NamedCreaterRESTStorage{SimpleRESTStorage: &SimpleRESTStorage{}}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":     &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/sub": storage,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{Other: "foo"}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/"+pathName+"/sub", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusCreated {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if storage.createdName != pathName {
0000000000000000000000000000000000000000;;			t.Errorf("Did not get expected name in create context. Got: %s, Expected: %s", storage.createdName, pathName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateChecksDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simple": &SimpleRESTStorage{}})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &example.Pod{}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/bar", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v\n%s", response, readBodyOrDie(response.Body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		} else if !strings.Contains(string(b), "cannot be handled as a Simple") {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %s", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setTestSelfLinker struct {
0000000000000000000000000000000000000000;;		t              *testing.T
0000000000000000000000000000000000000000;;		expectedSet    string
0000000000000000000000000000000000000000;;		alternativeSet sets.String
0000000000000000000000000000000000000000;;		name           string
0000000000000000000000000000000000000000;;		namespace      string
0000000000000000000000000000000000000000;;		called         bool
0000000000000000000000000000000000000000;;		err            error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *setTestSelfLinker) Namespace(runtime.Object) (string, error) { return s.namespace, s.err }
0000000000000000000000000000000000000000;;	func (s *setTestSelfLinker) Name(runtime.Object) (string, error)      { return s.name, s.err }
0000000000000000000000000000000000000000;;	func (s *setTestSelfLinker) SelfLink(runtime.Object) (string, error)  { return "", s.err }
0000000000000000000000000000000000000000;;	func (s *setTestSelfLinker) SetSelfLink(obj runtime.Object, selfLink string) error {
0000000000000000000000000000000000000000;;		if e, a := s.expectedSet, selfLink; e != a {
0000000000000000000000000000000000000000;;			if !s.alternativeSet.Has(a) {
0000000000000000000000000000000000000000;;				s.t.Errorf("expected '%v', got '%v'", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.called = true
0000000000000000000000000000000000000000;;		return s.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			injectedFunction: func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				time.Sleep(5 * time.Millisecond)
0000000000000000000000000000000000000000;;				return obj, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			name:        "bar",
0000000000000000000000000000000000000000;;			namespace:   "default",
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/foo/bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handleLinker(map[string]rest.Storage{"foo": &storage}, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/foo", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		var response *http.Response
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			response, err = client.Do(request)
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;		body, err := extractBody(response, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v %#v", err, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemOut.GetObjectKind().SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(&itemOut, simple) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simple, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusCreated {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status: %d, Expected: %d, %#v", response.StatusCode, http.StatusOK, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateYAML(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			injectedFunction: func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				time.Sleep(5 * time.Millisecond)
0000000000000000000000000000000000000000;;				return obj, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			name:        "bar",
0000000000000000000000000000000000000000;;			namespace:   "default",
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/foo/bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handleLinker(map[string]rest.Storage{"foo": &storage}, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// yaml encoder
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, ok := runtime.SerializerInfoForMediaType(codecs.SupportedMediaTypes(), "application/yaml")
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatal("No yaml serializer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		encoder := codecs.EncoderForVersion(info.Serializer, testGroupVersion)
0000000000000000000000000000000000000000;;		decoder := codecs.DecoderToVersion(info.Serializer, testInternalGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(encoder, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/foo", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request.Header.Set("Accept", "application/yaml, application/json")
0000000000000000000000000000000000000000;;		request.Header.Set("Content-Type", "application/yaml")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		var response *http.Response
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			response, err = client.Do(request)
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;		body, err := extractBodyDecoder(response, &itemOut, decoder)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v %#v", err, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemOut.GetObjectKind().SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(&itemOut, simple) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simple, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusCreated {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status: %d, Expected: %d, %#v", response.StatusCode, http.StatusOK, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestCreateInNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			injectedFunction: func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				time.Sleep(5 * time.Millisecond)
0000000000000000000000000000000000000000;;				return obj, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			name:        "bar",
0000000000000000000000000000000000000000;;			namespace:   "other",
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/other/foo/bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handleLinker(map[string]rest.Storage{"foo": &storage}, selfLinker)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/other/foo", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		var response *http.Response
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			response, err = client.Do(request)
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.Simple
0000000000000000000000000000000000000000;;		body, err := extractBody(response, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v\n%s", err, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemOut.GetObjectKind().SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(&itemOut, simple) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, simple, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusCreated {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status: %d, Expected: %d, %#v", response.StatusCode, http.StatusOK, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selfLinker.called {
0000000000000000000000000000000000000000;;			t.Errorf("Never set self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateInvokesAdmissionControl(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			injectedFunction: func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				time.Sleep(5 * time.Millisecond)
0000000000000000000000000000000000000000;;				return obj, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfLinker := &setTestSelfLinker{
0000000000000000000000000000000000000000;;			t:           t,
0000000000000000000000000000000000000000;;			name:        "bar",
0000000000000000000000000000000000000000;;			namespace:   "other",
0000000000000000000000000000000000000000;;			expectedSet: "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/other/foo/bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handleInternal(map[string]rest.Storage{"foo": &storage}, alwaysDeny{}, selfLinker, nil)
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{
0000000000000000000000000000000000000000;;			Other: "bar",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/other/foo", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		var response *http.Response
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			response, err = client.Do(request)
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusForbidden {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status: %d, Expected: %d, %#v", response.StatusCode, http.StatusForbidden, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectApiStatus(t *testing.T, method, url string, data []byte, code int) *metav1.Status {
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest(method, url, bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %#v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error on %s %s: %v", method, url, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var status metav1.Status
0000000000000000000000000000000000000000;;		if body, err := extractBody(response, &status); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error on %s %s: %v\nbody:\n%s", method, url, err, body)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if code != response.StatusCode {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %s %s to return %d, Got %d", method, url, code, response.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDelayReturnsError(t *testing.T) {
0000000000000000000000000000000000000000;;		storage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			injectedFunction: func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return nil, apierrs.NewAlreadyExists(schema.GroupResource{Resource: "foos"}, "bar")
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"foo": &storage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := expectApiStatus(t, "DELETE", fmt.Sprintf("%s/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/foo/bar", server.URL), nil, http.StatusConflict)
0000000000000000000000000000000000000000;;		if status.Status != metav1.StatusFailure || status.Message == "" || status.Details == nil || status.Reason != metav1.StatusReasonAlreadyExists {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status %#v", status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UnregisteredAPIObject struct {
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *UnregisteredAPIObject) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteJSONDecodeError(t *testing.T) {
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			responsewriters.WriteObjectNegotiated(request.NewContext(), codecs, newGroupVersion, w, req, http.StatusOK, &UnregisteredAPIObject{"Undecodable"})
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		// We send a 200 status code before we encode the object, so we expect OK, but there will
0000000000000000000000000000000000000000;;		// still be an error object.  This seems ok, the alternative is to validate the object before
0000000000000000000000000000000000000000;;		// encoding, but this really should never happen, so it's wasted compute for every API request.
0000000000000000000000000000000000000000;;		status := expectApiStatus(t, "GET", server.URL, nil, http.StatusOK)
0000000000000000000000000000000000000000;;		if status.Reason != metav1.StatusReasonUnknown {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected reason %#v", status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(status.Message, "no kind is registered for the type endpoints.UnregisteredAPIObject") {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected message %#v", status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type marshalError struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *marshalError) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return []byte{}, m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteRAWJSONMarshalError(t *testing.T) {
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			responsewriters.WriteRawJSON(http.StatusOK, &marshalError{errors.New("Undecodable")}, w)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;		resp, err := client.Get(server.URL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusInternalServerError {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected status code %d", resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateTimeout(t *testing.T) {
0000000000000000000000000000000000000000;;		testOver := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(testOver)
0000000000000000000000000000000000000000;;		storage := SimpleRESTStorage{
0000000000000000000000000000000000000000;;			injectedFunction: func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				// Eliminate flakes by ensuring the create operation takes longer than this test.
0000000000000000000000000000000000000000;;				<-testOver
0000000000000000000000000000000000000000;;				return obj, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"foo": &storage,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{Other: "foo"}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		itemOut := expectApiStatus(t, "POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/foo?timeout=4ms", data, apierrs.StatusServerTimeout)
0000000000000000000000000000000000000000;;		if itemOut.Status != metav1.StatusFailure || itemOut.Reason != metav1.StatusReasonTimeout {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected status %#v", itemOut)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateChecksAPIVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simple": &SimpleRESTStorage{}})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{}
0000000000000000000000000000000000000000;;		//using newCodec and send the request to testVersion URL shall cause a discrepancy in apiVersion
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(newCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		} else if !strings.Contains(string(b), "does not match the expected API version") {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %s", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateDefaultsAPIVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simple": &SimpleRESTStorage{}})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &m); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(m, "apiVersion")
0000000000000000000000000000000000000000;;		data, err = json.Marshal(m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusCreated {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected status: %d, Expected: %d, %#v", response.StatusCode, http.StatusCreated, response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateChecksAPIVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simple": &SimpleRESTStorage{}})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &genericapitesting.Simple{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(newCodec, simple)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("PUT", server.URL+"/"+prefix+"/"+testGroupVersion.Group+"/"+testGroupVersion.Version+"/namespaces/default/simple/bar", bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected response %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		} else if !strings.Contains(string(b), "does not match the expected API version") {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected response: %s", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SimpleXGSubresourceRESTStorage struct {
0000000000000000000000000000000000000000;;		item genericapitesting.SimpleXGSubresource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleXGSubresourceRESTStorage) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &genericapitesting.SimpleXGSubresource{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storage *SimpleXGSubresourceRESTStorage) Get(ctx request.Context, id string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		copied, err := scheme.Copy(&storage.item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copied, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestXGSubresource(t *testing.T) {
0000000000000000000000000000000000000000;;		container := restful.NewContainer()
0000000000000000000000000000000000000000;;		container.Router(restful.CurlyRouter{})
0000000000000000000000000000000000000000;;		mux := container.ServeMux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemID := "theID"
0000000000000000000000000000000000000000;;		subresourceStorage := &SimpleXGSubresourceRESTStorage{
0000000000000000000000000000000000000000;;			item: genericapitesting.SimpleXGSubresource{
0000000000000000000000000000000000000000;;				SubresourceInfo: "foo",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage := map[string]rest.Storage{
0000000000000000000000000000000000000000;;			"simple":           &SimpleRESTStorage{},
0000000000000000000000000000000000000000;;			"simple/subsimple": subresourceStorage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		group := APIGroupVersion{
0000000000000000000000000000000000000000;;			Storage: storage,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Creater:   scheme,
0000000000000000000000000000000000000000;;			Convertor: scheme,
0000000000000000000000000000000000000000;;			Copier:    scheme,
0000000000000000000000000000000000000000;;			Defaulter: scheme,
0000000000000000000000000000000000000000;;			Typer:     scheme,
0000000000000000000000000000000000000000;;			Linker:    selfLinker,
0000000000000000000000000000000000000000;;			Mapper:    namespaceMapper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ParameterCodec: parameterCodec,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Admit:   admissionControl,
0000000000000000000000000000000000000000;;			Context: requestContextMapper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Root:                   "/" + prefix,
0000000000000000000000000000000000000000;;			GroupVersion:           testGroupVersion,
0000000000000000000000000000000000000000;;			OptionsExternalVersion: &testGroupVersion,
0000000000000000000000000000000000000000;;			Serializer:             codecs,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			SubresourceGroupVersionKind: map[string]schema.GroupVersionKind{
0000000000000000000000000000000000000000;;				"simple/subsimple": testGroup2Version.WithKind("SimpleXGSubresource"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := (&group).InstallREST(container); err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unable to install container %s: %v", group.GroupVersion, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := newTestServer(defaultAPIServer{mux, container})
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/" + prefix + "/" + testGroupVersion.Group + "/" + testGroupVersion.Version + "/namespaces/default/simple/" + itemID + "/subsimple")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected response: %#v", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var itemOut genericapitesting.SimpleXGSubresource
0000000000000000000000000000000000000000;;		body, err := extractBody(resp, &itemOut)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test if the returned object has the expected group, version and kind
0000000000000000000000000000000000000000;;		// We are directly unmarshaling JSON here because TypeMeta cannot be decoded through the
0000000000000000000000000000000000000000;;		// installed decoders. TypeMeta cannot be decoded because it is added to the ignored
0000000000000000000000000000000000000000;;		// conversion type list in API scheme and hence cannot be converted from input type object
0000000000000000000000000000000000000000;;		// to output type object. So it's values don't appear in the decoded output object.
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(strings.NewReader(body))
0000000000000000000000000000000000000000;;		var itemFromBody genericapitesting.SimpleXGSubresource
0000000000000000000000000000000000000000;;		err = decoder.Decode(&itemFromBody)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected JSON decoding error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if want := fmt.Sprintf("%s/%s", testGroup2Version.Group, testGroup2Version.Version); itemFromBody.APIVersion != want {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected APIVersion got: %+v want: %+v", itemFromBody.APIVersion, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if itemFromBody.Kind != "SimpleXGSubresource" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected Kind got: %+v want: SimpleXGSubresource", itemFromBody.Kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if itemOut.Name != subresourceStorage.item.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected data: %#v, expected %#v (%s)", itemOut, subresourceStorage.item, string(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readBodyOrDie(r io.Reader) []byte {
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return body
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkUpdateProtobuf measures the cost of processing an update on the server in proto
0000000000000000000000000000000000000000;;	func BenchmarkUpdateProtobuf(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simpleStorage := &SimpleRESTStorage{}
0000000000000000000000000000000000000000;;		handler := handle(map[string]rest.Storage{"simples": simpleStorage})
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dest, _ := url.Parse(server.URL)
0000000000000000000000000000000000000000;;		dest.Path = "/" + prefix + "/" + newGroupVersion.Group + "/" + newGroupVersion.Version + "/namespaces/foo/simples/bar"
0000000000000000000000000000000000000000;;		dest.RawQuery = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(codecs.SupportedMediaTypes(), "application/vnd.kubernetes.protobuf")
0000000000000000000000000000000000000000;;		e := codecs.EncoderForVersion(info.Serializer, newGroupVersion)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(e, &items[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			request, err := http.NewRequest("PUT", dest.String(), bytes.NewReader(data))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			request.Header.Set("Accept", "application/vnd.kubernetes.protobuf")
0000000000000000000000000000000000000000;;			request.Header.Set("Content-Type", "application/vnd.kubernetes.protobuf")
0000000000000000000000000000000000000000;;			response, err := client.Do(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if response.StatusCode != http.StatusBadRequest {
0000000000000000000000000000000000000000;;				body, _ := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;				b.Fatalf("Unexpected response %#v\n%s", response, body)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, _ = ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;			response.Body.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestServer(handler http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithRequestInfo(handler, newTestRequestInfoResolver(), requestContextMapper)
0000000000000000000000000000000000000000;;		handler = request.WithRequestContext(handler, requestContextMapper)
0000000000000000000000000000000000000000;;		return httptest.NewServer(handler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestRequestInfoResolver() *request.RequestInfoFactory {
0000000000000000000000000000000000000000;;		return &request.RequestInfoFactory{
0000000000000000000000000000000000000000;;			APIPrefixes:          sets.NewString("api", "apis"),
0000000000000000000000000000000000000000;;			GrouplessAPIPrefixes: sets.NewString("api"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const benchmarkSeed = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkItems(b *testing.B) []example.Pod {
0000000000000000000000000000000000000000;;		clientapiObjectFuzzer := apitesting.FuzzerFor(examplefuzzer.Funcs(b, codecs), rand.NewSource(benchmarkSeed))
0000000000000000000000000000000000000000;;		items := make([]example.Pod, 3)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			clientapiObjectFuzzer.Fuzz(&items[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return items
0000000000000000000000000000000000000000;;	}
