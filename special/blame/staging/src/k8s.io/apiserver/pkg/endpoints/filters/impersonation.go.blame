0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f9bb8fa053463593a16bc18c77bf5f4428634359;pkg/apiserver/handler_impersonation.go[pkg/apiserver/handler_impersonation.go][staging/src/k8s.io/apiserver/pkg/endpoints/filters/impersonation.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticationv1 "k8s.io/api/authentication/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/httplog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithImpersonation is a filter that will inspect and check requests that attempt to change the user.Info for their requests
0000000000000000000000000000000000000000;;	func WithImpersonation(handler http.Handler, requestContextMapper request.RequestContextMapper, a authorizer.Authorizer, s runtime.NegotiatedSerializer) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			impersonationRequests, err := buildImpersonationRequests(req.Header)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("%v", err)
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(impersonationRequests) == 0 {
0000000000000000000000000000000000000000;;				handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx, exists := requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("no context found for request"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestor, exists := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("no user found for request"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if groups are not specified, then we need to look them up differently depending on the type of user
0000000000000000000000000000000000000000;;			// if they are specified, then they are the authority (including the inclusion of system:authenticated/system:unauthenticated groups)
0000000000000000000000000000000000000000;;			groupsSpecified := len(req.Header[authenticationv1.ImpersonateGroupHeader]) > 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure we're allowed to impersonate each thing we're requesting.  While we're iterating through, start building username
0000000000000000000000000000000000000000;;			// and group information
0000000000000000000000000000000000000000;;			username := ""
0000000000000000000000000000000000000000;;			groups := []string{}
0000000000000000000000000000000000000000;;			userExtra := map[string][]string{}
0000000000000000000000000000000000000000;;			for _, impersonationRequest := range impersonationRequests {
0000000000000000000000000000000000000000;;				actingAsAttributes := &authorizer.AttributesRecord{
0000000000000000000000000000000000000000;;					User:            requestor,
0000000000000000000000000000000000000000;;					Verb:            "impersonate",
0000000000000000000000000000000000000000;;					APIGroup:        impersonationRequest.GetObjectKind().GroupVersionKind().Group,
0000000000000000000000000000000000000000;;					Namespace:       impersonationRequest.Namespace,
0000000000000000000000000000000000000000;;					Name:            impersonationRequest.Name,
0000000000000000000000000000000000000000;;					ResourceRequest: true,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch impersonationRequest.GetObjectKind().GroupVersionKind().GroupKind() {
0000000000000000000000000000000000000000;;				case v1.SchemeGroupVersion.WithKind("ServiceAccount").GroupKind():
0000000000000000000000000000000000000000;;					actingAsAttributes.Resource = "serviceaccounts"
0000000000000000000000000000000000000000;;					username = serviceaccount.MakeUsername(impersonationRequest.Namespace, impersonationRequest.Name)
0000000000000000000000000000000000000000;;					if !groupsSpecified {
0000000000000000000000000000000000000000;;						// if groups aren't specified for a service account, we know the groups because its a fixed mapping.  Add them
0000000000000000000000000000000000000000;;						groups = serviceaccount.MakeGroupNames(impersonationRequest.Namespace, impersonationRequest.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case v1.SchemeGroupVersion.WithKind("User").GroupKind():
0000000000000000000000000000000000000000;;					actingAsAttributes.Resource = "users"
0000000000000000000000000000000000000000;;					username = impersonationRequest.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case v1.SchemeGroupVersion.WithKind("Group").GroupKind():
0000000000000000000000000000000000000000;;					actingAsAttributes.Resource = "groups"
0000000000000000000000000000000000000000;;					groups = append(groups, impersonationRequest.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case authenticationv1.SchemeGroupVersion.WithKind("UserExtra").GroupKind():
0000000000000000000000000000000000000000;;					extraKey := impersonationRequest.FieldPath
0000000000000000000000000000000000000000;;					extraValue := impersonationRequest.Name
0000000000000000000000000000000000000000;;					actingAsAttributes.Resource = "userextras"
0000000000000000000000000000000000000000;;					actingAsAttributes.Subresource = extraKey
0000000000000000000000000000000000000000;;					userExtra[extraKey] = append(userExtra[extraKey], extraValue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					glog.V(4).Infof("unknown impersonation request type: %v", impersonationRequest)
0000000000000000000000000000000000000000;;					responsewriters.Forbidden(ctx, actingAsAttributes, w, req, fmt.Sprintf("unknown impersonation request type: %v", impersonationRequest), s)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				allowed, reason, err := a.Authorize(actingAsAttributes)
0000000000000000000000000000000000000000;;				if err != nil || !allowed {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Forbidden: %#v, Reason: %s, Error: %v", req.RequestURI, reason, err)
0000000000000000000000000000000000000000;;					responsewriters.Forbidden(ctx, actingAsAttributes, w, req, reason, s)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !groupsSpecified && username != user.Anonymous {
0000000000000000000000000000000000000000;;				// When impersonating a non-anonymous user, if no groups were specified
0000000000000000000000000000000000000000;;				// include the system:authenticated group in the impersonated user info
0000000000000000000000000000000000000000;;				groups = append(groups, user.AllAuthenticated)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newUser := &user.DefaultInfo{
0000000000000000000000000000000000000000;;				Name:   username,
0000000000000000000000000000000000000000;;				Groups: groups,
0000000000000000000000000000000000000000;;				Extra:  userExtra,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestContextMapper.Update(req, request.WithUser(ctx, newUser))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			oldUser, _ := request.UserFrom(ctx)
0000000000000000000000000000000000000000;;			httplog.LogOf(req, w).Addf("%v is acting as %v", oldUser, newUser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// clear all the impersonation headers from the request
0000000000000000000000000000000000000000;;			req.Header.Del(authenticationv1.ImpersonateUserHeader)
0000000000000000000000000000000000000000;;			req.Header.Del(authenticationv1.ImpersonateGroupHeader)
0000000000000000000000000000000000000000;;			for headerName := range req.Header {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(headerName, authenticationv1.ImpersonateUserExtraHeaderPrefix) {
0000000000000000000000000000000000000000;;					req.Header.Del(headerName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildImpersonationRequests returns a list of objectreferences that represent the different things we're requesting to impersonate.
0000000000000000000000000000000000000000;;	// Also includes a map[string][]string representing user.Info.Extra
0000000000000000000000000000000000000000;;	// Each request must be authorized against the current user before switching contexts.
0000000000000000000000000000000000000000;;	func buildImpersonationRequests(headers http.Header) ([]v1.ObjectReference, error) {
0000000000000000000000000000000000000000;;		impersonationRequests := []v1.ObjectReference{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestedUser := headers.Get(authenticationv1.ImpersonateUserHeader)
0000000000000000000000000000000000000000;;		hasUser := len(requestedUser) > 0
0000000000000000000000000000000000000000;;		if hasUser {
0000000000000000000000000000000000000000;;			if namespace, name, err := serviceaccount.SplitUsername(requestedUser); err == nil {
0000000000000000000000000000000000000000;;				impersonationRequests = append(impersonationRequests, v1.ObjectReference{Kind: "ServiceAccount", Namespace: namespace, Name: name})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				impersonationRequests = append(impersonationRequests, v1.ObjectReference{Kind: "User", Name: requestedUser})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasGroups := false
0000000000000000000000000000000000000000;;		for _, group := range headers[authenticationv1.ImpersonateGroupHeader] {
0000000000000000000000000000000000000000;;			hasGroups = true
0000000000000000000000000000000000000000;;			impersonationRequests = append(impersonationRequests, v1.ObjectReference{Kind: "Group", Name: group})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasUserExtra := false
0000000000000000000000000000000000000000;;		for headerName, values := range headers {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(headerName, authenticationv1.ImpersonateUserExtraHeaderPrefix) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hasUserExtra = true
0000000000000000000000000000000000000000;;			extraKey := strings.ToLower(headerName[len(authenticationv1.ImpersonateUserExtraHeaderPrefix):])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make a separate request for each extra value they're trying to set
0000000000000000000000000000000000000000;;			for _, value := range values {
0000000000000000000000000000000000000000;;				impersonationRequests = append(impersonationRequests,
0000000000000000000000000000000000000000;;					v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind: "UserExtra",
0000000000000000000000000000000000000000;;						// we only parse out a group above, but the parsing will fail if there isn't SOME version
0000000000000000000000000000000000000000;;						// using the internal version will help us fail if anyone starts using it
0000000000000000000000000000000000000000;;						APIVersion: authenticationv1.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;						Name:       value,
0000000000000000000000000000000000000000;;						// ObjectReference doesn't have a subresource field.  FieldPath is close and available, so we'll use that
0000000000000000000000000000000000000000;;						// TODO fight the good fight for ObjectReference to refer to resources and subresources
0000000000000000000000000000000000000000;;						FieldPath: extraKey,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (hasGroups || hasUserExtra) && !hasUser {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("requested %v without impersonating a user", impersonationRequests)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return impersonationRequests, nil
0000000000000000000000000000000000000000;;	}
