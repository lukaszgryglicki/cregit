0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7c76be717720b98ceba9f572697a551d221acd03;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticationapi "k8s.io/api/authentication/v1"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ http.ResponseWriter = &legacyAuditResponseWriter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type legacyAuditResponseWriter struct {
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;		out io.Writer
0000000000000000000000000000000000000000;;		id  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *legacyAuditResponseWriter) printResponse(code int) {
0000000000000000000000000000000000000000;;		line := fmt.Sprintf("%s AUDIT: id=%q response=\"%d\"\n", time.Now().Format(time.RFC3339Nano), a.id, code)
0000000000000000000000000000000000000000;;		if _, err := fmt.Fprint(a.out, line); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to write audit log: %s, the error is: %v", line, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *legacyAuditResponseWriter) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		a.printResponse(code)
0000000000000000000000000000000000000000;;		a.ResponseWriter.WriteHeader(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fancyLegacyResponseWriterDelegator implements http.CloseNotifier, http.Flusher and
0000000000000000000000000000000000000000;;	// http.Hijacker which are needed to make certain http operation (e.g. watch, rsh, etc)
0000000000000000000000000000000000000000;;	// working.
0000000000000000000000000000000000000000;;	type fancyLegacyResponseWriterDelegator struct {
0000000000000000000000000000000000000000;;		*legacyAuditResponseWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyLegacyResponseWriterDelegator) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return f.ResponseWriter.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyLegacyResponseWriterDelegator) Flush() {
0000000000000000000000000000000000000000;;		f.ResponseWriter.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyLegacyResponseWriterDelegator) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		// fake a response status before protocol switch happens
0000000000000000000000000000000000000000;;		f.printResponse(http.StatusSwitchingProtocols)
0000000000000000000000000000000000000000;;		return f.ResponseWriter.(http.Hijacker).Hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ http.CloseNotifier = &fancyLegacyResponseWriterDelegator{}
0000000000000000000000000000000000000000;;	var _ http.Flusher = &fancyLegacyResponseWriterDelegator{}
0000000000000000000000000000000000000000;;	var _ http.Hijacker = &fancyLegacyResponseWriterDelegator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithLegacyAudit decorates a http.Handler with audit logging information for all the
0000000000000000000000000000000000000000;;	// requests coming to the server. If out is nil, no decoration takes place.
0000000000000000000000000000000000000000;;	// Each audit log contains two entries:
0000000000000000000000000000000000000000;;	// 1. the request line containing:
0000000000000000000000000000000000000000;;	//    - unique id allowing to match the response line (see 2)
0000000000000000000000000000000000000000;;	//    - source ip of the request
0000000000000000000000000000000000000000;;	//    - HTTP method being invoked
0000000000000000000000000000000000000000;;	//    - original user invoking the operation
0000000000000000000000000000000000000000;;	//    - original user's groups info
0000000000000000000000000000000000000000;;	//    - impersonated user for the operation
0000000000000000000000000000000000000000;;	//    - impersonated groups info
0000000000000000000000000000000000000000;;	//    - namespace of the request or <none>
0000000000000000000000000000000000000000;;	//    - uri is the full URI as requested
0000000000000000000000000000000000000000;;	// 2. the response line containing:
0000000000000000000000000000000000000000;;	//    - the unique id from 1
0000000000000000000000000000000000000000;;	//    - response code
0000000000000000000000000000000000000000;;	func WithLegacyAudit(handler http.Handler, requestContextMapper request.RequestContextMapper, out io.Writer) http.Handler {
0000000000000000000000000000000000000000;;		if out == nil {
0000000000000000000000000000000000000000;;			return handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			ctx, ok := requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, errors.New("no context found for request"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attribs, err := GetAuthorizerAttributes(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(w, req, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			username := "<none>"
0000000000000000000000000000000000000000;;			groups := "<none>"
0000000000000000000000000000000000000000;;			if attribs.GetUser() != nil {
0000000000000000000000000000000000000000;;				username = attribs.GetUser().GetName()
0000000000000000000000000000000000000000;;				if userGroups := attribs.GetUser().GetGroups(); len(userGroups) > 0 {
0000000000000000000000000000000000000000;;					groups = auditStringSlice(userGroups)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			asuser := req.Header.Get(authenticationapi.ImpersonateUserHeader)
0000000000000000000000000000000000000000;;			if len(asuser) == 0 {
0000000000000000000000000000000000000000;;				asuser = "<self>"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			asgroups := "<lookup>"
0000000000000000000000000000000000000000;;			requestedGroups := req.Header[authenticationapi.ImpersonateGroupHeader]
0000000000000000000000000000000000000000;;			if len(requestedGroups) > 0 {
0000000000000000000000000000000000000000;;				asgroups = auditStringSlice(requestedGroups)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			namespace := attribs.GetNamespace()
0000000000000000000000000000000000000000;;			if len(namespace) == 0 {
0000000000000000000000000000000000000000;;				namespace = "<none>"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			id := uuid.NewRandom().String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			line := fmt.Sprintf("%s AUDIT: id=%q ip=%q method=%q user=%q groups=%q as=%q asgroups=%q namespace=%q uri=%q\n",
0000000000000000000000000000000000000000;;				time.Now().Format(time.RFC3339Nano), id, utilnet.GetClientIP(req), req.Method, username, groups, asuser, asgroups, namespace, req.URL)
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprint(out, line); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to write audit log: %s, the error is: %v", line, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			respWriter := legacyDecorateResponseWriter(w, out, id)
0000000000000000000000000000000000000000;;			handler.ServeHTTP(respWriter, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func auditStringSlice(inList []string) string {
0000000000000000000000000000000000000000;;		quotedElements := make([]string, len(inList))
0000000000000000000000000000000000000000;;		for i, in := range inList {
0000000000000000000000000000000000000000;;			quotedElements[i] = fmt.Sprintf("%q", in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(quotedElements, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func legacyDecorateResponseWriter(responseWriter http.ResponseWriter, out io.Writer, id string) http.ResponseWriter {
0000000000000000000000000000000000000000;;		delegate := &legacyAuditResponseWriter{ResponseWriter: responseWriter, out: out, id: id}
0000000000000000000000000000000000000000;;		// check if the ResponseWriter we're wrapping is the fancy one we need
0000000000000000000000000000000000000000;;		// or if the basic is sufficient
0000000000000000000000000000000000000000;;		_, cn := responseWriter.(http.CloseNotifier)
0000000000000000000000000000000000000000;;		_, fl := responseWriter.(http.Flusher)
0000000000000000000000000000000000000000;;		_, hj := responseWriter.(http.Hijacker)
0000000000000000000000000000000000000000;;		if cn && fl && hj {
0000000000000000000000000000000000000000;;			return &fancyLegacyResponseWriterDelegator{delegate}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return delegate
0000000000000000000000000000000000000000;;	}
