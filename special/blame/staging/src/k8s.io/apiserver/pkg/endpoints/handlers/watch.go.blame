0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
59b364beac7300fe1d44d59d6bc25cb7b38ef36c;pkg/apiserver/watch.go[pkg/apiserver/watch.go][staging/src/k8s.io/apiserver/pkg/endpoints/handlers/watch.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package handlers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/streaming"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/negotiation"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/httplog"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/wsstream"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nothing will ever be sent down this channel
0000000000000000000000000000000000000000;;	var neverExitWatch <-chan time.Time = make(chan time.Time)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timeoutFactory abstracts watch timeout logic for testing
0000000000000000000000000000000000000000;;	type TimeoutFactory interface {
0000000000000000000000000000000000000000;;		TimeoutCh() (<-chan time.Time, func() bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// realTimeoutFactory implements timeoutFactory
0000000000000000000000000000000000000000;;	type realTimeoutFactory struct {
0000000000000000000000000000000000000000;;		timeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeoutChan returns a channel which will receive something when the watch times out,
0000000000000000000000000000000000000000;;	// and a cleanup function to call when this happens.
0000000000000000000000000000000000000000;;	func (w *realTimeoutFactory) TimeoutCh() (<-chan time.Time, func() bool) {
0000000000000000000000000000000000000000;;		if w.timeout == 0 {
0000000000000000000000000000000000000000;;			return neverExitWatch, func() bool { return false }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := time.NewTimer(w.timeout)
0000000000000000000000000000000000000000;;		return t.C, t.Stop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveWatch handles serving requests to the server
0000000000000000000000000000000000000000;;	// TODO: the functionality in this method and in WatchServer.Serve is not cleanly decoupled.
0000000000000000000000000000000000000000;;	func serveWatch(watcher watch.Interface, scope RequestScope, req *http.Request, w http.ResponseWriter, timeout time.Duration) {
0000000000000000000000000000000000000000;;		// negotiate for the stream serializer
0000000000000000000000000000000000000000;;		serializer, err := negotiation.NegotiateOutputStreamSerializer(req, scope.Serializer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			scope.err(err, w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		framer := serializer.StreamSerializer.Framer
0000000000000000000000000000000000000000;;		streamSerializer := serializer.StreamSerializer.Serializer
0000000000000000000000000000000000000000;;		embedded := serializer.Serializer
0000000000000000000000000000000000000000;;		if framer == nil {
0000000000000000000000000000000000000000;;			scope.err(fmt.Errorf("no framer defined for %q available for embedded encoding", serializer.MediaType), w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		encoder := scope.Serializer.EncoderForVersion(streamSerializer, scope.Kind.GroupVersion())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		useTextFraming := serializer.EncodesAsText
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the embedded serializer matching the media type
0000000000000000000000000000000000000000;;		embeddedEncoder := scope.Serializer.EncoderForVersion(embedded, scope.Kind.GroupVersion())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: next step, get back mediaTypeOptions from negotiate and return the exact value here
0000000000000000000000000000000000000000;;		mediaType := serializer.MediaType
0000000000000000000000000000000000000000;;		if mediaType != runtime.ContentTypeJSON {
0000000000000000000000000000000000000000;;			mediaType += ";stream=watch"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := scope.ContextFunc(req)
0000000000000000000000000000000000000000;;		requestInfo, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			scope.err(fmt.Errorf("missing requestInfo"), w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := &WatchServer{
0000000000000000000000000000000000000000;;			Watching: watcher,
0000000000000000000000000000000000000000;;			Scope:    scope,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			UseTextFraming:  useTextFraming,
0000000000000000000000000000000000000000;;			MediaType:       mediaType,
0000000000000000000000000000000000000000;;			Framer:          framer,
0000000000000000000000000000000000000000;;			Encoder:         encoder,
0000000000000000000000000000000000000000;;			EmbeddedEncoder: embeddedEncoder,
0000000000000000000000000000000000000000;;			Fixup: func(obj runtime.Object) {
0000000000000000000000000000000000000000;;				if err := setSelfLink(obj, requestInfo, scope.Namer); err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("failed to set link for object %v: %v", reflect.TypeOf(obj), err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			TimeoutFactory: &realTimeoutFactory{timeout},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WatchServer serves a watch.Interface over a websocket or vanilla HTTP.
0000000000000000000000000000000000000000;;	type WatchServer struct {
0000000000000000000000000000000000000000;;		Watching watch.Interface
0000000000000000000000000000000000000000;;		Scope    RequestScope
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// true if websocket messages should use text framing (as opposed to binary framing)
0000000000000000000000000000000000000000;;		UseTextFraming bool
0000000000000000000000000000000000000000;;		// the media type this watch is being served with
0000000000000000000000000000000000000000;;		MediaType string
0000000000000000000000000000000000000000;;		// used to frame the watch stream
0000000000000000000000000000000000000000;;		Framer runtime.Framer
0000000000000000000000000000000000000000;;		// used to encode the watch stream event itself
0000000000000000000000000000000000000000;;		Encoder runtime.Encoder
0000000000000000000000000000000000000000;;		// used to encode the nested object in the watch stream
0000000000000000000000000000000000000000;;		EmbeddedEncoder runtime.Encoder
0000000000000000000000000000000000000000;;		Fixup           func(runtime.Object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TimeoutFactory TimeoutFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP serves a series of encoded events via HTTP with Transfer-Encoding: chunked
0000000000000000000000000000000000000000;;	// or over a websocket connection.
0000000000000000000000000000000000000000;;	func (s *WatchServer) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		w = httplog.Unlogged(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if wsstream.IsWebSocketRequest(req) {
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", s.MediaType)
0000000000000000000000000000000000000000;;			websocket.Handler(s.HandleWS).ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cn, ok := w.(http.CloseNotifier)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("unable to start watch - can't get http.CloseNotifier: %#v", w)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			s.Scope.err(errors.NewInternalError(err), w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flusher, ok := w.(http.Flusher)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("unable to start watch - can't get http.Flusher: %#v", w)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			s.Scope.err(errors.NewInternalError(err), w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framer := s.Framer.NewFrameWriter(w)
0000000000000000000000000000000000000000;;		if framer == nil {
0000000000000000000000000000000000000000;;			// programmer error
0000000000000000000000000000000000000000;;			err := fmt.Errorf("no stream framing support is available for media type %q", s.MediaType)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			s.Scope.err(errors.NewBadRequest(err.Error()), w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := streaming.NewEncoder(framer, s.Encoder)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure the connection times out
0000000000000000000000000000000000000000;;		timeoutCh, cleanup := s.TimeoutFactory.TimeoutCh()
0000000000000000000000000000000000000000;;		defer cleanup()
0000000000000000000000000000000000000000;;		defer s.Watching.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// begin the stream
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", s.MediaType)
0000000000000000000000000000000000000000;;		w.Header().Set("Transfer-Encoding", "chunked")
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		flusher.Flush()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var unknown runtime.Unknown
0000000000000000000000000000000000000000;;		internalEvent := &metav1.InternalEvent{}
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		ch := s.Watching.ResultChan()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-cn.CloseNotify():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-timeoutCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case event, ok := <-ch:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// End of results.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				obj := event.Object
0000000000000000000000000000000000000000;;				s.Fixup(obj)
0000000000000000000000000000000000000000;;				if err := s.EmbeddedEncoder.Encode(obj, buf); err != nil {
0000000000000000000000000000000000000000;;					// unexpected error
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("unable to encode watch object: %v", err))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// ContentType is not required here because we are defaulting to the serializer
0000000000000000000000000000000000000000;;				// type
0000000000000000000000000000000000000000;;				unknown.Raw = buf.Bytes()
0000000000000000000000000000000000000000;;				event.Object = &unknown
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create the external type directly and encode it.  Clients will only recognize the serialization we provide.
0000000000000000000000000000000000000000;;				// The internal event is being reused, not reallocated so its just a few extra assignments to do it this way
0000000000000000000000000000000000000000;;				// and we get the benefit of using conversion functions which already have to stay in sync
0000000000000000000000000000000000000000;;				outEvent := &metav1.WatchEvent{}
0000000000000000000000000000000000000000;;				*internalEvent = metav1.InternalEvent(event)
0000000000000000000000000000000000000000;;				err := metav1.Convert_versioned_InternalEvent_to_versioned_Event(internalEvent, outEvent, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("unable to convert watch object: %v", err))
0000000000000000000000000000000000000000;;					// client disconnect.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := e.Encode(outEvent); err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("unable to encode watch object: %v (%#v)", err, e))
0000000000000000000000000000000000000000;;					// client disconnect.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(ch) == 0 {
0000000000000000000000000000000000000000;;					flusher.Flush()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				buf.Reset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleWS implements a websocket handler.
0000000000000000000000000000000000000000;;	func (s *WatchServer) HandleWS(ws *websocket.Conn) {
0000000000000000000000000000000000000000;;		defer ws.Close()
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;			// This blocks until the connection is closed.
0000000000000000000000000000000000000000;;			// Client should not send anything.
0000000000000000000000000000000000000000;;			wsstream.IgnoreReceives(ws, 0)
0000000000000000000000000000000000000000;;			// Once the client closes, we should also close
0000000000000000000000000000000000000000;;			close(done)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var unknown runtime.Unknown
0000000000000000000000000000000000000000;;		internalEvent := &metav1.InternalEvent{}
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		streamBuf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		ch := s.Watching.ResultChan()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-done:
0000000000000000000000000000000000000000;;				s.Watching.Stop()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case event, ok := <-ch:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// End of results.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				obj := event.Object
0000000000000000000000000000000000000000;;				s.Fixup(obj)
0000000000000000000000000000000000000000;;				if err := s.EmbeddedEncoder.Encode(obj, buf); err != nil {
0000000000000000000000000000000000000000;;					// unexpected error
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("unable to encode watch object: %v", err))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// ContentType is not required here because we are defaulting to the serializer
0000000000000000000000000000000000000000;;				// type
0000000000000000000000000000000000000000;;				unknown.Raw = buf.Bytes()
0000000000000000000000000000000000000000;;				event.Object = &unknown
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// the internal event will be versioned by the encoder
0000000000000000000000000000000000000000;;				// create the external type directly and encode it.  Clients will only recognize the serialization we provide.
0000000000000000000000000000000000000000;;				// The internal event is being reused, not reallocated so its just a few extra assignments to do it this way
0000000000000000000000000000000000000000;;				// and we get the benefit of using conversion functions which already have to stay in sync
0000000000000000000000000000000000000000;;				outEvent := &metav1.WatchEvent{}
0000000000000000000000000000000000000000;;				*internalEvent = metav1.InternalEvent(event)
0000000000000000000000000000000000000000;;				err := metav1.Convert_versioned_InternalEvent_to_versioned_Event(internalEvent, outEvent, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("unable to convert watch object: %v", err))
0000000000000000000000000000000000000000;;					// client disconnect.
0000000000000000000000000000000000000000;;					s.Watching.Stop()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := s.Encoder.Encode(outEvent, streamBuf); err != nil {
0000000000000000000000000000000000000000;;					// encoding error
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("unable to encode event: %v", err))
0000000000000000000000000000000000000000;;					s.Watching.Stop()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if s.UseTextFraming {
0000000000000000000000000000000000000000;;					if err := websocket.Message.Send(ws, streamBuf.String()); err != nil {
0000000000000000000000000000000000000000;;						// Client disconnect.
0000000000000000000000000000000000000000;;						s.Watching.Stop()
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err := websocket.Message.Send(ws, streamBuf.Bytes()); err != nil {
0000000000000000000000000000000000000000;;						// Client disconnect.
0000000000000000000000000000000000000000;;						s.Watching.Stop()
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.Reset()
0000000000000000000000000000000000000000;;				streamBuf.Reset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
