0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2d509fc0ef3a21f78ad3a055140ea33dc598e966;pkg/storage/util.go[pkg/storage/util.go][staging/src/k8s.io/apiserver/pkg/storage/util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation/path"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SimpleUpdateFunc func(runtime.Object) (runtime.Object, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SimpleUpdateFunc converts SimpleUpdateFunc into UpdateFunc
0000000000000000000000000000000000000000;;	func SimpleUpdate(fn SimpleUpdateFunc) UpdateFunc {
0000000000000000000000000000000000000000;;		return func(input runtime.Object, _ ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;			out, err := fn(input)
0000000000000000000000000000000000000000;;			return out, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SimpleFilter converts a selection predicate into a FilterFunc.
0000000000000000000000000000000000000000;;	// It ignores any error from Matches().
0000000000000000000000000000000000000000;;	func SimpleFilter(p SelectionPredicate) FilterFunc {
0000000000000000000000000000000000000000;;		return func(obj runtime.Object) bool {
0000000000000000000000000000000000000000;;			matches, err := p.Matches(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("invalid object for matching. Obj: %v. Err: %v", obj, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return matches
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EverythingFunc(runtime.Object) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NoTriggerFunc() []MatchValue {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NoTriggerPublisher(runtime.Object) []MatchValue {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseWatchResourceVersion takes a resource version argument and converts it to
0000000000000000000000000000000000000000;;	// the etcd version we should pass to helper.Watch(). Because resourceVersion is
0000000000000000000000000000000000000000;;	// an opaque value, the default watch behavior for non-zero watch is to watch
0000000000000000000000000000000000000000;;	// the next value (if you pass "1", you will see updates from "2" onwards).
0000000000000000000000000000000000000000;;	func ParseWatchResourceVersion(resourceVersion string) (uint64, error) {
0000000000000000000000000000000000000000;;		if resourceVersion == "" || resourceVersion == "0" {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, err := strconv.ParseUint(resourceVersion, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, NewInvalidError(field.ErrorList{
0000000000000000000000000000000000000000;;				// Validation errors are supposed to return version-specific field
0000000000000000000000000000000000000000;;				// paths, but this is probably close enough.
0000000000000000000000000000000000000000;;				field.Invalid(field.NewPath("resourceVersion"), resourceVersion, err.Error()),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return version, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseListResourceVersion takes a resource version argument and converts it to
0000000000000000000000000000000000000000;;	// the etcd version.
0000000000000000000000000000000000000000;;	func ParseListResourceVersion(resourceVersion string) (uint64, error) {
0000000000000000000000000000000000000000;;		if resourceVersion == "" {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, err := strconv.ParseUint(resourceVersion, 10, 64)
0000000000000000000000000000000000000000;;		return version, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NamespaceKeyFunc(prefix string, obj runtime.Object) (string, error) {
0000000000000000000000000000000000000000;;		meta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := meta.GetName()
0000000000000000000000000000000000000000;;		if msgs := path.IsValidPathSegmentName(name); len(msgs) != 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid name: %v", msgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return prefix + "/" + meta.GetNamespace() + "/" + name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NoNamespaceKeyFunc(prefix string, obj runtime.Object) (string, error) {
0000000000000000000000000000000000000000;;		meta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := meta.GetName()
0000000000000000000000000000000000000000;;		if msgs := path.IsValidPathSegmentName(name); len(msgs) != 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid name: %v", msgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return prefix + "/" + name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasPathPrefix returns true if the string matches pathPrefix exactly, or if is prefixed with pathPrefix at a path segment boundary
0000000000000000000000000000000000000000;;	func hasPathPrefix(s, pathPrefix string) bool {
0000000000000000000000000000000000000000;;		// Short circuit if s doesn't contain the prefix at all
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(s, pathPrefix) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pathPrefixLength := len(pathPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s) == pathPrefixLength {
0000000000000000000000000000000000000000;;			// Exact match
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(pathPrefix, "/") {
0000000000000000000000000000000000000000;;			// pathPrefix already ensured a path segment boundary
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s[pathPrefixLength:pathPrefixLength+1] == "/" {
0000000000000000000000000000000000000000;;			// The next character in s is a path segment boundary
0000000000000000000000000000000000000000;;			// Check this instead of normalizing pathPrefix to avoid allocating on every call
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HighWaterMark is a thread-safe object for tracking the maximum value seen
0000000000000000000000000000000000000000;;	// for some quantity.
0000000000000000000000000000000000000000;;	type HighWaterMark int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update returns true if and only if 'current' is the highest value ever seen.
0000000000000000000000000000000000000000;;	func (hwm *HighWaterMark) Update(current int64) bool {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			old := atomic.LoadInt64((*int64)(hwm))
0000000000000000000000000000000000000000;;			if current <= old {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if atomic.CompareAndSwapInt64((*int64)(hwm), old, current) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
