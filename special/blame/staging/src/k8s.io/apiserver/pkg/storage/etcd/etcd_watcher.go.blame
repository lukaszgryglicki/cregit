0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
801b93d618fa326556100f349a845bfe50114ad4;pkg/tools/etcd_tools_watch.go[pkg/tools/etcd_tools_watch.go][staging/src/k8s.io/apiserver/pkg/storage/etcd/etcd_watcher.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		etcdutil "k8s.io/apiserver/pkg/storage/etcd/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcd "github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Etcd watch event actions
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EtcdCreate = "create"
0000000000000000000000000000000000000000;;		EtcdGet    = "get"
0000000000000000000000000000000000000000;;		EtcdSet    = "set"
0000000000000000000000000000000000000000;;		EtcdCAS    = "compareAndSwap"
0000000000000000000000000000000000000000;;		EtcdDelete = "delete"
0000000000000000000000000000000000000000;;		EtcdCAD    = "compareAndDelete"
0000000000000000000000000000000000000000;;		EtcdExpire = "expire"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransformFunc attempts to convert an object to another object for use with a watcher.
0000000000000000000000000000000000000000;;	type TransformFunc func(runtime.Object) (runtime.Object, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// includeFunc returns true if the given key should be considered part of a watch
0000000000000000000000000000000000000000;;	type includeFunc func(key string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exceptKey is an includeFunc that returns false when the provided key matches the watched key
0000000000000000000000000000000000000000;;	func exceptKey(except string) includeFunc {
0000000000000000000000000000000000000000;;		return func(key string) bool {
0000000000000000000000000000000000000000;;			return key != except
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// etcdWatcher converts a native etcd watch to a watch.Interface.
0000000000000000000000000000000000000000;;	type etcdWatcher struct {
0000000000000000000000000000000000000000;;		// HighWaterMarks for performance debugging.
0000000000000000000000000000000000000000;;		// Important: Since HighWaterMark is using sync/atomic, it has to be at the top of the struct due to a bug on 32-bit platforms
0000000000000000000000000000000000000000;;		// See: https://golang.org/pkg/sync/atomic/ for more information
0000000000000000000000000000000000000000;;		incomingHWM storage.HighWaterMark
0000000000000000000000000000000000000000;;		outgoingHWM storage.HighWaterMark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoding runtime.Codec
0000000000000000000000000000000000000000;;		// Note that versioner is required for etcdWatcher to work correctly.
0000000000000000000000000000000000000000;;		// There is no public constructor of it, so be careful when manipulating
0000000000000000000000000000000000000000;;		// with it manually.
0000000000000000000000000000000000000000;;		versioner        storage.Versioner
0000000000000000000000000000000000000000;;		transform        TransformFunc
0000000000000000000000000000000000000000;;		valueTransformer ValueTransformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list    bool // If we're doing a recursive watch, should be true.
0000000000000000000000000000000000000000;;		quorum  bool // If we enable quorum, shoule be true
0000000000000000000000000000000000000000;;		include includeFunc
0000000000000000000000000000000000000000;;		filter  storage.FilterFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdIncoming  chan *etcd.Response
0000000000000000000000000000000000000000;;		etcdError     chan error
0000000000000000000000000000000000000000;;		ctx           context.Context
0000000000000000000000000000000000000000;;		cancel        context.CancelFunc
0000000000000000000000000000000000000000;;		etcdCallEnded chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outgoing chan watch.Event
0000000000000000000000000000000000000000;;		userStop chan struct{}
0000000000000000000000000000000000000000;;		stopped  bool
0000000000000000000000000000000000000000;;		stopLock sync.Mutex
0000000000000000000000000000000000000000;;		// wg is used to avoid calls to etcd after Stop(), and to make sure
0000000000000000000000000000000000000000;;		// that the translate goroutine is not leaked.
0000000000000000000000000000000000000000;;		wg sync.WaitGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Injectable for testing. Send the event down the outgoing channel.
0000000000000000000000000000000000000000;;		emit func(watch.Event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache etcdCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchWaitDuration is the amount of time to wait for an error from watch.
0000000000000000000000000000000000000000;;	const watchWaitDuration = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newEtcdWatcher returns a new etcdWatcher; if list is true, watch sub-nodes.
0000000000000000000000000000000000000000;;	// The versioner must be able to handle the objects that transform creates.
0000000000000000000000000000000000000000;;	func newEtcdWatcher(
0000000000000000000000000000000000000000;;		list bool, quorum bool, include includeFunc, filter storage.FilterFunc,
0000000000000000000000000000000000000000;;		encoding runtime.Codec, versioner storage.Versioner, transform TransformFunc,
0000000000000000000000000000000000000000;;		valueTransformer ValueTransformer,
0000000000000000000000000000000000000000;;		cache etcdCache) *etcdWatcher {
0000000000000000000000000000000000000000;;		w := &etcdWatcher{
0000000000000000000000000000000000000000;;			encoding:         encoding,
0000000000000000000000000000000000000000;;			versioner:        versioner,
0000000000000000000000000000000000000000;;			transform:        transform,
0000000000000000000000000000000000000000;;			valueTransformer: valueTransformer,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			list:    list,
0000000000000000000000000000000000000000;;			quorum:  quorum,
0000000000000000000000000000000000000000;;			include: include,
0000000000000000000000000000000000000000;;			filter:  filter,
0000000000000000000000000000000000000000;;			// Buffer this channel, so that the etcd client is not forced
0000000000000000000000000000000000000000;;			// to context switch with every object it gets, and so that a
0000000000000000000000000000000000000000;;			// long time spent decoding an object won't block the *next*
0000000000000000000000000000000000000000;;			// object. Basically, we see a lot of "401 window exceeded"
0000000000000000000000000000000000000000;;			// errors from etcd, and that's due to the client not streaming
0000000000000000000000000000000000000000;;			// results but rather getting them one at a time. So we really
0000000000000000000000000000000000000000;;			// want to never block the etcd client, if possible. The 100 is
0000000000000000000000000000000000000000;;			// mostly arbitrary--we know it goes as high as 50, though.
0000000000000000000000000000000000000000;;			// There's a V(2) log message that prints the length so we can
0000000000000000000000000000000000000000;;			// monitor how much of this buffer is actually used.
0000000000000000000000000000000000000000;;			etcdIncoming: make(chan *etcd.Response, 100),
0000000000000000000000000000000000000000;;			etcdError:    make(chan error, 1),
0000000000000000000000000000000000000000;;			// Similarly to etcdIncomming, we don't want to force context
0000000000000000000000000000000000000000;;			// switch on every new incoming object.
0000000000000000000000000000000000000000;;			outgoing: make(chan watch.Event, 100),
0000000000000000000000000000000000000000;;			userStop: make(chan struct{}),
0000000000000000000000000000000000000000;;			stopped:  false,
0000000000000000000000000000000000000000;;			wg:       sync.WaitGroup{},
0000000000000000000000000000000000000000;;			cache:    cache,
0000000000000000000000000000000000000000;;			ctx:      nil,
0000000000000000000000000000000000000000;;			cancel:   nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.emit = func(e watch.Event) {
0000000000000000000000000000000000000000;;			if curLen := int64(len(w.outgoing)); w.outgoingHWM.Update(curLen) {
0000000000000000000000000000000000000000;;				// Monitor if this gets backed up, and how much.
0000000000000000000000000000000000000000;;				glog.V(1).Infof("watch (%v): %v objects queued in outgoing channel.", reflect.TypeOf(e.Object).String(), curLen)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Give up on user stop, without this we leak a lot of goroutines in tests.
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case w.outgoing <- e:
0000000000000000000000000000000000000000;;			case <-w.userStop:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// translate will call done. We need to Add() here because otherwise,
0000000000000000000000000000000000000000;;		// if Stop() gets called before translate gets started, there'd be a
0000000000000000000000000000000000000000;;		// problem.
0000000000000000000000000000000000000000;;		w.wg.Add(1)
0000000000000000000000000000000000000000;;		go w.translate()
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// etcdWatch calls etcd's Watch function, and handles any errors. Meant to be called
0000000000000000000000000000000000000000;;	// as a goroutine.
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) etcdWatch(ctx context.Context, client etcd.KeysAPI, key string, resourceVersion uint64) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer close(w.etcdError)
0000000000000000000000000000000000000000;;		defer close(w.etcdIncoming)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All calls to etcd are coming from this function - once it is finished
0000000000000000000000000000000000000000;;		// no other call to etcd should be generated by this watcher.
0000000000000000000000000000000000000000;;		done := func() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need to be prepared, that Stop() can be called at any time.
0000000000000000000000000000000000000000;;		// It can potentially also be called, even before this function is called.
0000000000000000000000000000000000000000;;		// If that is the case, we simply skip all the code here.
0000000000000000000000000000000000000000;;		// See #18928 for more details.
0000000000000000000000000000000000000000;;		var watcher etcd.Watcher
0000000000000000000000000000000000000000;;		returned := func() bool {
0000000000000000000000000000000000000000;;			w.stopLock.Lock()
0000000000000000000000000000000000000000;;			defer w.stopLock.Unlock()
0000000000000000000000000000000000000000;;			if w.stopped {
0000000000000000000000000000000000000000;;				// Watcher has already been stopped - don't event initiate it here.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.wg.Add(1)
0000000000000000000000000000000000000000;;			done = w.wg.Done
0000000000000000000000000000000000000000;;			// Perform initialization of watcher under lock - we want to avoid situation when
0000000000000000000000000000000000000000;;			// Stop() is called in the meantime (which in tests can cause etcd termination and
0000000000000000000000000000000000000000;;			// strange behavior here).
0000000000000000000000000000000000000000;;			if resourceVersion == 0 {
0000000000000000000000000000000000000000;;				latest, err := etcdGetInitialWatchState(ctx, client, key, w.list, w.quorum, w.etcdIncoming)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					w.etcdError <- err
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resourceVersion = latest
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts := etcd.WatcherOptions{
0000000000000000000000000000000000000000;;				Recursive:  w.list,
0000000000000000000000000000000000000000;;				AfterIndex: resourceVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watcher = client.Watcher(key, &opts)
0000000000000000000000000000000000000000;;			w.ctx, w.cancel = context.WithCancel(ctx)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		defer done()
0000000000000000000000000000000000000000;;		if returned {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resp, err := watcher.Next(w.ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				w.etcdError <- err
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.etcdIncoming <- resp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// etcdGetInitialWatchState turns an etcd Get request into a watch equivalent
0000000000000000000000000000000000000000;;	func etcdGetInitialWatchState(ctx context.Context, client etcd.KeysAPI, key string, recursive bool, quorum bool, incoming chan<- *etcd.Response) (resourceVersion uint64, err error) {
0000000000000000000000000000000000000000;;		opts := etcd.GetOptions{
0000000000000000000000000000000000000000;;			Recursive: recursive,
0000000000000000000000000000000000000000;;			Sort:      false,
0000000000000000000000000000000000000000;;			Quorum:    quorum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := client.Get(ctx, key, &opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !etcdutil.IsEtcdNotFound(err) {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("watch was unable to retrieve the current index for the provided key (%q): %v", key, err))
0000000000000000000000000000000000000000;;				return resourceVersion, toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if etcdError, ok := err.(etcd.Error); ok {
0000000000000000000000000000000000000000;;				resourceVersion = etcdError.Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resourceVersion, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersion = resp.Index
0000000000000000000000000000000000000000;;		convertRecursiveResponse(resp.Node, resp, incoming)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertRecursiveResponse turns a recursive get response from etcd into individual response objects
0000000000000000000000000000000000000000;;	// by copying the original response.  This emulates the behavior of a recursive watch.
0000000000000000000000000000000000000000;;	func convertRecursiveResponse(node *etcd.Node, response *etcd.Response, incoming chan<- *etcd.Response) {
0000000000000000000000000000000000000000;;		if node.Dir {
0000000000000000000000000000000000000000;;			for i := range node.Nodes {
0000000000000000000000000000000000000000;;				convertRecursiveResponse(node.Nodes[i], response, incoming)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copied := *response
0000000000000000000000000000000000000000;;		copied.Action = "get"
0000000000000000000000000000000000000000;;		copied.Node = node
0000000000000000000000000000000000000000;;		incoming <- &copied
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// translate pulls stuff from etcd, converts, and pushes out the outgoing channel. Meant to be
0000000000000000000000000000000000000000;;	// called as a goroutine.
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) translate() {
0000000000000000000000000000000000000000;;		defer w.wg.Done()
0000000000000000000000000000000000000000;;		defer close(w.outgoing)
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err := <-w.etcdError:
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					var status *metav1.Status
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case etcdutil.IsEtcdWatchExpired(err):
0000000000000000000000000000000000000000;;						status = &metav1.Status{
0000000000000000000000000000000000000000;;							Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;							Message: err.Error(),
0000000000000000000000000000000000000000;;							Code:    http.StatusGone, // Gone
0000000000000000000000000000000000000000;;							Reason:  metav1.StatusReasonExpired,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					// TODO: need to generate errors using api/errors which has a circular dependency on this package
0000000000000000000000000000000000000000;;					//   no other way to inject errors
0000000000000000000000000000000000000000;;					// case etcdutil.IsEtcdUnreachable(err):
0000000000000000000000000000000000000000;;					//   status = errors.NewServerTimeout(...)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						status = &metav1.Status{
0000000000000000000000000000000000000000;;							Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;							Message: err.Error(),
0000000000000000000000000000000000000000;;							Code:    http.StatusInternalServerError,
0000000000000000000000000000000000000000;;							Reason:  metav1.StatusReasonInternalError,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.emit(watch.Event{
0000000000000000000000000000000000000000;;						Type:   watch.Error,
0000000000000000000000000000000000000000;;						Object: status,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-w.userStop:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case res, ok := <-w.etcdIncoming:
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					if curLen := int64(len(w.etcdIncoming)); w.incomingHWM.Update(curLen) {
0000000000000000000000000000000000000000;;						// Monitor if this gets backed up, and how much.
0000000000000000000000000000000000000000;;						glog.V(1).Infof("watch: %v objects queued in incoming channel.", curLen)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.sendResult(res)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If !ok, don't return here-- must wait for etcdError channel
0000000000000000000000000000000000000000;;				// to give an error or be closed.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeObject extracts an object from the provided etcd node or returns an error.
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) decodeObject(node *etcd.Node) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if obj, found := w.cache.getFromCache(node.ModifiedIndex, storage.SimpleFilter(storage.Everything)); found {
0000000000000000000000000000000000000000;;			return obj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, _, err := w.valueTransformer.TransformStringFromStorage(node.Value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(w.encoding, []byte(body))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure resource version is set on the object we load from etcd
0000000000000000000000000000000000000000;;		if err := w.versioner.UpdateObject(obj, node.ModifiedIndex); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("failure to version api object (%d) %#v: %v", node.ModifiedIndex, obj, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// perform any necessary transformation
0000000000000000000000000000000000000000;;		if w.transform != nil {
0000000000000000000000000000000000000000;;			obj, err = w.transform(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("failure to transform api object %#v: %v", obj, err))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if node.ModifiedIndex != 0 {
0000000000000000000000000000000000000000;;			w.cache.addToCache(node.ModifiedIndex, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) sendAdd(res *etcd.Response) {
0000000000000000000000000000000000000000;;		if res.Node == nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unexpected nil node: %#v", res))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.include != nil && !w.include(res.Node.Key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := w.decodeObject(res.Node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("failure to decode api object: %v\n'%v' from %#v %#v", err, string(res.Node.Value), res, res.Node))
0000000000000000000000000000000000000000;;			// TODO: expose an error through watch.Interface?
0000000000000000000000000000000000000000;;			// Ignore this value. If we stop the watch on a bad value, a client that uses
0000000000000000000000000000000000000000;;			// the resourceVersion to resume will never be able to get past a bad value.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !w.filter(obj) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		action := watch.Added
0000000000000000000000000000000000000000;;		w.emit(watch.Event{
0000000000000000000000000000000000000000;;			Type:   action,
0000000000000000000000000000000000000000;;			Object: obj,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) sendModify(res *etcd.Response) {
0000000000000000000000000000000000000000;;		if res.Node == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("unexpected nil node: %#v", res)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.include != nil && !w.include(res.Node.Key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		curObj, err := w.decodeObject(res.Node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("failure to decode api object: %v\n'%v' from %#v %#v", err, string(res.Node.Value), res, res.Node))
0000000000000000000000000000000000000000;;			// TODO: expose an error through watch.Interface?
0000000000000000000000000000000000000000;;			// Ignore this value. If we stop the watch on a bad value, a client that uses
0000000000000000000000000000000000000000;;			// the resourceVersion to resume will never be able to get past a bad value.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		curObjPasses := w.filter(curObj)
0000000000000000000000000000000000000000;;		oldObjPasses := false
0000000000000000000000000000000000000000;;		var oldObj runtime.Object
0000000000000000000000000000000000000000;;		if res.PrevNode != nil && res.PrevNode.Value != "" {
0000000000000000000000000000000000000000;;			// Ignore problems reading the old object.
0000000000000000000000000000000000000000;;			if oldObj, err = w.decodeObject(res.PrevNode); err == nil {
0000000000000000000000000000000000000000;;				if err := w.versioner.UpdateObject(oldObj, res.Node.ModifiedIndex); err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("failure to version api object (%d) %#v: %v", res.Node.ModifiedIndex, oldObj, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				oldObjPasses = w.filter(oldObj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Some changes to an object may cause it to start or stop matching a filter.
0000000000000000000000000000000000000000;;		// We need to report those as adds/deletes. So we have to check both the previous
0000000000000000000000000000000000000000;;		// and current value of the object.
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case curObjPasses && oldObjPasses:
0000000000000000000000000000000000000000;;			w.emit(watch.Event{
0000000000000000000000000000000000000000;;				Type:   watch.Modified,
0000000000000000000000000000000000000000;;				Object: curObj,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case curObjPasses && !oldObjPasses:
0000000000000000000000000000000000000000;;			w.emit(watch.Event{
0000000000000000000000000000000000000000;;				Type:   watch.Added,
0000000000000000000000000000000000000000;;				Object: curObj,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case !curObjPasses && oldObjPasses:
0000000000000000000000000000000000000000;;			w.emit(watch.Event{
0000000000000000000000000000000000000000;;				Type:   watch.Deleted,
0000000000000000000000000000000000000000;;				Object: oldObj,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do nothing if neither new nor old object passed the filter.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) sendDelete(res *etcd.Response) {
0000000000000000000000000000000000000000;;		if res.PrevNode == nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unexpected nil prev node: %#v", res))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.include != nil && !w.include(res.PrevNode.Key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node := *res.PrevNode
0000000000000000000000000000000000000000;;		if res.Node != nil {
0000000000000000000000000000000000000000;;			// Note that this sends the *old* object with the etcd index for the time at
0000000000000000000000000000000000000000;;			// which it gets deleted. This will allow users to restart the watch at the right
0000000000000000000000000000000000000000;;			// index.
0000000000000000000000000000000000000000;;			node.ModifiedIndex = res.Node.ModifiedIndex
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := w.decodeObject(&node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("failure to decode api object: %v\nfrom %#v %#v", err, res, res.Node))
0000000000000000000000000000000000000000;;			// TODO: expose an error through watch.Interface?
0000000000000000000000000000000000000000;;			// Ignore this value. If we stop the watch on a bad value, a client that uses
0000000000000000000000000000000000000000;;			// the resourceVersion to resume will never be able to get past a bad value.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !w.filter(obj) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.emit(watch.Event{
0000000000000000000000000000000000000000;;			Type:   watch.Deleted,
0000000000000000000000000000000000000000;;			Object: obj,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) sendResult(res *etcd.Response) {
0000000000000000000000000000000000000000;;		switch res.Action {
0000000000000000000000000000000000000000;;		case EtcdCreate, EtcdGet:
0000000000000000000000000000000000000000;;			// "Get" will only happen in watch 0 case, where we explicitly want ADDED event
0000000000000000000000000000000000000000;;			// for initial state.
0000000000000000000000000000000000000000;;			w.sendAdd(res)
0000000000000000000000000000000000000000;;		case EtcdSet, EtcdCAS:
0000000000000000000000000000000000000000;;			w.sendModify(res)
0000000000000000000000000000000000000000;;		case EtcdDelete, EtcdExpire, EtcdCAD:
0000000000000000000000000000000000000000;;			w.sendDelete(res)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unknown action: %v", res.Action))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResultChan implements watch.Interface.
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) ResultChan() <-chan watch.Event {
0000000000000000000000000000000000000000;;		return w.outgoing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop implements watch.Interface.
0000000000000000000000000000000000000000;;	func (w *etcdWatcher) Stop() {
0000000000000000000000000000000000000000;;		w.stopLock.Lock()
0000000000000000000000000000000000000000;;		if w.cancel != nil {
0000000000000000000000000000000000000000;;			w.cancel()
0000000000000000000000000000000000000000;;			w.cancel = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !w.stopped {
0000000000000000000000000000000000000000;;			w.stopped = true
0000000000000000000000000000000000000000;;			close(w.userStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.stopLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait until all calls to etcd are finished and no other
0000000000000000000000000000000000000000;;		// will be issued.
0000000000000000000000000000000000000000;;		w.wg.Wait()
0000000000000000000000000000000000000000;;	}
