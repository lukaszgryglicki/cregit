0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9524e06cb3de8c702646be485d1f0cdd7df08203;pkg/storage/etcd3/watcher.go[pkg/storage/etcd3/watcher.go][staging/src/k8s.io/apiserver/pkg/storage/etcd3/watcher.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		etcdrpc "github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// We have set a buffer in order to reduce times of context switches.
0000000000000000000000000000000000000000;;		incomingBufSize = 100
0000000000000000000000000000000000000000;;		outgoingBufSize = 100
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fatalOnDecodeError is used during testing to panic the server if watcher encounters a decoding error
0000000000000000000000000000000000000000;;	var fatalOnDecodeError = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errTestingDecode is the only error that testingDeferOnDecodeError catches during a panic
0000000000000000000000000000000000000000;;	var errTestingDecode = errors.New("sentinel error only used during testing to indicate watch decoding error")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testingDeferOnDecodeError is used during testing to recover from a panic caused by errTestingDecode, all other values continue to panic
0000000000000000000000000000000000000000;;	func testingDeferOnDecodeError() {
0000000000000000000000000000000000000000;;		if r := recover(); r != nil && r != errTestingDecode {
0000000000000000000000000000000000000000;;			panic(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// check to see if we are running in a test environment
0000000000000000000000000000000000000000;;		fatalOnDecodeError, _ = strconv.ParseBool(os.Getenv("KUBE_PANIC_WATCH_DECODE_ERROR"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watcher struct {
0000000000000000000000000000000000000000;;		client      *clientv3.Client
0000000000000000000000000000000000000000;;		codec       runtime.Codec
0000000000000000000000000000000000000000;;		versioner   storage.Versioner
0000000000000000000000000000000000000000;;		transformer value.Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchChan implements watch.Interface.
0000000000000000000000000000000000000000;;	type watchChan struct {
0000000000000000000000000000000000000000;;		watcher           *watcher
0000000000000000000000000000000000000000;;		key               string
0000000000000000000000000000000000000000;;		initialRev        int64
0000000000000000000000000000000000000000;;		recursive         bool
0000000000000000000000000000000000000000;;		internalFilter    storage.FilterFunc
0000000000000000000000000000000000000000;;		ctx               context.Context
0000000000000000000000000000000000000000;;		cancel            context.CancelFunc
0000000000000000000000000000000000000000;;		incomingEventChan chan *event
0000000000000000000000000000000000000000;;		resultChan        chan watch.Event
0000000000000000000000000000000000000000;;		errChan           chan error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWatcher(client *clientv3.Client, codec runtime.Codec, versioner storage.Versioner, transformer value.Transformer) *watcher {
0000000000000000000000000000000000000000;;		return &watcher{
0000000000000000000000000000000000000000;;			client:      client,
0000000000000000000000000000000000000000;;			codec:       codec,
0000000000000000000000000000000000000000;;			versioner:   versioner,
0000000000000000000000000000000000000000;;			transformer: transformer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch watches on a key and returns a watch.Interface that transfers relevant notifications.
0000000000000000000000000000000000000000;;	// If rev is zero, it will return the existing object(s) and then start watching from
0000000000000000000000000000000000000000;;	// the maximum revision+1 from returned objects.
0000000000000000000000000000000000000000;;	// If rev is non-zero, it will watch events happened after given revision.
0000000000000000000000000000000000000000;;	// If recursive is false, it watches on given key.
0000000000000000000000000000000000000000;;	// If recursive is true, it watches any children and directories under the key, excluding the root key itself.
0000000000000000000000000000000000000000;;	// pred must be non-nil. Only if pred matches the change, it will be returned.
0000000000000000000000000000000000000000;;	func (w *watcher) Watch(ctx context.Context, key string, rev int64, recursive bool, pred storage.SelectionPredicate) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		if recursive && !strings.HasSuffix(key, "/") {
0000000000000000000000000000000000000000;;			key += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wc := w.createWatchChan(ctx, key, rev, recursive, pred)
0000000000000000000000000000000000000000;;		go wc.run()
0000000000000000000000000000000000000000;;		return wc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watcher) createWatchChan(ctx context.Context, key string, rev int64, recursive bool, pred storage.SelectionPredicate) *watchChan {
0000000000000000000000000000000000000000;;		wc := &watchChan{
0000000000000000000000000000000000000000;;			watcher:           w,
0000000000000000000000000000000000000000;;			key:               key,
0000000000000000000000000000000000000000;;			initialRev:        rev,
0000000000000000000000000000000000000000;;			recursive:         recursive,
0000000000000000000000000000000000000000;;			internalFilter:    storage.SimpleFilter(pred),
0000000000000000000000000000000000000000;;			incomingEventChan: make(chan *event, incomingBufSize),
0000000000000000000000000000000000000000;;			resultChan:        make(chan watch.Event, outgoingBufSize),
0000000000000000000000000000000000000000;;			errChan:           make(chan error, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pred.Empty() {
0000000000000000000000000000000000000000;;			// The filter doesn't filter out any object.
0000000000000000000000000000000000000000;;			wc.internalFilter = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wc.ctx, wc.cancel = context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		return wc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) run() {
0000000000000000000000000000000000000000;;		watchClosedCh := make(chan struct{})
0000000000000000000000000000000000000000;;		go wc.startWatching(watchClosedCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resultChanWG sync.WaitGroup
0000000000000000000000000000000000000000;;		resultChanWG.Add(1)
0000000000000000000000000000000000000000;;		go wc.processEvent(&resultChanWG)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-wc.errChan:
0000000000000000000000000000000000000000;;			if err == context.Canceled {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errResult := parseError(err)
0000000000000000000000000000000000000000;;			if errResult != nil {
0000000000000000000000000000000000000000;;				// error result is guaranteed to be received by user before closing ResultChan.
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case wc.resultChan <- *errResult:
0000000000000000000000000000000000000000;;				case <-wc.ctx.Done(): // user has given up all results
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-watchClosedCh:
0000000000000000000000000000000000000000;;		case <-wc.ctx.Done(): // user cancel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We use wc.ctx to reap all goroutines. Under whatever condition, we should stop them all.
0000000000000000000000000000000000000000;;		// It's fine to double cancel.
0000000000000000000000000000000000000000;;		wc.cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need to wait until resultChan wouldn't be used anymore
0000000000000000000000000000000000000000;;		resultChanWG.Wait()
0000000000000000000000000000000000000000;;		close(wc.resultChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) Stop() {
0000000000000000000000000000000000000000;;		wc.cancel()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) ResultChan() <-chan watch.Event {
0000000000000000000000000000000000000000;;		return wc.resultChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sync tries to retrieve existing data and send them to process.
0000000000000000000000000000000000000000;;	// The revision to watch will be set to the revision in response.
0000000000000000000000000000000000000000;;	// All events sent will have isCreated=true
0000000000000000000000000000000000000000;;	func (wc *watchChan) sync() error {
0000000000000000000000000000000000000000;;		opts := []clientv3.OpOption{}
0000000000000000000000000000000000000000;;		if wc.recursive {
0000000000000000000000000000000000000000;;			opts = append(opts, clientv3.WithPrefix())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		getResp, err := wc.watcher.client.Get(wc.ctx, wc.key, opts...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wc.initialRev = getResp.Header.Revision
0000000000000000000000000000000000000000;;		for _, kv := range getResp.Kvs {
0000000000000000000000000000000000000000;;			wc.sendEvent(parseKV(kv))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startWatching does:
0000000000000000000000000000000000000000;;	// - get current objects if initialRev=0; set initialRev to current rev
0000000000000000000000000000000000000000;;	// - watch on given key and send events to process.
0000000000000000000000000000000000000000;;	func (wc *watchChan) startWatching(watchClosedCh chan struct{}) {
0000000000000000000000000000000000000000;;		if wc.initialRev == 0 {
0000000000000000000000000000000000000000;;			if err := wc.sync(); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("failed to sync with latest state: %v", err)
0000000000000000000000000000000000000000;;				wc.sendError(err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts := []clientv3.OpOption{clientv3.WithRev(wc.initialRev + 1), clientv3.WithPrevKV()}
0000000000000000000000000000000000000000;;		if wc.recursive {
0000000000000000000000000000000000000000;;			opts = append(opts, clientv3.WithPrefix())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wch := wc.watcher.client.Watch(wc.ctx, wc.key, opts...)
0000000000000000000000000000000000000000;;		for wres := range wch {
0000000000000000000000000000000000000000;;			if wres.Err() != nil {
0000000000000000000000000000000000000000;;				err := wres.Err()
0000000000000000000000000000000000000000;;				// If there is an error on server (e.g. compaction), the channel will return it before closed.
0000000000000000000000000000000000000000;;				glog.Errorf("watch chan error: %v", err)
0000000000000000000000000000000000000000;;				wc.sendError(err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, e := range wres.Events {
0000000000000000000000000000000000000000;;				wc.sendEvent(parseEvent(e))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// When we come to this point, it's only possible that client side ends the watch.
0000000000000000000000000000000000000000;;		// e.g. cancel the context, close the client.
0000000000000000000000000000000000000000;;		// If this watch chan is broken and context isn't cancelled, other goroutines will still hang.
0000000000000000000000000000000000000000;;		// We should notify the main thread that this goroutine has exited.
0000000000000000000000000000000000000000;;		close(watchClosedCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processEvent processes events from etcd watcher and sends results to resultChan.
0000000000000000000000000000000000000000;;	func (wc *watchChan) processEvent(wg *sync.WaitGroup) {
0000000000000000000000000000000000000000;;		defer wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case e := <-wc.incomingEventChan:
0000000000000000000000000000000000000000;;				res := wc.transform(e)
0000000000000000000000000000000000000000;;				if res == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(wc.resultChan) == outgoingBufSize {
0000000000000000000000000000000000000000;;					glog.Warningf("Fast watcher, slow processing. Number of buffered events: %d."+
0000000000000000000000000000000000000000;;						"Probably caused by slow dispatching events to watchers", outgoingBufSize)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If user couldn't receive results fast enough, we also block incoming events from watcher.
0000000000000000000000000000000000000000;;				// Because storing events in local will cause more memory usage.
0000000000000000000000000000000000000000;;				// The worst case would be closing the fast watcher.
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case wc.resultChan <- *res:
0000000000000000000000000000000000000000;;				case <-wc.ctx.Done():
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-wc.ctx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) filter(obj runtime.Object) bool {
0000000000000000000000000000000000000000;;		if wc.internalFilter == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wc.internalFilter(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) acceptAll() bool {
0000000000000000000000000000000000000000;;		return wc.internalFilter == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transform transforms an event into a result for user if not filtered.
0000000000000000000000000000000000000000;;	func (wc *watchChan) transform(e *event) (res *watch.Event) {
0000000000000000000000000000000000000000;;		curObj, oldObj, err := wc.prepareObjs(e)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to prepare current and previous objects: %v", err)
0000000000000000000000000000000000000000;;			wc.sendError(err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case e.isDeleted:
0000000000000000000000000000000000000000;;			if !wc.filter(oldObj) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res = &watch.Event{
0000000000000000000000000000000000000000;;				Type:   watch.Deleted,
0000000000000000000000000000000000000000;;				Object: oldObj,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case e.isCreated:
0000000000000000000000000000000000000000;;			if !wc.filter(curObj) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res = &watch.Event{
0000000000000000000000000000000000000000;;				Type:   watch.Added,
0000000000000000000000000000000000000000;;				Object: curObj,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if wc.acceptAll() {
0000000000000000000000000000000000000000;;				res = &watch.Event{
0000000000000000000000000000000000000000;;					Type:   watch.Modified,
0000000000000000000000000000000000000000;;					Object: curObj,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			curObjPasses := wc.filter(curObj)
0000000000000000000000000000000000000000;;			oldObjPasses := wc.filter(oldObj)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case curObjPasses && oldObjPasses:
0000000000000000000000000000000000000000;;				res = &watch.Event{
0000000000000000000000000000000000000000;;					Type:   watch.Modified,
0000000000000000000000000000000000000000;;					Object: curObj,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case curObjPasses && !oldObjPasses:
0000000000000000000000000000000000000000;;				res = &watch.Event{
0000000000000000000000000000000000000000;;					Type:   watch.Added,
0000000000000000000000000000000000000000;;					Object: curObj,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case !curObjPasses && oldObjPasses:
0000000000000000000000000000000000000000;;				res = &watch.Event{
0000000000000000000000000000000000000000;;					Type:   watch.Deleted,
0000000000000000000000000000000000000000;;					Object: oldObj,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseError(err error) *watch.Event {
0000000000000000000000000000000000000000;;		var status *metav1.Status
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err == etcdrpc.ErrCompacted:
0000000000000000000000000000000000000000;;			status = &metav1.Status{
0000000000000000000000000000000000000000;;				Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;				Message: err.Error(),
0000000000000000000000000000000000000000;;				Code:    http.StatusGone,
0000000000000000000000000000000000000000;;				Reason:  metav1.StatusReasonExpired,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			status = &metav1.Status{
0000000000000000000000000000000000000000;;				Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;				Message: err.Error(),
0000000000000000000000000000000000000000;;				Code:    http.StatusInternalServerError,
0000000000000000000000000000000000000000;;				Reason:  metav1.StatusReasonInternalError,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &watch.Event{
0000000000000000000000000000000000000000;;			Type:   watch.Error,
0000000000000000000000000000000000000000;;			Object: status,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) sendError(err error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case wc.errChan <- err:
0000000000000000000000000000000000000000;;		case <-wc.ctx.Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) sendEvent(e *event) {
0000000000000000000000000000000000000000;;		if len(wc.incomingEventChan) == incomingBufSize {
0000000000000000000000000000000000000000;;			glog.Warningf("Fast watcher, slow processing. Number of buffered events: %d."+
0000000000000000000000000000000000000000;;				"Probably caused by slow decoding, user not receiving fast, or other processing logic",
0000000000000000000000000000000000000000;;				incomingBufSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case wc.incomingEventChan <- e:
0000000000000000000000000000000000000000;;		case <-wc.ctx.Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wc *watchChan) prepareObjs(e *event) (curObj runtime.Object, oldObj runtime.Object, err error) {
0000000000000000000000000000000000000000;;		if !e.isDeleted {
0000000000000000000000000000000000000000;;			data, _, err := wc.watcher.transformer.TransformFromStorage(e.value, authenticatedDataString(e.key))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			curObj, err = decodeObj(wc.watcher.codec, wc.watcher.versioner, data, e.rev)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We need to decode prevValue, only if this is deletion event or
0000000000000000000000000000000000000000;;		// the underlying filter doesn't accept all objects (otherwise we
0000000000000000000000000000000000000000;;		// know that the filter for previous object will return true and
0000000000000000000000000000000000000000;;		// we need the object only to compute whether it was filtered out
0000000000000000000000000000000000000000;;		// before).
0000000000000000000000000000000000000000;;		if len(e.prevValue) > 0 && (e.isDeleted || !wc.acceptAll()) {
0000000000000000000000000000000000000000;;			data, _, err := wc.watcher.transformer.TransformFromStorage(e.prevValue, authenticatedDataString(e.key))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Note that this sends the *old* object with the etcd revision for the time at
0000000000000000000000000000000000000000;;			// which it gets deleted.
0000000000000000000000000000000000000000;;			oldObj, err = decodeObj(wc.watcher.codec, wc.watcher.versioner, data, e.rev)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return curObj, oldObj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeObj(codec runtime.Codec, versioner storage.Versioner, data []byte, rev int64) (_ runtime.Object, err error) {
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(codec, []byte(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if fatalOnDecodeError {
0000000000000000000000000000000000000000;;				// catch watch decode error iff we caused it on
0000000000000000000000000000000000000000;;				// purpose during a unit test
0000000000000000000000000000000000000000;;				defer testingDeferOnDecodeError()
0000000000000000000000000000000000000000;;				// we are running in a test environment and thus an
0000000000000000000000000000000000000000;;				// error here is due to a coder mistake if the defer
0000000000000000000000000000000000000000;;				// does not catch it
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// ensure resource version is set on the object we load from etcd
0000000000000000000000000000000000000000;;		if err := versioner.UpdateObject(obj, uint64(rev)); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failure to version api object (%d) %#v: %v", rev, obj, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
