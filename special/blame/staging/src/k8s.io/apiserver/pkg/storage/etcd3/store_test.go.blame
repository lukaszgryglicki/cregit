0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
255d6d647cdab5ad5e50d8c47d1faaac7bcbbb22;pkg/storage/etcd3/store_test.go[pkg/storage/etcd3/store_test.go][staging/src/k8s.io/apiserver/pkg/storage/etcd3/store_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		storagetests "k8s.io/apiserver/pkg/storage/tests"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/integration"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var scheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;	var codecs = serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultTestPrefix = "test!"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, metav1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		example.AddToScheme(scheme)
0000000000000000000000000000000000000000;;		examplev1.AddToScheme(scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prefixTransformer adds and verifies that all data has the correct prefix on its way in and out.
0000000000000000000000000000000000000000;;	type prefixTransformer struct {
0000000000000000000000000000000000000000;;		prefix []byte
0000000000000000000000000000000000000000;;		stale  bool
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p prefixTransformer) TransformFromStorage(b []byte, ctx value.Context) ([]byte, bool, error) {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			panic("no context provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !bytes.HasPrefix(b, p.prefix) {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("value does not have expected prefix: %s", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes.TrimPrefix(b, p.prefix), p.stale, p.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (p prefixTransformer) TransformToStorage(b []byte, ctx value.Context) ([]byte, error) {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			panic("no context provided")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b) > 0 {
0000000000000000000000000000000000000000;;			return append(append([]byte{}, p.prefix...), b...), p.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, p.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		etcdClient := cluster.RandClient()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := "/testkey"
0000000000000000000000000000000000000000;;		out := &example.Pod{}
0000000000000000000000000000000000000000;;		obj := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", SelfLink: "testlink"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that kv pair is empty before set
0000000000000000000000000000000000000000;;		getResp, err := etcdClient.KV.Get(ctx, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("etcdClient.KV.Get failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(getResp.Kvs) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("expecting empty result on key: %s", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = store.Create(ctx, key, obj, out, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Set failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// basic tests of the output
0000000000000000000000000000000000000000;;		if obj.ObjectMeta.Name != out.ObjectMeta.Name {
0000000000000000000000000000000000000000;;			t.Errorf("pod name want=%s, get=%s", obj.ObjectMeta.Name, out.ObjectMeta.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.ResourceVersion == "" {
0000000000000000000000000000000000000000;;			t.Errorf("output should have non-empty resource version")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.SelfLink != "" {
0000000000000000000000000000000000000000;;			t.Errorf("output should have empty self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkStorageInvariants(ctx, t, etcdClient, store, key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkStorageInvariants(ctx context.Context, t *testing.T, etcdClient *clientv3.Client, store *store, key string) {
0000000000000000000000000000000000000000;;		getResp, err := etcdClient.KV.Get(ctx, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("etcdClient.KV.Get failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(getResp.Kvs) == 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("expecting non empty result on key: %s", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoded, err := runtime.Decode(store.codec, getResp.Kvs[0].Value[len(defaultTestPrefix):])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expecting successful decode of object from %v\n%v", err, string(getResp.Kvs[0].Value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := decoded.(*example.Pod)
0000000000000000000000000000000000000000;;		if obj.ResourceVersion != "" {
0000000000000000000000000000000000000000;;			t.Errorf("stored object should have empty resource version")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj.SelfLink != "" {
0000000000000000000000000000000000000000;;			t.Errorf("stored output should have empty self link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateWithTTL(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		input := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		key := "/somekey"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := &example.Pod{}
0000000000000000000000000000000000000000;;		if err := store.Create(ctx, key, input, out, 1); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Create failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := store.Watch(ctx, key, out.ResourceVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCheckEventType(t, watch.Deleted, w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateWithKeyExist(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		obj := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		key, _ := testPropogateStore(ctx, t, store, obj)
0000000000000000000000000000000000000000;;		out := &example.Pod{}
0000000000000000000000000000000000000000;;		err := store.Create(ctx, key, obj, out, 0)
0000000000000000000000000000000000000000;;		if err == nil || !storage.IsNodeExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("expecting key exists error, but get: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGet(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			key               string
0000000000000000000000000000000000000000;;			ignoreNotFound    bool
0000000000000000000000000000000000000000;;			expectNotFoundErr bool
0000000000000000000000000000000000000000;;			expectedOut       *example.Pod
0000000000000000000000000000000000000000;;		}{{ // test get on existing item
0000000000000000000000000000000000000000;;			key:               key,
0000000000000000000000000000000000000000;;			ignoreNotFound:    false,
0000000000000000000000000000000000000000;;			expectNotFoundErr: false,
0000000000000000000000000000000000000000;;			expectedOut:       storedObj,
0000000000000000000000000000000000000000;;		}, { // test get on non-existing item with ignoreNotFound=false
0000000000000000000000000000000000000000;;			key:               "/non-existing",
0000000000000000000000000000000000000000;;			ignoreNotFound:    false,
0000000000000000000000000000000000000000;;			expectNotFoundErr: true,
0000000000000000000000000000000000000000;;		}, { // test get on non-existing item with ignoreNotFound=true
0000000000000000000000000000000000000000;;			key:               "/non-existing",
0000000000000000000000000000000000000000;;			ignoreNotFound:    true,
0000000000000000000000000000000000000000;;			expectNotFoundErr: false,
0000000000000000000000000000000000000000;;			expectedOut:       &example.Pod{},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			out := &example.Pod{}
0000000000000000000000000000000000000000;;			err := store.Get(ctx, tt.key, "", out, tt.ignoreNotFound)
0000000000000000000000000000000000000000;;			if tt.expectNotFoundErr {
0000000000000000000000000000000000000000;;				if err == nil || !storage.IsNotFound(err) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: expecting not found error, but get: %s", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Get failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(tt.expectedOut, out) {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: pod want=%#v, get=%#v", i, tt.expectedOut, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnconditionalDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			key               string
0000000000000000000000000000000000000000;;			expectedObj       *example.Pod
0000000000000000000000000000000000000000;;			expectNotFoundErr bool
0000000000000000000000000000000000000000;;		}{{ // test unconditional delete on existing key
0000000000000000000000000000000000000000;;			key:               key,
0000000000000000000000000000000000000000;;			expectedObj:       storedObj,
0000000000000000000000000000000000000000;;			expectNotFoundErr: false,
0000000000000000000000000000000000000000;;		}, { // test unconditional delete on non-existing key
0000000000000000000000000000000000000000;;			key:               "/non-existing",
0000000000000000000000000000000000000000;;			expectedObj:       nil,
0000000000000000000000000000000000000000;;			expectNotFoundErr: true,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			out := &example.Pod{} // reset
0000000000000000000000000000000000000000;;			err := store.Delete(ctx, tt.key, out, nil)
0000000000000000000000000000000000000000;;			if tt.expectNotFoundErr {
0000000000000000000000000000000000000000;;				if err == nil || !storage.IsNotFound(err) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: expecting not found error, but get: %s", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Delete failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(tt.expectedObj, out) {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: pod want=%#v, get=%#v", i, tt.expectedObj, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConditionalDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", UID: "A"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			precondition        *storage.Preconditions
0000000000000000000000000000000000000000;;			expectInvalidObjErr bool
0000000000000000000000000000000000000000;;		}{{ // test conditional delete with UID match
0000000000000000000000000000000000000000;;			precondition:        storage.NewUIDPreconditions("A"),
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;		}, { // test conditional delete with UID mismatch
0000000000000000000000000000000000000000;;			precondition:        storage.NewUIDPreconditions("B"),
0000000000000000000000000000000000000000;;			expectInvalidObjErr: true,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			out := &example.Pod{}
0000000000000000000000000000000000000000;;			err := store.Delete(ctx, key, out, tt.precondition)
0000000000000000000000000000000000000000;;			if tt.expectInvalidObjErr {
0000000000000000000000000000000000000000;;				if err == nil || !storage.IsInvalidObj(err) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: expecting invalid UID error, but get: %s", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Delete failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(storedObj, out) {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: pod want=%#v, get=%#v", i, storedObj, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key, storedObj = testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", UID: "A"}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetToList(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			key         string
0000000000000000000000000000000000000000;;			pred        storage.SelectionPredicate
0000000000000000000000000000000000000000;;			expectedOut []*example.Pod
0000000000000000000000000000000000000000;;		}{{ // test GetToList on existing key
0000000000000000000000000000000000000000;;			key:         key,
0000000000000000000000000000000000000000;;			pred:        storage.Everything,
0000000000000000000000000000000000000000;;			expectedOut: []*example.Pod{storedObj},
0000000000000000000000000000000000000000;;		}, { // test GetToList on non-existing key
0000000000000000000000000000000000000000;;			key:         "/non-existing",
0000000000000000000000000000000000000000;;			pred:        storage.Everything,
0000000000000000000000000000000000000000;;			expectedOut: nil,
0000000000000000000000000000000000000000;;		}, { // test GetToList with matching pod name
0000000000000000000000000000000000000000;;			key: "/non-existing",
0000000000000000000000000000000000000000;;			pred: storage.SelectionPredicate{
0000000000000000000000000000000000000000;;				Label: labels.Everything(),
0000000000000000000000000000000000000000;;				Field: fields.ParseSelectorOrDie("metadata.name!=" + storedObj.Name),
0000000000000000000000000000000000000000;;				GetAttrs: func(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;					pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;					return nil, fields.Set{"metadata.name": pod.Name}, pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedOut: nil,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			out := &example.PodList{}
0000000000000000000000000000000000000000;;			err := store.GetToList(ctx, tt.key, "", tt.pred, out)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("GetToList failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(out.Items) != len(tt.expectedOut) {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: length of list want=%d, get=%d", i, len(tt.expectedOut), len(out.Items))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j, wantPod := range tt.expectedOut {
0000000000000000000000000000000000000000;;				getPod := &out.Items[j]
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(wantPod, getPod) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: pod want=%#v, get=%#v", i, wantPod, getPod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGuaranteedUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		etcdClient := cluster.RandClient()
0000000000000000000000000000000000000000;;		key := "/testkey"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			key                 string
0000000000000000000000000000000000000000;;			ignoreNotFound      bool
0000000000000000000000000000000000000000;;			precondition        *storage.Preconditions
0000000000000000000000000000000000000000;;			expectNotFoundErr   bool
0000000000000000000000000000000000000000;;			expectInvalidObjErr bool
0000000000000000000000000000000000000000;;			expectNoUpdate      bool
0000000000000000000000000000000000000000;;			transformStale      bool
0000000000000000000000000000000000000000;;			hasSelfLink         bool
0000000000000000000000000000000000000000;;		}{{ // GuaranteedUpdate on non-existing key with ignoreNotFound=false
0000000000000000000000000000000000000000;;			key:                 "/non-existing",
0000000000000000000000000000000000000000;;			ignoreNotFound:      false,
0000000000000000000000000000000000000000;;			precondition:        nil,
0000000000000000000000000000000000000000;;			expectNotFoundErr:   true,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;			expectNoUpdate:      false,
0000000000000000000000000000000000000000;;		}, { // GuaranteedUpdate on non-existing key with ignoreNotFound=true
0000000000000000000000000000000000000000;;			key:                 "/non-existing",
0000000000000000000000000000000000000000;;			ignoreNotFound:      true,
0000000000000000000000000000000000000000;;			precondition:        nil,
0000000000000000000000000000000000000000;;			expectNotFoundErr:   false,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;			expectNoUpdate:      false,
0000000000000000000000000000000000000000;;		}, { // GuaranteedUpdate on existing key
0000000000000000000000000000000000000000;;			key:                 key,
0000000000000000000000000000000000000000;;			ignoreNotFound:      false,
0000000000000000000000000000000000000000;;			precondition:        nil,
0000000000000000000000000000000000000000;;			expectNotFoundErr:   false,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;			expectNoUpdate:      false,
0000000000000000000000000000000000000000;;		}, { // GuaranteedUpdate with same data
0000000000000000000000000000000000000000;;			key:                 key,
0000000000000000000000000000000000000000;;			ignoreNotFound:      false,
0000000000000000000000000000000000000000;;			precondition:        nil,
0000000000000000000000000000000000000000;;			expectNotFoundErr:   false,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;			expectNoUpdate:      true,
0000000000000000000000000000000000000000;;		}, { // GuaranteedUpdate with same data AND a self link
0000000000000000000000000000000000000000;;			key:                 key,
0000000000000000000000000000000000000000;;			ignoreNotFound:      false,
0000000000000000000000000000000000000000;;			precondition:        nil,
0000000000000000000000000000000000000000;;			expectNotFoundErr:   false,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;			expectNoUpdate:      true,
0000000000000000000000000000000000000000;;			hasSelfLink:         true,
0000000000000000000000000000000000000000;;		}, { // GuaranteedUpdate with same data but stale
0000000000000000000000000000000000000000;;			key:                 key,
0000000000000000000000000000000000000000;;			ignoreNotFound:      false,
0000000000000000000000000000000000000000;;			precondition:        nil,
0000000000000000000000000000000000000000;;			expectNotFoundErr:   false,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;			expectNoUpdate:      false,
0000000000000000000000000000000000000000;;			transformStale:      true,
0000000000000000000000000000000000000000;;		}, { // GuaranteedUpdate with UID match
0000000000000000000000000000000000000000;;			key:                 key,
0000000000000000000000000000000000000000;;			ignoreNotFound:      false,
0000000000000000000000000000000000000000;;			precondition:        storage.NewUIDPreconditions("A"),
0000000000000000000000000000000000000000;;			expectNotFoundErr:   false,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: false,
0000000000000000000000000000000000000000;;			expectNoUpdate:      true,
0000000000000000000000000000000000000000;;		}, { // GuaranteedUpdate with UID mismatch
0000000000000000000000000000000000000000;;			key:                 key,
0000000000000000000000000000000000000000;;			ignoreNotFound:      false,
0000000000000000000000000000000000000000;;			precondition:        storage.NewUIDPreconditions("B"),
0000000000000000000000000000000000000000;;			expectNotFoundErr:   false,
0000000000000000000000000000000000000000;;			expectInvalidObjErr: true,
0000000000000000000000000000000000000000;;			expectNoUpdate:      true,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			key, storeObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", UID: "A"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out := &example.Pod{}
0000000000000000000000000000000000000000;;			name := fmt.Sprintf("foo-%d", i)
0000000000000000000000000000000000000000;;			if tt.expectNoUpdate {
0000000000000000000000000000000000000000;;				name = storeObj.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			originalTransformer := store.transformer.(prefixTransformer)
0000000000000000000000000000000000000000;;			if tt.transformStale {
0000000000000000000000000000000000000000;;				transformer := originalTransformer
0000000000000000000000000000000000000000;;				transformer.stale = true
0000000000000000000000000000000000000000;;				store.transformer = transformer
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			version := storeObj.ResourceVersion
0000000000000000000000000000000000000000;;			err := store.GuaranteedUpdate(ctx, tt.key, out, tt.ignoreNotFound, tt.precondition,
0000000000000000000000000000000000000000;;				storage.SimpleUpdate(func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					if tt.expectNotFoundErr && tt.ignoreNotFound {
0000000000000000000000000000000000000000;;						if pod := obj.(*example.Pod); pod.Name != "" {
0000000000000000000000000000000000000000;;							t.Errorf("#%d: expecting zero value, but get=%#v", i, pod)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod := *storeObj
0000000000000000000000000000000000000000;;					if tt.hasSelfLink {
0000000000000000000000000000000000000000;;						pod.SelfLink = "testlink"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pod.Name = name
0000000000000000000000000000000000000000;;					return &pod, nil
0000000000000000000000000000000000000000;;				}))
0000000000000000000000000000000000000000;;			store.transformer = originalTransformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tt.expectNotFoundErr {
0000000000000000000000000000000000000000;;				if err == nil || !storage.IsNotFound(err) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: expecting not found error, but get: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tt.expectInvalidObjErr {
0000000000000000000000000000000000000000;;				if err == nil || !storage.IsInvalidObj(err) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: expecting invalid UID error, but get: %s", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("GuaranteedUpdate failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out.ObjectMeta.Name != name {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: pod name want=%s, get=%s", i, name, out.ObjectMeta.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out.SelfLink != "" {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: selflink should not be set", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify that kv pair is not empty after set and that the underlying data matches expectations
0000000000000000000000000000000000000000;;			checkStorageInvariants(ctx, t, etcdClient, store, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch tt.expectNoUpdate {
0000000000000000000000000000000000000000;;			case true:
0000000000000000000000000000000000000000;;				if version != out.ResourceVersion {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: expect no version change, before=%s, after=%s", i, version, out.ResourceVersion)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case false:
0000000000000000000000000000000000000000;;				if version == out.ResourceVersion {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: expect version change, but get the same version=%s", i, version)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGuaranteedUpdateWithTTL(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		input := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		key := "/somekey"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := &example.Pod{}
0000000000000000000000000000000000000000;;		err := store.GuaranteedUpdate(ctx, key, out, true, nil,
0000000000000000000000000000000000000000;;			func(_ runtime.Object, _ storage.ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;				ttl := uint64(1)
0000000000000000000000000000000000000000;;				return input, &ttl, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Create failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := store.Watch(ctx, key, out.ResourceVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCheckEventType(t, watch.Deleted, w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGuaranteedUpdateChecksStoredData(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		input := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		key := "/somekey"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// serialize input into etcd with data that would be normalized by a write - in this case, leading
0000000000000000000000000000000000000000;;		// and trailing whitespace
0000000000000000000000000000000000000000;;		codec := codecs.LegacyCodec(examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, input)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := store.client.Put(ctx, key, "test! "+string(data)+" ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this update should write the canonical value to etcd because the new serialization differs
0000000000000000000000000000000000000000;;		// from the stored serialization
0000000000000000000000000000000000000000;;		input.ResourceVersion = strconv.FormatInt(resp.Header.Revision, 10)
0000000000000000000000000000000000000000;;		out := &example.Pod{}
0000000000000000000000000000000000000000;;		err = store.GuaranteedUpdate(ctx, key, out, true, nil,
0000000000000000000000000000000000000000;;			func(_ runtime.Object, _ storage.ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;				return input, nil, nil
0000000000000000000000000000000000000000;;			}, input)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Update failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.ResourceVersion == strconv.FormatInt(resp.Header.Revision, 10) {
0000000000000000000000000000000000000000;;			t.Errorf("guaranteed update should have updated the serialized data, got %#v", out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGuaranteedUpdateWithConflict(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, _ := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errChan := make(chan error, 1)
0000000000000000000000000000000000000000;;		var firstToFinish sync.WaitGroup
0000000000000000000000000000000000000000;;		var secondToEnter sync.WaitGroup
0000000000000000000000000000000000000000;;		firstToFinish.Add(1)
0000000000000000000000000000000000000000;;		secondToEnter.Add(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			err := store.GuaranteedUpdate(ctx, key, &example.Pod{}, false, nil,
0000000000000000000000000000000000000000;;				storage.SimpleUpdate(func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;					pod.Name = "foo-1"
0000000000000000000000000000000000000000;;					secondToEnter.Wait()
0000000000000000000000000000000000000000;;					return pod, nil
0000000000000000000000000000000000000000;;				}))
0000000000000000000000000000000000000000;;			firstToFinish.Done()
0000000000000000000000000000000000000000;;			errChan <- err
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updateCount := 0
0000000000000000000000000000000000000000;;		err := store.GuaranteedUpdate(ctx, key, &example.Pod{}, false, nil,
0000000000000000000000000000000000000000;;			storage.SimpleUpdate(func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				if updateCount == 0 {
0000000000000000000000000000000000000000;;					secondToEnter.Done()
0000000000000000000000000000000000000000;;					firstToFinish.Wait()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				updateCount++
0000000000000000000000000000000000000000;;				pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;				pod.Name = "foo-2"
0000000000000000000000000000000000000000;;				return pod, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Second GuaranteedUpdate error %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := <-errChan; err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("First GuaranteedUpdate error %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if updateCount != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Should have conflict and called update func twice")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTransformationFailure(t *testing.T) {
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		store := newStore(cluster.RandClient(), false, codec, "", prefixTransformer{prefix: []byte(defaultTestPrefix)})
0000000000000000000000000000000000000000;;		ctx := context.Background()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preset := []struct {
0000000000000000000000000000000000000000;;			key       string
0000000000000000000000000000000000000000;;			obj       *example.Pod
0000000000000000000000000000000000000000;;			storedObj *example.Pod
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			key: "/one-level/test",
0000000000000000000000000000000000000000;;			obj: &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "bar"},
0000000000000000000000000000000000000000;;				Spec:       storagetests.DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			key: "/two-level/1/test",
0000000000000000000000000000000000000000;;			obj: &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: "baz"},
0000000000000000000000000000000000000000;;				Spec:       storagetests.DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		for i, ps := range preset[:1] {
0000000000000000000000000000000000000000;;			preset[i].storedObj = &example.Pod{}
0000000000000000000000000000000000000000;;			err := store.Create(ctx, ps.key, ps.obj, preset[:1][i].storedObj, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Set failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a second resource with an invalid prefix
0000000000000000000000000000000000000000;;		oldTransformer := store.transformer
0000000000000000000000000000000000000000;;		store.transformer = prefixTransformer{prefix: []byte("otherprefix!")}
0000000000000000000000000000000000000000;;		for i, ps := range preset[1:] {
0000000000000000000000000000000000000000;;			preset[1:][i].storedObj = &example.Pod{}
0000000000000000000000000000000000000000;;			err := store.Create(ctx, ps.key, ps.obj, preset[1:][i].storedObj, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Set failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		store.transformer = oldTransformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only the first item is returned, and no error
0000000000000000000000000000000000000000;;		var got example.PodList
0000000000000000000000000000000000000000;;		if err := store.List(ctx, "/", "", storage.Everything, &got); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := []example.Pod{*preset[0].storedObj}, got.Items; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected: %s", diff.ObjectReflectDiff(e, a))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get should fail
0000000000000000000000000000000000000000;;		if err := store.Get(ctx, preset[1].key, "", &example.Pod{}, false); !storage.IsInternalError(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// GuaranteedUpdate without suggestion should return an error
0000000000000000000000000000000000000000;;		if err := store.GuaranteedUpdate(ctx, preset[1].key, &example.Pod{}, false, nil, func(input runtime.Object, res storage.ResponseMeta) (output runtime.Object, ttl *uint64, err error) {
0000000000000000000000000000000000000000;;			return input, nil, nil
0000000000000000000000000000000000000000;;		}); !storage.IsInternalError(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// GuaranteedUpdate with suggestion should return an error if we don't change the object
0000000000000000000000000000000000000000;;		if err := store.GuaranteedUpdate(ctx, preset[1].key, &example.Pod{}, false, nil, func(input runtime.Object, res storage.ResponseMeta) (output runtime.Object, ttl *uint64, err error) {
0000000000000000000000000000000000000000;;			return input, nil, nil
0000000000000000000000000000000000000000;;		}, preset[1].obj); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete succeeds but reports an error because we cannot access the body
0000000000000000000000000000000000000000;;		if err := store.Delete(ctx, preset[1].key, &example.Pod{}, nil); !storage.IsInternalError(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := store.Get(ctx, preset[1].key, "", &example.Pod{}, false); !storage.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestList(t *testing.T) {
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		store := newStore(cluster.RandClient(), false, codec, "", prefixTransformer{prefix: []byte(defaultTestPrefix)})
0000000000000000000000000000000000000000;;		ctx := context.Background()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup storage with the following structure:
0000000000000000000000000000000000000000;;		//  /
0000000000000000000000000000000000000000;;		//   - one-level/
0000000000000000000000000000000000000000;;		//  |            - test
0000000000000000000000000000000000000000;;		//  |
0000000000000000000000000000000000000000;;		//   - two-level/
0000000000000000000000000000000000000000;;		//               - 1/
0000000000000000000000000000000000000000;;		//              |   - test
0000000000000000000000000000000000000000;;		//              |
0000000000000000000000000000000000000000;;		//               - 2/
0000000000000000000000000000000000000000;;		//                  - test
0000000000000000000000000000000000000000;;		preset := []struct {
0000000000000000000000000000000000000000;;			key       string
0000000000000000000000000000000000000000;;			obj       *example.Pod
0000000000000000000000000000000000000000;;			storedObj *example.Pod
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			key: "/one-level/test",
0000000000000000000000000000000000000000;;			obj: &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			key: "/two-level/1/test",
0000000000000000000000000000000000000000;;			obj: &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}},
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			key: "/two-level/2/test",
0000000000000000000000000000000000000000;;			obj: &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, ps := range preset {
0000000000000000000000000000000000000000;;			preset[i].storedObj = &example.Pod{}
0000000000000000000000000000000000000000;;			err := store.Create(ctx, ps.key, ps.obj, preset[i].storedObj, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Set failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			prefix      string
0000000000000000000000000000000000000000;;			pred        storage.SelectionPredicate
0000000000000000000000000000000000000000;;			expectedOut []*example.Pod
0000000000000000000000000000000000000000;;		}{{ // test List on existing key
0000000000000000000000000000000000000000;;			prefix:      "/one-level/",
0000000000000000000000000000000000000000;;			pred:        storage.Everything,
0000000000000000000000000000000000000000;;			expectedOut: []*example.Pod{preset[0].storedObj},
0000000000000000000000000000000000000000;;		}, { // test List on non-existing key
0000000000000000000000000000000000000000;;			prefix:      "/non-existing/",
0000000000000000000000000000000000000000;;			pred:        storage.Everything,
0000000000000000000000000000000000000000;;			expectedOut: nil,
0000000000000000000000000000000000000000;;		}, { // test List with pod name matching
0000000000000000000000000000000000000000;;			prefix: "/one-level/",
0000000000000000000000000000000000000000;;			pred: storage.SelectionPredicate{
0000000000000000000000000000000000000000;;				Label: labels.Everything(),
0000000000000000000000000000000000000000;;				Field: fields.ParseSelectorOrDie("metadata.name!=" + preset[0].storedObj.Name),
0000000000000000000000000000000000000000;;				GetAttrs: func(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;					pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;					return nil, fields.Set{"metadata.name": pod.Name}, pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expectedOut: nil,
0000000000000000000000000000000000000000;;		}, { // test List with multiple levels of directories and expect flattened result
0000000000000000000000000000000000000000;;			prefix:      "/two-level/",
0000000000000000000000000000000000000000;;			pred:        storage.Everything,
0000000000000000000000000000000000000000;;			expectedOut: []*example.Pod{preset[1].storedObj, preset[2].storedObj},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			out := &example.PodList{}
0000000000000000000000000000000000000000;;			err := store.List(ctx, tt.prefix, "0", tt.pred, out)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("List failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tt.expectedOut) != len(out.Items) {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: length of list want=%d, get=%d", i, len(tt.expectedOut), len(out.Items))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j, wantPod := range tt.expectedOut {
0000000000000000000000000000000000000000;;				getPod := &out.Items[j]
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(wantPod, getPod) {
0000000000000000000000000000000000000000;;					t.Errorf("#%d: pod want=%#v, get=%#v", i, wantPod, getPod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSetup(t *testing.T) (context.Context, *store, *integration.ClusterV3) {
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
0000000000000000000000000000000000000000;;		store := newStore(cluster.RandClient(), false, codec, "", prefixTransformer{prefix: []byte(defaultTestPrefix)})
0000000000000000000000000000000000000000;;		ctx := context.Background()
0000000000000000000000000000000000000000;;		return ctx, store, cluster
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testPropogateStore helps propogates store with objects, automates key generation, and returns
0000000000000000000000000000000000000000;;	// keys and stored objects.
0000000000000000000000000000000000000000;;	func testPropogateStore(ctx context.Context, t *testing.T, store *store, obj *example.Pod) (string, *example.Pod) {
0000000000000000000000000000000000000000;;		// Setup store with a key and grab the output for returning.
0000000000000000000000000000000000000000;;		key := "/testkey"
0000000000000000000000000000000000000000;;		err := store.unconditionalDelete(ctx, key, &example.Pod{})
0000000000000000000000000000000000000000;;		if err != nil && !storage.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Fatal("Cleanup failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setOutput := &example.Pod{}
0000000000000000000000000000000000000000;;		if err := store.Create(ctx, key, obj, setOutput, 0); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Set failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key, setOutput
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPrefix(t *testing.T) {
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		transformer := prefixTransformer{prefix: []byte(defaultTestPrefix)}
0000000000000000000000000000000000000000;;		testcases := map[string]string{
0000000000000000000000000000000000000000;;			"custom/prefix":     "/custom/prefix",
0000000000000000000000000000000000000000;;			"/custom//prefix//": "/custom/prefix",
0000000000000000000000000000000000000000;;			"/registry":         "/registry",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for configuredPrefix, effectivePrefix := range testcases {
0000000000000000000000000000000000000000;;			store := newStore(cluster.RandClient(), false, codec, configuredPrefix, transformer)
0000000000000000000000000000000000000000;;			if store.pathPrefix != effectivePrefix {
0000000000000000000000000000000000000000;;				t.Errorf("configured prefix of %s, expected effective prefix of %s, got %s", configuredPrefix, effectivePrefix, store.pathPrefix)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
