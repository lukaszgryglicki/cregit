0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1fafd90460f204febb85b412ce261f5a4e83389c;pkg/storage/cacher_whitebox_test.go[pkg/storage/cacher_whitebox_test.go][staging/src/k8s.io/apiserver/pkg/storage/cacher_whitebox_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifies the cacheWatcher.process goroutine is properly cleaned up even if
0000000000000000000000000000000000000000;;	// the writes to cacheWatcher.result channel is blocked.
0000000000000000000000000000000000000000;;	func TestCacheWatcherCleanupNotBlockedByResult(t *testing.T) {
0000000000000000000000000000000000000000;;		var lock sync.RWMutex
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		filter := func(string, labels.Set, fields.Set, bool) bool { return true }
0000000000000000000000000000000000000000;;		forget := func(bool) {
0000000000000000000000000000000000000000;;			lock.Lock()
0000000000000000000000000000000000000000;;			defer lock.Unlock()
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		initEvents := []*watchCacheEvent{
0000000000000000000000000000000000000000;;			{Object: &v1.Pod{}},
0000000000000000000000000000000000000000;;			{Object: &v1.Pod{}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// set the size of the buffer of w.result to 0, so that the writes to
0000000000000000000000000000000000000000;;		// w.result is blocked.
0000000000000000000000000000000000000000;;		w := newCacheWatcher(scheme.Scheme, 0, 0, initEvents, filter, forget)
0000000000000000000000000000000000000000;;		w.Stop()
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(1*time.Second, 5*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			lock.RLock()
0000000000000000000000000000000000000000;;			defer lock.RUnlock()
0000000000000000000000000000000000000000;;			return count == 2, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected forget() to be called twice, because sendWatchCacheEvent should not be blocked by the result channel: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCacheWatcherHandlesFiltering(t *testing.T) {
0000000000000000000000000000000000000000;;		filter := func(_ string, _ labels.Set, field fields.Set, _ bool) bool {
0000000000000000000000000000000000000000;;			return field["spec.nodeName"] == "host"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		forget := func(bool) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			events   []*watchCacheEvent
0000000000000000000000000000000000000000;;			expected []watch.Event
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// properly handle starting with the filter, then being deleted, then re-added
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				events: []*watchCacheEvent{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:      watch.Added,
0000000000000000000000000000000000000000;;						Object:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "1"}},
0000000000000000000000000000000000000000;;						ObjFields: fields.Set{"spec.nodeName": "host"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:          watch.Modified,
0000000000000000000000000000000000000000;;						PrevObject:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "1"}},
0000000000000000000000000000000000000000;;						PrevObjFields: fields.Set{"spec.nodeName": "host"},
0000000000000000000000000000000000000000;;						Object:        &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "2"}},
0000000000000000000000000000000000000000;;						ObjFields:     fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:          watch.Modified,
0000000000000000000000000000000000000000;;						PrevObject:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "2"}},
0000000000000000000000000000000000000000;;						PrevObjFields: fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;						Object:        &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "3"}},
0000000000000000000000000000000000000000;;						ObjFields:     fields.Set{"spec.nodeName": "host"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []watch.Event{
0000000000000000000000000000000000000000;;					{Type: watch.Added, Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "1"}}},
0000000000000000000000000000000000000000;;					{Type: watch.Deleted, Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "1"}}},
0000000000000000000000000000000000000000;;					{Type: watch.Added, Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "3"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// properly handle ignoring changes prior to the filter, then getting added, then deleted
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				events: []*watchCacheEvent{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:      watch.Added,
0000000000000000000000000000000000000000;;						Object:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "1"}},
0000000000000000000000000000000000000000;;						ObjFields: fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:          watch.Modified,
0000000000000000000000000000000000000000;;						PrevObject:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "1"}},
0000000000000000000000000000000000000000;;						PrevObjFields: fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;						Object:        &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "2"}},
0000000000000000000000000000000000000000;;						ObjFields:     fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:          watch.Modified,
0000000000000000000000000000000000000000;;						PrevObject:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "2"}},
0000000000000000000000000000000000000000;;						PrevObjFields: fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;						Object:        &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "3"}},
0000000000000000000000000000000000000000;;						ObjFields:     fields.Set{"spec.nodeName": "host"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:          watch.Modified,
0000000000000000000000000000000000000000;;						PrevObject:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "3"}},
0000000000000000000000000000000000000000;;						PrevObjFields: fields.Set{"spec.nodeName": "host"},
0000000000000000000000000000000000000000;;						Object:        &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "4"}},
0000000000000000000000000000000000000000;;						ObjFields:     fields.Set{"spec.nodeName": "host"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:          watch.Modified,
0000000000000000000000000000000000000000;;						PrevObject:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "4"}},
0000000000000000000000000000000000000000;;						PrevObjFields: fields.Set{"spec.nodeName": "host"},
0000000000000000000000000000000000000000;;						Object:        &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "5"}},
0000000000000000000000000000000000000000;;						ObjFields:     fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:          watch.Modified,
0000000000000000000000000000000000000000;;						PrevObject:    &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "5"}},
0000000000000000000000000000000000000000;;						PrevObjFields: fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;						Object:        &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "6"}},
0000000000000000000000000000000000000000;;						ObjFields:     fields.Set{"spec.nodeName": ""},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []watch.Event{
0000000000000000000000000000000000000000;;					{Type: watch.Added, Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "3"}}},
0000000000000000000000000000000000000000;;					{Type: watch.Modified, Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "4"}}},
0000000000000000000000000000000000000000;;					{Type: watch.Deleted, Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "4"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	TestCase:
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			// set the size of the buffer of w.result to 0, so that the writes to
0000000000000000000000000000000000000000;;			// w.result is blocked.
0000000000000000000000000000000000000000;;			for j := range testCase.events {
0000000000000000000000000000000000000000;;				testCase.events[j].ResourceVersion = uint64(j) + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w := newCacheWatcher(scheme.Scheme, 0, 0, testCase.events, filter, forget)
0000000000000000000000000000000000000000;;			ch := w.ResultChan()
0000000000000000000000000000000000000000;;			for j, event := range testCase.expected {
0000000000000000000000000000000000000000;;				e := <-ch
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(event, e) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected event %d: %s", i, j, diff.ObjectReflectDiff(event, e))
0000000000000000000000000000000000000000;;					break TestCase
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case obj, ok := <-ch:
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected excess event: %#v %t", i, obj, ok)
0000000000000000000000000000000000000000;;				break TestCase
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
