0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c5bc83828d622ece540df3d4087dc256d5cfa0ed;pkg/storage/cacher_test.go[pkg/storage/cacher_test.go][staging/src/k8s.io/apiserver/pkg/storage/tests/cacher_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		etcdstorage "k8s.io/apiserver/pkg/storage/etcd"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd/etcdtest"
0000000000000000000000000000000000000000;;		etcdtesting "k8s.io/apiserver/pkg/storage/etcd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd3"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		scheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;		codecs = serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, metav1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		example.AddToScheme(scheme)
0000000000000000000000000000000000000000;;		examplev1.AddToScheme(scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAttrs returns labels and fields of a given object for filtering purposes.
0000000000000000000000000000000000000000;;	func GetAttrs(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;		pod, ok := obj.(*example.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, false, fmt.Errorf("not a pod")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels.Set(pod.ObjectMeta.Labels), PodToSelectableFields(pod), pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodToSelectableFields returns a field set that represents the object
0000000000000000000000000000000000000000;;	// TODO: fields are not labels, and the validation rules for them do not apply.
0000000000000000000000000000000000000000;;	func PodToSelectableFields(pod *example.Pod) fields.Set {
0000000000000000000000000000000000000000;;		// The purpose of allocation with a given number of elements is to reduce
0000000000000000000000000000000000000000;;		// amount of allocations needed to create the fields.Set. If you add any
0000000000000000000000000000000000000000;;		// field here or the number of object-meta related fields changes, this should
0000000000000000000000000000000000000000;;		// be adjusted.
0000000000000000000000000000000000000000;;		podSpecificFieldsSet := make(fields.Set, 5)
0000000000000000000000000000000000000000;;		podSpecificFieldsSet["spec.nodeName"] = pod.Spec.NodeName
0000000000000000000000000000000000000000;;		podSpecificFieldsSet["spec.restartPolicy"] = string(pod.Spec.RestartPolicy)
0000000000000000000000000000000000000000;;		podSpecificFieldsSet["status.phase"] = string(pod.Status.Phase)
0000000000000000000000000000000000000000;;		return AddObjectMetaFieldsSet(podSpecificFieldsSet, &pod.ObjectMeta, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddObjectMetaFieldsSet(source fields.Set, objectMeta *metav1.ObjectMeta, hasNamespaceField bool) fields.Set {
0000000000000000000000000000000000000000;;		source["metadata.name"] = objectMeta.Name
0000000000000000000000000000000000000000;;		if hasNamespaceField {
0000000000000000000000000000000000000000;;			source["metadata.namespace"] = objectMeta.Namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return source
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEtcdTestStorage(t *testing.T, prefix string) (*etcdtesting.EtcdTestServer, storage.Interface) {
0000000000000000000000000000000000000000;;		server, _ := etcdtesting.NewUnsecuredEtcd3TestClientServer(t, scheme)
0000000000000000000000000000000000000000;;		storage := etcd3.New(server.V3Client, apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion), prefix, value.IdentityTransformer)
0000000000000000000000000000000000000000;;		return server, storage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestCacher(s storage.Interface, cap int) *storage.Cacher {
0000000000000000000000000000000000000000;;		prefix := "pods"
0000000000000000000000000000000000000000;;		config := storage.CacherConfig{
0000000000000000000000000000000000000000;;			CacheCapacity:  cap,
0000000000000000000000000000000000000000;;			Storage:        s,
0000000000000000000000000000000000000000;;			Versioner:      etcdstorage.APIObjectVersioner{},
0000000000000000000000000000000000000000;;			Copier:         scheme,
0000000000000000000000000000000000000000;;			Type:           &example.Pod{},
0000000000000000000000000000000000000000;;			ResourcePrefix: prefix,
0000000000000000000000000000000000000000;;			KeyFunc:        func(obj runtime.Object) (string, error) { return storage.NamespaceKeyFunc(prefix, obj) },
0000000000000000000000000000000000000000;;			GetAttrsFunc:   GetAttrs,
0000000000000000000000000000000000000000;;			NewListFunc:    func() runtime.Object { return &example.PodList{} },
0000000000000000000000000000000000000000;;			Codec:          codecs.LegacyCodec(examplev1.SchemeGroupVersion),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return storage.NewCacherFromConfig(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTestPod(name string) *example.Pod {
0000000000000000000000000000000000000000;;		return &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "ns", Name: name},
0000000000000000000000000000000000000000;;			Spec:       DeepEqualSafePodSpec(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updatePod(t *testing.T, s storage.Interface, obj, old *example.Pod) *example.Pod {
0000000000000000000000000000000000000000;;		updateFn := func(input runtime.Object, res storage.ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;			newObj, err := scheme.DeepCopy(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newObj.(*example.Pod), nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key := "pods/" + obj.Namespace + "/" + obj.Name
0000000000000000000000000000000000000000;;		if err := s.GuaranteedUpdate(context.TODO(), key, &example.Pod{}, old == nil, nil, updateFn); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj.ResourceVersion = ""
0000000000000000000000000000000000000000;;		result := &example.Pod{}
0000000000000000000000000000000000000000;;		if err := s.Get(context.TODO(), key, "", result, false); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGet(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 10)
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFoo := makeTestPod("foo")
0000000000000000000000000000000000000000;;		fooCreated := updatePod(t, etcdStorage, podFoo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We pass the ResourceVersion from the above Create() operation.
0000000000000000000000000000000000000000;;		result := &example.Pod{}
0000000000000000000000000000000000000000;;		if err := cacher.Get(context.TODO(), "pods/ns/foo", fooCreated.ResourceVersion, result, true); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := *fooCreated, *result; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, got: %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := cacher.Get(context.TODO(), "pods/ns/bar", fooCreated.ResourceVersion, result, true); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		emptyPod := example.Pod{}
0000000000000000000000000000000000000000;;		if e, a := emptyPod, *result; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected: %#v, got: %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := cacher.Get(context.TODO(), "pods/ns/bar", fooCreated.ResourceVersion, result, false); !storage.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestList(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 10)
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFoo := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podBar := makeTestPod("bar")
0000000000000000000000000000000000000000;;		podBaz := makeTestPod("baz")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFooPrime := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooPrime.Spec.NodeName = "fakeNode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fooCreated := updatePod(t, etcdStorage, podFoo, nil)
0000000000000000000000000000000000000000;;		_ = updatePod(t, etcdStorage, podBar, nil)
0000000000000000000000000000000000000000;;		_ = updatePod(t, etcdStorage, podBaz, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ = updatePod(t, etcdStorage, podFooPrime, fooCreated)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a pod in a namespace that contains "ns" as a prefix
0000000000000000000000000000000000000000;;		// Make sure it is not returned in a watch of "ns"
0000000000000000000000000000000000000000;;		podFooNS2 := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooNS2.Namespace += "2"
0000000000000000000000000000000000000000;;		updatePod(t, etcdStorage, podFooNS2, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleted := example.Pod{}
0000000000000000000000000000000000000000;;		if err := etcdStorage.Delete(context.TODO(), "pods/ns/bar", &deleted, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We first List directly from etcd by passing empty resourceVersion,
0000000000000000000000000000000000000000;;		// to get the current etcd resourceVersion.
0000000000000000000000000000000000000000;;		rvResult := &example.PodList{}
0000000000000000000000000000000000000000;;		if err := cacher.List(context.TODO(), "pods/ns", "", storage.Everything, rvResult); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletedPodRV := rvResult.ListMeta.ResourceVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := &example.PodList{}
0000000000000000000000000000000000000000;;		// We pass the current etcd ResourceVersion received from the above List() operation,
0000000000000000000000000000000000000000;;		// since there is not easy way to get ResourceVersion of barPod deletion operation.
0000000000000000000000000000000000000000;;		if err := cacher.List(context.TODO(), "pods/ns", deletedPodRV, storage.Everything, result); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.ListMeta.ResourceVersion != deletedPodRV {
0000000000000000000000000000000000000000;;			t.Errorf("Incorrect resource version: %v", result.ListMeta.ResourceVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(result.Items) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected list result: %d", len(result.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keys := sets.String{}
0000000000000000000000000000000000000000;;		for _, item := range result.Items {
0000000000000000000000000000000000000000;;			keys.Insert(item.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !keys.HasAll("foo", "baz") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected list result: %#v", result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range result.Items {
0000000000000000000000000000000000000000;;			// unset fields that are set by the infrastructure
0000000000000000000000000000000000000000;;			item.ResourceVersion = ""
0000000000000000000000000000000000000000;;			item.CreationTimestamp = metav1.Time{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if item.Namespace != "ns" {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected namespace: %s", item.Namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var expected *example.Pod
0000000000000000000000000000000000000000;;			switch item.Name {
0000000000000000000000000000000000000000;;			case "foo":
0000000000000000000000000000000000000000;;				expected = podFooPrime
0000000000000000000000000000000000000000;;			case "baz":
0000000000000000000000000000000000000000;;				expected = podBaz
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected item: %v", item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := *expected, item; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected: %#v, got: %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInfiniteList(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 10)
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFoo := makeTestPod("foo")
0000000000000000000000000000000000000000;;		fooCreated := updatePod(t, etcdStorage, podFoo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up List at fooCreated.ResourceVersion + 10
0000000000000000000000000000000000000000;;		rv, err := storage.ParseWatchResourceVersion(fooCreated.ResourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listRV := strconv.Itoa(int(rv + 10))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := &example.PodList{}
0000000000000000000000000000000000000000;;		err = cacher.List(context.TODO(), "pods/ns", listRV, storage.Everything, result)
0000000000000000000000000000000000000000;;		if !errors.IsTimeout(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyWatchEvent(t *testing.T, w watch.Interface, eventType watch.EventType, eventObject runtime.Object) {
0000000000000000000000000000000000000000;;		_, _, line, _ := goruntime.Caller(1)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case event := <-w.ResultChan():
0000000000000000000000000000000000000000;;			if e, a := eventType, event.Type; e != a {
0000000000000000000000000000000000000000;;				t.Logf("(called from line %d)", line)
0000000000000000000000000000000000000000;;				t.Errorf("Expected: %s, got: %s", eventType, event.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := eventObject, event.Object; !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;				t.Logf("(called from line %d)", line)
0000000000000000000000000000000000000000;;				t.Errorf("Expected (%s): %#v, got: %#v", eventType, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Logf("(called from line %d)", line)
0000000000000000000000000000000000000000;;			t.Errorf("Timed out waiting for an event")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type injectListError struct {
0000000000000000000000000000000000000000;;		errors int
0000000000000000000000000000000000000000;;		storage.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *injectListError) List(ctx context.Context, key string, resourceVersion string, p storage.SelectionPredicate, listObj runtime.Object) error {
0000000000000000000000000000000000000000;;		if self.errors > 0 {
0000000000000000000000000000000000000000;;			self.errors--
0000000000000000000000000000000000000000;;			return fmt.Errorf("injected error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return self.Interface.List(ctx, key, resourceVersion, p, listObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		// Inject one list error to make sure we test the relist case.
0000000000000000000000000000000000000000;;		etcdStorage = &injectListError{errors: 1, Interface: etcdStorage}
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 3) // small capacity to trigger "too old version" error
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFoo := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podBar := makeTestPod("bar")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFooPrime := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooPrime.Spec.NodeName = "fakeNode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFooBis := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooBis.Spec.NodeName = "anotherFakeNode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFooNS2 := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooNS2.Namespace += "2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialVersion is used to initate the watcher at the beginning of the world,
0000000000000000000000000000000000000000;;		// which is not defined precisely in etcd.
0000000000000000000000000000000000000000;;		initialVersion, err := cacher.LastSyncResourceVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startVersion := strconv.Itoa(int(initialVersion))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up Watch for object "podFoo".
0000000000000000000000000000000000000000;;		watcher, err := cacher.Watch(context.TODO(), "pods/ns/foo", startVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create in another namespace first to make sure events from other namespaces don't get delivered
0000000000000000000000000000000000000000;;		updatePod(t, etcdStorage, podFooNS2, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fooCreated := updatePod(t, etcdStorage, podFoo, nil)
0000000000000000000000000000000000000000;;		_ = updatePod(t, etcdStorage, podBar, nil)
0000000000000000000000000000000000000000;;		fooUpdated := updatePod(t, etcdStorage, podFooPrime, fooCreated)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, watcher, watch.Added, podFoo)
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, watcher, watch.Modified, podFooPrime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check whether we get too-old error via the watch channel
0000000000000000000000000000000000000000;;		tooOldWatcher, err := cacher.Watch(context.TODO(), "pods/ns/foo", "1", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected no direct error, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer tooOldWatcher.Stop()
0000000000000000000000000000000000000000;;		// Ensure we get a "Gone" error
0000000000000000000000000000000000000000;;		expectedGoneError := errors.NewGone("").ErrStatus
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, tooOldWatcher, watch.Error, &expectedGoneError)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initialWatcher, err := cacher.Watch(context.TODO(), "pods/ns/foo", fooCreated.ResourceVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer initialWatcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, initialWatcher, watch.Modified, podFooPrime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now test watch from "now".
0000000000000000000000000000000000000000;;		nowWatcher, err := cacher.Watch(context.TODO(), "pods/ns/foo", "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer nowWatcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, nowWatcher, watch.Added, podFooPrime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ = updatePod(t, etcdStorage, podFooBis, fooUpdated)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, nowWatcher, watch.Modified, podFooBis)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatcherTimeout(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 10)
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialVersion is used to initate the watcher at the beginning of the world,
0000000000000000000000000000000000000000;;		// which is not defined precisely in etcd.
0000000000000000000000000000000000000000;;		initialVersion, err := cacher.LastSyncResourceVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startVersion := strconv.Itoa(int(initialVersion))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a number of watchers that will not be reading any result.
0000000000000000000000000000000000000000;;		nonReadingWatchers := 50
0000000000000000000000000000000000000000;;		for i := 0; i < nonReadingWatchers; i++ {
0000000000000000000000000000000000000000;;			watcher, err := cacher.WatchList(context.TODO(), "pods/ns", startVersion, storage.Everything)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer watcher.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a second watcher that will be reading result.
0000000000000000000000000000000000000000;;		readingWatcher, err := cacher.WatchList(context.TODO(), "pods/ns", startVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readingWatcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		for i := 1; i <= 22; i++ {
0000000000000000000000000000000000000000;;			pod := makeTestPod(strconv.Itoa(i))
0000000000000000000000000000000000000000;;			_ = updatePod(t, etcdStorage, pod, nil)
0000000000000000000000000000000000000000;;			verifyWatchEvent(t, readingWatcher, watch.Added, pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if time.Since(startTime) > time.Duration(250*nonReadingWatchers)*time.Millisecond {
0000000000000000000000000000000000000000;;			t.Errorf("waiting for events took too long: %v", time.Since(startTime))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFiltering(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 10)
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that the cacher is initialized, before creating any pods,
0000000000000000000000000000000000000000;;		// so that we are sure that all events will be present in cacher.
0000000000000000000000000000000000000000;;		syncWatcher, err := cacher.Watch(context.TODO(), "pods/ns/foo", "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncWatcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFoo := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFoo.Labels = map[string]string{"filter": "foo"}
0000000000000000000000000000000000000000;;		podFooFiltered := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooPrime := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooPrime.Labels = map[string]string{"filter": "foo"}
0000000000000000000000000000000000000000;;		podFooPrime.Spec.NodeName = "fakeNode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podFooNS2 := makeTestPod("foo")
0000000000000000000000000000000000000000;;		podFooNS2.Namespace += "2"
0000000000000000000000000000000000000000;;		podFooNS2.Labels = map[string]string{"filter": "foo"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create in another namespace first to make sure events from other namespaces don't get delivered
0000000000000000000000000000000000000000;;		updatePod(t, etcdStorage, podFooNS2, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fooCreated := updatePod(t, etcdStorage, podFoo, nil)
0000000000000000000000000000000000000000;;		fooFiltered := updatePod(t, etcdStorage, podFooFiltered, fooCreated)
0000000000000000000000000000000000000000;;		fooUnfiltered := updatePod(t, etcdStorage, podFoo, fooFiltered)
0000000000000000000000000000000000000000;;		_ = updatePod(t, etcdStorage, podFooPrime, fooUnfiltered)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleted := example.Pod{}
0000000000000000000000000000000000000000;;		if err := etcdStorage.Delete(context.TODO(), "pods/ns/foo", &deleted, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up Watch for object "podFoo" with label filter set.
0000000000000000000000000000000000000000;;		pred := storage.SelectionPredicate{
0000000000000000000000000000000000000000;;			Label: labels.SelectorFromSet(labels.Set{"filter": "foo"}),
0000000000000000000000000000000000000000;;			Field: fields.Everything(),
0000000000000000000000000000000000000000;;			GetAttrs: func(obj runtime.Object) (label labels.Set, field fields.Set, uninitialized bool, err error) {
0000000000000000000000000000000000000000;;				metadata, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return labels.Set(metadata.GetLabels()), nil, metadata.GetInitializers() != nil, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		watcher, err := cacher.Watch(context.TODO(), "pods/ns/foo", fooCreated.ResourceVersion, pred)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, watcher, watch.Deleted, podFooFiltered)
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, watcher, watch.Added, podFoo)
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, watcher, watch.Modified, podFooPrime)
0000000000000000000000000000000000000000;;		verifyWatchEvent(t, watcher, watch.Deleted, podFooPrime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStartingResourceVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 10)
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add 1 object
0000000000000000000000000000000000000000;;		podFoo := makeTestPod("foo")
0000000000000000000000000000000000000000;;		fooCreated := updatePod(t, etcdStorage, podFoo, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up Watch starting at fooCreated.ResourceVersion + 10
0000000000000000000000000000000000000000;;		rv, err := storage.ParseWatchResourceVersion(fooCreated.ResourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rv += 10
0000000000000000000000000000000000000000;;		startVersion := strconv.Itoa(int(rv))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watcher, err := cacher.Watch(context.TODO(), "pods/ns/foo", startVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastFoo := fooCreated
0000000000000000000000000000000000000000;;		for i := 0; i < 11; i++ {
0000000000000000000000000000000000000000;;			podFooForUpdate := makeTestPod("foo")
0000000000000000000000000000000000000000;;			podFooForUpdate.Labels = map[string]string{"foo": strconv.Itoa(i)}
0000000000000000000000000000000000000000;;			lastFoo = updatePod(t, etcdStorage, podFooForUpdate, lastFoo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case e := <-watcher.ResultChan():
0000000000000000000000000000000000000000;;			pod := e.Object.(*example.Pod)
0000000000000000000000000000000000000000;;			podRV, err := storage.ParseWatchResourceVersion(pod.ResourceVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// event should have at least rv + 1, since we're starting the watch at rv
0000000000000000000000000000000000000000;;			if podRV <= rv {
0000000000000000000000000000000000000000;;				t.Errorf("expected event with resourceVersion of at least %d, got %d", rv+1, podRV)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("timed out waiting for event")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRandomWatchDeliver(t *testing.T) {
0000000000000000000000000000000000000000;;		server, etcdStorage := newEtcdTestStorage(t, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		cacher := newTestCacher(etcdStorage, 10)
0000000000000000000000000000000000000000;;		defer cacher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fooCreated := updatePod(t, etcdStorage, makeTestPod("foo"), nil)
0000000000000000000000000000000000000000;;		rv, err := storage.ParseWatchResourceVersion(fooCreated.ResourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startVersion := strconv.Itoa(int(rv))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watcher, err := cacher.WatchList(context.TODO(), "pods/ns", startVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we can create exactly 21 events that should be delivered
0000000000000000000000000000000000000000;;		// to the watcher, before it will completely block cacher and as
0000000000000000000000000000000000000000;;		// a result will be dropped.
0000000000000000000000000000000000000000;;		for i := 0; i < 21; i++ {
0000000000000000000000000000000000000000;;			updatePod(t, etcdStorage, makeTestPod(fmt.Sprintf("foo-%d", i)), nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now stop the watcher and check if the consecutive events are being delivered.
0000000000000000000000000000000000000000;;		watcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watched := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event, ok := <-watcher.ResultChan()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a, e := event.Object.(*example.Pod).Name, fmt.Sprintf("foo-%d", watched); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected object watched: %s, expected %s", a, e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watched++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
