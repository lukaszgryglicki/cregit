0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
255d6d647cdab5ad5e50d8c47d1faaac7bcbbb22;pkg/storage/etcd3/store.go[pkg/storage/etcd3/store.go][staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;		utiltrace "k8s.io/apiserver/pkg/util/trace"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authenticatedDataString satisfies the value.Context interface. It uses the key to
0000000000000000000000000000000000000000;;	// authenticate the stored data. This does not defend against reuse of previously
0000000000000000000000000000000000000000;;	// encrypted values under the same key, but will prevent an attacker from using an
0000000000000000000000000000000000000000;;	// encrypted value from a different key. A stronger authenticated data segment would
0000000000000000000000000000000000000000;;	// include the etcd3 Version field (which is incremented on each write to a key and
0000000000000000000000000000000000000000;;	// reset when the key is deleted), but an attacker with write access to etcd can
0000000000000000000000000000000000000000;;	// force deletion and recreation of keys to weaken that angle.
0000000000000000000000000000000000000000;;	type authenticatedDataString string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthenticatedData implements the value.Context interface.
0000000000000000000000000000000000000000;;	func (d authenticatedDataString) AuthenticatedData() []byte {
0000000000000000000000000000000000000000;;		return []byte(string(d))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ value.Context = authenticatedDataString("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type store struct {
0000000000000000000000000000000000000000;;		client *clientv3.Client
0000000000000000000000000000000000000000;;		// getOpts contains additional options that should be passed
0000000000000000000000000000000000000000;;		// to all Get() calls.
0000000000000000000000000000000000000000;;		getOps      []clientv3.OpOption
0000000000000000000000000000000000000000;;		codec       runtime.Codec
0000000000000000000000000000000000000000;;		versioner   storage.Versioner
0000000000000000000000000000000000000000;;		transformer value.Transformer
0000000000000000000000000000000000000000;;		pathPrefix  string
0000000000000000000000000000000000000000;;		watcher     *watcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type elemForDecode struct {
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;		rev  uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type objState struct {
0000000000000000000000000000000000000000;;		obj   runtime.Object
0000000000000000000000000000000000000000;;		meta  *storage.ResponseMeta
0000000000000000000000000000000000000000;;		rev   int64
0000000000000000000000000000000000000000;;		data  []byte
0000000000000000000000000000000000000000;;		stale bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns an etcd3 implementation of storage.Interface.
0000000000000000000000000000000000000000;;	func New(c *clientv3.Client, codec runtime.Codec, prefix string, transformer value.Transformer) storage.Interface {
0000000000000000000000000000000000000000;;		return newStore(c, true, codec, prefix, transformer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWithNoQuorumRead returns etcd3 implementation of storage.Interface
0000000000000000000000000000000000000000;;	// where Get operations don't require quorum read.
0000000000000000000000000000000000000000;;	func NewWithNoQuorumRead(c *clientv3.Client, codec runtime.Codec, prefix string, transformer value.Transformer) storage.Interface {
0000000000000000000000000000000000000000;;		return newStore(c, false, codec, prefix, transformer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStore(c *clientv3.Client, quorumRead bool, codec runtime.Codec, prefix string, transformer value.Transformer) *store {
0000000000000000000000000000000000000000;;		versioner := etcd.APIObjectVersioner{}
0000000000000000000000000000000000000000;;		result := &store{
0000000000000000000000000000000000000000;;			client:      c,
0000000000000000000000000000000000000000;;			codec:       codec,
0000000000000000000000000000000000000000;;			versioner:   versioner,
0000000000000000000000000000000000000000;;			transformer: transformer,
0000000000000000000000000000000000000000;;			// for compatibility with etcd2 impl.
0000000000000000000000000000000000000000;;			// no-op for default prefix of '/registry'.
0000000000000000000000000000000000000000;;			// keeps compatibility with etcd2 impl for custom prefixes that don't start with '/'
0000000000000000000000000000000000000000;;			pathPrefix: path.Join("/", prefix),
0000000000000000000000000000000000000000;;			watcher:    newWatcher(c, codec, versioner, transformer),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !quorumRead {
0000000000000000000000000000000000000000;;			// In case of non-quorum reads, we can set WithSerializable()
0000000000000000000000000000000000000000;;			// options for all Get operations.
0000000000000000000000000000000000000000;;			result.getOps = append(result.getOps, clientv3.WithSerializable())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Versioner implements storage.Interface.Versioner.
0000000000000000000000000000000000000000;;	func (s *store) Versioner() storage.Versioner {
0000000000000000000000000000000000000000;;		return s.versioner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get implements storage.Interface.Get.
0000000000000000000000000000000000000000;;	func (s *store) Get(ctx context.Context, key string, resourceVersion string, out runtime.Object, ignoreNotFound bool) error {
0000000000000000000000000000000000000000;;		key = path.Join(s.pathPrefix, key)
0000000000000000000000000000000000000000;;		getResp, err := s.client.KV.Get(ctx, key, s.getOps...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(getResp.Kvs) == 0 {
0000000000000000000000000000000000000000;;			if ignoreNotFound {
0000000000000000000000000000000000000000;;				return runtime.SetZeroValue(out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return storage.NewKeyNotFoundError(key, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kv := getResp.Kvs[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, _, err := s.transformer.TransformFromStorage(kv.Value, authenticatedDataString(key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return decode(s.codec, s.versioner, data, out, kv.ModRevision)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create implements storage.Interface.Create.
0000000000000000000000000000000000000000;;	func (s *store) Create(ctx context.Context, key string, obj, out runtime.Object, ttl uint64) error {
0000000000000000000000000000000000000000;;		if version, err := s.versioner.ObjectResourceVersion(obj); err == nil && version != 0 {
0000000000000000000000000000000000000000;;			return errors.New("resourceVersion should not be set on objects to be created")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.versioner.PrepareObjectForStorage(obj); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PrepareObjectForStorage failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(s.codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(s.pathPrefix, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts, err := s.ttlOpts(ctx, int64(ttl))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newData, err := s.transformer.TransformToStorage(data, authenticatedDataString(key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		txnResp, err := s.client.KV.Txn(ctx).If(
0000000000000000000000000000000000000000;;			notFound(key),
0000000000000000000000000000000000000000;;		).Then(
0000000000000000000000000000000000000000;;			clientv3.OpPut(key, string(newData), opts...),
0000000000000000000000000000000000000000;;		).Commit()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !txnResp.Succeeded {
0000000000000000000000000000000000000000;;			return storage.NewKeyExistsError(key, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if out != nil {
0000000000000000000000000000000000000000;;			putResp := txnResp.Responses[0].GetResponsePut()
0000000000000000000000000000000000000000;;			return decode(s.codec, s.versioner, data, out, putResp.Header.Revision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete implements storage.Interface.Delete.
0000000000000000000000000000000000000000;;	func (s *store) Delete(ctx context.Context, key string, out runtime.Object, preconditions *storage.Preconditions) error {
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("unable to convert output object to pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(s.pathPrefix, key)
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			return s.unconditionalDelete(ctx, key, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.conditionalDelete(ctx, key, out, v, preconditions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) unconditionalDelete(ctx context.Context, key string, out runtime.Object) error {
0000000000000000000000000000000000000000;;		// We need to do get and delete in single transaction in order to
0000000000000000000000000000000000000000;;		// know the value and revision before deleting it.
0000000000000000000000000000000000000000;;		txnResp, err := s.client.KV.Txn(ctx).If().Then(
0000000000000000000000000000000000000000;;			clientv3.OpGet(key),
0000000000000000000000000000000000000000;;			clientv3.OpDelete(key),
0000000000000000000000000000000000000000;;		).Commit()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		getResp := txnResp.Responses[0].GetResponseRange()
0000000000000000000000000000000000000000;;		if len(getResp.Kvs) == 0 {
0000000000000000000000000000000000000000;;			return storage.NewKeyNotFoundError(key, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kv := getResp.Kvs[0]
0000000000000000000000000000000000000000;;		data, _, err := s.transformer.TransformFromStorage(kv.Value, authenticatedDataString(key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decode(s.codec, s.versioner, data, out, kv.ModRevision)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) conditionalDelete(ctx context.Context, key string, out runtime.Object, v reflect.Value, preconditions *storage.Preconditions) error {
0000000000000000000000000000000000000000;;		getResp, err := s.client.KV.Get(ctx, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			origState, err := s.getState(getResp, key, v, false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := checkPreconditions(key, preconditions, origState.obj); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			txnResp, err := s.client.KV.Txn(ctx).If(
0000000000000000000000000000000000000000;;				clientv3.Compare(clientv3.ModRevision(key), "=", origState.rev),
0000000000000000000000000000000000000000;;			).Then(
0000000000000000000000000000000000000000;;				clientv3.OpDelete(key),
0000000000000000000000000000000000000000;;			).Else(
0000000000000000000000000000000000000000;;				clientv3.OpGet(key),
0000000000000000000000000000000000000000;;			).Commit()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !txnResp.Succeeded {
0000000000000000000000000000000000000000;;				getResp = (*clientv3.GetResponse)(txnResp.Responses[0].GetResponseRange())
0000000000000000000000000000000000000000;;				glog.V(4).Infof("deletion of %s failed because of a conflict, going to retry", key)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return decode(s.codec, s.versioner, origState.data, out, origState.rev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GuaranteedUpdate implements storage.Interface.GuaranteedUpdate.
0000000000000000000000000000000000000000;;	func (s *store) GuaranteedUpdate(
0000000000000000000000000000000000000000;;		ctx context.Context, key string, out runtime.Object, ignoreNotFound bool,
0000000000000000000000000000000000000000;;		preconditions *storage.Preconditions, tryUpdate storage.UpdateFunc, suggestion ...runtime.Object) error {
0000000000000000000000000000000000000000;;		trace := utiltrace.New(fmt.Sprintf("GuaranteedUpdate etcd3: %s", reflect.TypeOf(out).String()))
0000000000000000000000000000000000000000;;		defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("unable to convert output object to pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(s.pathPrefix, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var origState *objState
0000000000000000000000000000000000000000;;		var mustCheckData bool
0000000000000000000000000000000000000000;;		if len(suggestion) == 1 && suggestion[0] != nil {
0000000000000000000000000000000000000000;;			origState, err = s.getStateFromObject(suggestion[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mustCheckData = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			getResp, err := s.client.KV.Get(ctx, key, s.getOps...)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			origState, err = s.getState(getResp, key, v, ignoreNotFound)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step("initial value restored")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transformContext := authenticatedDataString(key)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err := checkPreconditions(key, preconditions, origState.obj); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret, ttl, err := s.updateState(origState, tryUpdate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(s.codec, ret)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !origState.stale && bytes.Equal(data, origState.data) {
0000000000000000000000000000000000000000;;				// if we skipped the original Get in this loop, we must refresh from
0000000000000000000000000000000000000000;;				// etcd in order to be sure the data in the store is equivalent to
0000000000000000000000000000000000000000;;				// our desired serialization
0000000000000000000000000000000000000000;;				if mustCheckData {
0000000000000000000000000000000000000000;;					getResp, err := s.client.KV.Get(ctx, key, s.getOps...)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					origState, err = s.getState(getResp, key, v, ignoreNotFound)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					mustCheckData = false
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return decode(s.codec, s.versioner, origState.data, out, origState.rev)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newData, err := s.transformer.TransformToStorage(data, transformContext)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts, err := s.ttlOpts(ctx, int64(ttl))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Transaction prepared")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			txnResp, err := s.client.KV.Txn(ctx).If(
0000000000000000000000000000000000000000;;				clientv3.Compare(clientv3.ModRevision(key), "=", origState.rev),
0000000000000000000000000000000000000000;;			).Then(
0000000000000000000000000000000000000000;;				clientv3.OpPut(key, string(newData), opts...),
0000000000000000000000000000000000000000;;			).Else(
0000000000000000000000000000000000000000;;				clientv3.OpGet(key),
0000000000000000000000000000000000000000;;			).Commit()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trace.Step("Transaction committed")
0000000000000000000000000000000000000000;;			if !txnResp.Succeeded {
0000000000000000000000000000000000000000;;				getResp := (*clientv3.GetResponse)(txnResp.Responses[0].GetResponseRange())
0000000000000000000000000000000000000000;;				glog.V(4).Infof("GuaranteedUpdate of %s failed because of a conflict, going to retry", key)
0000000000000000000000000000000000000000;;				origState, err = s.getState(getResp, key, v, ignoreNotFound)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				trace.Step("Retry value restored")
0000000000000000000000000000000000000000;;				mustCheckData = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			putResp := txnResp.Responses[0].GetResponsePut()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return decode(s.codec, s.versioner, data, out, putResp.Header.Revision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetToList implements storage.Interface.GetToList.
0000000000000000000000000000000000000000;;	func (s *store) GetToList(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate, listObj runtime.Object) error {
0000000000000000000000000000000000000000;;		listPtr, err := meta.GetItemsPtr(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(s.pathPrefix, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getResp, err := s.client.KV.Get(ctx, key, s.getOps...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(getResp.Kvs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, _, err := s.transformer.TransformFromStorage(getResp.Kvs[0].Value, authenticatedDataString(key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		elems := []*elemForDecode{{
0000000000000000000000000000000000000000;;			data: data,
0000000000000000000000000000000000000000;;			rev:  uint64(getResp.Kvs[0].ModRevision),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		if err := decodeList(elems, storage.SimpleFilter(pred), listPtr, s.codec, s.versioner); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update version with cluster level revision
0000000000000000000000000000000000000000;;		return s.versioner.UpdateList(listObj, uint64(getResp.Header.Revision))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List implements storage.Interface.List.
0000000000000000000000000000000000000000;;	func (s *store) List(ctx context.Context, key, resourceVersion string, pred storage.SelectionPredicate, listObj runtime.Object) error {
0000000000000000000000000000000000000000;;		listPtr, err := meta.GetItemsPtr(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(s.pathPrefix, key)
0000000000000000000000000000000000000000;;		// We need to make sure the key ended with "/" so that we only get children "directories".
0000000000000000000000000000000000000000;;		// e.g. if we have key "/a", "/a/b", "/ab", getting keys with prefix "/a" will return all three,
0000000000000000000000000000000000000000;;		// while with prefix "/a/" will return only "/a/b" which is the correct answer.
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(key, "/") {
0000000000000000000000000000000000000000;;			key += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		getResp, err := s.client.KV.Get(ctx, key, clientv3.WithPrefix())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elems := make([]*elemForDecode, 0, len(getResp.Kvs))
0000000000000000000000000000000000000000;;		for _, kv := range getResp.Kvs {
0000000000000000000000000000000000000000;;			data, _, err := s.transformer.TransformFromStorage(kv.Value, authenticatedDataString(kv.Key))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("unable to transform key %q: %v", key, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			elems = append(elems, &elemForDecode{
0000000000000000000000000000000000000000;;				data: data,
0000000000000000000000000000000000000000;;				rev:  uint64(kv.ModRevision),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := decodeList(elems, storage.SimpleFilter(pred), listPtr, s.codec, s.versioner); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update version with cluster level revision
0000000000000000000000000000000000000000;;		return s.versioner.UpdateList(listObj, uint64(getResp.Header.Revision))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch implements storage.Interface.Watch.
0000000000000000000000000000000000000000;;	func (s *store) Watch(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return s.watch(ctx, key, resourceVersion, pred, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WatchList implements storage.Interface.WatchList.
0000000000000000000000000000000000000000;;	func (s *store) WatchList(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return s.watch(ctx, key, resourceVersion, pred, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) watch(ctx context.Context, key string, rv string, pred storage.SelectionPredicate, recursive bool) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		rev, err := storage.ParseWatchResourceVersion(rv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(s.pathPrefix, key)
0000000000000000000000000000000000000000;;		return s.watcher.Watch(ctx, key, int64(rev), recursive, pred)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) getState(getResp *clientv3.GetResponse, key string, v reflect.Value, ignoreNotFound bool) (*objState, error) {
0000000000000000000000000000000000000000;;		state := &objState{
0000000000000000000000000000000000000000;;			obj:  reflect.New(v.Type()).Interface().(runtime.Object),
0000000000000000000000000000000000000000;;			meta: &storage.ResponseMeta{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(getResp.Kvs) == 0 {
0000000000000000000000000000000000000000;;			if !ignoreNotFound {
0000000000000000000000000000000000000000;;				return nil, storage.NewKeyNotFoundError(key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := runtime.SetZeroValue(state.obj); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			data, stale, err := s.transformer.TransformFromStorage(getResp.Kvs[0].Value, authenticatedDataString(key))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			state.rev = getResp.Kvs[0].ModRevision
0000000000000000000000000000000000000000;;			state.meta.ResourceVersion = uint64(state.rev)
0000000000000000000000000000000000000000;;			state.data = data
0000000000000000000000000000000000000000;;			state.stale = stale
0000000000000000000000000000000000000000;;			if err := decode(s.codec, s.versioner, state.data, state.obj, state.rev); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) getStateFromObject(obj runtime.Object) (*objState, error) {
0000000000000000000000000000000000000000;;		state := &objState{
0000000000000000000000000000000000000000;;			obj:  obj,
0000000000000000000000000000000000000000;;			meta: &storage.ResponseMeta{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rv, err := s.versioner.ObjectResourceVersion(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't get resource version: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		state.rev = int64(rv)
0000000000000000000000000000000000000000;;		state.meta.ResourceVersion = uint64(state.rev)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compute the serialized form - for that we need to temporarily clean
0000000000000000000000000000000000000000;;		// its resource version field (those are not stored in etcd).
0000000000000000000000000000000000000000;;		if err := s.versioner.PrepareObjectForStorage(obj); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("PrepareObjectForStorage failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		state.data, err = runtime.Encode(s.codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.versioner.UpdateObject(state.obj, uint64(rv))
0000000000000000000000000000000000000000;;		return state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) updateState(st *objState, userUpdate storage.UpdateFunc) (runtime.Object, uint64, error) {
0000000000000000000000000000000000000000;;		ret, ttlPtr, err := userUpdate(st.obj, *st.meta)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.versioner.PrepareObjectForStorage(ret); err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, fmt.Errorf("PrepareObjectForStorage failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ttl uint64
0000000000000000000000000000000000000000;;		if ttlPtr != nil {
0000000000000000000000000000000000000000;;			ttl = *ttlPtr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, ttl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ttlOpts returns client options based on given ttl.
0000000000000000000000000000000000000000;;	// ttl: if ttl is non-zero, it will attach the key to a lease with ttl of roughly the same length
0000000000000000000000000000000000000000;;	func (s *store) ttlOpts(ctx context.Context, ttl int64) ([]clientv3.OpOption, error) {
0000000000000000000000000000000000000000;;		if ttl == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: one lease per ttl key is expensive. Based on current use case, we can have a long window to
0000000000000000000000000000000000000000;;		// put keys within into same lease. We shall benchmark this and optimize the performance.
0000000000000000000000000000000000000000;;		lcr, err := s.client.Lease.Grant(ctx, ttl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []clientv3.OpOption{clientv3.WithLease(clientv3.LeaseID(lcr.ID))}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decode decodes value of bytes into object. It will also set the object resource version to rev.
0000000000000000000000000000000000000000;;	// On success, objPtr would be set to the object.
0000000000000000000000000000000000000000;;	func decode(codec runtime.Codec, versioner storage.Versioner, value []byte, objPtr runtime.Object, rev int64) error {
0000000000000000000000000000000000000000;;		if _, err := conversion.EnforcePtr(objPtr); err != nil {
0000000000000000000000000000000000000000;;			panic("unable to convert output object to pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err := codec.Decode(value, nil, objPtr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// being unable to set the version does not prevent the object from being extracted
0000000000000000000000000000000000000000;;		versioner.UpdateObject(objPtr, uint64(rev))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeList decodes a list of values into a list of objects, with resource version set to corresponding rev.
0000000000000000000000000000000000000000;;	// On success, ListPtr would be set to the list of objects.
0000000000000000000000000000000000000000;;	func decodeList(elems []*elemForDecode, filter storage.FilterFunc, ListPtr interface{}, codec runtime.Codec, versioner storage.Versioner) error {
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(ListPtr)
0000000000000000000000000000000000000000;;		if err != nil || v.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			panic("need ptr to slice")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, elem := range elems {
0000000000000000000000000000000000000000;;			obj, _, err := codec.Decode(elem.data, nil, reflect.New(v.Type().Elem()).Interface().(runtime.Object))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// being unable to set the version does not prevent the object from being extracted
0000000000000000000000000000000000000000;;			versioner.UpdateObject(obj, elem.rev)
0000000000000000000000000000000000000000;;			if filter(obj) {
0000000000000000000000000000000000000000;;				v.Set(reflect.Append(v, reflect.ValueOf(obj).Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkPreconditions(key string, preconditions *storage.Preconditions, out runtime.Object) error {
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objMeta, err := meta.Accessor(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storage.NewInternalErrorf("can't enforce preconditions %v on un-introspectable object %v, got error: %v", *preconditions, out, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if preconditions.UID != nil && *preconditions.UID != objMeta.GetUID() {
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("Precondition failed: UID in precondition: %v, UID in object meta: %v", *preconditions.UID, objMeta.GetUID())
0000000000000000000000000000000000000000;;			return storage.NewInvalidObjError(key, errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func notFound(key string) clientv3.Cmp {
0000000000000000000000000000000000000000;;		return clientv3.Compare(clientv3.ModRevision(key), "=", 0)
0000000000000000000000000000000000000000;;	}
