0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
650604ab4bae345fc2e32be274f880f3dd2a68bf;pkg/client/cache/watch_cache.go[pkg/client/cache/watch_cache.go][staging/src/k8s.io/apiserver/pkg/storage/watch_cache.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		utiltrace "k8s.io/apiserver/pkg/util/trace"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// blockTimeout determines how long we're willing to block the request
0000000000000000000000000000000000000000;;		// to wait for a given resource version to be propagated to cache,
0000000000000000000000000000000000000000;;		// before terminating request and returning Timeout error with retry
0000000000000000000000000000000000000000;;		// after suggestion.
0000000000000000000000000000000000000000;;		blockTimeout = 3 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchCacheEvent is a single "watch event" that is send to users of
0000000000000000000000000000000000000000;;	// watchCache. Additionally to a typical "watch.Event" it contains
0000000000000000000000000000000000000000;;	// the previous value of the object to enable proper filtering in the
0000000000000000000000000000000000000000;;	// upper layers.
0000000000000000000000000000000000000000;;	type watchCacheEvent struct {
0000000000000000000000000000000000000000;;		Type                 watch.EventType
0000000000000000000000000000000000000000;;		Object               runtime.Object
0000000000000000000000000000000000000000;;		ObjLabels            labels.Set
0000000000000000000000000000000000000000;;		ObjFields            fields.Set
0000000000000000000000000000000000000000;;		ObjUninitialized     bool
0000000000000000000000000000000000000000;;		PrevObject           runtime.Object
0000000000000000000000000000000000000000;;		PrevObjLabels        labels.Set
0000000000000000000000000000000000000000;;		PrevObjFields        fields.Set
0000000000000000000000000000000000000000;;		PrevObjUninitialized bool
0000000000000000000000000000000000000000;;		Key                  string
0000000000000000000000000000000000000000;;		ResourceVersion      uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Computing a key of an object is generally non-trivial (it performs
0000000000000000000000000000000000000000;;	// e.g. validation underneath). To avoid computing it multiple times
0000000000000000000000000000000000000000;;	// (to serve the event in different List/Watch requests), in the
0000000000000000000000000000000000000000;;	// underlying store we are keeping pair (key, object).
0000000000000000000000000000000000000000;;	type storeElement struct {
0000000000000000000000000000000000000000;;		Key    string
0000000000000000000000000000000000000000;;		Object runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func storeElementKey(obj interface{}) (string, error) {
0000000000000000000000000000000000000000;;		elem, ok := obj.(*storeElement)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("not a storeElement: %v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return elem.Key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchCacheElement is a single "watch event" stored in a cache.
0000000000000000000000000000000000000000;;	// It contains the resource version of the object and the object
0000000000000000000000000000000000000000;;	// itself.
0000000000000000000000000000000000000000;;	type watchCacheElement struct {
0000000000000000000000000000000000000000;;		resourceVersion uint64
0000000000000000000000000000000000000000;;		watchCacheEvent *watchCacheEvent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchCache implements a Store interface.
0000000000000000000000000000000000000000;;	// However, it depends on the elements implementing runtime.Object interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// watchCache is a "sliding window" (with a limited capacity) of objects
0000000000000000000000000000000000000000;;	// observed from a watch.
0000000000000000000000000000000000000000;;	type watchCache struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Condition on which lists are waiting for the fresh enough
0000000000000000000000000000000000000000;;		// resource version.
0000000000000000000000000000000000000000;;		cond *sync.Cond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum size of history window.
0000000000000000000000000000000000000000;;		capacity int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keyFunc is used to get a key in the underlying storage for a given object.
0000000000000000000000000000000000000000;;		keyFunc func(runtime.Object) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// getAttrsFunc is used to get labels and fields of an object.
0000000000000000000000000000000000000000;;		getAttrsFunc func(runtime.Object) (labels.Set, fields.Set, bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cache is used a cyclic buffer - its first element (with the smallest
0000000000000000000000000000000000000000;;		// resourceVersion) is defined by startIndex, its last element is defined
0000000000000000000000000000000000000000;;		// by endIndex (if cache is full it will be startIndex + capacity).
0000000000000000000000000000000000000000;;		// Both startIndex and endIndex can be greater than buffer capacity -
0000000000000000000000000000000000000000;;		// you should always apply modulo capacity to get an index in cache array.
0000000000000000000000000000000000000000;;		cache      []watchCacheElement
0000000000000000000000000000000000000000;;		startIndex int
0000000000000000000000000000000000000000;;		endIndex   int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// store will effectively support LIST operation from the "end of cache
0000000000000000000000000000000000000000;;		// history" i.e. from the moment just after the newest cached watched event.
0000000000000000000000000000000000000000;;		// It is necessary to effectively allow clients to start watching at now.
0000000000000000000000000000000000000000;;		// NOTE: We assume that <store> is thread-safe.
0000000000000000000000000000000000000000;;		store cache.Store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResourceVersion up to which the watchCache is propagated.
0000000000000000000000000000000000000000;;		resourceVersion uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This handler is run at the end of every successful Replace() method.
0000000000000000000000000000000000000000;;		onReplace func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This handler is run at the end of every Add/Update/Delete method
0000000000000000000000000000000000000000;;		// and additionally gets the previous value of the object.
0000000000000000000000000000000000000000;;		onEvent func(*watchCacheEvent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for testing timeouts.
0000000000000000000000000000000000000000;;		clock clock.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWatchCache(
0000000000000000000000000000000000000000;;		capacity int,
0000000000000000000000000000000000000000;;		keyFunc func(runtime.Object) (string, error),
0000000000000000000000000000000000000000;;		getAttrsFunc func(runtime.Object) (labels.Set, fields.Set, bool, error)) *watchCache {
0000000000000000000000000000000000000000;;		wc := &watchCache{
0000000000000000000000000000000000000000;;			capacity:        capacity,
0000000000000000000000000000000000000000;;			keyFunc:         keyFunc,
0000000000000000000000000000000000000000;;			getAttrsFunc:    getAttrsFunc,
0000000000000000000000000000000000000000;;			cache:           make([]watchCacheElement, capacity),
0000000000000000000000000000000000000000;;			startIndex:      0,
0000000000000000000000000000000000000000;;			endIndex:        0,
0000000000000000000000000000000000000000;;			store:           cache.NewStore(storeElementKey),
0000000000000000000000000000000000000000;;			resourceVersion: 0,
0000000000000000000000000000000000000000;;			clock:           clock.RealClock{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wc.cond = sync.NewCond(wc.RLocker())
0000000000000000000000000000000000000000;;		return wc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add takes runtime.Object as an argument.
0000000000000000000000000000000000000000;;	func (w *watchCache) Add(obj interface{}) error {
0000000000000000000000000000000000000000;;		object, resourceVersion, err := objectToVersionedRuntimeObject(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		event := watch.Event{Type: watch.Added, Object: object}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := func(elem *storeElement) error { return w.store.Add(elem) }
0000000000000000000000000000000000000000;;		return w.processEvent(event, resourceVersion, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update takes runtime.Object as an argument.
0000000000000000000000000000000000000000;;	func (w *watchCache) Update(obj interface{}) error {
0000000000000000000000000000000000000000;;		object, resourceVersion, err := objectToVersionedRuntimeObject(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		event := watch.Event{Type: watch.Modified, Object: object}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := func(elem *storeElement) error { return w.store.Update(elem) }
0000000000000000000000000000000000000000;;		return w.processEvent(event, resourceVersion, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete takes runtime.Object as an argument.
0000000000000000000000000000000000000000;;	func (w *watchCache) Delete(obj interface{}) error {
0000000000000000000000000000000000000000;;		object, resourceVersion, err := objectToVersionedRuntimeObject(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		event := watch.Event{Type: watch.Deleted, Object: object}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := func(elem *storeElement) error { return w.store.Delete(elem) }
0000000000000000000000000000000000000000;;		return w.processEvent(event, resourceVersion, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func objectToVersionedRuntimeObject(obj interface{}) (runtime.Object, uint64, error) {
0000000000000000000000000000000000000000;;		object, ok := obj.(runtime.Object)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, 0, fmt.Errorf("obj does not implement runtime.Object interface: %v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		meta, err := meta.Accessor(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersion, err := parseResourceVersion(meta.GetResourceVersion())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return object, resourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseResourceVersion(resourceVersion string) (uint64, error) {
0000000000000000000000000000000000000000;;		if resourceVersion == "" {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Use bitsize being the size of int on the machine.
0000000000000000000000000000000000000000;;		return strconv.ParseUint(resourceVersion, 10, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchCache) processEvent(event watch.Event, resourceVersion uint64, updateFunc func(*storeElement) error) error {
0000000000000000000000000000000000000000;;		key, err := w.keyFunc(event.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't compute key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		elem := &storeElement{Key: key, Object: event.Object}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: We should consider moving this lock below after the watchCacheEvent
0000000000000000000000000000000000000000;;		// is created. In such situation, the only problematic scenario is Replace(
0000000000000000000000000000000000000000;;		// happening after getting object from store and before acquiring a lock.
0000000000000000000000000000000000000000;;		// Maybe introduce another lock for this purpose.
0000000000000000000000000000000000000000;;		w.Lock()
0000000000000000000000000000000000000000;;		defer w.Unlock()
0000000000000000000000000000000000000000;;		previous, exists, err := w.store.Get(elem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objLabels, objFields, objUninitialized, err := w.getAttrsFunc(event.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var prevObject runtime.Object
0000000000000000000000000000000000000000;;		var prevObjLabels labels.Set
0000000000000000000000000000000000000000;;		var prevObjFields fields.Set
0000000000000000000000000000000000000000;;		var prevObjUninitialized bool
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			prevObject = previous.(*storeElement).Object
0000000000000000000000000000000000000000;;			prevObjLabels, prevObjFields, prevObjUninitialized, err = w.getAttrsFunc(prevObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		watchCacheEvent := &watchCacheEvent{
0000000000000000000000000000000000000000;;			Type:                 event.Type,
0000000000000000000000000000000000000000;;			Object:               event.Object,
0000000000000000000000000000000000000000;;			ObjLabels:            objLabels,
0000000000000000000000000000000000000000;;			ObjFields:            objFields,
0000000000000000000000000000000000000000;;			ObjUninitialized:     objUninitialized,
0000000000000000000000000000000000000000;;			PrevObject:           prevObject,
0000000000000000000000000000000000000000;;			PrevObjLabels:        prevObjLabels,
0000000000000000000000000000000000000000;;			PrevObjFields:        prevObjFields,
0000000000000000000000000000000000000000;;			PrevObjUninitialized: prevObjUninitialized,
0000000000000000000000000000000000000000;;			Key:                  key,
0000000000000000000000000000000000000000;;			ResourceVersion:      resourceVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.onEvent != nil {
0000000000000000000000000000000000000000;;			w.onEvent(watchCacheEvent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.updateCache(resourceVersion, watchCacheEvent)
0000000000000000000000000000000000000000;;		w.resourceVersion = resourceVersion
0000000000000000000000000000000000000000;;		w.cond.Broadcast()
0000000000000000000000000000000000000000;;		return updateFunc(elem)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assumes that lock is already held for write.
0000000000000000000000000000000000000000;;	func (w *watchCache) updateCache(resourceVersion uint64, event *watchCacheEvent) {
0000000000000000000000000000000000000000;;		if w.endIndex == w.startIndex+w.capacity {
0000000000000000000000000000000000000000;;			// Cache is full - remove the oldest element.
0000000000000000000000000000000000000000;;			w.startIndex++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.cache[w.endIndex%w.capacity] = watchCacheElement{resourceVersion, event}
0000000000000000000000000000000000000000;;		w.endIndex++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns list of pointers to <storeElement> objects.
0000000000000000000000000000000000000000;;	func (w *watchCache) List() []interface{} {
0000000000000000000000000000000000000000;;		return w.store.List()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitUntilFreshAndBlock waits until cache is at least as fresh as given <resourceVersion>.
0000000000000000000000000000000000000000;;	// NOTE: This function acquired lock and doesn't release it.
0000000000000000000000000000000000000000;;	// You HAVE TO explicitly call w.RUnlock() after this function.
0000000000000000000000000000000000000000;;	func (w *watchCache) waitUntilFreshAndBlock(resourceVersion uint64, trace *utiltrace.Trace) error {
0000000000000000000000000000000000000000;;		startTime := w.clock.Now()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// Wake us up when the time limit has expired.  The docs
0000000000000000000000000000000000000000;;			// promise that time.After (well, NewTimer, which it calls)
0000000000000000000000000000000000000000;;			// will wait *at least* the duration given. Since this go
0000000000000000000000000000000000000000;;			// routine starts sometime after we record the start time, and
0000000000000000000000000000000000000000;;			// it will wake up the loop below sometime after the broadcast,
0000000000000000000000000000000000000000;;			// we don't need to worry about waking it up before the time
0000000000000000000000000000000000000000;;			// has expired accidentally.
0000000000000000000000000000000000000000;;			<-w.clock.After(blockTimeout)
0000000000000000000000000000000000000000;;			w.cond.Broadcast()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.RLock()
0000000000000000000000000000000000000000;;		if trace != nil {
0000000000000000000000000000000000000000;;			trace.Step("watchCache locked acquired")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for w.resourceVersion < resourceVersion {
0000000000000000000000000000000000000000;;			if w.clock.Since(startTime) >= blockTimeout {
0000000000000000000000000000000000000000;;				// Timeout with retry after 1 second.
0000000000000000000000000000000000000000;;				return errors.NewTimeoutError(fmt.Sprintf("Too large resource version: %v, current: %v", resourceVersion, w.resourceVersion), 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trace != nil {
0000000000000000000000000000000000000000;;			trace.Step("watchCache fresh enough")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilFreshAndList returns list of pointers to <storeElement> objects.
0000000000000000000000000000000000000000;;	func (w *watchCache) WaitUntilFreshAndList(resourceVersion uint64, trace *utiltrace.Trace) ([]interface{}, uint64, error) {
0000000000000000000000000000000000000000;;		err := w.waitUntilFreshAndBlock(resourceVersion, trace)
0000000000000000000000000000000000000000;;		defer w.RUnlock()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.store.List(), w.resourceVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilFreshAndGet returns a pointers to <storeElement> object.
0000000000000000000000000000000000000000;;	func (w *watchCache) WaitUntilFreshAndGet(resourceVersion uint64, key string, trace *utiltrace.Trace) (interface{}, bool, uint64, error) {
0000000000000000000000000000000000000000;;		err := w.waitUntilFreshAndBlock(resourceVersion, trace)
0000000000000000000000000000000000000000;;		defer w.RUnlock()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value, exists, err := w.store.GetByKey(key)
0000000000000000000000000000000000000000;;		return value, exists, w.resourceVersion, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchCache) ListKeys() []string {
0000000000000000000000000000000000000000;;		return w.store.ListKeys()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get takes runtime.Object as a parameter. However, it returns
0000000000000000000000000000000000000000;;	// pointer to <storeElement>.
0000000000000000000000000000000000000000;;	func (w *watchCache) Get(obj interface{}) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		object, ok := obj.(runtime.Object)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("obj does not implement runtime.Object interface: %v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := w.keyFunc(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("couldn't compute key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w.store.Get(&storeElement{Key: key, Object: object})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey returns pointer to <storeElement>.
0000000000000000000000000000000000000000;;	func (w *watchCache) GetByKey(key string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		return w.store.GetByKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace takes slice of runtime.Object as a paramater.
0000000000000000000000000000000000000000;;	func (w *watchCache) Replace(objs []interface{}, resourceVersion string) error {
0000000000000000000000000000000000000000;;		version, err := parseResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		toReplace := make([]interface{}, 0, len(objs))
0000000000000000000000000000000000000000;;		for _, obj := range objs {
0000000000000000000000000000000000000000;;			object, ok := obj.(runtime.Object)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("didn't get runtime.Object for replace: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key, err := w.keyFunc(object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("couldn't compute key: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			toReplace = append(toReplace, &storeElement{Key: key, Object: object})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Lock()
0000000000000000000000000000000000000000;;		defer w.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.startIndex = 0
0000000000000000000000000000000000000000;;		w.endIndex = 0
0000000000000000000000000000000000000000;;		if err := w.store.Replace(toReplace, resourceVersion); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.resourceVersion = version
0000000000000000000000000000000000000000;;		if w.onReplace != nil {
0000000000000000000000000000000000000000;;			w.onReplace()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.cond.Broadcast()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchCache) SetOnReplace(onReplace func()) {
0000000000000000000000000000000000000000;;		w.Lock()
0000000000000000000000000000000000000000;;		defer w.Unlock()
0000000000000000000000000000000000000000;;		w.onReplace = onReplace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchCache) SetOnEvent(onEvent func(*watchCacheEvent)) {
0000000000000000000000000000000000000000;;		w.Lock()
0000000000000000000000000000000000000000;;		defer w.Unlock()
0000000000000000000000000000000000000000;;		w.onEvent = onEvent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchCache) GetAllEventsSinceThreadUnsafe(resourceVersion uint64) ([]*watchCacheEvent, error) {
0000000000000000000000000000000000000000;;		size := w.endIndex - w.startIndex
0000000000000000000000000000000000000000;;		oldest := w.resourceVersion
0000000000000000000000000000000000000000;;		if size > 0 {
0000000000000000000000000000000000000000;;			oldest = w.cache[w.startIndex%w.capacity].resourceVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resourceVersion == 0 {
0000000000000000000000000000000000000000;;			// resourceVersion = 0 means that we don't require any specific starting point
0000000000000000000000000000000000000000;;			// and we would like to start watching from ~now.
0000000000000000000000000000000000000000;;			// However, to keep backward compatibility, we additionally need to return the
0000000000000000000000000000000000000000;;			// current state and only then start watching from that point.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// TODO: In v2 api, we should stop returning the current state - #13969.
0000000000000000000000000000000000000000;;			allItems := w.store.List()
0000000000000000000000000000000000000000;;			result := make([]*watchCacheEvent, len(allItems))
0000000000000000000000000000000000000000;;			for i, item := range allItems {
0000000000000000000000000000000000000000;;				elem, ok := item.(*storeElement)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("not a storeElement: %v", elem)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				objLabels, objFields, objUninitialized, err := w.getAttrsFunc(elem.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result[i] = &watchCacheEvent{
0000000000000000000000000000000000000000;;					Type:             watch.Added,
0000000000000000000000000000000000000000;;					Object:           elem.Object,
0000000000000000000000000000000000000000;;					ObjLabels:        objLabels,
0000000000000000000000000000000000000000;;					ObjFields:        objFields,
0000000000000000000000000000000000000000;;					ObjUninitialized: objUninitialized,
0000000000000000000000000000000000000000;;					Key:              elem.Key,
0000000000000000000000000000000000000000;;					ResourceVersion:  w.resourceVersion,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resourceVersion < oldest-1 {
0000000000000000000000000000000000000000;;			return nil, errors.NewGone(fmt.Sprintf("too old resource version: %d (%d)", resourceVersion, oldest-1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Binary search the smallest index at which resourceVersion is greater than the given one.
0000000000000000000000000000000000000000;;		f := func(i int) bool {
0000000000000000000000000000000000000000;;			return w.cache[(w.startIndex+i)%w.capacity].resourceVersion > resourceVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		first := sort.Search(size, f)
0000000000000000000000000000000000000000;;		result := make([]*watchCacheEvent, size-first)
0000000000000000000000000000000000000000;;		for i := 0; i < size-first; i++ {
0000000000000000000000000000000000000000;;			result[i] = w.cache[(w.startIndex+first+i)%w.capacity].watchCacheEvent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchCache) GetAllEventsSince(resourceVersion uint64) ([]*watchCacheEvent, error) {
0000000000000000000000000000000000000000;;		w.RLock()
0000000000000000000000000000000000000000;;		defer w.RUnlock()
0000000000000000000000000000000000000000;;		return w.GetAllEventsSinceThreadUnsafe(resourceVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchCache) Resync() error {
0000000000000000000000000000000000000000;;		// Nothing to do
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
