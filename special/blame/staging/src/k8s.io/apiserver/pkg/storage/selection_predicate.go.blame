0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
50a984709663d988f64969f674579c900d2a6faf;pkg/storage/selection_predicate.go[pkg/storage/selection_predicate.go][staging/src/k8s.io/apiserver/pkg/storage/selection_predicate.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttrFunc returns label and field sets and the uninitialized flag for List or Watch to match.
0000000000000000000000000000000000000000;;	// In any failure to parse given object, it returns error.
0000000000000000000000000000000000000000;;	type AttrFunc func(obj runtime.Object) (labels.Set, fields.Set, bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectionPredicate is used to represent the way to select objects from api storage.
0000000000000000000000000000000000000000;;	type SelectionPredicate struct {
0000000000000000000000000000000000000000;;		Label                labels.Selector
0000000000000000000000000000000000000000;;		Field                fields.Selector
0000000000000000000000000000000000000000;;		IncludeUninitialized bool
0000000000000000000000000000000000000000;;		GetAttrs             AttrFunc
0000000000000000000000000000000000000000;;		IndexFields          []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matches returns true if the given object's labels and fields (as
0000000000000000000000000000000000000000;;	// returned by s.GetAttrs) match s.Label and s.Field. An error is
0000000000000000000000000000000000000000;;	// returned if s.GetAttrs fails.
0000000000000000000000000000000000000000;;	func (s *SelectionPredicate) Matches(obj runtime.Object) (bool, error) {
0000000000000000000000000000000000000000;;		if s.Empty() {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels, fields, uninitialized, err := s.GetAttrs(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.IncludeUninitialized && uninitialized {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matched := s.Label.Matches(labels)
0000000000000000000000000000000000000000;;		if matched && s.Field != nil {
0000000000000000000000000000000000000000;;			matched = (matched && s.Field.Matches(fields))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return matched, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchesObjectAttributes returns true if the given labels and fields
0000000000000000000000000000000000000000;;	// match s.Label and s.Field.
0000000000000000000000000000000000000000;;	func (s *SelectionPredicate) MatchesObjectAttributes(l labels.Set, f fields.Set, uninitialized bool) bool {
0000000000000000000000000000000000000000;;		if !s.IncludeUninitialized && uninitialized {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Label.Empty() && s.Field.Empty() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matched := s.Label.Matches(l)
0000000000000000000000000000000000000000;;		if matched && s.Field != nil {
0000000000000000000000000000000000000000;;			matched = (matched && s.Field.Matches(f))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return matched
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchesSingle will return (name, true) if and only if s.Field matches on the object's
0000000000000000000000000000000000000000;;	// name.
0000000000000000000000000000000000000000;;	func (s *SelectionPredicate) MatchesSingle() (string, bool) {
0000000000000000000000000000000000000000;;		// TODO: should be namespace.name
0000000000000000000000000000000000000000;;		if name, ok := s.Field.RequiresExactMatch("metadata.name"); ok {
0000000000000000000000000000000000000000;;			return name, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For any index defined by IndexFields, if a matcher can match only (a subset)
0000000000000000000000000000000000000000;;	// of objects that return <value> for a given index, a pair (<index name>, <value>)
0000000000000000000000000000000000000000;;	// wil be returned.
0000000000000000000000000000000000000000;;	// TODO: Consider supporting also labels.
0000000000000000000000000000000000000000;;	func (s *SelectionPredicate) MatcherIndex() []MatchValue {
0000000000000000000000000000000000000000;;		var result []MatchValue
0000000000000000000000000000000000000000;;		for _, field := range s.IndexFields {
0000000000000000000000000000000000000000;;			if value, ok := s.Field.RequiresExactMatch(field); ok {
0000000000000000000000000000000000000000;;				result = append(result, MatchValue{IndexName: field, Value: value})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns true if the predicate performs no filtering.
0000000000000000000000000000000000000000;;	func (s *SelectionPredicate) Empty() bool {
0000000000000000000000000000000000000000;;		return s.Label.Empty() && s.Field.Empty() && s.IncludeUninitialized
0000000000000000000000000000000000000000;;	}
