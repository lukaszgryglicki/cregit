0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c5bc83828d622ece540df3d4087dc256d5cfa0ed;pkg/storage/cacher.go[pkg/storage/cacher.go][staging/src/k8s.io/apiserver/pkg/storage/cacher.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		utiltrace "k8s.io/apiserver/pkg/util/trace"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CacherConfig contains the configuration for a given Cache.
0000000000000000000000000000000000000000;;	type CacherConfig struct {
0000000000000000000000000000000000000000;;		// Maximum size of the history cached in memory.
0000000000000000000000000000000000000000;;		CacheCapacity int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An underlying storage.Interface.
0000000000000000000000000000000000000000;;		Storage Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An underlying storage.Versioner.
0000000000000000000000000000000000000000;;		Versioner Versioner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Copier runtime.ObjectCopier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Cache will be caching objects of a given Type and assumes that they
0000000000000000000000000000000000000000;;		// are all stored under ResourcePrefix directory in the underlying database.
0000000000000000000000000000000000000000;;		Type           interface{}
0000000000000000000000000000000000000000;;		ResourcePrefix string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyFunc is used to get a key in the underlying storage for a given object.
0000000000000000000000000000000000000000;;		KeyFunc func(runtime.Object) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetAttrsFunc is used to get object labels, fields, and the uninitialized bool
0000000000000000000000000000000000000000;;		GetAttrsFunc func(runtime.Object) (label labels.Set, field fields.Set, uninitialized bool, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TriggerPublisherFunc is used for optimizing amount of watchers that
0000000000000000000000000000000000000000;;		// needs to process an incoming event.
0000000000000000000000000000000000000000;;		TriggerPublisherFunc TriggerPublisherFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewList is a function that creates new empty object storing a list of
0000000000000000000000000000000000000000;;		// objects of type Type.
0000000000000000000000000000000000000000;;		NewListFunc func() runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Codec runtime.Codec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watchersMap map[int]*cacheWatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wm watchersMap) addWatcher(w *cacheWatcher, number int) {
0000000000000000000000000000000000000000;;		wm[number] = w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wm watchersMap) deleteWatcher(number int) {
0000000000000000000000000000000000000000;;		delete(wm, number)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wm watchersMap) terminateAll() {
0000000000000000000000000000000000000000;;		for key, watcher := range wm {
0000000000000000000000000000000000000000;;			delete(wm, key)
0000000000000000000000000000000000000000;;			watcher.stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type indexedWatchers struct {
0000000000000000000000000000000000000000;;		allWatchers   watchersMap
0000000000000000000000000000000000000000;;		valueWatchers map[string]watchersMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *indexedWatchers) addWatcher(w *cacheWatcher, number int, value string, supported bool) {
0000000000000000000000000000000000000000;;		if supported {
0000000000000000000000000000000000000000;;			if _, ok := i.valueWatchers[value]; !ok {
0000000000000000000000000000000000000000;;				i.valueWatchers[value] = watchersMap{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.valueWatchers[value].addWatcher(w, number)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			i.allWatchers.addWatcher(w, number)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *indexedWatchers) deleteWatcher(number int, value string, supported bool) {
0000000000000000000000000000000000000000;;		if supported {
0000000000000000000000000000000000000000;;			i.valueWatchers[value].deleteWatcher(number)
0000000000000000000000000000000000000000;;			if len(i.valueWatchers[value]) == 0 {
0000000000000000000000000000000000000000;;				delete(i.valueWatchers, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			i.allWatchers.deleteWatcher(number)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *indexedWatchers) terminateAll(objectType reflect.Type) {
0000000000000000000000000000000000000000;;		if len(i.allWatchers) > 0 || len(i.valueWatchers) > 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("Terminating all watchers from cacher %v", objectType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.allWatchers.terminateAll()
0000000000000000000000000000000000000000;;		for index, watchers := range i.valueWatchers {
0000000000000000000000000000000000000000;;			watchers.terminateAll()
0000000000000000000000000000000000000000;;			delete(i.valueWatchers, index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watchFilterFunc func(key string, l labels.Set, f fields.Set, uninitialized bool) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cacher is responsible for serving WATCH and LIST requests for a given
0000000000000000000000000000000000000000;;	// resource from its internal cache and updating its cache in the background
0000000000000000000000000000000000000000;;	// based on the underlying storage contents.
0000000000000000000000000000000000000000;;	// Cacher implements storage.Interface (although most of the calls are just
0000000000000000000000000000000000000000;;	// delegated to the underlying storage).
0000000000000000000000000000000000000000;;	type Cacher struct {
0000000000000000000000000000000000000000;;		// HighWaterMarks for performance debugging.
0000000000000000000000000000000000000000;;		// Important: Since HighWaterMark is using sync/atomic, it has to be at the top of the struct due to a bug on 32-bit platforms
0000000000000000000000000000000000000000;;		// See: https://golang.org/pkg/sync/atomic/ for more information
0000000000000000000000000000000000000000;;		incomingHWM HighWaterMark
0000000000000000000000000000000000000000;;		// Incoming events that should be dispatched to watchers.
0000000000000000000000000000000000000000;;		incoming chan watchCacheEvent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Before accessing the cacher's cache, wait for the ready to be ok.
0000000000000000000000000000000000000000;;		// This is necessary to prevent users from accessing structures that are
0000000000000000000000000000000000000000;;		// uninitialized or are being repopulated right now.
0000000000000000000000000000000000000000;;		// ready needs to be set to false when the cacher is paused or stopped.
0000000000000000000000000000000000000000;;		// ready needs to be set to true when the cacher is ready to use after
0000000000000000000000000000000000000000;;		// initialization.
0000000000000000000000000000000000000000;;		ready *ready
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Underlying storage.Interface.
0000000000000000000000000000000000000000;;		storage Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copier runtime.ObjectCopier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expected type of objects in the underlying cache.
0000000000000000000000000000000000000000;;		objectType reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "sliding window" of recent changes of objects and the current state.
0000000000000000000000000000000000000000;;		watchCache *watchCache
0000000000000000000000000000000000000000;;		reflector  *cache.Reflector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Versioner is used to handle resource versions.
0000000000000000000000000000000000000000;;		versioner Versioner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// triggerFunc is used for optimizing amount of watchers that needs to process
0000000000000000000000000000000000000000;;		// an incoming event.
0000000000000000000000000000000000000000;;		triggerFunc TriggerPublisherFunc
0000000000000000000000000000000000000000;;		// watchers is mapping from the value of trigger function that a
0000000000000000000000000000000000000000;;		// watcher is interested into the watchers
0000000000000000000000000000000000000000;;		watcherIdx int
0000000000000000000000000000000000000000;;		watchers   indexedWatchers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Defines a time budget that can be spend on waiting for not-ready watchers
0000000000000000000000000000000000000000;;		// while dispatching event before shutting them down.
0000000000000000000000000000000000000000;;		dispatchTimeoutBudget *timeBudget
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handling graceful termination.
0000000000000000000000000000000000000000;;		stopLock sync.RWMutex
0000000000000000000000000000000000000000;;		stopped  bool
0000000000000000000000000000000000000000;;		stopCh   chan struct{}
0000000000000000000000000000000000000000;;		stopWg   sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new Cacher responsible for servicing WATCH and LIST requests from
0000000000000000000000000000000000000000;;	// its internal cache and updating its cache in the background based on the
0000000000000000000000000000000000000000;;	// given configuration.
0000000000000000000000000000000000000000;;	func NewCacherFromConfig(config CacherConfig) *Cacher {
0000000000000000000000000000000000000000;;		watchCache := newWatchCache(config.CacheCapacity, config.KeyFunc, config.GetAttrsFunc)
0000000000000000000000000000000000000000;;		listerWatcher := newCacherListerWatcher(config.Storage, config.ResourcePrefix, config.NewListFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Give this error when it is constructed rather than when you get the
0000000000000000000000000000000000000000;;		// first watch item, because it's much easier to track down that way.
0000000000000000000000000000000000000000;;		if obj, ok := config.Type.(runtime.Object); ok {
0000000000000000000000000000000000000000;;			if err := runtime.CheckCodec(config.Codec, obj); err != nil {
0000000000000000000000000000000000000000;;				panic("storage codec doesn't seem to match given type: " + err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		cacher := &Cacher{
0000000000000000000000000000000000000000;;			ready:       newReady(),
0000000000000000000000000000000000000000;;			storage:     config.Storage,
0000000000000000000000000000000000000000;;			copier:      config.Copier,
0000000000000000000000000000000000000000;;			objectType:  reflect.TypeOf(config.Type),
0000000000000000000000000000000000000000;;			watchCache:  watchCache,
0000000000000000000000000000000000000000;;			reflector:   cache.NewReflector(listerWatcher, config.Type, watchCache, 0),
0000000000000000000000000000000000000000;;			versioner:   config.Versioner,
0000000000000000000000000000000000000000;;			triggerFunc: config.TriggerPublisherFunc,
0000000000000000000000000000000000000000;;			watcherIdx:  0,
0000000000000000000000000000000000000000;;			watchers: indexedWatchers{
0000000000000000000000000000000000000000;;				allWatchers:   make(map[int]*cacheWatcher),
0000000000000000000000000000000000000000;;				valueWatchers: make(map[string]watchersMap),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// TODO: Figure out the correct value for the buffer size.
0000000000000000000000000000000000000000;;			incoming:              make(chan watchCacheEvent, 100),
0000000000000000000000000000000000000000;;			dispatchTimeoutBudget: newTimeBudget(stopCh),
0000000000000000000000000000000000000000;;			// We need to (potentially) stop both:
0000000000000000000000000000000000000000;;			// - wait.Until go-routine
0000000000000000000000000000000000000000;;			// - reflector.ListAndWatch
0000000000000000000000000000000000000000;;			// and there are no guarantees on the order that they will stop.
0000000000000000000000000000000000000000;;			// So we will be simply closing the channel, and synchronizing on the WaitGroup.
0000000000000000000000000000000000000000;;			stopCh: stopCh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		watchCache.SetOnEvent(cacher.processEvent)
0000000000000000000000000000000000000000;;		go cacher.dispatchEvents()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cacher.stopWg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer cacher.stopWg.Done()
0000000000000000000000000000000000000000;;			wait.Until(
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					if !cacher.isStopped() {
0000000000000000000000000000000000000000;;						cacher.startCaching(stopCh)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}, time.Second, stopCh,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return cacher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) startCaching(stopChannel <-chan struct{}) {
0000000000000000000000000000000000000000;;		// The 'usable' lock is always 'RLock'able when it is safe to use the cache.
0000000000000000000000000000000000000000;;		// It is safe to use the cache after a successful list until a disconnection.
0000000000000000000000000000000000000000;;		// We start with usable (write) locked. The below OnReplace function will
0000000000000000000000000000000000000000;;		// unlock it after a successful list. The below defer will then re-lock
0000000000000000000000000000000000000000;;		// it when this function exits (always due to disconnection), only if
0000000000000000000000000000000000000000;;		// we actually got a successful list. This cycle will repeat as needed.
0000000000000000000000000000000000000000;;		successfulList := false
0000000000000000000000000000000000000000;;		c.watchCache.SetOnReplace(func() {
0000000000000000000000000000000000000000;;			successfulList = true
0000000000000000000000000000000000000000;;			c.ready.set(true)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if successfulList {
0000000000000000000000000000000000000000;;				c.ready.set(false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.terminateAllWatchers()
0000000000000000000000000000000000000000;;		// Note that since onReplace may be not called due to errors, we explicitly
0000000000000000000000000000000000000000;;		// need to retry it on errors under lock.
0000000000000000000000000000000000000000;;		// Also note that startCaching is called in a loop, so there's no need
0000000000000000000000000000000000000000;;		// to have another loop here.
0000000000000000000000000000000000000000;;		if err := c.reflector.ListAndWatch(stopChannel); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("unexpected ListAndWatch error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) Versioner() Versioner {
0000000000000000000000000000000000000000;;		return c.storage.Versioner()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) Create(ctx context.Context, key string, obj, out runtime.Object, ttl uint64) error {
0000000000000000000000000000000000000000;;		return c.storage.Create(ctx, key, obj, out, ttl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) Delete(ctx context.Context, key string, out runtime.Object, preconditions *Preconditions) error {
0000000000000000000000000000000000000000;;		return c.storage.Delete(ctx, key, out, preconditions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) Watch(ctx context.Context, key string, resourceVersion string, pred SelectionPredicate) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		watchRV, err := ParseWatchResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.ready.wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We explicitly use thread unsafe version and do locking ourself to ensure that
0000000000000000000000000000000000000000;;		// no new events will be processed in the meantime. The watchCache will be unlocked
0000000000000000000000000000000000000000;;		// on return from this function.
0000000000000000000000000000000000000000;;		// Note that we cannot do it under Cacher lock, to avoid a deadlock, since the
0000000000000000000000000000000000000000;;		// underlying watchCache is calling processEvent under its lock.
0000000000000000000000000000000000000000;;		c.watchCache.RLock()
0000000000000000000000000000000000000000;;		defer c.watchCache.RUnlock()
0000000000000000000000000000000000000000;;		initEvents, err := c.watchCache.GetAllEventsSinceThreadUnsafe(watchRV)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// To match the uncached watch implementation, once we have passed authn/authz/admission,
0000000000000000000000000000000000000000;;			// and successfully parsed a resource version, other errors must fail with a watch event of type ERROR,
0000000000000000000000000000000000000000;;			// rather than a directly returned error.
0000000000000000000000000000000000000000;;			return newErrWatcher(err), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		triggerValue, triggerSupported := "", false
0000000000000000000000000000000000000000;;		// TODO: Currently we assume that in a given Cacher object, any <predicate> that is
0000000000000000000000000000000000000000;;		// passed here is aware of exactly the same trigger (at most one).
0000000000000000000000000000000000000000;;		// Thus, either 0 or 1 values will be returned.
0000000000000000000000000000000000000000;;		if matchValues := pred.MatcherIndex(); len(matchValues) > 0 {
0000000000000000000000000000000000000000;;			triggerValue, triggerSupported = matchValues[0].Value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there is triggerFunc defined, but triggerSupported is false,
0000000000000000000000000000000000000000;;		// we can't narrow the amount of events significantly at this point.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// That said, currently triggerFunc is defined only for Pods and Nodes,
0000000000000000000000000000000000000000;;		// and there is only constant number of watchers for which triggerSupported
0000000000000000000000000000000000000000;;		// is false (excluding those issues explicitly by users).
0000000000000000000000000000000000000000;;		// Thus, to reduce the risk of those watchers blocking all watchers of a
0000000000000000000000000000000000000000;;		// given resource in the system, we increase the sizes of buffers for them.
0000000000000000000000000000000000000000;;		chanSize := 10
0000000000000000000000000000000000000000;;		if c.triggerFunc != nil && !triggerSupported {
0000000000000000000000000000000000000000;;			// TODO: We should tune this value and ideally make it dependent on the
0000000000000000000000000000000000000000;;			// number of objects of a given type and/or their churn.
0000000000000000000000000000000000000000;;			chanSize = 1000
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		forget := forgetWatcher(c, c.watcherIdx, triggerValue, triggerSupported)
0000000000000000000000000000000000000000;;		watcher := newCacheWatcher(c.copier, watchRV, chanSize, initEvents, watchFilterFunction(key, pred), forget)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.watchers.addWatcher(watcher, c.watcherIdx, triggerValue, triggerSupported)
0000000000000000000000000000000000000000;;		c.watcherIdx++
0000000000000000000000000000000000000000;;		return watcher, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) WatchList(ctx context.Context, key string, resourceVersion string, pred SelectionPredicate) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return c.Watch(ctx, key, resourceVersion, pred)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) Get(ctx context.Context, key string, resourceVersion string, objPtr runtime.Object, ignoreNotFound bool) error {
0000000000000000000000000000000000000000;;		if resourceVersion == "" {
0000000000000000000000000000000000000000;;			// If resourceVersion is not specified, serve it from underlying
0000000000000000000000000000000000000000;;			// storage (for backward compatibility).
0000000000000000000000000000000000000000;;			return c.storage.Get(ctx, key, resourceVersion, objPtr, ignoreNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If resourceVersion is specified, serve it from cache.
0000000000000000000000000000000000000000;;		// It's guaranteed that the returned value is at least that
0000000000000000000000000000000000000000;;		// fresh as the given resourceVersion.
0000000000000000000000000000000000000000;;		getRV, err := ParseListResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not create a trace - it's not for free and there are tons
0000000000000000000000000000000000000000;;		// of Get requests. We can add it if it will be really needed.
0000000000000000000000000000000000000000;;		c.ready.wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objVal, err := conversion.EnforcePtr(objPtr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, exists, readResourceVersion, err := c.watchCache.WaitUntilFreshAndGet(getRV, key, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			elem, ok := obj.(*storeElement)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("non *storeElement returned from storage: %v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			objVal.Set(reflect.ValueOf(elem.Object).Elem())
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			objVal.Set(reflect.Zero(objVal.Type()))
0000000000000000000000000000000000000000;;			if !ignoreNotFound {
0000000000000000000000000000000000000000;;				return NewKeyNotFoundError(key, int64(readResourceVersion))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) GetToList(ctx context.Context, key string, resourceVersion string, pred SelectionPredicate, listObj runtime.Object) error {
0000000000000000000000000000000000000000;;		if resourceVersion == "" {
0000000000000000000000000000000000000000;;			// If resourceVersion is not specified, serve it from underlying
0000000000000000000000000000000000000000;;			// storage (for backward compatibility).
0000000000000000000000000000000000000000;;			return c.storage.GetToList(ctx, key, resourceVersion, pred, listObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If resourceVersion is specified, serve it from cache.
0000000000000000000000000000000000000000;;		// It's guaranteed that the returned value is at least that
0000000000000000000000000000000000000000;;		// fresh as the given resourceVersion.
0000000000000000000000000000000000000000;;		listRV, err := ParseListResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trace := utiltrace.New(fmt.Sprintf("cacher %v: List", c.objectType.String()))
0000000000000000000000000000000000000000;;		defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.ready.wait()
0000000000000000000000000000000000000000;;		trace.Step("Ready")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List elements with at least 'listRV' from cache.
0000000000000000000000000000000000000000;;		listPtr, err := meta.GetItemsPtr(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listVal, err := conversion.EnforcePtr(listPtr)
0000000000000000000000000000000000000000;;		if err != nil || listVal.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return fmt.Errorf("need a pointer to slice, got %v", listVal.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filter := filterFunction(key, pred)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, exists, readResourceVersion, err := c.watchCache.WaitUntilFreshAndGet(listRV, key, trace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step("Got from cache")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			elem, ok := obj.(*storeElement)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("non *storeElement returned from storage: %v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filter(elem.Key, elem.Object) {
0000000000000000000000000000000000000000;;				listVal.Set(reflect.Append(listVal, reflect.ValueOf(elem.Object).Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.versioner != nil {
0000000000000000000000000000000000000000;;			if err := c.versioner.UpdateList(listObj, readResourceVersion); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) List(ctx context.Context, key string, resourceVersion string, pred SelectionPredicate, listObj runtime.Object) error {
0000000000000000000000000000000000000000;;		if resourceVersion == "" {
0000000000000000000000000000000000000000;;			// If resourceVersion is not specified, serve it from underlying
0000000000000000000000000000000000000000;;			// storage (for backward compatibility).
0000000000000000000000000000000000000000;;			return c.storage.List(ctx, key, resourceVersion, pred, listObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If resourceVersion is specified, serve it from cache.
0000000000000000000000000000000000000000;;		// It's guaranteed that the returned value is at least that
0000000000000000000000000000000000000000;;		// fresh as the given resourceVersion.
0000000000000000000000000000000000000000;;		listRV, err := ParseListResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trace := utiltrace.New(fmt.Sprintf("cacher %v: List", c.objectType.String()))
0000000000000000000000000000000000000000;;		defer trace.LogIfLong(500 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.ready.wait()
0000000000000000000000000000000000000000;;		trace.Step("Ready")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List elements with at least 'listRV' from cache.
0000000000000000000000000000000000000000;;		listPtr, err := meta.GetItemsPtr(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listVal, err := conversion.EnforcePtr(listPtr)
0000000000000000000000000000000000000000;;		if err != nil || listVal.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return fmt.Errorf("need a pointer to slice, got %v", listVal.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filter := filterFunction(key, pred)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objs, readResourceVersion, err := c.watchCache.WaitUntilFreshAndList(listRV, trace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step(fmt.Sprintf("Listed %d items from cache", len(objs)))
0000000000000000000000000000000000000000;;		if len(objs) > listVal.Cap() && pred.Label.Empty() && pred.Field.Empty() {
0000000000000000000000000000000000000000;;			// Resize the slice appropriately, since we already know that none
0000000000000000000000000000000000000000;;			// of the elements will be filtered out.
0000000000000000000000000000000000000000;;			listVal.Set(reflect.MakeSlice(reflect.SliceOf(c.objectType.Elem()), 0, len(objs)))
0000000000000000000000000000000000000000;;			trace.Step("Resized result")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, obj := range objs {
0000000000000000000000000000000000000000;;			elem, ok := obj.(*storeElement)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("non *storeElement returned from storage: %v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filter(elem.Key, elem.Object) {
0000000000000000000000000000000000000000;;				listVal.Set(reflect.Append(listVal, reflect.ValueOf(elem.Object).Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step(fmt.Sprintf("Filtered %d items", listVal.Len()))
0000000000000000000000000000000000000000;;		if c.versioner != nil {
0000000000000000000000000000000000000000;;			if err := c.versioner.UpdateList(listObj, readResourceVersion); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (c *Cacher) GuaranteedUpdate(
0000000000000000000000000000000000000000;;		ctx context.Context, key string, ptrToType runtime.Object, ignoreNotFound bool,
0000000000000000000000000000000000000000;;		preconditions *Preconditions, tryUpdate UpdateFunc, _ ...runtime.Object) error {
0000000000000000000000000000000000000000;;		// Ignore the suggestion and try to pass down the current version of the object
0000000000000000000000000000000000000000;;		// read from cache.
0000000000000000000000000000000000000000;;		if elem, exists, err := c.watchCache.GetByKey(key); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("GetByKey returned error: %v", err)
0000000000000000000000000000000000000000;;		} else if exists {
0000000000000000000000000000000000000000;;			currObj, copyErr := c.copier.Copy(elem.(*storeElement).Object)
0000000000000000000000000000000000000000;;			if copyErr == nil {
0000000000000000000000000000000000000000;;				return c.storage.GuaranteedUpdate(ctx, key, ptrToType, ignoreNotFound, preconditions, tryUpdate, currObj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("couldn't copy object: %v", copyErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we couldn't get the object, fallback to no-suggestion.
0000000000000000000000000000000000000000;;		return c.storage.GuaranteedUpdate(ctx, key, ptrToType, ignoreNotFound, preconditions, tryUpdate)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) triggerValues(event *watchCacheEvent) ([]string, bool) {
0000000000000000000000000000000000000000;;		// TODO: Currently we assume that in a given Cacher object, its <c.triggerFunc>
0000000000000000000000000000000000000000;;		// is aware of exactly the same trigger (at most one). Thus calling:
0000000000000000000000000000000000000000;;		//   c.triggerFunc(<some object>)
0000000000000000000000000000000000000000;;		// can return only 0 or 1 values.
0000000000000000000000000000000000000000;;		// That means, that triggerValues itself may return up to 2 different values.
0000000000000000000000000000000000000000;;		if c.triggerFunc == nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make([]string, 0, 2)
0000000000000000000000000000000000000000;;		matchValues := c.triggerFunc(event.Object)
0000000000000000000000000000000000000000;;		if len(matchValues) > 0 {
0000000000000000000000000000000000000000;;			result = append(result, matchValues[0].Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if event.PrevObject == nil {
0000000000000000000000000000000000000000;;			return result, len(result) > 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prevMatchValues := c.triggerFunc(event.PrevObject)
0000000000000000000000000000000000000000;;		if len(prevMatchValues) > 0 {
0000000000000000000000000000000000000000;;			if len(result) == 0 || result[0] != prevMatchValues[0].Value {
0000000000000000000000000000000000000000;;				result = append(result, prevMatchValues[0].Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, len(result) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) processEvent(event *watchCacheEvent) {
0000000000000000000000000000000000000000;;		if curLen := int64(len(c.incoming)); c.incomingHWM.Update(curLen) {
0000000000000000000000000000000000000000;;			// Monitor if this gets backed up, and how much.
0000000000000000000000000000000000000000;;			glog.V(1).Infof("cacher (%v): %v objects queued in incoming channel.", c.objectType.String(), curLen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.incoming <- *event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) dispatchEvents() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, ok := <-c.incoming:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.dispatchEvent(&event)
0000000000000000000000000000000000000000;;			case <-c.stopCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) dispatchEvent(event *watchCacheEvent) {
0000000000000000000000000000000000000000;;		triggerValues, supported := c.triggerValues(event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		// Iterate over "allWatchers" no matter what the trigger function is.
0000000000000000000000000000000000000000;;		for _, watcher := range c.watchers.allWatchers {
0000000000000000000000000000000000000000;;			watcher.add(event, c.dispatchTimeoutBudget)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if supported {
0000000000000000000000000000000000000000;;			// Iterate over watchers interested in the given values of the trigger.
0000000000000000000000000000000000000000;;			for _, triggerValue := range triggerValues {
0000000000000000000000000000000000000000;;				for _, watcher := range c.watchers.valueWatchers[triggerValue] {
0000000000000000000000000000000000000000;;					watcher.add(event, c.dispatchTimeoutBudget)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// supported equal to false generally means that trigger function
0000000000000000000000000000000000000000;;			// is not defined (or not aware of any indexes). In this case,
0000000000000000000000000000000000000000;;			// watchers filters should generally also don't generate any
0000000000000000000000000000000000000000;;			// trigger values, but can cause problems in case of some
0000000000000000000000000000000000000000;;			// misconfiguration. Thus we paranoidly leave this branch.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Iterate over watchers interested in exact values for all values.
0000000000000000000000000000000000000000;;			for _, watchers := range c.watchers.valueWatchers {
0000000000000000000000000000000000000000;;				for _, watcher := range watchers {
0000000000000000000000000000000000000000;;					watcher.add(event, c.dispatchTimeoutBudget)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) terminateAllWatchers() {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		c.watchers.terminateAll(c.objectType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) isStopped() bool {
0000000000000000000000000000000000000000;;		c.stopLock.RLock()
0000000000000000000000000000000000000000;;		defer c.stopLock.RUnlock()
0000000000000000000000000000000000000000;;		return c.stopped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cacher) Stop() {
0000000000000000000000000000000000000000;;		c.stopLock.Lock()
0000000000000000000000000000000000000000;;		c.stopped = true
0000000000000000000000000000000000000000;;		c.stopLock.Unlock()
0000000000000000000000000000000000000000;;		close(c.stopCh)
0000000000000000000000000000000000000000;;		c.stopWg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func forgetWatcher(c *Cacher, index int, triggerValue string, triggerSupported bool) func(bool) {
0000000000000000000000000000000000000000;;		return func(lock bool) {
0000000000000000000000000000000000000000;;			if lock {
0000000000000000000000000000000000000000;;				c.Lock()
0000000000000000000000000000000000000000;;				defer c.Unlock()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// false is currently passed only if we are forcing watcher to close due
0000000000000000000000000000000000000000;;				// to its unresponsiveness and blocking other watchers.
0000000000000000000000000000000000000000;;				// TODO: Get this information in cleaner way.
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Forcing watcher close due to unresponsiveness: %v", c.objectType.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// It's possible that the watcher is already not in the structure (e.g. in case of
0000000000000000000000000000000000000000;;			// simulaneous Stop() and terminateAllWatchers(), but it doesn't break anything.
0000000000000000000000000000000000000000;;			c.watchers.deleteWatcher(index, triggerValue, triggerSupported)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filterFunction(key string, p SelectionPredicate) func(string, runtime.Object) bool {
0000000000000000000000000000000000000000;;		f := SimpleFilter(p)
0000000000000000000000000000000000000000;;		filterFunc := func(objKey string, obj runtime.Object) bool {
0000000000000000000000000000000000000000;;			if !hasPathPrefix(objKey, key) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return f(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filterFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func watchFilterFunction(key string, p SelectionPredicate) watchFilterFunc {
0000000000000000000000000000000000000000;;		filterFunc := func(objKey string, label labels.Set, field fields.Set, uninitialized bool) bool {
0000000000000000000000000000000000000000;;			if !hasPathPrefix(objKey, key) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.MatchesObjectAttributes(label, field, uninitialized)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filterFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns resource version to which the underlying cache is synced.
0000000000000000000000000000000000000000;;	func (c *Cacher) LastSyncResourceVersion() (uint64, error) {
0000000000000000000000000000000000000000;;		c.ready.wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceVersion := c.reflector.LastSyncResourceVersion()
0000000000000000000000000000000000000000;;		if resourceVersion == "" {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strconv.ParseUint(resourceVersion, 10, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cacherListerWatcher opaques storage.Interface to expose cache.ListerWatcher.
0000000000000000000000000000000000000000;;	type cacherListerWatcher struct {
0000000000000000000000000000000000000000;;		storage        Interface
0000000000000000000000000000000000000000;;		resourcePrefix string
0000000000000000000000000000000000000000;;		newListFunc    func() runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCacherListerWatcher(storage Interface, resourcePrefix string, newListFunc func() runtime.Object) cache.ListerWatcher {
0000000000000000000000000000000000000000;;		return &cacherListerWatcher{
0000000000000000000000000000000000000000;;			storage:        storage,
0000000000000000000000000000000000000000;;			resourcePrefix: resourcePrefix,
0000000000000000000000000000000000000000;;			newListFunc:    newListFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements cache.ListerWatcher interface.
0000000000000000000000000000000000000000;;	func (lw *cacherListerWatcher) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		list := lw.newListFunc()
0000000000000000000000000000000000000000;;		if err := lw.storage.List(context.TODO(), lw.resourcePrefix, "", Everything, list); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements cache.ListerWatcher interface.
0000000000000000000000000000000000000000;;	func (lw *cacherListerWatcher) Watch(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return lw.storage.WatchList(context.TODO(), lw.resourcePrefix, options.ResourceVersion, Everything)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cacherWatch implements watch.Interface to return a single error
0000000000000000000000000000000000000000;;	type errWatcher struct {
0000000000000000000000000000000000000000;;		result chan watch.Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newErrWatcher(err error) *errWatcher {
0000000000000000000000000000000000000000;;		// Create an error event
0000000000000000000000000000000000000000;;		errEvent := watch.Event{Type: watch.Error}
0000000000000000000000000000000000000000;;		switch err := err.(type) {
0000000000000000000000000000000000000000;;		case runtime.Object:
0000000000000000000000000000000000000000;;			errEvent.Object = err
0000000000000000000000000000000000000000;;		case *errors.StatusError:
0000000000000000000000000000000000000000;;			errEvent.Object = &err.ErrStatus
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			errEvent.Object = &metav1.Status{
0000000000000000000000000000000000000000;;				Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;				Message: err.Error(),
0000000000000000000000000000000000000000;;				Reason:  metav1.StatusReasonInternalError,
0000000000000000000000000000000000000000;;				Code:    http.StatusInternalServerError,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a watcher with room for a single event, populate it, and close the channel
0000000000000000000000000000000000000000;;		watcher := &errWatcher{result: make(chan watch.Event, 1)}
0000000000000000000000000000000000000000;;		watcher.result <- errEvent
0000000000000000000000000000000000000000;;		close(watcher.result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return watcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements watch.Interface.
0000000000000000000000000000000000000000;;	func (c *errWatcher) ResultChan() <-chan watch.Event {
0000000000000000000000000000000000000000;;		return c.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements watch.Interface.
0000000000000000000000000000000000000000;;	func (c *errWatcher) Stop() {
0000000000000000000000000000000000000000;;		// no-op
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cacherWatch implements watch.Interface
0000000000000000000000000000000000000000;;	type cacheWatcher struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		copier  runtime.ObjectCopier
0000000000000000000000000000000000000000;;		input   chan *watchCacheEvent
0000000000000000000000000000000000000000;;		result  chan watch.Event
0000000000000000000000000000000000000000;;		done    chan struct{}
0000000000000000000000000000000000000000;;		filter  watchFilterFunc
0000000000000000000000000000000000000000;;		stopped bool
0000000000000000000000000000000000000000;;		forget  func(bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCacheWatcher(copier runtime.ObjectCopier, resourceVersion uint64, chanSize int, initEvents []*watchCacheEvent, filter watchFilterFunc, forget func(bool)) *cacheWatcher {
0000000000000000000000000000000000000000;;		watcher := &cacheWatcher{
0000000000000000000000000000000000000000;;			copier:  copier,
0000000000000000000000000000000000000000;;			input:   make(chan *watchCacheEvent, chanSize),
0000000000000000000000000000000000000000;;			result:  make(chan watch.Event, chanSize),
0000000000000000000000000000000000000000;;			done:    make(chan struct{}),
0000000000000000000000000000000000000000;;			filter:  filter,
0000000000000000000000000000000000000000;;			stopped: false,
0000000000000000000000000000000000000000;;			forget:  forget,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go watcher.process(initEvents, resourceVersion)
0000000000000000000000000000000000000000;;		return watcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements watch.Interface.
0000000000000000000000000000000000000000;;	func (c *cacheWatcher) ResultChan() <-chan watch.Event {
0000000000000000000000000000000000000000;;		return c.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements watch.Interface.
0000000000000000000000000000000000000000;;	func (c *cacheWatcher) Stop() {
0000000000000000000000000000000000000000;;		c.forget(true)
0000000000000000000000000000000000000000;;		c.stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cacheWatcher) stop() {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		if !c.stopped {
0000000000000000000000000000000000000000;;			c.stopped = true
0000000000000000000000000000000000000000;;			close(c.done)
0000000000000000000000000000000000000000;;			close(c.input)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var timerPool sync.Pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cacheWatcher) add(event *watchCacheEvent, budget *timeBudget) {
0000000000000000000000000000000000000000;;		// Try to send the event immediately, without blocking.
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case c.input <- event:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OK, block sending, but only for up to <timeout>.
0000000000000000000000000000000000000000;;		// cacheWatcher.add is called very often, so arrange
0000000000000000000000000000000000000000;;		// to reuse timers instead of constantly allocating.
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		timeout := budget.takeAvailable()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, ok := timerPool.Get().(*time.Timer)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			t.Reset(timeout)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t = time.NewTimer(timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer timerPool.Put(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case c.input <- event:
0000000000000000000000000000000000000000;;			stopped := t.Stop()
0000000000000000000000000000000000000000;;			if !stopped {
0000000000000000000000000000000000000000;;				// Consume triggered (but not yet received) timer event
0000000000000000000000000000000000000000;;				// so that future reuse does not get a spurious timeout.
0000000000000000000000000000000000000000;;				<-t.C
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-t.C:
0000000000000000000000000000000000000000;;			// This means that we couldn't send event to that watcher.
0000000000000000000000000000000000000000;;			// Since we don't want to block on it infinitely,
0000000000000000000000000000000000000000;;			// we simply terminate it.
0000000000000000000000000000000000000000;;			c.forget(false)
0000000000000000000000000000000000000000;;			c.stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		budget.returnUnused(timeout - time.Since(startTime))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NOTE: sendWatchCacheEvent is assumed to not modify <event> !!!
0000000000000000000000000000000000000000;;	func (c *cacheWatcher) sendWatchCacheEvent(event *watchCacheEvent) {
0000000000000000000000000000000000000000;;		curObjPasses := event.Type != watch.Deleted && c.filter(event.Key, event.ObjLabels, event.ObjFields, event.ObjUninitialized)
0000000000000000000000000000000000000000;;		oldObjPasses := false
0000000000000000000000000000000000000000;;		if event.PrevObject != nil {
0000000000000000000000000000000000000000;;			oldObjPasses = c.filter(event.Key, event.PrevObjLabels, event.PrevObjFields, event.PrevObjUninitialized)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !curObjPasses && !oldObjPasses {
0000000000000000000000000000000000000000;;			// Watcher is not interested in that object.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var watchEvent watch.Event
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case curObjPasses && !oldObjPasses:
0000000000000000000000000000000000000000;;			object, err := c.copier.Copy(event.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("unexpected copy error: %v", err))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watchEvent = watch.Event{Type: watch.Added, Object: object}
0000000000000000000000000000000000000000;;		case curObjPasses && oldObjPasses:
0000000000000000000000000000000000000000;;			object, err := c.copier.Copy(event.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("unexpected copy error: %v", err))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watchEvent = watch.Event{Type: watch.Modified, Object: object}
0000000000000000000000000000000000000000;;		case !curObjPasses && oldObjPasses:
0000000000000000000000000000000000000000;;			object, err := c.copier.Copy(event.PrevObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("unexpected copy error: %v", err))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watchEvent = watch.Event{Type: watch.Deleted, Object: object}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need to ensure that if we put event X to the c.result, all
0000000000000000000000000000000000000000;;		// previous events were already put into it before, no matter whether
0000000000000000000000000000000000000000;;		// c.done is close or not.
0000000000000000000000000000000000000000;;		// Thus we cannot simply select from c.done and c.result and this
0000000000000000000000000000000000000000;;		// would give us non-determinism.
0000000000000000000000000000000000000000;;		// At the same time, we don't want to block infinitely on putting
0000000000000000000000000000000000000000;;		// to c.result, when c.done is already closed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This ensures that with c.done already close, we at most once go
0000000000000000000000000000000000000000;;		// into the next select after this. With that, no matter which
0000000000000000000000000000000000000000;;		// statement we choose there, we will deliver only consecutive
0000000000000000000000000000000000000000;;		// events.
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-c.done:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case c.result <- watchEvent:
0000000000000000000000000000000000000000;;		case <-c.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cacheWatcher) process(initEvents []*watchCacheEvent, resourceVersion uint64) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check how long we are processing initEvents.
0000000000000000000000000000000000000000;;		// As long as these are not processed, we are not processing
0000000000000000000000000000000000000000;;		// any incoming events, so if it takes long, we may actually
0000000000000000000000000000000000000000;;		// block all watchers for some time.
0000000000000000000000000000000000000000;;		// TODO: From the logs it seems that there happens processing
0000000000000000000000000000000000000000;;		// times even up to 1s which is very long. However, this doesn't
0000000000000000000000000000000000000000;;		// depend that much on the number of initEvents. E.g. from the
0000000000000000000000000000000000000000;;		// 2000-node Kubemark run we have logs like this, e.g.:
0000000000000000000000000000000000000000;;		// ... processing 13862 initEvents took 66.808689ms
0000000000000000000000000000000000000000;;		// ... processing 14040 initEvents took 993.532539ms
0000000000000000000000000000000000000000;;		// We should understand what is blocking us in those cases (e.g.
0000000000000000000000000000000000000000;;		// is it lack of CPU, network, or sth else) and potentially
0000000000000000000000000000000000000000;;		// consider increase size of result buffer in those cases.
0000000000000000000000000000000000000000;;		const initProcessThreshold = 500 * time.Millisecond
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		for _, event := range initEvents {
0000000000000000000000000000000000000000;;			c.sendWatchCacheEvent(event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		processingTime := time.Since(startTime)
0000000000000000000000000000000000000000;;		if processingTime > initProcessThreshold {
0000000000000000000000000000000000000000;;			objType := "<null>"
0000000000000000000000000000000000000000;;			if len(initEvents) > 0 {
0000000000000000000000000000000000000000;;				objType = reflect.TypeOf(initEvents[0].Object).String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("processing %d initEvents of %s took %v", len(initEvents), objType, processingTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer close(c.result)
0000000000000000000000000000000000000000;;		defer c.Stop()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event, ok := <-c.input
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// only send events newer than resourceVersion
0000000000000000000000000000000000000000;;			if event.ResourceVersion > resourceVersion {
0000000000000000000000000000000000000000;;				c.sendWatchCacheEvent(event)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ready struct {
0000000000000000000000000000000000000000;;		ok bool
0000000000000000000000000000000000000000;;		c  *sync.Cond
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReady() *ready {
0000000000000000000000000000000000000000;;		return &ready{c: sync.NewCond(&sync.Mutex{})}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ready) wait() {
0000000000000000000000000000000000000000;;		r.c.L.Lock()
0000000000000000000000000000000000000000;;		for !r.ok {
0000000000000000000000000000000000000000;;			r.c.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.c.L.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ready) set(ok bool) {
0000000000000000000000000000000000000000;;		r.c.L.Lock()
0000000000000000000000000000000000000000;;		defer r.c.L.Unlock()
0000000000000000000000000000000000000000;;		r.ok = ok
0000000000000000000000000000000000000000;;		r.c.Broadcast()
0000000000000000000000000000000000000000;;	}
