0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
830521d76096c8e1dbd3b82b6b968337e3734b24;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package secretbox
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		key1 = [32]byte{0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01}
0000000000000000000000000000000000000000;;		key2 = [32]byte{0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecretboxKeyRotation(t *testing.T) {
0000000000000000000000000000000000000000;;		testErr := fmt.Errorf("test error")
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(testErr,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewSecretboxTransformer(key1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewSecretboxTransformer(key2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		out, err := p.TransformToStorage([]byte("firstvalue"), context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !bytes.HasPrefix(out, []byte("first:")) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected prefix: %q", out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		from, stale, err := p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stale || !bytes.Equal([]byte("firstvalue"), from) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify changing the context does not fails storage
0000000000000000000000000000000000000000;;		// Secretbox is not currently an authenticating store
0000000000000000000000000000000000000000;;		from, stale, err = p.TransformFromStorage(out, value.DefaultContext([]byte("incorrect_context")))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("secretbox is not authenticated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reverse the order, use the second key
0000000000000000000000000000000000000000;;		p = value.NewPrefixTransformers(testErr,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewSecretboxTransformer(key2)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewSecretboxTransformer(key1)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		from, stale, err = p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stale || !bytes.Equal([]byte("firstvalue"), from) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkSecretboxRead_32_1024(b *testing.B)        { benchmarkSecretboxRead(b, 32, 1024, false) }
0000000000000000000000000000000000000000;;	func BenchmarkSecretboxRead_32_16384(b *testing.B)       { benchmarkSecretboxRead(b, 32, 16384, false) }
0000000000000000000000000000000000000000;;	func BenchmarkSecretboxRead_32_16384_Stale(b *testing.B) { benchmarkSecretboxRead(b, 32, 16384, true) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkSecretboxWrite_32_1024(b *testing.B)  { benchmarkSecretboxWrite(b, 32, 1024) }
0000000000000000000000000000000000000000;;	func BenchmarkSecretboxWrite_32_16384(b *testing.B) { benchmarkSecretboxWrite(b, 32, 16384) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkSecretboxRead(b *testing.B, keyLength int, valueLength int, stale bool) {
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewSecretboxTransformer(key1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewSecretboxTransformer(key2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;		v := bytes.Repeat([]byte("0123456789abcdef"), valueLength/16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := p.TransformToStorage(v, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// reverse the key order if stale
0000000000000000000000000000000000000000;;		if stale {
0000000000000000000000000000000000000000;;			p = value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;				value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewSecretboxTransformer(key1)},
0000000000000000000000000000000000000000;;				value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewSecretboxTransformer(key2)},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			from, stale, err := p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stale {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkSecretboxWrite(b *testing.B, keyLength int, valueLength int) {
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewSecretboxTransformer(key1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewSecretboxTransformer(key2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;		v := bytes.Repeat([]byte("0123456789abcdef"), valueLength/16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			_, err := p.TransformToStorage(v, context)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		lengths := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 128, 1024}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name    string
0000000000000000000000000000000000000000;;			context value.Context
0000000000000000000000000000000000000000;;			t       value.Transformer
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{name: "GCM 16 byte key", t: NewSecretboxTransformer(key1)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			t.Run(tt.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				context := tt.context
0000000000000000000000000000000000000000;;				if context == nil {
0000000000000000000000000000000000000000;;					context = value.DefaultContext("")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, l := range lengths {
0000000000000000000000000000000000000000;;					data := make([]byte, l)
0000000000000000000000000000000000000000;;					if _, err := io.ReadFull(rand.Reader, data); err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("unable to read sufficient random bytes: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					original := append([]byte{}, data...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ciphertext, err := tt.t.TransformToStorage(data, context)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("TransformToStorage error = %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					result, stale, err := tt.t.TransformFromStorage(ciphertext, context)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("TransformFromStorage error = %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if stale {
0000000000000000000000000000000000000000;;						t.Errorf("unexpected stale output")
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case l == 0:
0000000000000000000000000000000000000000;;						if len(result) != 0 {
0000000000000000000000000000000000000000;;							t.Errorf("Round trip failed len=%d\noriginal:\n%s\nresult:\n%s", l, hex.Dump(original), hex.Dump(result))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case !reflect.DeepEqual(original, result):
0000000000000000000000000000000000000000;;						t.Errorf("Round trip failed len=%d\noriginal:\n%s\nresult:\n%s", l, hex.Dump(original), hex.Dump(result))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
