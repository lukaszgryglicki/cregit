0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
63815de3fb513425e7e37709bc5ddfdf99e71e53;pkg/tools/etcd_util.go[pkg/tools/etcd_util.go][staging/src/k8s.io/apiserver/pkg/storage/etcd/util/etcd_util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcd "github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEtcdNotFound returns true if and only if err is an etcd not found error.
0000000000000000000000000000000000000000;;	func IsEtcdNotFound(err error) bool {
0000000000000000000000000000000000000000;;		return isEtcdErrorNum(err, etcd.ErrorCodeKeyNotFound)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEtcdNodeExist returns true if and only if err is an etcd node already exist error.
0000000000000000000000000000000000000000;;	func IsEtcdNodeExist(err error) bool {
0000000000000000000000000000000000000000;;		return isEtcdErrorNum(err, etcd.ErrorCodeNodeExist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEtcdTestFailed returns true if and only if err is an etcd write conflict.
0000000000000000000000000000000000000000;;	func IsEtcdTestFailed(err error) bool {
0000000000000000000000000000000000000000;;		return isEtcdErrorNum(err, etcd.ErrorCodeTestFailed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEtcdWatchExpired returns true if and only if err indicates the watch has expired.
0000000000000000000000000000000000000000;;	func IsEtcdWatchExpired(err error) bool {
0000000000000000000000000000000000000000;;		// NOTE: This seems weird why it wouldn't be etcd.ErrorCodeWatcherCleared
0000000000000000000000000000000000000000;;		//       I'm using the previous matching value
0000000000000000000000000000000000000000;;		return isEtcdErrorNum(err, etcd.ErrorCodeEventIndexCleared)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEtcdUnreachable returns true if and only if err indicates the server could not be reached.
0000000000000000000000000000000000000000;;	func IsEtcdUnreachable(err error) bool {
0000000000000000000000000000000000000000;;		// NOTE: The logic has changed previous error code no longer applies
0000000000000000000000000000000000000000;;		return err == etcd.ErrClusterUnavailable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isEtcdErrorNum returns true if and only if err is an etcd error, whose errorCode matches errorCode
0000000000000000000000000000000000000000;;	func isEtcdErrorNum(err error, errorCode int) bool {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if etcdError, ok := err.(etcd.Error); ok {
0000000000000000000000000000000000000000;;				return etcdError.Code == errorCode
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// NOTE: There are other error types returned
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetEtcdVersion performs a version check against the provided Etcd server,
0000000000000000000000000000000000000000;;	// returning the string response, and error (if any).
0000000000000000000000000000000000000000;;	func GetEtcdVersion(host string) (string, error) {
0000000000000000000000000000000000000000;;		response, err := http.Get(host + "/version")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer response.Body.Close()
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unsuccessful response from etcd server %q: %v", host, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionBytes, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(versionBytes), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type etcdHealth struct {
0000000000000000000000000000000000000000;;		// Note this has to be public so the json library can modify it.
0000000000000000000000000000000000000000;;		Health string `json:"health"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EtcdHealthCheck(data []byte) error {
0000000000000000000000000000000000000000;;		obj := etcdHealth{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj.Health != "true" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unhealthy status: %s", obj.Health)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
