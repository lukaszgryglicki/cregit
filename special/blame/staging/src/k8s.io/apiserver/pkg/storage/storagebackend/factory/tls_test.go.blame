0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ccb48b9c3baeb68baa0913c86a49c19231bcecf2;pkg/storage/storagebackend/factory/tls_test.go[pkg/storage/storagebackend/factory/tls_test.go][staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/tls_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package factory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/integration"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/transport"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd/testing/testingcert"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var scheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;	var codecs = serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, metav1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		example.AddToScheme(scheme)
0000000000000000000000000000000000000000;;		examplev1.AddToScheme(scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTLSConnection(t *testing.T) {
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certFile, keyFile, caFile := configureTLSCerts(t)
0000000000000000000000000000000000000000;;		defer os.RemoveAll(filepath.Dir(certFile))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsInfo := &transport.TLSInfo{
0000000000000000000000000000000000000000;;			CertFile: certFile,
0000000000000000000000000000000000000000;;			KeyFile:  keyFile,
0000000000000000000000000000000000000000;;			CAFile:   caFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{
0000000000000000000000000000000000000000;;			Size:      1,
0000000000000000000000000000000000000000;;			ClientTLS: tlsInfo,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := storagebackend.Config{
0000000000000000000000000000000000000000;;			Type:       storagebackend.StorageTypeETCD3,
0000000000000000000000000000000000000000;;			ServerList: []string{cluster.Members[0].GRPCAddr()},
0000000000000000000000000000000000000000;;			CertFile:   certFile,
0000000000000000000000000000000000000000;;			KeyFile:    keyFile,
0000000000000000000000000000000000000000;;			CAFile:     caFile,
0000000000000000000000000000000000000000;;			Codec:      codec,
0000000000000000000000000000000000000000;;			Copier:     scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storage, destroyFunc, err := newETCD3Storage(cfg)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = storage.Create(context.TODO(), "/abc", &example.Pod{}, nil, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Create failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func configureTLSCerts(t *testing.T) (certFile, keyFile, caFile string) {
0000000000000000000000000000000000000000;;		baseDir := os.TempDir()
0000000000000000000000000000000000000000;;		tempDir, err := ioutil.TempDir(baseDir, "etcd_certificates")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		certFile = path.Join(tempDir, "etcdcert.pem")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(certFile, []byte(testingcert.CertFileContent), 0644); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyFile = path.Join(tempDir, "etcdkey.pem")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(keyFile, []byte(testingcert.KeyFileContent), 0644); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		caFile = path.Join(tempDir, "ca.pem")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(caFile, []byte(testingcert.CAFileContent), 0644); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certFile, keyFile, caFile
0000000000000000000000000000000000000000;;	}
