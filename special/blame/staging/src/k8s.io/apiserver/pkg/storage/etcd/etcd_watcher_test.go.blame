0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
801b93d618fa326556100f349a845bfe50114ad4;pkg/tools/etcd_tools_watch_test.go[pkg/tools/etcd_tools_watch_test.go][staging/src/k8s.io/apiserver/pkg/storage/etcd/etcd_watcher_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		rt "runtime"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd/etcdtest"
0000000000000000000000000000000000000000;;		etcdtesting "k8s.io/apiserver/pkg/storage/etcd/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcd "github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var versioner = APIObjectVersioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements etcdCache interface as empty methods (i.e. does not cache any objects)
0000000000000000000000000000000000000000;;	type fakeEtcdCache struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeEtcdCache) getFromCache(index uint64, filter storage.FilterFunc) (runtime.Object, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeEtcdCache) addToCache(index uint64, obj runtime.Object) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ etcdCache = &fakeEtcdCache{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchInterpretations(t *testing.T) {
0000000000000000000000000000000000000000;;		_, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		// Declare some pods to make the test cases compact.
0000000000000000000000000000000000000000;;		podFoo := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		podBar := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}
0000000000000000000000000000000000000000;;		podBaz := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "baz"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All of these test cases will be run with the firstLetterIsB Filter.
0000000000000000000000000000000000000000;;		table := map[string]struct {
0000000000000000000000000000000000000000;;			actions       []string // Run this test item for every action here.
0000000000000000000000000000000000000000;;			prevNodeValue string
0000000000000000000000000000000000000000;;			nodeValue     string
0000000000000000000000000000000000000000;;			expectEmit    bool
0000000000000000000000000000000000000000;;			expectType    watch.EventType
0000000000000000000000000000000000000000;;			expectObject  runtime.Object
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"create": {
0000000000000000000000000000000000000000;;				actions:      []string{"create", "get"},
0000000000000000000000000000000000000000;;				nodeValue:    runtime.EncodeOrDie(codec, podBar),
0000000000000000000000000000000000000000;;				expectEmit:   true,
0000000000000000000000000000000000000000;;				expectType:   watch.Added,
0000000000000000000000000000000000000000;;				expectObject: podBar,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"create but filter blocks": {
0000000000000000000000000000000000000000;;				actions:    []string{"create", "get"},
0000000000000000000000000000000000000000;;				nodeValue:  runtime.EncodeOrDie(codec, podFoo),
0000000000000000000000000000000000000000;;				expectEmit: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"delete": {
0000000000000000000000000000000000000000;;				actions:       []string{"delete"},
0000000000000000000000000000000000000000;;				prevNodeValue: runtime.EncodeOrDie(codec, podBar),
0000000000000000000000000000000000000000;;				expectEmit:    true,
0000000000000000000000000000000000000000;;				expectType:    watch.Deleted,
0000000000000000000000000000000000000000;;				expectObject:  podBar,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"delete but filter blocks": {
0000000000000000000000000000000000000000;;				actions:    []string{"delete"},
0000000000000000000000000000000000000000;;				nodeValue:  runtime.EncodeOrDie(codec, podFoo),
0000000000000000000000000000000000000000;;				expectEmit: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"modify appears to create 1": {
0000000000000000000000000000000000000000;;				actions:      []string{"set", "compareAndSwap"},
0000000000000000000000000000000000000000;;				nodeValue:    runtime.EncodeOrDie(codec, podBar),
0000000000000000000000000000000000000000;;				expectEmit:   true,
0000000000000000000000000000000000000000;;				expectType:   watch.Added,
0000000000000000000000000000000000000000;;				expectObject: podBar,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"modify appears to create 2": {
0000000000000000000000000000000000000000;;				actions:       []string{"set", "compareAndSwap"},
0000000000000000000000000000000000000000;;				prevNodeValue: runtime.EncodeOrDie(codec, podFoo),
0000000000000000000000000000000000000000;;				nodeValue:     runtime.EncodeOrDie(codec, podBar),
0000000000000000000000000000000000000000;;				expectEmit:    true,
0000000000000000000000000000000000000000;;				expectType:    watch.Added,
0000000000000000000000000000000000000000;;				expectObject:  podBar,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"modify appears to delete": {
0000000000000000000000000000000000000000;;				actions:       []string{"set", "compareAndSwap"},
0000000000000000000000000000000000000000;;				prevNodeValue: runtime.EncodeOrDie(codec, podBar),
0000000000000000000000000000000000000000;;				nodeValue:     runtime.EncodeOrDie(codec, podFoo),
0000000000000000000000000000000000000000;;				expectEmit:    true,
0000000000000000000000000000000000000000;;				expectType:    watch.Deleted,
0000000000000000000000000000000000000000;;				expectObject:  podBar, // Should return last state that passed the filter!
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"modify modifies": {
0000000000000000000000000000000000000000;;				actions:       []string{"set", "compareAndSwap"},
0000000000000000000000000000000000000000;;				prevNodeValue: runtime.EncodeOrDie(codec, podBar),
0000000000000000000000000000000000000000;;				nodeValue:     runtime.EncodeOrDie(codec, podBaz),
0000000000000000000000000000000000000000;;				expectEmit:    true,
0000000000000000000000000000000000000000;;				expectType:    watch.Modified,
0000000000000000000000000000000000000000;;				expectObject:  podBaz,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"modify ignores": {
0000000000000000000000000000000000000000;;				actions:    []string{"set", "compareAndSwap"},
0000000000000000000000000000000000000000;;				nodeValue:  runtime.EncodeOrDie(codec, podFoo),
0000000000000000000000000000000000000000;;				expectEmit: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		firstLetterIsB := func(obj runtime.Object) bool {
0000000000000000000000000000000000000000;;			return obj.(*example.Pod).Name[0] == 'b'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, item := range table {
0000000000000000000000000000000000000000;;			for _, action := range item.actions {
0000000000000000000000000000000000000000;;				w := newEtcdWatcher(true, false, nil, firstLetterIsB, codec, versioner, nil, prefixTransformer{prefix: "test!"}, &fakeEtcdCache{})
0000000000000000000000000000000000000000;;				emitCalled := false
0000000000000000000000000000000000000000;;				w.emit = func(event watch.Event) {
0000000000000000000000000000000000000000;;					emitCalled = true
0000000000000000000000000000000000000000;;					if !item.expectEmit {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := item.expectType, event.Type; e != a {
0000000000000000000000000000000000000000;;						t.Errorf("'%v - %v': expected %v, got %v", name, action, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := item.expectObject, event.Object; !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;						t.Errorf("'%v - %v': expected %v, got %v", name, action, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var n, pn *etcd.Node
0000000000000000000000000000000000000000;;				if item.nodeValue != "" {
0000000000000000000000000000000000000000;;					n = &etcd.Node{Value: defaultPrefix(item.nodeValue)}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if item.prevNodeValue != "" {
0000000000000000000000000000000000000000;;					pn = &etcd.Node{Value: defaultPrefix(item.prevNodeValue)}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				w.sendResult(&etcd.Response{
0000000000000000000000000000000000000000;;					Action:   action,
0000000000000000000000000000000000000000;;					Node:     n,
0000000000000000000000000000000000000000;;					PrevNode: pn,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := item.expectEmit, emitCalled; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("'%v - %v': expected %v, got %v", name, action, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchInterpretation_ResponseNotSet(t *testing.T) {
0000000000000000000000000000000000000000;;		_, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := codecs.LegacyCodec(schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;		w := newEtcdWatcher(false, false, nil, storage.SimpleFilter(storage.Everything), codec, versioner, nil, prefixTransformer{prefix: "test!"}, &fakeEtcdCache{})
0000000000000000000000000000000000000000;;		w.emit = func(e watch.Event) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected emit: %v", e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.sendResult(&etcd.Response{
0000000000000000000000000000000000000000;;			Action: "update",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		w.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchInterpretation_ResponseNoNode(t *testing.T) {
0000000000000000000000000000000000000000;;		_, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := codecs.LegacyCodec(schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;		actions := []string{"create", "set", "compareAndSwap", "delete"}
0000000000000000000000000000000000000000;;		for _, action := range actions {
0000000000000000000000000000000000000000;;			w := newEtcdWatcher(false, false, nil, storage.SimpleFilter(storage.Everything), codec, versioner, nil, prefixTransformer{prefix: "test!"}, &fakeEtcdCache{})
0000000000000000000000000000000000000000;;			w.emit = func(e watch.Event) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected emit: %v", e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.sendResult(&etcd.Response{
0000000000000000000000000000000000000000;;				Action: action,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			w.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchInterpretation_ResponseBadData(t *testing.T) {
0000000000000000000000000000000000000000;;		_, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := codecs.LegacyCodec(schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;		actions := []string{"create", "set", "compareAndSwap", "delete"}
0000000000000000000000000000000000000000;;		for _, action := range actions {
0000000000000000000000000000000000000000;;			w := newEtcdWatcher(false, false, nil, storage.SimpleFilter(storage.Everything), codec, versioner, nil, prefixTransformer{prefix: "test!"}, &fakeEtcdCache{})
0000000000000000000000000000000000000000;;			w.emit = func(e watch.Event) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected emit: %v", e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.sendResult(&etcd.Response{
0000000000000000000000000000000000000000;;				Action: action,
0000000000000000000000000000000000000000;;				Node: &etcd.Node{
0000000000000000000000000000000000000000;;					Value: defaultPrefix("foobar"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			w.sendResult(&etcd.Response{
0000000000000000000000000000000000000000;;				Action: action,
0000000000000000000000000000000000000000;;				PrevNode: &etcd.Node{
0000000000000000000000000000000000000000;;					Value: defaultPrefix("foobar"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			w.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSendResultDeleteEventHaveLatestIndex(t *testing.T) {
0000000000000000000000000000000000000000;;		_, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		filter := func(obj runtime.Object) bool {
0000000000000000000000000000000000000000;;			return obj.(*example.Pod).Name != "bar"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w := newEtcdWatcher(false, false, nil, filter, codec, versioner, nil, prefixTransformer{prefix: "test!"}, &fakeEtcdCache{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventChan := make(chan watch.Event, 1)
0000000000000000000000000000000000000000;;		w.emit = func(e watch.Event) {
0000000000000000000000000000000000000000;;			eventChan <- e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fooPod := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		barPod := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}
0000000000000000000000000000000000000000;;		fooBytes, err := runtime.Encode(codec, fooPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Encode failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		barBytes, err := runtime.Encode(codec, barPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Encode failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			response *etcd.Response
0000000000000000000000000000000000000000;;			expRV    string
0000000000000000000000000000000000000000;;		}{{ // Delete event
0000000000000000000000000000000000000000;;			response: &etcd.Response{
0000000000000000000000000000000000000000;;				Action: EtcdDelete,
0000000000000000000000000000000000000000;;				Node: &etcd.Node{
0000000000000000000000000000000000000000;;					ModifiedIndex: 2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PrevNode: &etcd.Node{
0000000000000000000000000000000000000000;;					Value:         defaultPrefixValue(fooBytes),
0000000000000000000000000000000000000000;;					ModifiedIndex: 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expRV: "2",
0000000000000000000000000000000000000000;;		}, { // Modify event with uninterested data
0000000000000000000000000000000000000000;;			response: &etcd.Response{
0000000000000000000000000000000000000000;;				Action: EtcdSet,
0000000000000000000000000000000000000000;;				Node: &etcd.Node{
0000000000000000000000000000000000000000;;					Value:         defaultPrefixValue(barBytes),
0000000000000000000000000000000000000000;;					ModifiedIndex: 2,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PrevNode: &etcd.Node{
0000000000000000000000000000000000000000;;					Value:         defaultPrefixValue(fooBytes),
0000000000000000000000000000000000000000;;					ModifiedIndex: 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			expRV: "2",
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			w.sendResult(tt.response)
0000000000000000000000000000000000000000;;			ev := <-eventChan
0000000000000000000000000000000000000000;;			if ev.Type != watch.Deleted {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: event type want=Deleted, get=%s", i, ev.Type)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rv := ev.Object.(*example.Pod).ResourceVersion
0000000000000000000000000000000000000000;;			if rv != tt.expRV {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: resource version want=%s, get=%s", i, tt.expRV, rv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		scheme, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		server := etcdtesting.NewEtcdTestClientServer(t)
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		key := "/some/key"
0000000000000000000000000000000000000000;;		h := newEtcdHelper(server.Client, scheme, codec, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watching, err := h.Watch(context.TODO(), key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// watching is explicitly closed below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test normal case
0000000000000000000000000000000000000000;;		pod := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		returnObj := &example.Pod{}
0000000000000000000000000000000000000000;;		err = h.Create(context.TODO(), key, pod, returnObj, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event := <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if e, a := watch.Added, event.Type; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := pod, event.Object; !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watching.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There is a race in etcdWatcher so that after calling Stop() one of
0000000000000000000000000000000000000000;;		// two things can happen:
0000000000000000000000000000000000000000;;		// - ResultChan() may be closed (triggered by closing userStop channel)
0000000000000000000000000000000000000000;;		// - an Error "context cancelled" may be emitted (triggered by cancelling request
0000000000000000000000000000000000000000;;		//   to etcd and putting that error to etcdError channel)
0000000000000000000000000000000000000000;;		// We need to be prepared for both here.
0000000000000000000000000000000000000000;;		event, open := <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if open && event.Type != watch.Error {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event from stopped watcher: %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchEtcdState(t *testing.T) {
0000000000000000000000000000000000000000;;		scheme, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		key := "/somekey/foo"
0000000000000000000000000000000000000000;;		server := etcdtesting.NewEtcdTestClientServer(t)
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := newEtcdHelper(server.Client, scheme, codec, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;		watching, err := h.Watch(context.TODO(), key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watching.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = h.Create(context.TODO(), key, pod, pod, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event := <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if event.Type != watch.Added {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.ResourceVersion = ""
0000000000000000000000000000000000000000;;		pod.Status = example.PodStatus{
0000000000000000000000000000000000000000;;			Phase: example.PodPhase("Running"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CAS the previous value
0000000000000000000000000000000000000000;;		updateFn := func(input runtime.Object, res storage.ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;			newObj, err := scheme.DeepCopy(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newObj.(*example.Pod), nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = h.GuaranteedUpdate(context.TODO(), key, &example.Pod{}, false, nil, updateFn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event = <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if event.Type != watch.Modified {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := pod, event.Object; !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchFromZeroIndex(t *testing.T) {
0000000000000000000000000000000000000000;;		scheme, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		pod := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := "/somekey/foo"
0000000000000000000000000000000000000000;;		server := etcdtesting.NewEtcdTestClientServer(t)
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := newEtcdHelper(server.Client, scheme, codec, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set before the watch and verify events
0000000000000000000000000000000000000000;;		err := h.Create(context.TODO(), key, pod, pod, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.ResourceVersion = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watching, err := h.Watch(context.TODO(), key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The create trigger ADDED event when watching from 0
0000000000000000000000000000000000000000;;		event := <-watching.ResultChan()
0000000000000000000000000000000000000000;;		watching.Stop()
0000000000000000000000000000000000000000;;		if event.Type != watch.Added {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for concatenation on watch event with CAS
0000000000000000000000000000000000000000;;		updateFn := func(input runtime.Object, res storage.ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;			pod := input.(*example.Pod)
0000000000000000000000000000000000000000;;			pod.Name = "bar"
0000000000000000000000000000000000000000;;			return pod, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = h.GuaranteedUpdate(context.TODO(), key, &example.Pod{}, false, nil, updateFn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watching, err = h.Watch(context.TODO(), key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watching.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// because we watch from 0, first event that we receive will always be ADDED
0000000000000000000000000000000000000000;;		event = <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if event.Type != watch.Added {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Name = "baz"
0000000000000000000000000000000000000000;;		updateFn = func(input runtime.Object, res storage.ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;			pod := input.(*example.Pod)
0000000000000000000000000000000000000000;;			pod.Name = "baz"
0000000000000000000000000000000000000000;;			return pod, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = h.GuaranteedUpdate(context.TODO(), key, &example.Pod{}, false, nil, updateFn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event = <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if event.Type != watch.Modified {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := pod, event.Object; a == nil || !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchListFromZeroIndex(t *testing.T) {
0000000000000000000000000000000000000000;;		scheme, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		prefix := "/some/key"
0000000000000000000000000000000000000000;;		server := etcdtesting.NewEtcdTestClientServer(t)
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		h := newEtcdHelper(server.Client, scheme, codec, prefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watching, err := h.WatchList(context.TODO(), "/", "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watching.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// creates foo which should trigger the WatchList for "/"
0000000000000000000000000000000000000000;;		pod := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		err = h.Create(context.TODO(), pod.Name, pod, pod, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event, _ := <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if event.Type != watch.Added {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := pod, event.Object; !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchListIgnoresRootKey(t *testing.T) {
0000000000000000000000000000000000000000;;		scheme, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		pod := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		key := "/some/key"
0000000000000000000000000000000000000000;;		server := etcdtesting.NewEtcdTestClientServer(t)
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		h := newEtcdHelper(server.Client, scheme, codec, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watching, err := h.WatchList(context.TODO(), key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watching.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// creates key/foo which should trigger the WatchList for "key"
0000000000000000000000000000000000000000;;		err = h.Create(context.TODO(), key, pod, pod, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// force context switch to ensure watches would catch and notify.
0000000000000000000000000000000000000000;;		rt.Gosched()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case event, _ := <-watching.ResultChan():
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected event: %#v", event)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// fall through, expected behavior
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchPurposefulShutdown(t *testing.T) {
0000000000000000000000000000000000000000;;		scheme, codecs := testScheme(t)
0000000000000000000000000000000000000000;;		codec := codecs.LegacyCodec(schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;		server := etcdtesting.NewEtcdTestClientServer(t)
0000000000000000000000000000000000000000;;		defer server.Terminate(t)
0000000000000000000000000000000000000000;;		key := "/some/key"
0000000000000000000000000000000000000000;;		h := newEtcdHelper(server.Client, scheme, codec, etcdtest.PathPrefix())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test purposeful shutdown
0000000000000000000000000000000000000000;;		watching, err := h.Watch(context.TODO(), key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watching.Stop()
0000000000000000000000000000000000000000;;		rt.Gosched()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There is a race in etcdWatcher so that after calling Stop() one of
0000000000000000000000000000000000000000;;		// two things can happen:
0000000000000000000000000000000000000000;;		// - ResultChan() may be closed (triggered by closing userStop channel)
0000000000000000000000000000000000000000;;		// - an Error "context cancelled" may be emitted (triggered by cancelling request
0000000000000000000000000000000000000000;;		//   to etcd and putting that error to etcdError channel)
0000000000000000000000000000000000000000;;		// We need to be prepared for both here.
0000000000000000000000000000000000000000;;		event, open := <-watching.ResultChan()
0000000000000000000000000000000000000000;;		if open && event.Type != watch.Error {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected event from stopped watcher: %#v", event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
