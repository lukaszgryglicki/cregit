0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
5da2dc0a37bcde203fffb0bed5ffadf7c76f0631;pkg/util/etcd_tools.go[pkg/util/etcd_tools.go][staging/src/k8s.io/apiserver/pkg/storage/etcd/etcd_helper.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcd "github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilcache "k8s.io/apimachinery/pkg/util/cache"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd/metrics"
0000000000000000000000000000000000000000;;		etcdutil "k8s.io/apiserver/pkg/storage/etcd/util"
0000000000000000000000000000000000000000;;		utiltrace "k8s.io/apiserver/pkg/util/trace"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValueTransformer allows a string value to be transformed before being read from or written to the underlying store. The methods
0000000000000000000000000000000000000000;;	// must be able to undo the transformation caused by the other.
0000000000000000000000000000000000000000;;	type ValueTransformer interface {
0000000000000000000000000000000000000000;;		// TransformStringFromStorage may transform the provided string from its underlying storage representation or return an error.
0000000000000000000000000000000000000000;;		// Stale is true if the object on disk is stale and a write to etcd should be issued, even if the contents of the object
0000000000000000000000000000000000000000;;		// have not changed.
0000000000000000000000000000000000000000;;		TransformStringFromStorage(string) (value string, stale bool, err error)
0000000000000000000000000000000000000000;;		// TransformStringToStorage may transform the provided string into the appropriate form in storage or return an error.
0000000000000000000000000000000000000000;;		TransformStringToStorage(string) (value string, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type identityTransformer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (identityTransformer) TransformStringFromStorage(s string) (string, bool, error) {
0000000000000000000000000000000000000000;;		return s, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (identityTransformer) TransformStringToStorage(s string) (string, error) { return s, nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IdentityTransformer performs no transformation on the provided values.
0000000000000000000000000000000000000000;;	var IdentityTransformer ValueTransformer = identityTransformer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a new storage interface from the client
0000000000000000000000000000000000000000;;	// TODO: deprecate in favor of storage.Config abstraction over time
0000000000000000000000000000000000000000;;	func NewEtcdStorage(client etcd.Client, codec runtime.Codec, prefix string, quorum bool, cacheSize int, copier runtime.ObjectCopier, transformer ValueTransformer) storage.Interface {
0000000000000000000000000000000000000000;;		return &etcdHelper{
0000000000000000000000000000000000000000;;			etcdMembersAPI: etcd.NewMembersAPI(client),
0000000000000000000000000000000000000000;;			etcdKeysAPI:    etcd.NewKeysAPI(client),
0000000000000000000000000000000000000000;;			codec:          codec,
0000000000000000000000000000000000000000;;			versioner:      APIObjectVersioner{},
0000000000000000000000000000000000000000;;			copier:         copier,
0000000000000000000000000000000000000000;;			transformer:    transformer,
0000000000000000000000000000000000000000;;			pathPrefix:     path.Join("/", prefix),
0000000000000000000000000000000000000000;;			quorum:         quorum,
0000000000000000000000000000000000000000;;			cache:          utilcache.NewCache(cacheSize),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// etcdHelper is the reference implementation of storage.Interface.
0000000000000000000000000000000000000000;;	type etcdHelper struct {
0000000000000000000000000000000000000000;;		etcdMembersAPI etcd.MembersAPI
0000000000000000000000000000000000000000;;		etcdKeysAPI    etcd.KeysAPI
0000000000000000000000000000000000000000;;		codec          runtime.Codec
0000000000000000000000000000000000000000;;		copier         runtime.ObjectCopier
0000000000000000000000000000000000000000;;		transformer    ValueTransformer
0000000000000000000000000000000000000000;;		// Note that versioner is required for etcdHelper to work correctly.
0000000000000000000000000000000000000000;;		// The public constructors (NewStorage & NewEtcdStorage) are setting it
0000000000000000000000000000000000000000;;		// correctly, so be careful when manipulating with it manually.
0000000000000000000000000000000000000000;;		// optional, has to be set to perform any atomic operations
0000000000000000000000000000000000000000;;		versioner storage.Versioner
0000000000000000000000000000000000000000;;		// prefix for all etcd keys
0000000000000000000000000000000000000000;;		pathPrefix string
0000000000000000000000000000000000000000;;		// if true,  perform quorum read
0000000000000000000000000000000000000000;;		quorum bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We cache objects stored in etcd. For keys we use Node.ModifiedIndex which is equivalent
0000000000000000000000000000000000000000;;		// to resourceVersion.
0000000000000000000000000000000000000000;;		// This depends on etcd's indexes being globally unique across all objects/types. This will
0000000000000000000000000000000000000000;;		// have to revisited if we decide to do things like multiple etcd clusters, or etcd will
0000000000000000000000000000000000000000;;		// support multi-object transaction that will result in many objects with the same index.
0000000000000000000000000000000000000000;;		// Number of entries stored in the cache is controlled by maxEtcdCacheEntries constant.
0000000000000000000000000000000000000000;;		// TODO: Measure how much this cache helps after the conversion code is optimized.
0000000000000000000000000000000000000000;;		cache utilcache.Cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		metrics.Register()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) Versioner() storage.Versioner {
0000000000000000000000000000000000000000;;		return h.versioner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) Create(ctx context.Context, key string, obj, out runtime.Object, ttl uint64) error {
0000000000000000000000000000000000000000;;		trace := utiltrace.New("etcdHelper::Create " + getTypeName(obj))
0000000000000000000000000000000000000000;;		defer trace.LogIfLong(250 * time.Millisecond)
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(h.codec, obj)
0000000000000000000000000000000000000000;;		trace.Step("Object encoded")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version, err := h.versioner.ObjectResourceVersion(obj); err == nil && version != 0 {
0000000000000000000000000000000000000000;;			return errors.New("resourceVersion may not be set on objects to be created")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := h.versioner.PrepareObjectForStorage(obj); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("PrepareObjectForStorage returned an error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step("Version checked")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		opts := etcd.SetOptions{
0000000000000000000000000000000000000000;;			TTL:       time.Duration(ttl) * time.Second,
0000000000000000000000000000000000000000;;			PrevExist: etcd.PrevNoExist,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newBody, err := h.transformer.TransformStringToStorage(string(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := h.etcdKeysAPI.Set(ctx, key, newBody, &opts)
0000000000000000000000000000000000000000;;		trace.Step("Object created")
0000000000000000000000000000000000000000;;		metrics.RecordEtcdRequestLatency("create", getTypeName(obj), startTime)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out != nil {
0000000000000000000000000000000000000000;;			if _, err := conversion.EnforcePtr(out); err != nil {
0000000000000000000000000000000000000000;;				panic("unable to convert output object to pointer")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, _, _, err = h.extractObj(response, err, out, false, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkPreconditions(key string, preconditions *storage.Preconditions, out runtime.Object) error {
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objMeta, err := meta.Accessor(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return storage.NewInternalErrorf("can't enforce preconditions %v on un-introspectable object %v, got error: %v", *preconditions, out, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if preconditions.UID != nil && *preconditions.UID != objMeta.GetUID() {
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("Precondition failed: UID in precondition: %v, UID in object meta: %v", preconditions.UID, objMeta.GetUID())
0000000000000000000000000000000000000000;;			return storage.NewInvalidObjError(key, errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) Delete(ctx context.Context, key string, out runtime.Object, preconditions *storage.Preconditions) error {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("unable to convert output object to pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if preconditions == nil {
0000000000000000000000000000000000000000;;			startTime := time.Now()
0000000000000000000000000000000000000000;;			response, err := h.etcdKeysAPI.Delete(ctx, key, nil)
0000000000000000000000000000000000000000;;			metrics.RecordEtcdRequestLatency("delete", getTypeName(out), startTime)
0000000000000000000000000000000000000000;;			if !etcdutil.IsEtcdNotFound(err) {
0000000000000000000000000000000000000000;;				// if the object that existed prior to the delete is returned by etcd, update the out object.
0000000000000000000000000000000000000000;;				if err != nil || response.PrevNode != nil {
0000000000000000000000000000000000000000;;					_, _, _, err = h.extractObj(response, err, out, false, true)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the preconditions match.
0000000000000000000000000000000000000000;;		obj := reflect.New(v.Type()).Interface().(runtime.Object)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			_, node, res, _, err := h.bodyAndExtractObj(ctx, key, obj, false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := checkPreconditions(key, preconditions, obj); err != nil {
0000000000000000000000000000000000000000;;				return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			index := uint64(0)
0000000000000000000000000000000000000000;;			if node != nil {
0000000000000000000000000000000000000000;;				index = node.ModifiedIndex
0000000000000000000000000000000000000000;;			} else if res != nil {
0000000000000000000000000000000000000000;;				index = res.Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			opt := etcd.DeleteOptions{PrevIndex: index}
0000000000000000000000000000000000000000;;			startTime := time.Now()
0000000000000000000000000000000000000000;;			response, err := h.etcdKeysAPI.Delete(ctx, key, &opt)
0000000000000000000000000000000000000000;;			metrics.RecordEtcdRequestLatency("delete", getTypeName(out), startTime)
0000000000000000000000000000000000000000;;			if !etcdutil.IsEtcdTestFailed(err) {
0000000000000000000000000000000000000000;;				if !etcdutil.IsEtcdNotFound(err) {
0000000000000000000000000000000000000000;;					// if the object that existed prior to the delete is returned by etcd, update the out object.
0000000000000000000000000000000000000000;;					if err != nil || response.PrevNode != nil {
0000000000000000000000000000000000000000;;						_, _, _, err = h.extractObj(response, err, out, false, true)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("deletion of %s failed because of a conflict, going to retry", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) Watch(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		watchRV, err := storage.ParseWatchResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		w := newEtcdWatcher(false, h.quorum, nil, storage.SimpleFilter(pred), h.codec, h.versioner, nil, h.transformer, h)
0000000000000000000000000000000000000000;;		go w.etcdWatch(ctx, h.etcdKeysAPI, key, watchRV)
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) WatchList(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		watchRV, err := storage.ParseWatchResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		w := newEtcdWatcher(true, h.quorum, exceptKey(key), storage.SimpleFilter(pred), h.codec, h.versioner, nil, h.transformer, h)
0000000000000000000000000000000000000000;;		go w.etcdWatch(ctx, h.etcdKeysAPI, key, watchRV)
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) Get(ctx context.Context, key string, resourceVersion string, objPtr runtime.Object, ignoreNotFound bool) error {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		_, _, _, _, err := h.bodyAndExtractObj(ctx, key, objPtr, ignoreNotFound)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bodyAndExtractObj performs the normal Get path to etcd, returning the parsed node and response for additional information
0000000000000000000000000000000000000000;;	// about the response, like the current etcd index and the ttl.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) bodyAndExtractObj(ctx context.Context, key string, objPtr runtime.Object, ignoreNotFound bool) (body string, node *etcd.Node, res *etcd.Response, stale bool, err error) {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := &etcd.GetOptions{
0000000000000000000000000000000000000000;;			Quorum: h.quorum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := h.etcdKeysAPI.Get(ctx, key, opts)
0000000000000000000000000000000000000000;;		metrics.RecordEtcdRequestLatency("get", getTypeName(objPtr), startTime)
0000000000000000000000000000000000000000;;		if err != nil && !etcdutil.IsEtcdNotFound(err) {
0000000000000000000000000000000000000000;;			return "", nil, nil, false, toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, node, stale, err = h.extractObj(response, err, objPtr, ignoreNotFound, false)
0000000000000000000000000000000000000000;;		return body, node, response, stale, toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *etcdHelper) extractObj(response *etcd.Response, inErr error, objPtr runtime.Object, ignoreNotFound, prevNode bool) (body string, node *etcd.Node, stale bool, err error) {
0000000000000000000000000000000000000000;;		if response != nil {
0000000000000000000000000000000000000000;;			if prevNode {
0000000000000000000000000000000000000000;;				node = response.PrevNode
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				node = response.Node
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if inErr != nil || node == nil || len(node.Value) == 0 {
0000000000000000000000000000000000000000;;			if ignoreNotFound {
0000000000000000000000000000000000000000;;				v, err := conversion.EnforcePtr(objPtr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", nil, false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;				return "", nil, false, nil
0000000000000000000000000000000000000000;;			} else if inErr != nil {
0000000000000000000000000000000000000000;;				return "", nil, false, inErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", nil, false, fmt.Errorf("unable to locate a value on the response: %#v", response)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, stale, err = h.transformer.TransformStringFromStorage(node.Value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return body, nil, stale, storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, gvk, err := h.codec.Decode([]byte(body), nil, objPtr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return body, nil, stale, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out != objPtr {
0000000000000000000000000000000000000000;;			return body, nil, stale, fmt.Errorf("unable to decode object %s into %v", gvk.String(), reflect.TypeOf(objPtr))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// being unable to set the version does not prevent the object from being extracted
0000000000000000000000000000000000000000;;		_ = h.versioner.UpdateObject(objPtr, node.ModifiedIndex)
0000000000000000000000000000000000000000;;		return body, node, stale, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) GetToList(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate, listObj runtime.Object) error {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace := utiltrace.New("GetToList " + getTypeName(listObj))
0000000000000000000000000000000000000000;;		listPtr, err := meta.GetItemsPtr(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		trace.Step("About to read etcd node")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := &etcd.GetOptions{
0000000000000000000000000000000000000000;;			Quorum: h.quorum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := h.etcdKeysAPI.Get(ctx, key, opts)
0000000000000000000000000000000000000000;;		trace.Step("Etcd node read")
0000000000000000000000000000000000000000;;		metrics.RecordEtcdRequestLatency("get", getTypeName(listPtr), startTime)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if etcdutil.IsEtcdNotFound(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes := make([]*etcd.Node, 0)
0000000000000000000000000000000000000000;;		nodes = append(nodes, response.Node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := h.decodeNodeList(nodes, storage.SimpleFilter(pred), listPtr); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step("Object decoded")
0000000000000000000000000000000000000000;;		if err := h.versioner.UpdateList(listObj, response.Index); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeNodeList walks the tree of each node in the list and decodes into the specified object
0000000000000000000000000000000000000000;;	func (h *etcdHelper) decodeNodeList(nodes []*etcd.Node, filter storage.FilterFunc, slicePtr interface{}) error {
0000000000000000000000000000000000000000;;		trace := utiltrace.New("decodeNodeList " + getTypeName(slicePtr))
0000000000000000000000000000000000000000;;		defer trace.LogIfLong(400 * time.Millisecond)
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(slicePtr)
0000000000000000000000000000000000000000;;		if err != nil || v.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			// This should not happen at runtime.
0000000000000000000000000000000000000000;;			panic("need ptr to slice")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if node.Dir {
0000000000000000000000000000000000000000;;				// IMPORTANT: do not log each key as a discrete step in the trace log
0000000000000000000000000000000000000000;;				// as it produces an immense amount of log spam when there is a large
0000000000000000000000000000000000000000;;				// amount of content in the list.
0000000000000000000000000000000000000000;;				if err := h.decodeNodeList(node.Nodes, filter, slicePtr); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if obj, found := h.getFromCache(node.ModifiedIndex, filter); found {
0000000000000000000000000000000000000000;;				// obj != nil iff it matches the filter function.
0000000000000000000000000000000000000000;;				if obj != nil {
0000000000000000000000000000000000000000;;					v.Set(reflect.Append(v, reflect.ValueOf(obj).Elem()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				body, _, err := h.transformer.TransformStringFromStorage(node.Value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// omit items from lists and watches that cannot be transformed, but log the error
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("unable to transform key %q: %v", node.Key, err))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				obj, _, err := h.codec.Decode([]byte(body), nil, reflect.New(v.Type().Elem()).Interface().(runtime.Object))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// being unable to set the version does not prevent the object from being extracted
0000000000000000000000000000000000000000;;				_ = h.versioner.UpdateObject(obj, node.ModifiedIndex)
0000000000000000000000000000000000000000;;				if filter(obj) {
0000000000000000000000000000000000000000;;					v.Set(reflect.Append(v, reflect.ValueOf(obj).Elem()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if node.ModifiedIndex != 0 {
0000000000000000000000000000000000000000;;					h.addToCache(node.ModifiedIndex, obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step(fmt.Sprintf("Decoded %v nodes", len(nodes)))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) List(ctx context.Context, key string, resourceVersion string, pred storage.SelectionPredicate, listObj runtime.Object) error {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace := utiltrace.New("List " + getTypeName(listObj))
0000000000000000000000000000000000000000;;		defer trace.LogIfLong(400 * time.Millisecond)
0000000000000000000000000000000000000000;;		listPtr, err := meta.GetItemsPtr(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		trace.Step("About to list etcd node")
0000000000000000000000000000000000000000;;		nodes, index, err := h.listEtcdNode(ctx, key)
0000000000000000000000000000000000000000;;		trace.Step("Etcd node listed")
0000000000000000000000000000000000000000;;		metrics.RecordEtcdRequestLatency("list", getTypeName(listPtr), startTime)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := h.decodeNodeList(nodes, storage.SimpleFilter(pred), listPtr); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trace.Step("Node list decoded")
0000000000000000000000000000000000000000;;		if err := h.versioner.UpdateList(listObj, index); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *etcdHelper) listEtcdNode(ctx context.Context, key string) ([]*etcd.Node, uint64, error) {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts := etcd.GetOptions{
0000000000000000000000000000000000000000;;			Recursive: true,
0000000000000000000000000000000000000000;;			Sort:      true,
0000000000000000000000000000000000000000;;			Quorum:    h.quorum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := h.etcdKeysAPI.Get(ctx, key, &opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			var index uint64
0000000000000000000000000000000000000000;;			if etcdError, ok := err.(etcd.Error); ok {
0000000000000000000000000000000000000000;;				index = etcdError.Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodes := make([]*etcd.Node, 0)
0000000000000000000000000000000000000000;;			if etcdutil.IsEtcdNotFound(err) {
0000000000000000000000000000000000000000;;				return nodes, index, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nodes, index, toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.Node.Nodes, result.Index, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements storage.Interface.
0000000000000000000000000000000000000000;;	func (h *etcdHelper) GuaranteedUpdate(
0000000000000000000000000000000000000000;;		ctx context.Context, key string, ptrToType runtime.Object, ignoreNotFound bool,
0000000000000000000000000000000000000000;;		preconditions *storage.Preconditions, tryUpdate storage.UpdateFunc, _ ...runtime.Object) error {
0000000000000000000000000000000000000000;;		// Ignore the suggestion about current object.
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Context is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(ptrToType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Panic is appropriate, because this is a programming error.
0000000000000000000000000000000000000000;;			panic("need ptr to type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = path.Join(h.pathPrefix, key)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			obj := reflect.New(v.Type()).Interface().(runtime.Object)
0000000000000000000000000000000000000000;;			origBody, node, res, stale, err := h.bodyAndExtractObj(ctx, key, obj, ignoreNotFound)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := checkPreconditions(key, preconditions, obj); err != nil {
0000000000000000000000000000000000000000;;				return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			meta := storage.ResponseMeta{}
0000000000000000000000000000000000000000;;			if node != nil {
0000000000000000000000000000000000000000;;				meta.TTL = node.TTL
0000000000000000000000000000000000000000;;				meta.ResourceVersion = node.ModifiedIndex
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Get the object to be written by calling tryUpdate.
0000000000000000000000000000000000000000;;			ret, newTTL, err := tryUpdate(obj, meta)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			index := uint64(0)
0000000000000000000000000000000000000000;;			ttl := uint64(0)
0000000000000000000000000000000000000000;;			if node != nil {
0000000000000000000000000000000000000000;;				index = node.ModifiedIndex
0000000000000000000000000000000000000000;;				if node.TTL != 0 {
0000000000000000000000000000000000000000;;					ttl = uint64(node.TTL)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if node.Expiration != nil && ttl == 0 {
0000000000000000000000000000000000000000;;					ttl = 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if res != nil {
0000000000000000000000000000000000000000;;				index = res.Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if newTTL != nil {
0000000000000000000000000000000000000000;;				if ttl != 0 && *newTTL == 0 {
0000000000000000000000000000000000000000;;					// TODO: remove this after we have verified this is no longer an issue
0000000000000000000000000000000000000000;;					glog.V(4).Infof("GuaranteedUpdate is clearing TTL for %q, may not be intentional", key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ttl = *newTTL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Since update object may have a resourceVersion set, we need to clear it here.
0000000000000000000000000000000000000000;;			if err := h.versioner.PrepareObjectForStorage(ret); err != nil {
0000000000000000000000000000000000000000;;				return errors.New("resourceVersion cannot be set on objects store in etcd")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newBodyData, err := runtime.Encode(h.codec, ret)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newBody := string(newBodyData)
0000000000000000000000000000000000000000;;			data, err := h.transformer.TransformStringToStorage(newBody)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return storage.NewInternalError(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// First time this key has been used, try creating new value.
0000000000000000000000000000000000000000;;			if index == 0 {
0000000000000000000000000000000000000000;;				startTime := time.Now()
0000000000000000000000000000000000000000;;				opts := etcd.SetOptions{
0000000000000000000000000000000000000000;;					TTL:       time.Duration(ttl) * time.Second,
0000000000000000000000000000000000000000;;					PrevExist: etcd.PrevNoExist,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				response, err := h.etcdKeysAPI.Set(ctx, key, data, &opts)
0000000000000000000000000000000000000000;;				metrics.RecordEtcdRequestLatency("create", getTypeName(ptrToType), startTime)
0000000000000000000000000000000000000000;;				if etcdutil.IsEtcdNodeExist(err) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, _, _, err = h.extractObj(response, err, ptrToType, false, false)
0000000000000000000000000000000000000000;;				return toStorageErr(err, key, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we don't send an update, we simply return the currently existing
0000000000000000000000000000000000000000;;			// version of the object. However, the value transformer may indicate that
0000000000000000000000000000000000000000;;			// the on disk representation has changed and that we must commit an update.
0000000000000000000000000000000000000000;;			if newBody == origBody && !stale {
0000000000000000000000000000000000000000;;				_, _, _, err := h.extractObj(res, nil, ptrToType, ignoreNotFound, false)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			startTime := time.Now()
0000000000000000000000000000000000000000;;			// Swap origBody with data, if origBody is the latest etcd data.
0000000000000000000000000000000000000000;;			opts := etcd.SetOptions{
0000000000000000000000000000000000000000;;				PrevIndex: index,
0000000000000000000000000000000000000000;;				TTL:       time.Duration(ttl) * time.Second,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			response, err := h.etcdKeysAPI.Set(ctx, key, data, &opts)
0000000000000000000000000000000000000000;;			metrics.RecordEtcdRequestLatency("compareAndSwap", getTypeName(ptrToType), startTime)
0000000000000000000000000000000000000000;;			if etcdutil.IsEtcdTestFailed(err) {
0000000000000000000000000000000000000000;;				// Try again.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, _, _, err = h.extractObj(response, err, ptrToType, false, false)
0000000000000000000000000000000000000000;;			return toStorageErr(err, key, int64(index))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// etcdCache defines interface used for caching objects stored in etcd. Objects are keyed by
0000000000000000000000000000000000000000;;	// their Node.ModifiedIndex, which is unique across all types.
0000000000000000000000000000000000000000;;	// All implementations must be thread-safe.
0000000000000000000000000000000000000000;;	type etcdCache interface {
0000000000000000000000000000000000000000;;		getFromCache(index uint64, filter storage.FilterFunc) (runtime.Object, bool)
0000000000000000000000000000000000000000;;		addToCache(index uint64, obj runtime.Object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTypeName(obj interface{}) string {
0000000000000000000000000000000000000000;;		return reflect.TypeOf(obj).String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *etcdHelper) getFromCache(index uint64, filter storage.FilterFunc) (runtime.Object, bool) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.ObserveGetCache(startTime)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		obj, found := h.cache.Get(index)
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			if !filter(obj.(runtime.Object)) {
0000000000000000000000000000000000000000;;				return nil, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We should not return the object itself to avoid polluting the cache if someone
0000000000000000000000000000000000000000;;			// modifies returned values.
0000000000000000000000000000000000000000;;			objCopy, err := h.copier.Copy(obj.(runtime.Object))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error during DeepCopy of cached object: %q", err)
0000000000000000000000000000000000000000;;				// We can't return a copy, thus we report the object as not found.
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metrics.ObserveCacheHit()
0000000000000000000000000000000000000000;;			return objCopy.(runtime.Object), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metrics.ObserveCacheMiss()
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *etcdHelper) addToCache(index uint64, obj runtime.Object) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			metrics.ObserveAddCache(startTime)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		objCopy, err := h.copier.Copy(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error during DeepCopy of cached object: %q", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		isOverwrite := h.cache.Add(index, objCopy)
0000000000000000000000000000000000000000;;		if !isOverwrite {
0000000000000000000000000000000000000000;;			metrics.ObserveNewEntry()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toStorageErr(err error, key string, rv int64) error {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case etcdutil.IsEtcdNotFound(err):
0000000000000000000000000000000000000000;;			return storage.NewKeyNotFoundError(key, rv)
0000000000000000000000000000000000000000;;		case etcdutil.IsEtcdNodeExist(err):
0000000000000000000000000000000000000000;;			return storage.NewKeyExistsError(key, rv)
0000000000000000000000000000000000000000;;		case etcdutil.IsEtcdTestFailed(err):
0000000000000000000000000000000000000000;;			return storage.NewResourceVersionConflictsError(key, rv)
0000000000000000000000000000000000000000;;		case etcdutil.IsEtcdUnreachable(err):
0000000000000000000000000000000000000000;;			return storage.NewUnreachableError(key, rv)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
