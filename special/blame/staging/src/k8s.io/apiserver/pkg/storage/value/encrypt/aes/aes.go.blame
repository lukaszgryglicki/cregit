0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8743a18be39210ffc123c5c71384371b2d21c92c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package aes transforms values for storage at rest using AES-GCM.
0000000000000000000000000000000000000000;;	package aes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gcm implements AEAD encryption of the provided values given a cipher.Block algorithm.
0000000000000000000000000000000000000000;;	// The authenticated data provided as part of the value.Context method must match when the same
0000000000000000000000000000000000000000;;	// value is set to and loaded from storage. In order to ensure that values cannot be copied by
0000000000000000000000000000000000000000;;	// an attacker from a location under their control, use characteristics of the storage location
0000000000000000000000000000000000000000;;	// (such as the etcd key) as part of the authenticated data.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Because this mode requires a generated IV and IV reuse is a known weakness of AES-GCM, keys
0000000000000000000000000000000000000000;;	// must be rotated before a birthday attack becomes feasible. NIST SP 800-38D
0000000000000000000000000000000000000000;;	// (http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf) recommends using the same
0000000000000000000000000000000000000000;;	// key with random 96-bit nonces (the default nonce length) no more than 2^32 times, and
0000000000000000000000000000000000000000;;	// therefore transformers using this implementation *must* ensure they allow for frequent key
0000000000000000000000000000000000000000;;	// rotation. Future work should include investigation of AES-GCM-SIV as an alternative to
0000000000000000000000000000000000000000;;	// random nonces.
0000000000000000000000000000000000000000;;	type gcm struct {
0000000000000000000000000000000000000000;;		block cipher.Block
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGCMTransformer takes the given block cipher and performs encryption and decryption on the given
0000000000000000000000000000000000000000;;	// data.
0000000000000000000000000000000000000000;;	func NewGCMTransformer(block cipher.Block) value.Transformer {
0000000000000000000000000000000000000000;;		return &gcm{block: block}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *gcm) TransformFromStorage(data []byte, context value.Context) ([]byte, bool, error) {
0000000000000000000000000000000000000000;;		aead, err := cipher.NewGCM(t.block)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nonceSize := aead.NonceSize()
0000000000000000000000000000000000000000;;		if len(data) < nonceSize {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("the stored data was shorter than the required size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := aead.Open(nil, data[:nonceSize], data[nonceSize:], context.AuthenticatedData())
0000000000000000000000000000000000000000;;		return result, false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *gcm) TransformToStorage(data []byte, context value.Context) ([]byte, error) {
0000000000000000000000000000000000000000;;		aead, err := cipher.NewGCM(t.block)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nonceSize := aead.NonceSize()
0000000000000000000000000000000000000000;;		result := make([]byte, nonceSize+aead.Overhead()+len(data))
0000000000000000000000000000000000000000;;		n, err := rand.Read(result[:nonceSize])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != nonceSize {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to read sufficient random bytes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cipherText := aead.Seal(result[nonceSize:nonceSize], result[:nonceSize], data, context.AuthenticatedData())
0000000000000000000000000000000000000000;;		return result[:nonceSize+len(cipherText)], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cbc implements encryption at rest of the provided values given a cipher.Block algorithm.
0000000000000000000000000000000000000000;;	type cbc struct {
0000000000000000000000000000000000000000;;		block cipher.Block
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCBCTransformer takes the given block cipher and performs encryption and decryption on the given
0000000000000000000000000000000000000000;;	// data.
0000000000000000000000000000000000000000;;	func NewCBCTransformer(block cipher.Block) value.Transformer {
0000000000000000000000000000000000000000;;		return &cbc{block: block}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errInvalidBlockSize    = fmt.Errorf("the stored data is not a multiple of the block size")
0000000000000000000000000000000000000000;;		errInvalidPKCS7Data    = errors.New("invalid PKCS7 data (empty or not padded)")
0000000000000000000000000000000000000000;;		errInvalidPKCS7Padding = errors.New("invalid padding on input")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cbc) TransformFromStorage(data []byte, context value.Context) ([]byte, bool, error) {
0000000000000000000000000000000000000000;;		blockSize := aes.BlockSize
0000000000000000000000000000000000000000;;		if len(data) < blockSize {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("the stored data was shorter than the required size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iv := data[:blockSize]
0000000000000000000000000000000000000000;;		data = data[blockSize:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data)%blockSize != 0 {
0000000000000000000000000000000000000000;;			return nil, false, errInvalidBlockSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]byte, len(data))
0000000000000000000000000000000000000000;;		copy(result, data)
0000000000000000000000000000000000000000;;		mode := cipher.NewCBCDecrypter(t.block, iv)
0000000000000000000000000000000000000000;;		mode.CryptBlocks(result, result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove and verify PKCS#7 padding for CBC
0000000000000000000000000000000000000000;;		c := result[len(result)-1]
0000000000000000000000000000000000000000;;		paddingSize := int(c)
0000000000000000000000000000000000000000;;		size := len(result) - paddingSize
0000000000000000000000000000000000000000;;		if paddingSize == 0 || paddingSize > len(result) {
0000000000000000000000000000000000000000;;			return nil, false, errInvalidPKCS7Data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < paddingSize; i++ {
0000000000000000000000000000000000000000;;			if result[size+i] != c {
0000000000000000000000000000000000000000;;				return nil, false, errInvalidPKCS7Padding
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result[:size], false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cbc) TransformToStorage(data []byte, context value.Context) ([]byte, error) {
0000000000000000000000000000000000000000;;		blockSize := aes.BlockSize
0000000000000000000000000000000000000000;;		paddingSize := blockSize - (len(data) % blockSize)
0000000000000000000000000000000000000000;;		result := make([]byte, blockSize+len(data)+paddingSize)
0000000000000000000000000000000000000000;;		iv := result[:blockSize]
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand.Reader, iv); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to read sufficient random bytes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(result[blockSize:], data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add PKCS#7 padding for CBC
0000000000000000000000000000000000000000;;		copy(result[blockSize+len(data):], bytes.Repeat([]byte{byte(paddingSize)}, paddingSize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mode := cipher.NewCBCEncrypter(t.block, iv)
0000000000000000000000000000000000000000;;		mode.CryptBlocks(result[blockSize:], result[blockSize:])
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
