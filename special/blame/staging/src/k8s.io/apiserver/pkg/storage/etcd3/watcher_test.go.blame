0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9524e06cb3de8c702646be485d1f0cdd7df08203;pkg/storage/etcd3/watcher_test.go[pkg/storage/etcd3/watcher_test.go][staging/src/k8s.io/apiserver/pkg/storage/etcd3/watcher_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/integration"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		testWatch(t, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchList(t *testing.T) {
0000000000000000000000000000000000000000;;		testWatch(t, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// It tests that
0000000000000000000000000000000000000000;;	// - first occurrence of objects should notify Add event
0000000000000000000000000000000000000000;;	// - update should trigger Modified event
0000000000000000000000000000000000000000;;	// - update that gets filtered should trigger Deleted event
0000000000000000000000000000000000000000;;	func testWatch(t *testing.T, recursive bool) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		podFoo := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		podBar := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			key        string
0000000000000000000000000000000000000000;;			pred       storage.SelectionPredicate
0000000000000000000000000000000000000000;;			watchTests []*testWatchStruct
0000000000000000000000000000000000000000;;		}{{ // create a key
0000000000000000000000000000000000000000;;			key:        "/somekey-1",
0000000000000000000000000000000000000000;;			watchTests: []*testWatchStruct{{podFoo, true, watch.Added}},
0000000000000000000000000000000000000000;;			pred:       storage.Everything,
0000000000000000000000000000000000000000;;		}, { // create a key but obj gets filtered. Then update it with unfiltered obj
0000000000000000000000000000000000000000;;			key:        "/somekey-3",
0000000000000000000000000000000000000000;;			watchTests: []*testWatchStruct{{podFoo, false, ""}, {podBar, true, watch.Added}},
0000000000000000000000000000000000000000;;			pred: storage.SelectionPredicate{
0000000000000000000000000000000000000000;;				Label: labels.Everything(),
0000000000000000000000000000000000000000;;				Field: fields.ParseSelectorOrDie("metadata.name=bar"),
0000000000000000000000000000000000000000;;				GetAttrs: func(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;					pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;					return nil, fields.Set{"metadata.name": pod.Name}, pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, { // update
0000000000000000000000000000000000000000;;			key:        "/somekey-4",
0000000000000000000000000000000000000000;;			watchTests: []*testWatchStruct{{podFoo, true, watch.Added}, {podBar, true, watch.Modified}},
0000000000000000000000000000000000000000;;			pred:       storage.Everything,
0000000000000000000000000000000000000000;;		}, { // delete because of being filtered
0000000000000000000000000000000000000000;;			key:        "/somekey-5",
0000000000000000000000000000000000000000;;			watchTests: []*testWatchStruct{{podFoo, true, watch.Added}, {podBar, true, watch.Deleted}},
0000000000000000000000000000000000000000;;			pred: storage.SelectionPredicate{
0000000000000000000000000000000000000000;;				Label: labels.Everything(),
0000000000000000000000000000000000000000;;				Field: fields.ParseSelectorOrDie("metadata.name!=bar"),
0000000000000000000000000000000000000000;;				GetAttrs: func(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;					pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;					return nil, fields.Set{"metadata.name": pod.Name}, pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			w, err := store.watch(ctx, tt.key, "0", tt.pred, recursive)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var prevObj *example.Pod
0000000000000000000000000000000000000000;;			for _, watchTest := range tt.watchTests {
0000000000000000000000000000000000000000;;				out := &example.Pod{}
0000000000000000000000000000000000000000;;				key := tt.key
0000000000000000000000000000000000000000;;				if recursive {
0000000000000000000000000000000000000000;;					key = key + "/item"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := store.GuaranteedUpdate(ctx, key, out, true, nil, storage.SimpleUpdate(
0000000000000000000000000000000000000000;;					func(runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;						return watchTest.obj, nil
0000000000000000000000000000000000000000;;					}))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("GuaranteedUpdate failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if watchTest.expectEvent {
0000000000000000000000000000000000000000;;					expectObj := out
0000000000000000000000000000000000000000;;					if watchTest.watchType == watch.Deleted {
0000000000000000000000000000000000000000;;						expectObj = prevObj
0000000000000000000000000000000000000000;;						expectObj.ResourceVersion = out.ResourceVersion
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					testCheckResult(t, i, watchTest.watchType, w, expectObj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				prevObj = out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Stop()
0000000000000000000000000000000000000000;;			testCheckStop(t, i, w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteTriggerWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;		w, err := store.Watch(ctx, key, storedObj.ResourceVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := store.Delete(ctx, key, &example.Pod{}, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Delete failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCheckEventType(t, watch.Deleted, w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestWatchFromZero tests that
0000000000000000000000000000000000000000;;	// - watch from 0 should sync up and grab the object added before
0000000000000000000000000000000000000000;;	// - watch from 0 is able to return events for objects whose previous version has been compacted
0000000000000000000000000000000000000000;;	func TestWatchFromZero(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "ns"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := store.Watch(ctx, key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCheckResult(t, 0, watch.Added, w, storedObj)
0000000000000000000000000000000000000000;;		w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update
0000000000000000000000000000000000000000;;		out := &example.Pod{}
0000000000000000000000000000000000000000;;		err = store.GuaranteedUpdate(ctx, key, out, true, nil, storage.SimpleUpdate(
0000000000000000000000000000000000000000;;			func(runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "ns", Annotations: map[string]string{"a": "1"}}}, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("GuaranteedUpdate failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure when we watch from 0 we receive an ADDED event
0000000000000000000000000000000000000000;;		w, err = store.Watch(ctx, key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCheckResult(t, 1, watch.Added, w, out)
0000000000000000000000000000000000000000;;		w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update again
0000000000000000000000000000000000000000;;		out = &example.Pod{}
0000000000000000000000000000000000000000;;		err = store.GuaranteedUpdate(ctx, key, out, true, nil, storage.SimpleUpdate(
0000000000000000000000000000000000000000;;			func(runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "ns"}}, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("GuaranteedUpdate failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compact previous versions
0000000000000000000000000000000000000000;;		revToCompact, err := strconv.Atoi(out.ResourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error converting %q to an int: %v", storedObj.ResourceVersion, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = cluster.RandClient().Compact(ctx, int64(revToCompact), clientv3.WithCompactPhysical())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error compacting: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we can still watch from 0 and receive an ADDED event
0000000000000000000000000000000000000000;;		w, err = store.Watch(ctx, key, "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCheckResult(t, 2, watch.Added, w, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestWatchFromNoneZero tests that
0000000000000000000000000000000000000000;;	// - watch from non-0 should just watch changes after given version
0000000000000000000000000000000000000000;;	func TestWatchFromNoneZero(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := store.Watch(ctx, key, storedObj.ResourceVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := &example.Pod{}
0000000000000000000000000000000000000000;;		store.GuaranteedUpdate(ctx, key, out, true, nil, storage.SimpleUpdate(
0000000000000000000000000000000000000000;;			func(runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}, err
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		testCheckResult(t, 0, watch.Modified, w, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchError(t *testing.T) {
0000000000000000000000000000000000000000;;		codec := &testCodec{apitesting.TestCodec(codecs, examplev1.SchemeGroupVersion)}
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		invalidStore := newStore(cluster.RandClient(), false, codec, "", prefixTransformer{prefix: []byte("test!")})
0000000000000000000000000000000000000000;;		ctx := context.Background()
0000000000000000000000000000000000000000;;		w, err := invalidStore.Watch(ctx, "/abc", "0", storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		validStore := newStore(cluster.RandClient(), false, codec, "", prefixTransformer{prefix: []byte("test!")})
0000000000000000000000000000000000000000;;		validStore.GuaranteedUpdate(ctx, "/abc", &example.Pod{}, true, nil, storage.SimpleUpdate(
0000000000000000000000000000000000000000;;			func(runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}, nil
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;		testCheckEventType(t, watch.Error, w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchContextCancel(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		canceledCtx, cancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		// When we watch with a canceled context, we should detect that it's context canceled.
0000000000000000000000000000000000000000;;		// We won't take it as error and also close the watcher.
0000000000000000000000000000000000000000;;		w, err := store.watcher.Watch(canceledCtx, "/abc", 0, false, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case _, ok := <-w.ResultChan():
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				t.Error("ResultChan() should be closed")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchErrResultNotBlockAfterCancel(t *testing.T) {
0000000000000000000000000000000000000000;;		origCtx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(origCtx)
0000000000000000000000000000000000000000;;		w := store.watcher.createWatchChan(ctx, "/abc", 0, false, storage.Everything)
0000000000000000000000000000000000000000;;		// make resutlChan and errChan blocking to ensure ordering.
0000000000000000000000000000000000000000;;		w.resultChan = make(chan watch.Event)
0000000000000000000000000000000000000000;;		w.errChan = make(chan error)
0000000000000000000000000000000000000000;;		// The event flow goes like:
0000000000000000000000000000000000000000;;		// - first we send an error, it should block on resultChan.
0000000000000000000000000000000000000000;;		// - Then we cancel ctx. The blocking on resultChan should be freed up
0000000000000000000000000000000000000000;;		//   and run() goroutine should return.
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			w.run()
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		w.errChan <- fmt.Errorf("some error")
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWatchDeleteEventObjectHaveLatestRV(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx, store, cluster := testSetup(t)
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		key, storedObj := testPropogateStore(ctx, t, store, &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := store.Watch(ctx, key, storedObj.ResourceVersion, storage.Everything)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Watch failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		etcdW := cluster.RandClient().Watch(ctx, "/", clientv3.WithPrefix())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := store.Delete(ctx, key, &example.Pod{}, &storage.Preconditions{}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Delete failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := <-w.ResultChan()
0000000000000000000000000000000000000000;;		watchedDeleteObj := e.Object.(*example.Pod)
0000000000000000000000000000000000000000;;		var wres clientv3.WatchResponse
0000000000000000000000000000000000000000;;		wres = <-etcdW
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watchedDeleteRev, err := storage.ParseWatchResourceVersion(watchedDeleteObj.ResourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("ParseWatchResourceVersion failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if int64(watchedDeleteRev) != wres.Events[0].Kv.ModRevision {
0000000000000000000000000000000000000000;;			t.Errorf("Object from delete event have version: %v, should be the same as etcd delete's mod rev: %d",
0000000000000000000000000000000000000000;;				watchedDeleteRev, wres.Events[0].Kv.ModRevision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testWatchStruct struct {
0000000000000000000000000000000000000000;;		obj         *example.Pod
0000000000000000000000000000000000000000;;		expectEvent bool
0000000000000000000000000000000000000000;;		watchType   watch.EventType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testCodec struct {
0000000000000000000000000000000000000000;;		runtime.Codec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *testCodec) Decode(data []byte, defaults *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		return nil, nil, errTestingDecode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCheckEventType(t *testing.T, expectEventType watch.EventType, w watch.Interface) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case res := <-w.ResultChan():
0000000000000000000000000000000000000000;;			if res.Type != expectEventType {
0000000000000000000000000000000000000000;;				t.Errorf("event type want=%v, get=%v", expectEventType, res.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("time out after waiting %v on ResultChan", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCheckResult(t *testing.T, i int, expectEventType watch.EventType, w watch.Interface, expectObj *example.Pod) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case res := <-w.ResultChan():
0000000000000000000000000000000000000000;;			if res.Type != expectEventType {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: event type want=%v, get=%v", i, expectEventType, res.Type)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(expectObj, res.Object) {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: obj want=\n%#v\nget=\n%#v", i, expectObj, res.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("#%d: time out after waiting %v on ResultChan", i, wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testCheckStop(t *testing.T, i int, w watch.Interface) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case e, ok := <-w.ResultChan():
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				var obj string
0000000000000000000000000000000000000000;;				switch e.Object.(type) {
0000000000000000000000000000000000000000;;				case *example.Pod:
0000000000000000000000000000000000000000;;					obj = e.Object.(*example.Pod).Name
0000000000000000000000000000000000000000;;				case *metav1.Status:
0000000000000000000000000000000000000000;;					obj = e.Object.(*metav1.Status).Message
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Errorf("#%d: ResultChan should have been closed. Event: %s. Object: %s", i, e.Type, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("#%d: time out after waiting 1s on ResultChan", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
