0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
53f25fc3ba9671fa3c431e09a72e55b1f8f27f49;pkg/storage/etcd3/util.go[pkg/storage/etcd3/util.go][staging/src/k8s.io/apiserver/pkg/storage/etcd3/compact.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		compactInterval = 5 * time.Minute
0000000000000000000000000000000000000000;;		compactRevKey   = "compact_rev_key"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		endpointsMapMu sync.Mutex
0000000000000000000000000000000000000000;;		endpointsMap   map[string]struct{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		endpointsMap = make(map[string]struct{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartCompactor starts a compactor in the background to compact old version of keys that's not needed.
0000000000000000000000000000000000000000;;	// By default, we save the most recent 10 minutes data and compact versions > 10minutes ago.
0000000000000000000000000000000000000000;;	// It should be enough for slow watchers and to tolerate burst.
0000000000000000000000000000000000000000;;	// TODO: We might keep a longer history (12h) in the future once storage API can take advantage of past version of keys.
0000000000000000000000000000000000000000;;	func StartCompactor(ctx context.Context, client *clientv3.Client) {
0000000000000000000000000000000000000000;;		endpointsMapMu.Lock()
0000000000000000000000000000000000000000;;		defer endpointsMapMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In one process, we can have only one compactor for one cluster.
0000000000000000000000000000000000000000;;		// Currently we rely on endpoints to differentiate clusters.
0000000000000000000000000000000000000000;;		for _, ep := range client.Endpoints() {
0000000000000000000000000000000000000000;;			if _, ok := endpointsMap[ep]; ok {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("compactor already exists for endpoints %v", client.Endpoints())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ep := range client.Endpoints() {
0000000000000000000000000000000000000000;;			endpointsMap[ep] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go compactor(ctx, client, compactInterval)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compactor periodically compacts historical versions of keys in etcd.
0000000000000000000000000000000000000000;;	// It will compact keys with versions older than given interval.
0000000000000000000000000000000000000000;;	// In other words, after compaction, it will only contain keys set during last interval.
0000000000000000000000000000000000000000;;	// Any API call for the older versions of keys will return error.
0000000000000000000000000000000000000000;;	// Interval is the time interval between each compaction. The first compaction happens after "interval".
0000000000000000000000000000000000000000;;	func compactor(ctx context.Context, client *clientv3.Client, interval time.Duration) {
0000000000000000000000000000000000000000;;		// Technical definitions:
0000000000000000000000000000000000000000;;		// We have a special key in etcd defined as *compactRevKey*.
0000000000000000000000000000000000000000;;		// compactRevKey's value will be set to the string of last compacted revision.
0000000000000000000000000000000000000000;;		// compactRevKey's version will be used as logical time for comparison. THe version is referred as compact time.
0000000000000000000000000000000000000000;;		// Initially, because the key doesn't exist, the compact time (version) is 0.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Algorithm:
0000000000000000000000000000000000000000;;		// - Compare to see if (local compact_time) = (remote compact_time).
0000000000000000000000000000000000000000;;		// - If yes, increment both local and remote compact_time, and do a compaction.
0000000000000000000000000000000000000000;;		// - If not, set local to remote compact_time.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Technical details/insights:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The protocol here is lease based. If one compactor CAS successfully, the others would know it when they fail in
0000000000000000000000000000000000000000;;		// CAS later and would try again in 10 minutes. If an APIServer crashed, another one would "take over" the lease.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// For example, in the following diagram, we have a compactor C1 doing compaction in t1, t2. Another compactor C2
0000000000000000000000000000000000000000;;		// at t1' (t1 < t1' < t2) would CAS fail, set its known oldRev to rev at t1', and try again in t2' (t2' > t2).
0000000000000000000000000000000000000000;;		// If C1 crashed and wouldn't compact at t2, C2 would CAS successfully at t2'.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//                 oldRev(t2)     curRev(t2)
0000000000000000000000000000000000000000;;		//                                  +
0000000000000000000000000000000000000000;;		//   oldRev        curRev           |
0000000000000000000000000000000000000000;;		//     +             +              |
0000000000000000000000000000000000000000;;		//     |             |              |
0000000000000000000000000000000000000000;;		//     |             |    t1'       |     t2'
0000000000000000000000000000000000000000;;		// +---v-------------v----^---------v------^---->
0000000000000000000000000000000000000000;;		//     t0           t1             t2
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We have the guarantees:
0000000000000000000000000000000000000000;;		// - in normal cases, the interval is 10 minutes.
0000000000000000000000000000000000000000;;		// - in failover, the interval is >10m and <20m
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// FAQ:
0000000000000000000000000000000000000000;;		// - What if time is not accurate? We don't care as long as someone did the compaction. Atomicity is ensured using
0000000000000000000000000000000000000000;;		//   etcd API.
0000000000000000000000000000000000000000;;		// - What happened under heavy load scenarios? Initially, each apiserver will do only one compaction
0000000000000000000000000000000000000000;;		//   every 10 minutes. This is very unlikely affecting or affected w.r.t. server load.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var compactTime int64
0000000000000000000000000000000000000000;;		var rev int64
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(interval):
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			compactTime, rev, err = compact(ctx, client, compactTime, rev)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("etcd: endpoint (%v) compact failed: %v", client.Endpoints(), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compact compacts etcd store and returns current rev.
0000000000000000000000000000000000000000;;	// It will return the current compact time and global revision if no error occurred.
0000000000000000000000000000000000000000;;	// Note that CAS fail will not incur any error.
0000000000000000000000000000000000000000;;	func compact(ctx context.Context, client *clientv3.Client, t, rev int64) (int64, int64, error) {
0000000000000000000000000000000000000000;;		resp, err := client.KV.Txn(ctx).If(
0000000000000000000000000000000000000000;;			clientv3.Compare(clientv3.Version(compactRevKey), "=", t),
0000000000000000000000000000000000000000;;		).Then(
0000000000000000000000000000000000000000;;			clientv3.OpPut(compactRevKey, strconv.FormatInt(rev, 10)), // Expect side effect: increment Version
0000000000000000000000000000000000000000;;		).Else(
0000000000000000000000000000000000000000;;			clientv3.OpGet(compactRevKey),
0000000000000000000000000000000000000000;;		).Commit()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return t, rev, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curRev := resp.Header.Revision
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !resp.Succeeded {
0000000000000000000000000000000000000000;;			curTime := resp.Responses[0].GetResponseRange().Kvs[0].Version
0000000000000000000000000000000000000000;;			return curTime, curRev, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		curTime := t + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rev == 0 {
0000000000000000000000000000000000000000;;			// We don't compact on bootstrap.
0000000000000000000000000000000000000000;;			return curTime, curRev, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = client.Compact(ctx, rev); err != nil {
0000000000000000000000000000000000000000;;			return curTime, curRev, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("etcd: compacted rev (%d), endpoints (%v)", rev, client.Endpoints())
0000000000000000000000000000000000000000;;		return curTime, curRev, nil
0000000000000000000000000000000000000000;;	}
