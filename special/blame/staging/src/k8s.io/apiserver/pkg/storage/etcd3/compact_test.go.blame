0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
53f25fc3ba9671fa3c431e09a72e55b1f8f27f49;pkg/storage/etcd3/util_test.go[pkg/storage/etcd3/util_test.go][staging/src/k8s.io/apiserver/pkg/storage/etcd3/compact_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package etcd3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		etcdrpc "github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/integration"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCompact(t *testing.T) {
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		client := cluster.RandClient()
0000000000000000000000000000000000000000;;		ctx := context.Background()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putResp, err := client.Put(ctx, "/somekey", "data")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Put failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putResp1, err := client.Put(ctx, "/somekey", "data2")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Put failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err = compact(ctx, client, 0, putResp1.Header.Revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("compact failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := client.Get(ctx, "/somekey", clientv3.WithRev(putResp.Header.Revision))
0000000000000000000000000000000000000000;;		if err != etcdrpc.ErrCompacted {
0000000000000000000000000000000000000000;;			t.Errorf("Expecting ErrCompacted, but get=%v err=%v", obj, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestCompactConflict tests that two compactors (Let's use C1, C2) are trying to compact etcd cluster with the same
0000000000000000000000000000000000000000;;	// logical time.
0000000000000000000000000000000000000000;;	// - C1 compacts first. It will succeed.
0000000000000000000000000000000000000000;;	// - C2 compacts after. It will fail. But it will get latest logical time, which should be larger by one.
0000000000000000000000000000000000000000;;	func TestCompactConflict(t *testing.T) {
0000000000000000000000000000000000000000;;		cluster := integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1})
0000000000000000000000000000000000000000;;		defer cluster.Terminate(t)
0000000000000000000000000000000000000000;;		client := cluster.RandClient()
0000000000000000000000000000000000000000;;		ctx := context.Background()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putResp, err := client.Put(ctx, "/somekey", "data")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Put failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compact first. It would do the compaction and return compact time which is incremented by 1.
0000000000000000000000000000000000000000;;		curTime, _, err := compact(ctx, client, 0, putResp.Header.Revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("compact failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if curTime != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expect current logical time = 1, get = %v", curTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compact again with the same parameters. It won't do compaction but return the latest compact time.
0000000000000000000000000000000000000000;;		curTime2, _, err := compact(ctx, client, 0, putResp.Header.Revision)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("compact failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if curTime != curTime2 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected curTime (%v) != curTime2 (%v)", curTime, curTime2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
