0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f427bab5b3a32e1add038ae97fa45240580251f9;pkg/storage/time_budget.go[pkg/storage/time_budget.go][staging/src/k8s.io/apiserver/pkg/storage/time_budget.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		refreshPerSecond = 50 * time.Millisecond
0000000000000000000000000000000000000000;;		maxBudget        = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timeBudget implements a budget of time that you can use and is
0000000000000000000000000000000000000000;;	// periodically being refreshed. The pattern to use it is:
0000000000000000000000000000000000000000;;	//   budget := newTimeBudget(...)
0000000000000000000000000000000000000000;;	//   ...
0000000000000000000000000000000000000000;;	//   timeout := budget.takeAvailable()
0000000000000000000000000000000000000000;;	//   // Now you can spend at most timeout on doing stuff
0000000000000000000000000000000000000000;;	//   ...
0000000000000000000000000000000000000000;;	//   // If you didn't use all timeout, return what you didn't use
0000000000000000000000000000000000000000;;	//   budget.returnUnused(<unused part of timeout>)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: It's not recommended to be used concurrently from multiple threads -
0000000000000000000000000000000000000000;;	// if first user takes the whole timeout, the second one will get 0 timeout
0000000000000000000000000000000000000000;;	// even though the first one may return something later.
0000000000000000000000000000000000000000;;	type timeBudget struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		budget time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refresh   time.Duration
0000000000000000000000000000000000000000;;		maxBudget time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTimeBudget(stopCh <-chan struct{}) *timeBudget {
0000000000000000000000000000000000000000;;		result := &timeBudget{
0000000000000000000000000000000000000000;;			budget:    time.Duration(0),
0000000000000000000000000000000000000000;;			refresh:   refreshPerSecond,
0000000000000000000000000000000000000000;;			maxBudget: maxBudget,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go result.periodicallyRefresh(stopCh)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *timeBudget) periodicallyRefresh(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(time.Second)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;				t.Lock()
0000000000000000000000000000000000000000;;				if t.budget = t.budget + t.refresh; t.budget > t.maxBudget {
0000000000000000000000000000000000000000;;					t.budget = t.maxBudget
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Unlock()
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *timeBudget) takeAvailable() time.Duration {
0000000000000000000000000000000000000000;;		t.Lock()
0000000000000000000000000000000000000000;;		defer t.Unlock()
0000000000000000000000000000000000000000;;		result := t.budget
0000000000000000000000000000000000000000;;		t.budget = time.Duration(0)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *timeBudget) returnUnused(unused time.Duration) {
0000000000000000000000000000000000000000;;		t.Lock()
0000000000000000000000000000000000000000;;		defer t.Unlock()
0000000000000000000000000000000000000000;;		if unused < 0 {
0000000000000000000000000000000000000000;;			// We used more than allowed.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.budget = t.budget + unused; t.budget > t.maxBudget {
0000000000000000000000000000000000000000;;			t.budget = t.maxBudget
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
