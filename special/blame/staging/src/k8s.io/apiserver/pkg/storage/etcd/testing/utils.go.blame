0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6307519a211320773b2d62604741b84c82b68512;pkg/storage/etcd/etcd_test_util.go[pkg/storage/etcd/etcd_test_util.go][staging/src/k8s.io/apiserver/pkg/storage/etcd/testing/utils.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd/etcdtest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/etcd/testing/testingcert"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcd "github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v2http"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/integration"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/testutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/transport"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EtcdTestServer encapsulates the datastructures needed to start local instance for testing
0000000000000000000000000000000000000000;;	type EtcdTestServer struct {
0000000000000000000000000000000000000000;;		// The following are lumped etcd2 test server params
0000000000000000000000000000000000000000;;		// TODO: Deprecate in a post 1.5 release
0000000000000000000000000000000000000000;;		etcdserver.ServerConfig
0000000000000000000000000000000000000000;;		PeerListeners, ClientListeners []net.Listener
0000000000000000000000000000000000000000;;		Client                         etcd.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CertificatesDir string
0000000000000000000000000000000000000000;;		CertFile        string
0000000000000000000000000000000000000000;;		KeyFile         string
0000000000000000000000000000000000000000;;		CAFile          string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raftHandler http.Handler
0000000000000000000000000000000000000000;;		s           *etcdserver.EtcdServer
0000000000000000000000000000000000000000;;		hss         []*httptest.Server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The following are lumped etcd3 test server params
0000000000000000000000000000000000000000;;		v3Cluster *integration.ClusterV3
0000000000000000000000000000000000000000;;		V3Client  *clientv3.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newLocalListener opens a port localhost using any port
0000000000000000000000000000000000000000;;	func newLocalListener(t *testing.T) net.Listener {
0000000000000000000000000000000000000000;;		l, err := net.Listen("tcp", "127.0.0.1:0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newSecuredLocalListener opens a port localhost using any port
0000000000000000000000000000000000000000;;	// with SSL enable
0000000000000000000000000000000000000000;;	func newSecuredLocalListener(t *testing.T, certFile, keyFile, caFile string) net.Listener {
0000000000000000000000000000000000000000;;		var l net.Listener
0000000000000000000000000000000000000000;;		l, err := net.Listen("tcp", "127.0.0.1:0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsInfo := transport.TLSInfo{
0000000000000000000000000000000000000000;;			CertFile: certFile,
0000000000000000000000000000000000000000;;			KeyFile:  keyFile,
0000000000000000000000000000000000000000;;			CAFile:   caFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlscfg, err := tlsInfo.ServerConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected serverConfig error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l, err = transport.NewKeepAliveListener(l, "https", tlscfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newHttpTransport(t *testing.T, certFile, keyFile, caFile string) etcd.CancelableTransport {
0000000000000000000000000000000000000000;;		tlsInfo := transport.TLSInfo{
0000000000000000000000000000000000000000;;			CertFile: certFile,
0000000000000000000000000000000000000000;;			KeyFile:  keyFile,
0000000000000000000000000000000000000000;;			CAFile:   caFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tr, err := transport.NewTransport(tlsInfo, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configureTestCluster will set the params to start an etcd server
0000000000000000000000000000000000000000;;	func configureTestCluster(t *testing.T, name string, https bool) *EtcdTestServer {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		m := &EtcdTestServer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pln := newLocalListener(t)
0000000000000000000000000000000000000000;;		m.PeerListeners = []net.Listener{pln}
0000000000000000000000000000000000000000;;		m.PeerURLs, err = types.NewURLs([]string{"http://" + pln.Addr().String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow test launches to control where etcd data goes, for space or performance reasons
0000000000000000000000000000000000000000;;		baseDir := os.Getenv("TEST_ETCD_DIR")
0000000000000000000000000000000000000000;;		if len(baseDir) == 0 {
0000000000000000000000000000000000000000;;			baseDir = os.TempDir()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if https {
0000000000000000000000000000000000000000;;			m.CertificatesDir, err = ioutil.TempDir(baseDir, "etcd_certificates")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.CertFile = path.Join(m.CertificatesDir, "etcdcert.pem")
0000000000000000000000000000000000000000;;			if err = ioutil.WriteFile(m.CertFile, []byte(testingcert.CertFileContent), 0644); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.KeyFile = path.Join(m.CertificatesDir, "etcdkey.pem")
0000000000000000000000000000000000000000;;			if err = ioutil.WriteFile(m.KeyFile, []byte(testingcert.KeyFileContent), 0644); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.CAFile = path.Join(m.CertificatesDir, "ca.pem")
0000000000000000000000000000000000000000;;			if err = ioutil.WriteFile(m.CAFile, []byte(testingcert.CAFileContent), 0644); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cln := newSecuredLocalListener(t, m.CertFile, m.KeyFile, m.CAFile)
0000000000000000000000000000000000000000;;			m.ClientListeners = []net.Listener{cln}
0000000000000000000000000000000000000000;;			m.ClientURLs, err = types.NewURLs([]string{"https://" + cln.Addr().String()})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cln := newLocalListener(t)
0000000000000000000000000000000000000000;;			m.ClientListeners = []net.Listener{cln}
0000000000000000000000000000000000000000;;			m.ClientURLs, err = types.NewURLs([]string{"http://" + cln.Addr().String()})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.Name = name
0000000000000000000000000000000000000000;;		m.DataDir, err = ioutil.TempDir(baseDir, "etcd")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterStr := fmt.Sprintf("%s=http://%s", name, pln.Addr().String())
0000000000000000000000000000000000000000;;		m.InitialPeerURLsMap, err = types.NewURLsMap(clusterStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.InitialClusterToken = "TestEtcd"
0000000000000000000000000000000000000000;;		m.NewCluster = true
0000000000000000000000000000000000000000;;		m.ForceNewCluster = false
0000000000000000000000000000000000000000;;		m.ElectionTicks = 10
0000000000000000000000000000000000000000;;		m.TickMs = uint(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// launch will attempt to start the etcd server
0000000000000000000000000000000000000000;;	func (m *EtcdTestServer) launch(t *testing.T) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if m.s, err = etcdserver.NewServer(&m.ServerConfig); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to initialize the etcd server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.s.SyncTicker = time.Tick(500 * time.Millisecond)
0000000000000000000000000000000000000000;;		m.s.Start()
0000000000000000000000000000000000000000;;		m.raftHandler = &testutil.PauseableHandler{Next: v2http.NewPeerHandler(m.s)}
0000000000000000000000000000000000000000;;		for _, ln := range m.PeerListeners {
0000000000000000000000000000000000000000;;			hs := &httptest.Server{
0000000000000000000000000000000000000000;;				Listener: ln,
0000000000000000000000000000000000000000;;				Config:   &http.Server{Handler: m.raftHandler},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hs.Start()
0000000000000000000000000000000000000000;;			m.hss = append(m.hss, hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ln := range m.ClientListeners {
0000000000000000000000000000000000000000;;			hs := &httptest.Server{
0000000000000000000000000000000000000000;;				Listener: ln,
0000000000000000000000000000000000000000;;				Config:   &http.Server{Handler: v2http.NewClientHandler(m.s, m.ServerConfig.ReqTimeout())},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hs.Start()
0000000000000000000000000000000000000000;;			m.hss = append(m.hss, hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForEtcd wait until etcd is propagated correctly
0000000000000000000000000000000000000000;;	func (m *EtcdTestServer) waitUntilUp() error {
0000000000000000000000000000000000000000;;		membersAPI := etcd.NewMembersAPI(m.Client)
0000000000000000000000000000000000000000;;		for start := time.Now(); time.Since(start) < wait.ForeverTestTimeout; time.Sleep(10 * time.Millisecond) {
0000000000000000000000000000000000000000;;			members, err := membersAPI.List(context.TODO())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error when getting etcd cluster members")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(members) == 1 && len(members[0].ClientURLs) > 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("timeout on waiting for etcd cluster")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Terminate will shutdown the running etcd server
0000000000000000000000000000000000000000;;	func (m *EtcdTestServer) Terminate(t *testing.T) {
0000000000000000000000000000000000000000;;		if m.v3Cluster != nil {
0000000000000000000000000000000000000000;;			m.v3Cluster.Terminate(t)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m.Client = nil
0000000000000000000000000000000000000000;;			m.s.Stop()
0000000000000000000000000000000000000000;;			// TODO: This is a pretty ugly hack to workaround races during closing
0000000000000000000000000000000000000000;;			// in-memory etcd server in unit tests - see #18928 for more details.
0000000000000000000000000000000000000000;;			// We should get rid of it as soon as we have a proper fix - etcd clients
0000000000000000000000000000000000000000;;			// have overwritten transport counting opened connections (probably by
0000000000000000000000000000000000000000;;			// overwriting Dial function) and termination function waiting for all
0000000000000000000000000000000000000000;;			// connections to be closed and stopping accepting new ones.
0000000000000000000000000000000000000000;;			time.Sleep(250 * time.Millisecond)
0000000000000000000000000000000000000000;;			for _, hs := range m.hss {
0000000000000000000000000000000000000000;;				hs.CloseClientConnections()
0000000000000000000000000000000000000000;;				hs.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := os.RemoveAll(m.ServerConfig.DataDir); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(m.CertificatesDir) > 0 {
0000000000000000000000000000000000000000;;				if err := os.RemoveAll(m.CertificatesDir); err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEtcdTestClientServer DEPRECATED creates a new client and server for testing
0000000000000000000000000000000000000000;;	func NewEtcdTestClientServer(t *testing.T) *EtcdTestServer {
0000000000000000000000000000000000000000;;		server := configureTestCluster(t, "foo", true)
0000000000000000000000000000000000000000;;		err := server.launch(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to start etcd server error=%v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := etcd.Config{
0000000000000000000000000000000000000000;;			Endpoints: server.ClientURLs.StringSlice(),
0000000000000000000000000000000000000000;;			Transport: newHttpTransport(t, server.CertFile, server.KeyFile, server.CAFile),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server.Client, err = etcd.New(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			server.Terminate(t)
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error in NewEtcdTestClientServer (%v)", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := server.waitUntilUp(); err != nil {
0000000000000000000000000000000000000000;;			server.Terminate(t)
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error in waitUntilUp (%v)", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return server
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnsecuredEtcdTestClientServer DEPRECATED creates a new client and server for testing
0000000000000000000000000000000000000000;;	func NewUnsecuredEtcdTestClientServer(t *testing.T) *EtcdTestServer {
0000000000000000000000000000000000000000;;		server := configureTestCluster(t, "foo", false)
0000000000000000000000000000000000000000;;		err := server.launch(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to start etcd server error=%v", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg := etcd.Config{
0000000000000000000000000000000000000000;;			Endpoints: server.ClientURLs.StringSlice(),
0000000000000000000000000000000000000000;;			Transport: newHttpTransport(t, server.CertFile, server.KeyFile, server.CAFile),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server.Client, err = etcd.New(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error in NewUnsecuredEtcdTestClientServer (%v)", err)
0000000000000000000000000000000000000000;;			server.Terminate(t)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := server.waitUntilUp(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error in waitUntilUp (%v)", err)
0000000000000000000000000000000000000000;;			server.Terminate(t)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return server
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEtcd3TestClientServer creates a new client and server for testing
0000000000000000000000000000000000000000;;	func NewUnsecuredEtcd3TestClientServer(t *testing.T, scheme *runtime.Scheme) (*EtcdTestServer, *storagebackend.Config) {
0000000000000000000000000000000000000000;;		server := &EtcdTestServer{
0000000000000000000000000000000000000000;;			v3Cluster: integration.NewClusterV3(t, &integration.ClusterConfig{Size: 1}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server.V3Client = server.v3Cluster.RandClient()
0000000000000000000000000000000000000000;;		config := &storagebackend.Config{
0000000000000000000000000000000000000000;;			Type:                     "etcd3",
0000000000000000000000000000000000000000;;			Prefix:                   etcdtest.PathPrefix(),
0000000000000000000000000000000000000000;;			ServerList:               server.V3Client.Endpoints(),
0000000000000000000000000000000000000000;;			DeserializationCacheSize: etcdtest.DeserializationCacheSize,
0000000000000000000000000000000000000000;;			Copier: scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return server, config
0000000000000000000000000000000000000000;;	}
