0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8743a18be39210ffc123c5c71384371b2d21c92c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package value contains methods for assisting with transformation of values in storage.
0000000000000000000000000000000000000000;;	package value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Context is additional information that a storage transformation may need to verify the data at rest.
0000000000000000000000000000000000000000;;	type Context interface {
0000000000000000000000000000000000000000;;		// AuthenticatedData should return an array of bytes that describes the current value. If the value changes,
0000000000000000000000000000000000000000;;		// the transformer may report the value as unreadable or tampered. This may be nil if no such description exists
0000000000000000000000000000000000000000;;		// or is needed. For additional verification, set this to data that strongly identifies the value, such as
0000000000000000000000000000000000000000;;		// the key and creation version of the stored data.
0000000000000000000000000000000000000000;;		AuthenticatedData() []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transformer allows a value to be transformed before being read from or written to the underlying store. The methods
0000000000000000000000000000000000000000;;	// must be able to undo the transformation caused by the other.
0000000000000000000000000000000000000000;;	type Transformer interface {
0000000000000000000000000000000000000000;;		// TransformFromStorage may transform the provided data from its underlying storage representation or return an error.
0000000000000000000000000000000000000000;;		// Stale is true if the object on disk is stale and a write to etcd should be issued, even if the contents of the object
0000000000000000000000000000000000000000;;		// have not changed.
0000000000000000000000000000000000000000;;		TransformFromStorage(data []byte, context Context) (out []byte, stale bool, err error)
0000000000000000000000000000000000000000;;		// TransformToStorage may transform the provided data into the appropriate form in storage or return an error.
0000000000000000000000000000000000000000;;		TransformToStorage(data []byte, context Context) (out []byte, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type identityTransformer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IdentityTransformer performs no transformation of the provided data.
0000000000000000000000000000000000000000;;	var IdentityTransformer Transformer = identityTransformer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (identityTransformer) TransformFromStorage(b []byte, ctx Context) ([]byte, bool, error) {
0000000000000000000000000000000000000000;;		return b, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (identityTransformer) TransformToStorage(b []byte, ctx Context) ([]byte, error) {
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultContext is a simple implementation of Context for a slice of bytes.
0000000000000000000000000000000000000000;;	type DefaultContext []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthenticatedData returns itself.
0000000000000000000000000000000000000000;;	func (c DefaultContext) AuthenticatedData() []byte { return []byte(c) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MutableTransformer allows a transformer to be changed safely at runtime.
0000000000000000000000000000000000000000;;	type MutableTransformer struct {
0000000000000000000000000000000000000000;;		lock        sync.RWMutex
0000000000000000000000000000000000000000;;		transformer Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMutableTransformer creates a transformer that can be updated at any time by calling Set()
0000000000000000000000000000000000000000;;	func NewMutableTransformer(transformer Transformer) *MutableTransformer {
0000000000000000000000000000000000000000;;		return &MutableTransformer{transformer: transformer}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set updates the nested transformer.
0000000000000000000000000000000000000000;;	func (t *MutableTransformer) Set(transformer Transformer) {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		t.transformer = transformer
0000000000000000000000000000000000000000;;		t.lock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *MutableTransformer) TransformFromStorage(data []byte, context Context) (out []byte, stale bool, err error) {
0000000000000000000000000000000000000000;;		t.lock.RLock()
0000000000000000000000000000000000000000;;		transformer := t.transformer
0000000000000000000000000000000000000000;;		t.lock.RUnlock()
0000000000000000000000000000000000000000;;		return transformer.TransformFromStorage(data, context)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (t *MutableTransformer) TransformToStorage(data []byte, context Context) (out []byte, err error) {
0000000000000000000000000000000000000000;;		t.lock.RLock()
0000000000000000000000000000000000000000;;		transformer := t.transformer
0000000000000000000000000000000000000000;;		t.lock.RUnlock()
0000000000000000000000000000000000000000;;		return transformer.TransformToStorage(data, context)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrefixTransformer holds a transformer interface and the prefix that the transformation is located under.
0000000000000000000000000000000000000000;;	type PrefixTransformer struct {
0000000000000000000000000000000000000000;;		Prefix      []byte
0000000000000000000000000000000000000000;;		Transformer Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type prefixTransformers struct {
0000000000000000000000000000000000000000;;		transformers []PrefixTransformer
0000000000000000000000000000000000000000;;		err          error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Transformer = &prefixTransformers{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPrefixTransformers supports the Transformer interface by checking the incoming data against the provided
0000000000000000000000000000000000000000;;	// prefixes in order. The first matching prefix will be used to transform the value (the prefix is stripped
0000000000000000000000000000000000000000;;	// before the Transformer interface is invoked). The first provided transformer will be used when writing to
0000000000000000000000000000000000000000;;	// the store.
0000000000000000000000000000000000000000;;	func NewPrefixTransformers(err error, transformers ...PrefixTransformer) Transformer {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("the provided value does not match any of the supported transformers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &prefixTransformers{
0000000000000000000000000000000000000000;;			transformers: transformers,
0000000000000000000000000000000000000000;;			err:          err,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransformFromStorage finds the first transformer with a prefix matching the provided data and returns
0000000000000000000000000000000000000000;;	// the result of transforming the value. It will always mark any transformation as stale that is not using
0000000000000000000000000000000000000000;;	// the first transformer.
0000000000000000000000000000000000000000;;	func (t *prefixTransformers) TransformFromStorage(data []byte, context Context) ([]byte, bool, error) {
0000000000000000000000000000000000000000;;		for i, transformer := range t.transformers {
0000000000000000000000000000000000000000;;			if bytes.HasPrefix(data, transformer.Prefix) {
0000000000000000000000000000000000000000;;				result, stale, err := transformer.Transformer.TransformFromStorage(data[len(transformer.Prefix):], context)
0000000000000000000000000000000000000000;;				// To migrate away from encryption, user can specify an identity transformer higher up
0000000000000000000000000000000000000000;;				// (in the config file) than the encryption transformer. In that scenario, the identity transformer needs to
0000000000000000000000000000000000000000;;				// identify (during reads from disk) whether the data being read is encrypted or not. If the data is encrypted,
0000000000000000000000000000000000000000;;				// it shall throw an error, but that error should not prevent subsequent transformers from being tried.
0000000000000000000000000000000000000000;;				if len(transformer.Prefix) == 0 && err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return result, stale || i != 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, t.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransformToStorage uses the first transformer and adds its prefix to the data.
0000000000000000000000000000000000000000;;	func (t *prefixTransformers) TransformToStorage(data []byte, context Context) ([]byte, error) {
0000000000000000000000000000000000000000;;		transformer := t.transformers[0]
0000000000000000000000000000000000000000;;		prefixedData := make([]byte, len(transformer.Prefix), len(data)+len(transformer.Prefix))
0000000000000000000000000000000000000000;;		copy(prefixedData, transformer.Prefix)
0000000000000000000000000000000000000000;;		result, err := transformer.Transformer.TransformToStorage(data, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prefixedData = append(prefixedData, result...)
0000000000000000000000000000000000000000;;		return prefixedData, nil
0000000000000000000000000000000000000000;;	}
