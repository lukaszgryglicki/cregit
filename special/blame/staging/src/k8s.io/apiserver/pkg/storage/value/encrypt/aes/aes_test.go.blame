0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
8743a18be39210ffc123c5c71384371b2d21c92c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGCMDataStable(t *testing.T) {
0000000000000000000000000000000000000000;;		block, err := aes.NewCipher([]byte("0123456789abcdef"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aead, err := cipher.NewGCM(block)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// IMPORTANT: If you must fix this test, then all previously encrypted data from previously compiled versions is broken unless you hardcode the nonce size to 12
0000000000000000000000000000000000000000;;		if aead.NonceSize() != 12 {
0000000000000000000000000000000000000000;;			t.Fatalf("The underlying Golang crypto size has changed, old version of AES on disk will not be readable unless the AES implementation is changed to hardcode nonce size.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGCMKeyRotation(t *testing.T) {
0000000000000000000000000000000000000000;;		testErr := fmt.Errorf("test error")
0000000000000000000000000000000000000000;;		block1, err := aes.NewCipher([]byte("abcdefghijklmnop"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block2, err := aes.NewCipher([]byte("0123456789abcdef"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(testErr,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewGCMTransformer(block1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewGCMTransformer(block2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		out, err := p.TransformToStorage([]byte("firstvalue"), context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !bytes.HasPrefix(out, []byte("first:")) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected prefix: %q", out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		from, stale, err := p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stale || !bytes.Equal([]byte("firstvalue"), from) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify changing the context fails storage
0000000000000000000000000000000000000000;;		from, stale, err = p.TransformFromStorage(out, value.DefaultContext([]byte("incorrect_context")))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected unauthenticated data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reverse the order, use the second key
0000000000000000000000000000000000000000;;		p = value.NewPrefixTransformers(testErr,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewGCMTransformer(block2)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewGCMTransformer(block1)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		from, stale, err = p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stale || !bytes.Equal([]byte("firstvalue"), from) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCBCKeyRotation(t *testing.T) {
0000000000000000000000000000000000000000;;		testErr := fmt.Errorf("test error")
0000000000000000000000000000000000000000;;		block1, err := aes.NewCipher([]byte("abcdefghijklmnop"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block2, err := aes.NewCipher([]byte("0123456789abcdef"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(testErr,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewCBCTransformer(block1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewCBCTransformer(block2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		out, err := p.TransformToStorage([]byte("firstvalue"), context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !bytes.HasPrefix(out, []byte("first:")) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected prefix: %q", out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		from, stale, err := p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stale || !bytes.Equal([]byte("firstvalue"), from) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify changing the context fails storage
0000000000000000000000000000000000000000;;		from, stale, err = p.TransformFromStorage(out, value.DefaultContext([]byte("incorrect_context")))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("CBC mode does not support authentication: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reverse the order, use the second key
0000000000000000000000000000000000000000;;		p = value.NewPrefixTransformers(testErr,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewCBCTransformer(block2)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewCBCTransformer(block1)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		from, stale, err = p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stale || !bytes.Equal([]byte("firstvalue"), from) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkGCMRead_16_1024(b *testing.B)        { benchmarkGCMRead(b, 16, 1024, false) }
0000000000000000000000000000000000000000;;	func BenchmarkGCMRead_32_1024(b *testing.B)        { benchmarkGCMRead(b, 32, 1024, false) }
0000000000000000000000000000000000000000;;	func BenchmarkGCMRead_32_16384(b *testing.B)       { benchmarkGCMRead(b, 32, 16384, false) }
0000000000000000000000000000000000000000;;	func BenchmarkGCMRead_32_16384_Stale(b *testing.B) { benchmarkGCMRead(b, 32, 16384, true) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkGCMWrite_16_1024(b *testing.B)  { benchmarkGCMWrite(b, 16, 1024) }
0000000000000000000000000000000000000000;;	func BenchmarkGCMWrite_32_1024(b *testing.B)  { benchmarkGCMWrite(b, 32, 1024) }
0000000000000000000000000000000000000000;;	func BenchmarkGCMWrite_32_16384(b *testing.B) { benchmarkGCMWrite(b, 32, 16384) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkGCMRead(b *testing.B, keyLength int, valueLength int, stale bool) {
0000000000000000000000000000000000000000;;		block1, err := aes.NewCipher(bytes.Repeat([]byte("a"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block2, err := aes.NewCipher(bytes.Repeat([]byte("b"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewGCMTransformer(block1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewGCMTransformer(block2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;		v := bytes.Repeat([]byte("0123456789abcdef"), valueLength/16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := p.TransformToStorage(v, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// reverse the key order if stale
0000000000000000000000000000000000000000;;		if stale {
0000000000000000000000000000000000000000;;			p = value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;				value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewGCMTransformer(block1)},
0000000000000000000000000000000000000000;;				value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewGCMTransformer(block2)},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			from, stale, err := p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stale {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkGCMWrite(b *testing.B, keyLength int, valueLength int) {
0000000000000000000000000000000000000000;;		block1, err := aes.NewCipher(bytes.Repeat([]byte("a"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block2, err := aes.NewCipher(bytes.Repeat([]byte("b"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewGCMTransformer(block1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewGCMTransformer(block2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;		v := bytes.Repeat([]byte("0123456789abcdef"), valueLength/16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			_, err := p.TransformToStorage(v, context)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkCBCRead_32_1024(b *testing.B)        { benchmarkCBCRead(b, 32, 1024, false) }
0000000000000000000000000000000000000000;;	func BenchmarkCBCRead_32_16384(b *testing.B)       { benchmarkCBCRead(b, 32, 16384, false) }
0000000000000000000000000000000000000000;;	func BenchmarkCBCRead_32_16384_Stale(b *testing.B) { benchmarkCBCRead(b, 32, 16384, true) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkCBCWrite_32_1024(b *testing.B)  { benchmarkCBCWrite(b, 32, 1024) }
0000000000000000000000000000000000000000;;	func BenchmarkCBCWrite_32_16384(b *testing.B) { benchmarkCBCWrite(b, 32, 16384) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkCBCRead(b *testing.B, keyLength int, valueLength int, stale bool) {
0000000000000000000000000000000000000000;;		block1, err := aes.NewCipher(bytes.Repeat([]byte("a"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block2, err := aes.NewCipher(bytes.Repeat([]byte("b"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewCBCTransformer(block1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewCBCTransformer(block2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;		v := bytes.Repeat([]byte("0123456789abcdef"), valueLength/16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := p.TransformToStorage(v, context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// reverse the key order if stale
0000000000000000000000000000000000000000;;		if stale {
0000000000000000000000000000000000000000;;			p = value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;				value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewCBCTransformer(block1)},
0000000000000000000000000000000000000000;;				value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewCBCTransformer(block2)},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			from, stale, err := p.TransformFromStorage(out, context)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stale {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected data: %t %q", stale, from)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkCBCWrite(b *testing.B, keyLength int, valueLength int) {
0000000000000000000000000000000000000000;;		block1, err := aes.NewCipher(bytes.Repeat([]byte("a"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block2, err := aes.NewCipher(bytes.Repeat([]byte("b"), keyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			b.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := value.NewPrefixTransformers(nil,
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("first:"), Transformer: NewCBCTransformer(block1)},
0000000000000000000000000000000000000000;;			value.PrefixTransformer{Prefix: []byte("second:"), Transformer: NewCBCTransformer(block2)},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := value.DefaultContext([]byte("authenticated_data"))
0000000000000000000000000000000000000000;;		v := bytes.Repeat([]byte("0123456789abcdef"), valueLength/16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			_, err := p.TransformToStorage(v, context)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		lengths := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 128, 1024}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aes16block, err := aes.NewCipher([]byte(bytes.Repeat([]byte("a"), 16)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aes24block, err := aes.NewCipher([]byte(bytes.Repeat([]byte("b"), 24)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aes32block, err := aes.NewCipher([]byte(bytes.Repeat([]byte("c"), 32)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name    string
0000000000000000000000000000000000000000;;			context value.Context
0000000000000000000000000000000000000000;;			t       value.Transformer
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{name: "GCM 16 byte key", t: NewGCMTransformer(aes16block)},
0000000000000000000000000000000000000000;;			{name: "GCM 24 byte key", t: NewGCMTransformer(aes24block)},
0000000000000000000000000000000000000000;;			{name: "GCM 32 byte key", t: NewGCMTransformer(aes32block)},
0000000000000000000000000000000000000000;;			{name: "CBC 32 byte key", t: NewCBCTransformer(aes32block)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			t.Run(tt.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				context := tt.context
0000000000000000000000000000000000000000;;				if context == nil {
0000000000000000000000000000000000000000;;					context = value.DefaultContext("")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, l := range lengths {
0000000000000000000000000000000000000000;;					data := make([]byte, l)
0000000000000000000000000000000000000000;;					if _, err := io.ReadFull(rand.Reader, data); err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("unable to read sufficient random bytes: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					original := append([]byte{}, data...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ciphertext, err := tt.t.TransformToStorage(data, context)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("TransformToStorage error = %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					result, stale, err := tt.t.TransformFromStorage(ciphertext, context)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("TransformFromStorage error = %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if stale {
0000000000000000000000000000000000000000;;						t.Errorf("unexpected stale output")
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case l == 0:
0000000000000000000000000000000000000000;;						if len(result) != 0 {
0000000000000000000000000000000000000000;;							t.Errorf("Round trip failed len=%d\noriginal:\n%s\nresult:\n%s", l, hex.Dump(original), hex.Dump(result))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case !reflect.DeepEqual(original, result):
0000000000000000000000000000000000000000;;						t.Errorf("Round trip failed len=%d\noriginal:\n%s\nresult:\n%s", l, hex.Dump(original), hex.Dump(result))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
