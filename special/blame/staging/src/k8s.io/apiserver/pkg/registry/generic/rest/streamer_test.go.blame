0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c7be49699ff00d908a19b38e7497e3cc588fd980;pkg/registry/generic/rest/streamer_test.go[pkg/registry/generic/rest/streamer_test.go][staging/src/k8s.io/apiserver/pkg/registry/generic/rest/streamer_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInputStreamReader(t *testing.T) {
0000000000000000000000000000000000000000;;		resultString := "Test output"
0000000000000000000000000000000000000000;;		s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			w.Write([]byte(resultString))
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;		u, err := url.Parse(s.URL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error parsing server URL: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		streamer := &LocationStreamer{
0000000000000000000000000000000000000000;;			Location: u,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readCloser, _, _, err := streamer.InputStream("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when getting stream: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readCloser.Close()
0000000000000000000000000000000000000000;;		result, err := ioutil.ReadAll(readCloser)
0000000000000000000000000000000000000000;;		if string(result) != resultString {
0000000000000000000000000000000000000000;;			t.Errorf("Stream content does not match. Got: %s. Expected: %s.", string(result), resultString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInputStreamNullLocation(t *testing.T) {
0000000000000000000000000000000000000000;;		streamer := &LocationStreamer{
0000000000000000000000000000000000000000;;			Location: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readCloser, _, _, err := streamer.InputStream("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when getting stream with null location: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if readCloser != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected stream to be nil. Got: %#v", readCloser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testTransport struct {
0000000000000000000000000000000000000000;;		body string
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tt *testTransport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		r := bufio.NewReader(bytes.NewBufferString(tt.body))
0000000000000000000000000000000000000000;;		return http.ReadResponse(r, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeTransport(mime, message string) http.RoundTripper {
0000000000000000000000000000000000000000;;		content := fmt.Sprintf("HTTP/1.1 200 OK\nContent-Type: %s\n\n%s", mime, message)
0000000000000000000000000000000000000000;;		return &testTransport{body: content}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInputStreamContentType(t *testing.T) {
0000000000000000000000000000000000000000;;		location, _ := url.Parse("http://www.example.com")
0000000000000000000000000000000000000000;;		streamer := &LocationStreamer{
0000000000000000000000000000000000000000;;			Location:  location,
0000000000000000000000000000000000000000;;			Transport: fakeTransport("application/json", "hello world"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readCloser, _, contentType, err := streamer.InputStream("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when getting stream: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readCloser.Close()
0000000000000000000000000000000000000000;;		if contentType != "application/json" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected content type. Got: %s. Expected: application/json", contentType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInputStreamTransport(t *testing.T) {
0000000000000000000000000000000000000000;;		message := "hello world"
0000000000000000000000000000000000000000;;		location, _ := url.Parse("http://www.example.com")
0000000000000000000000000000000000000000;;		streamer := &LocationStreamer{
0000000000000000000000000000000000000000;;			Location:  location,
0000000000000000000000000000000000000000;;			Transport: fakeTransport("text/plain", message),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readCloser, _, _, err := streamer.InputStream("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when getting stream: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readCloser.Close()
0000000000000000000000000000000000000000;;		result, err := ioutil.ReadAll(readCloser)
0000000000000000000000000000000000000000;;		if string(result) != message {
0000000000000000000000000000000000000000;;			t.Errorf("Stream content does not match. Got: %s. Expected: %s.", string(result), message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeInternalServerErrorTransport(mime, message string) http.RoundTripper {
0000000000000000000000000000000000000000;;		content := fmt.Sprintf("HTTP/1.1 500 \"Internal Server Error\"\nContent-Type: %s\n\n%s", mime, message)
0000000000000000000000000000000000000000;;		return &testTransport{body: content}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInputStreamInternalServerErrorTransport(t *testing.T) {
0000000000000000000000000000000000000000;;		message := "Pod is in PodPending"
0000000000000000000000000000000000000000;;		location, _ := url.Parse("http://www.example.com")
0000000000000000000000000000000000000000;;		streamer := &LocationStreamer{
0000000000000000000000000000000000000000;;			Location:        location,
0000000000000000000000000000000000000000;;			Transport:       fakeInternalServerErrorTransport("text/plain", message),
0000000000000000000000000000000000000000;;			ResponseChecker: NewGenericHttpResponseChecker(schema.GroupResource{}, ""),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedError := errors.NewInternalError(fmt.Errorf("%s", message))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, _, err := streamer.InputStream("", "")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(err, expectedError) {
0000000000000000000000000000000000000000;;			t.Errorf("StreamInternalServerError does not match. Got: %s. Expected: %s.", err, expectedError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
