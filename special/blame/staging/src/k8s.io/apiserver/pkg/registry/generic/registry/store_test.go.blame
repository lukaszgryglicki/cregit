0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a5d0a3980ea92b4321a18ea3ec1c22f1a717fc1d;pkg/registry/generic/etcd_test.go[pkg/registry/generic/etcd_test.go][staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/selection"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		etcdstorage "k8s.io/apiserver/pkg/storage/etcd"
0000000000000000000000000000000000000000;;		etcdtesting "k8s.io/apiserver/pkg/storage/etcd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/names"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend/factory"
0000000000000000000000000000000000000000;;		storagetesting "k8s.io/apiserver/pkg/storage/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var scheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;	var codecs = serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, metav1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		example.AddToScheme(scheme)
0000000000000000000000000000000000000000;;		examplev1.AddToScheme(scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testGracefulStrategy struct {
0000000000000000000000000000000000000000;;		testRESTStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t testGracefulStrategy) CheckGracefulDelete(ctx genericapirequest.Context, obj runtime.Object, options *metav1.DeleteOptions) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ rest.RESTGracefulDeleteStrategy = testGracefulStrategy{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testOrphanDeleteStrategy struct {
0000000000000000000000000000000000000000;;		*testRESTStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *testOrphanDeleteStrategy) DefaultGarbageCollectionPolicy() rest.GarbageCollectionPolicy {
0000000000000000000000000000000000000000;;		return rest.OrphanDependents
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testRESTStrategy struct {
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;		names.NameGenerator
0000000000000000000000000000000000000000;;		namespaceScoped          bool
0000000000000000000000000000000000000000;;		allowCreateOnUpdate      bool
0000000000000000000000000000000000000000;;		allowUnconditionalUpdate bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) NamespaceScoped() bool          { return t.namespaceScoped }
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) AllowCreateOnUpdate() bool      { return t.allowCreateOnUpdate }
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) AllowUnconditionalUpdate() bool { return t.allowUnconditionalUpdate }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) PrepareForCreate(ctx genericapirequest.Context, obj runtime.Object) {
0000000000000000000000000000000000000000;;		metaObj, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels := metaObj.GetLabels()
0000000000000000000000000000000000000000;;		if labels == nil {
0000000000000000000000000000000000000000;;			labels = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels["prepare_create"] = "true"
0000000000000000000000000000000000000000;;		metaObj.SetLabels(labels)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {}
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) Validate(ctx genericapirequest.Context, obj runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (t *testRESTStrategy) Canonicalize(obj runtime.Object) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTestGenericStoreRegistry(t *testing.T) (factory.DestroyFunc, *Store) {
0000000000000000000000000000000000000000;;		return newTestGenericStoreRegistry(t, scheme, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodAttrs(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;		pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;		return labels.Set{"name": pod.ObjectMeta.Name}, nil, pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchPodName returns selection predicate that matches any pod with name in the set.
0000000000000000000000000000000000000000;;	// Makes testing simpler.
0000000000000000000000000000000000000000;;	func matchPodName(names ...string) storage.SelectionPredicate {
0000000000000000000000000000000000000000;;		// Note: even if pod name is a field, we have to use labels,
0000000000000000000000000000000000000000;;		// because field selector doesn't support "IN" operator.
0000000000000000000000000000000000000000;;		l, err := labels.NewRequirement("name", selection.In, names)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("Labels requirement must validate successfully")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return storage.SelectionPredicate{
0000000000000000000000000000000000000000;;			Label:    labels.Everything().Add(*l),
0000000000000000000000000000000000000000;;			Field:    fields.Everything(),
0000000000000000000000000000000000000000;;			GetAttrs: getPodAttrs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func matchEverything() storage.SelectionPredicate {
0000000000000000000000000000000000000000;;		return storage.SelectionPredicate{
0000000000000000000000000000000000000000;;			Label: labels.Everything(),
0000000000000000000000000000000000000000;;			Field: fields.Everything(),
0000000000000000000000000000000000000000;;			GetAttrs: func(obj runtime.Object) (label labels.Set, field fields.Set, uninitialized bool, err error) {
0000000000000000000000000000000000000000;;				return nil, nil, false, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreList(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "bar"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podB := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		noNamespaceContext := genericapirequest.NewContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := map[string]struct {
0000000000000000000000000000000000000000;;			in      *example.PodList
0000000000000000000000000000000000000000;;			m       storage.SelectionPredicate
0000000000000000000000000000000000000000;;			out     runtime.Object
0000000000000000000000000000000000000000;;			context genericapirequest.Context
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"notFound": {
0000000000000000000000000000000000000000;;				in:  nil,
0000000000000000000000000000000000000000;;				m:   matchEverything(),
0000000000000000000000000000000000000000;;				out: &example.PodList{Items: []example.Pod{}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"normal": {
0000000000000000000000000000000000000000;;				in:  &example.PodList{Items: []example.Pod{*podA, *podB}},
0000000000000000000000000000000000000000;;				m:   matchEverything(),
0000000000000000000000000000000000000000;;				out: &example.PodList{Items: []example.Pod{*podA, *podB}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"normalFiltered": {
0000000000000000000000000000000000000000;;				in:  &example.PodList{Items: []example.Pod{*podA, *podB}},
0000000000000000000000000000000000000000;;				m:   matchPodName("foo"),
0000000000000000000000000000000000000000;;				out: &example.PodList{Items: []example.Pod{*podB}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"normalFilteredNoNamespace": {
0000000000000000000000000000000000000000;;				in:      &example.PodList{Items: []example.Pod{*podA, *podB}},
0000000000000000000000000000000000000000;;				m:       matchPodName("foo"),
0000000000000000000000000000000000000000;;				out:     &example.PodList{Items: []example.Pod{*podB}},
0000000000000000000000000000000000000000;;				context: noNamespaceContext,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"normalFilteredMatchMultiple": {
0000000000000000000000000000000000000000;;				in:  &example.PodList{Items: []example.Pod{*podA, *podB}},
0000000000000000000000000000000000000000;;				m:   matchPodName("foo", "makeMatchSingleReturnFalse"),
0000000000000000000000000000000000000000;;				out: &example.PodList{Items: []example.Pod{*podB}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, item := range table {
0000000000000000000000000000000000000000;;			ctx := testContext
0000000000000000000000000000000000000000;;			if item.context != nil {
0000000000000000000000000000000000000000;;				ctx = item.context
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if item.in != nil {
0000000000000000000000000000000000000000;;				if err := storagetesting.CreateList("/pods", registry.Storage, item.in); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			list, err := registry.ListPredicate(ctx, item.m, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// DeepDerivative e,a is needed here b/c the storage layer sets ResourceVersion
0000000000000000000000000000000000000000;;			if e, a := item.out, list; !apiequality.Semantic.DeepDerivative(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Expected %#v, got %#v", name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			destroyFunc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestStoreListResourceVersion tests that if List with ResourceVersion > 0, it will wait until
0000000000000000000000000000000000000000;;	// the results are as fresh as given version.
0000000000000000000000000000000000000000;;	func TestStoreListResourceVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		fooPod := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		barPod := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "bar"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		destroyFunc, registry := newTestGenericStoreRegistry(t, scheme, true)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := registry.Create(ctx, fooPod, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versioner := etcdstorage.APIObjectVersioner{}
0000000000000000000000000000000000000000;;		rev, err := versioner.ObjectResourceVersion(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitListCh := make(chan runtime.Object, 1)
0000000000000000000000000000000000000000;;		go func(listRev uint64) {
0000000000000000000000000000000000000000;;			option := &metainternalversion.ListOptions{ResourceVersion: strconv.FormatUint(listRev, 10)}
0000000000000000000000000000000000000000;;			// It will wait until we create the second pod.
0000000000000000000000000000000000000000;;			l, err := registry.List(ctx, option)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				close(waitListCh)
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			waitListCh <- l
0000000000000000000000000000000000000000;;		}(rev + 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(500 * time.Millisecond):
0000000000000000000000000000000000000000;;		case l := <-waitListCh:
0000000000000000000000000000000000000000;;			t.Fatalf("expected waiting, but get %#v", l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := registry.Create(ctx, barPod, false); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Fatalf("timeout after %v", wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		case l, ok := <-waitListCh:
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pl := l.(*example.PodList).Items
0000000000000000000000000000000000000000;;			if len(pl) != 2 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected get 2 items, but got %d", len(pl))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreCreate(t *testing.T) {
0000000000000000000000000000000000000000;;		gracefulPeriod := int64(50)
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podB := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine2"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;		// re-define delete strategy to have graceful delete capability
0000000000000000000000000000000000000000;;		defaultDeleteStrategy := testRESTStrategy{scheme, names.SimpleNameGenerator, true, false, true}
0000000000000000000000000000000000000000;;		registry.DeleteStrategy = testGracefulStrategy{defaultDeleteStrategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the object
0000000000000000000000000000000000000000;;		objA, err := registry.Create(testContext, podA, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the object
0000000000000000000000000000000000000000;;		checkobj, err := registry.Get(testContext, podA.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify objects are equal
0000000000000000000000000000000000000000;;		if e, a := objA, checkobj; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now try to create the second pod
0000000000000000000000000000000000000000;;		_, err = registry.Create(testContext, podB, false)
0000000000000000000000000000000000000000;;		if !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify graceful delete capability is defined
0000000000000000000000000000000000000000;;		_, ok := registry.DeleteStrategy.(rest.RESTGracefulDeleteStrategy)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("No graceful capability set.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now delete pod with graceful period set
0000000000000000000000000000000000000000;;		delOpts := &metav1.DeleteOptions{GracePeriodSeconds: &gracefulPeriod}
0000000000000000000000000000000000000000;;		_, _, err = registry.Delete(testContext, podA.Name, delOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to delete pod gracefully. Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to create before graceful deletion period is over
0000000000000000000000000000000000000000;;		_, err = registry.Create(testContext, podA, false)
0000000000000000000000000000000000000000;;		if err == nil || !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected 'already exists' error from storage, but got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check the 'alredy exists' msg was edited
0000000000000000000000000000000000000000;;		msg := &err.(*errors.StatusError).ErrStatus.Message
0000000000000000000000000000000000000000;;		if !strings.Contains(*msg, "object is being deleted:") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error without the 'object is being deleted:' in message: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isPendingInitialization(obj metav1.Object) bool {
0000000000000000000000000000000000000000;;		return obj.GetInitializers() != nil && obj.GetInitializers().Result == nil && len(obj.GetInitializers().Pending) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasInitializers(obj metav1.Object, expected ...string) bool {
0000000000000000000000000000000000000000;;		if !isPendingInitialization(obj) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(expected) != len(obj.GetInitializers().Pending) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, init := range obj.GetInitializers().Pending {
0000000000000000000000000000000000000000;;			if init.Name != expected[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isFailedInitialization(obj metav1.Object) bool {
0000000000000000000000000000000000000000;;		return obj.GetInitializers() != nil && obj.GetInitializers().Result != nil && obj.GetInitializers().Result.Status == metav1.StatusFailure
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isInitialized(obj metav1.Object) bool {
0000000000000000000000000000000000000000;;		return obj.GetInitializers() == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreCreateInitialized(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "foo", Namespace: "test",
0000000000000000000000000000000000000000;;				Initializers: &metav1.Initializers{
0000000000000000000000000000000000000000;;					Pending: []metav1.Initializer{{Name: "Test"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		chObserver := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// simulate a background initializer that initializes the object
0000000000000000000000000000000000000000;;		early := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(ch)
0000000000000000000000000000000000000000;;			w, err := registry.Watch(ctx, &metainternalversion.ListOptions{
0000000000000000000000000000000000000000;;				IncludeUninitialized: true,
0000000000000000000000000000000000000000;;				Watch:                true,
0000000000000000000000000000000000000000;;				FieldSelector:        fields.OneTermEqualSelector("metadata.name", "foo"),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer w.Stop()
0000000000000000000000000000000000000000;;			event := <-w.ResultChan()
0000000000000000000000000000000000000000;;			pod := event.Object.(*example.Pod)
0000000000000000000000000000000000000000;;			if event.Type != watch.Added || !hasInitializers(pod, "Test") {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected event: %s %#v", event.Type, event.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-early:
0000000000000000000000000000000000000000;;				t.Fatalf("CreateInitialized should not have returned")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod.Initializers = nil
0000000000000000000000000000000000000000;;			updated, _, err := registry.Update(ctx, podA.Name, rest.DefaultUpdatedObjectInfo(pod, scheme))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod = updated.(*example.Pod)
0000000000000000000000000000000000000000;;			if !isInitialized(pod) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected update: %#v", pod.Initializers)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			event = <-w.ResultChan()
0000000000000000000000000000000000000000;;			if event.Type != watch.Modified || !isInitialized(event.Object.(*example.Pod)) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected event: %s %#v", event.Type, event.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a background worker that should only observe the final creation
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(chObserver)
0000000000000000000000000000000000000000;;			w, err := registry.Watch(ctx, &metainternalversion.ListOptions{
0000000000000000000000000000000000000000;;				IncludeUninitialized: false,
0000000000000000000000000000000000000000;;				Watch:                true,
0000000000000000000000000000000000000000;;				FieldSelector:        fields.OneTermEqualSelector("metadata.name", "foo"),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			event := <-w.ResultChan()
0000000000000000000000000000000000000000;;			pod := event.Object.(*example.Pod)
0000000000000000000000000000000000000000;;			if event.Type != watch.Added || !isInitialized(pod) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected event: %s %#v", event.Type, event.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the object
0000000000000000000000000000000000000000;;		objA, err := registry.Create(ctx, podA, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// signal that we're now waiting, then wait for both observers to see
0000000000000000000000000000000000000000;;		// the result of the create.
0000000000000000000000000000000000000000;;		early <- struct{}{}
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;		<-chObserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the object
0000000000000000000000000000000000000000;;		checkobj, err := registry.Get(ctx, podA.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify objects are equal
0000000000000000000000000000000000000000;;		if e, a := objA, checkobj; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreCreateInitializedFailed(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "foo", Namespace: "test",
0000000000000000000000000000000000000000;;				Initializers: &metav1.Initializers{
0000000000000000000000000000000000000000;;					Pending: []metav1.Initializer{{Name: "Test"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			w, err := registry.Watch(ctx, &metainternalversion.ListOptions{
0000000000000000000000000000000000000000;;				IncludeUninitialized: true,
0000000000000000000000000000000000000000;;				Watch:                true,
0000000000000000000000000000000000000000;;				FieldSelector:        fields.OneTermEqualSelector("metadata.name", "foo"),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			event := <-w.ResultChan()
0000000000000000000000000000000000000000;;			pod := event.Object.(*example.Pod)
0000000000000000000000000000000000000000;;			if event.Type != watch.Added || !hasInitializers(pod, "Test") {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected event: %s %#v", event.Type, event.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Initializers.Pending = nil
0000000000000000000000000000000000000000;;			pod.Initializers.Result = &metav1.Status{Status: metav1.StatusFailure, Code: 403, Reason: metav1.StatusReasonForbidden, Message: "induced failure"}
0000000000000000000000000000000000000000;;			updated, _, err := registry.Update(ctx, podA.Name, rest.DefaultUpdatedObjectInfo(pod, scheme))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod = updated.(*example.Pod)
0000000000000000000000000000000000000000;;			if !isFailedInitialization(pod) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected update: %#v", pod.Initializers)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			event = <-w.ResultChan()
0000000000000000000000000000000000000000;;			if event.Type != watch.Modified || !isFailedInitialization(event.Object.(*example.Pod)) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected event: %s %#v", event.Type, event.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			event = <-w.ResultChan()
0000000000000000000000000000000000000000;;			if event.Type != watch.Deleted || !isFailedInitialization(event.Object.(*example.Pod)) {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected event: %s %#v", event.Type, event.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Stop()
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the object
0000000000000000000000000000000000000000;;		_, err := registry.Create(ctx, podA, false)
0000000000000000000000000000000000000000;;		if !errors.IsForbidden(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %#v", err.(errors.APIStatus).Status())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err.(errors.APIStatus).Status().Message != "induced failure" {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the object
0000000000000000000000000000000000000000;;		_, err = registry.Get(ctx, podA.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateAndVerify(t *testing.T, ctx genericapirequest.Context, registry *Store, pod *example.Pod) bool {
0000000000000000000000000000000000000000;;		obj, _, err := registry.Update(ctx, pod.Name, rest.DefaultUpdatedObjectInfo(pod, scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		checkObj, err := registry.Get(ctx, pod.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := obj, checkObj; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podB := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine2"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podAWithResourceVersion := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Namespace: "test", ResourceVersion: "7"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test1 try to update a non-existing node
0000000000000000000000000000000000000000;;		_, _, err := registry.Update(testContext, podA.Name, rest.DefaultUpdatedObjectInfo(podA, scheme))
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test2 createIfNotFound and verify
0000000000000000000000000000000000000000;;		registry.UpdateStrategy.(*testRESTStrategy).allowCreateOnUpdate = true
0000000000000000000000000000000000000000;;		if !updateAndVerify(t, testContext, registry, podA) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error updating podA")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		registry.UpdateStrategy.(*testRESTStrategy).allowCreateOnUpdate = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test3 outofDate
0000000000000000000000000000000000000000;;		_, _, err = registry.Update(testContext, podAWithResourceVersion.Name, rest.DefaultUpdatedObjectInfo(podAWithResourceVersion, scheme))
0000000000000000000000000000000000000000;;		if !errors.IsConflict(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error updating podAWithResourceVersion: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test4 normal update and verify
0000000000000000000000000000000000000000;;		if !updateAndVerify(t, testContext, registry, podB) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error updating podB")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test5 unconditional update
0000000000000000000000000000000000000000;;		// NOTE: The logic for unconditional updates doesn't make sense to me, and imho should be removed.
0000000000000000000000000000000000000000;;		// doUnconditionalUpdate := resourceVersion == 0 && e.UpdateStrategy.AllowUnconditionalUpdate()
0000000000000000000000000000000000000000;;		// ^^ That condition can *never be true due to the creation of root objects.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// registry.UpdateStrategy.(*testRESTStrategy).allowUnconditionalUpdate = true
0000000000000000000000000000000000000000;;		// updateAndVerify(t, testContext, registry, podAWithResourceVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNoOpUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newPod := func() *example.Pod {
0000000000000000000000000000000000000000;;			return &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;					Name:      "foo",
0000000000000000000000000000000000000000;;					Labels:    map[string]string{"prepare_create": "true"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var createResult runtime.Object
0000000000000000000000000000000000000000;;		if createResult, err = registry.Create(genericapirequest.NewDefaultContext(), newPod(), false); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdPod, err := registry.Get(genericapirequest.NewDefaultContext(), "foo", &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var updateResult runtime.Object
0000000000000000000000000000000000000000;;		p := newPod()
0000000000000000000000000000000000000000;;		if updateResult, _, err = registry.Update(genericapirequest.NewDefaultContext(), p.Name, rest.DefaultUpdatedObjectInfo(p, scheme)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check whether we do not return empty result on no-op update.
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(createResult, updateResult) {
0000000000000000000000000000000000000000;;			t.Errorf("no-op update should return a correct value, got: %#v", updateResult)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedPod, err := registry.Get(genericapirequest.NewDefaultContext(), "foo", &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createdMeta, err := meta.Accessor(createdPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		updatedMeta, err := meta.Accessor(updatedPod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if createdMeta.GetResourceVersion() != updatedMeta.GetResourceVersion() {
0000000000000000000000000000000000000000;;			t.Errorf("no-op update should be ignored and not written to etcd")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Add a test to check no-op update if we have object with ResourceVersion
0000000000000000000000000000000000000000;;	// already stored in etcd. Currently there is no easy way to store object with
0000000000000000000000000000000000000000;;	// ResourceVersion in etcd.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testPodExport struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t testPodExport) Export(ctx genericapirequest.Context, obj runtime.Object, exact bool) error {
0000000000000000000000000000000000000000;;		pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;		if pod.Labels == nil {
0000000000000000000000000000000000000000;;			pod.Labels = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod.Labels["exported"] = "true"
0000000000000000000000000000000000000000;;		pod.Labels["exact"] = strconv.FormatBool(exact)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreCustomExport(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "test",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Labels:    map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		registry.ExportStrategy = testPodExport{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		registry.UpdateStrategy.(*testRESTStrategy).allowCreateOnUpdate = true
0000000000000000000000000000000000000000;;		if !updateAndVerify(t, testContext, registry, &podA) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error updating podA")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := registry.Export(testContext, podA.Name, metav1.ExportOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exportedPod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;		if exportedPod.Labels["exported"] != "true" {
0000000000000000000000000000000000000000;;			t.Errorf("expected: exported->true, found: %s", exportedPod.Labels["exported"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exportedPod.Labels["exact"] != "false" {
0000000000000000000000000000000000000000;;			t.Errorf("expected: exact->false, found: %s", exportedPod.Labels["exact"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exportedPod.Labels["prepare_create"] != "true" {
0000000000000000000000000000000000000000;;			t.Errorf("expected: prepare_create->true, found: %s", exportedPod.Labels["prepare_create"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(exportedPod.Labels, "exported")
0000000000000000000000000000000000000000;;		delete(exportedPod.Labels, "exact")
0000000000000000000000000000000000000000;;		delete(exportedPod.Labels, "prepare_create")
0000000000000000000000000000000000000000;;		exportObjectMeta(&podA.ObjectMeta, false)
0000000000000000000000000000000000000000;;		podA.Spec = exportedPod.Spec
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(&podA, exportedPod) {
0000000000000000000000000000000000000000;;			t.Errorf("expected:\n%v\nsaw:\n%v\n", &podA, exportedPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreBasicExport(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "test",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Labels:    map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec:   example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			Status: example.PodStatus{HostIP: "1.2.3.4"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		registry.UpdateStrategy.(*testRESTStrategy).allowCreateOnUpdate = true
0000000000000000000000000000000000000000;;		if !updateAndVerify(t, testContext, registry, &podA) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error updating podA")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := registry.Export(testContext, podA.Name, metav1.ExportOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exportedPod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;		if exportedPod.Labels["prepare_create"] != "true" {
0000000000000000000000000000000000000000;;			t.Errorf("expected: prepare_create->true, found: %s", exportedPod.Labels["prepare_create"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(exportedPod.Labels, "prepare_create")
0000000000000000000000000000000000000000;;		exportObjectMeta(&podA.ObjectMeta, false)
0000000000000000000000000000000000000000;;		podA.Spec = exportedPod.Spec
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(&podA, exportedPod) {
0000000000000000000000000000000000000000;;			t.Errorf("expected:\n%v\nsaw:\n%v\n", &podA, exportedPod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreGet(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Namespace: "test", Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := registry.Get(testContext, podA.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		registry.UpdateStrategy.(*testRESTStrategy).allowCreateOnUpdate = true
0000000000000000000000000000000000000000;;		if !updateAndVerify(t, testContext, registry, podA) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error updating podA")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo"},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test failure condition
0000000000000000000000000000000000000000;;		_, _, err := registry.Delete(testContext, podA.Name, nil)
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create pod
0000000000000000000000000000000000000000;;		_, err = registry.Create(testContext, podA, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete object
0000000000000000000000000000000000000000;;		_, wasDeleted, err := registry.Delete(testContext, podA.Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, pod %s should have been deleted immediately", podA.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to get a item which should be deleted
0000000000000000000000000000000000000000;;		_, err = registry.Get(testContext, podA.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreDeleteUninitialized(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Initializers: &metav1.Initializers{Pending: []metav1.Initializer{{Name: "Testing"}}}},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test failure condition
0000000000000000000000000000000000000000;;		_, _, err := registry.Delete(testContext, podA.Name, nil)
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create pod
0000000000000000000000000000000000000000;;		_, err = registry.Create(testContext, podA, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete object
0000000000000000000000000000000000000000;;		_, wasDeleted, err := registry.Delete(testContext, podA.Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, pod %s should have been deleted immediately", podA.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to get a item which should be deleted
0000000000000000000000000000000000000000;;		_, err = registry.Get(testContext, podA.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestGracefulStoreCanDeleteIfExistingGracePeriodZero tests recovery from
0000000000000000000000000000000000000000;;	// race condition where the graceful delete is unable to complete
0000000000000000000000000000000000000000;;	// in prior operation, but the pod remains with deletion timestamp
0000000000000000000000000000000000000000;;	// and grace period set to 0.
0000000000000000000000000000000000000000;;	func TestGracefulStoreCanDeleteIfExistingGracePeriodZero(t *testing.T) {
0000000000000000000000000000000000000000;;		deletionTimestamp := metav1.NewTime(time.Now())
0000000000000000000000000000000000000000;;		deletionGracePeriodSeconds := int64(0)
0000000000000000000000000000000000000000;;		initialGeneration := int64(1)
0000000000000000000000000000000000000000;;		pod := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:                       "foo",
0000000000000000000000000000000000000000;;				Generation:                 initialGeneration,
0000000000000000000000000000000000000000;;				DeletionGracePeriodSeconds: &deletionGracePeriodSeconds,
0000000000000000000000000000000000000000;;				DeletionTimestamp:          &deletionTimestamp,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		registry.EnableGarbageCollection = false
0000000000000000000000000000000000000000;;		defaultDeleteStrategy := testRESTStrategy{scheme, names.SimpleNameGenerator, true, false, true}
0000000000000000000000000000000000000000;;		registry.DeleteStrategy = testGracefulStrategy{defaultDeleteStrategy}
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		graceful, gracefulPending, err := rest.BeforeDelete(registry.DeleteStrategy, testContext, pod, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if graceful {
0000000000000000000000000000000000000000;;			t.Fatalf("graceful should be false if object has DeletionTimestamp and DeletionGracePeriodSeconds is 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gracefulPending {
0000000000000000000000000000000000000000;;			t.Fatalf("gracefulPending should be false if object has DeletionTimestamp and DeletionGracePeriodSeconds is 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGracefulStoreHandleFinalizers(t *testing.T) {
0000000000000000000000000000000000000000;;		initialGeneration := int64(1)
0000000000000000000000000000000000000000;;		podWithFinalizer := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Finalizers: []string{"foo.com/x"}, Generation: initialGeneration},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		registry.EnableGarbageCollection = true
0000000000000000000000000000000000000000;;		defaultDeleteStrategy := testRESTStrategy{scheme, names.SimpleNameGenerator, true, false, true}
0000000000000000000000000000000000000000;;		registry.DeleteStrategy = testGracefulStrategy{defaultDeleteStrategy}
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;		// create pod
0000000000000000000000000000000000000000;;		_, err := registry.Create(testContext, podWithFinalizer, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete the pod with grace period=0, the pod should still exist because it has a finalizer
0000000000000000000000000000000000000000;;		_, wasDeleted, err := registry.Delete(testContext, podWithFinalizer.Name, metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, pod %s should not have been deleted immediately", podWithFinalizer.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = registry.Get(testContext, podWithFinalizer.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedPodWithFinalizer := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Finalizers: []string{"foo.com/x"}, ResourceVersion: podWithFinalizer.ObjectMeta.ResourceVersion},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err = registry.Update(testContext, updatedPodWithFinalizer.ObjectMeta.Name, rest.DefaultUpdatedObjectInfo(updatedPodWithFinalizer, scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the object should still exist, because it still has a finalizer
0000000000000000000000000000000000000000;;		_, err = registry.Get(testContext, podWithFinalizer.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podWithNoFinalizer := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: podWithFinalizer.ObjectMeta.ResourceVersion},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "anothermachine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err = registry.Update(testContext, podWithFinalizer.ObjectMeta.Name, rest.DefaultUpdatedObjectInfo(podWithNoFinalizer, scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the pod should be removed, because its finalizer is removed
0000000000000000000000000000000000000000;;		_, err = registry.Get(testContext, podWithFinalizer.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFailedInitializationStoreUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		initialGeneration := int64(1)
0000000000000000000000000000000000000000;;		podInitializing := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Initializers: &metav1.Initializers{Pending: []metav1.Initializer{{Name: "Test"}}}, Generation: initialGeneration},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		registry.EnableGarbageCollection = true
0000000000000000000000000000000000000000;;		defaultDeleteStrategy := testRESTStrategy{scheme, names.SimpleNameGenerator, true, false, true}
0000000000000000000000000000000000000000;;		registry.DeleteStrategy = testGracefulStrategy{defaultDeleteStrategy}
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create pod, view initializing
0000000000000000000000000000000000000000;;		obj, err := registry.Create(testContext, podInitializing, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := obj.(*example.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update the pod with initialization failure, the pod should be deleted
0000000000000000000000000000000000000000;;		pod.Initializers.Result = &metav1.Status{Status: metav1.StatusFailure}
0000000000000000000000000000000000000000;;		result, _, err := registry.Update(testContext, podInitializing.Name, rest.DefaultUpdatedObjectInfo(pod, scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = registry.Get(testContext, podInitializing.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err == nil || !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod = result.(*example.Pod)
0000000000000000000000000000000000000000;;		if pod.Initializers == nil || pod.Initializers.Result == nil || pod.Initializers.Result.Status != metav1.StatusFailure {
0000000000000000000000000000000000000000;;			t.Fatalf("Pod returned from update was not correct: %#v", pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNonGracefulStoreHandleFinalizers(t *testing.T) {
0000000000000000000000000000000000000000;;		initialGeneration := int64(1)
0000000000000000000000000000000000000000;;		podWithFinalizer := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Finalizers: []string{"foo.com/x"}, Generation: initialGeneration},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		registry.EnableGarbageCollection = true
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;		// create pod
0000000000000000000000000000000000000000;;		_, err := registry.Create(testContext, podWithFinalizer, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete object with nil delete options doesn't delete the object
0000000000000000000000000000000000000000;;		_, wasDeleted, err := registry.Delete(testContext, podWithFinalizer.Name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, pod %s should not have been deleted immediately", podWithFinalizer.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the object should still exist
0000000000000000000000000000000000000000;;		obj, err := registry.Get(testContext, podWithFinalizer.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podWithFinalizer, ok := obj.(*example.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if podWithFinalizer.ObjectMeta.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expect the object to have DeletionTimestamp set, but got %#v", podWithFinalizer.ObjectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if podWithFinalizer.ObjectMeta.DeletionGracePeriodSeconds == nil || *podWithFinalizer.ObjectMeta.DeletionGracePeriodSeconds != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expect the object to have 0 DeletionGracePeriodSecond, but got %#v", podWithFinalizer.ObjectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if podWithFinalizer.Generation <= initialGeneration {
0000000000000000000000000000000000000000;;			t.Errorf("Deletion didn't increase Generation.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedPodWithFinalizer := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", Finalizers: []string{"foo.com/x"}, ResourceVersion: podWithFinalizer.ObjectMeta.ResourceVersion},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err = registry.Update(testContext, updatedPodWithFinalizer.ObjectMeta.Name, rest.DefaultUpdatedObjectInfo(updatedPodWithFinalizer, scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the object should still exist, because it still has a finalizer
0000000000000000000000000000000000000000;;		obj, err = registry.Get(testContext, podWithFinalizer.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podWithFinalizer, ok = obj.(*example.Pod)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podWithNoFinalizer := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", ResourceVersion: podWithFinalizer.ObjectMeta.ResourceVersion},
0000000000000000000000000000000000000000;;			Spec:       example.PodSpec{NodeName: "anothermachine"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err = registry.Update(testContext, podWithFinalizer.ObjectMeta.Name, rest.DefaultUpdatedObjectInfo(podWithNoFinalizer, scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the pod should be removed, because its finalizer is removed
0000000000000000000000000000000000000000;;		_, err = registry.Get(testContext, podWithFinalizer.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreDeleteWithOrphanDependents(t *testing.T) {
0000000000000000000000000000000000000000;;		initialGeneration := int64(1)
0000000000000000000000000000000000000000;;		podWithOrphanFinalizer := func(name string) *example.Pod {
0000000000000000000000000000000000000000;;			return &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: name, Finalizers: []string{"foo.com/x", metav1.FinalizerOrphanDependents, "bar.com/y"}, Generation: initialGeneration},
0000000000000000000000000000000000000000;;				Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podWithOtherFinalizers := func(name string) *example.Pod {
0000000000000000000000000000000000000000;;			return &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: name, Finalizers: []string{"foo.com/x", "bar.com/y"}, Generation: initialGeneration},
0000000000000000000000000000000000000000;;				Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podWithNoFinalizer := func(name string) *example.Pod {
0000000000000000000000000000000000000000;;			return &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: name, Generation: initialGeneration},
0000000000000000000000000000000000000000;;				Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podWithOnlyOrphanFinalizer := func(name string) *example.Pod {
0000000000000000000000000000000000000000;;			return &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: name, Finalizers: []string{metav1.FinalizerOrphanDependents}, Generation: initialGeneration},
0000000000000000000000000000000000000000;;				Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trueVar, falseVar := true, false
0000000000000000000000000000000000000000;;		orphanOptions := &metav1.DeleteOptions{OrphanDependents: &trueVar}
0000000000000000000000000000000000000000;;		nonOrphanOptions := &metav1.DeleteOptions{OrphanDependents: &falseVar}
0000000000000000000000000000000000000000;;		nilOrphanOptions := &metav1.DeleteOptions{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defaultDeleteStrategy doesn't implement rest.GarbageCollectionDeleteStrategy.
0000000000000000000000000000000000000000;;		defaultDeleteStrategy := &testRESTStrategy{scheme, names.SimpleNameGenerator, true, false, true}
0000000000000000000000000000000000000000;;		// orphanDeleteStrategy indicates the default garbage collection policy is
0000000000000000000000000000000000000000;;		// to orphan dependentes.
0000000000000000000000000000000000000000;;		orphanDeleteStrategy := &testOrphanDeleteStrategy{defaultDeleteStrategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			pod               *example.Pod
0000000000000000000000000000000000000000;;			options           *metav1.DeleteOptions
0000000000000000000000000000000000000000;;			strategy          rest.RESTDeleteStrategy
0000000000000000000000000000000000000000;;			expectNotFound    bool
0000000000000000000000000000000000000000;;			updatedFinalizers []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// cases run with DeleteOptions.OrphanDedependents=true
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOrphanFinalizer("pod1"),
0000000000000000000000000000000000000000;;				orphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", metav1.FinalizerOrphanDependents, "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOtherFinalizers("pod2"),
0000000000000000000000000000000000000000;;				orphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", "bar.com/y", metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithNoFinalizer("pod3"),
0000000000000000000000000000000000000000;;				orphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOnlyOrphanFinalizer("pod4"),
0000000000000000000000000000000000000000;;				orphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// cases run with DeleteOptions.OrphanDedependents=false
0000000000000000000000000000000000000000;;			// these cases all have oprhanDeleteStrategy, which should be ignored
0000000000000000000000000000000000000000;;			// because DeleteOptions has the highest priority.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOrphanFinalizer("pod5"),
0000000000000000000000000000000000000000;;				nonOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOtherFinalizers("pod6"),
0000000000000000000000000000000000000000;;				nonOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithNoFinalizer("pod7"),
0000000000000000000000000000000000000000;;				nonOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;				[]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOnlyOrphanFinalizer("pod8"),
0000000000000000000000000000000000000000;;				nonOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;				[]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// cases run with nil DeleteOptions.OrphanDependents. If the object
0000000000000000000000000000000000000000;;			// already has the orphan finalizer, then the DeleteStrategy should be
0000000000000000000000000000000000000000;;			// ignored. Otherwise the DeleteStrategy decides whether to add the
0000000000000000000000000000000000000000;;			// orphan finalizer.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOrphanFinalizer("pod9"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", metav1.FinalizerOrphanDependents, "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOrphanFinalizer("pod10"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", metav1.FinalizerOrphanDependents, "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOtherFinalizers("pod11"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOtherFinalizers("pod12"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", "bar.com/y", metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithNoFinalizer("pod13"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;				[]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithNoFinalizer("pod14"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOnlyOrphanFinalizer("pod15"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOnlyOrphanFinalizer("pod16"),
0000000000000000000000000000000000000000;;				nilOrphanOptions,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// cases run with nil DeleteOptions should have exact same behavior.
0000000000000000000000000000000000000000;;			// They should be exactly the same as above cases where
0000000000000000000000000000000000000000;;			// DeleteOptions.OrphanDependents is nil.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOrphanFinalizer("pod17"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", metav1.FinalizerOrphanDependents, "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOrphanFinalizer("pod18"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", metav1.FinalizerOrphanDependents, "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOtherFinalizers("pod19"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", "bar.com/y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOtherFinalizers("pod20"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{"foo.com/x", "bar.com/y", metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithNoFinalizer("pod21"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;				[]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithNoFinalizer("pod22"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOnlyOrphanFinalizer("pod23"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				podWithOnlyOrphanFinalizer("pod24"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;				[]string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		registry.EnableGarbageCollection = true
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testcases {
0000000000000000000000000000000000000000;;			registry.DeleteStrategy = tc.strategy
0000000000000000000000000000000000000000;;			// create pod
0000000000000000000000000000000000000000;;			_, err := registry.Create(testContext, tc.pod, false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, _, err = registry.Delete(testContext, tc.pod.Name, tc.options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, err := registry.Get(testContext, tc.pod.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if tc.expectNotFound && (err == nil || !errors.IsNotFound(err)) {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !tc.expectNotFound && err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !tc.expectNotFound {
0000000000000000000000000000000000000000;;				pod, ok := obj.(*example.Pod)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Fatalf("Expect the object to be a pod, but got %#v", obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.ObjectMeta.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Expect the object to have DeletionTimestamp set, but got %#v", pod.Name, pod.ObjectMeta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.ObjectMeta.DeletionGracePeriodSeconds == nil || *pod.ObjectMeta.DeletionGracePeriodSeconds != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Expect the object to have 0 DeletionGracePeriodSecond, but got %#v", pod.Name, pod.ObjectMeta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.Generation <= initialGeneration {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Deletion didn't increase Generation.", pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := tc.updatedFinalizers, pod.ObjectMeta.Finalizers; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Expect object %s to have finalizers %v, got %v", pod.Name, pod.ObjectMeta.Name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test the DeleteOptions.PropagationPolicy is handled correctly
0000000000000000000000000000000000000000;;	func TestStoreDeletionPropagation(t *testing.T) {
0000000000000000000000000000000000000000;;		initialGeneration := int64(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defaultDeleteStrategy doesn't implement rest.GarbageCollectionDeleteStrategy.
0000000000000000000000000000000000000000;;		defaultDeleteStrategy := &testRESTStrategy{scheme, names.SimpleNameGenerator, true, false, true}
0000000000000000000000000000000000000000;;		// orphanDeleteStrategy indicates the default garbage collection policy is
0000000000000000000000000000000000000000;;		// to orphan dependentes.
0000000000000000000000000000000000000000;;		orphanDeleteStrategy := &testOrphanDeleteStrategy{defaultDeleteStrategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foregroundPolicy := metav1.DeletePropagationForeground
0000000000000000000000000000000000000000;;		backgroundPolicy := metav1.DeletePropagationBackground
0000000000000000000000000000000000000000;;		orphanPolicy := metav1.DeletePropagationOrphan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := map[string]struct {
0000000000000000000000000000000000000000;;			options  *metav1.DeleteOptions
0000000000000000000000000000000000000000;;			strategy rest.RESTDeleteStrategy
0000000000000000000000000000000000000000;;			// finalizers that are already set in the object
0000000000000000000000000000000000000000;;			existingFinalizers []string
0000000000000000000000000000000000000000;;			expectedNotFound   bool
0000000000000000000000000000000000000000;;			expectedFinalizers []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=Foreground, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &foregroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=Foreground, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &foregroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=Background, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:          &metav1.DeleteOptions{PropagationPolicy: &backgroundPolicy},
0000000000000000000000000000000000000000;;				strategy:         defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedNotFound: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=Background, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:          &metav1.DeleteOptions{PropagationPolicy: &backgroundPolicy},
0000000000000000000000000000000000000000;;				strategy:         orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedNotFound: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=OrphanDependents, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &orphanPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=OrphanDependents, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &orphanPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=Default, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:          &metav1.DeleteOptions{PropagationPolicy: nil},
0000000000000000000000000000000000000000;;				strategy:         defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedNotFound: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no existing finalizers, PropagationPolicy=Default, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: nil},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// all cases in the following block have "existing orphan finalizer"
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=Foreground, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &foregroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=Foreground, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &foregroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=Background, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &backgroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedNotFound:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=Background, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &backgroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedNotFound:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=OrphanDependents, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &orphanPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=OrphanDependents, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &orphanPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=Default, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: nil},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing orphan finalizer, PropagationPolicy=Default, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: nil},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// all cases in the following block have "existing deleteDependents finalizer"
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=Foreground, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &foregroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=Foreground, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &foregroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=Background, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &backgroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedNotFound:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=Background, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &backgroundPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedNotFound:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=OrphanDependents, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &orphanPolicy},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=OrphanDependents, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: &orphanPolicy},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerOrphanDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=Default, defaultDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: nil},
0000000000000000000000000000000000000000;;				strategy:           defaultDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"existing deleteDependents finalizer, PropagationPolicy=Default, orphanDeleteStrategy": {
0000000000000000000000000000000000000000;;				options:            &metav1.DeleteOptions{PropagationPolicy: nil},
0000000000000000000000000000000000000000;;				strategy:           orphanDeleteStrategy,
0000000000000000000000000000000000000000;;				existingFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;				expectedFinalizers: []string{metav1.FinalizerDeleteDependents},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		registry.EnableGarbageCollection = true
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createPod := func(i int, finalizers []string) *example.Pod {
0000000000000000000000000000000000000000;;			return &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("pod-%d", i), Finalizers: finalizers, Generation: initialGeneration},
0000000000000000000000000000000000000000;;				Spec:       example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for title, tc := range testcases {
0000000000000000000000000000000000000000;;			t.Logf("case title: %s", title)
0000000000000000000000000000000000000000;;			registry.DeleteStrategy = tc.strategy
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			pod := createPod(i, tc.existingFinalizers)
0000000000000000000000000000000000000000;;			// create pod
0000000000000000000000000000000000000000;;			_, err := registry.Create(testContext, pod, false)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, _, err = registry.Delete(testContext, pod.Name, tc.options)
0000000000000000000000000000000000000000;;			obj, err := registry.Get(testContext, pod.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if tc.expectedNotFound {
0000000000000000000000000000000000000000;;				if err == nil || !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;					t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !tc.expectedNotFound && err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !tc.expectedNotFound {
0000000000000000000000000000000000000000;;				pod, ok := obj.(*example.Pod)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Fatalf("Expect the object to be a pod, but got %#v", obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := tc.expectedFinalizers, pod.ObjectMeta.Finalizers; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Expect object %s to have finalizers %v, got %v", pod.Name, pod.ObjectMeta.Name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.ObjectMeta.DeletionTimestamp == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Expect the object to have DeletionTimestamp set, but got %#v", pod.Name, pod.ObjectMeta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.ObjectMeta.DeletionGracePeriodSeconds == nil || *pod.ObjectMeta.DeletionGracePeriodSeconds != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Expect the object to have 0 DeletionGracePeriodSecond, but got %#v", pod.Name, pod.ObjectMeta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod.Generation <= initialGeneration {
0000000000000000000000000000000000000000;;					t.Errorf("%v: Deletion didn't increase Generation.", pod.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreDeleteCollection(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		podB := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}
0000000000000000000000000000000000000000;;		podC := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "baz",
0000000000000000000000000000000000000000;;				Initializers: &metav1.Initializers{
0000000000000000000000000000000000000000;;					Pending: []metav1.Initializer{{Name: "Test"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := registry.Create(testContext, podA, false); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := registry.Create(testContext, podB, false); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := registry.Create(testContext, podC, true); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete all pods.
0000000000000000000000000000000000000000;;		deleted, err := registry.DeleteCollection(testContext, nil, &metainternalversion.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletedPods := deleted.(*example.PodList)
0000000000000000000000000000000000000000;;		if len(deletedPods.Items) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected number of pods deleted: %d, expected: 3", len(deletedPods.Items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := registry.Get(testContext, podA.Name, &metav1.GetOptions{}); !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := registry.Get(testContext, podB.Name, &metav1.GetOptions{}); !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := registry.Get(testContext, podC.Name, &metav1.GetOptions{}); !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreDeleteCollectionNotFound(t *testing.T) {
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podA := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;		podB := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			// Setup
0000000000000000000000000000000000000000;;			if _, err := registry.Create(testContext, podA, false); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := registry.Create(testContext, podB, false); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Kick off multiple delete collection calls to test notfound behavior
0000000000000000000000000000000000000000;;			wg := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;			for j := 0; j < 2; j++ {
0000000000000000000000000000000000000000;;				wg.Add(1)
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					_, err := registry.DeleteCollection(testContext, nil, &metainternalversion.ListOptions{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := registry.Get(testContext, podA.Name, &metav1.GetOptions{}); !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := registry.Get(testContext, podB.Name, &metav1.GetOptions{}); !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test whether objects deleted with DeleteCollection are correctly delivered
0000000000000000000000000000000000000000;;	// to watchers.
0000000000000000000000000000000000000000;;	func TestStoreDeleteCollectionWithWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		podA := &example.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objCreated, err := registry.Create(testContext, podA, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podCreated := objCreated.(*example.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watcher, err := registry.WatchPredicate(testContext, matchPodName("foo"), podCreated.ResourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer watcher.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := registry.DeleteCollection(testContext, nil, &metainternalversion.ListOptions{}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got, open := <-watcher.ResultChan()
0000000000000000000000000000000000000000;;		if !open {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected channel close")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if got.Type != "DELETED" {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected event type: %s", got.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gotObject := got.Object.(*example.Pod)
0000000000000000000000000000000000000000;;			gotObject.ResourceVersion = podCreated.ResourceVersion
0000000000000000000000000000000000000000;;			if e, a := podCreated, gotObject; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected: %#v, got: %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStoreWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		testContext := genericapirequest.WithNamespace(genericapirequest.NewContext(), "test")
0000000000000000000000000000000000000000;;		noNamespaceContext := genericapirequest.NewContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := map[string]struct {
0000000000000000000000000000000000000000;;			selectPred storage.SelectionPredicate
0000000000000000000000000000000000000000;;			context    genericapirequest.Context
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"single": {
0000000000000000000000000000000000000000;;				selectPred: matchPodName("foo"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"multi": {
0000000000000000000000000000000000000000;;				selectPred: matchPodName("foo", "bar"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"singleNoNamespace": {
0000000000000000000000000000000000000000;;				selectPred: matchPodName("foo"),
0000000000000000000000000000000000000000;;				context:    noNamespaceContext,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, m := range table {
0000000000000000000000000000000000000000;;			ctx := testContext
0000000000000000000000000000000000000000;;			if m.context != nil {
0000000000000000000000000000000000000000;;				ctx = m.context
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podA := &example.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      "foo",
0000000000000000000000000000000000000000;;					Namespace: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: example.PodSpec{NodeName: "machine"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			destroyFunc, registry := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;			wi, err := registry.WatchPredicate(ctx, m.selectPred, "0")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", name, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				obj, err := registry.Create(testContext, podA, false)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					got, open := <-wi.ResultChan()
0000000000000000000000000000000000000000;;					if !open {
0000000000000000000000000000000000000000;;						t.Errorf("%v: unexpected channel close", name)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if e, a := obj, got.Object; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;							t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wi.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			destroyFunc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestGenericStoreRegistry(t *testing.T, scheme *runtime.Scheme, hasCacheEnabled bool) (factory.DestroyFunc, *Store) {
0000000000000000000000000000000000000000;;		podPrefix := "/pods"
0000000000000000000000000000000000000000;;		server, sc := etcdtesting.NewUnsecuredEtcd3TestClientServer(t, scheme)
0000000000000000000000000000000000000000;;		strategy := &testRESTStrategy{scheme, names.SimpleNameGenerator, true, false, true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc.Codec = apitesting.TestStorageCodec(codecs, examplev1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		s, dFunc, err := factory.Create(*sc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error creating storage: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		destroyFunc := func() {
0000000000000000000000000000000000000000;;			dFunc()
0000000000000000000000000000000000000000;;			server.Terminate(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasCacheEnabled {
0000000000000000000000000000000000000000;;			config := storage.CacherConfig{
0000000000000000000000000000000000000000;;				CacheCapacity:  10,
0000000000000000000000000000000000000000;;				Storage:        s,
0000000000000000000000000000000000000000;;				Versioner:      etcdstorage.APIObjectVersioner{},
0000000000000000000000000000000000000000;;				Copier:         scheme,
0000000000000000000000000000000000000000;;				Type:           &example.Pod{},
0000000000000000000000000000000000000000;;				ResourcePrefix: podPrefix,
0000000000000000000000000000000000000000;;				KeyFunc:        func(obj runtime.Object) (string, error) { return storage.NoNamespaceKeyFunc(podPrefix, obj) },
0000000000000000000000000000000000000000;;				GetAttrsFunc:   getPodAttrs,
0000000000000000000000000000000000000000;;				NewListFunc:    func() runtime.Object { return &example.PodList{} },
0000000000000000000000000000000000000000;;				Codec:          sc.Codec,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cacher := storage.NewCacherFromConfig(config)
0000000000000000000000000000000000000000;;			d := destroyFunc
0000000000000000000000000000000000000000;;			s = cacher
0000000000000000000000000000000000000000;;			destroyFunc = func() {
0000000000000000000000000000000000000000;;				cacher.Stop()
0000000000000000000000000000000000000000;;				d()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return destroyFunc, &Store{
0000000000000000000000000000000000000000;;			Copier:            scheme,
0000000000000000000000000000000000000000;;			NewFunc:           func() runtime.Object { return &example.Pod{} },
0000000000000000000000000000000000000000;;			NewListFunc:       func() runtime.Object { return &example.PodList{} },
0000000000000000000000000000000000000000;;			QualifiedResource: example.Resource("pods"),
0000000000000000000000000000000000000000;;			CreateStrategy:    strategy,
0000000000000000000000000000000000000000;;			UpdateStrategy:    strategy,
0000000000000000000000000000000000000000;;			DeleteStrategy:    strategy,
0000000000000000000000000000000000000000;;			KeyRootFunc: func(ctx genericapirequest.Context) string {
0000000000000000000000000000000000000000;;				return podPrefix
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			KeyFunc: func(ctx genericapirequest.Context, id string) (string, error) {
0000000000000000000000000000000000000000;;				if _, ok := genericapirequest.NamespaceFrom(ctx); !ok {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("namespace is required")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return path.Join(podPrefix, id), nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectNameFunc: func(obj runtime.Object) (string, error) { return obj.(*example.Pod).Name, nil },
0000000000000000000000000000000000000000;;			PredicateFunc: func(label labels.Selector, field fields.Selector) storage.SelectionPredicate {
0000000000000000000000000000000000000000;;				return storage.SelectionPredicate{
0000000000000000000000000000000000000000;;					Label: label,
0000000000000000000000000000000000000000;;					Field: field,
0000000000000000000000000000000000000000;;					GetAttrs: func(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;						pod, ok := obj.(*example.Pod)
0000000000000000000000000000000000000000;;						if !ok {
0000000000000000000000000000000000000000;;							return nil, nil, false, fmt.Errorf("not a pod")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return labels.Set(pod.ObjectMeta.Labels), generic.ObjectMetaFieldsSet(&pod.ObjectMeta, true), pod.Initializers != nil, nil
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Storage: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFinalizeDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		// Verify that it returns the expected Status.
0000000000000000000000000000000000000000;;		destroyFunc, s := NewTestGenericStoreRegistry(t)
0000000000000000000000000000000000000000;;		defer destroyFunc()
0000000000000000000000000000000000000000;;		obj := &example.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "foo", UID: "random-uid"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := s.finalizeDelete(obj, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected err: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		returnedObj := result.(*metav1.Status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedObj := &metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusSuccess,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Name:  "foo",
0000000000000000000000000000000000000000;;				Group: s.QualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:  s.QualifiedResource.Resource,
0000000000000000000000000000000000000000;;				UID:   "random-uid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(expectedObj, returnedObj) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected obj. expected %#v, got %#v", expectedObj, returnedObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
