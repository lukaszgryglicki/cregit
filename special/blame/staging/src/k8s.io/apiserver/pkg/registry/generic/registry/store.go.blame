0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
a5d0a3980ea92b4321a18ea3ec1c22f1a717fc1d;pkg/registry/generic/etcd.go[pkg/registry/generic/etcd.go][staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeerr "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation/path"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		metav1alpha1 "k8s.io/apimachinery/pkg/apis/meta/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		storeerr "k8s.io/apiserver/pkg/storage/errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectFunc is a function to act on a given object. An error may be returned
0000000000000000000000000000000000000000;;	// if the hook cannot be completed. An ObjectFunc may transform the provided
0000000000000000000000000000000000000000;;	// object.
0000000000000000000000000000000000000000;;	type ObjectFunc func(obj runtime.Object) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Store implements pkg/api/rest.StandardStorage. It's intended to be
0000000000000000000000000000000000000000;;	// embeddable and allows the consumer to implement any non-generic functions
0000000000000000000000000000000000000000;;	// that are required. This object is intended to be copyable so that it can be
0000000000000000000000000000000000000000;;	// used in different ways but share the same underlying behavior.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All fields are required unless specified.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The intended use of this type is embedding within a Kind specific
0000000000000000000000000000000000000000;;	// RESTStorage implementation. This type provides CRUD semantics on a Kubelike
0000000000000000000000000000000000000000;;	// resource, handling details like conflict detection with ResourceVersion and
0000000000000000000000000000000000000000;;	// semantics. The RESTCreateStrategy, RESTUpdateStrategy, and
0000000000000000000000000000000000000000;;	// RESTDeleteStrategy are generic across all backends, and encapsulate logic
0000000000000000000000000000000000000000;;	// specific to the API.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: make the default exposed methods exactly match a generic RESTStorage
0000000000000000000000000000000000000000;;	type Store struct {
0000000000000000000000000000000000000000;;		// Copier is used to make some storage caching decorators work
0000000000000000000000000000000000000000;;		Copier runtime.ObjectCopier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewFunc returns a new instance of the type this registry returns for a
0000000000000000000000000000000000000000;;		// GET of a single object, e.g.:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// curl GET /apis/group/version/namespaces/my-ns/myresource/name-of-object
0000000000000000000000000000000000000000;;		NewFunc func() runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewListFunc returns a new list of the type this registry; it is the
0000000000000000000000000000000000000000;;		// type returned when the resource is listed, e.g.:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// curl GET /apis/group/version/namespaces/my-ns/myresource
0000000000000000000000000000000000000000;;		NewListFunc func() runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// QualifiedResource is the pluralized name of the resource.
0000000000000000000000000000000000000000;;		QualifiedResource schema.GroupResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyRootFunc returns the root etcd key for this resource; should not
0000000000000000000000000000000000000000;;		// include trailing "/".  This is used for operations that work on the
0000000000000000000000000000000000000000;;		// entire collection (listing and watching).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// KeyRootFunc and KeyFunc must be supplied together or not at all.
0000000000000000000000000000000000000000;;		KeyRootFunc func(ctx genericapirequest.Context) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyFunc returns the key for a specific object in the collection.
0000000000000000000000000000000000000000;;		// KeyFunc is called for Create/Update/Get/Delete. Note that 'namespace'
0000000000000000000000000000000000000000;;		// can be gotten from ctx.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// KeyFunc and KeyRootFunc must be supplied together or not at all.
0000000000000000000000000000000000000000;;		KeyFunc func(ctx genericapirequest.Context, name string) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ObjectNameFunc returns the name of an object or an error.
0000000000000000000000000000000000000000;;		ObjectNameFunc func(obj runtime.Object) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTLFunc returns the TTL (time to live) that objects should be persisted
0000000000000000000000000000000000000000;;		// with. The existing parameter is the current TTL or the default for this
0000000000000000000000000000000000000000;;		// operation. The update parameter indicates whether this is an operation
0000000000000000000000000000000000000000;;		// against an existing object.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Objects that are persisted with a TTL are evicted once the TTL expires.
0000000000000000000000000000000000000000;;		TTLFunc func(obj runtime.Object, existing uint64, update bool) (uint64, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PredicateFunc returns a matcher corresponding to the provided labels
0000000000000000000000000000000000000000;;		// and fields. The SelectionPredicate returned should return true if the
0000000000000000000000000000000000000000;;		// object matches the given field and label selectors.
0000000000000000000000000000000000000000;;		PredicateFunc func(label labels.Selector, field fields.Selector) storage.SelectionPredicate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EnableGarbageCollection affects the handling of Update and Delete
0000000000000000000000000000000000000000;;		// requests. Enabling garbage collection allows finalizers to do work to
0000000000000000000000000000000000000000;;		// finalize this object before the store deletes it.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If any store has garbage collection enabled, it must also be enabled in
0000000000000000000000000000000000000000;;		// the kube-controller-manager.
0000000000000000000000000000000000000000;;		EnableGarbageCollection bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteCollectionWorkers is the maximum number of workers in a single
0000000000000000000000000000000000000000;;		// DeleteCollection call. Delete requests for the items in a collection
0000000000000000000000000000000000000000;;		// are issued in parallel.
0000000000000000000000000000000000000000;;		DeleteCollectionWorkers int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decorator is an optional exit hook on an object returned from the
0000000000000000000000000000000000000000;;		// underlying storage. The returned object could be an individual object
0000000000000000000000000000000000000000;;		// (e.g. Pod) or a list type (e.g. PodList). Decorator is intended for
0000000000000000000000000000000000000000;;		// integrations that are above storage and should only be used for
0000000000000000000000000000000000000000;;		// specific cases where storage of the value is not appropriate, since
0000000000000000000000000000000000000000;;		// they cannot be watched.
0000000000000000000000000000000000000000;;		Decorator ObjectFunc
0000000000000000000000000000000000000000;;		// CreateStrategy implements resource-specific behavior during creation.
0000000000000000000000000000000000000000;;		CreateStrategy rest.RESTCreateStrategy
0000000000000000000000000000000000000000;;		// AfterCreate implements a further operation to run after a resource is
0000000000000000000000000000000000000000;;		// created and before it is decorated, optional.
0000000000000000000000000000000000000000;;		AfterCreate ObjectFunc
0000000000000000000000000000000000000000;;		// UpdateStrategy implements resource-specific behavior during updates.
0000000000000000000000000000000000000000;;		UpdateStrategy rest.RESTUpdateStrategy
0000000000000000000000000000000000000000;;		// AfterUpdate implements a further operation to run after a resource is
0000000000000000000000000000000000000000;;		// updated and before it is decorated, optional.
0000000000000000000000000000000000000000;;		AfterUpdate ObjectFunc
0000000000000000000000000000000000000000;;		// DeleteStrategy implements resource-specific behavior during deletion.
0000000000000000000000000000000000000000;;		DeleteStrategy rest.RESTDeleteStrategy
0000000000000000000000000000000000000000;;		// AfterDelete implements a further operation to run after a resource is
0000000000000000000000000000000000000000;;		// deleted and before it is decorated, optional.
0000000000000000000000000000000000000000;;		AfterDelete ObjectFunc
0000000000000000000000000000000000000000;;		// ReturnDeletedObject determines whether the Store returns the object
0000000000000000000000000000000000000000;;		// that was deleted. Otherwise, return a generic success status response.
0000000000000000000000000000000000000000;;		ReturnDeletedObject bool
0000000000000000000000000000000000000000;;		// ExportStrategy implements resource-specific behavior during export,
0000000000000000000000000000000000000000;;		// optional. Exported objects are not decorated.
0000000000000000000000000000000000000000;;		ExportStrategy rest.RESTExportStrategy
0000000000000000000000000000000000000000;;		// TableConvertor is an optional interface for transforming items or lists
0000000000000000000000000000000000000000;;		// of items into tabular output. If unset, the default will be used.
0000000000000000000000000000000000000000;;		TableConvertor rest.TableConvertor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Storage is the interface for the underlying storage for the resource.
0000000000000000000000000000000000000000;;		Storage storage.Interface
0000000000000000000000000000000000000000;;		// Called to cleanup clients used by the underlying Storage; optional.
0000000000000000000000000000000000000000;;		DestroyFunc func()
0000000000000000000000000000000000000000;;		// Maximum size of the watch history cached in memory, in number of entries.
0000000000000000000000000000000000000000;;		// This value is ignored if Storage is non-nil. Nil is replaced with a default value.
0000000000000000000000000000000000000000;;		// A zero integer will disable caching.
0000000000000000000000000000000000000000;;		WatchCacheSize *int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: the rest.StandardStorage interface aggregates the common REST verbs
0000000000000000000000000000000000000000;;	var _ rest.StandardStorage = &Store{}
0000000000000000000000000000000000000000;;	var _ rest.Exporter = &Store{}
0000000000000000000000000000000000000000;;	var _ rest.TableConvertor = &Store{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const OptimisticLockErrorMsg = "the object has been modified; please apply your changes to the latest version and try again"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceKeyRootFunc is the default function for constructing storage paths
0000000000000000000000000000000000000000;;	// to resource directories enforcing namespace rules.
0000000000000000000000000000000000000000;;	func NamespaceKeyRootFunc(ctx genericapirequest.Context, prefix string) string {
0000000000000000000000000000000000000000;;		key := prefix
0000000000000000000000000000000000000000;;		ns, ok := genericapirequest.NamespaceFrom(ctx)
0000000000000000000000000000000000000000;;		if ok && len(ns) > 0 {
0000000000000000000000000000000000000000;;			key = key + "/" + ns
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceKeyFunc is the default function for constructing storage paths to
0000000000000000000000000000000000000000;;	// a resource relative to the given prefix enforcing namespace rules. If the
0000000000000000000000000000000000000000;;	// context does not contain a namespace, it errors.
0000000000000000000000000000000000000000;;	func NamespaceKeyFunc(ctx genericapirequest.Context, prefix string, name string) (string, error) {
0000000000000000000000000000000000000000;;		key := NamespaceKeyRootFunc(ctx, prefix)
0000000000000000000000000000000000000000;;		ns, ok := genericapirequest.NamespaceFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok || len(ns) == 0 {
0000000000000000000000000000000000000000;;			return "", kubeerr.NewBadRequest("Namespace parameter required.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return "", kubeerr.NewBadRequest("Name parameter required.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msgs := path.IsValidPathSegmentName(name); len(msgs) != 0 {
0000000000000000000000000000000000000000;;			return "", kubeerr.NewBadRequest(fmt.Sprintf("Name parameter invalid: %q: %s", name, strings.Join(msgs, ";")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = key + "/" + name
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoNamespaceKeyFunc is the default function for constructing storage paths
0000000000000000000000000000000000000000;;	// to a resource relative to the given prefix without a namespace.
0000000000000000000000000000000000000000;;	func NoNamespaceKeyFunc(ctx genericapirequest.Context, prefix string, name string) (string, error) {
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return "", kubeerr.NewBadRequest("Name parameter required.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msgs := path.IsValidPathSegmentName(name); len(msgs) != 0 {
0000000000000000000000000000000000000000;;			return "", kubeerr.NewBadRequest(fmt.Sprintf("Name parameter invalid: %q: %s", name, strings.Join(msgs, ";")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key := prefix + "/" + name
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New implements RESTStorage.New.
0000000000000000000000000000000000000000;;	func (e *Store) New() runtime.Object {
0000000000000000000000000000000000000000;;		return e.NewFunc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewList implements rest.Lister.
0000000000000000000000000000000000000000;;	func (e *Store) NewList() runtime.Object {
0000000000000000000000000000000000000000;;		return e.NewListFunc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of items matching labels and field according to the
0000000000000000000000000000000000000000;;	// store's PredicateFunc.
0000000000000000000000000000000000000000;;	func (e *Store) List(ctx genericapirequest.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		label := labels.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.LabelSelector != nil {
0000000000000000000000000000000000000000;;			label = options.LabelSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		field := fields.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.FieldSelector != nil {
0000000000000000000000000000000000000000;;			field = options.FieldSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, err := e.ListPredicate(ctx, e.PredicateFunc(label, field), options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.Decorator != nil {
0000000000000000000000000000000000000000;;			if err := e.Decorator(out); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListPredicate returns a list of all the items matching the given
0000000000000000000000000000000000000000;;	// SelectionPredicate.
0000000000000000000000000000000000000000;;	func (e *Store) ListPredicate(ctx genericapirequest.Context, p storage.SelectionPredicate, options *metainternalversion.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if options == nil {
0000000000000000000000000000000000000000;;			// By default we should serve the request from etcd.
0000000000000000000000000000000000000000;;			options = &metainternalversion.ListOptions{ResourceVersion: ""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.IncludeUninitialized = options.IncludeUninitialized
0000000000000000000000000000000000000000;;		list := e.NewListFunc()
0000000000000000000000000000000000000000;;		if name, ok := p.MatchesSingle(); ok {
0000000000000000000000000000000000000000;;			if key, err := e.KeyFunc(ctx, name); err == nil {
0000000000000000000000000000000000000000;;				err := e.Storage.GetToList(ctx, key, options.ResourceVersion, p, list)
0000000000000000000000000000000000000000;;				return list, storeerr.InterpretListError(err, e.QualifiedResource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we cannot extract a key based on the current context, the optimization is skipped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := e.Storage.List(ctx, e.KeyRootFunc(ctx), options.ResourceVersion, p, list)
0000000000000000000000000000000000000000;;		return list, storeerr.InterpretListError(err, e.QualifiedResource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create inserts a new item according to the unique key from the object.
0000000000000000000000000000000000000000;;	func (e *Store) Create(ctx genericapirequest.Context, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if err := rest.BeforeCreate(e.CreateStrategy, ctx, obj); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name, err := e.ObjectNameFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := e.KeyFunc(ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ttl, err := e.calculateTTL(obj, 0, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := e.NewFunc()
0000000000000000000000000000000000000000;;		if err := e.Storage.Create(ctx, key, obj, out, ttl); err != nil {
0000000000000000000000000000000000000000;;			err = storeerr.InterpretCreateError(err, e.QualifiedResource, name)
0000000000000000000000000000000000000000;;			err = rest.CheckGeneratedNameError(e.CreateStrategy, err, obj)
0000000000000000000000000000000000000000;;			if !kubeerr.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if errGet := e.Storage.Get(ctx, key, "", out, false); errGet != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			accessor, errGetAcc := meta.Accessor(out)
0000000000000000000000000000000000000000;;			if errGetAcc != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if accessor.GetDeletionTimestamp() != nil {
0000000000000000000000000000000000000000;;				msg := &err.(*kubeerr.StatusError).ErrStatus.Message
0000000000000000000000000000000000000000;;				*msg = fmt.Sprintf("object is being deleted: %s", *msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.AfterCreate != nil {
0000000000000000000000000000000000000000;;			if err := e.AfterCreate(out); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.Decorator != nil {
0000000000000000000000000000000000000000;;			if err := e.Decorator(obj); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !includeUninitialized {
0000000000000000000000000000000000000000;;			return e.WaitForInitialized(ctx, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Store) WaitForInitialized(ctx genericapirequest.Context, obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		// return early if we don't have initializers, or if they've completed already
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return obj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		initializers := accessor.GetInitializers()
0000000000000000000000000000000000000000;;		if initializers == nil {
0000000000000000000000000000000000000000;;			return obj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result := initializers.Result; result != nil {
0000000000000000000000000000000000000000;;			return nil, kubeerr.FromObject(result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, err := e.KeyFunc(ctx, accessor.GetName())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w, err := e.Storage.Watch(ctx, key, accessor.GetResourceVersion(), storage.SelectionPredicate{
0000000000000000000000000000000000000000;;			Label: labels.Everything(),
0000000000000000000000000000000000000000;;			Field: fields.Everything(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			IncludeUninitialized: true,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		latest := obj
0000000000000000000000000000000000000000;;		ch := w.ResultChan()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case event, ok := <-ch:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// TODO: should we just expose the partially initialized object?
0000000000000000000000000000000000000000;;					return nil, kubeerr.NewServerTimeout(e.QualifiedResource, "create", 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch event.Type {
0000000000000000000000000000000000000000;;				case watch.Deleted:
0000000000000000000000000000000000000000;;					if latest = event.Object; latest != nil {
0000000000000000000000000000000000000000;;						if accessor, err := meta.Accessor(latest); err == nil {
0000000000000000000000000000000000000000;;							if initializers := accessor.GetInitializers(); initializers != nil && initializers.Result != nil {
0000000000000000000000000000000000000000;;								// initialization failed, but we missed the modification event
0000000000000000000000000000000000000000;;								return nil, kubeerr.FromObject(initializers.Result)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, kubeerr.NewInternalError(fmt.Errorf("object deleted while waiting for creation"))
0000000000000000000000000000000000000000;;				case watch.Error:
0000000000000000000000000000000000000000;;					if status, ok := event.Object.(*metav1.Status); ok {
0000000000000000000000000000000000000000;;						return nil, &kubeerr.StatusError{ErrStatus: *status}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, kubeerr.NewInternalError(fmt.Errorf("unexpected object in watch stream, can't complete initialization %T", event.Object))
0000000000000000000000000000000000000000;;				case watch.Modified:
0000000000000000000000000000000000000000;;					latest = event.Object
0000000000000000000000000000000000000000;;					accessor, err = meta.Accessor(latest)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, kubeerr.NewInternalError(fmt.Errorf("object no longer has access to metadata %T: %v", latest, err))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					initializers := accessor.GetInitializers()
0000000000000000000000000000000000000000;;					if initializers == nil {
0000000000000000000000000000000000000000;;						// completed initialization
0000000000000000000000000000000000000000;;						return latest, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if result := initializers.Result; result != nil {
0000000000000000000000000000000000000000;;						// initialization failed
0000000000000000000000000000000000000000;;						return nil, kubeerr.FromObject(result)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldDeleteDuringUpdate checks if a Update is removing all the object's
0000000000000000000000000000000000000000;;	// finalizers. If so, it further checks if the object's
0000000000000000000000000000000000000000;;	// DeletionGracePeriodSeconds is 0. If so, it returns true. If garbage collection
0000000000000000000000000000000000000000;;	// is disabled it always returns false.
0000000000000000000000000000000000000000;;	func (e *Store) shouldDeleteDuringUpdate(ctx genericapirequest.Context, key string, obj, existing runtime.Object) bool {
0000000000000000000000000000000000000000;;		if !e.EnableGarbageCollection {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldMeta, err := meta.Accessor(existing)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(newMeta.GetFinalizers()) == 0 && oldMeta.GetDeletionGracePeriodSeconds() != nil && *oldMeta.GetDeletionGracePeriodSeconds() == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldDeleteForFailedInitialization returns true if the provided object is initializing and has
0000000000000000000000000000000000000000;;	// a failure recorded.
0000000000000000000000000000000000000000;;	func (e *Store) shouldDeleteForFailedInitialization(ctx genericapirequest.Context, obj runtime.Object) bool {
0000000000000000000000000000000000000000;;		m, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if initializers := m.GetInitializers(); initializers != nil && initializers.Result != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteWithoutFinalizers handles deleting an object ignoring its finalizer list.
0000000000000000000000000000000000000000;;	// Used for objects that are either been finalized or have never initialized.
0000000000000000000000000000000000000000;;	func (e *Store) deleteWithoutFinalizers(ctx genericapirequest.Context, name, key string, obj runtime.Object, preconditions *storage.Preconditions) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		out := e.NewFunc()
0000000000000000000000000000000000000000;;		glog.V(6).Infof("going to delete %s from registry, triggered by update", name)
0000000000000000000000000000000000000000;;		if err := e.Storage.Delete(ctx, key, out, preconditions); err != nil {
0000000000000000000000000000000000000000;;			// Deletion is racy, i.e., there could be multiple update
0000000000000000000000000000000000000000;;			// requests to remove all finalizers from the object, so we
0000000000000000000000000000000000000000;;			// ignore the NotFound error.
0000000000000000000000000000000000000000;;			if storage.IsNotFound(err) {
0000000000000000000000000000000000000000;;				_, err := e.finalizeDelete(obj, true)
0000000000000000000000000000000000000000;;				// clients are expecting an updated object if a PUT succeeded,
0000000000000000000000000000000000000000;;				// but finalizeDelete returns a metav1.Status, so return
0000000000000000000000000000000000000000;;				// the object in the request instead.
0000000000000000000000000000000000000000;;				return obj, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, false, storeerr.InterpretDeleteError(err, e.QualifiedResource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := e.finalizeDelete(out, true)
0000000000000000000000000000000000000000;;		// clients are expecting an updated object if a PUT succeeded, but
0000000000000000000000000000000000000000;;		// finalizeDelete returns a metav1.Status, so return the object in
0000000000000000000000000000000000000000;;		// the request instead.
0000000000000000000000000000000000000000;;		return obj, false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update performs an atomic update and set of the object. Returns the result of the update
0000000000000000000000000000000000000000;;	// or an error. If the registry allows create-on-update, the create flow will be executed.
0000000000000000000000000000000000000000;;	// A bool is returned along with the object and any errors, to indicate object creation.
0000000000000000000000000000000000000000;;	func (e *Store) Update(ctx genericapirequest.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		key, err := e.KeyFunc(ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			creatingObj runtime.Object
0000000000000000000000000000000000000000;;			creating    = false
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storagePreconditions := &storage.Preconditions{}
0000000000000000000000000000000000000000;;		if preconditions := objInfo.Preconditions(); preconditions != nil {
0000000000000000000000000000000000000000;;			storagePreconditions.UID = preconditions.UID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := e.NewFunc()
0000000000000000000000000000000000000000;;		// deleteObj is only used in case a deletion is carried out
0000000000000000000000000000000000000000;;		var deleteObj runtime.Object
0000000000000000000000000000000000000000;;		err = e.Storage.GuaranteedUpdate(ctx, key, out, true, storagePreconditions, func(existing runtime.Object, res storage.ResponseMeta) (runtime.Object, *uint64, error) {
0000000000000000000000000000000000000000;;			// Given the existing object, get the new object
0000000000000000000000000000000000000000;;			obj, err := objInfo.UpdatedObject(ctx, existing)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If AllowUnconditionalUpdate() is true and the object specified by
0000000000000000000000000000000000000000;;			// the user does not have a resource version, then we populate it with
0000000000000000000000000000000000000000;;			// the latest version. Else, we check that the version specified by
0000000000000000000000000000000000000000;;			// the user matches the version of latest storage object.
0000000000000000000000000000000000000000;;			resourceVersion, err := e.Storage.Versioner().ObjectResourceVersion(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			doUnconditionalUpdate := resourceVersion == 0 && e.UpdateStrategy.AllowUnconditionalUpdate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			version, err := e.Storage.Versioner().ObjectResourceVersion(existing)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if version == 0 {
0000000000000000000000000000000000000000;;				if !e.UpdateStrategy.AllowCreateOnUpdate() {
0000000000000000000000000000000000000000;;					return nil, nil, kubeerr.NewNotFound(e.QualifiedResource, name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				creating = true
0000000000000000000000000000000000000000;;				creatingObj = obj
0000000000000000000000000000000000000000;;				if err := rest.BeforeCreate(e.CreateStrategy, ctx, obj); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ttl, err := e.calculateTTL(obj, 0, false)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return obj, &ttl, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			creating = false
0000000000000000000000000000000000000000;;			creatingObj = nil
0000000000000000000000000000000000000000;;			if doUnconditionalUpdate {
0000000000000000000000000000000000000000;;				// Update the object's resource version to match the latest
0000000000000000000000000000000000000000;;				// storage object's resource version.
0000000000000000000000000000000000000000;;				err = e.Storage.Versioner().UpdateObject(obj, res.ResourceVersion)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Check if the object's resource version matches the latest
0000000000000000000000000000000000000000;;				// resource version.
0000000000000000000000000000000000000000;;				newVersion, err := e.Storage.Versioner().ObjectResourceVersion(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if newVersion == 0 {
0000000000000000000000000000000000000000;;					// TODO: The Invalid error should have a field for Resource.
0000000000000000000000000000000000000000;;					// After that field is added, we should fill the Resource and
0000000000000000000000000000000000000000;;					// leave the Kind field empty. See the discussion in #18526.
0000000000000000000000000000000000000000;;					qualifiedKind := schema.GroupKind{Group: e.QualifiedResource.Group, Kind: e.QualifiedResource.Resource}
0000000000000000000000000000000000000000;;					fieldErrList := field.ErrorList{field.Invalid(field.NewPath("metadata").Child("resourceVersion"), newVersion, "must be specified for an update")}
0000000000000000000000000000000000000000;;					return nil, nil, kubeerr.NewInvalid(qualifiedKind, name, fieldErrList)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if newVersion != version {
0000000000000000000000000000000000000000;;					return nil, nil, kubeerr.NewConflict(e.QualifiedResource, name, fmt.Errorf(OptimisticLockErrorMsg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := rest.BeforeUpdate(e.UpdateStrategy, ctx, obj, existing); err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e.shouldDeleteDuringUpdate(ctx, key, obj, existing) {
0000000000000000000000000000000000000000;;				deleteObj = obj
0000000000000000000000000000000000000000;;				return nil, nil, errEmptiedFinalizers
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ttl, err := e.calculateTTL(obj, res.TTL, true)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if int64(ttl) != res.TTL {
0000000000000000000000000000000000000000;;				return obj, &ttl, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return obj, nil, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// delete the object
0000000000000000000000000000000000000000;;			if err == errEmptiedFinalizers {
0000000000000000000000000000000000000000;;				return e.deleteWithoutFinalizers(ctx, name, key, deleteObj, storagePreconditions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if creating {
0000000000000000000000000000000000000000;;				err = storeerr.InterpretCreateError(err, e.QualifiedResource, name)
0000000000000000000000000000000000000000;;				err = rest.CheckGeneratedNameError(e.CreateStrategy, err, creatingObj)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = storeerr.InterpretUpdateError(err, e.QualifiedResource, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.shouldDeleteForFailedInitialization(ctx, out) {
0000000000000000000000000000000000000000;;			return e.deleteWithoutFinalizers(ctx, name, key, out, storagePreconditions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if creating {
0000000000000000000000000000000000000000;;			if e.AfterCreate != nil {
0000000000000000000000000000000000000000;;				if err := e.AfterCreate(out); err != nil {
0000000000000000000000000000000000000000;;					return nil, false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if e.AfterUpdate != nil {
0000000000000000000000000000000000000000;;				if err := e.AfterUpdate(out); err != nil {
0000000000000000000000000000000000000000;;					return nil, false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.Decorator != nil {
0000000000000000000000000000000000000000;;			if err := e.Decorator(out); err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, creating, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves the item from storage.
0000000000000000000000000000000000000000;;	func (e *Store) Get(ctx genericapirequest.Context, name string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		obj := e.NewFunc()
0000000000000000000000000000000000000000;;		key, err := e.KeyFunc(ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := e.Storage.Get(ctx, key, options.ResourceVersion, obj, false); err != nil {
0000000000000000000000000000000000000000;;			return nil, storeerr.InterpretGetError(err, e.QualifiedResource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.Decorator != nil {
0000000000000000000000000000000000000000;;			if err := e.Decorator(obj); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errAlreadyDeleting   = fmt.Errorf("abort delete")
0000000000000000000000000000000000000000;;		errDeleteNow         = fmt.Errorf("delete now")
0000000000000000000000000000000000000000;;		errEmptiedFinalizers = fmt.Errorf("emptied finalizers")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldOrphanDependents returns true if the finalizer for orphaning should be set
0000000000000000000000000000000000000000;;	// updated for FinalizerOrphanDependents. In the order of highest to lowest
0000000000000000000000000000000000000000;;	// priority, there are three factors affect whether to add/remove the
0000000000000000000000000000000000000000;;	// FinalizerOrphanDependents: options, existing finalizers of the object,
0000000000000000000000000000000000000000;;	// and e.DeleteStrategy.DefaultGarbageCollectionPolicy.
0000000000000000000000000000000000000000;;	func shouldOrphanDependents(e *Store, accessor metav1.Object, options *metav1.DeleteOptions) bool {
0000000000000000000000000000000000000000;;		if gcStrategy, ok := e.DeleteStrategy.(rest.GarbageCollectionDeleteStrategy); ok {
0000000000000000000000000000000000000000;;			if gcStrategy.DefaultGarbageCollectionPolicy() == rest.Unsupported {
0000000000000000000000000000000000000000;;				// return  false to indicate that we should NOT orphan
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An explicit policy was set at deletion time, that overrides everything
0000000000000000000000000000000000000000;;		if options != nil && options.OrphanDependents != nil {
0000000000000000000000000000000000000000;;			return *options.OrphanDependents
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options != nil && options.PropagationPolicy != nil {
0000000000000000000000000000000000000000;;			switch *options.PropagationPolicy {
0000000000000000000000000000000000000000;;			case metav1.DeletePropagationOrphan:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case metav1.DeletePropagationBackground, metav1.DeletePropagationForeground:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If a finalizer is set in the object, it overrides the default
0000000000000000000000000000000000000000;;		// validation should make sure the two cases won't be true at the same time.
0000000000000000000000000000000000000000;;		finalizers := accessor.GetFinalizers()
0000000000000000000000000000000000000000;;		for _, f := range finalizers {
0000000000000000000000000000000000000000;;			switch f {
0000000000000000000000000000000000000000;;			case metav1.FinalizerOrphanDependents:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case metav1.FinalizerDeleteDependents:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get default orphan policy from this REST object type if it exists
0000000000000000000000000000000000000000;;		if gcStrategy, ok := e.DeleteStrategy.(rest.GarbageCollectionDeleteStrategy); ok {
0000000000000000000000000000000000000000;;			if gcStrategy.DefaultGarbageCollectionPolicy() == rest.OrphanDependents {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldDeleteDependents returns true if the finalizer for foreground deletion should be set
0000000000000000000000000000000000000000;;	// updated for FinalizerDeleteDependents. In the order of highest to lowest
0000000000000000000000000000000000000000;;	// priority, there are three factors affect whether to add/remove the
0000000000000000000000000000000000000000;;	// FinalizerDeleteDependents: options, existing finalizers of the object, and
0000000000000000000000000000000000000000;;	// e.DeleteStrategy.DefaultGarbageCollectionPolicy.
0000000000000000000000000000000000000000;;	func shouldDeleteDependents(e *Store, accessor metav1.Object, options *metav1.DeleteOptions) bool {
0000000000000000000000000000000000000000;;		// Get default orphan policy from this REST object type
0000000000000000000000000000000000000000;;		if gcStrategy, ok := e.DeleteStrategy.(rest.GarbageCollectionDeleteStrategy); ok && gcStrategy.DefaultGarbageCollectionPolicy() == rest.Unsupported {
0000000000000000000000000000000000000000;;			// return false to indicate that we should NOT delete in foreground
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If an explicit policy was set at deletion time, that overrides both
0000000000000000000000000000000000000000;;		if options != nil && options.OrphanDependents != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options != nil && options.PropagationPolicy != nil {
0000000000000000000000000000000000000000;;			switch *options.PropagationPolicy {
0000000000000000000000000000000000000000;;			case metav1.DeletePropagationForeground:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case metav1.DeletePropagationBackground, metav1.DeletePropagationOrphan:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If a finalizer is set in the object, it overrides the default
0000000000000000000000000000000000000000;;		// validation has made sure the two cases won't be true at the same time.
0000000000000000000000000000000000000000;;		finalizers := accessor.GetFinalizers()
0000000000000000000000000000000000000000;;		for _, f := range finalizers {
0000000000000000000000000000000000000000;;			switch f {
0000000000000000000000000000000000000000;;			case metav1.FinalizerDeleteDependents:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case metav1.FinalizerOrphanDependents:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deletionFinalizers returns the deletion finalizers we should set on the object and a bool indicate they did or
0000000000000000000000000000000000000000;;	// did not change.
0000000000000000000000000000000000000000;;	func deletionFinalizers(e *Store, accessor metav1.Object, options *metav1.DeleteOptions) (bool, []string) {
0000000000000000000000000000000000000000;;		shouldOrphan := shouldOrphanDependents(e, accessor, options)
0000000000000000000000000000000000000000;;		shouldDeleteDependentInForeground := shouldDeleteDependents(e, accessor, options)
0000000000000000000000000000000000000000;;		newFinalizers := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// first remove both finalizers, add them back if needed.
0000000000000000000000000000000000000000;;		for _, f := range accessor.GetFinalizers() {
0000000000000000000000000000000000000000;;			if f == metav1.FinalizerOrphanDependents || f == metav1.FinalizerDeleteDependents {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newFinalizers = append(newFinalizers, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if shouldOrphan {
0000000000000000000000000000000000000000;;			newFinalizers = append(newFinalizers, metav1.FinalizerOrphanDependents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if shouldDeleteDependentInForeground {
0000000000000000000000000000000000000000;;			newFinalizers = append(newFinalizers, metav1.FinalizerDeleteDependents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldFinalizerSet := sets.NewString(accessor.GetFinalizers()...)
0000000000000000000000000000000000000000;;		newFinalizersSet := sets.NewString(newFinalizers...)
0000000000000000000000000000000000000000;;		if oldFinalizerSet.Equal(newFinalizersSet) {
0000000000000000000000000000000000000000;;			return false, accessor.GetFinalizers()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, newFinalizers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// markAsDeleting sets the obj's DeletionGracePeriodSeconds to 0, and sets the
0000000000000000000000000000000000000000;;	// DeletionTimestamp to "now". Finalizers are watching for such updates and will
0000000000000000000000000000000000000000;;	// finalize the object if their IDs are present in the object's Finalizers list.
0000000000000000000000000000000000000000;;	func markAsDeleting(obj runtime.Object) (err error) {
0000000000000000000000000000000000000000;;		objectMeta, kerr := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if kerr != nil {
0000000000000000000000000000000000000000;;			return kerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := metav1.NewTime(time.Now())
0000000000000000000000000000000000000000;;		// This handles Generation bump for resources that don't support graceful
0000000000000000000000000000000000000000;;		// deletion. For resources that support graceful deletion is handle in
0000000000000000000000000000000000000000;;		// pkg/api/rest/delete.go
0000000000000000000000000000000000000000;;		if objectMeta.GetDeletionTimestamp() == nil && objectMeta.GetGeneration() > 0 {
0000000000000000000000000000000000000000;;			objectMeta.SetGeneration(objectMeta.GetGeneration() + 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta.SetDeletionTimestamp(&now)
0000000000000000000000000000000000000000;;		var zero int64 = 0
0000000000000000000000000000000000000000;;		objectMeta.SetDeletionGracePeriodSeconds(&zero)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateForGracefulDeletion and updateForGracefulDeletionAndFinalizers both
0000000000000000000000000000000000000000;;	// implement deletion flows for graceful deletion.  Graceful deletion is
0000000000000000000000000000000000000000;;	// implemented as setting the deletion timestamp in an update.  If the
0000000000000000000000000000000000000000;;	// implementation of graceful deletion is changed, both of these methods
0000000000000000000000000000000000000000;;	// should be changed together.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateForGracefulDeletion updates the given object for graceful deletion by
0000000000000000000000000000000000000000;;	// setting the deletion timestamp and grace period seconds and returns:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. an error
0000000000000000000000000000000000000000;;	// 2. a boolean indicating that the object was not found, but it should be
0000000000000000000000000000000000000000;;	//    ignored
0000000000000000000000000000000000000000;;	// 3. a boolean indicating that the object's grace period is exhausted and it
0000000000000000000000000000000000000000;;	//    should be deleted immediately
0000000000000000000000000000000000000000;;	// 4. a new output object with the state that was updated
0000000000000000000000000000000000000000;;	// 5. a copy of the last existing state of the object
0000000000000000000000000000000000000000;;	func (e *Store) updateForGracefulDeletion(ctx genericapirequest.Context, name, key string, options *metav1.DeleteOptions, preconditions storage.Preconditions, in runtime.Object) (err error, ignoreNotFound, deleteImmediately bool, out, lastExisting runtime.Object) {
0000000000000000000000000000000000000000;;		lastGraceful := int64(0)
0000000000000000000000000000000000000000;;		out = e.NewFunc()
0000000000000000000000000000000000000000;;		err = e.Storage.GuaranteedUpdate(
0000000000000000000000000000000000000000;;			ctx,
0000000000000000000000000000000000000000;;			key,
0000000000000000000000000000000000000000;;			out,
0000000000000000000000000000000000000000;;			false, /* ignoreNotFound */
0000000000000000000000000000000000000000;;			&preconditions,
0000000000000000000000000000000000000000;;			storage.SimpleUpdate(func(existing runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				graceful, pendingGraceful, err := rest.BeforeDelete(e.DeleteStrategy, ctx, existing, options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pendingGraceful {
0000000000000000000000000000000000000000;;					return nil, errAlreadyDeleting
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !graceful {
0000000000000000000000000000000000000000;;					return nil, errDeleteNow
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lastGraceful = *options.GracePeriodSeconds
0000000000000000000000000000000000000000;;				lastExisting = existing
0000000000000000000000000000000000000000;;				return existing, nil
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			if lastGraceful > 0 {
0000000000000000000000000000000000000000;;				return nil, false, false, out, lastExisting
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If we are here, the registry supports grace period mechanism and
0000000000000000000000000000000000000000;;			// we are intentionally delete gracelessly. In this case, we may
0000000000000000000000000000000000000000;;			// enter a race with other k8s components. If other component wins
0000000000000000000000000000000000000000;;			// the race, the object will not be found, and we should tolerate
0000000000000000000000000000000000000000;;			// the NotFound error. See
0000000000000000000000000000000000000000;;			// https://github.com/kubernetes/kubernetes/issues/19403 for
0000000000000000000000000000000000000000;;			// details.
0000000000000000000000000000000000000000;;			return nil, true, true, out, lastExisting
0000000000000000000000000000000000000000;;		case errDeleteNow:
0000000000000000000000000000000000000000;;			// we've updated the object to have a zero grace period, or it's already at 0, so
0000000000000000000000000000000000000000;;			// we should fall through and truly delete the object.
0000000000000000000000000000000000000000;;			return nil, false, true, out, lastExisting
0000000000000000000000000000000000000000;;		case errAlreadyDeleting:
0000000000000000000000000000000000000000;;			out, err = e.finalizeDelete(in, true)
0000000000000000000000000000000000000000;;			return err, false, false, out, lastExisting
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return storeerr.InterpretUpdateError(err, e.QualifiedResource, name), false, false, out, lastExisting
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateForGracefulDeletionAndFinalizers updates the given object for
0000000000000000000000000000000000000000;;	// graceful deletion and finalization by setting the deletion timestamp and
0000000000000000000000000000000000000000;;	// grace period seconds (graceful deletion) and updating the list of
0000000000000000000000000000000000000000;;	// finalizers (finalization); it returns:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. an error
0000000000000000000000000000000000000000;;	// 2. a boolean indicating that the object was not found, but it should be
0000000000000000000000000000000000000000;;	//    ignored
0000000000000000000000000000000000000000;;	// 3. a boolean indicating that the object's grace period is exhausted and it
0000000000000000000000000000000000000000;;	//    should be deleted immediately
0000000000000000000000000000000000000000;;	// 4. a new output object with the state that was updated
0000000000000000000000000000000000000000;;	// 5. a copy of the last existing state of the object
0000000000000000000000000000000000000000;;	func (e *Store) updateForGracefulDeletionAndFinalizers(ctx genericapirequest.Context, name, key string, options *metav1.DeleteOptions, preconditions storage.Preconditions, in runtime.Object) (err error, ignoreNotFound, deleteImmediately bool, out, lastExisting runtime.Object) {
0000000000000000000000000000000000000000;;		lastGraceful := int64(0)
0000000000000000000000000000000000000000;;		var pendingFinalizers bool
0000000000000000000000000000000000000000;;		out = e.NewFunc()
0000000000000000000000000000000000000000;;		err = e.Storage.GuaranteedUpdate(
0000000000000000000000000000000000000000;;			ctx,
0000000000000000000000000000000000000000;;			key,
0000000000000000000000000000000000000000;;			out,
0000000000000000000000000000000000000000;;			false, /* ignoreNotFound */
0000000000000000000000000000000000000000;;			&preconditions,
0000000000000000000000000000000000000000;;			storage.SimpleUpdate(func(existing runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				graceful, pendingGraceful, err := rest.BeforeDelete(e.DeleteStrategy, ctx, existing, options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pendingGraceful {
0000000000000000000000000000000000000000;;					return nil, errAlreadyDeleting
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Add/remove the orphan finalizer as the options dictates.
0000000000000000000000000000000000000000;;				// Note that this occurs after checking pendingGraceufl, so
0000000000000000000000000000000000000000;;				// finalizers cannot be updated via DeleteOptions if deletion has
0000000000000000000000000000000000000000;;				// started.
0000000000000000000000000000000000000000;;				existingAccessor, err := meta.Accessor(existing)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				needsUpdate, newFinalizers := deletionFinalizers(e, existingAccessor, options)
0000000000000000000000000000000000000000;;				if needsUpdate {
0000000000000000000000000000000000000000;;					existingAccessor.SetFinalizers(newFinalizers)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pendingFinalizers = len(existingAccessor.GetFinalizers()) != 0
0000000000000000000000000000000000000000;;				if !graceful {
0000000000000000000000000000000000000000;;					// set the DeleteGracePeriods to 0 if the object has pendingFinalizers but not supporting graceful deletion
0000000000000000000000000000000000000000;;					if pendingFinalizers {
0000000000000000000000000000000000000000;;						glog.V(6).Infof("update the DeletionTimestamp to \"now\" and GracePeriodSeconds to 0 for object %s, because it has pending finalizers", name)
0000000000000000000000000000000000000000;;						err = markAsDeleting(existing)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return existing, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, errDeleteNow
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lastGraceful = *options.GracePeriodSeconds
0000000000000000000000000000000000000000;;				lastExisting = existing
0000000000000000000000000000000000000000;;				return existing, nil
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			// If there are pending finalizers, we never delete the object immediately.
0000000000000000000000000000000000000000;;			if pendingFinalizers {
0000000000000000000000000000000000000000;;				return nil, false, false, out, lastExisting
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lastGraceful > 0 {
0000000000000000000000000000000000000000;;				return nil, false, false, out, lastExisting
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If we are here, the registry supports grace period mechanism and
0000000000000000000000000000000000000000;;			// we are intentionally delete gracelessly. In this case, we may
0000000000000000000000000000000000000000;;			// enter a race with other k8s components. If other component wins
0000000000000000000000000000000000000000;;			// the race, the object will not be found, and we should tolerate
0000000000000000000000000000000000000000;;			// the NotFound error. See
0000000000000000000000000000000000000000;;			// https://github.com/kubernetes/kubernetes/issues/19403 for
0000000000000000000000000000000000000000;;			// details.
0000000000000000000000000000000000000000;;			return nil, true, true, out, lastExisting
0000000000000000000000000000000000000000;;		case errDeleteNow:
0000000000000000000000000000000000000000;;			// we've updated the object to have a zero grace period, or it's already at 0, so
0000000000000000000000000000000000000000;;			// we should fall through and truly delete the object.
0000000000000000000000000000000000000000;;			return nil, false, true, out, lastExisting
0000000000000000000000000000000000000000;;		case errAlreadyDeleting:
0000000000000000000000000000000000000000;;			out, err = e.finalizeDelete(in, true)
0000000000000000000000000000000000000000;;			return err, false, false, out, lastExisting
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return storeerr.InterpretUpdateError(err, e.QualifiedResource, name), false, false, out, lastExisting
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes the item from storage.
0000000000000000000000000000000000000000;;	func (e *Store) Delete(ctx genericapirequest.Context, name string, options *metav1.DeleteOptions) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		key, err := e.KeyFunc(ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := e.NewFunc()
0000000000000000000000000000000000000000;;		if err := e.Storage.Get(ctx, key, "", obj, false); err != nil {
0000000000000000000000000000000000000000;;			return nil, false, storeerr.InterpretDeleteError(err, e.QualifiedResource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// support older consumers of delete by treating "nil" as delete immediately
0000000000000000000000000000000000000000;;		if options == nil {
0000000000000000000000000000000000000000;;			options = metav1.NewDeleteOptions(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var preconditions storage.Preconditions
0000000000000000000000000000000000000000;;		if options.Preconditions != nil {
0000000000000000000000000000000000000000;;			preconditions.UID = options.Preconditions.UID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		graceful, pendingGraceful, err := rest.BeforeDelete(e.DeleteStrategy, ctx, obj, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// this means finalizers cannot be updated via DeleteOptions if a deletion is already pending
0000000000000000000000000000000000000000;;		if pendingGraceful {
0000000000000000000000000000000000000000;;			out, err := e.finalizeDelete(obj, false)
0000000000000000000000000000000000000000;;			return out, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check if obj has pending finalizers
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, kubeerr.NewInternalError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pendingFinalizers := len(accessor.GetFinalizers()) != 0
0000000000000000000000000000000000000000;;		var ignoreNotFound bool
0000000000000000000000000000000000000000;;		var deleteImmediately bool = true
0000000000000000000000000000000000000000;;		var lastExisting, out runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle combinations of graceful deletion and finalization by issuing
0000000000000000000000000000000000000000;;		// the correct updates.
0000000000000000000000000000000000000000;;		if e.EnableGarbageCollection {
0000000000000000000000000000000000000000;;			shouldUpdateFinalizers, _ := deletionFinalizers(e, accessor, options)
0000000000000000000000000000000000000000;;			// TODO: remove the check, because we support no-op updates now.
0000000000000000000000000000000000000000;;			if graceful || pendingFinalizers || shouldUpdateFinalizers {
0000000000000000000000000000000000000000;;				err, ignoreNotFound, deleteImmediately, out, lastExisting = e.updateForGracefulDeletionAndFinalizers(ctx, name, key, options, preconditions, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: remove the check on graceful, because we support no-op updates now.
0000000000000000000000000000000000000000;;			if graceful {
0000000000000000000000000000000000000000;;				err, ignoreNotFound, deleteImmediately, out, lastExisting = e.updateForGracefulDeletion(ctx, name, key, options, preconditions, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// !deleteImmediately covers all cases where err != nil. We keep both to be future-proof.
0000000000000000000000000000000000000000;;		if !deleteImmediately || err != nil {
0000000000000000000000000000000000000000;;			return out, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete immediately, or no graceful deletion supported
0000000000000000000000000000000000000000;;		glog.V(6).Infof("going to delete %s from registry: ", name)
0000000000000000000000000000000000000000;;		out = e.NewFunc()
0000000000000000000000000000000000000000;;		if err := e.Storage.Delete(ctx, key, out, &preconditions); err != nil {
0000000000000000000000000000000000000000;;			// Please refer to the place where we set ignoreNotFound for the reason
0000000000000000000000000000000000000000;;			// why we ignore the NotFound error .
0000000000000000000000000000000000000000;;			if storage.IsNotFound(err) && ignoreNotFound && lastExisting != nil {
0000000000000000000000000000000000000000;;				// The lastExisting object may not be the last state of the object
0000000000000000000000000000000000000000;;				// before its deletion, but it's the best approximation.
0000000000000000000000000000000000000000;;				out, err := e.finalizeDelete(lastExisting, true)
0000000000000000000000000000000000000000;;				return out, true, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, false, storeerr.InterpretDeleteError(err, e.QualifiedResource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, err = e.finalizeDelete(out, true)
0000000000000000000000000000000000000000;;		return out, true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyListOptions copies list options for mutation.
0000000000000000000000000000000000000000;;	func copyListOptions(options *metainternalversion.ListOptions) *metainternalversion.ListOptions {
0000000000000000000000000000000000000000;;		if options == nil {
0000000000000000000000000000000000000000;;			return &metainternalversion.ListOptions{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copied, err := metainternalversion.Copier.Copy(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copied.(*metainternalversion.ListOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteCollection removes all items returned by List with a given ListOptions from storage.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DeleteCollection is currently NOT atomic. It can happen that only subset of objects
0000000000000000000000000000000000000000;;	// will be deleted from storage, and then an error will be returned.
0000000000000000000000000000000000000000;;	// In case of success, the list of deleted objects will be returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: Currently, there is no easy way to remove 'directory' entry from storage (if we
0000000000000000000000000000000000000000;;	// are removing all objects of a given type) with the current API (it's technically
0000000000000000000000000000000000000000;;	// possibly with storage API, but watch is not delivered correctly then).
0000000000000000000000000000000000000000;;	// It will be possible to fix it with v3 etcd API.
0000000000000000000000000000000000000000;;	func (e *Store) DeleteCollection(ctx genericapirequest.Context, options *metav1.DeleteOptions, listOptions *metainternalversion.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		// DeleteCollection must remain backwards compatible with old clients that expect it to
0000000000000000000000000000000000000000;;		// remove all resources, initialized or not, within the type. It is also consistent with
0000000000000000000000000000000000000000;;		// Delete which does not require IncludeUninitialized
0000000000000000000000000000000000000000;;		listOptions = copyListOptions(listOptions)
0000000000000000000000000000000000000000;;		listOptions.IncludeUninitialized = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listObj, err := e.List(ctx, listOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := meta.ExtractList(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Spawn a number of goroutines, so that we can issue requests to storage
0000000000000000000000000000000000000000;;		// in parallel to speed up deletion.
0000000000000000000000000000000000000000;;		// TODO: Make this proportional to the number of items to delete, up to
0000000000000000000000000000000000000000;;		// DeleteCollectionWorkers (it doesn't make much sense to spawn 16
0000000000000000000000000000000000000000;;		// workers to delete 10 items).
0000000000000000000000000000000000000000;;		workersNumber := e.DeleteCollectionWorkers
0000000000000000000000000000000000000000;;		if workersNumber < 1 {
0000000000000000000000000000000000000000;;			workersNumber = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		toProcess := make(chan int, 2*workersNumber)
0000000000000000000000000000000000000000;;		errs := make(chan error, workersNumber+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer utilruntime.HandleCrash(func(panicReason interface{}) {
0000000000000000000000000000000000000000;;				errs <- fmt.Errorf("DeleteCollection distributor panicked: %v", panicReason)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			for i := 0; i < len(items); i++ {
0000000000000000000000000000000000000000;;				toProcess <- i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(toProcess)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Add(workersNumber)
0000000000000000000000000000000000000000;;		for i := 0; i < workersNumber; i++ {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				// panics don't cross goroutine boundaries
0000000000000000000000000000000000000000;;				defer utilruntime.HandleCrash(func(panicReason interface{}) {
0000000000000000000000000000000000000000;;					errs <- fmt.Errorf("DeleteCollection goroutine panicked: %v", panicReason)
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					index, ok := <-toProcess
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					accessor, err := meta.Accessor(items[index])
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errs <- err
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if _, _, err := e.Delete(ctx, accessor.GetName(), options); err != nil && !kubeerr.IsNotFound(err) {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Delete %s in DeleteCollection failed: %v", accessor.GetName(), err)
0000000000000000000000000000000000000000;;						errs <- err
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errs:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return listObj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finalizeDelete runs the Store's AfterDelete hook if runHooks is set and
0000000000000000000000000000000000000000;;	// returns the decorated deleted object if appropriate.
0000000000000000000000000000000000000000;;	func (e *Store) finalizeDelete(obj runtime.Object, runHooks bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if runHooks && e.AfterDelete != nil {
0000000000000000000000000000000000000000;;			if err := e.AfterDelete(obj); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.ReturnDeletedObject {
0000000000000000000000000000000000000000;;			if e.Decorator != nil {
0000000000000000000000000000000000000000;;				if err := e.Decorator(obj); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return obj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return information about the deleted object, which enables clients to
0000000000000000000000000000000000000000;;		// verify that the object was actually deleted and not waiting for finalizers.
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		details := &metav1.StatusDetails{
0000000000000000000000000000000000000000;;			Name:  accessor.GetName(),
0000000000000000000000000000000000000000;;			Group: e.QualifiedResource.Group,
0000000000000000000000000000000000000000;;			Kind:  e.QualifiedResource.Resource, // Yes we set Kind field to resource.
0000000000000000000000000000000000000000;;			UID:   accessor.GetUID(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		status := &metav1.Status{Status: metav1.StatusSuccess, Details: details}
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch makes a matcher for the given label and field, and calls
0000000000000000000000000000000000000000;;	// WatchPredicate. If possible, you should customize PredicateFunc to produce
0000000000000000000000000000000000000000;;	// a matcher that matches by key. SelectionPredicate does this for you
0000000000000000000000000000000000000000;;	// automatically.
0000000000000000000000000000000000000000;;	func (e *Store) Watch(ctx genericapirequest.Context, options *metainternalversion.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		label := labels.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.LabelSelector != nil {
0000000000000000000000000000000000000000;;			label = options.LabelSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		field := fields.Everything()
0000000000000000000000000000000000000000;;		if options != nil && options.FieldSelector != nil {
0000000000000000000000000000000000000000;;			field = options.FieldSelector
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		predicate := e.PredicateFunc(label, field)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceVersion := ""
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			resourceVersion = options.ResourceVersion
0000000000000000000000000000000000000000;;			predicate.IncludeUninitialized = options.IncludeUninitialized
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.WatchPredicate(ctx, predicate, resourceVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WatchPredicate starts a watch for the items that m matches.
0000000000000000000000000000000000000000;;	func (e *Store) WatchPredicate(ctx genericapirequest.Context, p storage.SelectionPredicate, resourceVersion string) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		if name, ok := p.MatchesSingle(); ok {
0000000000000000000000000000000000000000;;			if key, err := e.KeyFunc(ctx, name); err == nil {
0000000000000000000000000000000000000000;;				w, err := e.Storage.Watch(ctx, key, resourceVersion, p)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e.Decorator != nil {
0000000000000000000000000000000000000000;;					return newDecoratedWatcher(w, e.Decorator), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return w, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we cannot extract a key based on the current context, the
0000000000000000000000000000000000000000;;			// optimization is skipped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := e.Storage.WatchList(ctx, e.KeyRootFunc(ctx), resourceVersion, p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.Decorator != nil {
0000000000000000000000000000000000000000;;			return newDecoratedWatcher(w, e.Decorator), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// calculateTTL is a helper for retrieving the updated TTL for an object or
0000000000000000000000000000000000000000;;	// returning an error if the TTL cannot be calculated. The defaultTTL is
0000000000000000000000000000000000000000;;	// changed to 1 if less than zero. Zero means no TTL, not expire immediately.
0000000000000000000000000000000000000000;;	func (e *Store) calculateTTL(obj runtime.Object, defaultTTL int64, update bool) (ttl uint64, err error) {
0000000000000000000000000000000000000000;;		// TODO: validate this is assertion is still valid.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// etcd may return a negative TTL for a node if the expiration has not
0000000000000000000000000000000000000000;;		// occurred due to server lag - we will ensure that the value is at least
0000000000000000000000000000000000000000;;		// set.
0000000000000000000000000000000000000000;;		if defaultTTL < 0 {
0000000000000000000000000000000000000000;;			defaultTTL = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ttl = uint64(defaultTTL)
0000000000000000000000000000000000000000;;		if e.TTLFunc != nil {
0000000000000000000000000000000000000000;;			ttl, err = e.TTLFunc(obj, ttl, update)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ttl, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exportObjectMeta unsets the fields on the given object that should not be
0000000000000000000000000000000000000000;;	// present when the object is exported.
0000000000000000000000000000000000000000;;	func exportObjectMeta(accessor metav1.Object, exact bool) {
0000000000000000000000000000000000000000;;		accessor.SetUID("")
0000000000000000000000000000000000000000;;		if !exact {
0000000000000000000000000000000000000000;;			accessor.SetNamespace("")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor.SetCreationTimestamp(metav1.Time{})
0000000000000000000000000000000000000000;;		accessor.SetDeletionTimestamp(nil)
0000000000000000000000000000000000000000;;		accessor.SetResourceVersion("")
0000000000000000000000000000000000000000;;		accessor.SetSelfLink("")
0000000000000000000000000000000000000000;;		if len(accessor.GetGenerateName()) > 0 && !exact {
0000000000000000000000000000000000000000;;			accessor.SetName("")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Export implements the rest.Exporter interface
0000000000000000000000000000000000000000;;	func (e *Store) Export(ctx genericapirequest.Context, name string, opts metav1.ExportOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		obj, err := e.Get(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if accessor, err := meta.Accessor(obj); err == nil {
0000000000000000000000000000000000000000;;			exportObjectMeta(accessor, opts.Exact)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Object of type %v does not have ObjectMeta: %v", reflect.TypeOf(obj), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.ExportStrategy != nil {
0000000000000000000000000000000000000000;;			if err = e.ExportStrategy.Export(ctx, obj, opts.Exact); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.CreateStrategy.PrepareForCreate(ctx, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompleteWithOptions updates the store with the provided options and
0000000000000000000000000000000000000000;;	// defaults common fields.
0000000000000000000000000000000000000000;;	func (e *Store) CompleteWithOptions(options *generic.StoreOptions) error {
0000000000000000000000000000000000000000;;		if e.QualifiedResource.Empty() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("store %#v must have a non-empty qualified resource", e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.NewFunc == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("store for %s must have NewFunc set", e.QualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.NewListFunc == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("store for %s must have NewListFunc set", e.QualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (e.KeyRootFunc == nil) != (e.KeyFunc == nil) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("store for %s must set both KeyRootFunc and KeyFunc or neither", e.QualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var isNamespaced bool
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case e.CreateStrategy != nil:
0000000000000000000000000000000000000000;;			isNamespaced = e.CreateStrategy.NamespaceScoped()
0000000000000000000000000000000000000000;;		case e.UpdateStrategy != nil:
0000000000000000000000000000000000000000;;			isNamespaced = e.UpdateStrategy.NamespaceScoped()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("store for %s must have CreateStrategy or UpdateStrategy set", e.QualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.DeleteStrategy == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("store for %s must have DeleteStrategy set", e.QualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.RESTOptions == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("options for %s must have RESTOptions set", e.QualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.AttrFunc == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("options for %s must have AttrFunc set", e.QualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts, err := options.RESTOptions.GetRESTOptions(e.QualifiedResource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Resource prefix must come from the underlying factory
0000000000000000000000000000000000000000;;		prefix := opts.ResourcePrefix
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(prefix, "/") {
0000000000000000000000000000000000000000;;			prefix = "/" + prefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if prefix == "/" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("store for %s has an invalid prefix %q", e.QualifiedResource.String(), opts.ResourcePrefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the default behavior for storage key generation
0000000000000000000000000000000000000000;;		if e.KeyRootFunc == nil && e.KeyFunc == nil {
0000000000000000000000000000000000000000;;			if isNamespaced {
0000000000000000000000000000000000000000;;				e.KeyRootFunc = func(ctx genericapirequest.Context) string {
0000000000000000000000000000000000000000;;					return NamespaceKeyRootFunc(ctx, prefix)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.KeyFunc = func(ctx genericapirequest.Context, name string) (string, error) {
0000000000000000000000000000000000000000;;					return NamespaceKeyFunc(ctx, prefix, name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.KeyRootFunc = func(ctx genericapirequest.Context) string {
0000000000000000000000000000000000000000;;					return prefix
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.KeyFunc = func(ctx genericapirequest.Context, name string) (string, error) {
0000000000000000000000000000000000000000;;					return NoNamespaceKeyFunc(ctx, prefix, name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We adapt the store's keyFunc so that we can use it with the StorageDecorator
0000000000000000000000000000000000000000;;		// without making any assumptions about where objects are stored in etcd
0000000000000000000000000000000000000000;;		keyFunc := func(obj runtime.Object) (string, error) {
0000000000000000000000000000000000000000;;			accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isNamespaced {
0000000000000000000000000000000000000000;;				return e.KeyFunc(genericapirequest.WithNamespace(genericapirequest.NewContext(), accessor.GetNamespace()), accessor.GetName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return e.KeyFunc(genericapirequest.NewContext(), accessor.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		triggerFunc := options.TriggerFunc
0000000000000000000000000000000000000000;;		if triggerFunc == nil {
0000000000000000000000000000000000000000;;			triggerFunc = storage.NoTriggerPublisher
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.DeleteCollectionWorkers == 0 {
0000000000000000000000000000000000000000;;			e.DeleteCollectionWorkers = opts.DeleteCollectionWorkers
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.EnableGarbageCollection = opts.EnableGarbageCollection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.ObjectNameFunc == nil {
0000000000000000000000000000000000000000;;			e.ObjectNameFunc = func(obj runtime.Object) (string, error) {
0000000000000000000000000000000000000000;;				accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return accessor.GetName(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.Storage == nil {
0000000000000000000000000000000000000000;;			e.Storage, e.DestroyFunc = opts.Decorator(
0000000000000000000000000000000000000000;;				e.Copier,
0000000000000000000000000000000000000000;;				opts.StorageConfig,
0000000000000000000000000000000000000000;;				e.WatchCacheSize,
0000000000000000000000000000000000000000;;				e.NewFunc(),
0000000000000000000000000000000000000000;;				prefix,
0000000000000000000000000000000000000000;;				keyFunc,
0000000000000000000000000000000000000000;;				e.NewListFunc,
0000000000000000000000000000000000000000;;				options.AttrFunc,
0000000000000000000000000000000000000000;;				triggerFunc,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Store) ConvertToTable(ctx genericapirequest.Context, object runtime.Object, tableOptions runtime.Object) (*metav1alpha1.Table, error) {
0000000000000000000000000000000000000000;;		if e.TableConvertor != nil {
0000000000000000000000000000000000000000;;			return e.TableConvertor.ConvertToTable(ctx, object, tableOptions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rest.NewDefaultTableConvertor(e.QualifiedResource).ConvertToTable(ctx, object, tableOptions)
0000000000000000000000000000000000000000;;	}
