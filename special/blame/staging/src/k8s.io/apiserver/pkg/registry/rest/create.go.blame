0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6c6b79624f5ca15b220f88cdd468924a7bb5f854;pkg/api/rest/create.go[pkg/api/rest/create.go][staging/src/k8s.io/apiserver/pkg/registry/rest/create.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		genericvalidation "k8s.io/apimachinery/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation/path"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/names"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTCreateStrategy defines the minimum validation, accepted input, and
0000000000000000000000000000000000000000;;	// name generation behavior to create an object that follows Kubernetes
0000000000000000000000000000000000000000;;	// API conventions.
0000000000000000000000000000000000000000;;	type RESTCreateStrategy interface {
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;		// The name generator is used when the standard GenerateName field is set.
0000000000000000000000000000000000000000;;		// The NameGenerator will be invoked prior to validation.
0000000000000000000000000000000000000000;;		names.NameGenerator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NamespaceScoped returns true if the object must be within a namespace.
0000000000000000000000000000000000000000;;		NamespaceScoped() bool
0000000000000000000000000000000000000000;;		// PrepareForCreate is invoked on create before validation to normalize
0000000000000000000000000000000000000000;;		// the object.  For example: remove fields that are not to be persisted,
0000000000000000000000000000000000000000;;		// sort order-insensitive list fields, etc.  This should not remove fields
0000000000000000000000000000000000000000;;		// whose presence would be considered a validation error.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Often implemented as a type check and an initailization or clearing of
0000000000000000000000000000000000000000;;		// status. Clear the status because status changes are internal. External
0000000000000000000000000000000000000000;;		// callers of an api (users) should not be setting an initial status on
0000000000000000000000000000000000000000;;		// newly created objects.
0000000000000000000000000000000000000000;;		PrepareForCreate(ctx genericapirequest.Context, obj runtime.Object)
0000000000000000000000000000000000000000;;		// Validate returns an ErrorList with validation errors or nil.  Validate
0000000000000000000000000000000000000000;;		// is invoked after default fields in the object have been filled in
0000000000000000000000000000000000000000;;		// before the object is persisted.  This method should not mutate the
0000000000000000000000000000000000000000;;		// object.
0000000000000000000000000000000000000000;;		Validate(ctx genericapirequest.Context, obj runtime.Object) field.ErrorList
0000000000000000000000000000000000000000;;		// Canonicalize allows an object to be mutated into a canonical form. This
0000000000000000000000000000000000000000;;		// ensures that code that operates on these objects can rely on the common
0000000000000000000000000000000000000000;;		// form for things like comparison.  Canonicalize is invoked after
0000000000000000000000000000000000000000;;		// validation has succeeded but before the object has been persisted.
0000000000000000000000000000000000000000;;		// This method may mutate the object. Often implemented as a type check or
0000000000000000000000000000000000000000;;		// empty method.
0000000000000000000000000000000000000000;;		Canonicalize(obj runtime.Object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BeforeCreate ensures that common operations for all resources are performed on creation. It only returns
0000000000000000000000000000000000000000;;	// errors that can be converted to api.Status. It invokes PrepareForCreate, then GenerateName, then Validate.
0000000000000000000000000000000000000000;;	// It returns nil if the object should be created.
0000000000000000000000000000000000000000;;	func BeforeCreate(strategy RESTCreateStrategy, ctx genericapirequest.Context, obj runtime.Object) error {
0000000000000000000000000000000000000000;;		objectMeta, kind, kerr := objectMetaAndKind(strategy, obj)
0000000000000000000000000000000000000000;;		if kerr != nil {
0000000000000000000000000000000000000000;;			return kerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			if !ValidNamespace(ctx, objectMeta) {
0000000000000000000000000000000000000000;;				return errors.NewBadRequest("the namespace of the provided object does not match the namespace sent on the request")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			objectMeta.SetNamespace(metav1.NamespaceNone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta.SetDeletionTimestamp(nil)
0000000000000000000000000000000000000000;;		objectMeta.SetDeletionGracePeriodSeconds(nil)
0000000000000000000000000000000000000000;;		strategy.PrepareForCreate(ctx, obj)
0000000000000000000000000000000000000000;;		FillObjectMetaSystemFields(ctx, objectMeta)
0000000000000000000000000000000000000000;;		if len(objectMeta.GetGenerateName()) > 0 && len(objectMeta.GetName()) == 0 {
0000000000000000000000000000000000000000;;			objectMeta.SetName(strategy.GenerateName(objectMeta.GetGenerateName()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClusterName is ignored and should not be saved
0000000000000000000000000000000000000000;;		objectMeta.SetClusterName("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if errs := strategy.Validate(ctx, obj); len(errs) > 0 {
0000000000000000000000000000000000000000;;			return errors.NewInvalid(kind.GroupKind(), objectMeta.GetName(), errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Custom validation (including name validation) passed
0000000000000000000000000000000000000000;;		// Now run common validation on object meta
0000000000000000000000000000000000000000;;		// Do this *after* custom validation so that specific error messages are shown whenever possible
0000000000000000000000000000000000000000;;		if errs := genericvalidation.ValidateObjectMetaAccessor(objectMeta, strategy.NamespaceScoped(), path.ValidatePathSegmentName, field.NewPath("metadata")); len(errs) > 0 {
0000000000000000000000000000000000000000;;			return errors.NewInvalid(kind.GroupKind(), objectMeta.GetName(), errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strategy.Canonicalize(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckGeneratedNameError checks whether an error that occurred creating a resource is due
0000000000000000000000000000000000000000;;	// to generation being unable to pick a valid name.
0000000000000000000000000000000000000000;;	func CheckGeneratedNameError(strategy RESTCreateStrategy, err error, obj runtime.Object) error {
0000000000000000000000000000000000000000;;		if !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objectMeta, kind, kerr := objectMetaAndKind(strategy, obj)
0000000000000000000000000000000000000000;;		if kerr != nil {
0000000000000000000000000000000000000000;;			return kerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(objectMeta.GetGenerateName()) == 0 {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors.NewServerTimeoutForKind(kind.GroupKind(), "POST", 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectMetaAndKind retrieves kind and ObjectMeta from a runtime object, or returns an error.
0000000000000000000000000000000000000000;;	func objectMetaAndKind(typer runtime.ObjectTyper, obj runtime.Object) (metav1.Object, schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		objectMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, schema.GroupVersionKind{}, errors.NewInternalError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kinds, _, err := typer.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, schema.GroupVersionKind{}, errors.NewInternalError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return objectMeta, kinds[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceScopedStrategy has a method to tell if the object must be in a namespace.
0000000000000000000000000000000000000000;;	type NamespaceScopedStrategy interface {
0000000000000000000000000000000000000000;;		// NamespaceScoped returns if the object must be in a namespace.
0000000000000000000000000000000000000000;;		NamespaceScoped() bool
0000000000000000000000000000000000000000;;	}
