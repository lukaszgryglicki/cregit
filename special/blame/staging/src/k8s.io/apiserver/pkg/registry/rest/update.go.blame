0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
aeaccc360b17e2d29bd14adae57e77558516e94b;pkg/api/rest/update.go[pkg/api/rest/update.go][staging/src/k8s.io/apiserver/pkg/registry/rest/update.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		genericvalidation "k8s.io/apimachinery/pkg/api/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation/path"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTUpdateStrategy defines the minimum validation, accepted input, and
0000000000000000000000000000000000000000;;	// name generation behavior to update an object that follows Kubernetes
0000000000000000000000000000000000000000;;	// API conventions. A resource may have many UpdateStrategies, depending on
0000000000000000000000000000000000000000;;	// the call pattern in use.
0000000000000000000000000000000000000000;;	type RESTUpdateStrategy interface {
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;		// NamespaceScoped returns true if the object must be within a namespace.
0000000000000000000000000000000000000000;;		NamespaceScoped() bool
0000000000000000000000000000000000000000;;		// AllowCreateOnUpdate returns true if the object can be created by a PUT.
0000000000000000000000000000000000000000;;		AllowCreateOnUpdate() bool
0000000000000000000000000000000000000000;;		// PrepareForUpdate is invoked on update before validation to normalize
0000000000000000000000000000000000000000;;		// the object.  For example: remove fields that are not to be persisted,
0000000000000000000000000000000000000000;;		// sort order-insensitive list fields, etc.  This should not remove fields
0000000000000000000000000000000000000000;;		// whose presence would be considered a validation error.
0000000000000000000000000000000000000000;;		PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object)
0000000000000000000000000000000000000000;;		// ValidateUpdate is invoked after default fields in the object have been
0000000000000000000000000000000000000000;;		// filled in before the object is persisted.  This method should not mutate
0000000000000000000000000000000000000000;;		// the object.
0000000000000000000000000000000000000000;;		ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList
0000000000000000000000000000000000000000;;		// Canonicalize allows an object to be mutated into a canonical form. This
0000000000000000000000000000000000000000;;		// ensures that code that operates on these objects can rely on the common
0000000000000000000000000000000000000000;;		// form for things like comparison.  Canonicalize is invoked after
0000000000000000000000000000000000000000;;		// validation has succeeded but before the object has been persisted.
0000000000000000000000000000000000000000;;		// This method may mutate the object.
0000000000000000000000000000000000000000;;		Canonicalize(obj runtime.Object)
0000000000000000000000000000000000000000;;		// AllowUnconditionalUpdate returns true if the object can be updated
0000000000000000000000000000000000000000;;		// unconditionally (irrespective of the latest resource version), when
0000000000000000000000000000000000000000;;		// there is no resource version specified in the object.
0000000000000000000000000000000000000000;;		AllowUnconditionalUpdate() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: add other common fields that require global validation.
0000000000000000000000000000000000000000;;	func validateCommonFields(obj, old runtime.Object, strategy RESTUpdateStrategy) (field.ErrorList, error) {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		objectMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get new object metadata: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldObjectMeta, err := meta.Accessor(old)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get old object metadata: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, genericvalidation.ValidateObjectMetaAccessor(objectMeta, strategy.NamespaceScoped(), path.ValidatePathSegmentName, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, genericvalidation.ValidateObjectMetaAccessorUpdate(objectMeta, oldObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BeforeUpdate ensures that common operations for all resources are performed on update. It only returns
0000000000000000000000000000000000000000;;	// errors that can be converted to api.Status. It will invoke update validation with the provided existing
0000000000000000000000000000000000000000;;	// and updated objects.
0000000000000000000000000000000000000000;;	func BeforeUpdate(strategy RESTUpdateStrategy, ctx genericapirequest.Context, obj, old runtime.Object) error {
0000000000000000000000000000000000000000;;		objectMeta, kind, kerr := objectMetaAndKind(strategy, obj)
0000000000000000000000000000000000000000;;		if kerr != nil {
0000000000000000000000000000000000000000;;			return kerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			if !ValidNamespace(ctx, objectMeta) {
0000000000000000000000000000000000000000;;				return errors.NewBadRequest("the namespace of the provided object does not match the namespace sent on the request")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			objectMeta.SetNamespace(metav1.NamespaceNone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ensure requests cannot update generation
0000000000000000000000000000000000000000;;		oldMeta, err := meta.Accessor(old)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta.SetGeneration(oldMeta.GetGeneration())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strategy.PrepareForUpdate(ctx, obj, old)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClusterName is ignored and should not be saved
0000000000000000000000000000000000000000;;		objectMeta.SetClusterName("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure some common fields, like UID, are validated for all resources.
0000000000000000000000000000000000000000;;		errs, err := validateCommonFields(obj, old, strategy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return errors.NewInternalError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs = append(errs, strategy.ValidateUpdate(ctx, obj, old)...)
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			return errors.NewInvalid(kind.GroupKind(), objectMeta.GetName(), errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strategy.Canonicalize(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransformFunc is a function to transform and return newObj
0000000000000000000000000000000000000000;;	type TransformFunc func(ctx genericapirequest.Context, newObj runtime.Object, oldObj runtime.Object) (transformedNewObj runtime.Object, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultUpdatedObjectInfo implements UpdatedObjectInfo
0000000000000000000000000000000000000000;;	type defaultUpdatedObjectInfo struct {
0000000000000000000000000000000000000000;;		// obj is the updated object
0000000000000000000000000000000000000000;;		obj runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copier makes a copy of the object before returning it.
0000000000000000000000000000000000000000;;		// this allows repeated calls to UpdatedObject() to return
0000000000000000000000000000000000000000;;		// pristine data, even if the returned value is mutated.
0000000000000000000000000000000000000000;;		copier runtime.ObjectCopier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// transformers is an optional list of transforming functions that modify or
0000000000000000000000000000000000000000;;		// replace obj using information from the context, old object, or other sources.
0000000000000000000000000000000000000000;;		transformers []TransformFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultUpdatedObjectInfo returns an UpdatedObjectInfo impl based on the specified object.
0000000000000000000000000000000000000000;;	func DefaultUpdatedObjectInfo(obj runtime.Object, copier runtime.ObjectCopier, transformers ...TransformFunc) UpdatedObjectInfo {
0000000000000000000000000000000000000000;;		return &defaultUpdatedObjectInfo{obj, copier, transformers}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Preconditions satisfies the UpdatedObjectInfo interface.
0000000000000000000000000000000000000000;;	func (i *defaultUpdatedObjectInfo) Preconditions() *metav1.Preconditions {
0000000000000000000000000000000000000000;;		// Attempt to get the UID out of the object
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(i.obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If no UID can be read, no preconditions are possible
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If empty, no preconditions needed
0000000000000000000000000000000000000000;;		uid := accessor.GetUID()
0000000000000000000000000000000000000000;;		if len(uid) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &metav1.Preconditions{UID: &uid}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdatedObject satisfies the UpdatedObjectInfo interface.
0000000000000000000000000000000000000000;;	// It returns a copy of the held obj, passed through any configured transformers.
0000000000000000000000000000000000000000;;	func (i *defaultUpdatedObjectInfo) UpdatedObject(ctx genericapirequest.Context, oldObj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// Start with the configured object
0000000000000000000000000000000000000000;;		newObj := i.obj
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the original is non-nil (might be nil if the first transformer builds the object from the oldObj), make a copy,
0000000000000000000000000000000000000000;;		// so we don't return the original. BeforeUpdate can mutate the returned object, doing things like clearing ResourceVersion.
0000000000000000000000000000000000000000;;		// If we're re-called, we need to be able to return the pristine version.
0000000000000000000000000000000000000000;;		if newObj != nil {
0000000000000000000000000000000000000000;;			newObj, err = i.copier.Copy(newObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow any configured transformers to update the new object
0000000000000000000000000000000000000000;;		for _, transformer := range i.transformers {
0000000000000000000000000000000000000000;;			newObj, err = transformer(ctx, newObj, oldObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newObj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrappedUpdatedObjectInfo allows wrapping an existing objInfo and
0000000000000000000000000000000000000000;;	// chaining additional transformations/checks on the result of UpdatedObject()
0000000000000000000000000000000000000000;;	type wrappedUpdatedObjectInfo struct {
0000000000000000000000000000000000000000;;		// obj is the updated object
0000000000000000000000000000000000000000;;		objInfo UpdatedObjectInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// transformers is an optional list of transforming functions that modify or
0000000000000000000000000000000000000000;;		// replace obj using information from the context, old object, or other sources.
0000000000000000000000000000000000000000;;		transformers []TransformFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WrapUpdatedObjectInfo returns an UpdatedObjectInfo impl that delegates to
0000000000000000000000000000000000000000;;	// the specified objInfo, then calls the passed transformers
0000000000000000000000000000000000000000;;	func WrapUpdatedObjectInfo(objInfo UpdatedObjectInfo, transformers ...TransformFunc) UpdatedObjectInfo {
0000000000000000000000000000000000000000;;		return &wrappedUpdatedObjectInfo{objInfo, transformers}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Preconditions satisfies the UpdatedObjectInfo interface.
0000000000000000000000000000000000000000;;	func (i *wrappedUpdatedObjectInfo) Preconditions() *metav1.Preconditions {
0000000000000000000000000000000000000000;;		return i.objInfo.Preconditions()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdatedObject satisfies the UpdatedObjectInfo interface.
0000000000000000000000000000000000000000;;	// It delegates to the wrapped objInfo and passes the result through any configured transformers.
0000000000000000000000000000000000000000;;	func (i *wrappedUpdatedObjectInfo) UpdatedObject(ctx genericapirequest.Context, oldObj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		newObj, err := i.objInfo.UpdatedObject(ctx, oldObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newObj, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow any configured transformers to update the new object or error
0000000000000000000000000000000000000000;;		for _, transformer := range i.transformers {
0000000000000000000000000000000000000000;;			newObj, err = transformer(ctx, newObj, oldObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newObj, nil
0000000000000000000000000000000000000000;;	}
