0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2e83d02eea1f99d7a67687d9571cd258c111e901;pkg/registry/generic/registry/decorated_watcher.go[pkg/registry/generic/registry/decorated_watcher.go][staging/src/k8s.io/apiserver/pkg/registry/generic/registry/decorated_watcher.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decoratedWatcher struct {
0000000000000000000000000000000000000000;;		w         watch.Interface
0000000000000000000000000000000000000000;;		decorator ObjectFunc
0000000000000000000000000000000000000000;;		cancel    context.CancelFunc
0000000000000000000000000000000000000000;;		resultCh  chan watch.Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDecoratedWatcher(w watch.Interface, decorator ObjectFunc) *decoratedWatcher {
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		d := &decoratedWatcher{
0000000000000000000000000000000000000000;;			w:         w,
0000000000000000000000000000000000000000;;			decorator: decorator,
0000000000000000000000000000000000000000;;			cancel:    cancel,
0000000000000000000000000000000000000000;;			resultCh:  make(chan watch.Event),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go d.run(ctx)
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoratedWatcher) run(ctx context.Context) {
0000000000000000000000000000000000000000;;		var recv, send watch.Event
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case recv = <-d.w.ResultChan():
0000000000000000000000000000000000000000;;				switch recv.Type {
0000000000000000000000000000000000000000;;				case watch.Added, watch.Modified, watch.Deleted:
0000000000000000000000000000000000000000;;					err := d.decorator(recv.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						send = makeStatusErrorEvent(err)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					send = recv
0000000000000000000000000000000000000000;;				case watch.Error:
0000000000000000000000000000000000000000;;					send = recv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case d.resultCh <- send:
0000000000000000000000000000000000000000;;					if send.Type == watch.Error {
0000000000000000000000000000000000000000;;						d.cancel()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-ctx.Done():
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				d.w.Stop()
0000000000000000000000000000000000000000;;				close(d.resultCh)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoratedWatcher) Stop() {
0000000000000000000000000000000000000000;;		d.cancel()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoratedWatcher) ResultChan() <-chan watch.Event {
0000000000000000000000000000000000000000;;		return d.resultCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeStatusErrorEvent(err error) watch.Event {
0000000000000000000000000000000000000000;;		status := &metav1.Status{
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Message: err.Error(),
0000000000000000000000000000000000000000;;			Code:    http.StatusInternalServerError,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonInternalError,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return watch.Event{
0000000000000000000000000000000000000000;;			Type:   watch.Error,
0000000000000000000000000000000000000000;;			Object: status,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
