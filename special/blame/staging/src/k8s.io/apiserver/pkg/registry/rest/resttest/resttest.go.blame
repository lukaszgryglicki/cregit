0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6c6b79624f5ca15b220f88cdd468924a7bb5f854;pkg/api/rest/resttest/resttest.go[pkg/api/rest/resttest/resttest.go][staging/src/k8s.io/apiserver/pkg/registry/rest/resttest/resttest.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resttest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/validation/path"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Tester struct {
0000000000000000000000000000000000000000;;		*testing.T
0000000000000000000000000000000000000000;;		storage             rest.Storage
0000000000000000000000000000000000000000;;		clusterScope        bool
0000000000000000000000000000000000000000;;		createOnUpdate      bool
0000000000000000000000000000000000000000;;		generatesName       bool
0000000000000000000000000000000000000000;;		returnDeletedObject bool
0000000000000000000000000000000000000000;;		namer               func(int) string
0000000000000000000000000000000000000000;;		scheme              *runtime.Scheme
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(t *testing.T, storage rest.Storage, scheme *runtime.Scheme) *Tester {
0000000000000000000000000000000000000000;;		return &Tester{
0000000000000000000000000000000000000000;;			T:       t,
0000000000000000000000000000000000000000;;			storage: storage,
0000000000000000000000000000000000000000;;			namer:   defaultNamer,
0000000000000000000000000000000000000000;;			scheme:  scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultNamer(i int) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("foo%d", i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namer allows providing a custom name maker
0000000000000000000000000000000000000000;;	// By default "foo%d" is used
0000000000000000000000000000000000000000;;	func (t *Tester) Namer(namer func(int) string) *Tester {
0000000000000000000000000000000000000000;;		t.namer = namer
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) ClusterScope() *Tester {
0000000000000000000000000000000000000000;;		t.clusterScope = true
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) AllowCreateOnUpdate() *Tester {
0000000000000000000000000000000000000000;;		t.createOnUpdate = true
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) GeneratesName() *Tester {
0000000000000000000000000000000000000000;;		t.generatesName = true
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) ReturnDeletedObject() *Tester {
0000000000000000000000000000000000000000;;		t.returnDeletedObject = true
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestNamespace returns the namespace that will be used when creating contexts.
0000000000000000000000000000000000000000;;	// Returns NamespaceNone for cluster-scoped objects.
0000000000000000000000000000000000000000;;	func (t *Tester) TestNamespace() string {
0000000000000000000000000000000000000000;;		if t.clusterScope {
0000000000000000000000000000000000000000;;			return metav1.NamespaceNone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "test"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestContext returns a namespaced context that will be used when making storage calls.
0000000000000000000000000000000000000000;;	// Namespace is determined by TestNamespace()
0000000000000000000000000000000000000000;;	func (t *Tester) TestContext() genericapirequest.Context {
0000000000000000000000000000000000000000;;		if t.clusterScope {
0000000000000000000000000000000000000000;;			return genericapirequest.NewContext()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return genericapirequest.WithNamespace(genericapirequest.NewContext(), t.TestNamespace())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) getObjectMetaOrFail(obj runtime.Object) metav1.Object {
0000000000000000000000000000000000000000;;		objMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("object does not have ObjectMeta: %v\n%#v", err, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return objMeta
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) setObjectMeta(obj runtime.Object, name string) {
0000000000000000000000000000000000000000;;		meta := t.getObjectMetaOrFail(obj)
0000000000000000000000000000000000000000;;		meta.SetName(name)
0000000000000000000000000000000000000000;;		if t.clusterScope {
0000000000000000000000000000000000000000;;			meta.SetNamespace(metav1.NamespaceNone)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			meta.SetNamespace(genericapirequest.NamespaceValue(t.TestContext()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		meta.SetGenerateName("")
0000000000000000000000000000000000000000;;		meta.SetGeneration(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyOrDie(obj runtime.Object, copier runtime.ObjectCopier) runtime.Object {
0000000000000000000000000000000000000000;;		out, err := copier.Copy(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AssignFunc func([]runtime.Object) []runtime.Object
0000000000000000000000000000000000000000;;	type EmitFunc func(runtime.Object, string) error
0000000000000000000000000000000000000000;;	type GetFunc func(genericapirequest.Context, runtime.Object) (runtime.Object, error)
0000000000000000000000000000000000000000;;	type InitWatchFunc func()
0000000000000000000000000000000000000000;;	type InjectErrFunc func(err error)
0000000000000000000000000000000000000000;;	type IsErrorFunc func(err error) bool
0000000000000000000000000000000000000000;;	type CreateFunc func(genericapirequest.Context, runtime.Object) error
0000000000000000000000000000000000000000;;	type SetRVFunc func(uint64)
0000000000000000000000000000000000000000;;	type UpdateFunc func(runtime.Object) runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test creating an object.
0000000000000000000000000000000000000000;;	func (t *Tester) TestCreate(valid runtime.Object, createFn CreateFunc, getFn GetFunc, invalid ...runtime.Object) {
0000000000000000000000000000000000000000;;		t.testCreateHasMetadata(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		if !t.generatesName {
0000000000000000000000000000000000000000;;			t.testCreateGeneratesName(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.testCreateEquals(copyOrDie(valid, t.scheme), getFn)
0000000000000000000000000000000000000000;;		t.testCreateAlreadyExisting(copyOrDie(valid, t.scheme), createFn)
0000000000000000000000000000000000000000;;		if t.clusterScope {
0000000000000000000000000000000000000000;;			t.testCreateDiscardsObjectNamespace(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;			t.testCreateIgnoresContextNamespace(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;			t.testCreateIgnoresMismatchedNamespace(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;			t.testCreateResetsUserData(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.testCreateRejectsMismatchedNamespace(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.testCreateInvokesValidation(invalid...)
0000000000000000000000000000000000000000;;		t.testCreateValidatesNames(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		t.testCreateIgnoreClusterName(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test updating an object.
0000000000000000000000000000000000000000;;	func (t *Tester) TestUpdate(valid runtime.Object, createFn CreateFunc, getFn GetFunc, updateFn UpdateFunc, invalidUpdateFn ...UpdateFunc) {
0000000000000000000000000000000000000000;;		t.testUpdateEquals(copyOrDie(valid, t.scheme), createFn, getFn, updateFn)
0000000000000000000000000000000000000000;;		t.testUpdateFailsOnVersionTooOld(copyOrDie(valid, t.scheme), createFn, getFn)
0000000000000000000000000000000000000000;;		t.testUpdateOnNotFound(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		if !t.clusterScope {
0000000000000000000000000000000000000000;;			t.testUpdateRejectsMismatchedNamespace(copyOrDie(valid, t.scheme), createFn, getFn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.testUpdateInvokesValidation(copyOrDie(valid, t.scheme), createFn, invalidUpdateFn...)
0000000000000000000000000000000000000000;;		t.testUpdateWithWrongUID(copyOrDie(valid, t.scheme), createFn, getFn)
0000000000000000000000000000000000000000;;		t.testUpdateRetrievesOldObject(copyOrDie(valid, t.scheme), createFn, getFn)
0000000000000000000000000000000000000000;;		t.testUpdatePropagatesUpdatedObjectError(copyOrDie(valid, t.scheme), createFn, getFn)
0000000000000000000000000000000000000000;;		t.testUpdateIgnoreGenerationUpdates(copyOrDie(valid, t.scheme), createFn, getFn)
0000000000000000000000000000000000000000;;		t.testUpdateIgnoreClusterName(copyOrDie(valid, t.scheme), createFn, getFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test deleting an object.
0000000000000000000000000000000000000000;;	func (t *Tester) TestDelete(valid runtime.Object, createFn CreateFunc, getFn GetFunc, isNotFoundFn IsErrorFunc) {
0000000000000000000000000000000000000000;;		t.testDeleteNonExist(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		t.testDeleteNoGraceful(copyOrDie(valid, t.scheme), createFn, getFn, isNotFoundFn)
0000000000000000000000000000000000000000;;		t.testDeleteWithUID(copyOrDie(valid, t.scheme), createFn, getFn, isNotFoundFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test gracefully deleting an object.
0000000000000000000000000000000000000000;;	func (t *Tester) TestDeleteGraceful(valid runtime.Object, createFn CreateFunc, getFn GetFunc, expectedGrace int64) {
0000000000000000000000000000000000000000;;		t.testDeleteGracefulHasDefault(copyOrDie(valid, t.scheme), createFn, getFn, expectedGrace)
0000000000000000000000000000000000000000;;		t.testDeleteGracefulWithValue(copyOrDie(valid, t.scheme), createFn, getFn, expectedGrace)
0000000000000000000000000000000000000000;;		t.testDeleteGracefulUsesZeroOnNil(copyOrDie(valid, t.scheme), createFn, expectedGrace)
0000000000000000000000000000000000000000;;		t.testDeleteGracefulExtend(copyOrDie(valid, t.scheme), createFn, getFn, expectedGrace)
0000000000000000000000000000000000000000;;		t.testDeleteGracefulShorten(copyOrDie(valid, t.scheme), createFn, getFn, expectedGrace)
0000000000000000000000000000000000000000;;		t.testDeleteGracefulImmediate(copyOrDie(valid, t.scheme), createFn, getFn, expectedGrace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test getting object.
0000000000000000000000000000000000000000;;	func (t *Tester) TestGet(valid runtime.Object) {
0000000000000000000000000000000000000000;;		t.testGetFound(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		t.testGetNotFound(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		t.testGetMimatchedNamespace(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		if !t.clusterScope {
0000000000000000000000000000000000000000;;			t.testGetDifferentNamespace(copyOrDie(valid, t.scheme))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test listing objects.
0000000000000000000000000000000000000000;;	func (t *Tester) TestList(valid runtime.Object, assignFn AssignFunc) {
0000000000000000000000000000000000000000;;		t.testListNotFound(assignFn)
0000000000000000000000000000000000000000;;		t.testListFound(copyOrDie(valid, t.scheme), assignFn)
0000000000000000000000000000000000000000;;		t.testListMatchLabels(copyOrDie(valid, t.scheme), assignFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test watching objects.
0000000000000000000000000000000000000000;;	func (t *Tester) TestWatch(
0000000000000000000000000000000000000000;;		valid runtime.Object, emitFn EmitFunc,
0000000000000000000000000000000000000000;;		labelsPass, labelsFail []labels.Set, fieldsPass, fieldsFail []fields.Set, actions []string) {
0000000000000000000000000000000000000000;;		t.testWatchLabels(copyOrDie(valid, t.scheme), emitFn, labelsPass, labelsFail, actions)
0000000000000000000000000000000000000000;;		t.testWatchFields(copyOrDie(valid, t.scheme), emitFn, fieldsPass, fieldsFail, actions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =============================================================================
0000000000000000000000000000000000000000;;	// Creation tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) delete(ctx genericapirequest.Context, obj runtime.Object) error {
0000000000000000000000000000000000000000;;		objectMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deleter, ok := t.storage.(rest.GracefulDeleter)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected deleting storage, got %v", t.storage)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err = deleter.Delete(ctx, objectMeta.GetName(), nil)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateAlreadyExisting(obj runtime.Object, createFn CreateFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(1))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(ctx, foo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := t.storage.(rest.Creater).Create(ctx, foo, false)
0000000000000000000000000000000000000000;;		if !errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			t.Errorf("expected already exists err, got %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateEquals(obj runtime.Object, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(2))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		created, err := t.storage.(rest.Creater).Create(ctx, foo, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(ctx, created)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set resource version which might be unset in created object.
0000000000000000000000000000000000000000;;		createdMeta := t.getObjectMetaOrFail(created)
0000000000000000000000000000000000000000;;		gotMeta := t.getObjectMetaOrFail(got)
0000000000000000000000000000000000000000;;		createdMeta.SetResourceVersion(gotMeta.GetResourceVersion())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := created, got; !apiequality.Semantic.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected obj: %#v, expected %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateDiscardsObjectNamespace(valid runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(valid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore non-empty namespace in object meta
0000000000000000000000000000000000000000;;		objectMeta.SetNamespace("not-default")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ideally, we'd get an error back here, but at least verify the namespace wasn't persisted
0000000000000000000000000000000000000000;;		created, err := t.storage.(rest.Creater).Create(t.TestContext(), copyOrDie(valid, t.scheme), false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(t.TestContext(), created)
0000000000000000000000000000000000000000;;		createdObjectMeta := t.getObjectMetaOrFail(created)
0000000000000000000000000000000000000000;;		if createdObjectMeta.GetNamespace() != metav1.NamespaceNone {
0000000000000000000000000000000000000000;;			t.Errorf("Expected empty namespace on created object, got '%v'", createdObjectMeta.GetNamespace())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateGeneratesName(valid runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(valid)
0000000000000000000000000000000000000000;;		objectMeta.SetName("")
0000000000000000000000000000000000000000;;		objectMeta.SetGenerateName("test-")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		created, err := t.storage.(rest.Creater).Create(t.TestContext(), valid, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(t.TestContext(), created)
0000000000000000000000000000000000000000;;		if objectMeta.GetName() == "test-" || !strings.HasPrefix(objectMeta.GetName(), "test-") {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected name: %#v", valid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateHasMetadata(valid runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(valid)
0000000000000000000000000000000000000000;;		objectMeta.SetName(t.namer(1))
0000000000000000000000000000000000000000;;		objectMeta.SetNamespace(t.TestNamespace())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := t.storage.(rest.Creater).Create(t.TestContext(), valid, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected object from result: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(t.TestContext(), obj)
0000000000000000000000000000000000000000;;		if !metav1.HasObjectMetaSystemFieldValues(objectMeta) {
0000000000000000000000000000000000000000;;			t.Errorf("storage did not populate object meta field values")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateIgnoresContextNamespace(valid runtime.Object) {
0000000000000000000000000000000000000000;;		// Ignore non-empty namespace in context
0000000000000000000000000000000000000000;;		ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), "not-default2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ideally, we'd get an error back here, but at least verify the namespace wasn't persisted
0000000000000000000000000000000000000000;;		created, err := t.storage.(rest.Creater).Create(ctx, copyOrDie(valid, t.scheme), false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(ctx, created)
0000000000000000000000000000000000000000;;		createdObjectMeta := t.getObjectMetaOrFail(created)
0000000000000000000000000000000000000000;;		if createdObjectMeta.GetNamespace() != metav1.NamespaceNone {
0000000000000000000000000000000000000000;;			t.Errorf("Expected empty namespace on created object, got '%v'", createdObjectMeta.GetNamespace())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateIgnoresMismatchedNamespace(valid runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(valid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore non-empty namespace in object meta
0000000000000000000000000000000000000000;;		objectMeta.SetNamespace("not-default")
0000000000000000000000000000000000000000;;		ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), "not-default2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ideally, we'd get an error back here, but at least verify the namespace wasn't persisted
0000000000000000000000000000000000000000;;		created, err := t.storage.(rest.Creater).Create(ctx, copyOrDie(valid, t.scheme), false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(ctx, created)
0000000000000000000000000000000000000000;;		createdObjectMeta := t.getObjectMetaOrFail(created)
0000000000000000000000000000000000000000;;		if createdObjectMeta.GetNamespace() != metav1.NamespaceNone {
0000000000000000000000000000000000000000;;			t.Errorf("Expected empty namespace on created object, got '%v'", createdObjectMeta.GetNamespace())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateValidatesNames(valid runtime.Object) {
0000000000000000000000000000000000000000;;		for _, invalidName := range path.NameMayNotBe {
0000000000000000000000000000000000000000;;			objCopy := copyOrDie(valid, t.scheme)
0000000000000000000000000000000000000000;;			objCopyMeta := t.getObjectMetaOrFail(objCopy)
0000000000000000000000000000000000000000;;			objCopyMeta.SetName(invalidName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx := t.TestContext()
0000000000000000000000000000000000000000;;			_, err := t.storage.(rest.Creater).Create(ctx, objCopy, false)
0000000000000000000000000000000000000000;;			if !errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected to get an invalid resource error, got '%v'", invalidName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, invalidSuffix := range path.NameMayNotContain {
0000000000000000000000000000000000000000;;			objCopy := copyOrDie(valid, t.scheme)
0000000000000000000000000000000000000000;;			objCopyMeta := t.getObjectMetaOrFail(objCopy)
0000000000000000000000000000000000000000;;			objCopyMeta.SetName(objCopyMeta.GetName() + invalidSuffix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ctx := t.TestContext()
0000000000000000000000000000000000000000;;			_, err := t.storage.(rest.Creater).Create(ctx, objCopy, false)
0000000000000000000000000000000000000000;;			if !errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected to get an invalid resource error, got '%v'", invalidSuffix, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateInvokesValidation(invalid ...runtime.Object) {
0000000000000000000000000000000000000000;;		for i, obj := range invalid {
0000000000000000000000000000000000000000;;			ctx := t.TestContext()
0000000000000000000000000000000000000000;;			_, err := t.storage.(rest.Creater).Create(ctx, obj, false)
0000000000000000000000000000000000000000;;			if !errors.IsInvalid(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Expected to get an invalid resource error, got %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateRejectsMismatchedNamespace(valid runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(valid)
0000000000000000000000000000000000000000;;		objectMeta.SetNamespace("not-default")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := t.storage.(rest.Creater).Create(t.TestContext(), valid, false)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error, but we didn't get one")
0000000000000000000000000000000000000000;;		} else if !strings.Contains(err.Error(), "does not match the namespace sent on the request") {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 'does not match the namespace sent on the request' error, got '%v'", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateResetsUserData(valid runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(valid)
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		objectMeta.SetUID("bad-uid")
0000000000000000000000000000000000000000;;		objectMeta.SetCreationTimestamp(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := t.storage.(rest.Creater).Create(t.TestContext(), valid, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected object from result: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(t.TestContext(), obj)
0000000000000000000000000000000000000000;;		if objectMeta.GetUID() == "bad-uid" || objectMeta.GetCreationTimestamp() == now {
0000000000000000000000000000000000000000;;			t.Errorf("ObjectMeta did not reset basic fields: %#v", objectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testCreateIgnoreClusterName(valid runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(valid)
0000000000000000000000000000000000000000;;		objectMeta.SetName(t.namer(3))
0000000000000000000000000000000000000000;;		objectMeta.SetClusterName("clustername-to-ignore")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := t.storage.(rest.Creater).Create(t.TestContext(), copyOrDie(valid, t.scheme), false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer t.delete(t.TestContext(), obj)
0000000000000000000000000000000000000000;;		createdObjectMeta := t.getObjectMetaOrFail(obj)
0000000000000000000000000000000000000000;;		if len(createdObjectMeta.GetClusterName()) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected empty clusterName on created object, got '%v'", createdObjectMeta.GetClusterName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =============================================================================
0000000000000000000000000000000000000000;;	// Update tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateEquals(obj runtime.Object, createFn CreateFunc, getFn GetFunc, updateFn UpdateFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(2))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		toUpdate, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		toUpdate = updateFn(toUpdate)
0000000000000000000000000000000000000000;;		toUpdateMeta := t.getObjectMetaOrFail(toUpdate)
0000000000000000000000000000000000000000;;		updated, created, err := t.storage.(rest.Updater).Update(ctx, toUpdateMeta.GetName(), rest.DefaultUpdatedObjectInfo(toUpdate, t.scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if created {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected creation")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		got, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set resource version which might be unset in created object.
0000000000000000000000000000000000000000;;		updatedMeta := t.getObjectMetaOrFail(updated)
0000000000000000000000000000000000000000;;		gotMeta := t.getObjectMetaOrFail(got)
0000000000000000000000000000000000000000;;		updatedMeta.SetResourceVersion(gotMeta.GetResourceVersion())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := updated, got; !apiequality.Semantic.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected obj: %#v, expected %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateFailsOnVersionTooOld(obj runtime.Object, createFn CreateFunc, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(3))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storedFoo, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		older := copyOrDie(storedFoo, t.scheme)
0000000000000000000000000000000000000000;;		olderMeta := t.getObjectMetaOrFail(older)
0000000000000000000000000000000000000000;;		olderMeta.SetResourceVersion("1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err = t.storage.(rest.Updater).Update(t.TestContext(), olderMeta.GetName(), rest.DefaultUpdatedObjectInfo(older, t.scheme))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected an error, but we didn't get one")
0000000000000000000000000000000000000000;;		} else if !errors.IsConflict(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected Conflict error, got '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateInvokesValidation(obj runtime.Object, createFn CreateFunc, invalidUpdateFn ...UpdateFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(4))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, update := range invalidUpdateFn {
0000000000000000000000000000000000000000;;			toUpdate := update(copyOrDie(foo, t.scheme))
0000000000000000000000000000000000000000;;			toUpdateMeta := t.getObjectMetaOrFail(toUpdate)
0000000000000000000000000000000000000000;;			got, created, err := t.storage.(rest.Updater).Update(t.TestContext(), toUpdateMeta.GetName(), rest.DefaultUpdatedObjectInfo(toUpdate, t.scheme))
0000000000000000000000000000000000000000;;			if got != nil || created {
0000000000000000000000000000000000000000;;				t.Errorf("expected nil object and no creation for object: %v", toUpdate)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !errors.IsInvalid(err) && !errors.IsBadRequest(err) {
0000000000000000000000000000000000000000;;				t.Errorf("expected invalid or bad request error, got %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateWithWrongUID(obj runtime.Object, createFn CreateFunc, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(5))
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		objectMeta.SetUID(types.UID("UID0000"))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta.SetUID(types.UID("UID1111"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, created, err := t.storage.(rest.Updater).Update(ctx, objectMeta.GetName(), rest.DefaultUpdatedObjectInfo(foo, t.scheme))
0000000000000000000000000000000000000000;;		if created || obj != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected nil object and no creation for object: %v", foo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil || !errors.IsConflict(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateRetrievesOldObject(obj runtime.Object, createFn CreateFunc, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(6))
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		objectMeta.SetAnnotations(map[string]string{"A": "1"})
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storedFoo, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storedFooWithUpdates := copyOrDie(storedFoo, t.scheme)
0000000000000000000000000000000000000000;;		objectMeta = t.getObjectMetaOrFail(storedFooWithUpdates)
0000000000000000000000000000000000000000;;		objectMeta.SetAnnotations(map[string]string{"A": "2"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure a custom transform is called, and sees the expected updatedObject and oldObject
0000000000000000000000000000000000000000;;		// This tests the mechanism used to pass the old and new object to admission
0000000000000000000000000000000000000000;;		calledUpdatedObject := 0
0000000000000000000000000000000000000000;;		noopTransform := func(_ genericapirequest.Context, updatedObject runtime.Object, oldObject runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(storedFoo, oldObject) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected\n\t%#v\ngot\n\t%#v", storedFoo, oldObject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(storedFooWithUpdates, updatedObject) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected\n\t%#v\ngot\n\t%#v", storedFooWithUpdates, updatedObject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			calledUpdatedObject++
0000000000000000000000000000000000000000;;			return updatedObject, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedObj, created, err := t.storage.(rest.Updater).Update(ctx, objectMeta.GetName(), rest.DefaultUpdatedObjectInfo(storedFooWithUpdates, t.scheme, noopTransform))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if created {
0000000000000000000000000000000000000000;;			t.Errorf("expected no creation for object")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if updatedObj == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected non-nil object from update")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if calledUpdatedObject != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected UpdatedObject() to be called 1 time, was called %d", calledUpdatedObject)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdatePropagatesUpdatedObjectError(obj runtime.Object, createFn CreateFunc, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		name := t.namer(7)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, name)
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure our transform is called, and sees the expected updatedObject and oldObject
0000000000000000000000000000000000000000;;		propagateErr := fmt.Errorf("custom updated object error for %v", foo)
0000000000000000000000000000000000000000;;		noopTransform := func(_ genericapirequest.Context, updatedObject runtime.Object, oldObject runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;			return nil, propagateErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err := t.storage.(rest.Updater).Update(ctx, name, rest.DefaultUpdatedObjectInfo(foo, t.scheme, noopTransform))
0000000000000000000000000000000000000000;;		if err != propagateErr {
0000000000000000000000000000000000000000;;			t.Errorf("expected propagated error, got %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateIgnoreGenerationUpdates(obj runtime.Object, createFn CreateFunc, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		name := t.namer(8)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storedFoo, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		older := copyOrDie(storedFoo, t.scheme)
0000000000000000000000000000000000000000;;		olderMeta := t.getObjectMetaOrFail(older)
0000000000000000000000000000000000000000;;		olderMeta.SetGeneration(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err = t.storage.(rest.Updater).Update(t.TestContext(), olderMeta.GetName(), rest.DefaultUpdatedObjectInfo(older, t.scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedFoo, err := getFn(ctx, older)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exp, got := int64(1), t.getObjectMetaOrFail(updatedFoo).GetGeneration(); exp != got {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected generation update: expected %d, got %d", exp, got)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateOnNotFound(obj runtime.Object) {
0000000000000000000000000000000000000000;;		t.setObjectMeta(obj, t.namer(0))
0000000000000000000000000000000000000000;;		_, created, err := t.storage.(rest.Updater).Update(t.TestContext(), t.namer(0), rest.DefaultUpdatedObjectInfo(obj, t.scheme))
0000000000000000000000000000000000000000;;		if t.createOnUpdate {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("creation allowed on updated, but got an error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !created {
0000000000000000000000000000000000000000;;				t.Errorf("creation allowed on update, but object not created")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected an error, but we didn't get one")
0000000000000000000000000000000000000000;;			} else if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected NotFound error, got '%v'", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateRejectsMismatchedNamespace(obj runtime.Object, createFn CreateFunc, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(1))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storedFoo, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(storedFoo)
0000000000000000000000000000000000000000;;		objectMeta.SetName(t.namer(1))
0000000000000000000000000000000000000000;;		objectMeta.SetNamespace("not-default")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, updated, err := t.storage.(rest.Updater).Update(t.TestContext(), "foo1", rest.DefaultUpdatedObjectInfo(storedFoo, t.scheme))
0000000000000000000000000000000000000000;;		if obj != nil || updated {
0000000000000000000000000000000000000000;;			t.Errorf("expected nil object and not updated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected an error, but didn't get one")
0000000000000000000000000000000000000000;;		} else if !strings.Contains(err.Error(), "does not match the namespace sent on the request") {
0000000000000000000000000000000000000000;;			t.Errorf("expected 'does not match the namespace sent on the request' error, got '%v'", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testUpdateIgnoreClusterName(obj runtime.Object, createFn CreateFunc, getFn GetFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		name := t.namer(9)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storedFoo, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		older := copyOrDie(storedFoo, t.scheme)
0000000000000000000000000000000000000000;;		olderMeta := t.getObjectMetaOrFail(older)
0000000000000000000000000000000000000000;;		olderMeta.SetClusterName("clustername-to-ignore")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err = t.storage.(rest.Updater).Update(t.TestContext(), olderMeta.GetName(), rest.DefaultUpdatedObjectInfo(older, t.scheme))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedFoo, err := getFn(ctx, older)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if clusterName := t.getObjectMetaOrFail(updatedFoo).GetClusterName(); len(clusterName) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected clusterName update: expected empty, got %v", clusterName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =============================================================================
0000000000000000000000000000000000000000;;	// Deletion tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteNoGraceful(obj runtime.Object, createFn CreateFunc, getFn GetFunc, isNotFoundFn IsErrorFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(1))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		obj, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(10))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !t.returnDeletedObject {
0000000000000000000000000000000000000000;;			if status, ok := obj.(*metav1.Status); !ok {
0000000000000000000000000000000000000000;;				t.Errorf("expected status of delete, got %v", status)
0000000000000000000000000000000000000000;;			} else if status.Status != metav1.StatusSuccess {
0000000000000000000000000000000000000000;;				t.Errorf("expected success, got: %v", status.Status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err == nil || !isNotFoundFn(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteNonExist(obj runtime.Object) {
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, _, err := t.storage.(rest.GracefulDeleter).Delete(t.TestContext(), objectMeta.GetName(), nil)
0000000000000000000000000000000000000000;;		if err == nil || !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//  This test the fast-fail path. We test that the precondition gets verified
0000000000000000000000000000000000000000;;	//  again before deleting the object in tests of pkg/storage/etcd.
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteWithUID(obj runtime.Object, createFn CreateFunc, getFn GetFunc, isNotFoundFn IsErrorFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(1))
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		objectMeta.SetUID(types.UID("UID0000"))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, _, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewPreconditionDeleteOptions("UID1111"))
0000000000000000000000000000000000000000;;		if err == nil || !errors.IsConflict(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, _, err = t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewPreconditionDeleteOptions("UID0000"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !t.returnDeletedObject {
0000000000000000000000000000000000000000;;			if status, ok := obj.(*metav1.Status); !ok {
0000000000000000000000000000000000000000;;				t.Errorf("expected status of delete, got %v", status)
0000000000000000000000000000000000000000;;			} else if status.Status != metav1.StatusSuccess {
0000000000000000000000000000000000000000;;				t.Errorf("expected success, got: %v", status.Status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err == nil || !isNotFoundFn(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =============================================================================
0000000000000000000000000000000000000000;;	// Graceful Deletion tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteGracefulHasDefault(obj runtime.Object, createFn CreateFunc, getFn GetFunc, expectedGrace int64) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(1))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		generation := objectMeta.GetGeneration()
0000000000000000000000000000000000000000;;		_, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), &metav1.DeleteOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should not have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := getFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("did not gracefully delete resource: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		object, err := t.storage.(rest.Getter).Get(ctx, objectMeta.GetName(), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error, object should exist: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta = t.getObjectMetaOrFail(object)
0000000000000000000000000000000000000000;;		if objectMeta.GetDeletionTimestamp() == nil || objectMeta.GetDeletionGracePeriodSeconds() == nil || *objectMeta.GetDeletionGracePeriodSeconds() != expectedGrace {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected deleted meta: %#v", objectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if generation >= objectMeta.GetGeneration() {
0000000000000000000000000000000000000000;;			t.Error("Generation wasn't bumped when deletion timestamp was set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteGracefulWithValue(obj runtime.Object, createFn CreateFunc, getFn GetFunc, expectedGrace int64) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(2))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		generation := objectMeta.GetGeneration()
0000000000000000000000000000000000000000;;		_, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(expectedGrace+2))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should not have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := getFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("did not gracefully delete resource: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		object, err := t.storage.(rest.Getter).Get(ctx, objectMeta.GetName(), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error, object should exist: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta = t.getObjectMetaOrFail(object)
0000000000000000000000000000000000000000;;		if objectMeta.GetDeletionTimestamp() == nil || objectMeta.GetDeletionGracePeriodSeconds() == nil || *objectMeta.GetDeletionGracePeriodSeconds() != expectedGrace+2 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected deleted meta: %#v", objectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if generation >= objectMeta.GetGeneration() {
0000000000000000000000000000000000000000;;			t.Error("Generation wasn't bumped when deletion timestamp was set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteGracefulExtend(obj runtime.Object, createFn CreateFunc, getFn GetFunc, expectedGrace int64) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(3))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		generation := objectMeta.GetGeneration()
0000000000000000000000000000000000000000;;		_, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(expectedGrace))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should not have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := getFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("did not gracefully delete resource: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// second delete duration is ignored
0000000000000000000000000000000000000000;;		_, wasDeleted, err = t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(expectedGrace+2))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should not have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		object, err := t.storage.(rest.Getter).Get(ctx, objectMeta.GetName(), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error, object should exist: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta = t.getObjectMetaOrFail(object)
0000000000000000000000000000000000000000;;		if objectMeta.GetDeletionTimestamp() == nil || objectMeta.GetDeletionGracePeriodSeconds() == nil || *objectMeta.GetDeletionGracePeriodSeconds() != expectedGrace {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected deleted meta: %#v", objectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if generation >= objectMeta.GetGeneration() {
0000000000000000000000000000000000000000;;			t.Error("Generation wasn't bumped when deletion timestamp was set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteGracefulImmediate(obj runtime.Object, createFn CreateFunc, getFn GetFunc, expectedGrace int64) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, "foo4")
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		generation := objectMeta.GetGeneration()
0000000000000000000000000000000000000000;;		_, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(expectedGrace))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should not have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := getFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("did not gracefully delete resource: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// second delete is immediate, resource is deleted
0000000000000000000000000000000000000000;;		out, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(0))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted != true {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = t.storage.(rest.Getter).Get(ctx, objectMeta.GetName(), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error, object should be deleted immediately: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta = t.getObjectMetaOrFail(out)
0000000000000000000000000000000000000000;;		// the second delete shouldn't update the object, so the objectMeta.GetDeletionGracePeriodSeconds() should eqaul to the value set in the first delete.
0000000000000000000000000000000000000000;;		if objectMeta.GetDeletionTimestamp() == nil || objectMeta.GetDeletionGracePeriodSeconds() == nil || *objectMeta.GetDeletionGracePeriodSeconds() != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected deleted meta: %#v", objectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if generation >= objectMeta.GetGeneration() {
0000000000000000000000000000000000000000;;			t.Error("Generation wasn't bumped when deletion timestamp was set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteGracefulUsesZeroOnNil(obj runtime.Object, createFn CreateFunc, expectedGrace int64) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(5))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		_, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := t.storage.(rest.Getter).Get(ctx, objectMeta.GetName(), &metav1.GetOptions{}); !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error, object should not exist: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Regression test for bug discussed in #27539
0000000000000000000000000000000000000000;;	func (t *Tester) testDeleteGracefulShorten(obj runtime.Object, createFn CreateFunc, getFn GetFunc, expectedGrace int64) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo, t.namer(6))
0000000000000000000000000000000000000000;;		if err := createFn(ctx, foo); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bigGrace := int64(time.Hour)
0000000000000000000000000000000000000000;;		if expectedGrace > bigGrace {
0000000000000000000000000000000000000000;;			bigGrace = 2 * expectedGrace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta := t.getObjectMetaOrFail(foo)
0000000000000000000000000000000000000000;;		_, wasDeleted, err := t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(bigGrace))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should not have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		object, err := getFn(ctx, foo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("did not gracefully delete resource: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta = t.getObjectMetaOrFail(object)
0000000000000000000000000000000000000000;;		deletionTimestamp := *objectMeta.GetDeletionTimestamp()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// second delete duration is ignored
0000000000000000000000000000000000000000;;		_, wasDeleted, err = t.storage.(rest.GracefulDeleter).Delete(ctx, objectMeta.GetName(), metav1.NewDeleteOptions(expectedGrace))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wasDeleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected, object %s should not have been deleted immediately", objectMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		object, err = t.storage.(rest.Getter).Get(ctx, objectMeta.GetName(), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error, object should exist: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objectMeta = t.getObjectMetaOrFail(object)
0000000000000000000000000000000000000000;;		if objectMeta.GetDeletionTimestamp() == nil || objectMeta.GetDeletionGracePeriodSeconds() == nil ||
0000000000000000000000000000000000000000;;			*objectMeta.GetDeletionGracePeriodSeconds() != expectedGrace || !objectMeta.GetDeletionTimestamp().Before(deletionTimestamp) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected deleted meta: %#v", objectMeta)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =============================================================================
0000000000000000000000000000000000000000;;	// Get tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testGetDifferentNamespace ensures same-name objects in different namespaces do not clash
0000000000000000000000000000000000000000;;	func (t *Tester) testGetDifferentNamespace(obj runtime.Object) {
0000000000000000000000000000000000000000;;		if t.clusterScope {
0000000000000000000000000000000000000000;;			t.Fatalf("the test does not work in in cluster-scope")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objMeta := t.getObjectMetaOrFail(obj)
0000000000000000000000000000000000000000;;		objMeta.SetName(t.namer(5))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx1 := genericapirequest.WithNamespace(genericapirequest.NewContext(), "bar3")
0000000000000000000000000000000000000000;;		objMeta.SetNamespace(genericapirequest.NamespaceValue(ctx1))
0000000000000000000000000000000000000000;;		_, err := t.storage.(rest.Creater).Create(ctx1, obj, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx2 := genericapirequest.WithNamespace(genericapirequest.NewContext(), "bar4")
0000000000000000000000000000000000000000;;		objMeta.SetNamespace(genericapirequest.NamespaceValue(ctx2))
0000000000000000000000000000000000000000;;		_, err = t.storage.(rest.Creater).Create(ctx2, obj, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got1, err := t.storage.(rest.Getter).Get(ctx1, objMeta.GetName(), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		got1Meta := t.getObjectMetaOrFail(got1)
0000000000000000000000000000000000000000;;		if got1Meta.GetName() != objMeta.GetName() {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected name of object: %#v, expected: %s", got1, objMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got1Meta.GetNamespace() != genericapirequest.NamespaceValue(ctx1) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected namespace of object: %#v, expected: %s", got1, genericapirequest.NamespaceValue(ctx1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got2, err := t.storage.(rest.Getter).Get(ctx2, objMeta.GetName(), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		got2Meta := t.getObjectMetaOrFail(got2)
0000000000000000000000000000000000000000;;		if got2Meta.GetName() != objMeta.GetName() {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected name of object: %#v, expected: %s", got2, objMeta.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got2Meta.GetNamespace() != genericapirequest.NamespaceValue(ctx2) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected namespace of object: %#v, expected: %s", got2, genericapirequest.NamespaceValue(ctx2))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testGetFound(obj runtime.Object) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;		t.setObjectMeta(obj, t.namer(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existing, err := t.storage.(rest.Creater).Create(ctx, obj, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existingMeta := t.getObjectMetaOrFail(existing)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got, err := t.storage.(rest.Getter).Get(ctx, t.namer(1), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gotMeta := t.getObjectMetaOrFail(got)
0000000000000000000000000000000000000000;;		gotMeta.SetResourceVersion(existingMeta.GetResourceVersion())
0000000000000000000000000000000000000000;;		if e, a := existing, got; !apiequality.Semantic.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected obj: %#v, expected %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testGetMimatchedNamespace(obj runtime.Object) {
0000000000000000000000000000000000000000;;		ctx1 := genericapirequest.WithNamespace(genericapirequest.NewContext(), "bar1")
0000000000000000000000000000000000000000;;		ctx2 := genericapirequest.WithNamespace(genericapirequest.NewContext(), "bar2")
0000000000000000000000000000000000000000;;		objMeta := t.getObjectMetaOrFail(obj)
0000000000000000000000000000000000000000;;		objMeta.SetName(t.namer(4))
0000000000000000000000000000000000000000;;		objMeta.SetNamespace(genericapirequest.NamespaceValue(ctx1))
0000000000000000000000000000000000000000;;		_, err := t.storage.(rest.Creater).Create(ctx1, obj, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = t.storage.(rest.Getter).Get(ctx2, t.namer(4), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if t.clusterScope {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error returned: %#v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testGetNotFound(obj runtime.Object) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;		t.setObjectMeta(obj, t.namer(2))
0000000000000000000000000000000000000000;;		_, err := t.storage.(rest.Creater).Create(ctx, obj, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = t.storage.(rest.Getter).Get(ctx, t.namer(3), &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error returned: %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =============================================================================
0000000000000000000000000000000000000000;;	// List tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func listToItems(listObj runtime.Object) ([]runtime.Object, error) {
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items := v.FieldByName("Items")
0000000000000000000000000000000000000000;;		if !items.IsValid() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected Items field in %v", listObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if items.Type().Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected Items field type: %v", items.Type().Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make([]runtime.Object, items.Len())
0000000000000000000000000000000000000000;;		for i := 0; i < items.Len(); i++ {
0000000000000000000000000000000000000000;;			result[i] = items.Index(i).Addr().Interface().(runtime.Object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testListFound(obj runtime.Object, assignFn AssignFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo1 := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo1, t.namer(1))
0000000000000000000000000000000000000000;;		foo2 := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo2, t.namer(2))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existing := assignFn([]runtime.Object{foo1, foo2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listObj, err := t.storage.(rest.Lister).List(ctx, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := listToItems(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(items) != len(existing) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected number of items: %v", len(items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(existing, items) {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %#v, got: %#v", existing, items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testListMatchLabels(obj runtime.Object, assignFn AssignFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;		testLabels := map[string]string{"key": "value"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo3 := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		t.setObjectMeta(foo3, "foo3")
0000000000000000000000000000000000000000;;		foo4 := copyOrDie(obj, t.scheme)
0000000000000000000000000000000000000000;;		foo4Meta := t.getObjectMetaOrFail(foo4)
0000000000000000000000000000000000000000;;		foo4Meta.SetName("foo4")
0000000000000000000000000000000000000000;;		foo4Meta.SetNamespace(genericapirequest.NamespaceValue(ctx))
0000000000000000000000000000000000000000;;		foo4Meta.SetLabels(testLabels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objs := ([]runtime.Object{foo3, foo4})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assignFn(objs)
0000000000000000000000000000000000000000;;		filtered := []runtime.Object{objs[1]}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector := labels.SelectorFromSet(labels.Set(testLabels))
0000000000000000000000000000000000000000;;		options := &metainternalversion.ListOptions{LabelSelector: selector}
0000000000000000000000000000000000000000;;		listObj, err := t.storage.(rest.Lister).List(ctx, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := listToItems(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(items) != len(filtered) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected number of items: %v", len(items))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(filtered, items) {
0000000000000000000000000000000000000000;;			t.Errorf("expected: %#v, got: %#v", filtered, items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testListNotFound(assignFn AssignFunc) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;		_ = assignFn([]runtime.Object{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listObj, err := t.storage.(rest.Lister).List(ctx, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := listToItems(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(items) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected items: %#v", items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =============================================================================
0000000000000000000000000000000000000000;;	// Watching tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testWatchFields(obj runtime.Object, emitFn EmitFunc, fieldsPass, fieldsFail []fields.Set, actions []string) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, field := range fieldsPass {
0000000000000000000000000000000000000000;;			for _, action := range actions {
0000000000000000000000000000000000000000;;				options := &metainternalversion.ListOptions{FieldSelector: field.AsSelector(), ResourceVersion: "1"}
0000000000000000000000000000000000000000;;				watcher, err := t.storage.(rest.Watcher).Watch(ctx, options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v, %v", err, action)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := emitFn(obj, action); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case _, ok := <-watcher.ResultChan():
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t.Errorf("watch channel should be open")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;					t.Errorf("unexpected timeout from result channel")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				watcher.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, field := range fieldsFail {
0000000000000000000000000000000000000000;;			for _, action := range actions {
0000000000000000000000000000000000000000;;				options := &metainternalversion.ListOptions{FieldSelector: field.AsSelector(), ResourceVersion: "1"}
0000000000000000000000000000000000000000;;				watcher, err := t.storage.(rest.Watcher).Watch(ctx, options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := emitFn(obj, action); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-watcher.ResultChan():
0000000000000000000000000000000000000000;;					t.Errorf("unexpected result from result channel")
0000000000000000000000000000000000000000;;				case <-time.After(time.Millisecond * 500):
0000000000000000000000000000000000000000;;					// expected case
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				watcher.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tester) testWatchLabels(obj runtime.Object, emitFn EmitFunc, labelsPass, labelsFail []labels.Set, actions []string) {
0000000000000000000000000000000000000000;;		ctx := t.TestContext()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, label := range labelsPass {
0000000000000000000000000000000000000000;;			for _, action := range actions {
0000000000000000000000000000000000000000;;				options := &metainternalversion.ListOptions{LabelSelector: label.AsSelector(), ResourceVersion: "1"}
0000000000000000000000000000000000000000;;				watcher, err := t.storage.(rest.Watcher).Watch(ctx, options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := emitFn(obj, action); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case _, ok := <-watcher.ResultChan():
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t.Errorf("watch channel should be open")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;					t.Errorf("unexpected timeout from result channel")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				watcher.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, label := range labelsFail {
0000000000000000000000000000000000000000;;			for _, action := range actions {
0000000000000000000000000000000000000000;;				options := &metainternalversion.ListOptions{LabelSelector: label.AsSelector(), ResourceVersion: "1"}
0000000000000000000000000000000000000000;;				watcher, err := t.storage.(rest.Watcher).Watch(ctx, options)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := emitFn(obj, action); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-watcher.ResultChan():
0000000000000000000000000000000000000000;;					t.Errorf("unexpected result from result channel")
0000000000000000000000000000000000000000;;				case <-time.After(time.Millisecond * 500):
0000000000000000000000000000000000000000;;					// expected case
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				watcher.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
