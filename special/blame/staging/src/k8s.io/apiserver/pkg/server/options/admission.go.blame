0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
cc172cd789a15b0c897a046d4425aba07957900e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission/initializer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AdmissionOptions holds the admission options
0000000000000000000000000000000000000000;;	type AdmissionOptions struct {
0000000000000000000000000000000000000000;;		PluginNames []string
0000000000000000000000000000000000000000;;		ConfigFile  string
0000000000000000000000000000000000000000;;		Plugins     *admission.Plugins
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAdmissionOptions creates a new instance of AdmissionOptions
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	// In addition it calls RegisterAllAdmissionPlugins to register
0000000000000000000000000000000000000000;;	// all generic admission plugins.
0000000000000000000000000000000000000000;;	func NewAdmissionOptions() *AdmissionOptions {
0000000000000000000000000000000000000000;;		options := &AdmissionOptions{
0000000000000000000000000000000000000000;;			Plugins:     &admission.Plugins{},
0000000000000000000000000000000000000000;;			PluginNames: []string{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server.RegisterAllAdmissionPlugins(options.Plugins)
0000000000000000000000000000000000000000;;		return options
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlags adds flags related to admission for a specific APIServer to the specified FlagSet
0000000000000000000000000000000000000000;;	func (a *AdmissionOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringSliceVar(&a.PluginNames, "admission-control", a.PluginNames, ""+
0000000000000000000000000000000000000000;;			"Ordered list of plug-ins to do admission control of resources into cluster. "+
0000000000000000000000000000000000000000;;			"Comma-delimited list of: "+strings.Join(a.Plugins.Registered(), ", ")+".")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&a.ConfigFile, "admission-control-config-file", a.ConfigFile,
0000000000000000000000000000000000000000;;			"File with admission control configuration.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ApplyTo adds the admission chain to the server configuration
0000000000000000000000000000000000000000;;	// the method lazily initializes a generic plugin that is appended to the list of pluginInitializers
0000000000000000000000000000000000000000;;	// note this method uses:
0000000000000000000000000000000000000000;;	//  genericconfig.LoopbackClientConfig
0000000000000000000000000000000000000000;;	//  genericconfig.SharedInformerFactory
0000000000000000000000000000000000000000;;	//  genericconfig.Authorizer
0000000000000000000000000000000000000000;;	func (a *AdmissionOptions) ApplyTo(serverCfg *server.Config, pluginInitializers ...admission.PluginInitializer) error {
0000000000000000000000000000000000000000;;		pluginsConfigProvider, err := admission.ReadAdmissionConfiguration(a.PluginNames, a.ConfigFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to read plugin config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := kubernetes.NewForConfig(serverCfg.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		genericInitializer, err := initializer.New(clientset, serverCfg.SharedInformerFactory, serverCfg.Authorizer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		initializersChain := admission.PluginInitializers{}
0000000000000000000000000000000000000000;;		pluginInitializers = append(pluginInitializers, genericInitializer)
0000000000000000000000000000000000000000;;		initializersChain = append(initializersChain, pluginInitializers...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		admissionChain, err := a.Plugins.NewFromPlugins(a.PluginNames, pluginsConfigProvider, initializersChain)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverCfg.AdmissionControl = admissionChain
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
