0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
25c96307b54868d62008969f1b781b7e30c45e7b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/NYTimes/gziphandler"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/googleapis/gnostic/OpenAPIv2"
0000000000000000000000000000000000000000;;		"github.com/googleapis/gnostic/compiler"
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;		genericmux "k8s.io/apiserver/pkg/server/mux"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OpenAPIService struct {
0000000000000000000000000000000000000000;;		orgSpec      *spec.Swagger
0000000000000000000000000000000000000000;;		specBytes    []byte
0000000000000000000000000000000000000000;;		specPb       []byte
0000000000000000000000000000000000000000;;		specPbGz     []byte
0000000000000000000000000000000000000000;;		lastModified time.Time
0000000000000000000000000000000000000000;;		updateHooks  []func(*http.Request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterOpenAPIService registers a handler to provides standard OpenAPI specification.
0000000000000000000000000000000000000000;;	func RegisterOpenAPIService(openapiSpec *spec.Swagger, servePath string, mux *genericmux.PathRecorderMux) (*OpenAPIService, error) {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(servePath, JSON_EXT) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Serving path must ends with \"%s\".", JSON_EXT)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servePathBase := servePath[:len(servePath)-len(JSON_EXT)]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o := OpenAPIService{}
0000000000000000000000000000000000000000;;		if err := o.UpdateSpec(openapiSpec); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mime.AddExtensionType(".json", MIME_JSON)
0000000000000000000000000000000000000000;;		mime.AddExtensionType(".pb-v1", MIME_PB)
0000000000000000000000000000000000000000;;		mime.AddExtensionType(".gz", MIME_PB_GZ)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type fileInfo struct {
0000000000000000000000000000000000000000;;			ext     string
0000000000000000000000000000000000000000;;			getData func() []byte
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files := []fileInfo{
0000000000000000000000000000000000000000;;			{".json", o.getSwaggerBytes},
0000000000000000000000000000000000000000;;			{"-2.0.0.json", o.getSwaggerBytes},
0000000000000000000000000000000000000000;;			{"-2.0.0.pb-v1", o.getSwaggerPbBytes},
0000000000000000000000000000000000000000;;			{"-2.0.0.pb-v1.gz", o.getSwaggerPbGzBytes},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			path := servePathBase + file.ext
0000000000000000000000000000000000000000;;			getData := file.getData
0000000000000000000000000000000000000000;;			mux.Handle(path, gziphandler.GzipHandler(http.HandlerFunc(
0000000000000000000000000000000000000000;;				func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;					if r.URL.Path != path {
0000000000000000000000000000000000000000;;						w.WriteHeader(http.StatusNotFound)
0000000000000000000000000000000000000000;;						w.Write([]byte("Path not found!"))
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					o.update(r)
0000000000000000000000000000000000000000;;					data := getData()
0000000000000000000000000000000000000000;;					etag := computeEtag(data)
0000000000000000000000000000000000000000;;					w.Header().Set("Etag", etag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// ServeContent will take care of caching using eTag.
0000000000000000000000000000000000000000;;					http.ServeContent(w, r, path, o.lastModified, bytes.NewReader(data))
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &o, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *OpenAPIService) getSwaggerBytes() []byte {
0000000000000000000000000000000000000000;;		return o.specBytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *OpenAPIService) getSwaggerPbBytes() []byte {
0000000000000000000000000000000000000000;;		return o.specPb
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *OpenAPIService) getSwaggerPbGzBytes() []byte {
0000000000000000000000000000000000000000;;		return o.specPbGz
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *OpenAPIService) GetSpec() *spec.Swagger {
0000000000000000000000000000000000000000;;		return o.orgSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *OpenAPIService) UpdateSpec(openapiSpec *spec.Swagger) (err error) {
0000000000000000000000000000000000000000;;		o.orgSpec = openapiSpec
0000000000000000000000000000000000000000;;		o.specBytes, err = json.MarshalIndent(openapiSpec, " ", " ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.specPb, err = toProtoBinary(o.specBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.specPbGz = toGzip(o.specPb)
0000000000000000000000000000000000000000;;		o.lastModified = time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toProtoBinary(spec []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		var info yaml.MapSlice
0000000000000000000000000000000000000000;;		err := yaml.Unmarshal(spec, &info)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		document, err := openapi_v2.NewDocument(info, compiler.NewContext("$root", nil))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return proto.Marshal(document)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toGzip(data []byte) []byte {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		zw := gzip.NewWriter(&buf)
0000000000000000000000000000000000000000;;		zw.Write(data)
0000000000000000000000000000000000000000;;		zw.Close()
0000000000000000000000000000000000000000;;		return buf.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds an update hook to be called on each spec request. The hook is responsible
0000000000000000000000000000000000000000;;	// to call UpdateSpec method.
0000000000000000000000000000000000000000;;	func (o *OpenAPIService) AddUpdateHook(hook func(*http.Request)) {
0000000000000000000000000000000000000000;;		o.updateHooks = append(o.updateHooks, hook)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *OpenAPIService) update(r *http.Request) {
0000000000000000000000000000000000000000;;		for _, h := range o.updateHooks {
0000000000000000000000000000000000000000;;			h(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
