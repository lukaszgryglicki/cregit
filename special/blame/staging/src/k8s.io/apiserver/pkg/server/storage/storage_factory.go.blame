0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
829d9382ef92e755aad1a7c5c1387462687119c6;pkg/genericapiserver/storage_factory.go[pkg/genericapiserver/storage_factory.go][staging/src/k8s.io/apiserver/pkg/server/storage/storage_factory.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Backend describes the storage servers, the information here should be enough
0000000000000000000000000000000000000000;;	// for health validations.
0000000000000000000000000000000000000000;;	type Backend struct {
0000000000000000000000000000000000000000;;		// the url of storage backend like: https://etcd.domain:2379
0000000000000000000000000000000000000000;;		Server string
0000000000000000000000000000000000000000;;		// the required tls config
0000000000000000000000000000000000000000;;		TLSConfig *tls.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageFactory is the interface to locate the storage for a given GroupResource
0000000000000000000000000000000000000000;;	type StorageFactory interface {
0000000000000000000000000000000000000000;;		// New finds the storage destination for the given group and resource. It will
0000000000000000000000000000000000000000;;		// return an error if the group has no storage destination configured.
0000000000000000000000000000000000000000;;		NewConfig(groupResource schema.GroupResource) (*storagebackend.Config, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResourcePrefix returns the overridden resource prefix for the GroupResource
0000000000000000000000000000000000000000;;		// This allows for cohabitation of resources with different native types and provides
0000000000000000000000000000000000000000;;		// centralized control over the shape of etcd directories
0000000000000000000000000000000000000000;;		ResourcePrefix(groupResource schema.GroupResource) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Backends gets all backends for all registered storage destinations.
0000000000000000000000000000000000000000;;		// Used for getting all instances for health validations.
0000000000000000000000000000000000000000;;		Backends() []Backend
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultStorageFactory takes a GroupResource and returns back its storage interface.  This result includes:
0000000000000000000000000000000000000000;;	// 1. Merged etcd config, including: auth, server locations, prefixes
0000000000000000000000000000000000000000;;	// 2. Resource encodings for storage: group,version,kind to store as
0000000000000000000000000000000000000000;;	// 3. Cohabitating default: some resources like hpa are exposed through multiple APIs.  They must agree on 1 and 2
0000000000000000000000000000000000000000;;	type DefaultStorageFactory struct {
0000000000000000000000000000000000000000;;		// StorageConfig describes how to create a storage backend in general.
0000000000000000000000000000000000000000;;		// Its authentication information will be used for every storage.Interface returned.
0000000000000000000000000000000000000000;;		StorageConfig storagebackend.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Overrides map[schema.GroupResource]groupResourceOverrides
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DefaultResourcePrefixes map[schema.GroupResource]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultMediaType is the media type used to store resources. If it is not set, "application/json" is used.
0000000000000000000000000000000000000000;;		DefaultMediaType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultSerializer is used to create encoders and decoders for the storage.Interface.
0000000000000000000000000000000000000000;;		DefaultSerializer runtime.StorageSerializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResourceEncodingConfig describes how to encode a particular GroupVersionResource
0000000000000000000000000000000000000000;;		ResourceEncodingConfig ResourceEncodingConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// APIResourceConfigSource indicates whether the *storage* is enabled, NOT the API
0000000000000000000000000000000000000000;;		// This is discrete from resource enablement because those are separate concerns.  How this source is configured
0000000000000000000000000000000000000000;;		// is left to the caller.
0000000000000000000000000000000000000000;;		APIResourceConfigSource APIResourceConfigSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// newStorageCodecFn exists to be overwritten for unit testing.
0000000000000000000000000000000000000000;;		newStorageCodecFn func(opts StorageCodecConfig) (codec runtime.Codec, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type groupResourceOverrides struct {
0000000000000000000000000000000000000000;;		// etcdLocation contains the list of "special" locations that are used for particular GroupResources
0000000000000000000000000000000000000000;;		// These are merged on top of the StorageConfig when requesting the storage.Interface for a given GroupResource
0000000000000000000000000000000000000000;;		etcdLocation []string
0000000000000000000000000000000000000000;;		// etcdPrefix is the base location for a GroupResource.
0000000000000000000000000000000000000000;;		etcdPrefix string
0000000000000000000000000000000000000000;;		// etcdResourcePrefix is the location to use to store a particular type under the `etcdPrefix` location
0000000000000000000000000000000000000000;;		// If empty, the default mapping is used.  If the default mapping doesn't contain an entry, it will use
0000000000000000000000000000000000000000;;		// the ToLowered name of the resource, not including the group.
0000000000000000000000000000000000000000;;		etcdResourcePrefix string
0000000000000000000000000000000000000000;;		// mediaType is the desired serializer to choose. If empty, the default is chosen.
0000000000000000000000000000000000000000;;		mediaType string
0000000000000000000000000000000000000000;;		// serializer contains the list of "special" serializers for a GroupResource.  Resource=* means for the entire group
0000000000000000000000000000000000000000;;		serializer runtime.StorageSerializer
0000000000000000000000000000000000000000;;		// cohabitatingResources keeps track of which resources must be stored together.  This happens when we have multiple ways
0000000000000000000000000000000000000000;;		// of exposing one set of concepts.  autoscaling.HPA and extensions.HPA as a for instance
0000000000000000000000000000000000000000;;		// The order of the slice matters!  It is the priority order of lookup for finding a storage location
0000000000000000000000000000000000000000;;		cohabitatingResources []schema.GroupResource
0000000000000000000000000000000000000000;;		// encoderDecoratorFn is optional and may wrap the provided encoder prior to being serialized.
0000000000000000000000000000000000000000;;		encoderDecoratorFn func(runtime.Encoder) runtime.Encoder
0000000000000000000000000000000000000000;;		// decoderDecoratorFn is optional and may wrap the provided decoders (can add new decoders). The order of
0000000000000000000000000000000000000000;;		// returned decoders will be priority for attempt to decode.
0000000000000000000000000000000000000000;;		decoderDecoratorFn func([]runtime.Decoder) []runtime.Decoder
0000000000000000000000000000000000000000;;		// transformer is optional and shall encrypt that resource at rest.
0000000000000000000000000000000000000000;;		transformer value.Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Apply overrides the provided config and options if the override has a value in that position
0000000000000000000000000000000000000000;;	func (o groupResourceOverrides) Apply(config *storagebackend.Config, options *StorageCodecConfig) {
0000000000000000000000000000000000000000;;		if len(o.etcdLocation) > 0 {
0000000000000000000000000000000000000000;;			config.ServerList = o.etcdLocation
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(o.etcdPrefix) > 0 {
0000000000000000000000000000000000000000;;			config.Prefix = o.etcdPrefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(o.mediaType) > 0 {
0000000000000000000000000000000000000000;;			options.StorageMediaType = o.mediaType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.serializer != nil {
0000000000000000000000000000000000000000;;			options.StorageSerializer = o.serializer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.encoderDecoratorFn != nil {
0000000000000000000000000000000000000000;;			options.EncoderDecoratorFn = o.encoderDecoratorFn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.decoderDecoratorFn != nil {
0000000000000000000000000000000000000000;;			options.DecoderDecoratorFn = o.decoderDecoratorFn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.transformer != nil {
0000000000000000000000000000000000000000;;			config.Transformer = o.transformer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ StorageFactory = &DefaultStorageFactory{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const AllResources = "*"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// specialDefaultResourcePrefixes are prefixes compiled into Kubernetes.
0000000000000000000000000000000000000000;;	// TODO: move out of this package, it is not generic
0000000000000000000000000000000000000000;;	var specialDefaultResourcePrefixes = map[schema.GroupResource]string{
0000000000000000000000000000000000000000;;		{Group: "", Resource: "replicationControllers"}:        "controllers",
0000000000000000000000000000000000000000;;		{Group: "", Resource: "replicationcontrollers"}:        "controllers",
0000000000000000000000000000000000000000;;		{Group: "", Resource: "endpoints"}:                     "services/endpoints",
0000000000000000000000000000000000000000;;		{Group: "", Resource: "nodes"}:                         "minions",
0000000000000000000000000000000000000000;;		{Group: "", Resource: "services"}:                      "services/specs",
0000000000000000000000000000000000000000;;		{Group: "extensions", Resource: "ingresses"}:           "ingress",
0000000000000000000000000000000000000000;;		{Group: "extensions", Resource: "podsecuritypolicies"}: "podsecuritypolicy",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefaultStorageFactory(config storagebackend.Config, defaultMediaType string, defaultSerializer runtime.StorageSerializer, resourceEncodingConfig ResourceEncodingConfig, resourceConfig APIResourceConfigSource) *DefaultStorageFactory {
0000000000000000000000000000000000000000;;		if len(defaultMediaType) == 0 {
0000000000000000000000000000000000000000;;			defaultMediaType = runtime.ContentTypeJSON
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &DefaultStorageFactory{
0000000000000000000000000000000000000000;;			StorageConfig:           config,
0000000000000000000000000000000000000000;;			Overrides:               map[schema.GroupResource]groupResourceOverrides{},
0000000000000000000000000000000000000000;;			DefaultMediaType:        defaultMediaType,
0000000000000000000000000000000000000000;;			DefaultSerializer:       defaultSerializer,
0000000000000000000000000000000000000000;;			ResourceEncodingConfig:  resourceEncodingConfig,
0000000000000000000000000000000000000000;;			APIResourceConfigSource: resourceConfig,
0000000000000000000000000000000000000000;;			DefaultResourcePrefixes: specialDefaultResourcePrefixes,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newStorageCodecFn: NewStorageCodec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) SetEtcdLocation(groupResource schema.GroupResource, location []string) {
0000000000000000000000000000000000000000;;		overrides := s.Overrides[groupResource]
0000000000000000000000000000000000000000;;		overrides.etcdLocation = location
0000000000000000000000000000000000000000;;		s.Overrides[groupResource] = overrides
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) SetEtcdPrefix(groupResource schema.GroupResource, prefix string) {
0000000000000000000000000000000000000000;;		overrides := s.Overrides[groupResource]
0000000000000000000000000000000000000000;;		overrides.etcdPrefix = prefix
0000000000000000000000000000000000000000;;		s.Overrides[groupResource] = overrides
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetResourceEtcdPrefix sets the prefix for a resource, but not the base-dir.  You'll end up in `etcdPrefix/resourceEtcdPrefix`.
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) SetResourceEtcdPrefix(groupResource schema.GroupResource, prefix string) {
0000000000000000000000000000000000000000;;		overrides := s.Overrides[groupResource]
0000000000000000000000000000000000000000;;		overrides.etcdResourcePrefix = prefix
0000000000000000000000000000000000000000;;		s.Overrides[groupResource] = overrides
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) SetSerializer(groupResource schema.GroupResource, mediaType string, serializer runtime.StorageSerializer) {
0000000000000000000000000000000000000000;;		overrides := s.Overrides[groupResource]
0000000000000000000000000000000000000000;;		overrides.mediaType = mediaType
0000000000000000000000000000000000000000;;		overrides.serializer = serializer
0000000000000000000000000000000000000000;;		s.Overrides[groupResource] = overrides
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) SetTransformer(groupResource schema.GroupResource, transformer value.Transformer) {
0000000000000000000000000000000000000000;;		overrides := s.Overrides[groupResource]
0000000000000000000000000000000000000000;;		overrides.transformer = transformer
0000000000000000000000000000000000000000;;		s.Overrides[groupResource] = overrides
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddCohabitatingResources links resources together the order of the slice matters!  its the priority order of lookup for finding a storage location
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) AddCohabitatingResources(groupResources ...schema.GroupResource) {
0000000000000000000000000000000000000000;;		for _, groupResource := range groupResources {
0000000000000000000000000000000000000000;;			overrides := s.Overrides[groupResource]
0000000000000000000000000000000000000000;;			overrides.cohabitatingResources = groupResources
0000000000000000000000000000000000000000;;			s.Overrides[groupResource] = overrides
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) AddSerializationChains(encoderDecoratorFn func(runtime.Encoder) runtime.Encoder, decoderDecoratorFn func([]runtime.Decoder) []runtime.Decoder, groupResources ...schema.GroupResource) {
0000000000000000000000000000000000000000;;		for _, groupResource := range groupResources {
0000000000000000000000000000000000000000;;			overrides := s.Overrides[groupResource]
0000000000000000000000000000000000000000;;			overrides.encoderDecoratorFn = encoderDecoratorFn
0000000000000000000000000000000000000000;;			overrides.decoderDecoratorFn = decoderDecoratorFn
0000000000000000000000000000000000000000;;			s.Overrides[groupResource] = overrides
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAllResourcesAlias(resource schema.GroupResource) schema.GroupResource {
0000000000000000000000000000000000000000;;		return schema.GroupResource{Group: resource.Group, Resource: AllResources}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) getStorageGroupResource(groupResource schema.GroupResource) schema.GroupResource {
0000000000000000000000000000000000000000;;		for _, potentialStorageResource := range s.Overrides[groupResource].cohabitatingResources {
0000000000000000000000000000000000000000;;			if s.APIResourceConfigSource.AnyVersionOfResourceEnabled(potentialStorageResource) {
0000000000000000000000000000000000000000;;				return potentialStorageResource
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return groupResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New finds the storage destination for the given group and resource. It will
0000000000000000000000000000000000000000;;	// return an error if the group has no storage destination configured.
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) NewConfig(groupResource schema.GroupResource) (*storagebackend.Config, error) {
0000000000000000000000000000000000000000;;		chosenStorageResource := s.getStorageGroupResource(groupResource)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// operate on copy
0000000000000000000000000000000000000000;;		storageConfig := s.StorageConfig
0000000000000000000000000000000000000000;;		codecConfig := StorageCodecConfig{
0000000000000000000000000000000000000000;;			StorageMediaType:  s.DefaultMediaType,
0000000000000000000000000000000000000000;;			StorageSerializer: s.DefaultSerializer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if override, ok := s.Overrides[getAllResourcesAlias(chosenStorageResource)]; ok {
0000000000000000000000000000000000000000;;			override.Apply(&storageConfig, &codecConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if override, ok := s.Overrides[chosenStorageResource]; ok {
0000000000000000000000000000000000000000;;			override.Apply(&storageConfig, &codecConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		codecConfig.StorageVersion, err = s.ResourceEncodingConfig.StorageEncodingFor(chosenStorageResource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		codecConfig.MemoryVersion, err = s.ResourceEncodingConfig.InMemoryEncodingFor(groupResource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		codecConfig.Config = storageConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageConfig.Codec, err = s.newStorageCodecFn(codecConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("storing %v in %v, reading as %v from %v", groupResource, codecConfig.StorageVersion, codecConfig.MemoryVersion, codecConfig.Config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &storageConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Backends returns all backends for all registered storage destinations.
0000000000000000000000000000000000000000;;	// Used for getting all instances for health validations.
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) Backends() []Backend {
0000000000000000000000000000000000000000;;		servers := sets.NewString(s.StorageConfig.ServerList...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, overrides := range s.Overrides {
0000000000000000000000000000000000000000;;			servers.Insert(overrides.etcdLocation...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsConfig := &tls.Config{
0000000000000000000000000000000000000000;;			InsecureSkipVerify: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.StorageConfig.CertFile) > 0 && len(s.StorageConfig.KeyFile) > 0 {
0000000000000000000000000000000000000000;;			cert, err := tls.LoadX509KeyPair(s.StorageConfig.CertFile, s.StorageConfig.KeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("failed to load key pair while getting backends: %s", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tlsConfig.Certificates = []tls.Certificate{cert}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.StorageConfig.CAFile) > 0 {
0000000000000000000000000000000000000000;;			if caCert, err := ioutil.ReadFile(s.StorageConfig.CAFile); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("failed to read ca file while getting backends: %s", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				caPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;				caPool.AppendCertsFromPEM(caCert)
0000000000000000000000000000000000000000;;				tlsConfig.RootCAs = caPool
0000000000000000000000000000000000000000;;				tlsConfig.InsecureSkipVerify = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backends := []Backend{}
0000000000000000000000000000000000000000;;		for server := range servers {
0000000000000000000000000000000000000000;;			backends = append(backends, Backend{
0000000000000000000000000000000000000000;;				Server:    server,
0000000000000000000000000000000000000000;;				TLSConfig: tlsConfig,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return backends
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DefaultStorageFactory) ResourcePrefix(groupResource schema.GroupResource) string {
0000000000000000000000000000000000000000;;		chosenStorageResource := s.getStorageGroupResource(groupResource)
0000000000000000000000000000000000000000;;		groupOverride := s.Overrides[getAllResourcesAlias(chosenStorageResource)]
0000000000000000000000000000000000000000;;		exactResourceOverride := s.Overrides[chosenStorageResource]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdResourcePrefix := s.DefaultResourcePrefixes[chosenStorageResource]
0000000000000000000000000000000000000000;;		if len(groupOverride.etcdResourcePrefix) > 0 {
0000000000000000000000000000000000000000;;			etcdResourcePrefix = groupOverride.etcdResourcePrefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(exactResourceOverride.etcdResourcePrefix) > 0 {
0000000000000000000000000000000000000000;;			etcdResourcePrefix = exactResourceOverride.etcdResourcePrefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(etcdResourcePrefix) == 0 {
0000000000000000000000000000000000000000;;			etcdResourcePrefix = strings.ToLower(chosenStorageResource.Resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return etcdResourcePrefix
0000000000000000000000000000000000000000;;	}
