0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
51e8fd64f1f114710aaf9fb6d04ca5027218ea37;pkg/genericapiserver/config.go[pkg/genericapiserver/config.go][staging/src/k8s.io/apiserver/pkg/server/config.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		openapicommon "k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		auditpolicy "k8s.io/apiserver/pkg/audit/policy"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticatorfactory"
0000000000000000000000000000000000000000;;		authenticatorunion "k8s.io/apiserver/pkg/authentication/request/union"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizerfactory"
0000000000000000000000000000000000000000;;		authorizerunion "k8s.io/apiserver/pkg/authorization/union"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/discovery"
0000000000000000000000000000000000000000;;		genericapifilters "k8s.io/apiserver/pkg/endpoints/filters"
0000000000000000000000000000000000000000;;		apiopenapi "k8s.io/apiserver/pkg/endpoints/openapi"
0000000000000000000000000000000000000000;;		apirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/features"
0000000000000000000000000000000000000000;;		genericregistry "k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		genericfilters "k8s.io/apiserver/pkg/server/filters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/routes"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/apiserver/pkg/apis/apiserver/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultLegacyAPIPrefix is where the the legacy APIs will be located.
0000000000000000000000000000000000000000;;		DefaultLegacyAPIPrefix = "/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// APIGroupPrefix is where non-legacy API group will be located.
0000000000000000000000000000000000000000;;		APIGroupPrefix = "/apis"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config is a structure used to configure a GenericAPIServer.
0000000000000000000000000000000000000000;;	// It's members are sorted roughly in order of importance for composers.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// SecureServingInfo is required to serve https
0000000000000000000000000000000000000000;;		SecureServingInfo *SecureServingInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LoopbackClientConfig is a config for a privileged loopback connection to the API server
0000000000000000000000000000000000000000;;		// This is required for proper functioning of the PostStartHooks on a GenericAPIServer
0000000000000000000000000000000000000000;;		LoopbackClientConfig *restclient.Config
0000000000000000000000000000000000000000;;		// Authenticator determines which subject is making the request
0000000000000000000000000000000000000000;;		Authenticator authenticator.Request
0000000000000000000000000000000000000000;;		// Authorizer determines whether the subject is allowed to make the request based only
0000000000000000000000000000000000000000;;		// on the RequestURI
0000000000000000000000000000000000000000;;		Authorizer authorizer.Authorizer
0000000000000000000000000000000000000000;;		// AdmissionControl performs deep inspection of a given request (including content)
0000000000000000000000000000000000000000;;		// to set values and determine whether its allowed
0000000000000000000000000000000000000000;;		AdmissionControl      admission.Interface
0000000000000000000000000000000000000000;;		CorsAllowedOriginList []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EnableSwaggerUI bool
0000000000000000000000000000000000000000;;		EnableIndex     bool
0000000000000000000000000000000000000000;;		EnableProfiling bool
0000000000000000000000000000000000000000;;		EnableDiscovery bool
0000000000000000000000000000000000000000;;		// Requires generic profiling enabled
0000000000000000000000000000000000000000;;		EnableContentionProfiling bool
0000000000000000000000000000000000000000;;		EnableMetrics             bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DisabledPostStartHooks sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Version will enable the /version endpoint if non-nil
0000000000000000000000000000000000000000;;		Version *version.Info
0000000000000000000000000000000000000000;;		// LegacyAuditWriter is the destination for audit logs.  If nil, they will not be written.
0000000000000000000000000000000000000000;;		LegacyAuditWriter io.Writer
0000000000000000000000000000000000000000;;		// AuditBackend is where audit events are sent to.
0000000000000000000000000000000000000000;;		AuditBackend audit.Backend
0000000000000000000000000000000000000000;;		// AuditPolicyChecker makes the decision of whether and how to audit log a request.
0000000000000000000000000000000000000000;;		AuditPolicyChecker auditpolicy.Checker
0000000000000000000000000000000000000000;;		// SupportsBasicAuth indicates that's at least one Authenticator supports basic auth
0000000000000000000000000000000000000000;;		// If this is true, a basic auth challenge is returned on authentication failure
0000000000000000000000000000000000000000;;		// TODO(roberthbailey): Remove once the server no longer supports http basic auth.
0000000000000000000000000000000000000000;;		SupportsBasicAuth bool
0000000000000000000000000000000000000000;;		// ExternalAddress is the host name to use for external (public internet) facing URLs (e.g. Swagger)
0000000000000000000000000000000000000000;;		// Will default to a value based on secure serving info and available ipv4 IPs.
0000000000000000000000000000000000000000;;		ExternalAddress string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SharedInformerFactory provides shared informers for resources
0000000000000000000000000000000000000000;;		SharedInformerFactory informers.SharedInformerFactory
0000000000000000000000000000000000000000;;		//===========================================================================
0000000000000000000000000000000000000000;;		// Fields you probably don't care about changing
0000000000000000000000000000000000000000;;		//===========================================================================
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BuildHandlerChainFunc allows you to build custom handler chains by decorating the apiHandler.
0000000000000000000000000000000000000000;;		BuildHandlerChainFunc func(apiHandler http.Handler, c *Config) (secure http.Handler)
0000000000000000000000000000000000000000;;		// DiscoveryAddresses is used to build the IPs pass to discovery.  If nil, the ExternalAddress is
0000000000000000000000000000000000000000;;		// always reported
0000000000000000000000000000000000000000;;		DiscoveryAddresses discovery.Addresses
0000000000000000000000000000000000000000;;		// The default set of healthz checks. There might be more added via AddHealthzChecks dynamically.
0000000000000000000000000000000000000000;;		HealthzChecks []healthz.HealthzChecker
0000000000000000000000000000000000000000;;		// LegacyAPIGroupPrefixes is used to set up URL parsing for authorization and for validating requests
0000000000000000000000000000000000000000;;		// to InstallLegacyAPIGroup.  New API servers don't generally have legacy groups at all.
0000000000000000000000000000000000000000;;		LegacyAPIGroupPrefixes sets.String
0000000000000000000000000000000000000000;;		// RequestContextMapper maps requests to contexts. Exported so downstream consumers can provider their own mappers
0000000000000000000000000000000000000000;;		// TODO confirm that anyone downstream actually uses this and doesn't just need an accessor
0000000000000000000000000000000000000000;;		RequestContextMapper apirequest.RequestContextMapper
0000000000000000000000000000000000000000;;		// Serializer is required and provides the interface for serializing and converting objects to and from the wire
0000000000000000000000000000000000000000;;		// The default (api.Codecs) usually works fine.
0000000000000000000000000000000000000000;;		Serializer runtime.NegotiatedSerializer
0000000000000000000000000000000000000000;;		// OpenAPIConfig will be used in generating OpenAPI spec. This is nil by default. Use DefaultOpenAPIConfig for "working" defaults.
0000000000000000000000000000000000000000;;		OpenAPIConfig *openapicommon.Config
0000000000000000000000000000000000000000;;		// SwaggerConfig will be used in generating Swagger spec. This is nil by default. Use DefaultSwaggerConfig for "working" defaults.
0000000000000000000000000000000000000000;;		SwaggerConfig *swagger.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RESTOptionsGetter is used to construct RESTStorage types via the generic registry.
0000000000000000000000000000000000000000;;		RESTOptionsGetter genericregistry.RESTOptionsGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If specified, requests will be allocated a random timeout between this value, and twice this value.
0000000000000000000000000000000000000000;;		// Note that it is up to the request handlers to ignore or honor this timeout. In seconds.
0000000000000000000000000000000000000000;;		MinRequestTimeout int
0000000000000000000000000000000000000000;;		// MaxRequestsInFlight is the maximum number of parallel non-long-running requests. Every further
0000000000000000000000000000000000000000;;		// request has to wait. Applies only to non-mutating requests.
0000000000000000000000000000000000000000;;		MaxRequestsInFlight int
0000000000000000000000000000000000000000;;		// MaxMutatingRequestsInFlight is the maximum number of parallel mutating requests. Every further
0000000000000000000000000000000000000000;;		// request has to wait.
0000000000000000000000000000000000000000;;		MaxMutatingRequestsInFlight int
0000000000000000000000000000000000000000;;		// Predicate which is true for paths of long-running http requests
0000000000000000000000000000000000000000;;		LongRunningFunc apirequest.LongRunningRequestCheck
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EnableAPIResponseCompression indicates whether API Responses should support compression
0000000000000000000000000000000000000000;;		// if the client requests it via Accept-Encoding
0000000000000000000000000000000000000000;;		EnableAPIResponseCompression bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//===========================================================================
0000000000000000000000000000000000000000;;		// values below here are targets for removal
0000000000000000000000000000000000000000;;		//===========================================================================
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The port on PublicAddress where a read-write server will be installed.
0000000000000000000000000000000000000000;;		// Defaults to 6443 if not set.
0000000000000000000000000000000000000000;;		ReadWritePort int
0000000000000000000000000000000000000000;;		// PublicAddress is the IP address where members of the cluster (kubelet,
0000000000000000000000000000000000000000;;		// kube-proxy, services, etc.) can reach the GenericAPIServer.
0000000000000000000000000000000000000000;;		// If nil or 0.0.0.0, the host's default interface will be used.
0000000000000000000000000000000000000000;;		PublicAddress net.IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SecureServingInfo struct {
0000000000000000000000000000000000000000;;		// BindAddress is the ip:port to serve on
0000000000000000000000000000000000000000;;		BindAddress string
0000000000000000000000000000000000000000;;		// BindNetwork is the type of network to bind to - defaults to "tcp", accepts "tcp",
0000000000000000000000000000000000000000;;		// "tcp4", and "tcp6".
0000000000000000000000000000000000000000;;		BindNetwork string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cert is the main server cert which is used if SNI does not match. Cert must be non-nil and is
0000000000000000000000000000000000000000;;		// allowed to be in SNICerts.
0000000000000000000000000000000000000000;;		Cert *tls.Certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CACert is an optional certificate authority used for the loopback connection of the Admission controllers.
0000000000000000000000000000000000000000;;		// If this is nil, the certificate authority is extracted from Cert or a matching SNI certificate.
0000000000000000000000000000000000000000;;		CACert *tls.Certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SNICerts are the TLS certificates by name used for SNI.
0000000000000000000000000000000000000000;;		SNICerts map[string]*tls.Certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClientCA is the certificate bundle for all the signers that you'll recognize for incoming client certificates
0000000000000000000000000000000000000000;;		ClientCA *x509.CertPool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MinTLSVersion optionally overrides the minimum TLS version supported.
0000000000000000000000000000000000000000;;		// Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
0000000000000000000000000000000000000000;;		MinTLSVersion uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CipherSuites optionally overrides the list of allowed cipher suites for the server.
0000000000000000000000000000000000000000;;		// Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
0000000000000000000000000000000000000000;;		CipherSuites []uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConfig returns a Config struct with the default values
0000000000000000000000000000000000000000;;	func NewConfig(codecs serializer.CodecFactory) *Config {
0000000000000000000000000000000000000000;;		return &Config{
0000000000000000000000000000000000000000;;			Serializer:                   codecs,
0000000000000000000000000000000000000000;;			ReadWritePort:                443,
0000000000000000000000000000000000000000;;			RequestContextMapper:         apirequest.NewRequestContextMapper(),
0000000000000000000000000000000000000000;;			BuildHandlerChainFunc:        DefaultBuildHandlerChain,
0000000000000000000000000000000000000000;;			LegacyAPIGroupPrefixes:       sets.NewString(DefaultLegacyAPIPrefix),
0000000000000000000000000000000000000000;;			DisabledPostStartHooks:       sets.NewString(),
0000000000000000000000000000000000000000;;			HealthzChecks:                []healthz.HealthzChecker{healthz.PingHealthz},
0000000000000000000000000000000000000000;;			EnableIndex:                  true,
0000000000000000000000000000000000000000;;			EnableDiscovery:              true,
0000000000000000000000000000000000000000;;			EnableProfiling:              true,
0000000000000000000000000000000000000000;;			MaxRequestsInFlight:          400,
0000000000000000000000000000000000000000;;			MaxMutatingRequestsInFlight:  200,
0000000000000000000000000000000000000000;;			MinRequestTimeout:            1800,
0000000000000000000000000000000000000000;;			EnableAPIResponseCompression: utilfeature.DefaultFeatureGate.Enabled(features.APIResponseCompression),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Default to treating watch as a long-running operation
0000000000000000000000000000000000000000;;			// Generic API servers have no inherent long-running subresources
0000000000000000000000000000000000000000;;			LongRunningFunc: genericfilters.BasicLongRunningRequestCheck(sets.NewString("watch"), sets.NewString()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultOpenAPIConfig(getDefinitions openapicommon.GetOpenAPIDefinitions, scheme *runtime.Scheme) *openapicommon.Config {
0000000000000000000000000000000000000000;;		defNamer := apiopenapi.NewDefinitionNamer(scheme)
0000000000000000000000000000000000000000;;		return &openapicommon.Config{
0000000000000000000000000000000000000000;;			ProtocolList:   []string{"https"},
0000000000000000000000000000000000000000;;			IgnorePrefixes: []string{"/swaggerapi"},
0000000000000000000000000000000000000000;;			Info: &spec.Info{
0000000000000000000000000000000000000000;;				InfoProps: spec.InfoProps{
0000000000000000000000000000000000000000;;					Title: "Generic API Server",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DefaultResponse: &spec.Response{
0000000000000000000000000000000000000000;;				ResponseProps: spec.ResponseProps{
0000000000000000000000000000000000000000;;					Description: "Default Response.",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			GetOperationIDAndTags: apiopenapi.GetOperationIDAndTags,
0000000000000000000000000000000000000000;;			GetDefinitionName:     defNamer.GetDefinitionName,
0000000000000000000000000000000000000000;;			GetDefinitions:        getDefinitions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultSwaggerConfig returns a default configuration without WebServiceURL and
0000000000000000000000000000000000000000;;	// WebServices set.
0000000000000000000000000000000000000000;;	func DefaultSwaggerConfig() *swagger.Config {
0000000000000000000000000000000000000000;;		return &swagger.Config{
0000000000000000000000000000000000000000;;			ApiPath:         "/swaggerapi",
0000000000000000000000000000000000000000;;			SwaggerPath:     "/swaggerui/",
0000000000000000000000000000000000000000;;			SwaggerFilePath: "/swagger-ui/",
0000000000000000000000000000000000000000;;			SchemaFormatHandler: func(typeName string) string {
0000000000000000000000000000000000000000;;				switch typeName {
0000000000000000000000000000000000000000;;				case "metav1.Time", "*metav1.Time":
0000000000000000000000000000000000000000;;					return "date-time"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Config) ApplyClientCert(clientCAFile string) (*Config, error) {
0000000000000000000000000000000000000000;;		if c.SecureServingInfo != nil {
0000000000000000000000000000000000000000;;			if len(clientCAFile) > 0 {
0000000000000000000000000000000000000000;;				clientCAs, err := certutil.CertsFromFile(clientCAFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to load client CA file: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.SecureServingInfo.ClientCA == nil {
0000000000000000000000000000000000000000;;					c.SecureServingInfo.ClientCA = x509.NewCertPool()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, cert := range clientCAs {
0000000000000000000000000000000000000000;;					c.SecureServingInfo.ClientCA.AddCert(cert)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type completedConfig struct {
0000000000000000000000000000000000000000;;		*Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete fills in any fields not set that are required to have valid data and can be derived
0000000000000000000000000000000000000000;;	// from other fields.  If you're going to `ApplyOptions`, do that first.  It's mutating the receiver.
0000000000000000000000000000000000000000;;	func (c *Config) Complete() completedConfig {
0000000000000000000000000000000000000000;;		if len(c.ExternalAddress) == 0 && c.PublicAddress != nil {
0000000000000000000000000000000000000000;;			hostAndPort := c.PublicAddress.String()
0000000000000000000000000000000000000000;;			if c.ReadWritePort != 0 {
0000000000000000000000000000000000000000;;				hostAndPort = net.JoinHostPort(hostAndPort, strconv.Itoa(c.ReadWritePort))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.ExternalAddress = hostAndPort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.OpenAPIConfig != nil && c.OpenAPIConfig.SecurityDefinitions != nil {
0000000000000000000000000000000000000000;;			// Setup OpenAPI security: all APIs will have the same authentication for now.
0000000000000000000000000000000000000000;;			c.OpenAPIConfig.DefaultSecurity = []map[string][]string{}
0000000000000000000000000000000000000000;;			keys := []string{}
0000000000000000000000000000000000000000;;			for k := range *c.OpenAPIConfig.SecurityDefinitions {
0000000000000000000000000000000000000000;;				keys = append(keys, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(keys)
0000000000000000000000000000000000000000;;			for _, k := range keys {
0000000000000000000000000000000000000000;;				c.OpenAPIConfig.DefaultSecurity = append(c.OpenAPIConfig.DefaultSecurity, map[string][]string{k: {}})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.OpenAPIConfig.CommonResponses == nil {
0000000000000000000000000000000000000000;;				c.OpenAPIConfig.CommonResponses = map[int]spec.Response{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, exists := c.OpenAPIConfig.CommonResponses[http.StatusUnauthorized]; !exists {
0000000000000000000000000000000000000000;;				c.OpenAPIConfig.CommonResponses[http.StatusUnauthorized] = spec.Response{
0000000000000000000000000000000000000000;;					ResponseProps: spec.ResponseProps{
0000000000000000000000000000000000000000;;						Description: "Unauthorized",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.OpenAPIConfig.Info == nil {
0000000000000000000000000000000000000000;;				c.OpenAPIConfig.Info = &spec.Info{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.OpenAPIConfig.Info.Version == "" {
0000000000000000000000000000000000000000;;				if c.Version != nil {
0000000000000000000000000000000000000000;;					c.OpenAPIConfig.Info.Version = strings.Split(c.Version.String(), "-")[0]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					c.OpenAPIConfig.Info.Version = "unversioned"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.SwaggerConfig != nil && len(c.SwaggerConfig.WebServicesUrl) == 0 {
0000000000000000000000000000000000000000;;			if c.SecureServingInfo != nil {
0000000000000000000000000000000000000000;;				c.SwaggerConfig.WebServicesUrl = "https://" + c.ExternalAddress
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c.SwaggerConfig.WebServicesUrl = "http://" + c.ExternalAddress
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.DiscoveryAddresses == nil {
0000000000000000000000000000000000000000;;			c.DiscoveryAddresses = discovery.DefaultAddresses{DefaultAddress: c.ExternalAddress}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the loopbackclientconfig is specified AND it has a token for use against the API server
0000000000000000000000000000000000000000;;		// wrap the authenticator and authorizer in loopback authentication logic
0000000000000000000000000000000000000000;;		if c.Authenticator != nil && c.Authorizer != nil && c.LoopbackClientConfig != nil && len(c.LoopbackClientConfig.BearerToken) > 0 {
0000000000000000000000000000000000000000;;			privilegedLoopbackToken := c.LoopbackClientConfig.BearerToken
0000000000000000000000000000000000000000;;			var uid = uuid.NewRandom().String()
0000000000000000000000000000000000000000;;			tokens := make(map[string]*user.DefaultInfo)
0000000000000000000000000000000000000000;;			tokens[privilegedLoopbackToken] = &user.DefaultInfo{
0000000000000000000000000000000000000000;;				Name:   user.APIServerUser,
0000000000000000000000000000000000000000;;				UID:    uid,
0000000000000000000000000000000000000000;;				Groups: []string{user.SystemPrivilegedGroup},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tokenAuthenticator := authenticatorfactory.NewFromTokens(tokens)
0000000000000000000000000000000000000000;;			c.Authenticator = authenticatorunion.New(tokenAuthenticator, c.Authenticator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tokenAuthorizer := authorizerfactory.NewPrivilegedGroups(user.SystemPrivilegedGroup)
0000000000000000000000000000000000000000;;			c.Authorizer = authorizerunion.New(tokenAuthorizer, c.Authorizer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SkipComplete provides a way to construct a server instance without config completion.
0000000000000000000000000000000000000000;;	func (c *Config) SkipComplete() completedConfig {
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new server which logically combines the handling chain with the passed server.
0000000000000000000000000000000000000000;;	// name is used to differentiate for logging.  The handler chain in particular can be difficult as it starts delgating.
0000000000000000000000000000000000000000;;	func (c completedConfig) New(name string, delegationTarget DelegationTarget) (*GenericAPIServer, error) {
0000000000000000000000000000000000000000;;		// The delegationTarget and the config must agree on the RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Serializer == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Genericapiserver.New() called with config.Serializer == nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.LoopbackClientConfig == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Genericapiserver.New() called with config.LoopbackClientConfig == nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handlerChainBuilder := func(handler http.Handler) http.Handler {
0000000000000000000000000000000000000000;;			return c.BuildHandlerChainFunc(handler, c.Config)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiServerHandler := NewAPIServerHandler(name, c.RequestContextMapper, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &GenericAPIServer{
0000000000000000000000000000000000000000;;			discoveryAddresses:     c.DiscoveryAddresses,
0000000000000000000000000000000000000000;;			LoopbackClientConfig:   c.LoopbackClientConfig,
0000000000000000000000000000000000000000;;			legacyAPIGroupPrefixes: c.LegacyAPIGroupPrefixes,
0000000000000000000000000000000000000000;;			admissionControl:       c.AdmissionControl,
0000000000000000000000000000000000000000;;			requestContextMapper:   c.RequestContextMapper,
0000000000000000000000000000000000000000;;			Serializer:             c.Serializer,
0000000000000000000000000000000000000000;;			AuditBackend:           c.AuditBackend,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			minRequestTimeout: time.Duration(c.MinRequestTimeout) * time.Second,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			SecureServingInfo: c.SecureServingInfo,
0000000000000000000000000000000000000000;;			ExternalAddress:   c.ExternalAddress,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Handler: apiServerHandler,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			listedPathProvider: apiServerHandler,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			swaggerConfig: c.SwaggerConfig,
0000000000000000000000000000000000000000;;			openAPIConfig: c.OpenAPIConfig,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			postStartHooks:         map[string]postStartHookEntry{},
0000000000000000000000000000000000000000;;			disabledPostStartHooks: c.DisabledPostStartHooks,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			healthzChecks: c.HealthzChecks,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			DiscoveryGroupManager: discovery.NewRootAPIsHandler(c.DiscoveryAddresses, c.Serializer, c.RequestContextMapper),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			enableAPIResponseCompression: c.EnableAPIResponseCompression,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range delegationTarget.PostStartHooks() {
0000000000000000000000000000000000000000;;			s.postStartHooks[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericApiServerHookName := "generic-apiserver-start-informers"
0000000000000000000000000000000000000000;;		if c.SharedInformerFactory != nil && !s.isHookRegistered(genericApiServerHookName) {
0000000000000000000000000000000000000000;;			err := s.AddPostStartHook(genericApiServerHookName, func(context PostStartHookContext) error {
0000000000000000000000000000000000000000;;				c.SharedInformerFactory.Start(context.StopCh)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, delegateCheck := range delegationTarget.HealthzChecks() {
0000000000000000000000000000000000000000;;			skip := false
0000000000000000000000000000000000000000;;			for _, existingCheck := range c.HealthzChecks {
0000000000000000000000000000000000000000;;				if existingCheck.Name() == delegateCheck.Name() {
0000000000000000000000000000000000000000;;					skip = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if skip {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.healthzChecks = append(s.healthzChecks, delegateCheck)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.listedPathProvider = routes.ListedPathProviders{s.listedPathProvider, delegationTarget}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		installAPI(s, c.Config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// use the UnprotectedHandler from the delegation target to ensure that we don't attempt to double authenticator, authorize,
0000000000000000000000000000000000000000;;		// or some other part of the filter chain in delegation cases.
0000000000000000000000000000000000000000;;		if delegationTarget.UnprotectedHandler() == nil && c.EnableIndex {
0000000000000000000000000000000000000000;;			s.Handler.NonGoRestfulMux.NotFoundHandler(routes.IndexLister{
0000000000000000000000000000000000000000;;				StatusCode:   http.StatusNotFound,
0000000000000000000000000000000000000000;;				PathProvider: s.listedPathProvider,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler {
0000000000000000000000000000000000000000;;		handler := genericapifilters.WithAuthorization(apiHandler, c.RequestContextMapper, c.Authorizer, c.Serializer)
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithImpersonation(handler, c.RequestContextMapper, c.Authorizer, c.Serializer)
0000000000000000000000000000000000000000;;		if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) {
0000000000000000000000000000000000000000;;			handler = genericapifilters.WithAudit(handler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			handler = genericapifilters.WithLegacyAudit(handler, c.RequestContextMapper, c.LegacyAuditWriter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithAuthentication(handler, c.RequestContextMapper, c.Authenticator, genericapifilters.Unauthorized(c.RequestContextMapper, c.Serializer, c.SupportsBasicAuth))
0000000000000000000000000000000000000000;;		handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, nil, nil, nil, "true")
0000000000000000000000000000000000000000;;		handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.RequestContextMapper, c.LongRunningFunc)
0000000000000000000000000000000000000000;;		handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.RequestContextMapper, c.LongRunningFunc)
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithRequestInfo(handler, NewRequestInfoResolver(c), c.RequestContextMapper)
0000000000000000000000000000000000000000;;		handler = apirequest.WithRequestContext(handler, c.RequestContextMapper)
0000000000000000000000000000000000000000;;		handler = genericfilters.WithPanicRecovery(handler)
0000000000000000000000000000000000000000;;		return handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func installAPI(s *GenericAPIServer, c *Config) {
0000000000000000000000000000000000000000;;		if c.EnableIndex {
0000000000000000000000000000000000000000;;			routes.Index{}.Install(s.listedPathProvider, s.Handler.NonGoRestfulMux)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.SwaggerConfig != nil && c.EnableSwaggerUI {
0000000000000000000000000000000000000000;;			routes.SwaggerUI{}.Install(s.Handler.NonGoRestfulMux)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.EnableProfiling {
0000000000000000000000000000000000000000;;			routes.Profiling{}.Install(s.Handler.NonGoRestfulMux)
0000000000000000000000000000000000000000;;			if c.EnableContentionProfiling {
0000000000000000000000000000000000000000;;				goruntime.SetBlockProfileRate(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.EnableMetrics {
0000000000000000000000000000000000000000;;			if c.EnableProfiling {
0000000000000000000000000000000000000000;;				routes.MetricsWithReset{}.Install(s.Handler.NonGoRestfulMux)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				routes.DefaultMetrics{}.Install(s.Handler.NonGoRestfulMux)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		routes.Version{Version: c.Version}.Install(s.Handler.GoRestfulContainer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.EnableDiscovery {
0000000000000000000000000000000000000000;;			s.Handler.GoRestfulContainer.Add(s.DiscoveryGroupManager.WebService())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRequestInfoResolver(c *Config) *apirequest.RequestInfoFactory {
0000000000000000000000000000000000000000;;		apiPrefixes := sets.NewString(strings.Trim(APIGroupPrefix, "/")) // all possible API prefixes
0000000000000000000000000000000000000000;;		legacyAPIPrefixes := sets.String{}                               // APIPrefixes that won't have groups (legacy)
0000000000000000000000000000000000000000;;		for legacyAPIPrefix := range c.LegacyAPIGroupPrefixes {
0000000000000000000000000000000000000000;;			apiPrefixes.Insert(strings.Trim(legacyAPIPrefix, "/"))
0000000000000000000000000000000000000000;;			legacyAPIPrefixes.Insert(strings.Trim(legacyAPIPrefix, "/"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &apirequest.RequestInfoFactory{
0000000000000000000000000000000000000000;;			APIPrefixes:          apiPrefixes,
0000000000000000000000000000000000000000;;			GrouplessAPIPrefixes: legacyAPIPrefixes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
