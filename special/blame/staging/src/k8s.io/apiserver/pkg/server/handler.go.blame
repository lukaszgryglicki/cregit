0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
e545bf7cbd4a4afc6c5610b883a1f78e9399a404;pkg/genericapiserver/mux/container.go[pkg/genericapiserver/mux/container.go][staging/src/k8s.io/apiserver/pkg/server/handler.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		rt "runtime"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/mux"
0000000000000000000000000000000000000000;;		genericmux "k8s.io/apiserver/pkg/server/mux"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIServerHandlers holds the different http.Handlers used by the API server.
0000000000000000000000000000000000000000;;	// This includes the full handler chain, the director (which chooses between gorestful and nonGoRestful,
0000000000000000000000000000000000000000;;	// the gorestful handler (used for the API) which falls through to the nonGoRestful handler on unregistered paths,
0000000000000000000000000000000000000000;;	// and the nonGoRestful handler (which can contain a fallthrough of its own)
0000000000000000000000000000000000000000;;	// FullHandlerChain -> Director -> {GoRestfulContainer,NonGoRestfulMux} based on inspection of registered web services
0000000000000000000000000000000000000000;;	type APIServerHandler struct {
0000000000000000000000000000000000000000;;		// FullHandlerChain is the one that is eventually served with.  It should include the full filter
0000000000000000000000000000000000000000;;		// chain and then call the Director.
0000000000000000000000000000000000000000;;		FullHandlerChain http.Handler
0000000000000000000000000000000000000000;;		// The registered APIs.  InstallAPIs uses this.  Other servers probably shouldn't access this directly.
0000000000000000000000000000000000000000;;		GoRestfulContainer *restful.Container
0000000000000000000000000000000000000000;;		// NonGoRestfulMux is the final HTTP handler in the chain.
0000000000000000000000000000000000000000;;		// It comes after all filters and the API handling
0000000000000000000000000000000000000000;;		// This is where other servers can attach handler to various parts of the chain.
0000000000000000000000000000000000000000;;		NonGoRestfulMux *mux.PathRecorderMux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Director is here so that we can properly handle fall through and proxy cases.
0000000000000000000000000000000000000000;;		// This looks a bit bonkers, but here's what's happening.  We need to have /apis handling registered in gorestful in order to have
0000000000000000000000000000000000000000;;		// swagger generated for compatibility.  Doing that with `/apis` as a webservice, means that it forcibly 404s (no defaulting allowed)
0000000000000000000000000000000000000000;;		// all requests which are not /apis or /apis/.  We need those calls to fall through behind goresful for proper delegation.  Trying to
0000000000000000000000000000000000000000;;		// register for a pattern which includes everything behind it doesn't work because gorestful negotiates for verbs and content encoding
0000000000000000000000000000000000000000;;		// and all those things go crazy when gorestful really just needs to pass through.  In addition, openapi enforces unique verb constraints
0000000000000000000000000000000000000000;;		// which we don't fit into and it still muddies up swagger.  Trying to switch the webservices into a route doesn't work because the
0000000000000000000000000000000000000000;;		//  containing webservice faces all the same problems listed above.
0000000000000000000000000000000000000000;;		// This leads to the crazy thing done here.  Our mux does what we need, so we'll place it in front of gorestful.  It will introspect to
0000000000000000000000000000000000000000;;		// decide if the the route is likely to be handled by goresful and route there if needed.  Otherwise, it goes to PostGoRestful mux in
0000000000000000000000000000000000000000;;		// order to handle "normal" paths and delegation. Hopefully no API consumers will ever have to deal with this level of detail.  I think
0000000000000000000000000000000000000000;;		// we should consider completely removing gorestful.
0000000000000000000000000000000000000000;;		// Other servers should only use this opaquely to delegate to an API server.
0000000000000000000000000000000000000000;;		Director http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerChainBuilderFn is used to wrap the GoRestfulContainer handler using the provided handler chain.
0000000000000000000000000000000000000000;;	// It is normally used to apply filtering like authentication and authorization
0000000000000000000000000000000000000000;;	type HandlerChainBuilderFn func(apiHandler http.Handler) http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAPIServerHandler(name string, contextMapper request.RequestContextMapper, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler) *APIServerHandler {
0000000000000000000000000000000000000000;;		nonGoRestfulMux := genericmux.NewPathRecorderMux(name)
0000000000000000000000000000000000000000;;		if notFoundHandler != nil {
0000000000000000000000000000000000000000;;			nonGoRestfulMux.NotFoundHandler(notFoundHandler)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gorestfulContainer := restful.NewContainer()
0000000000000000000000000000000000000000;;		gorestfulContainer.ServeMux = http.NewServeMux()
0000000000000000000000000000000000000000;;		gorestfulContainer.Router(restful.CurlyRouter{}) // e.g. for proxy/{kind}/{name}/{*}
0000000000000000000000000000000000000000;;		gorestfulContainer.RecoverHandler(func(panicReason interface{}, httpWriter http.ResponseWriter) {
0000000000000000000000000000000000000000;;			logStackOnRecover(s, panicReason, httpWriter)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		gorestfulContainer.ServiceErrorHandler(func(serviceErr restful.ServiceError, request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;			ctx, ok := contextMapper.Get(request.Request)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				responsewriters.InternalError(response.ResponseWriter, request.Request, errors.New("no context found for request"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceErrorHandler(ctx, s, serviceErr, request, response)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		director := director{
0000000000000000000000000000000000000000;;			name:               name,
0000000000000000000000000000000000000000;;			goRestfulContainer: gorestfulContainer,
0000000000000000000000000000000000000000;;			nonGoRestfulMux:    nonGoRestfulMux,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &APIServerHandler{
0000000000000000000000000000000000000000;;			FullHandlerChain:   handlerChainBuilder(director),
0000000000000000000000000000000000000000;;			GoRestfulContainer: gorestfulContainer,
0000000000000000000000000000000000000000;;			NonGoRestfulMux:    nonGoRestfulMux,
0000000000000000000000000000000000000000;;			Director:           director,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListedPaths returns the paths that should be shown under /
0000000000000000000000000000000000000000;;	func (a *APIServerHandler) ListedPaths() []string {
0000000000000000000000000000000000000000;;		var handledPaths []string
0000000000000000000000000000000000000000;;		// Extract the paths handled using restful.WebService
0000000000000000000000000000000000000000;;		for _, ws := range a.GoRestfulContainer.RegisteredWebServices() {
0000000000000000000000000000000000000000;;			handledPaths = append(handledPaths, ws.RootPath())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handledPaths = append(handledPaths, a.NonGoRestfulMux.ListedPaths()...)
0000000000000000000000000000000000000000;;		sort.Strings(handledPaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handledPaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type director struct {
0000000000000000000000000000000000000000;;		name               string
0000000000000000000000000000000000000000;;		goRestfulContainer *restful.Container
0000000000000000000000000000000000000000;;		nonGoRestfulMux    *mux.PathRecorderMux
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d director) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		path := req.URL.Path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check to see if our webservices want to claim this path
0000000000000000000000000000000000000000;;		for _, ws := range d.goRestfulContainer.RegisteredWebServices() {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ws.RootPath() == "/apis":
0000000000000000000000000000000000000000;;				// if we are exactly /apis or /apis/, then we need special handling in loop.
0000000000000000000000000000000000000000;;				// normally these are passed to the nonGoRestfulMux, but if discovery is enabled, it will go directly.
0000000000000000000000000000000000000000;;				// We can't rely on a prefix match since /apis matches everything (see the big comment on Director above)
0000000000000000000000000000000000000000;;				if path == "/apis" || path == "/apis/" {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("%v: %v %q satisfied by gorestful with webservice %v", d.name, req.Method, path, ws.RootPath())
0000000000000000000000000000000000000000;;					// don't use servemux here because gorestful servemuxes get messed up when removing webservices
0000000000000000000000000000000000000000;;					// TODO fix gorestful, remove TPRs, or stop using gorestful
0000000000000000000000000000000000000000;;					d.goRestfulContainer.Dispatch(w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case strings.HasPrefix(path, ws.RootPath()):
0000000000000000000000000000000000000000;;				// ensure an exact match or a path boundary match
0000000000000000000000000000000000000000;;				if len(path) == len(ws.RootPath()) || path[len(ws.RootPath())] == '/' {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("%v: %v %q satisfied by gorestful with webservice %v", d.name, req.Method, path, ws.RootPath())
0000000000000000000000000000000000000000;;					// don't use servemux here because gorestful servemuxes get messed up when removing webservices
0000000000000000000000000000000000000000;;					// TODO fix gorestful, remove TPRs, or stop using gorestful
0000000000000000000000000000000000000000;;					d.goRestfulContainer.Dispatch(w, req)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we didn't find a match, then we just skip gorestful altogether
0000000000000000000000000000000000000000;;		glog.V(5).Infof("%v: %v %q satisfied by nonGoRestful", d.name, req.Method, path)
0000000000000000000000000000000000000000;;		d.nonGoRestfulMux.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//TODO: Unify with RecoverPanics?
0000000000000000000000000000000000000000;;	func logStackOnRecover(s runtime.NegotiatedSerializer, panicReason interface{}, w http.ResponseWriter) {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		buffer.WriteString(fmt.Sprintf("recover from panic situation: - %v\r\n", panicReason))
0000000000000000000000000000000000000000;;		for i := 2; ; i++ {
0000000000000000000000000000000000000000;;			_, file, line, ok := rt.Caller(i)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.WriteString(fmt.Sprintf("    %s:%d\r\n", file, line))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Errorln(buffer.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := http.Header{}
0000000000000000000000000000000000000000;;		if ct := w.Header().Get("Content-Type"); len(ct) > 0 {
0000000000000000000000000000000000000000;;			headers.Set("Accept", ct)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		emptyContext := request.NewContext() // best we can do here: we don't know the request
0000000000000000000000000000000000000000;;		responsewriters.ErrorNegotiated(emptyContext, apierrors.NewGenericServerResponse(http.StatusInternalServerError, "", schema.GroupResource{}, "", "", 0, false), s, schema.GroupVersion{}, w, &http.Request{Header: headers})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceErrorHandler(ctx request.Context, s runtime.NegotiatedSerializer, serviceErr restful.ServiceError, request *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;		responsewriters.ErrorNegotiated(
0000000000000000000000000000000000000000;;			ctx,
0000000000000000000000000000000000000000;;			apierrors.NewGenericServerResponse(serviceErr.Code, "", schema.GroupResource{}, "", serviceErr.Message, 0, false),
0000000000000000000000000000000000000000;;			s,
0000000000000000000000000000000000000000;;			schema.GroupVersion{},
0000000000000000000000000000000000000000;;			resp,
0000000000000000000000000000000000000000;;			request.Request,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP makes it an http.Handler
0000000000000000000000000000000000000000;;	func (a *APIServerHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		a.FullHandlerChain.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;	}
