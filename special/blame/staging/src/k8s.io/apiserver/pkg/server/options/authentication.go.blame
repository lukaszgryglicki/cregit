0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2b7b457926026557350d1f3ea910bf10dcd6a416;pkg/genericapiserver/options/authentication.go[pkg/genericapiserver/options/authentication.go][staging/src/k8s.io/apiserver/pkg/server/options/authentication.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticatorfactory"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		authenticationclient "k8s.io/client-go/kubernetes/typed/authentication/v1beta1"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/client-go/kubernetes/typed/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RequestHeaderAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		UsernameHeaders     []string
0000000000000000000000000000000000000000;;		GroupHeaders        []string
0000000000000000000000000000000000000000;;		ExtraHeaderPrefixes []string
0000000000000000000000000000000000000000;;		ClientCAFile        string
0000000000000000000000000000000000000000;;		AllowedNames        []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *RequestHeaderAuthenticationOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringSliceVar(&s.UsernameHeaders, "requestheader-username-headers", s.UsernameHeaders, ""+
0000000000000000000000000000000000000000;;			"List of request headers to inspect for usernames. X-Remote-User is common.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringSliceVar(&s.GroupHeaders, "requestheader-group-headers", s.GroupHeaders, ""+
0000000000000000000000000000000000000000;;			"List of request headers to inspect for groups. X-Remote-Group is suggested.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringSliceVar(&s.ExtraHeaderPrefixes, "requestheader-extra-headers-prefix", s.ExtraHeaderPrefixes, ""+
0000000000000000000000000000000000000000;;			"List of request header prefixes to inspect. X-Remote-Extra- is suggested.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.ClientCAFile, "requestheader-client-ca-file", s.ClientCAFile, ""+
0000000000000000000000000000000000000000;;			"Root certificate bundle to use to verify client certificates on incoming requests "+
0000000000000000000000000000000000000000;;			"before trusting usernames in headers specified by --requestheader-username-headers")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringSliceVar(&s.AllowedNames, "requestheader-allowed-names", s.AllowedNames, ""+
0000000000000000000000000000000000000000;;			"List of client certificate common names to allow to provide usernames in headers "+
0000000000000000000000000000000000000000;;			"specified by --requestheader-username-headers. If empty, any client certificate validated "+
0000000000000000000000000000000000000000;;			"by the authorities in --requestheader-client-ca-file is allowed.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToAuthenticationRequestHeaderConfig returns a RequestHeaderConfig config object for these options
0000000000000000000000000000000000000000;;	// if necessary, nil otherwise.
0000000000000000000000000000000000000000;;	func (s *RequestHeaderAuthenticationOptions) ToAuthenticationRequestHeaderConfig() *authenticatorfactory.RequestHeaderConfig {
0000000000000000000000000000000000000000;;		if len(s.ClientCAFile) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &authenticatorfactory.RequestHeaderConfig{
0000000000000000000000000000000000000000;;			UsernameHeaders:     s.UsernameHeaders,
0000000000000000000000000000000000000000;;			GroupHeaders:        s.GroupHeaders,
0000000000000000000000000000000000000000;;			ExtraHeaderPrefixes: s.ExtraHeaderPrefixes,
0000000000000000000000000000000000000000;;			ClientCA:            s.ClientCAFile,
0000000000000000000000000000000000000000;;			AllowedClientNames:  s.AllowedNames,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientCertAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		// ClientCA is the certificate bundle for all the signers that you'll recognize for incoming client certificates
0000000000000000000000000000000000000000;;		ClientCA string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ClientCertAuthenticationOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&s.ClientCA, "client-ca-file", s.ClientCA, ""+
0000000000000000000000000000000000000000;;			"If set, any request presenting a client certificate signed by one of "+
0000000000000000000000000000000000000000;;			"the authorities in the client-ca-file is authenticated with an identity "+
0000000000000000000000000000000000000000;;			"corresponding to the CommonName of the client certificate.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelegatingAuthenticationOptions provides an easy way for composing API servers to delegate their authentication to
0000000000000000000000000000000000000000;;	// the root kube API server.  The API federator will act as
0000000000000000000000000000000000000000;;	// a front proxy and direction connections will be able to delegate to the core kube API server
0000000000000000000000000000000000000000;;	type DelegatingAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		// RemoteKubeConfigFile is the file to use to connect to a "normal" kube API server which hosts the
0000000000000000000000000000000000000000;;		// TokenAccessReview.authentication.k8s.io endpoint for checking tokens.
0000000000000000000000000000000000000000;;		RemoteKubeConfigFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CacheTTL is the length of time that a token authentication answer will be cached.
0000000000000000000000000000000000000000;;		CacheTTL time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ClientCert    ClientCertAuthenticationOptions
0000000000000000000000000000000000000000;;		RequestHeader RequestHeaderAuthenticationOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SkipInClusterLookup bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDelegatingAuthenticationOptions() *DelegatingAuthenticationOptions {
0000000000000000000000000000000000000000;;		return &DelegatingAuthenticationOptions{
0000000000000000000000000000000000000000;;			// very low for responsiveness, but high enough to handle storms
0000000000000000000000000000000000000000;;			CacheTTL:   10 * time.Second,
0000000000000000000000000000000000000000;;			ClientCert: ClientCertAuthenticationOptions{},
0000000000000000000000000000000000000000;;			RequestHeader: RequestHeaderAuthenticationOptions{
0000000000000000000000000000000000000000;;				UsernameHeaders:     []string{"x-remote-user"},
0000000000000000000000000000000000000000;;				GroupHeaders:        []string{"x-remote-group"},
0000000000000000000000000000000000000000;;				ExtraHeaderPrefixes: []string{"x-remote-extra-"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) Validate() []error {
0000000000000000000000000000000000000000;;		allErrors := []error{}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&s.RemoteKubeConfigFile, "authentication-kubeconfig", s.RemoteKubeConfigFile, ""+
0000000000000000000000000000000000000000;;			"kubeconfig file pointing at the 'core' kubernetes server with enough rights to create "+
0000000000000000000000000000000000000000;;			"tokenaccessreviews.authentication.k8s.io.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.DurationVar(&s.CacheTTL, "authentication-token-webhook-cache-ttl", s.CacheTTL,
0000000000000000000000000000000000000000;;			"The duration to cache responses from the webhook token authenticator.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.ClientCert.AddFlags(fs)
0000000000000000000000000000000000000000;;		s.RequestHeader.AddFlags(fs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.BoolVar(&s.SkipInClusterLookup, "authentication-skip-lookup", s.SkipInClusterLookup, ""+
0000000000000000000000000000000000000000;;			"If false, the authentication-kubeconfig will be used to lookup missing authentication "+
0000000000000000000000000000000000000000;;			"configuration from the cluster.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) ApplyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		clientCA, err := s.getClientCA()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, err = c.ApplyClientCert(clientCA.ClientCA)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to load client CA file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestHeader, err := s.getRequestHeader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, err = c.ApplyClientCert(requestHeader.ClientCAFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to load client CA file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg, err := s.ToAuthenticationConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		authenticator, securityDefinitions, err := cfg.New()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Authenticator = authenticator
0000000000000000000000000000000000000000;;		if c.OpenAPIConfig != nil {
0000000000000000000000000000000000000000;;			c.OpenAPIConfig.SecurityDefinitions = securityDefinitions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.SupportsBasicAuth = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) ToAuthenticationConfig() (authenticatorfactory.DelegatingAuthenticatorConfig, error) {
0000000000000000000000000000000000000000;;		tokenClient, err := s.newTokenAccessReview()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return authenticatorfactory.DelegatingAuthenticatorConfig{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientCA, err := s.getClientCA()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return authenticatorfactory.DelegatingAuthenticatorConfig{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestHeader, err := s.getRequestHeader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return authenticatorfactory.DelegatingAuthenticatorConfig{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := authenticatorfactory.DelegatingAuthenticatorConfig{
0000000000000000000000000000000000000000;;			Anonymous:               true,
0000000000000000000000000000000000000000;;			TokenAccessReviewClient: tokenClient,
0000000000000000000000000000000000000000;;			CacheTTL:                s.CacheTTL,
0000000000000000000000000000000000000000;;			ClientCAFile:            clientCA.ClientCA,
0000000000000000000000000000000000000000;;			RequestHeaderConfig:     requestHeader.ToAuthenticationRequestHeaderConfig(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		authenticationConfigMapNamespace = metav1.NamespaceSystem
0000000000000000000000000000000000000000;;		authenticationConfigMapName      = "extension-apiserver-authentication"
0000000000000000000000000000000000000000;;		authenticationRoleName           = "extension-apiserver-authentication-reader"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) getClientCA() (*ClientCertAuthenticationOptions, error) {
0000000000000000000000000000000000000000;;		if len(s.ClientCert.ClientCA) > 0 || s.SkipInClusterLookup {
0000000000000000000000000000000000000000;;			return &s.ClientCert, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		incluster, err := s.lookupInClusterClientCA()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to get configmap/%s in %s.  Usually fixed by "+
0000000000000000000000000000000000000000;;				"'kubectl create rolebinding -n %s ROLE_NAME --role=%s --serviceaccount=YOUR_NS:YOUR_SA'",
0000000000000000000000000000000000000000;;				authenticationConfigMapName, authenticationConfigMapNamespace, authenticationConfigMapNamespace, authenticationRoleName)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if incluster == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cluster doesn't provide client-ca-file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return incluster, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) getRequestHeader() (*RequestHeaderAuthenticationOptions, error) {
0000000000000000000000000000000000000000;;		if len(s.RequestHeader.ClientCAFile) > 0 || s.SkipInClusterLookup {
0000000000000000000000000000000000000000;;			return &s.RequestHeader, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		incluster, err := s.lookupInClusterRequestHeader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to get configmap/%s in %s.  Usually fixed by "+
0000000000000000000000000000000000000000;;				"'kubectl create rolebinding -n %s ROLE_NAME --role=%s --serviceaccount=YOUR_NS:YOUR_SA'",
0000000000000000000000000000000000000000;;				authenticationConfigMapName, authenticationConfigMapNamespace, authenticationConfigMapNamespace, authenticationRoleName)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if incluster == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cluster doesn't provide requestheader-client-ca-file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return incluster, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) lookupInClusterClientCA() (*ClientCertAuthenticationOptions, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := s.getClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := coreclient.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authConfigMap, err := client.ConfigMaps(authenticationConfigMapNamespace).Get(authenticationConfigMapName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientCA, ok := authConfigMap.Data["client-ca-file"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "client-ca-file")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(clientCA), 0600); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ClientCertAuthenticationOptions{ClientCA: f.Name()}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) lookupInClusterRequestHeader() (*RequestHeaderAuthenticationOptions, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := s.getClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := coreclient.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authConfigMap, err := client.ConfigMaps(authenticationConfigMapNamespace).Get(authenticationConfigMapName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestHeaderCA, ok := authConfigMap.Data["requestheader-client-ca-file"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "requestheader-client-ca-file")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(requestHeaderCA), 0600); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usernameHeaders, err := deserializeStrings(authConfigMap.Data["requestheader-username-headers"])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupHeaders, err := deserializeStrings(authConfigMap.Data["requestheader-group-headers"])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extraHeaderPrefixes, err := deserializeStrings(authConfigMap.Data["requestheader-extra-headers-prefix"])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allowedNames, err := deserializeStrings(authConfigMap.Data["requestheader-allowed-names"])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &RequestHeaderAuthenticationOptions{
0000000000000000000000000000000000000000;;			UsernameHeaders:     usernameHeaders,
0000000000000000000000000000000000000000;;			GroupHeaders:        groupHeaders,
0000000000000000000000000000000000000000;;			ExtraHeaderPrefixes: extraHeaderPrefixes,
0000000000000000000000000000000000000000;;			ClientCAFile:        f.Name(),
0000000000000000000000000000000000000000;;			AllowedNames:        allowedNames,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deserializeStrings(in string) ([]string, error) {
0000000000000000000000000000000000000000;;		if len(in) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ret []string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal([]byte(in), &ret); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) getClientConfig() (*rest.Config, error) {
0000000000000000000000000000000000000000;;		var clientConfig *rest.Config
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if len(s.RemoteKubeConfigFile) > 0 {
0000000000000000000000000000000000000000;;			loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: s.RemoteKubeConfigFile}
0000000000000000000000000000000000000000;;			loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clientConfig, err = loader.ClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// without the remote kubeconfig file, try to use the in-cluster config.  Most addon API servers will
0000000000000000000000000000000000000000;;			// use this path
0000000000000000000000000000000000000000;;			clientConfig, err = rest.InClusterConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set high qps/burst limits since this will effectively limit API server responsiveness
0000000000000000000000000000000000000000;;		clientConfig.QPS = 200
0000000000000000000000000000000000000000;;		clientConfig.Burst = 400
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthenticationOptions) newTokenAccessReview() (authenticationclient.TokenReviewInterface, error) {
0000000000000000000000000000000000000000;;		clientConfig, err := s.getClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := authenticationclient.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return client.TokenReviews(), nil
0000000000000000000000000000000000000000;;	}
