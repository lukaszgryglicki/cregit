0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
40fe2598d553cb4584d1e5bdebac0b0ce55e2f47;pkg/genericapiserver/options/authorization.go[pkg/genericapiserver/options/authorization.go][staging/src/k8s.io/apiserver/pkg/server/options/authorization.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizerfactory"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		authorizationclient "k8s.io/client-go/kubernetes/typed/authorization/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelegatingAuthorizationOptions provides an easy way for composing API servers to delegate their authorization to
0000000000000000000000000000000000000000;;	// the root kube API server
0000000000000000000000000000000000000000;;	type DelegatingAuthorizationOptions struct {
0000000000000000000000000000000000000000;;		// RemoteKubeConfigFile is the file to use to connect to a "normal" kube API server which hosts the
0000000000000000000000000000000000000000;;		// SubjectAccessReview.authorization.k8s.io endpoint for checking tokens.
0000000000000000000000000000000000000000;;		RemoteKubeConfigFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AllowCacheTTL is the length of time that a successful authorization response will be cached
0000000000000000000000000000000000000000;;		AllowCacheTTL time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DenyCacheTTL is the length of time that an unsuccessful authorization response will be cached.
0000000000000000000000000000000000000000;;		// You generally want more responsive, "deny, try again" flows.
0000000000000000000000000000000000000000;;		DenyCacheTTL time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDelegatingAuthorizationOptions() *DelegatingAuthorizationOptions {
0000000000000000000000000000000000000000;;		return &DelegatingAuthorizationOptions{
0000000000000000000000000000000000000000;;			// very low for responsiveness, but high enough to handle storms
0000000000000000000000000000000000000000;;			AllowCacheTTL: 10 * time.Second,
0000000000000000000000000000000000000000;;			DenyCacheTTL:  10 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthorizationOptions) Validate() []error {
0000000000000000000000000000000000000000;;		allErrors := []error{}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthorizationOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&s.RemoteKubeConfigFile, "authorization-kubeconfig", s.RemoteKubeConfigFile, ""+
0000000000000000000000000000000000000000;;			"kubeconfig file pointing at the 'core' kubernetes server with enough rights to create "+
0000000000000000000000000000000000000000;;			" subjectaccessreviews.authorization.k8s.io.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.DurationVar(&s.AllowCacheTTL, "authorization-webhook-cache-authorized-ttl",
0000000000000000000000000000000000000000;;			s.AllowCacheTTL,
0000000000000000000000000000000000000000;;			"The duration to cache 'authorized' responses from the webhook authorizer.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.DurationVar(&s.DenyCacheTTL,
0000000000000000000000000000000000000000;;			"authorization-webhook-cache-unauthorized-ttl", s.DenyCacheTTL,
0000000000000000000000000000000000000000;;			"The duration to cache 'unauthorized' responses from the webhook authorizer.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthorizationOptions) ApplyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		cfg, err := s.ToAuthorizationConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		authorizer, err := cfg.New()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Authorizer = authorizer
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthorizationOptions) ToAuthorizationConfig() (authorizerfactory.DelegatingAuthorizerConfig, error) {
0000000000000000000000000000000000000000;;		sarClient, err := s.newSubjectAccessReview()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return authorizerfactory.DelegatingAuthorizerConfig{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := authorizerfactory.DelegatingAuthorizerConfig{
0000000000000000000000000000000000000000;;			SubjectAccessReviewClient: sarClient,
0000000000000000000000000000000000000000;;			AllowCacheTTL:             s.AllowCacheTTL,
0000000000000000000000000000000000000000;;			DenyCacheTTL:              s.DenyCacheTTL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *DelegatingAuthorizationOptions) newSubjectAccessReview() (authorizationclient.SubjectAccessReviewInterface, error) {
0000000000000000000000000000000000000000;;		var clientConfig *rest.Config
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if len(s.RemoteKubeConfigFile) > 0 {
0000000000000000000000000000000000000000;;			loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: s.RemoteKubeConfigFile}
0000000000000000000000000000000000000000;;			loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			clientConfig, err = loader.ClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// without the remote kubeconfig file, try to use the in-cluster config.  Most addon API servers will
0000000000000000000000000000000000000000;;			// use this path
0000000000000000000000000000000000000000;;			clientConfig, err = rest.InClusterConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set high qps/burst limits since this will effectively limit API server responsiveness
0000000000000000000000000000000000000000;;		clientConfig.QPS = 200
0000000000000000000000000000000000000000;;		clientConfig.Burst = 400
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := authorizationclient.NewForConfig(clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return client.SubjectAccessReviews(), nil
0000000000000000000000000000000000000000;;	}
