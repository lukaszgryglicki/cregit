0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8e5dbdd02c2eaa420abecbec0f800f9e5c8f9f8b;pkg/genericapiserver/filters/cors_test.go[pkg/genericapiserver/filters/cors_test.go][staging/src/k8s.io/apiserver/pkg/server/filters/cors_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCORSAllowedOrigins(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			allowedOrigins []string
0000000000000000000000000000000000000000;;			origin         string
0000000000000000000000000000000000000000;;			allowed        bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{[]string{}, "example.com", false},
0000000000000000000000000000000000000000;;			{[]string{"example.com"}, "example.com", true},
0000000000000000000000000000000000000000;;			{[]string{"example.com"}, "not-allowed.com", false},
0000000000000000000000000000000000000000;;			{[]string{"not-matching.com", "example.com"}, "example.com", true},
0000000000000000000000000000000000000000;;			{[]string{".*"}, "example.com", true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			handler := WithCORS(
0000000000000000000000000000000000000000;;				http.HandlerFunc(func(http.ResponseWriter, *http.Request) {}),
0000000000000000000000000000000000000000;;				item.allowedOrigins, nil, nil, nil, "true",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;			client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request, err := http.NewRequest("GET", server.URL+"/version", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			request.Header.Set("Origin", item.origin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			response, err := client.Do(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if item.allowed {
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(item.origin, response.Header.Get("Access-Control-Allow-Origin")) {
0000000000000000000000000000000000000000;;					t.Errorf("Expected %#v, Got %#v", item.origin, response.Header.Get("Access-Control-Allow-Origin"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Allow-Credentials") == "" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Access-Control-Allow-Credentials header to be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Allow-Headers") == "" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Access-Control-Allow-Headers header to be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Allow-Methods") == "" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Access-Control-Allow-Methods header to be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Expose-Headers") != "Date" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Date in Access-Control-Expose-Headers header")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Allow-Origin") != "" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Access-Control-Allow-Origin header to not be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Allow-Credentials") != "" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Access-Control-Allow-Credentials header to not be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Allow-Headers") != "" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Access-Control-Allow-Headers header to not be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Allow-Methods") != "" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Access-Control-Allow-Methods header to not be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if response.Header.Get("Access-Control-Expose-Headers") == "Date" {
0000000000000000000000000000000000000000;;					t.Errorf("Expected Date in Access-Control-Expose-Headers header")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCORSAllowedMethods(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			allowedMethods []string
0000000000000000000000000000000000000000;;			method         string
0000000000000000000000000000000000000000;;			allowed        bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{nil, "POST", true},
0000000000000000000000000000000000000000;;			{nil, "GET", true},
0000000000000000000000000000000000000000;;			{nil, "OPTIONS", true},
0000000000000000000000000000000000000000;;			{nil, "PUT", true},
0000000000000000000000000000000000000000;;			{nil, "DELETE", true},
0000000000000000000000000000000000000000;;			{nil, "PATCH", true},
0000000000000000000000000000000000000000;;			{[]string{"GET", "POST"}, "PATCH", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowsMethod := func(res *http.Response, method string) bool {
0000000000000000000000000000000000000000;;			allowedMethods := strings.Split(res.Header.Get("Access-Control-Allow-Methods"), ",")
0000000000000000000000000000000000000000;;			for _, allowedMethod := range allowedMethods {
0000000000000000000000000000000000000000;;				if strings.TrimSpace(allowedMethod) == method {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			handler := WithCORS(
0000000000000000000000000000000000000000;;				http.HandlerFunc(func(http.ResponseWriter, *http.Request) {}),
0000000000000000000000000000000000000000;;				[]string{".*"}, test.allowedMethods, nil, nil, "true",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;			defer server.Close()
0000000000000000000000000000000000000000;;			client := http.Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request, err := http.NewRequest(test.method, server.URL+"/version", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			request.Header.Set("Origin", "allowed.com")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			response, err := client.Do(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			methodAllowed := allowsMethod(response, test.method)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case test.allowed && !methodAllowed:
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v to be allowed, Got only %#v", test.method, response.Header.Get("Access-Control-Allow-Methods"))
0000000000000000000000000000000000000000;;			case !test.allowed && methodAllowed:
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected allowed method %v, Expected only %#v", test.method, response.Header.Get("Access-Control-Allow-Methods"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCompileRegex(t *testing.T) {
0000000000000000000000000000000000000000;;		uncompiledRegexes := []string{"endsWithMe$", "^startingWithMe"}
0000000000000000000000000000000000000000;;		regexes, err := compileRegexps(uncompiledRegexes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to compile legal regexes: '%v': %v", uncompiledRegexes, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(regexes) != len(uncompiledRegexes) {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong number of regexes returned: '%v': %v", uncompiledRegexes, regexes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !regexes[0].MatchString("Something that endsWithMe") {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong regex returned: '%v': %v", uncompiledRegexes[0], regexes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if regexes[0].MatchString("Something that doesn't endsWithMe.") {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong regex returned: '%v': %v", uncompiledRegexes[0], regexes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !regexes[1].MatchString("startingWithMe is very important") {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong regex returned: '%v': %v", uncompiledRegexes[1], regexes[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if regexes[1].MatchString("not startingWithMe should fail") {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong regex returned: '%v': %v", uncompiledRegexes[1], regexes[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
