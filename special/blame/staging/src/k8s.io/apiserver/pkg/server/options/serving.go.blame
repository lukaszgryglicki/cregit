0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
abf7839d6d18872eec184c84472035855fcca97d;pkg/genericapiserver/options/serving_options.go[pkg/genericapiserver/options/serving_options.go][staging/src/k8s.io/apiserver/pkg/server/options/serving.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		utilflag "k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SecureServingOptions struct {
0000000000000000000000000000000000000000;;		BindAddress net.IP
0000000000000000000000000000000000000000;;		BindPort    int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServerCert is the TLS cert info for serving secure traffic
0000000000000000000000000000000000000000;;		ServerCert GeneratableKeyCert
0000000000000000000000000000000000000000;;		// SNICertKeys are named CertKeys for serving secure traffic with SNI support.
0000000000000000000000000000000000000000;;		SNICertKeys []utilflag.NamedCertKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// when set determines whether to use loopback configuration to create shared informers.
0000000000000000000000000000000000000000;;		useLoopbackCfg bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CertKey struct {
0000000000000000000000000000000000000000;;		// CertFile is a file containing a PEM-encoded certificate, and possibly the complete certificate chain
0000000000000000000000000000000000000000;;		CertFile string
0000000000000000000000000000000000000000;;		// KeyFile is a file containing a PEM-encoded private key for the certificate specified by CertFile
0000000000000000000000000000000000000000;;		KeyFile string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GeneratableKeyCert struct {
0000000000000000000000000000000000000000;;		CertKey CertKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CACertFile is an optional file containing the certificate chain for CertKey.CertFile
0000000000000000000000000000000000000000;;		CACertFile string
0000000000000000000000000000000000000000;;		// CertDirectory is a directory that will contain the certificates.  If the cert and key aren't specifically set
0000000000000000000000000000000000000000;;		// this will be used to derive a match with the "pair-name"
0000000000000000000000000000000000000000;;		CertDirectory string
0000000000000000000000000000000000000000;;		// PairName is the name which will be used with CertDirectory to make a cert and key names
0000000000000000000000000000000000000000;;		// It becomes CertDirector/PairName.crt and CertDirector/PairName.key
0000000000000000000000000000000000000000;;		PairName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSecureServingOptions() *SecureServingOptions {
0000000000000000000000000000000000000000;;		return &SecureServingOptions{
0000000000000000000000000000000000000000;;			BindAddress: net.ParseIP("0.0.0.0"),
0000000000000000000000000000000000000000;;			BindPort:    443,
0000000000000000000000000000000000000000;;			ServerCert: GeneratableKeyCert{
0000000000000000000000000000000000000000;;				PairName:      "apiserver",
0000000000000000000000000000000000000000;;				CertDirectory: "apiserver.local.config/certificates",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) DefaultExternalAddress() (net.IP, error) {
0000000000000000000000000000000000000000;;		return utilnet.ChooseBindAddress(s.BindAddress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) Validate() []error {
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.BindPort < 0 || s.BindPort > 65535 {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("--secure-port %v must be between 0 and 65535, inclusive. 0 for turning off secure port.", s.BindPort))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.IPVar(&s.BindAddress, "bind-address", s.BindAddress, ""+
0000000000000000000000000000000000000000;;			"The IP address on which to listen for the --secure-port port. The "+
0000000000000000000000000000000000000000;;			"associated interface(s) must be reachable by the rest of the cluster, and by CLI/web "+
0000000000000000000000000000000000000000;;			"clients. If blank, all interfaces will be used (0.0.0.0).")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.IntVar(&s.BindPort, "secure-port", s.BindPort, ""+
0000000000000000000000000000000000000000;;			"The port on which to serve HTTPS with authentication and authorization. If 0, "+
0000000000000000000000000000000000000000;;			"don't serve HTTPS at all.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.ServerCert.CertDirectory, "cert-dir", s.ServerCert.CertDirectory, ""+
0000000000000000000000000000000000000000;;			"The directory where the TLS certs are located. "+
0000000000000000000000000000000000000000;;			"If --tls-cert-file and --tls-private-key-file are provided, this flag will be ignored.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.ServerCert.CertKey.CertFile, "tls-cert-file", s.ServerCert.CertKey.CertFile, ""+
0000000000000000000000000000000000000000;;			"File containing the default x509 Certificate for HTTPS. (CA cert, if any, concatenated "+
0000000000000000000000000000000000000000;;			"after server cert). If HTTPS serving is enabled, and --tls-cert-file and "+
0000000000000000000000000000000000000000;;			"--tls-private-key-file are not provided, a self-signed certificate and key "+
0000000000000000000000000000000000000000;;			"are generated for the public address and saved to /var/run/kubernetes.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.ServerCert.CertKey.KeyFile, "tls-private-key-file", s.ServerCert.CertKey.KeyFile,
0000000000000000000000000000000000000000;;			"File containing the default x509 private key matching --tls-cert-file.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.ServerCert.CACertFile, "tls-ca-file", s.ServerCert.CACertFile, "If set, this "+
0000000000000000000000000000000000000000;;			"certificate authority will used for secure access from Admission "+
0000000000000000000000000000000000000000;;			"Controllers. This must be a valid PEM-encoded CA bundle. Altneratively, the certificate authority "+
0000000000000000000000000000000000000000;;			"can be appended to the certificate provided by --tls-cert-file.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.Var(utilflag.NewNamedCertKeyArray(&s.SNICertKeys), "tls-sni-cert-key", ""+
0000000000000000000000000000000000000000;;			"A pair of x509 certificate and private key file paths, optionally suffixed with a list of "+
0000000000000000000000000000000000000000;;			"domain patterns which are fully qualified domain names, possibly with prefixed wildcard "+
0000000000000000000000000000000000000000;;			"segments. If no domain patterns are provided, the names of the certificate are "+
0000000000000000000000000000000000000000;;			"extracted. Non-wildcard matches trump over wildcard matches, explicit domain patterns "+
0000000000000000000000000000000000000000;;			"trump over extracted names. For multiple key/certificate pairs, use the "+
0000000000000000000000000000000000000000;;			"--tls-sni-cert-key multiple times. "+
0000000000000000000000000000000000000000;;			"Examples: \"example.crt,example.key\" or \"foo.crt,foo.key:*.foo.com,foo.com\".")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) AddDeprecatedFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.IPVar(&s.BindAddress, "public-address-override", s.BindAddress,
0000000000000000000000000000000000000000;;			"DEPRECATED: see --bind-address instead.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("public-address-override", "see --bind-address instead.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ApplyTo fills up serving information in the server configuration.
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) ApplyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		if s.BindPort <= 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.applyServingInfoTo(c); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create self-signed cert+key with the fake server.LoopbackClientServerNameOverride and
0000000000000000000000000000000000000000;;		// let the server return it when the loopback client connects.
0000000000000000000000000000000000000000;;		certPem, keyPem, err := certutil.GenerateSelfSignedCertKey(server.LoopbackClientServerNameOverride, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to generate self-signed certificate for loopback connection: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsCert, err := tls.X509KeyPair(certPem, keyPem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to generate self-signed certificate for loopback connection: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secureLoopbackClientConfig, err := c.SecureServingInfo.NewLoopbackClientConfig(uuid.NewRandom().String(), certPem)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// if we failed and there's no fallback loopback client config, we need to fail
0000000000000000000000000000000000000000;;		case err != nil && c.LoopbackClientConfig == nil:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we failed, but we already have a fallback loopback client config (usually insecure), allow it
0000000000000000000000000000000000000000;;		case err != nil && c.LoopbackClientConfig != nil:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			c.LoopbackClientConfig = secureLoopbackClientConfig
0000000000000000000000000000000000000000;;			c.SecureServingInfo.SNICerts[server.LoopbackClientServerNameOverride] = &tlsCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create shared informers, if not explicitly set use in cluster config.
0000000000000000000000000000000000000000;;		// do not fail on an error, this allows an external API server to startup
0000000000000000000000000000000000000000;;		// outside of a kube cluster.
0000000000000000000000000000000000000000;;		var clientCfg *rest.Config
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;		if s.useLoopbackCfg {
0000000000000000000000000000000000000000;;			clientCfg = c.LoopbackClientConfig
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			clientCfg, err = rest.InClusterConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Couldn't create in cluster config due to %v. SharedInformerFactory will not be set.", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientset, err := kubernetes.NewForConfig(clientCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Couldn't create clientset due to %v. SharedInformerFactory will not be set.", err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.SharedInformerFactory = informers.NewSharedInformerFactory(clientset, 10*time.Minute)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForceLoopbackConfigUsage forces the usage of the loopback configuration
0000000000000000000000000000000000000000;;	// to create SharedInformerFactory. The primary client of this method
0000000000000000000000000000000000000000;;	// is kube API server, no other API server is the source of truth for kube APIs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	// this method MUST be called prior to ApplyTo to take an effect.
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) ForceLoopbackConfigUsage() {
0000000000000000000000000000000000000000;;		s.useLoopbackCfg = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) applyServingInfoTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		if s.BindPort <= 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secureServingInfo := &server.SecureServingInfo{
0000000000000000000000000000000000000000;;			BindAddress: net.JoinHostPort(s.BindAddress.String(), strconv.Itoa(s.BindPort)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverCertFile, serverKeyFile := s.ServerCert.CertKey.CertFile, s.ServerCert.CertKey.KeyFile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// load main cert
0000000000000000000000000000000000000000;;		if len(serverCertFile) != 0 || len(serverKeyFile) != 0 {
0000000000000000000000000000000000000000;;			tlsCert, err := tls.LoadX509KeyPair(serverCertFile, serverKeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to load server certificate: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secureServingInfo.Cert = &tlsCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// optionally load CA cert
0000000000000000000000000000000000000000;;		if len(s.ServerCert.CACertFile) != 0 {
0000000000000000000000000000000000000000;;			pemData, err := ioutil.ReadFile(s.ServerCert.CACertFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to read certificate authority from %q: %v", s.ServerCert.CACertFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			block, pemData := pem.Decode(pemData)
0000000000000000000000000000000000000000;;			if block == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("no certificate found in certificate authority file %q", s.ServerCert.CACertFile)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if block.Type != "CERTIFICATE" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("expected CERTIFICATE block in certiticate authority file %q, found: %s", s.ServerCert.CACertFile, block.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secureServingInfo.CACert = &tls.Certificate{
0000000000000000000000000000000000000000;;				Certificate: [][]byte{block.Bytes},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// load SNI certs
0000000000000000000000000000000000000000;;		namedTLSCerts := make([]server.NamedTLSCert, 0, len(s.SNICertKeys))
0000000000000000000000000000000000000000;;		for _, nck := range s.SNICertKeys {
0000000000000000000000000000000000000000;;			tlsCert, err := tls.LoadX509KeyPair(nck.CertFile, nck.KeyFile)
0000000000000000000000000000000000000000;;			namedTLSCerts = append(namedTLSCerts, server.NamedTLSCert{
0000000000000000000000000000000000000000;;				TLSCert: tlsCert,
0000000000000000000000000000000000000000;;				Names:   nck.Names,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to load SNI cert and key: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		secureServingInfo.SNICerts, err = server.GetNamedCertificateMap(namedTLSCerts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.SecureServingInfo = secureServingInfo
0000000000000000000000000000000000000000;;		c.ReadWritePort = s.BindPort
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SecureServingOptions) MaybeDefaultWithSelfSignedCerts(publicAddress string, alternateDNS []string, alternateIPs []net.IP) error {
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyCert := &s.ServerCert.CertKey
0000000000000000000000000000000000000000;;		if s.BindPort == 0 || len(keyCert.CertFile) != 0 || len(keyCert.KeyFile) != 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyCert.CertFile = path.Join(s.ServerCert.CertDirectory, s.ServerCert.PairName+".crt")
0000000000000000000000000000000000000000;;		keyCert.KeyFile = path.Join(s.ServerCert.CertDirectory, s.ServerCert.PairName+".key")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		canReadCertAndKey, err := certutil.CanReadCertAndKey(keyCert.CertFile, keyCert.KeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !canReadCertAndKey {
0000000000000000000000000000000000000000;;			// add either the bind address or localhost to the valid alternates
0000000000000000000000000000000000000000;;			bindIP := s.BindAddress.String()
0000000000000000000000000000000000000000;;			if bindIP == "0.0.0.0" {
0000000000000000000000000000000000000000;;				alternateDNS = append(alternateDNS, "localhost")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				alternateIPs = append(alternateIPs, s.BindAddress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cert, key, err := certutil.GenerateSelfSignedCertKey(publicAddress, alternateIPs, alternateDNS); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to generate self signed cert: %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := certutil.WriteCert(keyCert.CertFile, cert); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := certutil.WriteKey(keyCert.KeyFile, key); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("Generated self-signed cert (%s, %s)", keyCert.CertFile, keyCert.KeyFile)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
