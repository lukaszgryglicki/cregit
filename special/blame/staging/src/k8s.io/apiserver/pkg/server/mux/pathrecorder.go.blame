0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d5f6ddbe9785fd36f3e4fb0345d7a924ad12898e;pkg/apiserver/mux.go[pkg/apiserver/mux.go][staging/src/k8s.io/apiserver/pkg/server/mux/pathrecorder.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathRecorderMux wraps a mux object and records the registered exposedPaths.
0000000000000000000000000000000000000000;;	type PathRecorderMux struct {
0000000000000000000000000000000000000000;;		// name is used for logging so you can trace requests through
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock            sync.Mutex
0000000000000000000000000000000000000000;;		notFoundHandler http.Handler
0000000000000000000000000000000000000000;;		pathToHandler   map[string]http.Handler
0000000000000000000000000000000000000000;;		prefixToHandler map[string]http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mux stores a pathHandler and is used to handle the actual serving.
0000000000000000000000000000000000000000;;		// Turns out, we want to accept trailing slashes, BUT we don't care about handling
0000000000000000000000000000000000000000;;		// everything under them.  This does exactly matches only unless its explicitly requested to
0000000000000000000000000000000000000000;;		// do something different
0000000000000000000000000000000000000000;;		mux atomic.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// exposedPaths is the list of paths that should be shown at /
0000000000000000000000000000000000000000;;		exposedPaths []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pathStacks holds the stacks of all registered paths.  This allows us to show a more helpful message
0000000000000000000000000000000000000000;;		// before the "http: multiple registrations for %s" panic.
0000000000000000000000000000000000000000;;		pathStacks map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pathHandler is an http.Handler that will satify requests first by exact match, then by prefix,
0000000000000000000000000000000000000000;;	// then by notFoundHandler
0000000000000000000000000000000000000000;;	type pathHandler struct {
0000000000000000000000000000000000000000;;		// muxName is used for logging so you can trace requests through
0000000000000000000000000000000000000000;;		muxName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pathToHandler is a map of exactly matching request to its handler
0000000000000000000000000000000000000000;;		pathToHandler map[string]http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this has to be sorted by most slashes then by length
0000000000000000000000000000000000000000;;		prefixHandlers []prefixHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// notFoundHandler is the handler to use for satisfying requests with no other match
0000000000000000000000000000000000000000;;		notFoundHandler http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prefixHandler holds the prefix it should match and the handler to use
0000000000000000000000000000000000000000;;	type prefixHandler struct {
0000000000000000000000000000000000000000;;		// prefix is the prefix to test for a request match
0000000000000000000000000000000000000000;;		prefix string
0000000000000000000000000000000000000000;;		// handler is used to satisfy matching requests
0000000000000000000000000000000000000000;;		handler http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPathRecorderMux creates a new PathRecorderMux
0000000000000000000000000000000000000000;;	func NewPathRecorderMux(name string) *PathRecorderMux {
0000000000000000000000000000000000000000;;		ret := &PathRecorderMux{
0000000000000000000000000000000000000000;;			name:            name,
0000000000000000000000000000000000000000;;			pathToHandler:   map[string]http.Handler{},
0000000000000000000000000000000000000000;;			prefixToHandler: map[string]http.Handler{},
0000000000000000000000000000000000000000;;			mux:             atomic.Value{},
0000000000000000000000000000000000000000;;			exposedPaths:    []string{},
0000000000000000000000000000000000000000;;			pathStacks:      map[string]string{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret.mux.Store(&pathHandler{notFoundHandler: http.NotFoundHandler()})
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListedPaths returns the registered handler exposedPaths.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) ListedPaths() []string {
0000000000000000000000000000000000000000;;		handledPaths := append([]string{}, m.exposedPaths...)
0000000000000000000000000000000000000000;;		sort.Strings(handledPaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handledPaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) trackCallers(path string) {
0000000000000000000000000000000000000000;;		if existingStack, ok := m.pathStacks[path]; ok {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("registered %q from %v", path, existingStack))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.pathStacks[path] = string(debug.Stack())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// refreshMuxLocked creates a new mux and must be called while locked.  Otherwise the view of handlers may
0000000000000000000000000000000000000000;;	// not be consistent
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) refreshMuxLocked() {
0000000000000000000000000000000000000000;;		newMux := &pathHandler{
0000000000000000000000000000000000000000;;			muxName:         m.name,
0000000000000000000000000000000000000000;;			pathToHandler:   map[string]http.Handler{},
0000000000000000000000000000000000000000;;			prefixHandlers:  []prefixHandler{},
0000000000000000000000000000000000000000;;			notFoundHandler: http.NotFoundHandler(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.notFoundHandler != nil {
0000000000000000000000000000000000000000;;			newMux.notFoundHandler = m.notFoundHandler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for path, handler := range m.pathToHandler {
0000000000000000000000000000000000000000;;			newMux.pathToHandler[path] = handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys := sets.StringKeySet(m.prefixToHandler).List()
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(byPrefixPriority(keys)))
0000000000000000000000000000000000000000;;		for _, prefix := range keys {
0000000000000000000000000000000000000000;;			newMux.prefixHandlers = append(newMux.prefixHandlers, prefixHandler{
0000000000000000000000000000000000000000;;				prefix:  prefix,
0000000000000000000000000000000000000000;;				handler: m.prefixToHandler[prefix],
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mux.Store(newMux)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotFoundHandler sets the handler to use if there's no match for a give path
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) NotFoundHandler(notFoundHandler http.Handler) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.notFoundHandler = notFoundHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.refreshMuxLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unregister removes a path from the mux.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) Unregister(path string) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(m.pathToHandler, path)
0000000000000000000000000000000000000000;;		delete(m.prefixToHandler, path)
0000000000000000000000000000000000000000;;		delete(m.pathStacks, path)
0000000000000000000000000000000000000000;;		for i := range m.exposedPaths {
0000000000000000000000000000000000000000;;			if m.exposedPaths[i] == path {
0000000000000000000000000000000000000000;;				m.exposedPaths = append(m.exposedPaths[:i], m.exposedPaths[i+1:]...)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.refreshMuxLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle registers the handler for the given pattern.
0000000000000000000000000000000000000000;;	// If a handler already exists for pattern, Handle panics.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) Handle(path string, handler http.Handler) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;		m.trackCallers(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.exposedPaths = append(m.exposedPaths, path)
0000000000000000000000000000000000000000;;		m.pathToHandler[path] = handler
0000000000000000000000000000000000000000;;		m.refreshMuxLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleFunc registers the handler function for the given pattern.
0000000000000000000000000000000000000000;;	// If a handler already exists for pattern, Handle panics.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) HandleFunc(path string, handler func(http.ResponseWriter, *http.Request)) {
0000000000000000000000000000000000000000;;		m.Handle(path, http.HandlerFunc(handler))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnlistedHandle registers the handler for the given pattern, but doesn't list it.
0000000000000000000000000000000000000000;;	// If a handler already exists for pattern, Handle panics.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) UnlistedHandle(path string, handler http.Handler) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;		m.trackCallers(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.pathToHandler[path] = handler
0000000000000000000000000000000000000000;;		m.refreshMuxLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnlistedHandleFunc registers the handler function for the given pattern, but doesn't list it.
0000000000000000000000000000000000000000;;	// If a handler already exists for pattern, Handle panics.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) UnlistedHandleFunc(path string, handler func(http.ResponseWriter, *http.Request)) {
0000000000000000000000000000000000000000;;		m.UnlistedHandle(path, http.HandlerFunc(handler))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlePrefix is like Handle, but matches for anything under the path.  Like a standard golang trailing slash.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) HandlePrefix(path string, handler http.Handler) {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(path, "/") {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("%q must end in a trailing slash", path))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;		m.trackCallers(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.exposedPaths = append(m.exposedPaths, path)
0000000000000000000000000000000000000000;;		m.prefixToHandler[path] = handler
0000000000000000000000000000000000000000;;		m.refreshMuxLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnlistedHandlePrefix is like UnlistedHandle, but matches for anything under the path.  Like a standard golang trailing slash.
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) UnlistedHandlePrefix(path string, handler http.Handler) {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(path, "/") {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("%q must end in a trailing slash", path))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;		m.trackCallers(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.prefixToHandler[path] = handler
0000000000000000000000000000000000000000;;		m.refreshMuxLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP makes it an http.Handler
0000000000000000000000000000000000000000;;	func (m *PathRecorderMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		m.mux.Load().(*pathHandler).ServeHTTP(w, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP makes it an http.Handler
0000000000000000000000000000000000000000;;	func (h *pathHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if exactHandler, ok := h.pathToHandler[r.URL.Path]; ok {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("%v: %q satisfied by exact match", h.muxName, r.URL.Path)
0000000000000000000000000000000000000000;;			exactHandler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, prefixHandler := range h.prefixHandlers {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(r.URL.Path, prefixHandler.prefix) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("%v: %q satisfied by prefix %v", h.muxName, r.URL.Path, prefixHandler.prefix)
0000000000000000000000000000000000000000;;				prefixHandler.handler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("%v: %q satisfied by NotFoundHandler", h.muxName, r.URL.Path)
0000000000000000000000000000000000000000;;		h.notFoundHandler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byPrefixPriority sorts url prefixes by the order in which they should be tested by the mux
0000000000000000000000000000000000000000;;	// this has to be sorted by most slashes then by length so that we can iterate straight
0000000000000000000000000000000000000000;;	// through to match the "best" one first.
0000000000000000000000000000000000000000;;	type byPrefixPriority []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s byPrefixPriority) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s byPrefixPriority) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s byPrefixPriority) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		lhsNumParts := strings.Count(s[i], "/")
0000000000000000000000000000000000000000;;		rhsNumParts := strings.Count(s[j], "/")
0000000000000000000000000000000000000000;;		if lhsNumParts != rhsNumParts {
0000000000000000000000000000000000000000;;			return lhsNumParts < rhsNumParts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lhsLen := len(s[i])
0000000000000000000000000000000000000000;;		rhsLen := len(s[j])
0000000000000000000000000000000000000000;;		if lhsLen != rhsLen {
0000000000000000000000000000000000000000;;			return lhsLen < rhsLen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Compare(s[i], s[j]) < 0
0000000000000000000000000000000000000000;;	}
