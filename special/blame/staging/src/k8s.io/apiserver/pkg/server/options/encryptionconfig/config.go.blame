0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
4fa123cff3ededa351298350459e08f67c006163;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package encryptionconfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml "github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value"
0000000000000000000000000000000000000000;;		aestransformer "k8s.io/apiserver/pkg/storage/value/encrypt/aes"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value/encrypt/identity"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/value/encrypt/secretbox"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		aesCBCTransformerPrefixV1    = "k8s:enc:aescbc:v1:"
0000000000000000000000000000000000000000;;		aesGCMTransformerPrefixV1    = "k8s:enc:aesgcm:v1:"
0000000000000000000000000000000000000000;;		secretboxTransformerPrefixV1 = "k8s:enc:secretbox:v1:"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTransformerOverrides returns the transformer overrides by reading and parsing the encryption provider configuration file
0000000000000000000000000000000000000000;;	func GetTransformerOverrides(filepath string) (map[schema.GroupResource]value.Transformer, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(filepath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error opening encryption provider configuration file %q: %v", filepath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err := ParseEncryptionConfiguration(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error while parsing encryption provider configuration file %q: %v", filepath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseEncryptionConfiguration parses configuration data and returns the transformer overrides
0000000000000000000000000000000000000000;;	func ParseEncryptionConfiguration(f io.Reader) (map[schema.GroupResource]value.Transformer, error) {
0000000000000000000000000000000000000000;;		configFileContents, err := ioutil.ReadAll(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not read contents: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var config EncryptionConfig
0000000000000000000000000000000000000000;;		err = yaml.Unmarshal(configFileContents, &config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error while parsing file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.Kind != "EncryptionConfig" && config.Kind != "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid configuration kind %q provided", config.Kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.Kind == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid configuration file, missing Kind")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO config.APIVersion is unchecked
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceToPrefixTransformer := map[schema.GroupResource][]value.PrefixTransformer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For each entry in the configuration
0000000000000000000000000000000000000000;;		for _, resourceConfig := range config.Resources {
0000000000000000000000000000000000000000;;			transformers, err := GetPrefixTransformers(&resourceConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// For each resource, create a list of providers to use
0000000000000000000000000000000000000000;;			for _, resource := range resourceConfig.Resources {
0000000000000000000000000000000000000000;;				gr := schema.ParseGroupResource(resource)
0000000000000000000000000000000000000000;;				resourceToPrefixTransformer[gr] = append(
0000000000000000000000000000000000000000;;					resourceToPrefixTransformer[gr], transformers...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := map[schema.GroupResource]value.Transformer{}
0000000000000000000000000000000000000000;;		for gr, transList := range resourceToPrefixTransformer {
0000000000000000000000000000000000000000;;			result[gr] = value.NewMutableTransformer(value.NewPrefixTransformers(fmt.Errorf("no matching prefix found"), transList...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPrefixTransformer constructs and returns the appropriate prefix transformers for the passed resource using its configuration
0000000000000000000000000000000000000000;;	func GetPrefixTransformers(config *ResourceConfig) ([]value.PrefixTransformer, error) {
0000000000000000000000000000000000000000;;		var result []value.PrefixTransformer
0000000000000000000000000000000000000000;;		for _, provider := range config.Providers {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var transformer value.PrefixTransformer
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if provider.AESGCM != nil {
0000000000000000000000000000000000000000;;				transformer, err = GetAESPrefixTransformer(provider.AESGCM, aestransformer.NewGCMTransformer, aesGCMTransformerPrefixV1)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return result, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if provider.AESCBC != nil {
0000000000000000000000000000000000000000;;				if found == true {
0000000000000000000000000000000000000000;;					return result, fmt.Errorf("more than one provider specified in a single element, should split into different list elements")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				transformer, err = GetAESPrefixTransformer(provider.AESCBC, aestransformer.NewCBCTransformer, aesCBCTransformerPrefixV1)
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if provider.Secretbox != nil {
0000000000000000000000000000000000000000;;				if found == true {
0000000000000000000000000000000000000000;;					return result, fmt.Errorf("more than one provider specified in a single element, should split into different list elements")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				transformer, err = GetSecretboxPrefixTransformer(provider.Secretbox)
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if provider.Identity != nil {
0000000000000000000000000000000000000000;;				if found == true {
0000000000000000000000000000000000000000;;					return result, fmt.Errorf("more than one provider specified in a single element, should split into different list elements")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				transformer = value.PrefixTransformer{
0000000000000000000000000000000000000000;;					Transformer: identity.NewEncryptCheckTransformer(),
0000000000000000000000000000000000000000;;					Prefix:      []byte{},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return result, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, transformer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if found == false {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("invalid provider configuration provided")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlockTransformerFunc taske an AES cipher block and returns a value transformer.
0000000000000000000000000000000000000000;;	type BlockTransformerFunc func(cipher.Block) value.Transformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAESPrefixTransformer returns a prefix transformer from the provided configuration.
0000000000000000000000000000000000000000;;	// Returns an AES transformer based on the provided prefix and block transformer.
0000000000000000000000000000000000000000;;	func GetAESPrefixTransformer(config *AESConfig, fn BlockTransformerFunc, prefix string) (value.PrefixTransformer, error) {
0000000000000000000000000000000000000000;;		var result value.PrefixTransformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.Keys) == 0 {
0000000000000000000000000000000000000000;;			return result, fmt.Errorf("aes provider has no valid keys")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, key := range config.Keys {
0000000000000000000000000000000000000000;;			if key.Name == "" {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("key with invalid name provided")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if key.Secret == "" {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("key %v has no provided secret", key.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyTransformers := []value.PrefixTransformer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, keyData := range config.Keys {
0000000000000000000000000000000000000000;;			key, err := base64.StdEncoding.DecodeString(keyData.Secret)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("could not obtain secret for named key %s: %s", keyData.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			block, err := aes.NewCipher(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("error while creating cipher for named key %s: %s", keyData.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a new PrefixTransformer for this key
0000000000000000000000000000000000000000;;			keyTransformers = append(keyTransformers,
0000000000000000000000000000000000000000;;				value.PrefixTransformer{
0000000000000000000000000000000000000000;;					Transformer: fn(block),
0000000000000000000000000000000000000000;;					Prefix:      []byte(keyData.Name + ":"),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a prefixTransformer which can choose between these keys
0000000000000000000000000000000000000000;;		keyTransformer := value.NewPrefixTransformers(
0000000000000000000000000000000000000000;;			fmt.Errorf("no matching key was found for the provided AES transformer"), keyTransformers...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a PrefixTransformer which shall later be put in a list with other providers
0000000000000000000000000000000000000000;;		result = value.PrefixTransformer{
0000000000000000000000000000000000000000;;			Transformer: keyTransformer,
0000000000000000000000000000000000000000;;			Prefix:      []byte(prefix),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSecretboxPrefixTransformer returns a prefix transformer from the provided configuration
0000000000000000000000000000000000000000;;	func GetSecretboxPrefixTransformer(config *SecretboxConfig) (value.PrefixTransformer, error) {
0000000000000000000000000000000000000000;;		var result value.PrefixTransformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.Keys) == 0 {
0000000000000000000000000000000000000000;;			return result, fmt.Errorf("secretbox provider has no valid keys")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, key := range config.Keys {
0000000000000000000000000000000000000000;;			if key.Name == "" {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("key with invalid name provided")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if key.Secret == "" {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("key %v has no provided secret", key.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyTransformers := []value.PrefixTransformer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, keyData := range config.Keys {
0000000000000000000000000000000000000000;;			key, err := base64.StdEncoding.DecodeString(keyData.Secret)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("could not obtain secret for named key %s: %s", keyData.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(key) != 32 {
0000000000000000000000000000000000000000;;				return result, fmt.Errorf("expected key size 32 for aes-cbc provider, got %v", len(key))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keyArray := [32]byte{}
0000000000000000000000000000000000000000;;			copy(keyArray[:], key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a new PrefixTransformer for this key
0000000000000000000000000000000000000000;;			keyTransformers = append(keyTransformers,
0000000000000000000000000000000000000000;;				value.PrefixTransformer{
0000000000000000000000000000000000000000;;					Transformer: secretbox.NewSecretboxTransformer(keyArray),
0000000000000000000000000000000000000000;;					Prefix:      []byte(keyData.Name + ":"),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a prefixTransformer which can choose between these keys
0000000000000000000000000000000000000000;;		keyTransformer := value.NewPrefixTransformers(
0000000000000000000000000000000000000000;;			fmt.Errorf("no matching key was found for the provided Secretbox transformer"), keyTransformers...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a PrefixTransformer which shall later be put in a list with other providers
0000000000000000000000000000000000000000;;		result = value.PrefixTransformer{
0000000000000000000000000000000000000000;;			Transformer: keyTransformer,
0000000000000000000000000000000000000000;;			Prefix:      []byte(secretboxTransformerPrefixV1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
