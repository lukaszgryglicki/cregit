0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c7bf7696633937349795039a4428acc197a0b7c3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/recognizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/storagebackend"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageCodecConfig are the arguments passed to newStorageCodecFn
0000000000000000000000000000000000000000;;	type StorageCodecConfig struct {
0000000000000000000000000000000000000000;;		StorageMediaType  string
0000000000000000000000000000000000000000;;		StorageSerializer runtime.StorageSerializer
0000000000000000000000000000000000000000;;		StorageVersion    schema.GroupVersion
0000000000000000000000000000000000000000;;		MemoryVersion     schema.GroupVersion
0000000000000000000000000000000000000000;;		Config            storagebackend.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EncoderDecoratorFn func(runtime.Encoder) runtime.Encoder
0000000000000000000000000000000000000000;;		DecoderDecoratorFn func([]runtime.Decoder) []runtime.Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStorageCodec assembles a storage codec for the provided storage media type, the provided serializer, and the requested
0000000000000000000000000000000000000000;;	// storage and memory versions.
0000000000000000000000000000000000000000;;	func NewStorageCodec(opts StorageCodecConfig) (runtime.Codec, error) {
0000000000000000000000000000000000000000;;		mediaType, _, err := mime.ParseMediaType(opts.StorageMediaType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%q is not a valid mime-type", opts.StorageMediaType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.Config.Type == storagebackend.StorageTypeETCD2 && mediaType != "application/json" {
0000000000000000000000000000000000000000;;			glog.Warningf(`storage type %q does not support media type %q, using "application/json"`, storagebackend.StorageTypeETCD2, mediaType)
0000000000000000000000000000000000000000;;			mediaType = "application/json"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializer, ok := runtime.SerializerInfoForMediaType(opts.StorageSerializer.SupportedMediaTypes(), mediaType)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to find serializer for %q", mediaType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := serializer.Serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure the selected encoder supports string data
0000000000000000000000000000000000000000;;		if !serializer.EncodesAsText && opts.Config.Type == storagebackend.StorageTypeETCD2 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("storage type %q does not support binary media type %q", storagebackend.StorageTypeETCD2, mediaType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Give callers the opportunity to wrap encoders and decoders.  For decoders, each returned decoder will
0000000000000000000000000000000000000000;;		// be passed to the recognizer so that multiple decoders are available.
0000000000000000000000000000000000000000;;		var encoder runtime.Encoder = s
0000000000000000000000000000000000000000;;		if opts.EncoderDecoratorFn != nil {
0000000000000000000000000000000000000000;;			encoder = opts.EncoderDecoratorFn(encoder)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoders := []runtime.Decoder{
0000000000000000000000000000000000000000;;			// selected decoder as the primary
0000000000000000000000000000000000000000;;			s,
0000000000000000000000000000000000000000;;			// universal deserializer as a fallback
0000000000000000000000000000000000000000;;			opts.StorageSerializer.UniversalDeserializer(),
0000000000000000000000000000000000000000;;			// base64-wrapped universal deserializer as a last resort.
0000000000000000000000000000000000000000;;			// this allows reading base64-encoded protobuf, which should only exist if etcd2+protobuf was used at some point.
0000000000000000000000000000000000000000;;			// data written that way could exist in etcd2, or could have been migrated to etcd3.
0000000000000000000000000000000000000000;;			// TODO: flag this type of data if we encounter it, require migration (read to decode, write to persist using a supported encoder), and remove in 1.8
0000000000000000000000000000000000000000;;			runtime.NewBase64Serializer(nil, opts.StorageSerializer.UniversalDeserializer()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.DecoderDecoratorFn != nil {
0000000000000000000000000000000000000000;;			decoders = opts.DecoderDecoratorFn(decoders)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure the storage receives the correct version.
0000000000000000000000000000000000000000;;		encoder = opts.StorageSerializer.EncoderForVersion(
0000000000000000000000000000000000000000;;			encoder,
0000000000000000000000000000000000000000;;			runtime.NewMultiGroupVersioner(
0000000000000000000000000000000000000000;;				opts.StorageVersion,
0000000000000000000000000000000000000000;;				schema.GroupKind{Group: opts.StorageVersion.Group},
0000000000000000000000000000000000000000;;				schema.GroupKind{Group: opts.MemoryVersion.Group},
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		decoder := opts.StorageSerializer.DecoderToVersion(
0000000000000000000000000000000000000000;;			recognizer.NewDecoder(decoders...),
0000000000000000000000000000000000000000;;			runtime.NewMultiGroupVersioner(
0000000000000000000000000000000000000000;;				opts.MemoryVersion,
0000000000000000000000000000000000000000;;				schema.GroupKind{Group: opts.MemoryVersion.Group},
0000000000000000000000000000000000000000;;				schema.GroupKind{Group: opts.StorageVersion.Group},
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return runtime.NewCodec(encoder, decoder), nil
0000000000000000000000000000000000000000;;	}
