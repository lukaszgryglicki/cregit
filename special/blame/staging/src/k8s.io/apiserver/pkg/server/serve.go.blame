0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c16de24a2694d84493d7b40f05ca38857d1eb1bd;pkg/genericapiserver/serve.go[pkg/genericapiserver/serve.go][staging/src/k8s.io/apiserver/pkg/server/serve.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/pkg/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultKeepAlivePeriod = 3 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveSecurely runs the secure http server. It fails only if certificates cannot
0000000000000000000000000000000000000000;;	// be loaded or the initial listen call fails. The actual server loop (stoppable by closing
0000000000000000000000000000000000000000;;	// stopCh) runs in a go routine, i.e. serveSecurely does not block.
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) serveSecurely(stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		secureServer := &http.Server{
0000000000000000000000000000000000000000;;			Addr:           s.SecureServingInfo.BindAddress,
0000000000000000000000000000000000000000;;			Handler:        s.Handler,
0000000000000000000000000000000000000000;;			MaxHeaderBytes: 1 << 20,
0000000000000000000000000000000000000000;;			TLSConfig: &tls.Config{
0000000000000000000000000000000000000000;;				NameToCertificate: s.SecureServingInfo.SNICerts,
0000000000000000000000000000000000000000;;				// Can't use SSLv3 because of POODLE and BEAST
0000000000000000000000000000000000000000;;				// Can't use TLSv1.0 because of POODLE and BEAST using CBC cipher
0000000000000000000000000000000000000000;;				// Can't use TLSv1.1 because of RC4 cipher usage
0000000000000000000000000000000000000000;;				MinVersion: tls.VersionTLS12,
0000000000000000000000000000000000000000;;				// enable HTTP2 for go's 1.7 HTTP Server
0000000000000000000000000000000000000000;;				NextProtos: []string{"h2", "http/1.1"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.SecureServingInfo.MinTLSVersion > 0 {
0000000000000000000000000000000000000000;;			secureServer.TLSConfig.MinVersion = s.SecureServingInfo.MinTLSVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.SecureServingInfo.CipherSuites) > 0 {
0000000000000000000000000000000000000000;;			secureServer.TLSConfig.CipherSuites = s.SecureServingInfo.CipherSuites
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.SecureServingInfo.Cert != nil {
0000000000000000000000000000000000000000;;			secureServer.TLSConfig.Certificates = []tls.Certificate{*s.SecureServingInfo.Cert}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// append all named certs. Otherwise, the go tls stack will think no SNI processing
0000000000000000000000000000000000000000;;		// is necessary because there is only one cert anyway.
0000000000000000000000000000000000000000;;		// Moreover, if ServerCert.CertFile/ServerCert.KeyFile are not set, the first SNI
0000000000000000000000000000000000000000;;		// cert will become the default cert. That's what we expect anyway.
0000000000000000000000000000000000000000;;		for _, c := range s.SecureServingInfo.SNICerts {
0000000000000000000000000000000000000000;;			secureServer.TLSConfig.Certificates = append(secureServer.TLSConfig.Certificates, *c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.SecureServingInfo.ClientCA != nil {
0000000000000000000000000000000000000000;;			// Populate PeerCertificates in requests, but don't reject connections without certificates
0000000000000000000000000000000000000000;;			// This allows certificates to be validated by authenticators, while still allowing other auth types
0000000000000000000000000000000000000000;;			secureServer.TLSConfig.ClientAuth = tls.RequestClientCert
0000000000000000000000000000000000000000;;			// Specify allowed CAs for client certificates
0000000000000000000000000000000000000000;;			secureServer.TLSConfig.ClientCAs = s.SecureServingInfo.ClientCA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Serving securely on %s", s.SecureServingInfo.BindAddress)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		s.effectiveSecurePort, err = RunServer(secureServer, s.SecureServingInfo.BindNetwork, stopCh)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunServer listens on the given port, then spawns a go-routine continuously serving
0000000000000000000000000000000000000000;;	// until the stopCh is closed. The port is returned. This function does not block.
0000000000000000000000000000000000000000;;	func RunServer(server *http.Server, network string, stopCh <-chan struct{}) (int, error) {
0000000000000000000000000000000000000000;;		if len(server.Addr) == 0 {
0000000000000000000000000000000000000000;;			return 0, errors.New("address cannot be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(network) == 0 {
0000000000000000000000000000000000000000;;			network = "tcp"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ln, err := net.Listen(network, server.Addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to listen on %v: %v", server.Addr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get port
0000000000000000000000000000000000000000;;		tcpAddr, ok := ln.Addr().(*net.TCPAddr)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			ln.Close()
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid listen address: %q", ln.Addr().String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop the server by closing the listener
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-stopCh
0000000000000000000000000000000000000000;;			ln.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var listener net.Listener
0000000000000000000000000000000000000000;;			listener = tcpKeepAliveListener{ln.(*net.TCPListener)}
0000000000000000000000000000000000000000;;			if server.TLSConfig != nil {
0000000000000000000000000000000000000000;;				listener = tls.NewListener(listener, server.TLSConfig)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := server.Serve(listener)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Stopped listening on %s", tcpAddr.String())
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				glog.Info(msg)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("%s due to error: %v", msg, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tcpAddr.Port, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamedTLSCert struct {
0000000000000000000000000000000000000000;;		TLSCert tls.Certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// names is a list of domain patterns: fully qualified domain names, possibly prefixed with
0000000000000000000000000000000000000000;;		// wildcard segments.
0000000000000000000000000000000000000000;;		Names []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNamedCertificateMap returns a map of *tls.Certificate by name. It's is
0000000000000000000000000000000000000000;;	// suitable for use in tls.Config#NamedCertificates. Returns an error if any of the certs
0000000000000000000000000000000000000000;;	// cannot be loaded. Returns nil if len(certs) == 0
0000000000000000000000000000000000000000;;	func GetNamedCertificateMap(certs []NamedTLSCert) (map[string]*tls.Certificate, error) {
0000000000000000000000000000000000000000;;		// register certs with implicit names first, reverse order such that earlier trump over the later
0000000000000000000000000000000000000000;;		byName := map[string]*tls.Certificate{}
0000000000000000000000000000000000000000;;		for i := len(certs) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if len(certs[i].Names) > 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cert := &certs[i].TLSCert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// read names from certificate common names and DNS names
0000000000000000000000000000000000000000;;			if len(cert.Certificate) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("empty SNI certificate, skipping")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x509Cert, err := x509.ParseCertificate(cert.Certificate[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("parse error for SNI certificate: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cn := x509Cert.Subject.CommonName
0000000000000000000000000000000000000000;;			if cn == "*" || len(validation.IsDNS1123Subdomain(strings.TrimPrefix(cn, "*."))) == 0 {
0000000000000000000000000000000000000000;;				byName[cn] = cert
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, san := range x509Cert.DNSNames {
0000000000000000000000000000000000000000;;				byName[san] = cert
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// intentionally all IPs in the cert are ignored as SNI forbids passing IPs
0000000000000000000000000000000000000000;;			// to select a cert. Before go 1.6 the tls happily passed IPs as SNI values.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// register certs with explicit names last, overwriting every of the implicit ones,
0000000000000000000000000000000000000000;;		// again in reverse order.
0000000000000000000000000000000000000000;;		for i := len(certs) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			namedCert := &certs[i]
0000000000000000000000000000000000000000;;			for _, name := range namedCert.Names {
0000000000000000000000000000000000000000;;				byName[name] = &certs[i].TLSCert
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return byName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted
0000000000000000000000000000000000000000;;	// connections. It's used by ListenAndServe and ListenAndServeTLS so
0000000000000000000000000000000000000000;;	// dead TCP connections (e.g. closing laptop mid-download) eventually
0000000000000000000000000000000000000000;;	// go away.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copied from Go 1.7.2 net/http/server.go
0000000000000000000000000000000000000000;;	type tcpKeepAliveListener struct {
0000000000000000000000000000000000000000;;		*net.TCPListener
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ln tcpKeepAliveListener) Accept() (net.Conn, error) {
0000000000000000000000000000000000000000;;		tc, err := ln.AcceptTCP()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.SetKeepAlive(true)
0000000000000000000000000000000000000000;;		tc.SetKeepAlivePeriod(defaultKeepAlivePeriod)
0000000000000000000000000000000000000000;;		return tc, nil
0000000000000000000000000000000000000000;;	}
