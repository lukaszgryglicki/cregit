0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
191bdee193a42667782373f025f6ecad9b9e6f78;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/trie"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DEFINITION_PREFIX = "#/definitions/"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cloner = conversion.NewCloner()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run a walkRefCallback method on all references of an OpenAPI spec
0000000000000000000000000000000000000000;;	type walkAllRefs struct {
0000000000000000000000000000000000000000;;		// walkRefCallback will be called on each reference and the return value
0000000000000000000000000000000000000000;;		// will replace that reference. This will allow the callers to change
0000000000000000000000000000000000000000;;		// all/some references of an spec (e.g. useful in renaming definitions).
0000000000000000000000000000000000000000;;		walkRefCallback func(ref spec.Ref) spec.Ref
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The spec to walk through.
0000000000000000000000000000000000000000;;		root *spec.Swagger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWalkAllRefs(walkRef func(ref spec.Ref) spec.Ref, sp *spec.Swagger) *walkAllRefs {
0000000000000000000000000000000000000000;;		return &walkAllRefs{
0000000000000000000000000000000000000000;;			walkRefCallback: walkRef,
0000000000000000000000000000000000000000;;			root:            sp,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *walkAllRefs) walkRef(ref spec.Ref) spec.Ref {
0000000000000000000000000000000000000000;;		if ref.String() != "" {
0000000000000000000000000000000000000000;;			refStr := ref.String()
0000000000000000000000000000000000000000;;			// References that start with #/definitions/ has a definition
0000000000000000000000000000000000000000;;			// inside the same spec file. If that is the case, walk through
0000000000000000000000000000000000000000;;			// those definitions too.
0000000000000000000000000000000000000000;;			// We do not support external references yet.
0000000000000000000000000000000000000000;;			if strings.HasPrefix(refStr, DEFINITION_PREFIX) {
0000000000000000000000000000000000000000;;				def := s.root.Definitions[refStr[len(DEFINITION_PREFIX):]]
0000000000000000000000000000000000000000;;				s.walkSchema(&def)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.walkRefCallback(ref)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *walkAllRefs) walkSchema(schema *spec.Schema) {
0000000000000000000000000000000000000000;;		if schema == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schema.Ref = s.walkRef(schema.Ref)
0000000000000000000000000000000000000000;;		for _, v := range schema.Definitions {
0000000000000000000000000000000000000000;;			s.walkSchema(&v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range schema.Properties {
0000000000000000000000000000000000000000;;			s.walkSchema(&v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range schema.PatternProperties {
0000000000000000000000000000000000000000;;			s.walkSchema(&v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range schema.AllOf {
0000000000000000000000000000000000000000;;			s.walkSchema(&v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range schema.AnyOf {
0000000000000000000000000000000000000000;;			s.walkSchema(&v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range schema.OneOf {
0000000000000000000000000000000000000000;;			s.walkSchema(&v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.Not != nil {
0000000000000000000000000000000000000000;;			s.walkSchema(schema.Not)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.AdditionalProperties != nil && schema.AdditionalProperties.Schema != nil {
0000000000000000000000000000000000000000;;			s.walkSchema(schema.AdditionalProperties.Schema)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.AdditionalItems != nil && schema.AdditionalItems.Schema != nil {
0000000000000000000000000000000000000000;;			s.walkSchema(schema.AdditionalItems.Schema)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.Items != nil {
0000000000000000000000000000000000000000;;			if schema.Items.Schema != nil {
0000000000000000000000000000000000000000;;				s.walkSchema(schema.Items.Schema)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range schema.Items.Schemas {
0000000000000000000000000000000000000000;;				s.walkSchema(&v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *walkAllRefs) walkParams(params []spec.Parameter) {
0000000000000000000000000000000000000000;;		if params == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, param := range params {
0000000000000000000000000000000000000000;;			param.Ref = s.walkRef(param.Ref)
0000000000000000000000000000000000000000;;			s.walkSchema(param.Schema)
0000000000000000000000000000000000000000;;			if param.Items != nil {
0000000000000000000000000000000000000000;;				param.Items.Ref = s.walkRef(param.Items.Ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *walkAllRefs) walkResponse(resp *spec.Response) {
0000000000000000000000000000000000000000;;		if resp == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Ref = s.walkRef(resp.Ref)
0000000000000000000000000000000000000000;;		s.walkSchema(resp.Schema)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *walkAllRefs) walkOperation(op *spec.Operation) {
0000000000000000000000000000000000000000;;		if op == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.walkParams(op.Parameters)
0000000000000000000000000000000000000000;;		if op.Responses == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.walkResponse(op.Responses.Default)
0000000000000000000000000000000000000000;;		for _, r := range op.Responses.StatusCodeResponses {
0000000000000000000000000000000000000000;;			s.walkResponse(&r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *walkAllRefs) Start() {
0000000000000000000000000000000000000000;;		for _, pathItem := range s.root.Paths.Paths {
0000000000000000000000000000000000000000;;			s.walkParams(pathItem.Parameters)
0000000000000000000000000000000000000000;;			s.walkOperation(pathItem.Delete)
0000000000000000000000000000000000000000;;			s.walkOperation(pathItem.Get)
0000000000000000000000000000000000000000;;			s.walkOperation(pathItem.Head)
0000000000000000000000000000000000000000;;			s.walkOperation(pathItem.Options)
0000000000000000000000000000000000000000;;			s.walkOperation(pathItem.Patch)
0000000000000000000000000000000000000000;;			s.walkOperation(pathItem.Post)
0000000000000000000000000000000000000000;;			s.walkOperation(pathItem.Put)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterSpecByPaths remove unnecessary paths and unused definitions.
0000000000000000000000000000000000000000;;	func FilterSpecByPaths(sp *spec.Swagger, keepPathPrefixes []string) {
0000000000000000000000000000000000000000;;		// First remove unwanted paths
0000000000000000000000000000000000000000;;		prefixes := trie.New(keepPathPrefixes)
0000000000000000000000000000000000000000;;		orgPaths := sp.Paths
0000000000000000000000000000000000000000;;		if orgPaths == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sp.Paths = &spec.Paths{
0000000000000000000000000000000000000000;;			VendorExtensible: orgPaths.VendorExtensible,
0000000000000000000000000000000000000000;;			Paths:            map[string]spec.PathItem{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for path, pathItem := range orgPaths.Paths {
0000000000000000000000000000000000000000;;			if !prefixes.HasPrefix(path) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sp.Paths.Paths[path] = pathItem
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Walk all references to find all definition references.
0000000000000000000000000000000000000000;;		usedDefinitions := map[string]bool{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newWalkAllRefs(func(ref spec.Ref) spec.Ref {
0000000000000000000000000000000000000000;;			if ref.String() != "" {
0000000000000000000000000000000000000000;;				refStr := ref.String()
0000000000000000000000000000000000000000;;				if strings.HasPrefix(refStr, DEFINITION_PREFIX) {
0000000000000000000000000000000000000000;;					usedDefinitions[refStr[len(DEFINITION_PREFIX):]] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ref
0000000000000000000000000000000000000000;;		}, sp).Start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove unused definitions
0000000000000000000000000000000000000000;;		orgDefinitions := sp.Definitions
0000000000000000000000000000000000000000;;		sp.Definitions = spec.Definitions{}
0000000000000000000000000000000000000000;;		for k, v := range orgDefinitions {
0000000000000000000000000000000000000000;;			if usedDefinitions[k] {
0000000000000000000000000000000000000000;;				sp.Definitions[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalSchemaMap(s1, s2 map[string]spec.Schema) bool {
0000000000000000000000000000000000000000;;		if len(s1) != len(s2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range s1 {
0000000000000000000000000000000000000000;;			v2, found := s2[k]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !EqualSchema(&v, &v2) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalSchemaArray(s1, s2 []spec.Schema) bool {
0000000000000000000000000000000000000000;;		if s1 == nil || s2 == nil {
0000000000000000000000000000000000000000;;			return s1 == nil && s2 == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s1) != len(s2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v1 := range s1 {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, v2 := range s2 {
0000000000000000000000000000000000000000;;				if EqualSchema(&v1, &v2) {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v2 := range s2 {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, v1 := range s1 {
0000000000000000000000000000000000000000;;				if EqualSchema(&v1, &v2) {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalSchemaOrBool(s1, s2 *spec.SchemaOrBool) bool {
0000000000000000000000000000000000000000;;		if s1 == nil || s2 == nil {
0000000000000000000000000000000000000000;;			return s1 == s2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.Allows != s2.Allows {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !EqualSchema(s1.Schema, s2.Schema) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalSchemaOrArray(s1, s2 *spec.SchemaOrArray) bool {
0000000000000000000000000000000000000000;;		if s1 == nil || s2 == nil {
0000000000000000000000000000000000000000;;			return s1 == s2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !EqualSchema(s1.Schema, s2.Schema) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaArray(s1.Schemas, s2.Schemas) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalStringArray(s1, s2 []string) bool {
0000000000000000000000000000000000000000;;		if len(s1) != len(s2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v1 := range s1 {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, v2 := range s2 {
0000000000000000000000000000000000000000;;				if v1 == v2 {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v2 := range s2 {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, v1 := range s1 {
0000000000000000000000000000000000000000;;				if v1 == v2 {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalFloatPointer(s1, s2 *float64) bool {
0000000000000000000000000000000000000000;;		if s1 == nil || s2 == nil {
0000000000000000000000000000000000000000;;			return s1 == s2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *s1 == *s2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalIntPointer(s1, s2 *int64) bool {
0000000000000000000000000000000000000000;;		if s1 == nil || s2 == nil {
0000000000000000000000000000000000000000;;			return s1 == s2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *s1 == *s2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EqualSchema returns true if models have the same properties and references
0000000000000000000000000000000000000000;;	// even if they have different documentation.
0000000000000000000000000000000000000000;;	func EqualSchema(s1, s2 *spec.Schema) bool {
0000000000000000000000000000000000000000;;		if s1 == nil || s2 == nil {
0000000000000000000000000000000000000000;;			return s1 == s2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.Ref.String() != s2.Ref.String() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaMap(s1.Definitions, s2.Definitions) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaMap(s1.Properties, s2.Properties) {
0000000000000000000000000000000000000000;;			fmt.Println("Not equal props")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaMap(s1.PatternProperties, s2.PatternProperties) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaArray(s1.AllOf, s2.AllOf) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaArray(s1.AnyOf, s2.AnyOf) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaArray(s1.OneOf, s2.OneOf) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !EqualSchema(s1.Not, s2.Not) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaOrBool(s1.AdditionalProperties, s2.AdditionalProperties) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaOrBool(s1.AdditionalItems, s2.AdditionalItems) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalSchemaOrArray(s1.Items, s2.Items) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalStringArray(s1.Type, s2.Type) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.Format != s2.Format {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalFloatPointer(s1.Minimum, s2.Minimum) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalFloatPointer(s1.Maximum, s2.Maximum) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.ExclusiveMaximum != s2.ExclusiveMaximum {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.ExclusiveMinimum != s2.ExclusiveMinimum {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalFloatPointer(s1.MultipleOf, s2.MultipleOf) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalIntPointer(s1.MaxLength, s2.MaxLength) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalIntPointer(s1.MinLength, s2.MinLength) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalIntPointer(s1.MaxItems, s2.MaxItems) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalIntPointer(s1.MinItems, s2.MinItems) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.Pattern != s2.Pattern {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.UniqueItems != s2.UniqueItems {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalIntPointer(s1.MaxProperties, s2.MaxProperties) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalIntPointer(s1.MinProperties, s2.MinProperties) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalStringArray(s1.Required, s2.Required) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(s1.Enum) == 0 && len(s2.Enum) == 0 && len(s1.Dependencies) == 0 && len(s2.Dependencies) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func renameDefinition(s *spec.Swagger, old, new string) {
0000000000000000000000000000000000000000;;		old_ref := DEFINITION_PREFIX + old
0000000000000000000000000000000000000000;;		new_ref := DEFINITION_PREFIX + new
0000000000000000000000000000000000000000;;		newWalkAllRefs(func(ref spec.Ref) spec.Ref {
0000000000000000000000000000000000000000;;			if ref.String() == old_ref {
0000000000000000000000000000000000000000;;				return spec.MustCreateRef(new_ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ref
0000000000000000000000000000000000000000;;		}, s).Start()
0000000000000000000000000000000000000000;;		s.Definitions[new] = s.Definitions[old]
0000000000000000000000000000000000000000;;		delete(s.Definitions, old)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy paths and definitions from source to dest, rename definitions if needed.
0000000000000000000000000000000000000000;;	// dest will be mutated, and source will not be changed.
0000000000000000000000000000000000000000;;	func MergeSpecs(dest, source *spec.Swagger) error {
0000000000000000000000000000000000000000;;		source, err := CloneSpec(source)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range source.Paths.Paths {
0000000000000000000000000000000000000000;;			if _, found := dest.Paths.Paths[k]; found {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to merge: Duplicated path %s", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dest.Paths.Paths[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usedNames := map[string]bool{}
0000000000000000000000000000000000000000;;		for k := range dest.Definitions {
0000000000000000000000000000000000000000;;			usedNames[k] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type Rename struct {
0000000000000000000000000000000000000000;;			from, to string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		renames := []Rename{}
0000000000000000000000000000000000000000;;		for k, v := range source.Definitions {
0000000000000000000000000000000000000000;;			v2, found := dest.Definitions[k]
0000000000000000000000000000000000000000;;			if found || usedNames[k] {
0000000000000000000000000000000000000000;;				if found && EqualSchema(&v, &v2) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i := 2
0000000000000000000000000000000000000000;;				newName := fmt.Sprintf("%s_v%d", k, i)
0000000000000000000000000000000000000000;;				for usedNames[newName] {
0000000000000000000000000000000000000000;;					i += 1
0000000000000000000000000000000000000000;;					newName = fmt.Sprintf("%s_v%d", k, i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				renames = append(renames, Rename{from: k, to: newName})
0000000000000000000000000000000000000000;;				usedNames[newName] = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				usedNames[k] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range renames {
0000000000000000000000000000000000000000;;			renameDefinition(source, r.from, r.to)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range source.Definitions {
0000000000000000000000000000000000000000;;			if _, found := dest.Definitions[k]; !found {
0000000000000000000000000000000000000000;;				dest.Definitions[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clone OpenAPI spec
0000000000000000000000000000000000000000;;	func CloneSpec(source *spec.Swagger) (*spec.Swagger, error) {
0000000000000000000000000000000000000000;;		if ret, err := cloner.DeepCopy(source); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ret.(*spec.Swagger), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
