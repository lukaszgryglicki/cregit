0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8e5dbdd02c2eaa420abecbec0f800f9e5c8f9f8b;pkg/genericapiserver/filters/maxinflight_test.go[pkg/genericapiserver/filters/maxinflight_test.go][staging/src/k8s.io/apiserver/pkg/server/filters/maxinflight_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		apifilters "k8s.io/apiserver/pkg/endpoints/filters"
0000000000000000000000000000000000000000;;		apirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createMaxInflightServer(callsWg, blockWg *sync.WaitGroup, disableCallsWg *bool, disableCallsWgMutex *sync.Mutex, nonMutating, mutating int) *httptest.Server {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		longRunningRequestCheck := BasicLongRunningRequestCheck(sets.NewString("watch"), sets.NewString("proxy"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestContextMapper := apirequest.NewRequestContextMapper()
0000000000000000000000000000000000000000;;		requestInfoFactory := &apirequest.RequestInfoFactory{APIPrefixes: sets.NewString("apis", "api"), GrouplessAPIPrefixes: sets.NewString("api")}
0000000000000000000000000000000000000000;;		handler := WithMaxInFlightLimit(
0000000000000000000000000000000000000000;;			http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				// A short, accounted request that does not wait for block WaitGroup.
0000000000000000000000000000000000000000;;				if strings.Contains(r.URL.Path, "dontwait") {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				disableCallsWgMutex.Lock()
0000000000000000000000000000000000000000;;				waitForCalls := *disableCallsWg
0000000000000000000000000000000000000000;;				disableCallsWgMutex.Unlock()
0000000000000000000000000000000000000000;;				if waitForCalls {
0000000000000000000000000000000000000000;;					callsWg.Done()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				blockWg.Wait()
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			nonMutating,
0000000000000000000000000000000000000000;;			mutating,
0000000000000000000000000000000000000000;;			requestContextMapper,
0000000000000000000000000000000000000000;;			longRunningRequestCheck,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		handler = apifilters.WithRequestInfo(handler, requestInfoFactory, requestContextMapper)
0000000000000000000000000000000000000000;;		handler = apirequest.WithRequestContext(handler, requestContextMapper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return httptest.NewServer(handler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests that MaxInFlightLimit works, i.e.
0000000000000000000000000000000000000000;;	// - "long" requests such as proxy or watch, identified by regexp are not accounted despite
0000000000000000000000000000000000000000;;	//   hanging for the long time,
0000000000000000000000000000000000000000;;	// - "short" requests are correctly accounted, i.e. there can be only size of channel passed to the
0000000000000000000000000000000000000000;;	//   constructor in flight at any given moment,
0000000000000000000000000000000000000000;;	// - subsequent "short" requests are rejected instantly with appropriate error,
0000000000000000000000000000000000000000;;	// - subsequent "long" requests are handled normally,
0000000000000000000000000000000000000000;;	// - we correctly recover after some "short" requests finish, i.e. we can process new ones.
0000000000000000000000000000000000000000;;	func TestMaxInFlightNonMutating(t *testing.T) {
0000000000000000000000000000000000000000;;		const AllowedNonMutatingInflightRequestsNo = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Calls is used to wait until all server calls are received. We are sending
0000000000000000000000000000000000000000;;		// AllowedNonMutatingInflightRequestsNo of 'long' not-accounted requests and the same number of
0000000000000000000000000000000000000000;;		// 'short' accounted ones.
0000000000000000000000000000000000000000;;		calls := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		calls.Add(AllowedNonMutatingInflightRequestsNo * 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Responses is used to wait until all responses are
0000000000000000000000000000000000000000;;		// received. This prevents some async requests getting EOF
0000000000000000000000000000000000000000;;		// errors from prematurely closing the server
0000000000000000000000000000000000000000;;		responses := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		responses.Add(AllowedNonMutatingInflightRequestsNo * 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Block is used to keep requests in flight for as long as we need to. All requests will
0000000000000000000000000000000000000000;;		// be unblocked at the same time.
0000000000000000000000000000000000000000;;		block := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		block.Add(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForCalls := true
0000000000000000000000000000000000000000;;		waitForCallsMutex := sync.Mutex{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := createMaxInflightServer(calls, block, &waitForCalls, &waitForCallsMutex, AllowedNonMutatingInflightRequestsNo, 1)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These should hang, but not affect accounting.  use a query param match
0000000000000000000000000000000000000000;;		for i := 0; i < AllowedNonMutatingInflightRequestsNo; i++ {
0000000000000000000000000000000000000000;;			// These should hang waiting on block...
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				if err := expectHTTPGet(server.URL+"/api/v1/namespaces/default/wait?watch=true", http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;					t.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				responses.Done()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that sever is not saturated by not-accounted calls
0000000000000000000000000000000000000000;;		if err := expectHTTPGet(server.URL+"/dontwait", http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These should hang and be accounted, i.e. saturate the server
0000000000000000000000000000000000000000;;		for i := 0; i < AllowedNonMutatingInflightRequestsNo; i++ {
0000000000000000000000000000000000000000;;			// These should hang waiting on block...
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				if err := expectHTTPGet(server.URL, http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;					t.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				responses.Done()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We wait for all calls to be received by the server
0000000000000000000000000000000000000000;;		calls.Wait()
0000000000000000000000000000000000000000;;		// Disable calls notifications in the server
0000000000000000000000000000000000000000;;		waitForCallsMutex.Lock()
0000000000000000000000000000000000000000;;		waitForCalls = false
0000000000000000000000000000000000000000;;		waitForCallsMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do this multiple times to show that rate limit rejected requests don't block.
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			if err := expectHTTPGet(server.URL, errors.StatusTooManyRequests); err != nil {
0000000000000000000000000000000000000000;;				t.Error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Validate that non-accounted URLs still work.  use a path regex match
0000000000000000000000000000000000000000;;		if err := expectHTTPGet(server.URL+"/api/v1/watch/namespaces/default/dontwait", http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We should allow a single mutating request.
0000000000000000000000000000000000000000;;		if err := expectHTTPPost(server.URL+"/dontwait", http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let all hanging requests finish
0000000000000000000000000000000000000000;;		block.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Show that we recover from being blocked up.
0000000000000000000000000000000000000000;;		// Too avoid flakyness we need to wait until at least one of the requests really finishes.
0000000000000000000000000000000000000000;;		responses.Wait()
0000000000000000000000000000000000000000;;		if err := expectHTTPGet(server.URL, http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMaxInFlightMutating(t *testing.T) {
0000000000000000000000000000000000000000;;		const AllowedMutatingInflightRequestsNo = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		calls := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		calls.Add(AllowedMutatingInflightRequestsNo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		responses := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		responses.Add(AllowedMutatingInflightRequestsNo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Block is used to keep requests in flight for as long as we need to. All requests will
0000000000000000000000000000000000000000;;		// be unblocked at the same time.
0000000000000000000000000000000000000000;;		block := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		block.Add(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitForCalls := true
0000000000000000000000000000000000000000;;		waitForCallsMutex := sync.Mutex{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := createMaxInflightServer(calls, block, &waitForCalls, &waitForCallsMutex, 1, AllowedMutatingInflightRequestsNo)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These should hang and be accounted, i.e. saturate the server
0000000000000000000000000000000000000000;;		for i := 0; i < AllowedMutatingInflightRequestsNo; i++ {
0000000000000000000000000000000000000000;;			// These should hang waiting on block...
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				if err := expectHTTPPost(server.URL+"/foo/bar", http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;					t.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				responses.Done()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We wait for all calls to be received by the server
0000000000000000000000000000000000000000;;		calls.Wait()
0000000000000000000000000000000000000000;;		// Disable calls notifications in the server
0000000000000000000000000000000000000000;;		// Disable calls notifications in the server
0000000000000000000000000000000000000000;;		waitForCallsMutex.Lock()
0000000000000000000000000000000000000000;;		waitForCalls = false
0000000000000000000000000000000000000000;;		waitForCallsMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do this multiple times to show that rate limit rejected requests don't block.
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			if err := expectHTTPPost(server.URL+"/foo/bar/", errors.StatusTooManyRequests); err != nil {
0000000000000000000000000000000000000000;;				t.Error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Validate that non-mutating URLs still work.  use a path regex match
0000000000000000000000000000000000000000;;		if err := expectHTTPGet(server.URL+"/dontwait", http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let all hanging requests finish
0000000000000000000000000000000000000000;;		block.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Show that we recover from being blocked up.
0000000000000000000000000000000000000000;;		// Too avoid flakyness we need to wait until at least one of the requests really finishes.
0000000000000000000000000000000000000000;;		responses.Wait()
0000000000000000000000000000000000000000;;		if err := expectHTTPPost(server.URL+"/foo/bar", http.StatusOK); err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We use GET as a sample non-mutating request.
0000000000000000000000000000000000000000;;	func expectHTTPGet(url string, code int) error {
0000000000000000000000000000000000000000;;		r, err := http.Get(url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.StatusCode != code {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected response: %v", r.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We use POST as a sample mutating request.
0000000000000000000000000000000000000000;;	func expectHTTPPost(url string, code int) error {
0000000000000000000000000000000000000000;;		r, err := http.Post(url, "text/html", strings.NewReader("foo bar"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.StatusCode != code {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected response: %v", r.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
