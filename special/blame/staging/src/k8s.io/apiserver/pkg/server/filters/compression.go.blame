0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
27962518eaf04bb3898519189a335b68adf6da5a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"compress/zlib"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compressor is an interface to compression writers
0000000000000000000000000000000000000000;;	type Compressor interface {
0000000000000000000000000000000000000000;;		io.WriteCloser
0000000000000000000000000000000000000000;;		Flush() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		headerAcceptEncoding  = "Accept-Encoding"
0000000000000000000000000000000000000000;;		headerContentEncoding = "Content-Encoding"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encodingGzip    = "gzip"
0000000000000000000000000000000000000000;;		encodingDeflate = "deflate"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithCompression wraps an http.Handler with the Compression Handler
0000000000000000000000000000000000000000;;	func WithCompression(handler http.Handler, ctxMapper request.RequestContextMapper) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			wantsCompression, encoding := wantsCompressedResponse(req, ctxMapper)
0000000000000000000000000000000000000000;;			w.Header().Set("Vary", "Accept-Encoding")
0000000000000000000000000000000000000000;;			if wantsCompression {
0000000000000000000000000000000000000000;;				compressionWriter, err := NewCompressionResponseWriter(w, encoding)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					handleError(w, req, err)
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("failed to compress HTTP response: %v", err))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				compressionWriter.Header().Set("Content-Encoding", encoding)
0000000000000000000000000000000000000000;;				handler.ServeHTTP(compressionWriter, req)
0000000000000000000000000000000000000000;;				compressionWriter.(*compressionResponseWriter).Close()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wantsCompressedResponse reads the Accept-Encoding header to see if and which encoding is requested.
0000000000000000000000000000000000000000;;	func wantsCompressedResponse(req *http.Request, ctxMapper request.RequestContextMapper) (bool, string) {
0000000000000000000000000000000000000000;;		// don't compress watches
0000000000000000000000000000000000000000;;		ctx, ok := ctxMapper.Get(req)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, ok := request.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !info.IsResourceRequest {
0000000000000000000000000000000000000000;;			return false, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Verb == "watch" {
0000000000000000000000000000000000000000;;			return false, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		header := req.Header.Get(headerAcceptEncoding)
0000000000000000000000000000000000000000;;		gi := strings.Index(header, encodingGzip)
0000000000000000000000000000000000000000;;		zi := strings.Index(header, encodingDeflate)
0000000000000000000000000000000000000000;;		// use in order of appearance
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case gi == -1:
0000000000000000000000000000000000000000;;			return zi != -1, encodingDeflate
0000000000000000000000000000000000000000;;		case zi == -1:
0000000000000000000000000000000000000000;;			return gi != -1, encodingGzip
0000000000000000000000000000000000000000;;		case gi < zi:
0000000000000000000000000000000000000000;;			return true, encodingGzip
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return true, encodingDeflate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type compressionResponseWriter struct {
0000000000000000000000000000000000000000;;		writer     http.ResponseWriter
0000000000000000000000000000000000000000;;		compressor Compressor
0000000000000000000000000000000000000000;;		encoding   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCompressionResponseWriter returns wraps w with a compression ResponseWriter, using the given encoding
0000000000000000000000000000000000000000;;	func NewCompressionResponseWriter(w http.ResponseWriter, encoding string) (http.ResponseWriter, error) {
0000000000000000000000000000000000000000;;		var compressor Compressor
0000000000000000000000000000000000000000;;		switch encoding {
0000000000000000000000000000000000000000;;		case encodingGzip:
0000000000000000000000000000000000000000;;			compressor = gzip.NewWriter(w)
0000000000000000000000000000000000000000;;		case encodingDeflate:
0000000000000000000000000000000000000000;;			compressor = zlib.NewWriter(w)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not a supported encoding type", encoding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &compressionResponseWriter{
0000000000000000000000000000000000000000;;			writer:     w,
0000000000000000000000000000000000000000;;			compressor: compressor,
0000000000000000000000000000000000000000;;			encoding:   encoding,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compressionResponseWriter implements http.Responsewriter Interface
0000000000000000000000000000000000000000;;	var _ http.ResponseWriter = &compressionResponseWriter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *compressionResponseWriter) Header() http.Header {
0000000000000000000000000000000000000000;;		return c.writer.Header()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compress data according to compression method
0000000000000000000000000000000000000000;;	func (c *compressionResponseWriter) Write(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		if c.compressorClosed() {
0000000000000000000000000000000000000000;;			return -1, errors.New("compressing error: tried to write data using closed compressor")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Header().Set(headerContentEncoding, c.encoding)
0000000000000000000000000000000000000000;;		return c.compressor.Write(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *compressionResponseWriter) WriteHeader(status int) {
0000000000000000000000000000000000000000;;		c.writer.WriteHeader(status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseNotify is part of http.CloseNotifier interface
0000000000000000000000000000000000000000;;	func (c *compressionResponseWriter) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return c.writer.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close the underlying compressor
0000000000000000000000000000000000000000;;	func (c *compressionResponseWriter) Close() error {
0000000000000000000000000000000000000000;;		if c.compressorClosed() {
0000000000000000000000000000000000000000;;			return errors.New("Compressing error: tried to close already closed compressor")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.compressor.Close()
0000000000000000000000000000000000000000;;		c.compressor = nil
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *compressionResponseWriter) Flush() {
0000000000000000000000000000000000000000;;		if c.compressorClosed() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.compressor.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *compressionResponseWriter) compressorClosed() bool {
0000000000000000000000000000000000000000;;		return nil == c.compressor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestfulWithCompression wraps WithCompression to be compatible with go-restful
0000000000000000000000000000000000000000;;	func RestfulWithCompression(function restful.RouteFunction, ctxMapper request.RequestContextMapper) restful.RouteFunction {
0000000000000000000000000000000000000000;;		return restful.RouteFunction(func(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;			handler := WithCompression(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				response.ResponseWriter = w
0000000000000000000000000000000000000000;;				request.Request = req
0000000000000000000000000000000000000000;;				function(request, response)
0000000000000000000000000000000000000000;;			}), ctxMapper)
0000000000000000000000000000000000000000;;			handler.ServeHTTP(response.ResponseWriter, request.Request)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
