0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c99a81742508523017bdbe3484265831a43d073a;pkg/genericapiserver/genericapiserver_test.go[pkg/genericapiserver/genericapiserver_test.go][staging/src/k8s.io/apiserver/pkg/server/genericapiserver_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/example"
0000000000000000000000000000000000000000;;		examplev1 "k8s.io/apiserver/pkg/apis/example/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/discovery"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		etcdtesting "k8s.io/apiserver/pkg/storage/etcd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/fake"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		extensionsGroupName = "extensions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		v1GroupVersion = schema.GroupVersion{Group: "", Version: "v1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme         = runtime.NewScheme()
0000000000000000000000000000000000000000;;		codecs         = serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;		parameterCodec = runtime.NewParameterCodec(scheme)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(scheme, metav1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		scheme.AddUnversionedTypes(v1GroupVersion,
0000000000000000000000000000000000000000;;			&metav1.Status{},
0000000000000000000000000000000000000000;;			&metav1.APIVersions{},
0000000000000000000000000000000000000000;;			&metav1.APIGroupList{},
0000000000000000000000000000000000000000;;			&metav1.APIGroup{},
0000000000000000000000000000000000000000;;			&metav1.APIResourceList{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		example.AddToScheme(scheme)
0000000000000000000000000000000000000000;;		examplev1.AddToScheme(scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testGetOpenAPIDefinitions(ref openapi.ReferenceCallback) map[string]openapi.OpenAPIDefinition {
0000000000000000000000000000000000000000;;		return map[string]openapi.OpenAPIDefinition{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setUp is a convience function for setting up for (most) tests.
0000000000000000000000000000000000000000;;	func setUp(t *testing.T) (*etcdtesting.EtcdTestServer, Config, *assert.Assertions) {
0000000000000000000000000000000000000000;;		etcdServer, _ := etcdtesting.NewUnsecuredEtcd3TestClientServer(t, scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := NewConfig(codecs)
0000000000000000000000000000000000000000;;		config.PublicAddress = net.ParseIP("192.168.10.4")
0000000000000000000000000000000000000000;;		config.RequestContextMapper = genericapirequest.NewRequestContextMapper()
0000000000000000000000000000000000000000;;		config.LegacyAPIGroupPrefixes = sets.NewString("/api")
0000000000000000000000000000000000000000;;		config.LoopbackClientConfig = &restclient.Config{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;		if clientset == nil {
0000000000000000000000000000000000000000;;			t.Fatal("unable to create fake client set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.SharedInformerFactory = informers.NewSharedInformerFactory(clientset, config.LoopbackClientConfig.Timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO restore this test, but right now, eliminate our cycle
0000000000000000000000000000000000000000;;		// config.OpenAPIConfig = DefaultOpenAPIConfig(testGetOpenAPIDefinitions, runtime.NewScheme())
0000000000000000000000000000000000000000;;		// config.OpenAPIConfig.Info = &spec.Info{
0000000000000000000000000000000000000000;;		// 	InfoProps: spec.InfoProps{
0000000000000000000000000000000000000000;;		// 		Title:   "Kubernetes",
0000000000000000000000000000000000000000;;		// 		Version: "unversioned",
0000000000000000000000000000000000000000;;		// 	},
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		config.SwaggerConfig = DefaultSwaggerConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return etcdServer, *config, assert.New(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMaster(t *testing.T) (*GenericAPIServer, *etcdtesting.EtcdTestServer, Config, *assert.Assertions) {
0000000000000000000000000000000000000000;;		etcdserver, config, assert := setUp(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := config.Complete().New("test", EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in bringing up the server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, etcdserver, config, assert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestNew verifies that the New function returns a GenericAPIServer
0000000000000000000000000000000000000000;;	// using the configuration properly.
0000000000000000000000000000000000000000;;	func TestNew(t *testing.T) {
0000000000000000000000000000000000000000;;		s, etcdserver, config, assert := newMaster(t)
0000000000000000000000000000000000000000;;		defer etcdserver.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify many of the variables match their config counterparts
0000000000000000000000000000000000000000;;		assert.Equal(s.legacyAPIGroupPrefixes, config.LegacyAPIGroupPrefixes)
0000000000000000000000000000000000000000;;		assert.Equal(s.admissionControl, config.AdmissionControl)
0000000000000000000000000000000000000000;;		assert.Equal(s.RequestContextMapper(), config.RequestContextMapper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// these values get defaulted
0000000000000000000000000000000000000000;;		assert.Equal(net.JoinHostPort(config.PublicAddress.String(), "443"), s.ExternalAddress)
0000000000000000000000000000000000000000;;		assert.NotNil(s.swaggerConfig)
0000000000000000000000000000000000000000;;		assert.Equal("http://"+s.ExternalAddress, s.swaggerConfig.WebServicesUrl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verifies that AddGroupVersions works as expected.
0000000000000000000000000000000000000000;;	func TestInstallAPIGroups(t *testing.T) {
0000000000000000000000000000000000000000;;		etcdserver, config, assert := setUp(t)
0000000000000000000000000000000000000000;;		defer etcdserver.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.LegacyAPIGroupPrefixes = sets.NewString("/apiPrefix")
0000000000000000000000000000000000000000;;		config.DiscoveryAddresses = discovery.DefaultAddresses{DefaultAddress: "ExternalAddress"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := config.SkipComplete().New("test", EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in bringing up the server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testAPI := func(gv schema.GroupVersion) APIGroupInfo {
0000000000000000000000000000000000000000;;			getter, noVerbs := testGetterStorage{}, testNoVerbsStorage{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;			scheme.AddKnownTypeWithName(gv.WithKind("Getter"), getter.New())
0000000000000000000000000000000000000000;;			scheme.AddKnownTypeWithName(gv.WithKind("NoVerb"), noVerbs.New())
0000000000000000000000000000000000000000;;			scheme.AddKnownTypes(v1GroupVersion, &metav1.Status{})
0000000000000000000000000000000000000000;;			metav1.AddToGroupVersion(scheme, v1GroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			interfacesFor := func(version schema.GroupVersion) (*meta.VersionInterfaces, error) {
0000000000000000000000000000000000000000;;				return &meta.VersionInterfaces{
0000000000000000000000000000000000000000;;					ObjectConvertor:  scheme,
0000000000000000000000000000000000000000;;					MetadataAccessor: meta.NewAccessor(),
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper := meta.NewDefaultRESTMapperFromScheme([]schema.GroupVersion{gv}, interfacesFor, "", sets.NewString(), sets.NewString(), scheme)
0000000000000000000000000000000000000000;;			groupMeta := apimachinery.GroupMeta{
0000000000000000000000000000000000000000;;				GroupVersion:  gv,
0000000000000000000000000000000000000000;;				GroupVersions: []schema.GroupVersion{gv},
0000000000000000000000000000000000000000;;				RESTMapper:    mapper,
0000000000000000000000000000000000000000;;				InterfacesFor: interfacesFor,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return APIGroupInfo{
0000000000000000000000000000000000000000;;				GroupMeta: groupMeta,
0000000000000000000000000000000000000000;;				VersionedResourcesStorageMap: map[string]map[string]rest.Storage{
0000000000000000000000000000000000000000;;					gv.Version: {
0000000000000000000000000000000000000000;;						"getter":  &testGetterStorage{Version: gv.Version},
0000000000000000000000000000000000000000;;						"noverbs": &testNoVerbsStorage{Version: gv.Version},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				OptionsExternalVersion: &schema.GroupVersion{Version: "v1"},
0000000000000000000000000000000000000000;;				ParameterCodec:         parameterCodec,
0000000000000000000000000000000000000000;;				NegotiatedSerializer:   codecs,
0000000000000000000000000000000000000000;;				Scheme:                 scheme,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apis := []APIGroupInfo{
0000000000000000000000000000000000000000;;			testAPI(schema.GroupVersion{Group: "", Version: "v1"}),
0000000000000000000000000000000000000000;;			testAPI(schema.GroupVersion{Group: extensionsGroupName, Version: "v1"}),
0000000000000000000000000000000000000000;;			testAPI(schema.GroupVersion{Group: "batch", Version: "v1"}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = s.InstallLegacyAPIGroup("/apiPrefix", &apis[0])
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		groupPaths := []string{
0000000000000000000000000000000000000000;;			config.LegacyAPIGroupPrefixes.List()[0], // /apiPrefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, api := range apis[1:] {
0000000000000000000000000000000000000000;;			err = s.InstallAPIGroup(&api)
0000000000000000000000000000000000000000;;			assert.NoError(err)
0000000000000000000000000000000000000000;;			groupPaths = append(groupPaths, APIGroupPrefix+"/"+api.GroupMeta.GroupVersion.Group) // /apis/<group>
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewServer(s.Handler)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range apis {
0000000000000000000000000000000000000000;;			// should serve APIGroup at group path
0000000000000000000000000000000000000000;;			info := &apis[i]
0000000000000000000000000000000000000000;;			path := groupPaths[i]
0000000000000000000000000000000000000000;;			resp, err := http.Get(server.URL + path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error getting path %q path: %v", i, path, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error reading body at path %q: %v", i, path, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.Logf("[%d] json at %s: %s", i, path, string(body))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				// legacy API returns APIVersions
0000000000000000000000000000000000000000;;				group := metav1.APIVersions{}
0000000000000000000000000000000000000000;;				err = json.Unmarshal(body, &group)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected error parsing json body at path %q: %v", i, path, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// API groups return APIGroup
0000000000000000000000000000000000000000;;				group := metav1.APIGroup{}
0000000000000000000000000000000000000000;;				err = json.Unmarshal(body, &group)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected error parsing json body at path %q: %v", i, path, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if got, expected := group.Name, info.GroupMeta.GroupVersion.Group; got != expected {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected group name at path %q: got=%q expected=%q", i, path, got, expected)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if got, expected := group.PreferredVersion.Version, info.GroupMeta.GroupVersion.Version; got != expected {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] unexpected group version at path %q: got=%q expected=%q", i, path, got, expected)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// should serve APIResourceList at group path + /<group-version>
0000000000000000000000000000000000000000;;			path = path + "/" + info.GroupMeta.GroupVersion.Version
0000000000000000000000000000000000000000;;			resp, err = http.Get(server.URL + path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error getting path %q path: %v", i, path, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			body, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error reading body at path %q: %v", i, path, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.Logf("[%d] json at %s: %s", i, path, string(body))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resources := metav1.APIResourceList{}
0000000000000000000000000000000000000000;;			err = json.Unmarshal(body, &resources)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error parsing json body at path %q: %v", i, path, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if got, expected := resources.GroupVersion, info.GroupMeta.GroupVersion.String(); got != expected {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected groupVersion at path %q: got=%q expected=%q", i, path, got, expected)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// the verbs should match the features of resources
0000000000000000000000000000000000000000;;			for _, r := range resources.APIResources {
0000000000000000000000000000000000000000;;				switch r.Name {
0000000000000000000000000000000000000000;;				case "getter":
0000000000000000000000000000000000000000;;					if got, expected := sets.NewString([]string(r.Verbs)...), sets.NewString("get"); !got.Equal(expected) {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] unexpected verbs for resource %s/%s: got=%v expected=%v", i, resources.GroupVersion, r.Name, got, expected)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case "noverbs":
0000000000000000000000000000000000000000;;					if r.Verbs == nil {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] unexpected nil verbs slice. Expected: []string{}", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if got, expected := sets.NewString([]string(r.Verbs)...), sets.NewString(); !got.Equal(expected) {
0000000000000000000000000000000000000000;;						t.Errorf("[%d] unexpected verbs for resource %s/%s: got=%v expected=%v", i, resources.GroupVersion, r.Name, got, expected)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPrepareRun(t *testing.T) {
0000000000000000000000000000000000000000;;		s, etcdserver, config, assert := newMaster(t)
0000000000000000000000000000000000000000;;		defer etcdserver.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.NotNil(config.SwaggerConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewServer(s.Handler.Director)
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.PrepareRun()
0000000000000000000000000000000000000000;;		s.RunPostStartHooks(done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// swagger is installed in PrepareRun
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/swaggerapi/")
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.Equal(http.StatusOK, resp.StatusCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// healthz checks are installed in PrepareRun
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/healthz")
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.Equal(http.StatusOK, resp.StatusCode)
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/healthz/ping")
0000000000000000000000000000000000000000;;		assert.NoError(err)
0000000000000000000000000000000000000000;;		assert.Equal(http.StatusOK, resp.StatusCode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestCustomHandlerChain verifies the handler chain with custom handler chain builder functions.
0000000000000000000000000000000000000000;;	func TestCustomHandlerChain(t *testing.T) {
0000000000000000000000000000000000000000;;		etcdserver, config, _ := setUp(t)
0000000000000000000000000000000000000000;;		defer etcdserver.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var protected, called bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.BuildHandlerChainFunc = func(apiHandler http.Handler, c *Config) http.Handler {
0000000000000000000000000000000000000000;;			return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				protected = true
0000000000000000000000000000000000000000;;				apiHandler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := http.HandlerFunc(func(r http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			called = true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := config.SkipComplete().New("test", EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in bringing up the server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Handler.NonGoRestfulMux.Handle("/nonswagger", handler)
0000000000000000000000000000000000000000;;		s.Handler.NonGoRestfulMux.Handle("/secret", handler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Test struct {
0000000000000000000000000000000000000000;;			handler   http.Handler
0000000000000000000000000000000000000000;;			path      string
0000000000000000000000000000000000000000;;			protected bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range []Test{
0000000000000000000000000000000000000000;;			{s.Handler, "/nonswagger", true},
0000000000000000000000000000000000000000;;			{s.Handler, "/secret", true},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			protected, called = false, false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var w io.Reader
0000000000000000000000000000000000000000;;			req, err := http.NewRequest("GET", test.path, w)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Unexpected http error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			test.handler.ServeHTTP(httptest.NewRecorder(), req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !called {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Expected handler to be called.", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.protected != protected {
0000000000000000000000000000000000000000;;				t.Errorf("%d: Expected protected=%v, got protected=%v.", i, test.protected, protected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestNotRestRoutesHaveAuth checks that special non-routes are behind authz/authn.
0000000000000000000000000000000000000000;;	func TestNotRestRoutesHaveAuth(t *testing.T) {
0000000000000000000000000000000000000000;;		etcdserver, config, _ := setUp(t)
0000000000000000000000000000000000000000;;		defer etcdserver.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authz := mockAuthorizer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.LegacyAPIGroupPrefixes = sets.NewString("/apiPrefix")
0000000000000000000000000000000000000000;;		config.Authorizer = &authz
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.EnableSwaggerUI = true
0000000000000000000000000000000000000000;;		config.EnableIndex = true
0000000000000000000000000000000000000000;;		config.EnableProfiling = true
0000000000000000000000000000000000000000;;		config.SwaggerConfig = DefaultSwaggerConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeVersion := fakeVersion()
0000000000000000000000000000000000000000;;		config.Version = &kubeVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := config.SkipComplete().New("test", EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in bringing up the server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			route string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"/"},
0000000000000000000000000000000000000000;;			{"/swagger-ui/"},
0000000000000000000000000000000000000000;;			{"/debug/pprof/"},
0000000000000000000000000000000000000000;;			{"/version"},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			resp := httptest.NewRecorder()
0000000000000000000000000000000000000000;;			req, _ := http.NewRequest("GET", test.route, nil)
0000000000000000000000000000000000000000;;			s.Handler.ServeHTTP(resp, req)
0000000000000000000000000000000000000000;;			if resp.Code != 200 {
0000000000000000000000000000000000000000;;				t.Errorf("route %q expected to work: code %d", test.route, resp.Code)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if authz.lastURI != test.route {
0000000000000000000000000000000000000000;;				t.Errorf("route %q expected to go through authorization, last route did: %q", test.route, authz.lastURI)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockAuthorizer struct {
0000000000000000000000000000000000000000;;		lastURI string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (authz *mockAuthorizer) Authorize(a authorizer.Attributes) (authorized bool, reason string, err error) {
0000000000000000000000000000000000000000;;		authz.lastURI = a.GetPath()
0000000000000000000000000000000000000000;;		return true, "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockAuthenticator struct {
0000000000000000000000000000000000000000;;		lastURI string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (authn *mockAuthenticator) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		authn.lastURI = req.RequestURI
0000000000000000000000000000000000000000;;		return &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name: "foo",
0000000000000000000000000000000000000000;;		}, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeResponse(resp *http.Response, obj interface{}) error {
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testGetterStorage struct {
0000000000000000000000000000000000000000;;		Version string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *testGetterStorage) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &metav1.APIGroup{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "Getter",
0000000000000000000000000000000000000000;;				APIVersion: p.Version,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *testGetterStorage) Get(ctx genericapirequest.Context, name string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testNoVerbsStorage struct {
0000000000000000000000000000000000000000;;		Version string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *testNoVerbsStorage) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &metav1.APIGroup{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{
0000000000000000000000000000000000000000;;				Kind:       "NoVerbs",
0000000000000000000000000000000000000000;;				APIVersion: p.Version,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeVersion() version.Info {
0000000000000000000000000000000000000000;;		return version.Info{
0000000000000000000000000000000000000000;;			Major:        "42",
0000000000000000000000000000000000000000;;			Minor:        "42",
0000000000000000000000000000000000000000;;			GitVersion:   "42",
0000000000000000000000000000000000000000;;			GitCommit:    "34973274ccef6ab4dfaaf86599792fa9c3fe4689",
0000000000000000000000000000000000000000;;			GitTreeState: "Dirty",
0000000000000000000000000000000000000000;;			BuildDate:    time.Now().String(),
0000000000000000000000000000000000000000;;			GoVersion:    goruntime.Version(),
0000000000000000000000000000000000000000;;			Compiler:     goruntime.Compiler,
0000000000000000000000000000000000000000;;			Platform:     fmt.Sprintf("%s/%s", goruntime.GOOS, goruntime.GOARCH),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
