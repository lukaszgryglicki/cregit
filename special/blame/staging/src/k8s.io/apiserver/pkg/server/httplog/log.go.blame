0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
acfcf8a2bf425c9eaac1354f35c3023054d29025;pkg/apiserver/logger.go[pkg/apiserver/logger.go][staging/src/k8s.io/apiserver/pkg/server/httplog/log.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package httplog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler wraps all HTTP calls to delegate with nice logging.
0000000000000000000000000000000000000000;;	// delegate may use LogOf(w).Addf(...) to write additional info to
0000000000000000000000000000000000000000;;	// the per-request log message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Intended to wrap calls to your ServeMux.
0000000000000000000000000000000000000000;;	func Handler(delegate http.Handler, pred StacktracePred) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			defer NewLogged(req, &w).StacktraceWhen(pred).Log()
0000000000000000000000000000000000000000;;			delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StacktracePred returns true if a stacktrace should be logged for this status.
0000000000000000000000000000000000000000;;	type StacktracePred func(httpStatus int) (logStacktrace bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type logger interface {
0000000000000000000000000000000000000000;;		Addf(format string, data ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a layer on top of ResponseWriter, so we can track latency and error
0000000000000000000000000000000000000000;;	// message sources.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO now that we're using go-restful, we shouldn't need to be wrapping
0000000000000000000000000000000000000000;;	// the http.ResponseWriter. We can recover panics from go-restful, and
0000000000000000000000000000000000000000;;	// the logging value is questionable.
0000000000000000000000000000000000000000;;	type respLogger struct {
0000000000000000000000000000000000000000;;		hijacked       bool
0000000000000000000000000000000000000000;;		statusRecorded bool
0000000000000000000000000000000000000000;;		status         int
0000000000000000000000000000000000000000;;		statusStack    string
0000000000000000000000000000000000000000;;		addedInfo      string
0000000000000000000000000000000000000000;;		startTime      time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		captureErrorOutput bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req *http.Request
0000000000000000000000000000000000000000;;		w   http.ResponseWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logStacktracePred StacktracePred
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Simple logger that logs immediately when Addf is called
0000000000000000000000000000000000000000;;	type passthroughLogger struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addf logs info immediately.
0000000000000000000000000000000000000000;;	func (passthroughLogger) Addf(format string, data ...interface{}) {
0000000000000000000000000000000000000000;;		glog.V(2).Info(fmt.Sprintf(format, data...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultStacktracePred is the default implementation of StacktracePred.
0000000000000000000000000000000000000000;;	func DefaultStacktracePred(status int) bool {
0000000000000000000000000000000000000000;;		return (status < http.StatusOK || status >= http.StatusInternalServerError) && status != http.StatusSwitchingProtocols
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLogged turns a normal response writer into a logged response writer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Usage:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// defer NewLogged(req, &w).StacktraceWhen(StatusIsNot(200, 202)).Log()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// (Only the call to Log() is deferred, so you can set everything up in one line!)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that this *changes* your writer, to route response writing actions
0000000000000000000000000000000000000000;;	// through the logger.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use LogOf(w).Addf(...) to log something along with the response result.
0000000000000000000000000000000000000000;;	func NewLogged(req *http.Request, w *http.ResponseWriter) *respLogger {
0000000000000000000000000000000000000000;;		if _, ok := (*w).(*respLogger); ok {
0000000000000000000000000000000000000000;;			// Don't double-wrap!
0000000000000000000000000000000000000000;;			panic("multiple NewLogged calls!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rl := &respLogger{
0000000000000000000000000000000000000000;;			startTime:         time.Now(),
0000000000000000000000000000000000000000;;			req:               req,
0000000000000000000000000000000000000000;;			w:                 *w,
0000000000000000000000000000000000000000;;			logStacktracePred: DefaultStacktracePred,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*w = rl // hijack caller's writer!
0000000000000000000000000000000000000000;;		return rl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogOf returns the logger hiding in w. If there is not an existing logger
0000000000000000000000000000000000000000;;	// then a passthroughLogger will be created which will log to stdout immediately
0000000000000000000000000000000000000000;;	// when Addf is called.
0000000000000000000000000000000000000000;;	func LogOf(req *http.Request, w http.ResponseWriter) logger {
0000000000000000000000000000000000000000;;		if _, exists := w.(*respLogger); !exists {
0000000000000000000000000000000000000000;;			pl := &passthroughLogger{}
0000000000000000000000000000000000000000;;			return pl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rl, ok := w.(*respLogger); ok {
0000000000000000000000000000000000000000;;			return rl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("Unable to find or create the logger!")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unlogged returns the original ResponseWriter, or w if it is not our inserted logger.
0000000000000000000000000000000000000000;;	func Unlogged(w http.ResponseWriter) http.ResponseWriter {
0000000000000000000000000000000000000000;;		if rl, ok := w.(*respLogger); ok {
0000000000000000000000000000000000000000;;			return rl.w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StacktraceWhen sets the stacktrace logging predicate, which decides when to log a stacktrace.
0000000000000000000000000000000000000000;;	// There's a default, so you don't need to call this unless you don't like the default.
0000000000000000000000000000000000000000;;	func (rl *respLogger) StacktraceWhen(pred StacktracePred) *respLogger {
0000000000000000000000000000000000000000;;		rl.logStacktracePred = pred
0000000000000000000000000000000000000000;;		return rl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusIsNot returns a StacktracePred which will cause stacktraces to be logged
0000000000000000000000000000000000000000;;	// for any status *not* in the given list.
0000000000000000000000000000000000000000;;	func StatusIsNot(statuses ...int) StacktracePred {
0000000000000000000000000000000000000000;;		return func(status int) bool {
0000000000000000000000000000000000000000;;			for _, s := range statuses {
0000000000000000000000000000000000000000;;				if status == s {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addf adds additional data to be logged with this request.
0000000000000000000000000000000000000000;;	func (rl *respLogger) Addf(format string, data ...interface{}) {
0000000000000000000000000000000000000000;;		rl.addedInfo += "\n" + fmt.Sprintf(format, data...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Log is intended to be called once at the end of your request handler, via defer
0000000000000000000000000000000000000000;;	func (rl *respLogger) Log() {
0000000000000000000000000000000000000000;;		latency := time.Since(rl.startTime)
0000000000000000000000000000000000000000;;		if glog.V(2) {
0000000000000000000000000000000000000000;;			if !rl.hijacked {
0000000000000000000000000000000000000000;;				glog.InfoDepth(1, fmt.Sprintf("%s %s: (%v) %v%v%v [%s %s]", rl.req.Method, rl.req.RequestURI, latency, rl.status, rl.statusStack, rl.addedInfo, rl.req.Header["User-Agent"], rl.req.RemoteAddr))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.InfoDepth(1, fmt.Sprintf("%s %s: (%v) hijacked [%s %s]", rl.req.Method, rl.req.RequestURI, latency, rl.req.Header["User-Agent"], rl.req.RemoteAddr))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header implements http.ResponseWriter.
0000000000000000000000000000000000000000;;	func (rl *respLogger) Header() http.Header {
0000000000000000000000000000000000000000;;		return rl.w.Header()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write implements http.ResponseWriter.
0000000000000000000000000000000000000000;;	func (rl *respLogger) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !rl.statusRecorded {
0000000000000000000000000000000000000000;;			rl.recordStatus(http.StatusOK) // Default if WriteHeader hasn't been called
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rl.captureErrorOutput {
0000000000000000000000000000000000000000;;			rl.Addf("logging error output: %q\n", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rl.w.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flush implements http.Flusher even if the underlying http.Writer doesn't implement it.
0000000000000000000000000000000000000000;;	// Flush is used for streaming purposes and allows to flush buffered data to the client.
0000000000000000000000000000000000000000;;	func (rl *respLogger) Flush() {
0000000000000000000000000000000000000000;;		if flusher, ok := rl.w.(http.Flusher); ok {
0000000000000000000000000000000000000000;;			flusher.Flush()
0000000000000000000000000000000000000000;;		} else if glog.V(2) {
0000000000000000000000000000000000000000;;			glog.InfoDepth(1, fmt.Sprintf("Unable to convert %+v into http.Flusher", rl.w))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeader implements http.ResponseWriter.
0000000000000000000000000000000000000000;;	func (rl *respLogger) WriteHeader(status int) {
0000000000000000000000000000000000000000;;		rl.recordStatus(status)
0000000000000000000000000000000000000000;;		rl.w.WriteHeader(status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hijack implements http.Hijacker.
0000000000000000000000000000000000000000;;	func (rl *respLogger) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		rl.hijacked = true
0000000000000000000000000000000000000000;;		return rl.w.(http.Hijacker).Hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseNotify implements http.CloseNotifier
0000000000000000000000000000000000000000;;	func (rl *respLogger) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return rl.w.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *respLogger) recordStatus(status int) {
0000000000000000000000000000000000000000;;		rl.status = status
0000000000000000000000000000000000000000;;		rl.statusRecorded = true
0000000000000000000000000000000000000000;;		if rl.logStacktracePred(status) {
0000000000000000000000000000000000000000;;			// Only log stacks for errors
0000000000000000000000000000000000000000;;			stack := make([]byte, 50*1024)
0000000000000000000000000000000000000000;;			stack = stack[:runtime.Stack(stack, false)]
0000000000000000000000000000000000000000;;			rl.statusStack = "\n" + string(stack)
0000000000000000000000000000000000000000;;			rl.captureErrorOutput = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rl.statusStack = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
