0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8e5dbdd02c2eaa420abecbec0f800f9e5c8f9f8b;pkg/genericapiserver/filters/timeout.go[pkg/genericapiserver/filters/timeout.go][staging/src/k8s.io/apiserver/pkg/server/filters/timeout.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/metrics"
0000000000000000000000000000000000000000;;		apirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const globalTimeout = time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errConnKilled = fmt.Errorf("kill connection/stream")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithTimeoutForNonLongRunningRequests times out non-long-running requests after the time given by globalTimeout.
0000000000000000000000000000000000000000;;	func WithTimeoutForNonLongRunningRequests(handler http.Handler, requestContextMapper apirequest.RequestContextMapper, longRunning apirequest.LongRunningRequestCheck) http.Handler {
0000000000000000000000000000000000000000;;		if longRunning == nil {
0000000000000000000000000000000000000000;;			return handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeoutFunc := func(req *http.Request) (<-chan time.Time, func(), *apierrors.StatusError) {
0000000000000000000000000000000000000000;;			// TODO unify this with apiserver.MaxInFlightLimit
0000000000000000000000000000000000000000;;			ctx, ok := requestContextMapper.Get(req)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// if this happens, the handler chain isn't setup correctly because there is no context mapper
0000000000000000000000000000000000000000;;				return time.After(globalTimeout), func() {}, apierrors.NewInternalError(fmt.Errorf("no context found for request during timeout"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestInfo, ok := apirequest.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// if this happens, the handler chain isn't setup correctly because there is no request info
0000000000000000000000000000000000000000;;				return time.After(globalTimeout), func() {}, apierrors.NewInternalError(fmt.Errorf("no request info found for request during timeout"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if longRunning(req, requestInfo) {
0000000000000000000000000000000000000000;;				return nil, nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			metricFn := func() {
0000000000000000000000000000000000000000;;				metrics.MonitorRequest(req, strings.ToUpper(requestInfo.Verb), requestInfo.Resource, requestInfo.Subresource, "", http.StatusInternalServerError, now)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return time.After(globalTimeout), metricFn, apierrors.NewServerTimeout(schema.GroupResource{Group: requestInfo.APIGroup, Resource: requestInfo.Resource}, requestInfo.Verb, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return WithTimeout(handler, timeoutFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithTimeout returns an http.Handler that runs h with a timeout
0000000000000000000000000000000000000000;;	// determined by timeoutFunc. The new http.Handler calls h.ServeHTTP to handle
0000000000000000000000000000000000000000;;	// each request, but if a call runs for longer than its time limit, the
0000000000000000000000000000000000000000;;	// handler responds with a 503 Service Unavailable error and the message
0000000000000000000000000000000000000000;;	// provided. (If msg is empty, a suitable default message will be sent.) After
0000000000000000000000000000000000000000;;	// the handler times out, writes by h to its http.ResponseWriter will return
0000000000000000000000000000000000000000;;	// http.ErrHandlerTimeout. If timeoutFunc returns a nil timeout channel, no
0000000000000000000000000000000000000000;;	// timeout will be enforced. recordFn is a function that will be invoked whenever
0000000000000000000000000000000000000000;;	// a timeout happens.
0000000000000000000000000000000000000000;;	func WithTimeout(h http.Handler, timeoutFunc func(*http.Request) (timeout <-chan time.Time, recordFn func(), err *apierrors.StatusError)) http.Handler {
0000000000000000000000000000000000000000;;		return &timeoutHandler{h, timeoutFunc}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timeoutHandler struct {
0000000000000000000000000000000000000000;;		handler http.Handler
0000000000000000000000000000000000000000;;		timeout func(*http.Request) (<-chan time.Time, func(), *apierrors.StatusError)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *timeoutHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		after, recordFn, err := t.timeout(r)
0000000000000000000000000000000000000000;;		if after == nil {
0000000000000000000000000000000000000000;;			t.handler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		tw := newTimeoutWriter(w)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			t.handler.ServeHTTP(tw, r)
0000000000000000000000000000000000000000;;			close(done)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case <-after:
0000000000000000000000000000000000000000;;			recordFn()
0000000000000000000000000000000000000000;;			tw.timeout(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timeoutWriter interface {
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;		timeout(*apierrors.StatusError)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTimeoutWriter(w http.ResponseWriter) timeoutWriter {
0000000000000000000000000000000000000000;;		base := &baseTimeoutWriter{w: w}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, notifiable := w.(http.CloseNotifier)
0000000000000000000000000000000000000000;;		_, hijackable := w.(http.Hijacker)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case notifiable && hijackable:
0000000000000000000000000000000000000000;;			return &closeHijackTimeoutWriter{base}
0000000000000000000000000000000000000000;;		case notifiable:
0000000000000000000000000000000000000000;;			return &closeTimeoutWriter{base}
0000000000000000000000000000000000000000;;		case hijackable:
0000000000000000000000000000000000000000;;			return &hijackTimeoutWriter{base}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return base
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type baseTimeoutWriter struct {
0000000000000000000000000000000000000000;;		w http.ResponseWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		// if the timeout handler has timedout
0000000000000000000000000000000000000000;;		timedOut bool
0000000000000000000000000000000000000000;;		// if this timeout writer has wrote header
0000000000000000000000000000000000000000;;		wroteHeader bool
0000000000000000000000000000000000000000;;		// if this timeout writer has been hijacked
0000000000000000000000000000000000000000;;		hijacked bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *baseTimeoutWriter) Header() http.Header {
0000000000000000000000000000000000000000;;		tw.mu.Lock()
0000000000000000000000000000000000000000;;		defer tw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tw.timedOut {
0000000000000000000000000000000000000000;;			return http.Header{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tw.w.Header()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *baseTimeoutWriter) Write(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		tw.mu.Lock()
0000000000000000000000000000000000000000;;		defer tw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tw.timedOut {
0000000000000000000000000000000000000000;;			return 0, http.ErrHandlerTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tw.hijacked {
0000000000000000000000000000000000000000;;			return 0, http.ErrHijacked
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tw.wroteHeader = true
0000000000000000000000000000000000000000;;		return tw.w.Write(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *baseTimeoutWriter) Flush() {
0000000000000000000000000000000000000000;;		tw.mu.Lock()
0000000000000000000000000000000000000000;;		defer tw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tw.timedOut {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flusher, ok := tw.w.(http.Flusher); ok {
0000000000000000000000000000000000000000;;			flusher.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *baseTimeoutWriter) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		tw.mu.Lock()
0000000000000000000000000000000000000000;;		defer tw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tw.timedOut || tw.wroteHeader || tw.hijacked {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tw.wroteHeader = true
0000000000000000000000000000000000000000;;		tw.w.WriteHeader(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *baseTimeoutWriter) timeout(err *apierrors.StatusError) {
0000000000000000000000000000000000000000;;		tw.mu.Lock()
0000000000000000000000000000000000000000;;		defer tw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tw.timedOut = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The timeout writer has not been used by the inner handler.
0000000000000000000000000000000000000000;;		// We can safely timeout the HTTP request by sending by a timeout
0000000000000000000000000000000000000000;;		// handler
0000000000000000000000000000000000000000;;		if !tw.wroteHeader && !tw.hijacked {
0000000000000000000000000000000000000000;;			tw.w.WriteHeader(http.StatusGatewayTimeout)
0000000000000000000000000000000000000000;;			enc := json.NewEncoder(tw.w)
0000000000000000000000000000000000000000;;			enc.Encode(&err.ErrStatus)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The timeout writer has been used by the inner handler. There is
0000000000000000000000000000000000000000;;			// no way to timeout the HTTP request at the point. We have to shutdown
0000000000000000000000000000000000000000;;			// the connection for HTTP1 or reset stream for HTTP2.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Note from: Brad Fitzpatrick
0000000000000000000000000000000000000000;;			// if the ServeHTTP goroutine panics, that will do the best possible thing for both
0000000000000000000000000000000000000000;;			// HTTP/1 and HTTP/2. In HTTP/1, assuming you're replying with at least HTTP/1.1 and
0000000000000000000000000000000000000000;;			// you've already flushed the headers so it's using HTTP chunking, it'll kill the TCP
0000000000000000000000000000000000000000;;			// connection immediately without a proper 0-byte EOF chunk, so the peer will recognize
0000000000000000000000000000000000000000;;			// the response as bogus. In HTTP/2 the server will just RST_STREAM the stream, leaving
0000000000000000000000000000000000000000;;			// the TCP connection open, but resetting the stream to the peer so it'll have an error,
0000000000000000000000000000000000000000;;			// like the HTTP/1 case.
0000000000000000000000000000000000000000;;			panic(errConnKilled)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *baseTimeoutWriter) closeNotify() <-chan bool {
0000000000000000000000000000000000000000;;		tw.mu.Lock()
0000000000000000000000000000000000000000;;		defer tw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tw.timedOut {
0000000000000000000000000000000000000000;;			done := make(chan bool)
0000000000000000000000000000000000000000;;			close(done)
0000000000000000000000000000000000000000;;			return done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tw.w.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *baseTimeoutWriter) hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		tw.mu.Lock()
0000000000000000000000000000000000000000;;		defer tw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tw.timedOut {
0000000000000000000000000000000000000000;;			return nil, nil, http.ErrHandlerTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn, rw, err := tw.w.(http.Hijacker).Hijack()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			tw.hijacked = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, rw, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type closeTimeoutWriter struct {
0000000000000000000000000000000000000000;;		*baseTimeoutWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *closeTimeoutWriter) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return tw.closeNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hijackTimeoutWriter struct {
0000000000000000000000000000000000000000;;		*baseTimeoutWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *hijackTimeoutWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		return tw.hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type closeHijackTimeoutWriter struct {
0000000000000000000000000000000000000000;;		*baseTimeoutWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *closeHijackTimeoutWriter) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return tw.closeNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tw *closeHijackTimeoutWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		return tw.hijack()
0000000000000000000000000000000000000000;;	}
