0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6181045ba39e6d653067ebafa377aa506922aef4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"gopkg.in/natefinch/lumberjack.v2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit/policy"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		pluginlog "k8s.io/apiserver/plugin/pkg/audit/log"
0000000000000000000000000000000000000000;;		pluginwebhook "k8s.io/apiserver/plugin/pkg/audit/webhook"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendBackend(existing, newBackend audit.Backend) audit.Backend {
0000000000000000000000000000000000000000;;		if existing == nil {
0000000000000000000000000000000000000000;;			return newBackend
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return audit.Union(existing, newBackend)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func advancedAuditingEnabled() bool {
0000000000000000000000000000000000000000;;		return utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuditOptions struct {
0000000000000000000000000000000000000000;;		// Policy configuration file for filtering audit events that are captured.
0000000000000000000000000000000000000000;;		// If unspecified, a default is provided.
0000000000000000000000000000000000000000;;		PolicyFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Plugin options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LogOptions     AuditLogOptions
0000000000000000000000000000000000000000;;		WebhookOptions AuditWebhookOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuditLogOptions holds the legacy audit log writer. If the AdvancedAuditing feature
0000000000000000000000000000000000000000;;	// is enabled, these options determine the output of the structured audit log.
0000000000000000000000000000000000000000;;	type AuditLogOptions struct {
0000000000000000000000000000000000000000;;		Path       string
0000000000000000000000000000000000000000;;		MaxAge     int
0000000000000000000000000000000000000000;;		MaxBackups int
0000000000000000000000000000000000000000;;		MaxSize    int
0000000000000000000000000000000000000000;;		Format     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuditWebhookOptions control the webhook configuration for audit events.
0000000000000000000000000000000000000000;;	type AuditWebhookOptions struct {
0000000000000000000000000000000000000000;;		ConfigFile string
0000000000000000000000000000000000000000;;		// Should the webhook asynchronous batch events to the webhook backend or
0000000000000000000000000000000000000000;;		// should the webhook block responses?
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Defaults to asynchronous batch events.
0000000000000000000000000000000000000000;;		Mode string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAuditOptions() *AuditOptions {
0000000000000000000000000000000000000000;;		return &AuditOptions{
0000000000000000000000000000000000000000;;			WebhookOptions: AuditWebhookOptions{Mode: pluginwebhook.ModeBatch},
0000000000000000000000000000000000000000;;			LogOptions:     AuditLogOptions{Format: pluginlog.FormatLegacy},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks invalid config combination
0000000000000000000000000000000000000000;;	func (o *AuditOptions) Validate() []error {
0000000000000000000000000000000000000000;;		allErrors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !advancedAuditingEnabled() {
0000000000000000000000000000000000000000;;			if len(o.PolicyFile) > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, fmt.Errorf("feature '%s' must be enabled to set option --audit-policy-file", features.AdvancedAuditing))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(o.WebhookOptions.ConfigFile) > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, fmt.Errorf("feature '%s' must be enabled to set option --audit-webhook-config-file", features.AdvancedAuditing))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// check webhook mode
0000000000000000000000000000000000000000;;			validMode := false
0000000000000000000000000000000000000000;;			for _, m := range pluginwebhook.AllowedModes {
0000000000000000000000000000000000000000;;				if m == o.WebhookOptions.Mode {
0000000000000000000000000000000000000000;;					validMode = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !validMode {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, fmt.Errorf("invalid audit webhook mode %s, allowed modes are %q", o.WebhookOptions.Mode, strings.Join(pluginwebhook.AllowedModes, ",")))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check log format
0000000000000000000000000000000000000000;;			validFormat := false
0000000000000000000000000000000000000000;;			for _, f := range pluginlog.AllowedFormats {
0000000000000000000000000000000000000000;;				if f == o.LogOptions.Format {
0000000000000000000000000000000000000000;;					validFormat = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !validFormat {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, fmt.Errorf("invalid audit log format %s, allowed formats are %q", o.LogOptions.Format, strings.Join(pluginlog.AllowedFormats, ",")))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&o.PolicyFile, "audit-policy-file", o.PolicyFile,
0000000000000000000000000000000000000000;;			"Path to the file that defines the audit policy configuration. Requires the 'AdvancedAuditing' feature gate."+
0000000000000000000000000000000000000000;;				" With AdvancedAuditing, a profile is required to enable auditing.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.LogOptions.AddFlags(fs)
0000000000000000000000000000000000000000;;		o.WebhookOptions.AddFlags(fs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditOptions) ApplyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		// Apply legacy audit options if advanced audit is not enabled.
0000000000000000000000000000000000000000;;		if !advancedAuditingEnabled() {
0000000000000000000000000000000000000000;;			return o.LogOptions.legacyApplyTo(c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply advanced options if advanced audit is enabled.
0000000000000000000000000000000000000000;;		// 1. Apply generic options.
0000000000000000000000000000000000000000;;		if err := o.applyTo(c); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. Apply plugin options.
0000000000000000000000000000000000000000;;		if err := o.LogOptions.advancedApplyTo(c); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := o.WebhookOptions.applyTo(c); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditOptions) applyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		if o.PolicyFile == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := policy.LoadPolicyFromFile(o.PolicyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("loading audit policy file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.AuditPolicyChecker = policy.NewChecker(p)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditLogOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&o.Path, "audit-log-path", o.Path,
0000000000000000000000000000000000000000;;			"If set, all requests coming to the apiserver will be logged to this file.  '-' means standard out.")
0000000000000000000000000000000000000000;;		fs.IntVar(&o.MaxAge, "audit-log-maxage", o.MaxBackups,
0000000000000000000000000000000000000000;;			"The maximum number of days to retain old audit log files based on the timestamp encoded in their filename.")
0000000000000000000000000000000000000000;;		fs.IntVar(&o.MaxBackups, "audit-log-maxbackup", o.MaxBackups,
0000000000000000000000000000000000000000;;			"The maximum number of old audit log files to retain.")
0000000000000000000000000000000000000000;;		fs.IntVar(&o.MaxSize, "audit-log-maxsize", o.MaxSize,
0000000000000000000000000000000000000000;;			"The maximum size in megabytes of the audit log file before it gets rotated.")
0000000000000000000000000000000000000000;;		fs.StringVar(&o.Format, "audit-log-format", o.Format,
0000000000000000000000000000000000000000;;			"Format of saved audits. \"legacy\" indicates 1-line text format for each event."+
0000000000000000000000000000000000000000;;				" \"json\" indicates structured json format. Requires the 'AdvancedAuditing' feature"+
0000000000000000000000000000000000000000;;				" gate. Known formats are "+strings.Join(pluginlog.AllowedFormats, ",")+".")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditLogOptions) getWriter() io.Writer {
0000000000000000000000000000000000000000;;		if o.Path == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var w io.Writer = os.Stdout
0000000000000000000000000000000000000000;;		if o.Path != "-" {
0000000000000000000000000000000000000000;;			w = &lumberjack.Logger{
0000000000000000000000000000000000000000;;				Filename:   o.Path,
0000000000000000000000000000000000000000;;				MaxAge:     o.MaxAge,
0000000000000000000000000000000000000000;;				MaxBackups: o.MaxBackups,
0000000000000000000000000000000000000000;;				MaxSize:    o.MaxSize,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditLogOptions) advancedApplyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		if w := o.getWriter(); w != nil {
0000000000000000000000000000000000000000;;			c.AuditBackend = appendBackend(c.AuditBackend, pluginlog.NewBackend(w, o.Format))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditLogOptions) legacyApplyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		c.LegacyAuditWriter = o.getWriter()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditWebhookOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&o.ConfigFile, "audit-webhook-config-file", o.ConfigFile,
0000000000000000000000000000000000000000;;			"Path to a kubeconfig formatted file that defines the audit webhook configuration."+
0000000000000000000000000000000000000000;;				" Requires the 'AdvancedAuditing' feature gate.")
0000000000000000000000000000000000000000;;		fs.StringVar(&o.Mode, "audit-webhook-mode", o.Mode,
0000000000000000000000000000000000000000;;			"Strategy for sending audit events. Blocking indicates sending events should block"+
0000000000000000000000000000000000000000;;				" server responses. Batch causes the webhook to buffer and send events"+
0000000000000000000000000000000000000000;;				" asynchronously. Known modes are "+strings.Join(pluginwebhook.AllowedModes, ",")+".")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AuditWebhookOptions) applyTo(c *server.Config) error {
0000000000000000000000000000000000000000;;		if o.ConfigFile == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		webhook, err := pluginwebhook.NewBackend(o.ConfigFile, o.Mode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("initializing audit webhook: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.AuditBackend = appendBackend(c.AuditBackend, webhook)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
