0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
026f71bac912c3396ba215e8f9bdecbf263f53a0;pkg/genericapiserver/serve_test.go[pkg/genericapiserver/serve_test.go][staging/src/k8s.io/apiserver/pkg/server/options/serving_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		cryptorand "crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		. "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		utilflag "k8s.io/apiserver/pkg/util/flag"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/discovery"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setUp(t *testing.T) Config {
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		codecs := serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := NewConfig(codecs)
0000000000000000000000000000000000000000;;		config.RequestContextMapper = genericapirequest.NewRequestContextMapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return *config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestCertSpec struct {
0000000000000000000000000000000000000000;;		host       string
0000000000000000000000000000000000000000;;		names, ips []string // in certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamedTestCertSpec struct {
0000000000000000000000000000000000000000;;		TestCertSpec
0000000000000000000000000000000000000000;;		explicitNames []string // as --tls-sni-cert-key explicit names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetNamedCertificateMap(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			certs         []NamedTestCertSpec
0000000000000000000000000000000000000000;;			explicitNames []string
0000000000000000000000000000000000000000;;			expected      map[string]int // name to certs[*] index
0000000000000000000000000000000000000000;;			errorString   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// empty certs
0000000000000000000000000000000000000000;;				expected: map[string]int{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// only one cert
0000000000000000000000000000000000000000;;				certs: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: map[string]int{
0000000000000000000000000000000000000000;;					"test.com": 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// ips are ignored
0000000000000000000000000000000000000000;;				certs: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;							ips:  []string{"1.2.3.4"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: map[string]int{
0000000000000000000000000000000000000000;;					"test.com": 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// two certs with the same name
0000000000000000000000000000000000000000;;				certs: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: map[string]int{
0000000000000000000000000000000000000000;;					"test.com": 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// two certs with different names
0000000000000000000000000000000000000000;;				certs: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test2.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test1.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: map[string]int{
0000000000000000000000000000000000000000;;					"test1.com": 1,
0000000000000000000000000000000000000000;;					"test2.com": 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// two certs with the same name, explicit trumps
0000000000000000000000000000000000000000;;				certs: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						explicitNames: []string{"test.com"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: map[string]int{
0000000000000000000000000000000000000000;;					"test.com": 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// certs with partial overlap; ips are ignored
0000000000000000000000000000000000000000;;				certs: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host:  "a",
0000000000000000000000000000000000000000;;							names: []string{"a.test.com", "test.com"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host:  "b",
0000000000000000000000000000000000000000;;							names: []string{"b.test.com", "test.com"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: map[string]int{
0000000000000000000000000000000000000000;;					"a": 0, "b": 1,
0000000000000000000000000000000000000000;;					"a.test.com": 0, "b.test.com": 1,
0000000000000000000000000000000000000000;;					"test.com": 0,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// wildcards
0000000000000000000000000000000000000000;;				certs: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host:  "a",
0000000000000000000000000000000000000000;;							names: []string{"a.test.com", "test.com"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						explicitNames: []string{"*.test.com", "test.com"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host:  "b",
0000000000000000000000000000000000000000;;							names: []string{"b.test.com", "test.com"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						explicitNames: []string{"dev.test.com", "test.com"},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				expected: map[string]int{
0000000000000000000000000000000000000000;;					"test.com":     0,
0000000000000000000000000000000000000000;;					"*.test.com":   0,
0000000000000000000000000000000000000000;;					"dev.test.com": 1,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	NextTest:
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			var namedTLSCerts []NamedTLSCert
0000000000000000000000000000000000000000;;			bySignature := map[string]int{} // index in test.certs by cert signature
0000000000000000000000000000000000000000;;			for j, c := range test.certs {
0000000000000000000000000000000000000000;;				cert, err := createTestTLSCerts(c.TestCertSpec)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d - failed to create cert %d: %v", i, j, err)
0000000000000000000000000000000000000000;;					continue NextTest
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				namedTLSCerts = append(namedTLSCerts, NamedTLSCert{
0000000000000000000000000000000000000000;;					TLSCert: cert,
0000000000000000000000000000000000000000;;					Names:   c.explicitNames,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sig, err := certSignature(cert)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d - failed to get signature for %d: %v", i, j, err)
0000000000000000000000000000000000000000;;					continue NextTest
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bySignature[sig] = j
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			certMap, err := GetNamedCertificateMap(namedTLSCerts)
0000000000000000000000000000000000000000;;			if err == nil && len(test.errorString) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%d - expected no error, got: %v", i, err)
0000000000000000000000000000000000000000;;			} else if err != nil && err.Error() != test.errorString {
0000000000000000000000000000000000000000;;				t.Errorf("%d - expected error %q, got: %v", i, test.errorString, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				got := map[string]int{}
0000000000000000000000000000000000000000;;				for name, cert := range certMap {
0000000000000000000000000000000000000000;;					x509Certs, err := x509.ParseCertificates(cert.Certificate[0])
0000000000000000000000000000000000000000;;					assert.NoError(t, err, "%d - invalid certificate for %q", i, name)
0000000000000000000000000000000000000000;;					assert.True(t, len(x509Certs) > 0, "%d - expected at least one x509 cert in tls cert for %q", i, name)
0000000000000000000000000000000000000000;;					got[name] = bySignature[x509CertSignature(x509Certs[0])]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				assert.EqualValues(t, test.expected, got, "%d - wrong certificate map", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServerRunWithSNI(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			Cert              TestCertSpec
0000000000000000000000000000000000000000;;			SNICerts          []NamedTestCertSpec
0000000000000000000000000000000000000000;;			ExpectedCertIndex int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// passed in the client hello info, "localhost" if unset
0000000000000000000000000000000000000000;;			ServerName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// optional ip or hostname to pass to NewLoopbackClientConfig
0000000000000000000000000000000000000000;;			LoopbackClientBindAddressOverride string
0000000000000000000000000000000000000000;;			ExpectLoopbackClientError         bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"only one cert": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "localhost",
0000000000000000000000000000000000000000;;					ips:  []string{"127.0.0.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: -1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"cert with multiple alternate names": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host:  "localhost",
0000000000000000000000000000000000000000;;					names: []string{"test.com"},
0000000000000000000000000000000000000000;;					ips:   []string{"127.0.0.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: -1,
0000000000000000000000000000000000000000;;				ServerName:        "test.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"one SNI and the default cert with the same name": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "localhost",
0000000000000000000000000000000000000000;;					ips:  []string{"127.0.0.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SNICerts: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "localhost",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"matching SNI cert": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "localhost",
0000000000000000000000000000000000000000;;					ips:  []string{"127.0.0.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SNICerts: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: 0,
0000000000000000000000000000000000000000;;				ServerName:        "test.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"matching IP in SNI cert and the server cert": {
0000000000000000000000000000000000000000;;				// IPs must not be passed via SNI. Hence, the ServerName in the
0000000000000000000000000000000000000000;;				// HELLO packet is empty and the server should select the non-SNI cert.
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "localhost",
0000000000000000000000000000000000000000;;					ips:  []string{"10.0.0.1", "127.0.0.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SNICerts: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "test.com",
0000000000000000000000000000000000000000;;							ips:  []string{"10.0.0.1"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: -1,
0000000000000000000000000000000000000000;;				ServerName:        "10.0.0.1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"wildcards": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "localhost",
0000000000000000000000000000000000000000;;					ips:  []string{"127.0.0.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SNICerts: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host:  "test.com",
0000000000000000000000000000000000000000;;							names: []string{"*.test.com"},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: 0,
0000000000000000000000000000000000000000;;				ServerName:        "www.test.com",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"loopback: LoopbackClientServerNameOverride not on any cert": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "test.com",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SNICerts: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "localhost",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"loopback: LoopbackClientServerNameOverride on server cert": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: server.LoopbackClientServerNameOverride,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SNICerts: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: "localhost",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"loopback: LoopbackClientServerNameOverride on SNI cert": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "localhost",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				SNICerts: []NamedTestCertSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						TestCertSpec: TestCertSpec{
0000000000000000000000000000000000000000;;							host: server.LoopbackClientServerNameOverride,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex: -1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"loopback: bind to 0.0.0.0 => loopback uses localhost": {
0000000000000000000000000000000000000000;;				Cert: TestCertSpec{
0000000000000000000000000000000000000000;;					host: "localhost",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedCertIndex:                 -1,
0000000000000000000000000000000000000000;;				LoopbackClientBindAddressOverride: "0.0.0.0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		specToName := func(spec TestCertSpec) string {
0000000000000000000000000000000000000000;;			name := spec.host + "_" + strings.Join(spec.names, ",") + "_" + strings.Join(spec.ips, ",")
0000000000000000000000000000000000000000;;			return strings.Replace(name, "*", "star", -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	NextTest:
0000000000000000000000000000000000000000;;		for title, test := range tests {
0000000000000000000000000000000000000000;;			// create server cert
0000000000000000000000000000000000000000;;			certDir := "testdata/" + specToName(test.Cert)
0000000000000000000000000000000000000000;;			serverCertBundleFile := filepath.Join(certDir, "cert")
0000000000000000000000000000000000000000;;			serverKeyFile := filepath.Join(certDir, "key")
0000000000000000000000000000000000000000;;			err := getOrCreateTestCertFiles(serverCertBundleFile, serverKeyFile, test.Cert)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%q - failed to create server cert: %v", title, err)
0000000000000000000000000000000000000000;;				continue NextTest
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ca, err := caCertFromBundle(serverCertBundleFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%q - failed to extract ca cert from server cert bundle: %v", title, err)
0000000000000000000000000000000000000000;;				continue NextTest
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			caCerts := []*x509.Certificate{ca}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// create SNI certs
0000000000000000000000000000000000000000;;			var namedCertKeys []utilflag.NamedCertKey
0000000000000000000000000000000000000000;;			serverSig, err := certFileSignature(serverCertBundleFile, serverKeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%q - failed to get server cert signature: %v", title, err)
0000000000000000000000000000000000000000;;				continue NextTest
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			signatures := map[string]int{
0000000000000000000000000000000000000000;;				serverSig: -1,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j, c := range test.SNICerts {
0000000000000000000000000000000000000000;;				sniDir := filepath.Join(certDir, specToName(c.TestCertSpec))
0000000000000000000000000000000000000000;;				certBundleFile := filepath.Join(sniDir, "cert")
0000000000000000000000000000000000000000;;				keyFile := filepath.Join(sniDir, "key")
0000000000000000000000000000000000000000;;				err := getOrCreateTestCertFiles(certBundleFile, keyFile, c.TestCertSpec)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed to create SNI cert %d: %v", title, j, err)
0000000000000000000000000000000000000000;;					continue NextTest
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				namedCertKeys = append(namedCertKeys, utilflag.NamedCertKey{
0000000000000000000000000000000000000000;;					KeyFile:  keyFile,
0000000000000000000000000000000000000000;;					CertFile: certBundleFile,
0000000000000000000000000000000000000000;;					Names:    c.explicitNames,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ca, err := caCertFromBundle(certBundleFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed to extract ca cert from SNI cert %d: %v", title, j, err)
0000000000000000000000000000000000000000;;					continue NextTest
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				caCerts = append(caCerts, ca)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// store index in namedCertKeys with the signature as the key
0000000000000000000000000000000000000000;;				sig, err := certFileSignature(certBundleFile, keyFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed get SNI cert %d signature: %v", title, j, err)
0000000000000000000000000000000000000000;;					continue NextTest
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				signatures[sig] = j
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				defer close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// launch server
0000000000000000000000000000000000000000;;				config := setUp(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				v := fakeVersion()
0000000000000000000000000000000000000000;;				config.Version = &v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				config.EnableIndex = true
0000000000000000000000000000000000000000;;				secureOptions := &SecureServingOptions{
0000000000000000000000000000000000000000;;					BindAddress: net.ParseIP("127.0.0.1"),
0000000000000000000000000000000000000000;;					BindPort:    6443,
0000000000000000000000000000000000000000;;					ServerCert: GeneratableKeyCert{
0000000000000000000000000000000000000000;;						CertKey: CertKey{
0000000000000000000000000000000000000000;;							CertFile: serverCertBundleFile,
0000000000000000000000000000000000000000;;							KeyFile:  serverKeyFile,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					SNICertKeys: namedCertKeys,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				config.LoopbackClientConfig = &restclient.Config{}
0000000000000000000000000000000000000000;;				if err := secureOptions.ApplyTo(&config); err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed applying the SecureServingOptions: %v", title, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				s, err := config.Complete().New("test", server.EmptyDelegate)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed creating the server: %v", title, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// patch in a 0-port to enable auto port allocation
0000000000000000000000000000000000000000;;				s.SecureServingInfo.BindAddress = "127.0.0.1:0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// add poststart hook to know when the server is up.
0000000000000000000000000000000000000000;;				startedCh := make(chan struct{})
0000000000000000000000000000000000000000;;				s.AddPostStartHook("test-notifier", func(context PostStartHookContext) error {
0000000000000000000000000000000000000000;;					close(startedCh)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				preparedServer := s.PrepareRun()
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					if err := preparedServer.Run(stopCh); err != nil {
0000000000000000000000000000000000000000;;						t.Fatal(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// load ca certificates into a pool
0000000000000000000000000000000000000000;;				roots := x509.NewCertPool()
0000000000000000000000000000000000000000;;				for _, caCert := range caCerts {
0000000000000000000000000000000000000000;;					roots.AddCert(caCert)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				<-startedCh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				effectiveSecurePort := fmt.Sprintf("%d", preparedServer.EffectiveSecurePort())
0000000000000000000000000000000000000000;;				// try to dial
0000000000000000000000000000000000000000;;				addr := fmt.Sprintf("localhost:%s", effectiveSecurePort)
0000000000000000000000000000000000000000;;				t.Logf("Dialing %s as %q", addr, test.ServerName)
0000000000000000000000000000000000000000;;				conn, err := tls.Dial("tcp", addr, &tls.Config{
0000000000000000000000000000000000000000;;					RootCAs:    roots,
0000000000000000000000000000000000000000;;					ServerName: test.ServerName, // used for SNI in the client HELLO packet
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed to connect: %v", title, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check returned server certificate
0000000000000000000000000000000000000000;;				sig := x509CertSignature(conn.ConnectionState().PeerCertificates[0])
0000000000000000000000000000000000000000;;				gotCertIndex, found := signatures[sig]
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					t.Errorf("%q - unknown signature returned from server: %s", title, sig)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if gotCertIndex != test.ExpectedCertIndex {
0000000000000000000000000000000000000000;;					t.Errorf("%q - expected cert index %d, got cert index %d", title, test.ExpectedCertIndex, gotCertIndex)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check that the loopback client can connect
0000000000000000000000000000000000000000;;				host := "127.0.0.1"
0000000000000000000000000000000000000000;;				if len(test.LoopbackClientBindAddressOverride) != 0 {
0000000000000000000000000000000000000000;;					host = test.LoopbackClientBindAddressOverride
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.LoopbackClientConfig.Host = net.JoinHostPort(host, effectiveSecurePort)
0000000000000000000000000000000000000000;;				if test.ExpectLoopbackClientError {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Errorf("%q - expected error creating loopback client config", title)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed creating loopback client config: %v", title, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				client, err := discovery.NewDiscoveryClientForConfig(s.LoopbackClientConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed to create loopback client: %v", title, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				got, err := client.ServerVersion()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%q - failed to connect with loopback client: %v", title, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if expected := &v; !reflect.DeepEqual(got, expected) {
0000000000000000000000000000000000000000;;					t.Errorf("%q - loopback client didn't get correct version info: expected=%v got=%v", title, expected, got)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseIPList(ips []string) []net.IP {
0000000000000000000000000000000000000000;;		var netIPs []net.IP
0000000000000000000000000000000000000000;;		for _, ip := range ips {
0000000000000000000000000000000000000000;;			netIPs = append(netIPs, net.ParseIP(ip))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return netIPs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createTestTLSCerts(spec TestCertSpec) (tlsCert tls.Certificate, err error) {
0000000000000000000000000000000000000000;;		certPem, keyPem, err := generateSelfSignedCertKey(spec.host, parseIPList(spec.ips), spec.names)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return tlsCert, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsCert, err = tls.X509KeyPair(certPem, keyPem)
0000000000000000000000000000000000000000;;		return tlsCert, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOrCreateTestCertFiles(certFileName, keyFileName string, spec TestCertSpec) (err error) {
0000000000000000000000000000000000000000;;		if _, err := os.Stat(certFileName); err == nil {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(keyFileName); err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certPem, keyPem, err := generateSelfSignedCertKey(spec.host, parseIPList(spec.ips), spec.names)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os.MkdirAll(filepath.Dir(certFileName), os.FileMode(0755))
0000000000000000000000000000000000000000;;		err = ioutil.WriteFile(certFileName, certPem, os.FileMode(0755))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os.MkdirAll(filepath.Dir(keyFileName), os.FileMode(0755))
0000000000000000000000000000000000000000;;		err = ioutil.WriteFile(keyFileName, keyPem, os.FileMode(0755))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func caCertFromBundle(bundlePath string) (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		pemData, err := ioutil.ReadFile(bundlePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fetch last block
0000000000000000000000000000000000000000;;		var block *pem.Block
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var nextBlock *pem.Block
0000000000000000000000000000000000000000;;			nextBlock, pemData = pem.Decode(pemData)
0000000000000000000000000000000000000000;;			if nextBlock == nil {
0000000000000000000000000000000000000000;;				if block == nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("no certificate found in %q", bundlePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return x509.ParseCertificate(block.Bytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			block = nextBlock
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func x509CertSignature(cert *x509.Certificate) string {
0000000000000000000000000000000000000000;;		return base64.StdEncoding.EncodeToString(cert.Signature)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func certFileSignature(certFile, keyFile string) (string, error) {
0000000000000000000000000000000000000000;;		cert, err := tls.LoadX509KeyPair(certFile, keyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certSignature(cert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func certSignature(cert tls.Certificate) (string, error) {
0000000000000000000000000000000000000000;;		x509Certs, err := x509.ParseCertificates(cert.Certificate[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x509CertSignature(x509Certs[0]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeVersion() version.Info {
0000000000000000000000000000000000000000;;		return version.Info{
0000000000000000000000000000000000000000;;			Major:        "42",
0000000000000000000000000000000000000000;;			Minor:        "42",
0000000000000000000000000000000000000000;;			GitVersion:   "42",
0000000000000000000000000000000000000000;;			GitCommit:    "34973274ccef6ab4dfaaf86599792fa9c3fe4689",
0000000000000000000000000000000000000000;;			GitTreeState: "Dirty",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateSelfSignedCertKey creates a self-signed certificate and key for the given host.
0000000000000000000000000000000000000000;;	// Host may be an IP or a DNS name
0000000000000000000000000000000000000000;;	// You may also specify additional subject alt names (either ip or dns names) for the certificate
0000000000000000000000000000000000000000;;	func generateSelfSignedCertKey(host string, alternateIPs []net.IP, alternateDNS []string) ([]byte, []byte, error) {
0000000000000000000000000000000000000000;;		priv, err := rsa.GenerateKey(cryptorand.Reader, 2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template := x509.Certificate{
0000000000000000000000000000000000000000;;			SerialNumber: big.NewInt(1),
0000000000000000000000000000000000000000;;			Subject: pkix.Name{
0000000000000000000000000000000000000000;;				CommonName: fmt.Sprintf("%s@%d", host, time.Now().Unix()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NotBefore: time.Unix(0, 0),
0000000000000000000000000000000000000000;;			NotAfter:  time.Now().Add(time.Hour * 24 * 365 * 100),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
0000000000000000000000000000000000000000;;			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;			BasicConstraintsValid: true,
0000000000000000000000000000000000000000;;			IsCA: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ip := net.ParseIP(host); ip != nil {
0000000000000000000000000000000000000000;;			template.IPAddresses = append(template.IPAddresses, ip)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			template.DNSNames = append(template.DNSNames, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template.IPAddresses = append(template.IPAddresses, alternateIPs...)
0000000000000000000000000000000000000000;;		template.DNSNames = append(template.DNSNames, alternateDNS...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		derBytes, err := x509.CreateCertificate(cryptorand.Reader, &template, &template, &priv.PublicKey, priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate cert
0000000000000000000000000000000000000000;;		certBuffer := bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := pem.Encode(&certBuffer, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes}); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate key
0000000000000000000000000000000000000000;;		keyBuffer := bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := pem.Encode(&keyBuffer, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(priv)}); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return certBuffer.Bytes(), keyBuffer.Bytes(), nil
0000000000000000000000000000000000000000;;	}
