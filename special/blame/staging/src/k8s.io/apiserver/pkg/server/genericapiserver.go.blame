0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c99a81742508523017bdbe3484265831a43d073a;pkg/genericapiserver/genericapiserver.go[pkg/genericapiserver/genericapiserver.go][staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		systemd "github.com/coreos/go-systemd/daemon"
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		openapicommon "k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/audit"
0000000000000000000000000000000000000000;;		genericapi "k8s.io/apiserver/pkg/endpoints"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/discovery"
0000000000000000000000000000000000000000;;		apirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/routes"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Info about an API group.
0000000000000000000000000000000000000000;;	type APIGroupInfo struct {
0000000000000000000000000000000000000000;;		GroupMeta apimachinery.GroupMeta
0000000000000000000000000000000000000000;;		// Info about the resources in this group. Its a map from version to resource to the storage.
0000000000000000000000000000000000000000;;		VersionedResourcesStorageMap map[string]map[string]rest.Storage
0000000000000000000000000000000000000000;;		// OptionsExternalVersion controls the APIVersion used for common objects in the
0000000000000000000000000000000000000000;;		// schema like api.Status, api.DeleteOptions, and metav1.ListOptions. Other implementors may
0000000000000000000000000000000000000000;;		// define a version "v1beta1" but want to use the Kubernetes "v1" internal objects.
0000000000000000000000000000000000000000;;		// If nil, defaults to groupMeta.GroupVersion.
0000000000000000000000000000000000000000;;		// TODO: Remove this when https://github.com/kubernetes/kubernetes/issues/19018 is fixed.
0000000000000000000000000000000000000000;;		OptionsExternalVersion *schema.GroupVersion
0000000000000000000000000000000000000000;;		// MetaGroupVersion defaults to "meta.k8s.io/v1" and is the scheme group version used to decode
0000000000000000000000000000000000000000;;		// common API implementations like ListOptions. Future changes will allow this to vary by group
0000000000000000000000000000000000000000;;		// version (for when the inevitable meta/v2 group emerges).
0000000000000000000000000000000000000000;;		MetaGroupVersion *schema.GroupVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scheme includes all of the types used by this group and how to convert between them (or
0000000000000000000000000000000000000000;;		// to convert objects from outside of this group that are accepted in this API).
0000000000000000000000000000000000000000;;		// TODO: replace with interfaces
0000000000000000000000000000000000000000;;		Scheme *runtime.Scheme
0000000000000000000000000000000000000000;;		// NegotiatedSerializer controls how this group encodes and decodes data
0000000000000000000000000000000000000000;;		NegotiatedSerializer runtime.NegotiatedSerializer
0000000000000000000000000000000000000000;;		// ParameterCodec performs conversions for query parameters passed to API calls
0000000000000000000000000000000000000000;;		ParameterCodec runtime.ParameterCodec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SubresourceGroupVersionKind contains the GroupVersionKind overrides for each subresource that is
0000000000000000000000000000000000000000;;		// accessible from this API group version. The GroupVersionKind is that of the external version of
0000000000000000000000000000000000000000;;		// the subresource. The key of this map should be the path of the subresource. The keys here should
0000000000000000000000000000000000000000;;		// match the keys in the Storage map above for subresources.
0000000000000000000000000000000000000000;;		SubresourceGroupVersionKind map[string]schema.GroupVersionKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenericAPIServer contains state for a Kubernetes cluster api server.
0000000000000000000000000000000000000000;;	type GenericAPIServer struct {
0000000000000000000000000000000000000000;;		// discoveryAddresses is used to build cluster IPs for discovery.
0000000000000000000000000000000000000000;;		discoveryAddresses discovery.Addresses
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LoopbackClientConfig is a config for a privileged loopback connection to the API server
0000000000000000000000000000000000000000;;		LoopbackClientConfig *restclient.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// minRequestTimeout is how short the request timeout can be.  This is used to build the RESTHandler
0000000000000000000000000000000000000000;;		minRequestTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// legacyAPIGroupPrefixes is used to set up URL parsing for authorization and for validating requests
0000000000000000000000000000000000000000;;		// to InstallLegacyAPIGroup
0000000000000000000000000000000000000000;;		legacyAPIGroupPrefixes sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// admissionControl is used to build the RESTStorage that backs an API Group.
0000000000000000000000000000000000000000;;		admissionControl admission.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// requestContextMapper provides a way to get the context for a request.  It may be nil.
0000000000000000000000000000000000000000;;		requestContextMapper apirequest.RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SecureServingInfo *SecureServingInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// numerical ports, set after listening
0000000000000000000000000000000000000000;;		effectiveSecurePort int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExternalAddress is the address (hostname or IP and port) that should be used in
0000000000000000000000000000000000000000;;		// external (public internet) URLs for this GenericAPIServer.
0000000000000000000000000000000000000000;;		ExternalAddress string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// storage contains the RESTful endpoints exposed by this GenericAPIServer
0000000000000000000000000000000000000000;;		storage map[string]rest.Storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Serializer controls how common API objects not in a group/version prefix are serialized for this server.
0000000000000000000000000000000000000000;;		// Individual APIGroups may define their own serializers.
0000000000000000000000000000000000000000;;		Serializer runtime.NegotiatedSerializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "Outputs"
0000000000000000000000000000000000000000;;		// Handler holdes the handlers being used by this API server
0000000000000000000000000000000000000000;;		Handler *APIServerHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listedPathProvider is a lister which provides the set of paths to show at /
0000000000000000000000000000000000000000;;		listedPathProvider routes.ListedPathProvider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DiscoveryGroupManager serves /apis
0000000000000000000000000000000000000000;;		DiscoveryGroupManager discovery.GroupManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enable swagger and/or OpenAPI if these configs are non-nil.
0000000000000000000000000000000000000000;;		swaggerConfig *swagger.Config
0000000000000000000000000000000000000000;;		openAPIConfig *openapicommon.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enables updating OpenAPI spec using update method.
0000000000000000000000000000000000000000;;		OpenAPIService *openapi.OpenAPIService
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PostStartHooks are each called after the server has started listening, in a separate go func for each
0000000000000000000000000000000000000000;;		// with no guarantee of ordering between them.  The map key is a name used for error reporting.
0000000000000000000000000000000000000000;;		// It may kill the process with a panic if it wishes to by returning an error.
0000000000000000000000000000000000000000;;		postStartHookLock      sync.Mutex
0000000000000000000000000000000000000000;;		postStartHooks         map[string]postStartHookEntry
0000000000000000000000000000000000000000;;		postStartHooksCalled   bool
0000000000000000000000000000000000000000;;		disabledPostStartHooks sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// healthz checks
0000000000000000000000000000000000000000;;		healthzLock    sync.Mutex
0000000000000000000000000000000000000000;;		healthzChecks  []healthz.HealthzChecker
0000000000000000000000000000000000000000;;		healthzCreated bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// auditing. The backend is started after the server starts listening.
0000000000000000000000000000000000000000;;		AuditBackend audit.Backend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// enableAPIResponseCompression indicates whether API Responses should support compression
0000000000000000000000000000000000000000;;		// if the client requests it via Accept-Encoding
0000000000000000000000000000000000000000;;		enableAPIResponseCompression bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelegationTarget is an interface which allows for composition of API servers with top level handling that works
0000000000000000000000000000000000000000;;	// as expected.
0000000000000000000000000000000000000000;;	type DelegationTarget interface {
0000000000000000000000000000000000000000;;		// UnprotectedHandler returns a handler that is NOT protected by a normal chain
0000000000000000000000000000000000000000;;		UnprotectedHandler() http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequestContextMapper returns the existing RequestContextMapper.  Because we cannot rewire all existing
0000000000000000000000000000000000000000;;		// uses of this function, this will be used in any delegating API server
0000000000000000000000000000000000000000;;		RequestContextMapper() apirequest.RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PostStartHooks returns the post-start hooks that need to be combined
0000000000000000000000000000000000000000;;		PostStartHooks() map[string]postStartHookEntry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HealthzChecks returns the healthz checks that need to be combined
0000000000000000000000000000000000000000;;		HealthzChecks() []healthz.HealthzChecker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListedPaths returns the paths for supporting an index
0000000000000000000000000000000000000000;;		ListedPaths() []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OpenAPISpec returns the OpenAPI spec of the delegation target if exists, nil otherwise.
0000000000000000000000000000000000000000;;		OpenAPISpec() *spec.Swagger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) UnprotectedHandler() http.Handler {
0000000000000000000000000000000000000000;;		// when we delegate, we need the server we're delegating to choose whether or not to use gorestful
0000000000000000000000000000000000000000;;		return s.Handler.Director
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) PostStartHooks() map[string]postStartHookEntry {
0000000000000000000000000000000000000000;;		return s.postStartHooks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) HealthzChecks() []healthz.HealthzChecker {
0000000000000000000000000000000000000000;;		return s.healthzChecks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) ListedPaths() []string {
0000000000000000000000000000000000000000;;		return s.listedPathProvider.ListedPaths()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) OpenAPISpec() *spec.Swagger {
0000000000000000000000000000000000000000;;		return s.OpenAPIService.GetSpec()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var EmptyDelegate = emptyDelegate{
0000000000000000000000000000000000000000;;		requestContextMapper: apirequest.NewRequestContextMapper(),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type emptyDelegate struct {
0000000000000000000000000000000000000000;;		requestContextMapper apirequest.RequestContextMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s emptyDelegate) UnprotectedHandler() http.Handler {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s emptyDelegate) PostStartHooks() map[string]postStartHookEntry {
0000000000000000000000000000000000000000;;		return map[string]postStartHookEntry{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s emptyDelegate) HealthzChecks() []healthz.HealthzChecker {
0000000000000000000000000000000000000000;;		return []healthz.HealthzChecker{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s emptyDelegate) ListedPaths() []string {
0000000000000000000000000000000000000000;;		return []string{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s emptyDelegate) RequestContextMapper() apirequest.RequestContextMapper {
0000000000000000000000000000000000000000;;		return s.requestContextMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s emptyDelegate) OpenAPISpec() *spec.Swagger {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestContextMapper is exposed so that third party resource storage can be build in a different location.
0000000000000000000000000000000000000000;;	// TODO refactor third party resource storage
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) RequestContextMapper() apirequest.RequestContextMapper {
0000000000000000000000000000000000000000;;		return s.requestContextMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinRequestTimeout is exposed so that third party resource storage can be build in a different location.
0000000000000000000000000000000000000000;;	// TODO refactor third party resource storage
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) MinRequestTimeout() time.Duration {
0000000000000000000000000000000000000000;;		return s.minRequestTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type preparedGenericAPIServer struct {
0000000000000000000000000000000000000000;;		*GenericAPIServer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareRun does post API installation setup steps.
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) PrepareRun() preparedGenericAPIServer {
0000000000000000000000000000000000000000;;		if s.swaggerConfig != nil {
0000000000000000000000000000000000000000;;			routes.Swagger{Config: s.swaggerConfig}.Install(s.Handler.GoRestfulContainer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.PrepareOpenAPIService()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.installHealthz()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return preparedGenericAPIServer{s}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareOpenAPIService installs OpenAPI handler if it does not exists.
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) PrepareOpenAPIService() {
0000000000000000000000000000000000000000;;		if s.openAPIConfig != nil && s.OpenAPIService == nil {
0000000000000000000000000000000000000000;;			s.OpenAPIService = routes.OpenAPI{
0000000000000000000000000000000000000000;;				Config: s.openAPIConfig,
0000000000000000000000000000000000000000;;			}.Install(s.Handler.GoRestfulContainer, s.Handler.NonGoRestfulMux)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run spawns the secure http server. It only returns if stopCh is closed
0000000000000000000000000000000000000000;;	// or the secure port cannot be listened on initially.
0000000000000000000000000000000000000000;;	func (s preparedGenericAPIServer) Run(stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		err := s.NonBlockingRun(stopCh)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NonBlockingRun spawns the secure http server. An error is
0000000000000000000000000000000000000000;;	// returned if the secure port cannot be listened on.
0000000000000000000000000000000000000000;;	func (s preparedGenericAPIServer) NonBlockingRun(stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		// Use an internal stop channel to allow cleanup of the listeners on error.
0000000000000000000000000000000000000000;;		internalStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.SecureServingInfo != nil && s.Handler != nil {
0000000000000000000000000000000000000000;;			if err := s.serveSecurely(internalStopCh); err != nil {
0000000000000000000000000000000000000000;;				close(internalStopCh)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now that listener have bound successfully, it is the
0000000000000000000000000000000000000000;;		// responsibility of the caller to close the provided channel to
0000000000000000000000000000000000000000;;		// ensure cleanup.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-stopCh
0000000000000000000000000000000000000000;;			close(internalStopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the audit backend before any request comes in. This means we cannot turn it into a
0000000000000000000000000000000000000000;;		// post start hook because without calling Backend.Run the Backend.ProcessEvents call might block.
0000000000000000000000000000000000000000;;		if s.AuditBackend != nil {
0000000000000000000000000000000000000000;;			if err := s.AuditBackend.Run(stopCh); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to run the audit backend: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.RunPostStartHooks(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := systemd.SdNotify(true, "READY=1\n"); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to send systemd daemon successful start message: %v\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EffectiveSecurePort returns the secure port we bound to.
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) EffectiveSecurePort() int {
0000000000000000000000000000000000000000;;		return s.effectiveSecurePort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// installAPIResources is a private method for installing the REST storage backing each api groupversionresource
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) installAPIResources(apiPrefix string, apiGroupInfo *APIGroupInfo) error {
0000000000000000000000000000000000000000;;		for _, groupVersion := range apiGroupInfo.GroupMeta.GroupVersions {
0000000000000000000000000000000000000000;;			if len(apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]) == 0 {
0000000000000000000000000000000000000000;;				glog.Warningf("Skipping API %v because it has no resources.", groupVersion)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			apiGroupVersion := s.getAPIGroupVersion(apiGroupInfo, groupVersion, apiPrefix)
0000000000000000000000000000000000000000;;			if apiGroupInfo.OptionsExternalVersion != nil {
0000000000000000000000000000000000000000;;				apiGroupVersion.OptionsExternalVersion = apiGroupInfo.OptionsExternalVersion
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := apiGroupVersion.InstallREST(s.Handler.GoRestfulContainer); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to setup API %v: %v", apiGroupInfo, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) InstallLegacyAPIGroup(apiPrefix string, apiGroupInfo *APIGroupInfo) error {
0000000000000000000000000000000000000000;;		if !s.legacyAPIGroupPrefixes.Has(apiPrefix) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%q is not in the allowed legacy API prefixes: %v", apiPrefix, s.legacyAPIGroupPrefixes.List())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.installAPIResources(apiPrefix, apiGroupInfo); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// setup discovery
0000000000000000000000000000000000000000;;		apiVersions := []string{}
0000000000000000000000000000000000000000;;		for _, groupVersion := range apiGroupInfo.GroupMeta.GroupVersions {
0000000000000000000000000000000000000000;;			apiVersions = append(apiVersions, groupVersion.Version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Install the version handler.
0000000000000000000000000000000000000000;;		// Add a handler at /<apiPrefix> to enumerate the supported api versions.
0000000000000000000000000000000000000000;;		s.Handler.GoRestfulContainer.Add(discovery.NewLegacyRootAPIHandler(s.discoveryAddresses, s.Serializer, apiPrefix, apiVersions, s.requestContextMapper).WebService())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exposes the given api group in the API.
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) InstallAPIGroup(apiGroupInfo *APIGroupInfo) error {
0000000000000000000000000000000000000000;;		// Do not register empty group or empty version.  Doing so claims /apis/ for the wrong entity to be returned.
0000000000000000000000000000000000000000;;		// Catching these here places the error  much closer to its origin
0000000000000000000000000000000000000000;;		if len(apiGroupInfo.GroupMeta.GroupVersion.Group) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot register handler with an empty group for %#v", *apiGroupInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(apiGroupInfo.GroupMeta.GroupVersion.Version) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot register handler with an empty version for %#v", *apiGroupInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.installAPIResources(APIGroupPrefix, apiGroupInfo); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// setup discovery
0000000000000000000000000000000000000000;;		// Install the version handler.
0000000000000000000000000000000000000000;;		// Add a handler at /apis/<groupName> to enumerate all versions supported by this group.
0000000000000000000000000000000000000000;;		apiVersionsForDiscovery := []metav1.GroupVersionForDiscovery{}
0000000000000000000000000000000000000000;;		for _, groupVersion := range apiGroupInfo.GroupMeta.GroupVersions {
0000000000000000000000000000000000000000;;			// Check the config to make sure that we elide versions that don't have any resources
0000000000000000000000000000000000000000;;			if len(apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version]) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			apiVersionsForDiscovery = append(apiVersionsForDiscovery, metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;				GroupVersion: groupVersion.String(),
0000000000000000000000000000000000000000;;				Version:      groupVersion.Version,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		preferredVersionForDiscovery := metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;			GroupVersion: apiGroupInfo.GroupMeta.GroupVersion.String(),
0000000000000000000000000000000000000000;;			Version:      apiGroupInfo.GroupMeta.GroupVersion.Version,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiGroup := metav1.APIGroup{
0000000000000000000000000000000000000000;;			Name:             apiGroupInfo.GroupMeta.GroupVersion.Group,
0000000000000000000000000000000000000000;;			Versions:         apiVersionsForDiscovery,
0000000000000000000000000000000000000000;;			PreferredVersion: preferredVersionForDiscovery,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.DiscoveryGroupManager.AddGroup(apiGroup)
0000000000000000000000000000000000000000;;		s.Handler.GoRestfulContainer.Add(discovery.NewAPIGroupHandler(s.Serializer, apiGroup, s.requestContextMapper).WebService())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) getAPIGroupVersion(apiGroupInfo *APIGroupInfo, groupVersion schema.GroupVersion, apiPrefix string) *genericapi.APIGroupVersion {
0000000000000000000000000000000000000000;;		storage := make(map[string]rest.Storage)
0000000000000000000000000000000000000000;;		for k, v := range apiGroupInfo.VersionedResourcesStorageMap[groupVersion.Version] {
0000000000000000000000000000000000000000;;			storage[strings.ToLower(k)] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version := s.newAPIGroupVersion(apiGroupInfo, groupVersion)
0000000000000000000000000000000000000000;;		version.Root = apiPrefix
0000000000000000000000000000000000000000;;		version.Storage = storage
0000000000000000000000000000000000000000;;		return version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *GenericAPIServer) newAPIGroupVersion(apiGroupInfo *APIGroupInfo, groupVersion schema.GroupVersion) *genericapi.APIGroupVersion {
0000000000000000000000000000000000000000;;		return &genericapi.APIGroupVersion{
0000000000000000000000000000000000000000;;			GroupVersion:     groupVersion,
0000000000000000000000000000000000000000;;			MetaGroupVersion: apiGroupInfo.MetaGroupVersion,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ParameterCodec:  apiGroupInfo.ParameterCodec,
0000000000000000000000000000000000000000;;			Serializer:      apiGroupInfo.NegotiatedSerializer,
0000000000000000000000000000000000000000;;			Creater:         apiGroupInfo.Scheme,
0000000000000000000000000000000000000000;;			Convertor:       apiGroupInfo.Scheme,
0000000000000000000000000000000000000000;;			UnsafeConvertor: runtime.UnsafeObjectConvertor(apiGroupInfo.Scheme),
0000000000000000000000000000000000000000;;			Copier:          apiGroupInfo.Scheme,
0000000000000000000000000000000000000000;;			Defaulter:       apiGroupInfo.Scheme,
0000000000000000000000000000000000000000;;			Typer:           apiGroupInfo.Scheme,
0000000000000000000000000000000000000000;;			SubresourceGroupVersionKind: apiGroupInfo.SubresourceGroupVersionKind,
0000000000000000000000000000000000000000;;			Linker: apiGroupInfo.GroupMeta.SelfLinker,
0000000000000000000000000000000000000000;;			Mapper: apiGroupInfo.GroupMeta.RESTMapper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Admit:                        s.admissionControl,
0000000000000000000000000000000000000000;;			Context:                      s.RequestContextMapper(),
0000000000000000000000000000000000000000;;			MinRequestTimeout:            s.minRequestTimeout,
0000000000000000000000000000000000000000;;			EnableAPIResponseCompression: s.enableAPIResponseCompression,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultAPIGroupInfo returns an APIGroupInfo stubbed with "normal" values
0000000000000000000000000000000000000000;;	// exposed for easier composition from other packages
0000000000000000000000000000000000000000;;	func NewDefaultAPIGroupInfo(group string, registry *registered.APIRegistrationManager, scheme *runtime.Scheme, parameterCodec runtime.ParameterCodec, codecs serializer.CodecFactory) APIGroupInfo {
0000000000000000000000000000000000000000;;		groupMeta := registry.GroupOrDie(group)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return APIGroupInfo{
0000000000000000000000000000000000000000;;			GroupMeta:                    *groupMeta,
0000000000000000000000000000000000000000;;			VersionedResourcesStorageMap: map[string]map[string]rest.Storage{},
0000000000000000000000000000000000000000;;			// TODO unhardcode this.  It was hardcoded before, but we need to re-evaluate
0000000000000000000000000000000000000000;;			OptionsExternalVersion: &schema.GroupVersion{Version: "v1"},
0000000000000000000000000000000000000000;;			Scheme:                 scheme,
0000000000000000000000000000000000000000;;			ParameterCodec:         parameterCodec,
0000000000000000000000000000000000000000;;			NegotiatedSerializer:   codecs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
