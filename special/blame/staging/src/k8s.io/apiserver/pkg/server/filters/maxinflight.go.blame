0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8e5dbdd02c2eaa420abecbec0f800f9e5c8f9f8b;pkg/genericapiserver/filters/maxinflight.go[pkg/genericapiserver/filters/maxinflight.go][staging/src/k8s.io/apiserver/pkg/server/filters/maxinflight.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/metrics"
0000000000000000000000000000000000000000;;		apirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constant for the retry-after interval on rate limiting.
0000000000000000000000000000000000000000;;	// TODO: maybe make this dynamic? or user-adjustable?
0000000000000000000000000000000000000000;;	const retryAfter = "1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nonMutatingRequestVerbs = sets.NewString("get", "list", "watch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleError(w http.ResponseWriter, r *http.Request, err error) {
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "Internal Server Error: %#v", r.RequestURI)
0000000000000000000000000000000000000000;;		glog.Errorf(err.Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMaxInFlightLimit limits the number of in-flight requests to buffer size of the passed in channel.
0000000000000000000000000000000000000000;;	func WithMaxInFlightLimit(
0000000000000000000000000000000000000000;;		handler http.Handler,
0000000000000000000000000000000000000000;;		nonMutatingLimit int,
0000000000000000000000000000000000000000;;		mutatingLimit int,
0000000000000000000000000000000000000000;;		requestContextMapper genericapirequest.RequestContextMapper,
0000000000000000000000000000000000000000;;		longRunningRequestCheck apirequest.LongRunningRequestCheck,
0000000000000000000000000000000000000000;;	) http.Handler {
0000000000000000000000000000000000000000;;		if nonMutatingLimit == 0 && mutatingLimit == 0 {
0000000000000000000000000000000000000000;;			return handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var nonMutatingChan chan bool
0000000000000000000000000000000000000000;;		var mutatingChan chan bool
0000000000000000000000000000000000000000;;		if nonMutatingLimit != 0 {
0000000000000000000000000000000000000000;;			nonMutatingChan = make(chan bool, nonMutatingLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mutatingLimit != 0 {
0000000000000000000000000000000000000000;;			mutatingChan = make(chan bool, mutatingLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			ctx, ok := requestContextMapper.Get(r)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				handleError(w, r, fmt.Errorf("no context found for request, handler chain must be wrong"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestInfo, ok := apirequest.RequestInfoFrom(ctx)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				handleError(w, r, fmt.Errorf("no RequestInfo found in context, handler chain must be wrong"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Skip tracking long running events.
0000000000000000000000000000000000000000;;			if longRunningRequestCheck != nil && longRunningRequestCheck(r, requestInfo) {
0000000000000000000000000000000000000000;;				handler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var c chan bool
0000000000000000000000000000000000000000;;			if !nonMutatingRequestVerbs.Has(requestInfo.Verb) {
0000000000000000000000000000000000000000;;				c = mutatingChan
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c = nonMutatingChan
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c == nil {
0000000000000000000000000000000000000000;;				handler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case c <- true:
0000000000000000000000000000000000000000;;					defer func() { <-c }()
0000000000000000000000000000000000000000;;					handler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					metrics.MonitorRequest(r, strings.ToUpper(requestInfo.Verb), requestInfo.Resource, requestInfo.Subresource, "", errors.StatusTooManyRequests, time.Now())
0000000000000000000000000000000000000000;;					tooManyRequests(r, w)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tooManyRequests(req *http.Request, w http.ResponseWriter) {
0000000000000000000000000000000000000000;;		// Return a 429 status indicating "Too Many Requests"
0000000000000000000000000000000000000000;;		w.Header().Set("Retry-After", retryAfter)
0000000000000000000000000000000000000000;;		http.Error(w, "Too many requests, please try again later.", errors.StatusTooManyRequests)
0000000000000000000000000000000000000000;;	}
