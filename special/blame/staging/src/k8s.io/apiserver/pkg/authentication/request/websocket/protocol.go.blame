0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
587e3b5c432f7623e2f9ee47e85ff13cbc09d6b6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package websocket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/textproto"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/util/wsstream"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const bearerProtocolPrefix = "base64url.bearer.authorization.k8s.io."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var protocolHeader = textproto.CanonicalMIMEHeaderKey("Sec-WebSocket-Protocol")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errInvalidToken = errors.New("invalid bearer token")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProtocolAuthenticator allows a websocket connection to provide a bearer token as a subprotocol
0000000000000000000000000000000000000000;;	// in the format "base64url.bearer.authorization.<base64url-without-padding(bearer-token)>"
0000000000000000000000000000000000000000;;	type ProtocolAuthenticator struct {
0000000000000000000000000000000000000000;;		// auth is the token authenticator to use to validate the token
0000000000000000000000000000000000000000;;		auth authenticator.Token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewProtocolAuthenticator(auth authenticator.Token) *ProtocolAuthenticator {
0000000000000000000000000000000000000000;;		return &ProtocolAuthenticator{auth}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *ProtocolAuthenticator) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		// Only accept websocket connections
0000000000000000000000000000000000000000;;		if !wsstream.IsWebSocketRequest(req) {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := ""
0000000000000000000000000000000000000000;;		sawTokenProtocol := false
0000000000000000000000000000000000000000;;		filteredProtocols := []string{}
0000000000000000000000000000000000000000;;		for _, protocolHeader := range req.Header[protocolHeader] {
0000000000000000000000000000000000000000;;			for _, protocol := range strings.Split(protocolHeader, ",") {
0000000000000000000000000000000000000000;;				protocol = strings.TrimSpace(protocol)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(protocol, bearerProtocolPrefix) {
0000000000000000000000000000000000000000;;					filteredProtocols = append(filteredProtocols, protocol)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if sawTokenProtocol {
0000000000000000000000000000000000000000;;					return nil, false, errors.New("multiple base64.bearer.authorization tokens specified")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sawTokenProtocol = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				encodedToken := strings.TrimPrefix(protocol, bearerProtocolPrefix)
0000000000000000000000000000000000000000;;				decodedToken, err := base64.RawURLEncoding.DecodeString(encodedToken)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, false, errors.New("invalid base64.bearer.authorization token encoding")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !utf8.Valid(decodedToken) {
0000000000000000000000000000000000000000;;					return nil, false, errors.New("invalid base64.bearer.authorization token")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				token = string(decodedToken)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must pass at least one other subprotocol so that we can remove the one containing the bearer token,
0000000000000000000000000000000000000000;;		// and there is at least one to echo back to the client
0000000000000000000000000000000000000000;;		if len(token) > 0 && len(filteredProtocols) == 0 {
0000000000000000000000000000000000000000;;			return nil, false, errors.New("missing additional subprotocol")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(token) == 0 {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user, ok, err := a.auth.AuthenticateToken(token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// on success, remove the protocol with the token
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			// https://tools.ietf.org/html/rfc6455#section-11.3.4 indicates the Sec-WebSocket-Protocol header may appear multiple times
0000000000000000000000000000000000000000;;			// in a request, and is logically the same as a single Sec-WebSocket-Protocol header field that contains all values
0000000000000000000000000000000000000000;;			req.Header.Set(protocolHeader, strings.Join(filteredProtocols, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the token authenticator didn't error, provide a default error
0000000000000000000000000000000000000000;;		if !ok && err == nil {
0000000000000000000000000000000000000000;;			err = errInvalidToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return user, ok, err
0000000000000000000000000000000000000000;;	}
