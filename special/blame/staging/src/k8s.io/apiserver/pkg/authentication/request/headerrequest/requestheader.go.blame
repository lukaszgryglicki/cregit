0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
007ba76f4acb1f785973677eec71dbe8e38e80be;plugin/pkg/auth/authenticator/request/headerrequest/requestheader.go[plugin/pkg/auth/authenticator/request/headerrequest/requestheader.go][staging/src/k8s.io/apiserver/pkg/authentication/request/headerrequest/requestheader.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package headerrequest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		x509request "k8s.io/apiserver/pkg/authentication/request/x509"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		utilcert "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type requestHeaderAuthRequestHandler struct {
0000000000000000000000000000000000000000;;		// nameHeaders are the headers to check (in order, case-insensitively) for an identity. The first header with a value wins.
0000000000000000000000000000000000000000;;		nameHeaders []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// groupHeaders are the headers to check (case-insensitively) for group membership.  All values of all headers will be added.
0000000000000000000000000000000000000000;;		groupHeaders []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// extraHeaderPrefixes are the head prefixes to check (case-insensitively) for filling in
0000000000000000000000000000000000000000;;		// the user.Info.Extra.  All values of all matching headers will be added.
0000000000000000000000000000000000000000;;		extraHeaderPrefixes []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(nameHeaders []string, groupHeaders []string, extraHeaderPrefixes []string) (authenticator.Request, error) {
0000000000000000000000000000000000000000;;		trimmedNameHeaders, err := trimHeaders(nameHeaders...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trimmedGroupHeaders, err := trimHeaders(groupHeaders...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trimmedExtraHeaderPrefixes, err := trimHeaders(extraHeaderPrefixes...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &requestHeaderAuthRequestHandler{
0000000000000000000000000000000000000000;;			nameHeaders:         trimmedNameHeaders,
0000000000000000000000000000000000000000;;			groupHeaders:        trimmedGroupHeaders,
0000000000000000000000000000000000000000;;			extraHeaderPrefixes: trimmedExtraHeaderPrefixes,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trimHeaders(headerNames ...string) ([]string, error) {
0000000000000000000000000000000000000000;;		ret := []string{}
0000000000000000000000000000000000000000;;		for _, headerName := range headerNames {
0000000000000000000000000000000000000000;;			trimmedHeader := strings.TrimSpace(headerName)
0000000000000000000000000000000000000000;;			if len(trimmedHeader) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("empty header %q", headerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret = append(ret, trimmedHeader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSecure(clientCA string, proxyClientNames []string, nameHeaders []string, groupHeaders []string, extraHeaderPrefixes []string) (authenticator.Request, error) {
0000000000000000000000000000000000000000;;		headerAuthenticator, err := New(nameHeaders, groupHeaders, extraHeaderPrefixes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(clientCA) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing clientCA file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wrap with an x509 verifier
0000000000000000000000000000000000000000;;		caData, err := ioutil.ReadFile(clientCA)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading %s: %v", clientCA, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts := x509request.DefaultVerifyOptions()
0000000000000000000000000000000000000000;;		opts.Roots = x509.NewCertPool()
0000000000000000000000000000000000000000;;		certs, err := utilcert.ParseCertsPEM(caData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error loading certs from  %s: %v", clientCA, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cert := range certs {
0000000000000000000000000000000000000000;;			opts.Roots.AddCert(cert)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return x509request.NewVerifier(opts, headerAuthenticator, sets.NewString(proxyClientNames...)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *requestHeaderAuthRequestHandler) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		name := headerValue(req.Header, a.nameHeaders)
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groups := allHeaderValues(req.Header, a.groupHeaders)
0000000000000000000000000000000000000000;;		extra := newExtra(req.Header, a.extraHeaderPrefixes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clear headers used for authentication
0000000000000000000000000000000000000000;;		for _, headerName := range a.nameHeaders {
0000000000000000000000000000000000000000;;			req.Header.Del(headerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, headerName := range a.groupHeaders {
0000000000000000000000000000000000000000;;			req.Header.Del(headerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k := range extra {
0000000000000000000000000000000000000000;;			for _, prefix := range a.extraHeaderPrefixes {
0000000000000000000000000000000000000000;;				req.Header.Del(prefix + k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name:   name,
0000000000000000000000000000000000000000;;			Groups: groups,
0000000000000000000000000000000000000000;;			Extra:  extra,
0000000000000000000000000000000000000000;;		}, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func headerValue(h http.Header, headerNames []string) string {
0000000000000000000000000000000000000000;;		for _, headerName := range headerNames {
0000000000000000000000000000000000000000;;			headerValue := h.Get(headerName)
0000000000000000000000000000000000000000;;			if len(headerValue) > 0 {
0000000000000000000000000000000000000000;;				return headerValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func allHeaderValues(h http.Header, headerNames []string) []string {
0000000000000000000000000000000000000000;;		ret := []string{}
0000000000000000000000000000000000000000;;		for _, headerName := range headerNames {
0000000000000000000000000000000000000000;;			values, ok := h[headerName]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, headerValue := range values {
0000000000000000000000000000000000000000;;				if len(headerValue) > 0 {
0000000000000000000000000000000000000000;;					ret = append(ret, headerValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newExtra(h http.Header, headerPrefixes []string) map[string][]string {
0000000000000000000000000000000000000000;;		ret := map[string][]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we have to iterate over prefixes first in order to have proper ordering inside the value slices
0000000000000000000000000000000000000000;;		for _, prefix := range headerPrefixes {
0000000000000000000000000000000000000000;;			for headerName, vv := range h {
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(strings.ToLower(headerName), strings.ToLower(prefix)) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				extraKey := strings.ToLower(headerName[len(prefix):])
0000000000000000000000000000000000000000;;				ret[extraKey] = append(ret[extraKey], vv...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
