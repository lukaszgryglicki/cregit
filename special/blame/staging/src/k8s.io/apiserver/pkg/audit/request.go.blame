0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
7c76be717720b98ceba9f572697a551d221acd03;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package audit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticationv1 "k8s.io/api/authentication/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;		auditinternal "k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewEventFromRequest(req *http.Request, level auditinternal.Level, attribs authorizer.Attributes) (*auditinternal.Event, error) {
0000000000000000000000000000000000000000;;		ev := &auditinternal.Event{
0000000000000000000000000000000000000000;;			Timestamp:  metav1.NewTime(time.Now()),
0000000000000000000000000000000000000000;;			Verb:       attribs.GetVerb(),
0000000000000000000000000000000000000000;;			RequestURI: req.URL.RequestURI(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ev.Level = level
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// prefer the id from the headers. If not available, create a new one.
0000000000000000000000000000000000000000;;		// TODO(audit): do we want to forbid the header for non-front-proxy users?
0000000000000000000000000000000000000000;;		ids := req.Header.Get(auditinternal.HeaderAuditID)
0000000000000000000000000000000000000000;;		if ids != "" {
0000000000000000000000000000000000000000;;			ev.AuditID = types.UID(ids)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ev.AuditID = types.UID(uuid.NewRandom().String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ips := utilnet.SourceIPs(req)
0000000000000000000000000000000000000000;;		ev.SourceIPs = make([]string, len(ips))
0000000000000000000000000000000000000000;;		for i := range ips {
0000000000000000000000000000000000000000;;			ev.SourceIPs[i] = ips[i].String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if user := attribs.GetUser(); user != nil {
0000000000000000000000000000000000000000;;			ev.User.Username = user.GetName()
0000000000000000000000000000000000000000;;			ev.User.Extra = map[string]auditinternal.ExtraValue{}
0000000000000000000000000000000000000000;;			for k, v := range user.GetExtra() {
0000000000000000000000000000000000000000;;				ev.User.Extra[k] = auditinternal.ExtraValue(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ev.User.Groups = user.GetGroups()
0000000000000000000000000000000000000000;;			ev.User.UID = user.GetUID()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if asuser := req.Header.Get(authenticationv1.ImpersonateUserHeader); len(asuser) > 0 {
0000000000000000000000000000000000000000;;			ev.ImpersonatedUser = &auditinternal.UserInfo{
0000000000000000000000000000000000000000;;				Username: asuser,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if requestedGroups := req.Header[authenticationv1.ImpersonateGroupHeader]; len(requestedGroups) > 0 {
0000000000000000000000000000000000000000;;				ev.ImpersonatedUser.Groups = requestedGroups
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ev.ImpersonatedUser.Extra = map[string]auditinternal.ExtraValue{}
0000000000000000000000000000000000000000;;			for k, v := range req.Header {
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(k, authenticationv1.ImpersonateUserExtraHeaderPrefix) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				k = k[len(authenticationv1.ImpersonateUserExtraHeaderPrefix):]
0000000000000000000000000000000000000000;;				ev.ImpersonatedUser.Extra[k] = auditinternal.ExtraValue(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if attribs.IsResourceRequest() {
0000000000000000000000000000000000000000;;			ev.ObjectRef = &auditinternal.ObjectReference{
0000000000000000000000000000000000000000;;				Namespace:   attribs.GetNamespace(),
0000000000000000000000000000000000000000;;				Name:        attribs.GetName(),
0000000000000000000000000000000000000000;;				Resource:    attribs.GetResource(),
0000000000000000000000000000000000000000;;				Subresource: attribs.GetSubresource(),
0000000000000000000000000000000000000000;;				APIVersion:  attribs.GetAPIGroup() + "/" + attribs.GetAPIVersion(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ev, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogRequestObject fills in the request object into an audit event. The passed runtime.Object
0000000000000000000000000000000000000000;;	// will be converted to the given gv.
0000000000000000000000000000000000000000;;	func LogRequestObject(ae *audit.Event, obj runtime.Object, gvr schema.GroupVersionResource, subresource string, s runtime.NegotiatedSerializer) {
0000000000000000000000000000000000000000;;		if ae == nil || ae.Level.Less(audit.LevelMetadata) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// complete ObjectRef
0000000000000000000000000000000000000000;;		if ae.ObjectRef == nil {
0000000000000000000000000000000000000000;;			ae.ObjectRef = &audit.ObjectReference{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if acc, ok := obj.(metav1.ObjectMetaAccessor); ok {
0000000000000000000000000000000000000000;;			meta := acc.GetObjectMeta()
0000000000000000000000000000000000000000;;			if len(ae.ObjectRef.Namespace) == 0 {
0000000000000000000000000000000000000000;;				ae.ObjectRef.Namespace = meta.GetNamespace()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ae.ObjectRef.Name) == 0 {
0000000000000000000000000000000000000000;;				ae.ObjectRef.Name = meta.GetName()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ae.ObjectRef.UID) == 0 {
0000000000000000000000000000000000000000;;				ae.ObjectRef.UID = meta.GetUID()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ae.ObjectRef.ResourceVersion) == 0 {
0000000000000000000000000000000000000000;;				ae.ObjectRef.ResourceVersion = meta.GetResourceVersion()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: ObjectRef should include the API group.
0000000000000000000000000000000000000000;;		if len(ae.ObjectRef.APIVersion) == 0 {
0000000000000000000000000000000000000000;;			ae.ObjectRef.APIVersion = gvr.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ae.ObjectRef.Resource) == 0 {
0000000000000000000000000000000000000000;;			ae.ObjectRef.Resource = gvr.Resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ae.ObjectRef.Subresource) == 0 {
0000000000000000000000000000000000000000;;			ae.ObjectRef.Subresource = subresource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ae.Level.Less(audit.LevelRequest) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(audit): hook into the serializer to avoid double conversion
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		ae.RequestObject, err = encodeObject(obj, gvr.GroupVersion(), s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// TODO(audit): add error slice to audit event struct
0000000000000000000000000000000000000000;;			glog.Warningf("Auditing failed of %v request: %v", reflect.TypeOf(obj).Name(), err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogRquestPatch fills in the given patch as the request object into an audit event.
0000000000000000000000000000000000000000;;	func LogRequestPatch(ae *audit.Event, patch []byte) {
0000000000000000000000000000000000000000;;		if ae == nil || ae.Level.Less(audit.LevelRequest) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ae.RequestObject = &runtime.Unknown{
0000000000000000000000000000000000000000;;			Raw:         patch,
0000000000000000000000000000000000000000;;			ContentType: runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogResponseObject fills in the response object into an audit event. The passed runtime.Object
0000000000000000000000000000000000000000;;	// will be converted to the given gv.
0000000000000000000000000000000000000000;;	func LogResponseObject(ae *audit.Event, obj runtime.Object, gv schema.GroupVersion, s runtime.NegotiatedSerializer) {
0000000000000000000000000000000000000000;;		if ae == nil || ae.Level.Less(audit.LevelMetadata) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status, ok := obj.(*metav1.Status); ok {
0000000000000000000000000000000000000000;;			ae.ResponseStatus = status
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ae.Level.Less(audit.LevelRequestResponse) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(audit): hook into the serializer to avoid double conversion
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		ae.ResponseObject, err = encodeObject(obj, gv, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Audit failed for %q response: %v", reflect.TypeOf(obj).Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeObject(obj runtime.Object, gv schema.GroupVersion, serializer runtime.NegotiatedSerializer) (*runtime.Unknown, error) {
0000000000000000000000000000000000000000;;		supported := serializer.SupportedMediaTypes()
0000000000000000000000000000000000000000;;		for i := range supported {
0000000000000000000000000000000000000000;;			if supported[i].MediaType == "application/json" {
0000000000000000000000000000000000000000;;				enc := serializer.EncoderForVersion(supported[i].Serializer, gv)
0000000000000000000000000000000000000000;;				var buf bytes.Buffer
0000000000000000000000000000000000000000;;				if err := enc.Encode(obj, &buf); err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("encoding failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return &runtime.Unknown{
0000000000000000000000000000000000000000;;					Raw:         buf.Bytes(),
0000000000000000000000000000000000000000;;					ContentType: runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no json encoder found")
0000000000000000000000000000000000000000;;	}
