0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
a7319ac0b5b58130f54b3bb52fa9e005a464b861;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package policy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/apis/audit"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultAuditLevel is the default level to audit at, if no policy rules are matched.
0000000000000000000000000000000000000000;;		DefaultAuditLevel = audit.LevelNone
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checker exposes methods for checking the policy rules.
0000000000000000000000000000000000000000;;	type Checker interface {
0000000000000000000000000000000000000000;;		// Check the audit level for a request with the given authorizer attributes.
0000000000000000000000000000000000000000;;		Level(authorizer.Attributes) audit.Level
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewChecker creates a new policy checker.
0000000000000000000000000000000000000000;;	func NewChecker(policy *audit.Policy) Checker {
0000000000000000000000000000000000000000;;		return &policyChecker{*policy}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeChecker creates a checker that returns a constant level for all requests (for testing).
0000000000000000000000000000000000000000;;	func FakeChecker(level audit.Level) Checker {
0000000000000000000000000000000000000000;;		return &fakeChecker{level}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type policyChecker struct {
0000000000000000000000000000000000000000;;		audit.Policy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *policyChecker) Level(attrs authorizer.Attributes) audit.Level {
0000000000000000000000000000000000000000;;		for _, rule := range p.Rules {
0000000000000000000000000000000000000000;;			if ruleMatches(&rule, attrs) {
0000000000000000000000000000000000000000;;				return rule.Level
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return DefaultAuditLevel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether the rule matches the request attrs.
0000000000000000000000000000000000000000;;	func ruleMatches(r *audit.PolicyRule, attrs authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		if len(r.Users) > 0 {
0000000000000000000000000000000000000000;;			if !hasString(r.Users, attrs.GetUser().GetName()) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.UserGroups) > 0 {
0000000000000000000000000000000000000000;;			matched := false
0000000000000000000000000000000000000000;;			for _, group := range attrs.GetUser().GetGroups() {
0000000000000000000000000000000000000000;;				if hasString(r.UserGroups, group) {
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !matched {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.Verbs) > 0 {
0000000000000000000000000000000000000000;;			if !hasString(r.Verbs, attrs.GetVerb()) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(r.Namespaces) > 0 || len(r.Resources) > 0 {
0000000000000000000000000000000000000000;;			return ruleMatchesResource(r, attrs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(r.NonResourceURLs) > 0 {
0000000000000000000000000000000000000000;;			return ruleMatchesNonResource(r, attrs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether the rule's non-resource URLs match the request attrs.
0000000000000000000000000000000000000000;;	func ruleMatchesNonResource(r *audit.PolicyRule, attrs authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		if attrs.IsResourceRequest() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := attrs.GetPath()
0000000000000000000000000000000000000000;;		for _, spec := range r.NonResourceURLs {
0000000000000000000000000000000000000000;;			if pathMatches(path, spec) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether the path matches the path specification.
0000000000000000000000000000000000000000;;	func pathMatches(path, spec string) bool {
0000000000000000000000000000000000000000;;		// Allow wildcard match
0000000000000000000000000000000000000000;;		if spec == "*" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Allow exact match
0000000000000000000000000000000000000000;;		if spec == path {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Allow a trailing * subpath match
0000000000000000000000000000000000000000;;		if strings.HasSuffix(spec, "*") && strings.HasPrefix(path, strings.TrimRight(spec, "*")) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether the rule's resource fields match the request attrs.
0000000000000000000000000000000000000000;;	func ruleMatchesResource(r *audit.PolicyRule, attrs authorizer.Attributes) bool {
0000000000000000000000000000000000000000;;		if !attrs.IsResourceRequest() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(r.Namespaces) > 0 {
0000000000000000000000000000000000000000;;			if !hasString(r.Namespaces, attrs.GetNamespace()) { // Non-namespaced resources use the empty string.
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.Resources) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiGroup := attrs.GetAPIGroup()
0000000000000000000000000000000000000000;;		resource := attrs.GetResource()
0000000000000000000000000000000000000000;;		for _, gr := range r.Resources {
0000000000000000000000000000000000000000;;			if gr.Group == apiGroup {
0000000000000000000000000000000000000000;;				if len(gr.Resources) == 0 {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, res := range gr.Resources {
0000000000000000000000000000000000000000;;					if res == resource {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Utility function to check whether a string slice contains a string.
0000000000000000000000000000000000000000;;	func hasString(slice []string, value string) bool {
0000000000000000000000000000000000000000;;		for _, s := range slice {
0000000000000000000000000000000000000000;;			if s == value {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeChecker struct {
0000000000000000000000000000000000000000;;		level audit.Level
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeChecker) Level(_ authorizer.Attributes) audit.Level {
0000000000000000000000000000000000000000;;		return f.level
0000000000000000000000000000000000000000;;	}
