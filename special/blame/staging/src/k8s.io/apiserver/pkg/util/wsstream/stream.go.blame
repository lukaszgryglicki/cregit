0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1171e0d21008d8a5368fdafc4a759176bbe282f4;pkg/util/wsstream/stream.go[pkg/util/wsstream/stream.go][staging/src/k8s.io/apiserver/pkg/util/wsstream/stream.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package wsstream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The WebSocket subprotocol "binary.k8s.io" will only send messages to the
0000000000000000000000000000000000000000;;	// client and ignore messages sent to the server. The received messages are
0000000000000000000000000000000000000000;;	// the exact bytes written to the stream. Zero byte messages are possible.
0000000000000000000000000000000000000000;;	const binaryWebSocketProtocol = "binary.k8s.io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The WebSocket subprotocol "base64.binary.k8s.io" will only send messages to the
0000000000000000000000000000000000000000;;	// client and ignore messages sent to the server. The received messages are
0000000000000000000000000000000000000000;;	// a base64 version of the bytes written to the stream. Zero byte messages are
0000000000000000000000000000000000000000;;	// possible.
0000000000000000000000000000000000000000;;	const base64BinaryWebSocketProtocol = "base64.binary.k8s.io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReaderProtocolConfig describes a websocket subprotocol with one stream.
0000000000000000000000000000000000000000;;	type ReaderProtocolConfig struct {
0000000000000000000000000000000000000000;;		Binary bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultReaderProtocols returns a stream protocol map with the
0000000000000000000000000000000000000000;;	// subprotocols "", "channel.k8s.io", "base64.channel.k8s.io".
0000000000000000000000000000000000000000;;	func NewDefaultReaderProtocols() map[string]ReaderProtocolConfig {
0000000000000000000000000000000000000000;;		return map[string]ReaderProtocolConfig{
0000000000000000000000000000000000000000;;			"": {Binary: true},
0000000000000000000000000000000000000000;;			binaryWebSocketProtocol:       {Binary: true},
0000000000000000000000000000000000000000;;			base64BinaryWebSocketProtocol: {Binary: false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reader supports returning an arbitrary byte stream over a websocket channel.
0000000000000000000000000000000000000000;;	type Reader struct {
0000000000000000000000000000000000000000;;		err              chan error
0000000000000000000000000000000000000000;;		r                io.Reader
0000000000000000000000000000000000000000;;		ping             bool
0000000000000000000000000000000000000000;;		timeout          time.Duration
0000000000000000000000000000000000000000;;		protocols        map[string]ReaderProtocolConfig
0000000000000000000000000000000000000000;;		selectedProtocol string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handleCrash func() // overridable for testing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReader creates a WebSocket pipe that will copy the contents of r to a provided
0000000000000000000000000000000000000000;;	// WebSocket connection. If ping is true, a zero length message will be sent to the client
0000000000000000000000000000000000000000;;	// before the stream begins reading.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The protocols parameter maps subprotocol names to StreamProtocols. The empty string
0000000000000000000000000000000000000000;;	// subprotocol name is used if websocket.Config.Protocol is empty.
0000000000000000000000000000000000000000;;	func NewReader(r io.Reader, ping bool, protocols map[string]ReaderProtocolConfig) *Reader {
0000000000000000000000000000000000000000;;		return &Reader{
0000000000000000000000000000000000000000;;			r:           r,
0000000000000000000000000000000000000000;;			err:         make(chan error),
0000000000000000000000000000000000000000;;			ping:        ping,
0000000000000000000000000000000000000000;;			protocols:   protocols,
0000000000000000000000000000000000000000;;			handleCrash: func() { runtime.HandleCrash() },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetIdleTimeout sets the interval for both reads and writes before timeout. If not specified,
0000000000000000000000000000000000000000;;	// there is no timeout on the reader.
0000000000000000000000000000000000000000;;	func (r *Reader) SetIdleTimeout(duration time.Duration) {
0000000000000000000000000000000000000000;;		r.timeout = duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Reader) handshake(config *websocket.Config, req *http.Request) error {
0000000000000000000000000000000000000000;;		supportedProtocols := make([]string, 0, len(r.protocols))
0000000000000000000000000000000000000000;;		for p := range r.protocols {
0000000000000000000000000000000000000000;;			supportedProtocols = append(supportedProtocols, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return handshake(config, req, supportedProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy the reader to the response. The created WebSocket is closed after this
0000000000000000000000000000000000000000;;	// method completes.
0000000000000000000000000000000000000000;;	func (r *Reader) Copy(w http.ResponseWriter, req *http.Request) error {
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer r.handleCrash()
0000000000000000000000000000000000000000;;			websocket.Server{Handshake: r.handshake, Handler: r.handle}.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return <-r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handle implements a WebSocket handler.
0000000000000000000000000000000000000000;;	func (r *Reader) handle(ws *websocket.Conn) {
0000000000000000000000000000000000000000;;		// Close the connection when the client requests it, or when we finish streaming, whichever happens first
0000000000000000000000000000000000000000;;		closeConnOnce := &sync.Once{}
0000000000000000000000000000000000000000;;		closeConn := func() {
0000000000000000000000000000000000000000;;			closeConnOnce.Do(func() {
0000000000000000000000000000000000000000;;				ws.Close()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		negotiated := ws.Config().Protocol
0000000000000000000000000000000000000000;;		r.selectedProtocol = negotiated[0]
0000000000000000000000000000000000000000;;		defer close(r.err)
0000000000000000000000000000000000000000;;		defer closeConn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			// This blocks until the connection is closed.
0000000000000000000000000000000000000000;;			// Client should not send anything.
0000000000000000000000000000000000000000;;			IgnoreReceives(ws, r.timeout)
0000000000000000000000000000000000000000;;			// Once the client closes, we should also close
0000000000000000000000000000000000000000;;			closeConn()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.err <- messageCopy(ws, r.r, !r.protocols[r.selectedProtocol].Binary, r.ping, r.timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resetTimeout(ws *websocket.Conn, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if timeout > 0 {
0000000000000000000000000000000000000000;;			ws.SetDeadline(time.Now().Add(timeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func messageCopy(ws *websocket.Conn, r io.Reader, base64Encode, ping bool, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		buf := make([]byte, 2048)
0000000000000000000000000000000000000000;;		if ping {
0000000000000000000000000000000000000000;;			resetTimeout(ws, timeout)
0000000000000000000000000000000000000000;;			if base64Encode {
0000000000000000000000000000000000000000;;				if err := websocket.Message.Send(ws, ""); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := websocket.Message.Send(ws, []byte{}); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resetTimeout(ws, timeout)
0000000000000000000000000000000000000000;;			n, err := r.Read(buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				if base64Encode {
0000000000000000000000000000000000000000;;					if err := websocket.Message.Send(ws, base64.StdEncoding.EncodeToString(buf[:n])); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err := websocket.Message.Send(ws, buf[:n]); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
