0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1e71d4b598a10932febf978325f27cb07ad91bf1;pkg/util/config/feature_gate.go[pkg/util/config/feature_gate.go][staging/src/k8s.io/apiserver/pkg/util/feature/feature_gate.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package feature
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Feature string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		flagName = "feature-gates"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allAlphaGate is a global toggle for alpha features. Per-feature key
0000000000000000000000000000000000000000;;		// values override the default set by allAlphaGate. Examples:
0000000000000000000000000000000000000000;;		//   AllAlpha=false,NewFeature=true  will result in newFeature=true
0000000000000000000000000000000000000000;;		//   AllAlpha=true,NewFeature=false  will result in newFeature=false
0000000000000000000000000000000000000000;;		allAlphaGate Feature = "AllAlpha"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// The generic features.
0000000000000000000000000000000000000000;;		defaultFeatures = map[Feature]FeatureSpec{
0000000000000000000000000000000000000000;;			allAlphaGate: {Default: false, PreRelease: Alpha},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Special handling for a few gates.
0000000000000000000000000000000000000000;;		specialFeatures = map[Feature]func(f *featureGate, val bool){
0000000000000000000000000000000000000000;;			allAlphaGate: setUnsetAlphaGates,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultFeatureGate is a shared global FeatureGate.
0000000000000000000000000000000000000000;;		DefaultFeatureGate FeatureGate = NewFeatureGate()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FeatureSpec struct {
0000000000000000000000000000000000000000;;		Default    bool
0000000000000000000000000000000000000000;;		PreRelease prerelease
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type prerelease string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Values for PreRelease.
0000000000000000000000000000000000000000;;		Alpha = prerelease("ALPHA")
0000000000000000000000000000000000000000;;		Beta  = prerelease("BETA")
0000000000000000000000000000000000000000;;		GA    = prerelease("")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FeatureGate parses and stores flag gates for known features from
0000000000000000000000000000000000000000;;	// a string like feature1=true,feature2=false,...
0000000000000000000000000000000000000000;;	type FeatureGate interface {
0000000000000000000000000000000000000000;;		AddFlag(fs *pflag.FlagSet)
0000000000000000000000000000000000000000;;		Set(value string) error
0000000000000000000000000000000000000000;;		Enabled(key Feature) bool
0000000000000000000000000000000000000000;;		Add(features map[Feature]FeatureSpec) error
0000000000000000000000000000000000000000;;		KnownFeatures() []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// featureGate implements FeatureGate as well as pflag.Value for flag parsing.
0000000000000000000000000000000000000000;;	type featureGate struct {
0000000000000000000000000000000000000000;;		known   map[Feature]FeatureSpec
0000000000000000000000000000000000000000;;		special map[Feature]func(*featureGate, bool)
0000000000000000000000000000000000000000;;		enabled map[Feature]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// is set to true when AddFlag is called. Note: initialization is not go-routine safe, lookup is
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setUnsetAlphaGates(f *featureGate, val bool) {
0000000000000000000000000000000000000000;;		for k, v := range f.known {
0000000000000000000000000000000000000000;;			if v.PreRelease == Alpha {
0000000000000000000000000000000000000000;;				if _, found := f.enabled[k]; !found {
0000000000000000000000000000000000000000;;					f.enabled[k] = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set, String, and Type implement pflag.Value
0000000000000000000000000000000000000000;;	var _ pflag.Value = &featureGate{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFeatureGate() *featureGate {
0000000000000000000000000000000000000000;;		f := &featureGate{
0000000000000000000000000000000000000000;;			known:   map[Feature]FeatureSpec{},
0000000000000000000000000000000000000000;;			special: specialFeatures,
0000000000000000000000000000000000000000;;			enabled: map[Feature]bool{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range defaultFeatures {
0000000000000000000000000000000000000000;;			f.known[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set Parses a string of the form // "key1=value1,key2=value2,..." into a
0000000000000000000000000000000000000000;;	// map[string]bool of known keys or returns an error.
0000000000000000000000000000000000000000;;	func (f *featureGate) Set(value string) error {
0000000000000000000000000000000000000000;;		for _, s := range strings.Split(value, ",") {
0000000000000000000000000000000000000000;;			if len(s) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			arr := strings.SplitN(s, "=", 2)
0000000000000000000000000000000000000000;;			k := Feature(strings.TrimSpace(arr[0]))
0000000000000000000000000000000000000000;;			_, ok := f.known[Feature(k)]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unrecognized key: %s", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(arr) != 2 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("missing bool value for %s", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v := strings.TrimSpace(arr[1])
0000000000000000000000000000000000000000;;			boolValue, err := strconv.ParseBool(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid value of %s: %s, err: %v", k, v, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.enabled[k] = boolValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Handle "special" features like "all alpha gates"
0000000000000000000000000000000000000000;;			if fn, found := f.special[k]; found {
0000000000000000000000000000000000000000;;				fn(f, boolValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("feature gates: %v", f.enabled)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *featureGate) String() string {
0000000000000000000000000000000000000000;;		pairs := []string{}
0000000000000000000000000000000000000000;;		for k, v := range f.enabled {
0000000000000000000000000000000000000000;;			pairs = append(pairs, fmt.Sprintf("%s=%t", k, v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(pairs)
0000000000000000000000000000000000000000;;		return strings.Join(pairs, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *featureGate) Type() string {
0000000000000000000000000000000000000000;;		return "mapStringBool"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *featureGate) Add(features map[Feature]FeatureSpec) error {
0000000000000000000000000000000000000000;;		if f.closed {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot add a feature gate after adding it to the flag set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, spec := range features {
0000000000000000000000000000000000000000;;			if existingSpec, found := f.known[name]; found {
0000000000000000000000000000000000000000;;				if existingSpec == spec {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("feature gate %q with different spec already exists: %v", name, existingSpec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.known[name] = spec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *featureGate) Enabled(key Feature) bool {
0000000000000000000000000000000000000000;;		defaultValue := f.known[key].Default
0000000000000000000000000000000000000000;;		if f.enabled != nil {
0000000000000000000000000000000000000000;;			if v, ok := f.enabled[key]; ok {
0000000000000000000000000000000000000000;;				return v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlag adds a flag for setting global feature gates to the specified FlagSet.
0000000000000000000000000000000000000000;;	func (f *featureGate) AddFlag(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		f.closed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		known := f.KnownFeatures()
0000000000000000000000000000000000000000;;		fs.Var(f, flagName, ""+
0000000000000000000000000000000000000000;;			"A set of key=value pairs that describe feature gates for alpha/experimental features. "+
0000000000000000000000000000000000000000;;			"Options are:\n"+strings.Join(known, "\n"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a string describing the FeatureGate's known features.
0000000000000000000000000000000000000000;;	func (f *featureGate) KnownFeatures() []string {
0000000000000000000000000000000000000000;;		var known []string
0000000000000000000000000000000000000000;;		for k, v := range f.known {
0000000000000000000000000000000000000000;;			pre := ""
0000000000000000000000000000000000000000;;			if v.PreRelease != GA {
0000000000000000000000000000000000000000;;				pre = fmt.Sprintf("%s - ", v.PreRelease)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			known = append(known, fmt.Sprintf("%s=true|false (%sdefault=%t)", k, pre, v.Default))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(known)
0000000000000000000000000000000000000000;;		return known
0000000000000000000000000000000000000000;;	}
