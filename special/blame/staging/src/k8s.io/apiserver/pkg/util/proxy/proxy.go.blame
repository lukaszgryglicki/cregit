0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
33096dcb4a7ee010e89bc58069b003b7394bd911;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		listersv1 "k8s.io/client-go/listers/core/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findServicePort finds the service port by name or numerically.
0000000000000000000000000000000000000000;;	func findServicePort(svc *v1.Service, port intstr.IntOrString) (*v1.ServicePort, error) {
0000000000000000000000000000000000000000;;		for _, svcPort := range svc.Spec.Ports {
0000000000000000000000000000000000000000;;			if (port.Type == intstr.Int && int32(svcPort.Port) == port.IntVal) || (port.Type == intstr.String && svcPort.Name == port.StrVal) {
0000000000000000000000000000000000000000;;				return &svcPort, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.NewServiceUnavailable(fmt.Sprintf("no service port %q found for service %q", port.String(), svc.Name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceLocation returns a URL to which one can send traffic for the specified service.
0000000000000000000000000000000000000000;;	func ResolveEndpoint(services listersv1.ServiceLister, endpoints listersv1.EndpointsLister, namespace, id string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		svc, err := services.Services(namespace).Get(id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		port := intstr.FromInt(443)
0000000000000000000000000000000000000000;;		svcPort, err := findServicePort(svc, port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case svc.Spec.Type == v1.ServiceTypeClusterIP, svc.Spec.Type == v1.ServiceTypeLoadBalancer, svc.Spec.Type == v1.ServiceTypeNodePort:
0000000000000000000000000000000000000000;;			// these are fine
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported service type %q", svc.Spec.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eps, err := endpoints.Endpoints(namespace).Get(svc.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(eps.Subsets) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.NewServiceUnavailable(fmt.Sprintf("no endpoints available for service %q", svc.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pick a random Subset to start searching from.
0000000000000000000000000000000000000000;;		ssSeed := rand.Intn(len(eps.Subsets))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find a Subset that has the port.
0000000000000000000000000000000000000000;;		for ssi := 0; ssi < len(eps.Subsets); ssi++ {
0000000000000000000000000000000000000000;;			ss := &eps.Subsets[(ssSeed+ssi)%len(eps.Subsets)]
0000000000000000000000000000000000000000;;			if len(ss.Addresses) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range ss.Ports {
0000000000000000000000000000000000000000;;				if ss.Ports[i].Name == svcPort.Name {
0000000000000000000000000000000000000000;;					// Pick a random address.
0000000000000000000000000000000000000000;;					ip := ss.Addresses[rand.Intn(len(ss.Addresses))].IP
0000000000000000000000000000000000000000;;					port := int(ss.Ports[i].Port)
0000000000000000000000000000000000000000;;					return &url.URL{
0000000000000000000000000000000000000000;;						Scheme: "https",
0000000000000000000000000000000000000000;;						Host:   net.JoinHostPort(ip, strconv.Itoa(port)),
0000000000000000000000000000000000000000;;					}, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.NewServiceUnavailable(fmt.Sprintf("no endpoints available for service %q", id))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ResolveCluster(services listersv1.ServiceLister, namespace, id string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		svc, err := services.Services(namespace).Get(id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		port := intstr.FromInt(443)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case svc.Spec.Type == v1.ServiceTypeClusterIP && svc.Spec.ClusterIP == v1.ClusterIPNone:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(`cannot route to service with ClusterIP "None"`)
0000000000000000000000000000000000000000;;		// use IP from a clusterIP for these service types
0000000000000000000000000000000000000000;;		case svc.Spec.Type == v1.ServiceTypeClusterIP, svc.Spec.Type == v1.ServiceTypeLoadBalancer, svc.Spec.Type == v1.ServiceTypeNodePort:
0000000000000000000000000000000000000000;;			svcPort, err := findServicePort(svc, port)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &url.URL{
0000000000000000000000000000000000000000;;				Scheme: "https",
0000000000000000000000000000000000000000;;				Host:   net.JoinHostPort(svc.Spec.ClusterIP, fmt.Sprintf("%d", svcPort.Port)),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case svc.Spec.Type == v1.ServiceTypeExternalName:
0000000000000000000000000000000000000000;;			if port.Type != intstr.Int {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("named ports not supported")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &url.URL{
0000000000000000000000000000000000000000;;				Scheme: "https",
0000000000000000000000000000000000000000;;				Host:   net.JoinHostPort(svc.Spec.ExternalName, port.String()),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported service type %q", svc.Spec.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
