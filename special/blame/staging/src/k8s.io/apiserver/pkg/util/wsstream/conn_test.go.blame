0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1171e0d21008d8a5368fdafc4a759176bbe282f4;pkg/util/wsstream/conn_test.go[pkg/util/wsstream/conn_test.go][staging/src/k8s.io/apiserver/pkg/util/wsstream/conn_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package wsstream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newServer(handler http.Handler) (*httptest.Server, string) {
0000000000000000000000000000000000000000;;		server := httptest.NewServer(handler)
0000000000000000000000000000000000000000;;		serverAddr := server.Listener.Addr().String()
0000000000000000000000000000000000000000;;		return server, serverAddr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRawConn(t *testing.T) {
0000000000000000000000000000000000000000;;		channels := []ChannelType{ReadWriteChannel, ReadWriteChannel, IgnoreChannel, ReadChannel, WriteChannel}
0000000000000000000000000000000000000000;;		conn := NewConn(NewDefaultChannelProtocols(channels))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, addr := newServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			conn.Open(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := websocket.Dial("ws://"+addr, "", "http://localhost/")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer client.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-conn.ready
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify we can read a client write
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadAll(conn.channels[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(data, []byte("client")) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected server read: %v", data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n, err := client.Write(append([]byte{0}, []byte("client")...)); err != nil || n != 7 {
0000000000000000000000000000000000000000;;			t.Fatalf("%d: %v", n, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify we can read a server write
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			if n, err := conn.channels[1].Write([]byte("server")); err != nil && n != 6 {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: %v", n, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := make([]byte, 1024)
0000000000000000000000000000000000000000;;		if n, err := io.ReadAtLeast(client, data, 6); n != 7 || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%d: %v", n, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(data[:7], append([]byte{1}, []byte("server")...)) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected client read: %v", data[:7])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that an ignore channel is empty in both directions.
0000000000000000000000000000000000000000;;		if n, err := conn.channels[2].Write([]byte("test")); n != 4 || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("writes should be ignored")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data = make([]byte, 1024)
0000000000000000000000000000000000000000;;		if n, err := conn.channels[2].Read(data); n != 0 || err != io.EOF {
0000000000000000000000000000000000000000;;			t.Errorf("reads should be ignored")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that a write to a Read channel doesn't block
0000000000000000000000000000000000000000;;		if n, err := conn.channels[3].Write([]byte("test")); n != 4 || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("writes should be ignored")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that a read from a Write channel doesn't block
0000000000000000000000000000000000000000;;		data = make([]byte, 1024)
0000000000000000000000000000000000000000;;		if n, err := conn.channels[4].Read(data); n != 0 || err != io.EOF {
0000000000000000000000000000000000000000;;			t.Errorf("reads should be ignored")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that a client write to a Write channel doesn't block (is dropped)
0000000000000000000000000000000000000000;;		if n, err := client.Write(append([]byte{4}, []byte("ignored")...)); err != nil || n != 8 {
0000000000000000000000000000000000000000;;			t.Fatalf("%d: %v", n, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.Close()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBase64Conn(t *testing.T) {
0000000000000000000000000000000000000000;;		conn := NewConn(NewDefaultChannelProtocols([]ChannelType{ReadWriteChannel, ReadWriteChannel}))
0000000000000000000000000000000000000000;;		s, addr := newServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			conn.Open(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, err := websocket.NewConfig("ws://"+addr, "http://localhost/")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.Protocol = []string{"base64.channel.k8s.io"}
0000000000000000000000000000000000000000;;		client, err := websocket.DialConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer client.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-conn.ready
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadAll(conn.channels[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(data, []byte("client")) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected server read: %s", string(data))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientData := base64.StdEncoding.EncodeToString([]byte("client"))
0000000000000000000000000000000000000000;;		if n, err := client.Write(append([]byte{'0'}, clientData...)); err != nil || n != len(clientData)+1 {
0000000000000000000000000000000000000000;;			t.Fatalf("%d: %v", n, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			if n, err := conn.channels[1].Write([]byte("server")); err != nil && n != 6 {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: %v", n, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := make([]byte, 1024)
0000000000000000000000000000000000000000;;		if n, err := io.ReadAtLeast(client, data, 9); n != 9 || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%d: %v", n, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expect := []byte(base64.StdEncoding.EncodeToString([]byte("server")))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(data[:9], append([]byte{'1'}, expect...)) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected client read: %v", data[:9])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.Close()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type versionTest struct {
0000000000000000000000000000000000000000;;		supported map[string]bool // protocol -> binary
0000000000000000000000000000000000000000;;		requested []string
0000000000000000000000000000000000000000;;		error     bool
0000000000000000000000000000000000000000;;		expected  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func versionTests() []versionTest {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			binary = true
0000000000000000000000000000000000000000;;			base64 = false
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return []versionTest{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				supported: nil,
0000000000000000000000000000000000000000;;				requested: []string{"raw"},
0000000000000000000000000000000000000000;;				error:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				supported: map[string]bool{"": binary, "raw": binary, "base64": base64},
0000000000000000000000000000000000000000;;				requested: nil,
0000000000000000000000000000000000000000;;				expected:  "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				supported: map[string]bool{"": binary, "raw": binary, "base64": base64},
0000000000000000000000000000000000000000;;				requested: []string{"v1.raw"},
0000000000000000000000000000000000000000;;				error:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				supported: map[string]bool{"": binary, "raw": binary, "base64": base64},
0000000000000000000000000000000000000000;;				requested: []string{"v1.raw", "v1.base64"},
0000000000000000000000000000000000000000;;				error:     true,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				supported: map[string]bool{"": binary, "raw": binary, "base64": base64},
0000000000000000000000000000000000000000;;				requested: []string{"v1.raw", "raw"},
0000000000000000000000000000000000000000;;				expected:  "raw",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				supported: map[string]bool{"": binary, "v1.raw": binary, "v1.base64": base64, "v2.raw": binary, "v2.base64": base64},
0000000000000000000000000000000000000000;;				requested: []string{"v1.raw"},
0000000000000000000000000000000000000000;;				expected:  "v1.raw",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				supported: map[string]bool{"": binary, "v1.raw": binary, "v1.base64": base64, "v2.raw": binary, "v2.base64": base64},
0000000000000000000000000000000000000000;;				requested: []string{"v2.base64"},
0000000000000000000000000000000000000000;;				expected:  "v2.base64",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVersionedConn(t *testing.T) {
0000000000000000000000000000000000000000;;		for i, test := range versionTests() {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				supportedProtocols := map[string]ChannelProtocolConfig{}
0000000000000000000000000000000000000000;;				for p, binary := range test.supported {
0000000000000000000000000000000000000000;;					supportedProtocols[p] = ChannelProtocolConfig{
0000000000000000000000000000000000000000;;						Binary:   binary,
0000000000000000000000000000000000000000;;						Channels: []ChannelType{ReadWriteChannel},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				conn := NewConn(supportedProtocols)
0000000000000000000000000000000000000000;;				// note that it's not enough to wait for conn.ready to avoid a race here. Hence,
0000000000000000000000000000000000000000;;				// we use a channel.
0000000000000000000000000000000000000000;;				selectedProtocol := make(chan string, 0)
0000000000000000000000000000000000000000;;				s, addr := newServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;					p, _, _ := conn.Open(w, req)
0000000000000000000000000000000000000000;;					selectedProtocol <- p
0000000000000000000000000000000000000000;;				}))
0000000000000000000000000000000000000000;;				defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				config, err := websocket.NewConfig("ws://"+addr, "http://localhost/")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatal(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				config.Protocol = test.requested
0000000000000000000000000000000000000000;;				client, err := websocket.DialConfig(config)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !test.error {
0000000000000000000000000000000000000000;;						t.Fatalf("test %d: didn't expect error: %v", i, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer client.Close()
0000000000000000000000000000000000000000;;				if test.error && err == nil {
0000000000000000000000000000000000000000;;					t.Fatalf("test %d: expected an error", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				<-conn.ready
0000000000000000000000000000000000000000;;				if got, expected := <-selectedProtocol, test.expected; got != expected {
0000000000000000000000000000000000000000;;					t.Fatalf("test %d: unexpected protocol version: got=%s expected=%s", i, got, expected)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
