0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
731838f4a3ebf8249a59c71cb9a8aa93606f3de7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package webhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd/api/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		errBadCertificate    = "Get .*: remote error: tls: bad certificate"
0000000000000000000000000000000000000000;;		errNoConfiguration   = "invalid configuration: no configuration has been provided"
0000000000000000000000000000000000000000;;		errMissingCertPath   = "invalid configuration: unable to read %s %s for %s due to open %s: .*"
0000000000000000000000000000000000000000;;		errSignedByUnknownCA = "Get .*: x509: certificate signed by unknown authority"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultCluster = v1.NamedCluster{
0000000000000000000000000000000000000000;;			Cluster: v1.Cluster{
0000000000000000000000000000000000000000;;				Server: "https://webhook.example.com",
0000000000000000000000000000000000000000;;				CertificateAuthorityData: caCert,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultUser = v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;			AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;				ClientCertificateData: clientCert,
0000000000000000000000000000000000000000;;				ClientKeyData:         clientKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		namedCluster = v1.NamedCluster{
0000000000000000000000000000000000000000;;			Cluster: v1.Cluster{
0000000000000000000000000000000000000000;;				Server: "https://webhook.example.com",
0000000000000000000000000000000000000000;;				CertificateAuthorityData: caCert,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Name: "test-cluster",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupVersions = []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		retryBackoff  = time.Duration(500) * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestDisabledGroupVersion ensures that requiring a group version works as expected
0000000000000000000000000000000000000000;;	func TestDisabledGroupVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		gv := schema.GroupVersion{Group: "webhook.util.k8s.io", Version: "v1"}
0000000000000000000000000000000000000000;;		gvs := []schema.GroupVersion{gv}
0000000000000000000000000000000000000000;;		registry := registered.NewOrDie(gv.String())
0000000000000000000000000000000000000000;;		_, err := NewGenericWebhook(registry, scheme.Codecs, "/some/path", gvs, retryBackoff)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected an error")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			aErrMsg := err.Error()
0000000000000000000000000000000000000000;;			eErrMsg := fmt.Sprintf("webhook plugin requires enabling extension resource: %s", gv)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if aErrMsg != eErrMsg {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error message mismatch:\n  Expected: %s\n  Actual:   %s", eErrMsg, aErrMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestKubeConfigFile ensures that a kube config file, regardless of validity, is handled properly
0000000000000000000000000000000000000000;;	func TestKubeConfigFile(t *testing.T) {
0000000000000000000000000000000000000000;;		badCAPath := "/tmp/missing/ca.pem"
0000000000000000000000000000000000000000;;		badClientCertPath := "/tmp/missing/client.pem"
0000000000000000000000000000000000000000;;		badClientKeyPath := "/tmp/missing/client-key.pem"
0000000000000000000000000000000000000000;;		dir := bootstrapTestDir(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer os.RemoveAll(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These tests check for all of the ways in which a Kubernetes config file could be malformed within the context of
0000000000000000000000000000000000000000;;		// configuring a webhook.  Configuration issues that arise while using the webhook are tested elsewhere.
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test           string
0000000000000000000000000000000000000000;;			cluster        *v1.NamedCluster
0000000000000000000000000000000000000000;;			context        *v1.NamedContext
0000000000000000000000000000000000000000;;			currentContext string
0000000000000000000000000000000000000000;;			user           *v1.NamedAuthInfo
0000000000000000000000000000000000000000;;			errRegex       string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:     "missing context (no default, none specified)",
0000000000000000000000000000000000000000;;				cluster:  &namedCluster,
0000000000000000000000000000000000000000;;				errRegex: errNoConfiguration,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:           "missing context (specified context is missing)",
0000000000000000000000000000000000000000;;				cluster:        &namedCluster,
0000000000000000000000000000000000000000;;				currentContext: "missing-context",
0000000000000000000000000000000000000000;;				errRegex:       errNoConfiguration,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "context without cluster",
0000000000000000000000000000000000000000;;				context: &v1.NamedContext{
0000000000000000000000000000000000000000;;					Context: v1.Context{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				currentContext: "testing-context",
0000000000000000000000000000000000000000;;				errRegex:       errNoConfiguration,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:    "context without user",
0000000000000000000000000000000000000000;;				cluster: &namedCluster,
0000000000000000000000000000000000000000;;				context: &v1.NamedContext{
0000000000000000000000000000000000000000;;					Context: v1.Context{
0000000000000000000000000000000000000000;;						Cluster: namedCluster.Name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				currentContext: "testing-context",
0000000000000000000000000000000000000000;;				errRegex:       "", // Not an error at parse time, only when using the webhook
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:    "context with missing cluster",
0000000000000000000000000000000000000000;;				cluster: &namedCluster,
0000000000000000000000000000000000000000;;				context: &v1.NamedContext{
0000000000000000000000000000000000000000;;					Context: v1.Context{
0000000000000000000000000000000000000000;;						Cluster: "missing-cluster",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errRegex: errNoConfiguration,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:    "context with missing user",
0000000000000000000000000000000000000000;;				cluster: &namedCluster,
0000000000000000000000000000000000000000;;				context: &v1.NamedContext{
0000000000000000000000000000000000000000;;					Context: v1.Context{
0000000000000000000000000000000000000000;;						Cluster:  namedCluster.Name,
0000000000000000000000000000000000000000;;						AuthInfo: "missing-user",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				currentContext: "testing-context",
0000000000000000000000000000000000000000;;				errRegex:       "", // Not an error at parse time, only when using the webhook
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "cluster with invalid CA certificate path",
0000000000000000000000000000000000000000;;				cluster: &v1.NamedCluster{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{
0000000000000000000000000000000000000000;;						Server:               namedCluster.Cluster.Server,
0000000000000000000000000000000000000000;;						CertificateAuthority: badCAPath,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:     &defaultUser,
0000000000000000000000000000000000000000;;				errRegex: fmt.Sprintf(errMissingCertPath, "certificate-authority", badCAPath, "", badCAPath),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "cluster with invalid CA certificate ",
0000000000000000000000000000000000000000;;				cluster: &v1.NamedCluster{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{
0000000000000000000000000000000000000000;;						Server: namedCluster.Cluster.Server,
0000000000000000000000000000000000000000;;						CertificateAuthorityData: caKey,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user:     &defaultUser,
0000000000000000000000000000000000000000;;				errRegex: "", // Not an error at parse time, only when using the webhook
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:    "user with invalid client certificate path",
0000000000000000000000000000000000000000;;				cluster: &defaultCluster,
0000000000000000000000000000000000000000;;				user: &v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;						ClientCertificate: badClientCertPath,
0000000000000000000000000000000000000000;;						ClientKeyData:     defaultUser.AuthInfo.ClientKeyData,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errRegex: fmt.Sprintf(errMissingCertPath, "client-cert", badClientCertPath, "", badClientCertPath),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:    "user with invalid client certificate",
0000000000000000000000000000000000000000;;				cluster: &defaultCluster,
0000000000000000000000000000000000000000;;				user: &v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;						ClientCertificateData: clientKey,
0000000000000000000000000000000000000000;;						ClientKeyData:         defaultUser.AuthInfo.ClientKeyData,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errRegex: "tls: failed to find certificate PEM data in certificate input, but did find a private key; PEM inputs may have been switched",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:    "user with invalid client certificate path",
0000000000000000000000000000000000000000;;				cluster: &defaultCluster,
0000000000000000000000000000000000000000;;				user: &v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;						ClientCertificateData: defaultUser.AuthInfo.ClientCertificateData,
0000000000000000000000000000000000000000;;						ClientKey:             badClientKeyPath,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errRegex: fmt.Sprintf(errMissingCertPath, "client-key", badClientKeyPath, "", badClientKeyPath),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:    "user with invalid client certificate",
0000000000000000000000000000000000000000;;				cluster: &defaultCluster,
0000000000000000000000000000000000000000;;				user: &v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;						ClientCertificateData: defaultUser.AuthInfo.ClientCertificateData,
0000000000000000000000000000000000000000;;						ClientKeyData:         clientCert,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errRegex: "tls: found a certificate rather than a key in the PEM for the private key",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:     "valid configuration (certificate data embeded in config)",
0000000000000000000000000000000000000000;;				cluster:  &defaultCluster,
0000000000000000000000000000000000000000;;				user:     &defaultUser,
0000000000000000000000000000000000000000;;				errRegex: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test: "valid configuration (certificate files referenced in config)",
0000000000000000000000000000000000000000;;				cluster: &v1.NamedCluster{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{
0000000000000000000000000000000000000000;;						Server:               "https://webhook.example.com",
0000000000000000000000000000000000000000;;						CertificateAuthority: filepath.Join(dir, "ca.pem"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				user: &v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;						ClientCertificate: filepath.Join(dir, "client.pem"),
0000000000000000000000000000000000000000;;						ClientKey:         filepath.Join(dir, "client-key.pem"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				errRegex: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			err := func() error {
0000000000000000000000000000000000000000;;				kubeConfig := v1.Config{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if tt.cluster != nil {
0000000000000000000000000000000000000000;;					kubeConfig.Clusters = []v1.NamedCluster{*tt.cluster}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if tt.context != nil {
0000000000000000000000000000000000000000;;					kubeConfig.Contexts = []v1.NamedContext{*tt.context}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if tt.user != nil {
0000000000000000000000000000000000000000;;					kubeConfig.AuthInfos = []v1.NamedAuthInfo{*tt.user}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				kubeConfigFile, err := newKubeConfigFile(kubeConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					defer os.Remove(kubeConfigFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					_, err = NewGenericWebhook(registered.NewOrDie(""), scheme.Codecs, kubeConfigFile, groupVersions, retryBackoff)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if tt.errRegex != "" {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected an error", tt.test)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if tt.errRegex == "" {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %v", tt.test, err)
0000000000000000000000000000000000000000;;				} else if !regexp.MustCompile(tt.errRegex).MatchString(err.Error()) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error message to match:\n  Expected: %s\n  Actual:   %s", tt.test, tt.errRegex, err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestMissingKubeConfigFile ensures that a kube config path to a missing file is handled properly
0000000000000000000000000000000000000000;;	func TestMissingKubeConfigFile(t *testing.T) {
0000000000000000000000000000000000000000;;		kubeConfigPath := "/some/missing/path"
0000000000000000000000000000000000000000;;		_, err := NewGenericWebhook(registered.NewOrDie(""), scheme.Codecs, kubeConfigPath, groupVersions, retryBackoff)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("creating the webhook should had failed")
0000000000000000000000000000000000000000;;		} else if strings.Index(err.Error(), fmt.Sprintf("stat %s", kubeConfigPath)) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestTLSConfig ensures that the TLS-based communication between client and server works as expected
0000000000000000000000000000000000000000;;	func TestTLSConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		invalidCert := []byte("invalid")
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			test                            string
0000000000000000000000000000000000000000;;			clientCert, clientKey, clientCA []byte
0000000000000000000000000000000000000000;;			serverCert, serverKey, serverCA []byte
0000000000000000000000000000000000000000;;			errRegex                        string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "invalid server CA",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: invalidCert,
0000000000000000000000000000000000000000;;				errRegex: errBadCertificate,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "invalid client certificate",
0000000000000000000000000000000000000000;;				clientCert: invalidCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: caCert,
0000000000000000000000000000000000000000;;				errRegex: "tls: failed to find any PEM data in certificate input",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "invalid client key",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: invalidCert, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: caCert,
0000000000000000000000000000000000000000;;				errRegex: "tls: failed to find any PEM data in key input",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "client does not trust server",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				errRegex: errSignedByUnknownCA,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "server does not trust client",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: badCACert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: caCert,
0000000000000000000000000000000000000000;;				errRegex: errSignedByUnknownCA + " .*",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "server requires auth, client provides it",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey, serverCA: caCert,
0000000000000000000000000000000000000000;;				errRegex: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "server does not require client auth",
0000000000000000000000000000000000000000;;				clientCA:   caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				errRegex: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:       "server does not require client auth, client provides it",
0000000000000000000000000000000000000000;;				clientCert: clientCert, clientKey: clientKey, clientCA: caCert,
0000000000000000000000000000000000000000;;				serverCert: serverCert, serverKey: serverKey,
0000000000000000000000000000000000000000;;				errRegex: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				test:     "webhook does not support insecure servers",
0000000000000000000000000000000000000000;;				errRegex: errSignedByUnknownCA,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			// Use a closure so defer statements trigger between loop iterations.
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				// Create and start a simple HTTPS server
0000000000000000000000000000000000000000;;				server, err := newTestServer(tt.serverCert, tt.serverKey, tt.serverCA, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: failed to create server: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create a Kubernetes client configuration file
0000000000000000000000000000000000000000;;				configFile, err := newKubeConfigFile(v1.Config{
0000000000000000000000000000000000000000;;					Clusters: []v1.NamedCluster{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Cluster: v1.Cluster{
0000000000000000000000000000000000000000;;								Server: server.URL,
0000000000000000000000000000000000000000;;								CertificateAuthorityData: tt.clientCA,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					AuthInfos: []v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;								ClientCertificateData: tt.clientCert,
0000000000000000000000000000000000000000;;								ClientKeyData:         tt.clientKey,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: %v", tt.test, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defer os.Remove(configFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wh, err := NewGenericWebhook(registered.NewOrDie(""), scheme.Codecs, configFile, groupVersions, retryBackoff)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					err = wh.RestClient.Get().Do().Error()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if tt.errRegex != "" {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected an error", tt.test)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if tt.errRegex == "" {
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected error: %v", tt.test, err)
0000000000000000000000000000000000000000;;					} else if !regexp.MustCompile(tt.errRegex).MatchString(err.Error()) {
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected error message mismatch:\n  Expected: %s\n  Actual:   %s", tt.test, tt.errRegex, err.Error())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestWithExponentialBackoff ensures that the webhook's exponential backoff support works as expected
0000000000000000000000000000000000000000;;	func TestWithExponentialBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		count := 0 // To keep track of the requests
0000000000000000000000000000000000000000;;		gr := schema.GroupResource{
0000000000000000000000000000000000000000;;			Group:    "webhook.util.k8s.io",
0000000000000000000000000000000000000000;;			Resource: "test",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handler that will handle all backoff CONDITIONS
0000000000000000000000000000000000000000;;		ebHandler := func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch count++; count {
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				// Timeout error with retry supplied
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusGatewayTimeout)
0000000000000000000000000000000000000000;;				json.NewEncoder(w).Encode(apierrors.NewServerTimeout(gr, "get", 2))
0000000000000000000000000000000000000000;;			case 2:
0000000000000000000000000000000000000000;;				// Internal server error
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				json.NewEncoder(w).Encode(apierrors.NewInternalError(fmt.Errorf("nope")))
0000000000000000000000000000000000000000;;			case 3:
0000000000000000000000000000000000000000;;				// HTTP error that is not retryable
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNotAcceptable)
0000000000000000000000000000000000000000;;				json.NewEncoder(w).Encode(apierrors.NewGenericServerResponse(http.StatusNotAcceptable, "get", gr, "testing", "nope", 0, false))
0000000000000000000000000000000000000000;;			case 4:
0000000000000000000000000000000000000000;;				// Successful request
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;				json.NewEncoder(w).Encode(map[string]string{
0000000000000000000000000000000000000000;;					"status": "OK",
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create and start a simple HTTPS server
0000000000000000000000000000000000000000;;		server, err := newTestServer(clientCert, clientKey, caCert, ebHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create server: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a Kubernetes client configuration file
0000000000000000000000000000000000000000;;		configFile, err := newKubeConfigFile(v1.Config{
0000000000000000000000000000000000000000;;			Clusters: []v1.NamedCluster{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Cluster: v1.Cluster{
0000000000000000000000000000000000000000;;						Server: server.URL,
0000000000000000000000000000000000000000;;						CertificateAuthorityData: caCert,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			AuthInfos: []v1.NamedAuthInfo{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					AuthInfo: v1.AuthInfo{
0000000000000000000000000000000000000000;;						ClientCertificateData: clientCert,
0000000000000000000000000000000000000000;;						ClientKeyData:         clientKey,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to create the client config file: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer os.Remove(configFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wh, err := NewGenericWebhook(registered.NewOrDie(""), scheme.Codecs, configFile, groupVersions, retryBackoff)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create the webhook: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := wh.WithExponentialBackoff(func() rest.Result {
0000000000000000000000000000000000000000;;			return wh.RestClient.Get().Do()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var statusCode int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.StatusCode(&statusCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if statusCode != http.StatusNotAcceptable {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected status code: %d", statusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result = wh.WithExponentialBackoff(func() rest.Result {
0000000000000000000000000000000000000000;;			return wh.RestClient.Get().Do()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.StatusCode(&statusCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if statusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected status code: %d", statusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bootstrapTestDir(t *testing.T) string {
0000000000000000000000000000000000000000;;		dir, err := ioutil.TempDir("", "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The certificates needed on disk for the tests
0000000000000000000000000000000000000000;;		files := map[string][]byte{
0000000000000000000000000000000000000000;;			"ca.pem":         caCert,
0000000000000000000000000000000000000000;;			"client.pem":     clientCert,
0000000000000000000000000000000000000000;;			"client-key.pem": clientKey,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the certificate files to disk or fail
0000000000000000000000000000000000000000;;		for fileName, fileData := range files {
0000000000000000000000000000000000000000;;			if err := ioutil.WriteFile(filepath.Join(dir, fileName), fileData, 0400); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newKubeConfigFile(config v1.Config) (string, error) {
0000000000000000000000000000000000000000;;		configFile, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to create the Kubernetes client config file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = json.NewEncoder(configFile).Encode(config); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to write the Kubernetes client configuration to disk: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return configFile.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestServer(clientCert, clientKey, caCert []byte, handler func(http.ResponseWriter, *http.Request)) (*httptest.Server, error) {
0000000000000000000000000000000000000000;;		var tlsConfig *tls.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if clientCert != nil {
0000000000000000000000000000000000000000;;			cert, err := tls.X509KeyPair(clientCert, clientKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tlsConfig = &tls.Config{
0000000000000000000000000000000000000000;;				Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if caCert != nil {
0000000000000000000000000000000000000000;;			rootCAs := x509.NewCertPool()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rootCAs.AppendCertsFromPEM(caCert)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tlsConfig == nil {
0000000000000000000000000000000000000000;;				tlsConfig = &tls.Config{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tlsConfig.ClientCAs = rootCAs
0000000000000000000000000000000000000000;;			tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if handler == nil {
0000000000000000000000000000000000000000;;			handler = func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				w.Write([]byte("OK"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewUnstartedServer(http.HandlerFunc(handler))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server.TLS = tlsConfig
0000000000000000000000000000000000000000;;		server.StartTLS()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server, nil
0000000000000000000000000000000000000000;;	}
