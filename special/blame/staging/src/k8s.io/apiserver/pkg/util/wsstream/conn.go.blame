0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1171e0d21008d8a5368fdafc4a759176bbe282f4;pkg/util/wsstream/conn.go[pkg/util/wsstream/conn.go][staging/src/k8s.io/apiserver/pkg/util/wsstream/conn.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package wsstream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Websocket subprotocol "channel.k8s.io" prepends each binary message with a byte indicating
0000000000000000000000000000000000000000;;	// the channel number (zero indexed) the message was sent on. Messages in both directions should
0000000000000000000000000000000000000000;;	// prefix their messages with this channel byte. When used for remote execution, the channel numbers
0000000000000000000000000000000000000000;;	// are by convention defined to match the POSIX file-descriptors assigned to STDIN, STDOUT, and STDERR
0000000000000000000000000000000000000000;;	// (0, 1, and 2). No other conversion is performed on the raw subprotocol - writes are sent as they
0000000000000000000000000000000000000000;;	// are received by the server.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example client session:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    CONNECT http://server.com with subprotocol "channel.k8s.io"
0000000000000000000000000000000000000000;;	//    WRITE []byte{0, 102, 111, 111, 10} # send "foo\n" on channel 0 (STDIN)
0000000000000000000000000000000000000000;;	//    READ  []byte{1, 10}                # receive "\n" on channel 1 (STDOUT)
0000000000000000000000000000000000000000;;	//    CLOSE
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	const ChannelWebSocketProtocol = "channel.k8s.io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Websocket subprotocol "base64.channel.k8s.io" base64 encodes each message with a character
0000000000000000000000000000000000000000;;	// indicating the channel number (zero indexed) the message was sent on. Messages in both directions
0000000000000000000000000000000000000000;;	// should prefix their messages with this channel char. When used for remote execution, the channel
0000000000000000000000000000000000000000;;	// numbers are by convention defined to match the POSIX file-descriptors assigned to STDIN, STDOUT,
0000000000000000000000000000000000000000;;	// and STDERR ('0', '1', and '2'). The data received on the server is base64 decoded (and must be
0000000000000000000000000000000000000000;;	// be valid) and data written by the server to the client is base64 encoded.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example client session:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    CONNECT http://server.com with subprotocol "base64.channel.k8s.io"
0000000000000000000000000000000000000000;;	//    WRITE []byte{48, 90, 109, 57, 118, 67, 103, 111, 61} # send "foo\n" (base64: "Zm9vCgo=") on channel '0' (STDIN)
0000000000000000000000000000000000000000;;	//    READ  []byte{49, 67, 103, 61, 61} # receive "\n" (base64: "Cg==") on channel '1' (STDOUT)
0000000000000000000000000000000000000000;;	//    CLOSE
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	const Base64ChannelWebSocketProtocol = "base64.channel.k8s.io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type codecType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rawCodec codecType = iota
0000000000000000000000000000000000000000;;		base64Codec
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ChannelType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		IgnoreChannel ChannelType = iota
0000000000000000000000000000000000000000;;		ReadChannel
0000000000000000000000000000000000000000;;		WriteChannel
0000000000000000000000000000000000000000;;		ReadWriteChannel
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// connectionUpgradeRegex matches any Connection header value that includes upgrade
0000000000000000000000000000000000000000;;		connectionUpgradeRegex = regexp.MustCompile("(^|.*,\\s*)upgrade($|\\s*,)")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsWebSocketRequest returns true if the incoming request contains connection upgrade headers
0000000000000000000000000000000000000000;;	// for WebSockets.
0000000000000000000000000000000000000000;;	func IsWebSocketRequest(req *http.Request) bool {
0000000000000000000000000000000000000000;;		if !strings.EqualFold(req.Header.Get("Upgrade"), "websocket") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return connectionUpgradeRegex.MatchString(strings.ToLower(req.Header.Get("Connection")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IgnoreReceives reads from a WebSocket until it is closed, then returns. If timeout is set, the
0000000000000000000000000000000000000000;;	// read and write deadlines are pushed every time a new message is received.
0000000000000000000000000000000000000000;;	func IgnoreReceives(ws *websocket.Conn, timeout time.Duration) {
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;		var data []byte
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resetTimeout(ws, timeout)
0000000000000000000000000000000000000000;;			if err := websocket.Message.Receive(ws, &data); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handshake ensures the provided user protocol matches one of the allowed protocols. It returns
0000000000000000000000000000000000000000;;	// no error if no protocol is specified.
0000000000000000000000000000000000000000;;	func handshake(config *websocket.Config, req *http.Request, allowed []string) error {
0000000000000000000000000000000000000000;;		protocols := config.Protocol
0000000000000000000000000000000000000000;;		if len(protocols) == 0 {
0000000000000000000000000000000000000000;;			protocols = []string{""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, protocol := range protocols {
0000000000000000000000000000000000000000;;			for _, allow := range allowed {
0000000000000000000000000000000000000000;;				if allow == protocol {
0000000000000000000000000000000000000000;;					config.Protocol = []string{protocol}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("requested protocol(s) are not supported: %v; supports %v", config.Protocol, allowed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChannelProtocolConfig describes a websocket subprotocol with channels.
0000000000000000000000000000000000000000;;	type ChannelProtocolConfig struct {
0000000000000000000000000000000000000000;;		Binary   bool
0000000000000000000000000000000000000000;;		Channels []ChannelType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultChannelProtocols returns a channel protocol map with the
0000000000000000000000000000000000000000;;	// subprotocols "", "channel.k8s.io", "base64.channel.k8s.io" and the given
0000000000000000000000000000000000000000;;	// channels.
0000000000000000000000000000000000000000;;	func NewDefaultChannelProtocols(channels []ChannelType) map[string]ChannelProtocolConfig {
0000000000000000000000000000000000000000;;		return map[string]ChannelProtocolConfig{
0000000000000000000000000000000000000000;;			"": {Binary: true, Channels: channels},
0000000000000000000000000000000000000000;;			ChannelWebSocketProtocol:       {Binary: true, Channels: channels},
0000000000000000000000000000000000000000;;			Base64ChannelWebSocketProtocol: {Binary: false, Channels: channels},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conn supports sending multiple binary channels over a websocket connection.
0000000000000000000000000000000000000000;;	type Conn struct {
0000000000000000000000000000000000000000;;		protocols        map[string]ChannelProtocolConfig
0000000000000000000000000000000000000000;;		selectedProtocol string
0000000000000000000000000000000000000000;;		channels         []*websocketChannel
0000000000000000000000000000000000000000;;		codec            codecType
0000000000000000000000000000000000000000;;		ready            chan struct{}
0000000000000000000000000000000000000000;;		ws               *websocket.Conn
0000000000000000000000000000000000000000;;		timeout          time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConn creates a WebSocket connection that supports a set of channels. Channels begin each
0000000000000000000000000000000000000000;;	// web socket message with a single byte indicating the channel number (0-N). 255 is reserved for
0000000000000000000000000000000000000000;;	// future use. The channel types for each channel are passed as an array, supporting the different
0000000000000000000000000000000000000000;;	// duplex modes. Read and Write refer to whether the channel can be used as a Reader or Writer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The protocols parameter maps subprotocol names to ChannelProtocols. The empty string subprotocol
0000000000000000000000000000000000000000;;	// name is used if websocket.Config.Protocol is empty.
0000000000000000000000000000000000000000;;	func NewConn(protocols map[string]ChannelProtocolConfig) *Conn {
0000000000000000000000000000000000000000;;		return &Conn{
0000000000000000000000000000000000000000;;			ready:     make(chan struct{}),
0000000000000000000000000000000000000000;;			protocols: protocols,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetIdleTimeout sets the interval for both reads and writes before timeout. If not specified,
0000000000000000000000000000000000000000;;	// there is no timeout on the connection.
0000000000000000000000000000000000000000;;	func (conn *Conn) SetIdleTimeout(duration time.Duration) {
0000000000000000000000000000000000000000;;		conn.timeout = duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open the connection and create channels for reading and writing. It returns
0000000000000000000000000000000000000000;;	// the selected subprotocol, a slice of channels and an error.
0000000000000000000000000000000000000000;;	func (conn *Conn) Open(w http.ResponseWriter, req *http.Request) (string, []io.ReadWriteCloser, error) {
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			defer conn.Close()
0000000000000000000000000000000000000000;;			websocket.Server{Handshake: conn.handshake, Handler: conn.handle}.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		<-conn.ready
0000000000000000000000000000000000000000;;		rwc := make([]io.ReadWriteCloser, len(conn.channels))
0000000000000000000000000000000000000000;;		for i := range conn.channels {
0000000000000000000000000000000000000000;;			rwc[i] = conn.channels[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn.selectedProtocol, rwc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (conn *Conn) initialize(ws *websocket.Conn) {
0000000000000000000000000000000000000000;;		negotiated := ws.Config().Protocol
0000000000000000000000000000000000000000;;		conn.selectedProtocol = negotiated[0]
0000000000000000000000000000000000000000;;		p := conn.protocols[conn.selectedProtocol]
0000000000000000000000000000000000000000;;		if p.Binary {
0000000000000000000000000000000000000000;;			conn.codec = rawCodec
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			conn.codec = base64Codec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.ws = ws
0000000000000000000000000000000000000000;;		conn.channels = make([]*websocketChannel, len(p.Channels))
0000000000000000000000000000000000000000;;		for i, t := range p.Channels {
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case ReadChannel:
0000000000000000000000000000000000000000;;				conn.channels[i] = newWebsocketChannel(conn, byte(i), true, false)
0000000000000000000000000000000000000000;;			case WriteChannel:
0000000000000000000000000000000000000000;;				conn.channels[i] = newWebsocketChannel(conn, byte(i), false, true)
0000000000000000000000000000000000000000;;			case ReadWriteChannel:
0000000000000000000000000000000000000000;;				conn.channels[i] = newWebsocketChannel(conn, byte(i), true, true)
0000000000000000000000000000000000000000;;			case IgnoreChannel:
0000000000000000000000000000000000000000;;				conn.channels[i] = newWebsocketChannel(conn, byte(i), false, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(conn.ready)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (conn *Conn) handshake(config *websocket.Config, req *http.Request) error {
0000000000000000000000000000000000000000;;		supportedProtocols := make([]string, 0, len(conn.protocols))
0000000000000000000000000000000000000000;;		for p := range conn.protocols {
0000000000000000000000000000000000000000;;			supportedProtocols = append(supportedProtocols, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return handshake(config, req, supportedProtocols)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (conn *Conn) resetTimeout() {
0000000000000000000000000000000000000000;;		if conn.timeout > 0 {
0000000000000000000000000000000000000000;;			conn.ws.SetDeadline(time.Now().Add(conn.timeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close is only valid after Open has been called
0000000000000000000000000000000000000000;;	func (conn *Conn) Close() error {
0000000000000000000000000000000000000000;;		<-conn.ready
0000000000000000000000000000000000000000;;		for _, s := range conn.channels {
0000000000000000000000000000000000000000;;			s.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.ws.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handle implements a websocket handler.
0000000000000000000000000000000000000000;;	func (conn *Conn) handle(ws *websocket.Conn) {
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;		conn.initialize(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			conn.resetTimeout()
0000000000000000000000000000000000000000;;			var data []byte
0000000000000000000000000000000000000000;;			if err := websocket.Message.Receive(ws, &data); err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					glog.Errorf("Error on socket receive: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(data) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			channel := data[0]
0000000000000000000000000000000000000000;;			if conn.codec == base64Codec {
0000000000000000000000000000000000000000;;				channel = channel - '0'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data = data[1:]
0000000000000000000000000000000000000000;;			if int(channel) >= len(conn.channels) {
0000000000000000000000000000000000000000;;				glog.V(6).Infof("Frame is targeted for a reader %d that is not valid, possible protocol error", channel)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := conn.channels[channel].DataFromSocket(data); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to write frame to %d: %v\n%s", channel, err, string(data))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write multiplexes the specified channel onto the websocket
0000000000000000000000000000000000000000;;	func (conn *Conn) write(num byte, data []byte) (int, error) {
0000000000000000000000000000000000000000;;		conn.resetTimeout()
0000000000000000000000000000000000000000;;		switch conn.codec {
0000000000000000000000000000000000000000;;		case rawCodec:
0000000000000000000000000000000000000000;;			frame := make([]byte, len(data)+1)
0000000000000000000000000000000000000000;;			frame[0] = num
0000000000000000000000000000000000000000;;			copy(frame[1:], data)
0000000000000000000000000000000000000000;;			if err := websocket.Message.Send(conn.ws, frame); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case base64Codec:
0000000000000000000000000000000000000000;;			frame := string('0'+num) + base64.StdEncoding.EncodeToString(data)
0000000000000000000000000000000000000000;;			if err := websocket.Message.Send(conn.ws, frame); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(data), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// websocketChannel represents a channel in a connection
0000000000000000000000000000000000000000;;	type websocketChannel struct {
0000000000000000000000000000000000000000;;		conn *Conn
0000000000000000000000000000000000000000;;		num  byte
0000000000000000000000000000000000000000;;		r    io.Reader
0000000000000000000000000000000000000000;;		w    io.WriteCloser
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		read, write bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newWebsocketChannel creates a pipe for writing to a websocket. Do not write to this pipe
0000000000000000000000000000000000000000;;	// prior to the connection being opened. It may be no, half, or full duplex depending on
0000000000000000000000000000000000000000;;	// read and write.
0000000000000000000000000000000000000000;;	func newWebsocketChannel(conn *Conn, num byte, read, write bool) *websocketChannel {
0000000000000000000000000000000000000000;;		r, w := io.Pipe()
0000000000000000000000000000000000000000;;		return &websocketChannel{conn, num, r, w, read, write}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *websocketChannel) Write(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !p.write {
0000000000000000000000000000000000000000;;			return len(data), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.conn.write(p.num, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DataFromSocket is invoked by the connection receiver to move data from the connection
0000000000000000000000000000000000000000;;	// into a specific channel.
0000000000000000000000000000000000000000;;	func (p *websocketChannel) DataFromSocket(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !p.read {
0000000000000000000000000000000000000000;;			return len(data), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch p.conn.codec {
0000000000000000000000000000000000000000;;		case rawCodec:
0000000000000000000000000000000000000000;;			return p.w.Write(data)
0000000000000000000000000000000000000000;;		case base64Codec:
0000000000000000000000000000000000000000;;			dst := make([]byte, len(data))
0000000000000000000000000000000000000000;;			n, err := base64.StdEncoding.Decode(dst, data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.w.Write(dst[:n])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *websocketChannel) Read(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !p.read {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.r.Read(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *websocketChannel) Close() error {
0000000000000000000000000000000000000000;;		return p.w.Close()
0000000000000000000000000000000000000000;;	}
