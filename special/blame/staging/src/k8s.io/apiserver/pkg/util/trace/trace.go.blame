0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
0d3b66d79c2e8315cc0f8916e60624ab42db67d4;pkg/util/trace.go[pkg/util/trace.go][staging/src/k8s.io/apiserver/pkg/util/trace/trace.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package trace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type traceStep struct {
0000000000000000000000000000000000000000;;		stepTime time.Time
0000000000000000000000000000000000000000;;		msg      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Trace struct {
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		startTime time.Time
0000000000000000000000000000000000000000;;		steps     []traceStep
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(name string) *Trace {
0000000000000000000000000000000000000000;;		return &Trace{name, time.Now(), nil}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Trace) Step(msg string) {
0000000000000000000000000000000000000000;;		if t.steps == nil {
0000000000000000000000000000000000000000;;			// traces almost always have less than 6 steps, do this to avoid more than a single allocation
0000000000000000000000000000000000000000;;			t.steps = make([]traceStep, 0, 6)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.steps = append(t.steps, traceStep{time.Now(), msg})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Trace) Log() {
0000000000000000000000000000000000000000;;		// an explicit logging request should dump all the steps out at the higher level
0000000000000000000000000000000000000000;;		t.logWithStepThreshold(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Trace) logWithStepThreshold(stepThreshold time.Duration) {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		tracenum := rand.Int31()
0000000000000000000000000000000000000000;;		endTime := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		totalTime := endTime.Sub(t.startTime)
0000000000000000000000000000000000000000;;		buffer.WriteString(fmt.Sprintf("Trace[%d]: %q (started: %v) (total time: %v):\n", tracenum, t.name, t.startTime, totalTime))
0000000000000000000000000000000000000000;;		lastStepTime := t.startTime
0000000000000000000000000000000000000000;;		for _, step := range t.steps {
0000000000000000000000000000000000000000;;			stepDuration := step.stepTime.Sub(lastStepTime)
0000000000000000000000000000000000000000;;			if stepThreshold == 0 || stepDuration > stepThreshold || glog.V(4) {
0000000000000000000000000000000000000000;;				buffer.WriteString(fmt.Sprintf("Trace[%d]: [%v] [%v] %v\n", tracenum, step.stepTime.Sub(t.startTime), stepDuration, step.msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastStepTime = step.stepTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stepDuration := endTime.Sub(lastStepTime)
0000000000000000000000000000000000000000;;		if stepThreshold == 0 || stepDuration > stepThreshold || glog.V(4) {
0000000000000000000000000000000000000000;;			buffer.WriteString(fmt.Sprintf("Trace[%d]: [%v] [%v] END\n", tracenum, endTime.Sub(t.startTime), stepDuration))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Info(buffer.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Trace) LogIfLong(threshold time.Duration) {
0000000000000000000000000000000000000000;;		if time.Since(t.startTime) >= threshold {
0000000000000000000000000000000000000000;;			// if any step took more than it's share of the total allowed time, it deserves a higher log level
0000000000000000000000000000000000000000;;			stepThreshold := threshold / time.Duration(len(t.steps)+1)
0000000000000000000000000000000000000000;;			t.logWithStepThreshold(stepThreshold)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Trace) TotalTime() time.Duration {
0000000000000000000000000000000000000000;;		return time.Since(t.startTime)
0000000000000000000000000000000000000000;;	}
