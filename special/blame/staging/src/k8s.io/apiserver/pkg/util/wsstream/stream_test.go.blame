0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
1171e0d21008d8a5368fdafc4a759176bbe282f4;pkg/util/wsstream/stream_test.go[pkg/util/wsstream/stream_test.go][staging/src/k8s.io/apiserver/pkg/util/wsstream/stream_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package wsstream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStream(t *testing.T) {
0000000000000000000000000000000000000000;;		input := "some random text"
0000000000000000000000000000000000000000;;		r := NewReader(bytes.NewBuffer([]byte(input)), true, NewDefaultReaderProtocols())
0000000000000000000000000000000000000000;;		r.SetIdleTimeout(time.Second)
0000000000000000000000000000000000000000;;		data, err := readWebSocket(r, t, nil)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(data, []byte(input)) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected server read: %v", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStreamPing(t *testing.T) {
0000000000000000000000000000000000000000;;		input := "some random text"
0000000000000000000000000000000000000000;;		r := NewReader(bytes.NewBuffer([]byte(input)), true, NewDefaultReaderProtocols())
0000000000000000000000000000000000000000;;		r.SetIdleTimeout(time.Second)
0000000000000000000000000000000000000000;;		err := expectWebSocketFrames(r, t, nil, [][]byte{
0000000000000000000000000000000000000000;;			{},
0000000000000000000000000000000000000000;;			[]byte(input),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStreamBase64(t *testing.T) {
0000000000000000000000000000000000000000;;		input := "some random text"
0000000000000000000000000000000000000000;;		encoded := base64.StdEncoding.EncodeToString([]byte(input))
0000000000000000000000000000000000000000;;		r := NewReader(bytes.NewBuffer([]byte(input)), true, NewDefaultReaderProtocols())
0000000000000000000000000000000000000000;;		data, err := readWebSocket(r, t, nil, "base64.binary.k8s.io")
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(data, []byte(encoded)) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected server read: %v\n%v", data, []byte(encoded))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStreamVersionedBase64(t *testing.T) {
0000000000000000000000000000000000000000;;		input := "some random text"
0000000000000000000000000000000000000000;;		encoded := base64.StdEncoding.EncodeToString([]byte(input))
0000000000000000000000000000000000000000;;		r := NewReader(bytes.NewBuffer([]byte(input)), true, map[string]ReaderProtocolConfig{
0000000000000000000000000000000000000000;;			"":                        {Binary: true},
0000000000000000000000000000000000000000;;			"binary.k8s.io":           {Binary: true},
0000000000000000000000000000000000000000;;			"base64.binary.k8s.io":    {Binary: false},
0000000000000000000000000000000000000000;;			"v1.binary.k8s.io":        {Binary: true},
0000000000000000000000000000000000000000;;			"v1.base64.binary.k8s.io": {Binary: false},
0000000000000000000000000000000000000000;;			"v2.binary.k8s.io":        {Binary: true},
0000000000000000000000000000000000000000;;			"v2.base64.binary.k8s.io": {Binary: false},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		data, err := readWebSocket(r, t, nil, "v2.base64.binary.k8s.io")
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(data, []byte(encoded)) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected server read: %v\n%v", data, []byte(encoded))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStreamVersionedCopy(t *testing.T) {
0000000000000000000000000000000000000000;;		for i, test := range versionTests() {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				supportedProtocols := map[string]ReaderProtocolConfig{}
0000000000000000000000000000000000000000;;				for p, binary := range test.supported {
0000000000000000000000000000000000000000;;					supportedProtocols[p] = ReaderProtocolConfig{
0000000000000000000000000000000000000000;;						Binary: binary,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				input := "some random text"
0000000000000000000000000000000000000000;;				r := NewReader(bytes.NewBuffer([]byte(input)), true, supportedProtocols)
0000000000000000000000000000000000000000;;				s, addr := newServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;					err := r.Copy(w, req)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						w.WriteHeader(503)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}))
0000000000000000000000000000000000000000;;				defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				config, err := websocket.NewConfig("ws://"+addr, "http://localhost/")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Error(err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				config.Protocol = test.requested
0000000000000000000000000000000000000000;;				client, err := websocket.DialConfig(config)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !test.error {
0000000000000000000000000000000000000000;;						t.Errorf("test %d: didn't expect error: %v", i, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer client.Close()
0000000000000000000000000000000000000000;;				if test.error && err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("test %d: expected an error", i)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				<-r.err
0000000000000000000000000000000000000000;;				if got, expected := r.selectedProtocol, test.expected; got != expected {
0000000000000000000000000000000000000000;;					t.Errorf("test %d: unexpected protocol version: got=%s expected=%s", i, got, expected)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStreamError(t *testing.T) {
0000000000000000000000000000000000000000;;		input := "some random text"
0000000000000000000000000000000000000000;;		errs := &errorReader{
0000000000000000000000000000000000000000;;			reads: [][]byte{
0000000000000000000000000000000000000000;;				[]byte("some random"),
0000000000000000000000000000000000000000;;				[]byte(" text"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			err: fmt.Errorf("bad read"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewReader(errs, false, NewDefaultReaderProtocols())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := readWebSocket(r, t, nil)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(data, []byte(input)) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected server read: %v", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil || err.Error() != "bad read" {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStreamSurvivesPanic(t *testing.T) {
0000000000000000000000000000000000000000;;		input := "some random text"
0000000000000000000000000000000000000000;;		errs := &errorReader{
0000000000000000000000000000000000000000;;			reads: [][]byte{
0000000000000000000000000000000000000000;;				[]byte("some random"),
0000000000000000000000000000000000000000;;				[]byte(" text"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			panicMessage: "bad read",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := NewReader(errs, false, NewDefaultReaderProtocols())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do not call runtime.HandleCrash() in handler. Otherwise, the tests are interrupted.
0000000000000000000000000000000000000000;;		r.handleCrash = func() { recover() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := readWebSocket(r, t, nil)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(data, []byte(input)) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected server read: %v", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStreamClosedDuringRead(t *testing.T) {
0000000000000000000000000000000000000000;;		for i := 0; i < 25; i++ {
0000000000000000000000000000000000000000;;			ch := make(chan struct{})
0000000000000000000000000000000000000000;;			input := "some random text"
0000000000000000000000000000000000000000;;			errs := &errorReader{
0000000000000000000000000000000000000000;;				reads: [][]byte{
0000000000000000000000000000000000000000;;					[]byte("some random"),
0000000000000000000000000000000000000000;;					[]byte(" text"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				err:   fmt.Errorf("stuff"),
0000000000000000000000000000000000000000;;				pause: ch,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r := NewReader(errs, false, NewDefaultReaderProtocols())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			data, err := readWebSocket(r, t, func(c *websocket.Conn) {
0000000000000000000000000000000000000000;;				c.Close()
0000000000000000000000000000000000000000;;				close(ch)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			// verify that the data returned by the server on an early close always has a specific error
0000000000000000000000000000000000000000;;			if err == nil || !strings.Contains(err.Error(), "use of closed network connection") {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// verify that the data returned is a strict subset of the input
0000000000000000000000000000000000000000;;			if !bytes.HasPrefix([]byte(input), data) && len(data) != 0 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected server read: %q", string(data))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorReader struct {
0000000000000000000000000000000000000000;;		reads        [][]byte
0000000000000000000000000000000000000000;;		err          error
0000000000000000000000000000000000000000;;		panicMessage string
0000000000000000000000000000000000000000;;		pause        chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *errorReader) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		if len(r.reads) == 0 {
0000000000000000000000000000000000000000;;			if r.pause != nil {
0000000000000000000000000000000000000000;;				<-r.pause
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(r.panicMessage) != 0 {
0000000000000000000000000000000000000000;;				panic(r.panicMessage)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		next := r.reads[0]
0000000000000000000000000000000000000000;;		r.reads = r.reads[1:]
0000000000000000000000000000000000000000;;		copy(p, next)
0000000000000000000000000000000000000000;;		return len(next), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readWebSocket(r *Reader, t *testing.T, fn func(*websocket.Conn), protocols ...string) ([]byte, error) {
0000000000000000000000000000000000000000;;		errCh := make(chan error, 1)
0000000000000000000000000000000000000000;;		s, addr := newServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			errCh <- r.Copy(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, _ := websocket.NewConfig("ws://"+addr, "http://"+addr)
0000000000000000000000000000000000000000;;		config.Protocol = protocols
0000000000000000000000000000000000000000;;		client, err := websocket.DialConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer client.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fn != nil {
0000000000000000000000000000000000000000;;			fn(client)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return data, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data, <-errCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectWebSocketFrames(r *Reader, t *testing.T, fn func(*websocket.Conn), frames [][]byte, protocols ...string) error {
0000000000000000000000000000000000000000;;		errCh := make(chan error, 1)
0000000000000000000000000000000000000000;;		s, addr := newServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			errCh <- r.Copy(w, req)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config, _ := websocket.NewConfig("ws://"+addr, "http://"+addr)
0000000000000000000000000000000000000000;;		config.Protocol = protocols
0000000000000000000000000000000000000000;;		ws, err := websocket.DialConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fn != nil {
0000000000000000000000000000000000000000;;			fn(ws)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range frames {
0000000000000000000000000000000000000000;;			var data []byte
0000000000000000000000000000000000000000;;			if err := websocket.Message.Receive(ws, &data); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(frames[i], data) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("frame %d did not match expected: %v", data, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var data []byte
0000000000000000000000000000000000000000;;		if err := websocket.Message.Receive(ws, &data); err != io.EOF {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected no more frames: %v (%v)", err, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return <-errCh
0000000000000000000000000000000000000000;;	}
