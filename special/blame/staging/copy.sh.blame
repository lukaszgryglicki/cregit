0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	FAIL_ON_CHANGES=false
0000000000000000000000000000000000000000;;	DRY_RUN=false
0000000000000000000000000000000000000000;;	RUN_FROM_UPDATE_SCRIPT=false
0000000000000000000000000000000000000000;;	while getopts ":fdu" opt; do
0000000000000000000000000000000000000000;;	  case $opt in
0000000000000000000000000000000000000000;;	    f)
0000000000000000000000000000000000000000;;	      FAIL_ON_CHANGES=true
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    d)
0000000000000000000000000000000000000000;;	      DRY_RUN=true
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    u)
0000000000000000000000000000000000000000;;	      RUN_FROM_UPDATE_SCRIPT=true
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    \?)
0000000000000000000000000000000000000000;;	      echo "Invalid option: -$OPTARG" >&2
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	readonly FAIL_ON_CHANGES DRY_RUN
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ "${RUN_FROM_UPDATE_SCRIPT}" != true ]; then
0000000000000000000000000000000000000000;;	  echo "Do not run this script directly, but via hack/update-staging-client-go.sh."
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# PREREQUISITES: run `godep restore` in the main repo before calling this script.
0000000000000000000000000000000000000000;;	kube::util::ensure-temp-dir
0000000000000000000000000000000000000000;;	TMP_GOPATH="${KUBE_TEMP}/go"
0000000000000000000000000000000000000000;;	mkdir -p "${TMP_GOPATH}/src/k8s.io"
0000000000000000000000000000000000000000;;	CLIENTSET="clientset"
0000000000000000000000000000000000000000;;	MAIN_REPO_FROM_SRC="k8s.io/kubernetes"
0000000000000000000000000000000000000000;;	MAIN_REPO="$(cd "${KUBE_ROOT}"; pwd)" # absolute path
0000000000000000000000000000000000000000;;	CLIENT_REPO_FROM_SRC="k8s.io/client-go"
0000000000000000000000000000000000000000;;	CLIENT_REPO="${MAIN_REPO}/staging/src/${CLIENT_REPO_FROM_SRC}"
0000000000000000000000000000000000000000;;	CLIENT_REPO_TEMP="${TMP_GOPATH}/src/k8s.io/construct-client-go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if LANG=C sed --help 2>&1 | grep -q GNU; then
0000000000000000000000000000000000000000;;	  SED="sed"
0000000000000000000000000000000000000000;;	elif which gsed &>/dev/null; then
0000000000000000000000000000000000000000;;	  SED="gsed"
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  echo "Failed to find GNU sed as sed or gsed. If you are on Mac: brew install gnu-sed." >&2
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# working in the ${CLIENT_REPO_TEMP} so 'godep save' won't complain about dirty working tree.
0000000000000000000000000000000000000000;;	echo "creating the tmp directory"
0000000000000000000000000000000000000000;;	mkdir -p "${CLIENT_REPO_TEMP}"
0000000000000000000000000000000000000000;;	cd "${CLIENT_REPO}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# there are two classes of package in staging/client-go, those which are authoritative (client-go has the only copy)
0000000000000000000000000000000000000000;;	# and those which are copied and rewritten (client-go is not authoritative).
0000000000000000000000000000000000000000;;	# we first copy out the authoritative packages to the temp location, then copy non-authoritative packages
0000000000000000000000000000000000000000;;	# then save over the original
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# save copies code from client-go into the temp folder to make sure we don't lose it by accident
0000000000000000000000000000000000000000;;	# TODO this is temporary until everything in certain directories is authoritative
0000000000000000000000000000000000000000;;	function save() {
0000000000000000000000000000000000000000;;	  mkdir -p "$(dirname "${CLIENT_REPO_TEMP}/$1")"
0000000000000000000000000000000000000000;;	  cp -r "${CLIENT_REPO}/$1"* "${CLIENT_REPO_TEMP}/"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# save everything for which the staging directory is the source of truth
0000000000000000000000000000000000000000;;	save "discovery"
0000000000000000000000000000000000000000;;	save "dynamic"
0000000000000000000000000000000000000000;;	save "rest"
0000000000000000000000000000000000000000;;	save "testing"
0000000000000000000000000000000000000000;;	save "tools"
0000000000000000000000000000000000000000;;	save "transport"
0000000000000000000000000000000000000000;;	save "third_party"
0000000000000000000000000000000000000000;;	save "plugin"
0000000000000000000000000000000000000000;;	save "util"
0000000000000000000000000000000000000000;;	save "examples"
0000000000000000000000000000000000000000;;	save "OWNERS"
0000000000000000000000000000000000000000;;	save "Godeps"
0000000000000000000000000000000000000000;;	save "LICENSE"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# mkcp copies file from the main repo to the client repo, it creates the directory if it doesn't exist in the client repo.
0000000000000000000000000000000000000000;;	function mkcp() {
0000000000000000000000000000000000000000;;	  mkdir -p "${CLIENT_REPO_TEMP}/$2" && cp -r "${MAIN_REPO}/$1" "${CLIENT_REPO_TEMP}/$2"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# assemble all the other parts of the staging directory
0000000000000000000000000000000000000000;;	echo "copying client packages"
0000000000000000000000000000000000000000;;	# need to copy version.  We aren't authoritative here
0000000000000000000000000000000000000000;;	# version has subdirs which we don't need.  Only copy the files we want
0000000000000000000000000000000000000000;;	mkdir -p "${CLIENT_REPO_TEMP}/pkg/version"
0000000000000000000000000000000000000000;;	find "${MAIN_REPO}/pkg/version" -maxdepth 1 -type f | xargs -I{} cp {} "${CLIENT_REPO_TEMP}/pkg/version"
0000000000000000000000000000000000000000;;	# need to copy clientsets, though later we should copy APIs and later generate clientsets
0000000000000000000000000000000000000000;;	mkcp "pkg/client/clientset_generated/${CLIENTSET}" "pkg/client/clientset_generated"
0000000000000000000000000000000000000000;;	mkcp "pkg/client/informers/informers_generated/externalversions" "pkg/client/informers/informers_generated"
0000000000000000000000000000000000000000;;	mkcp "pkg/client/listers" "pkg/client"
0000000000000000000000000000000000000000;;	# remove internalversion listers
0000000000000000000000000000000000000000;;	find "${CLIENT_REPO_TEMP}/pkg/client/listers/" -maxdepth 2 -mindepth 2 -name internalversion -exec rm -r {} \;
0000000000000000000000000000000000000000;;	mkcp "pkg/api/v1/ref" "pkg/api/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "rewriting imports"
0000000000000000000000000000000000000000;;	grep -Rl "\"${MAIN_REPO_FROM_SRC}" "${CLIENT_REPO_TEMP}" | \
0000000000000000000000000000000000000000;;	  grep "\.go" | \
0000000000000000000000000000000000000000;;	  grep -v "vendor/" | \
0000000000000000000000000000000000000000;;	  xargs ${SED} -i "s|\"${MAIN_REPO_FROM_SRC}|\"${CLIENT_REPO_FROM_SRC}|g"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# strip all generator tags from client-go
0000000000000000000000000000000000000000;;	find "${CLIENT_REPO_TEMP}" -type f -name "*.go" -print0 | xargs -0 ${SED} -i '/^\/\/ +k8s:openapi-gen=true/d'
0000000000000000000000000000000000000000;;	find "${CLIENT_REPO_TEMP}" -type f -name "*.go" -print0 | xargs -0 ${SED} -i '/^\/\/ +k8s:defaulter-gen=/d'
0000000000000000000000000000000000000000;;	find "${CLIENT_REPO_TEMP}" -type f -name "*.go" -print0 | xargs -0 ${SED} -i '/^\/\/ +k8s:deepcopy-gen=/d'
0000000000000000000000000000000000000000;;	find "${CLIENT_REPO_TEMP}" -type f -name "*.go" -print0 | xargs -0 ${SED} -i '/^\/\/ +k8s:conversion-gen=/d'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "rearranging directory layout"
0000000000000000000000000000000000000000;;	# $1 and $2 are relative to ${CLIENT_REPO_TEMP}
0000000000000000000000000000000000000000;;	function mvfolder {
0000000000000000000000000000000000000000;;	  local src=${1%/#/}
0000000000000000000000000000000000000000;;	  local dst=${2%/#/}
0000000000000000000000000000000000000000;;	  mkdir -p "${CLIENT_REPO_TEMP}/${dst}"
0000000000000000000000000000000000000000;;	  # move
0000000000000000000000000000000000000000;;	  mv "${CLIENT_REPO_TEMP}/${src}"/* "${CLIENT_REPO_TEMP}/${dst}"
0000000000000000000000000000000000000000;;	  # rewrite package
0000000000000000000000000000000000000000;;	  local src_package="${src##*/}"
0000000000000000000000000000000000000000;;	  local dst_package="${dst##*/}"
0000000000000000000000000000000000000000;;	  find "${CLIENT_REPO_TEMP}/${dst}" -type f -name "*.go" -print0 | xargs -0 ${SED} -i "s,package ${src_package},package ${dst_package},g"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  { grep -Rl "\"${CLIENT_REPO_FROM_SRC}/${src}" "${CLIENT_REPO_TEMP}" || true ; } | while read -r target ; do
0000000000000000000000000000000000000000;;	    # rewrite imports
0000000000000000000000000000000000000000;;	    # the first rule is to convert import lines like `restclient "k8s.io/client-go/pkg/client/restclient"`,
0000000000000000000000000000000000000000;;	    # where a package alias is the same the package name.
0000000000000000000000000000000000000000;;	    ${SED} -i "s,\<${src_package} \"${CLIENT_REPO_FROM_SRC}/${src},${dst_package} \"${CLIENT_REPO_FROM_SRC}/${dst},g" "${target}"
0000000000000000000000000000000000000000;;	    ${SED} -i "s,\"${CLIENT_REPO_FROM_SRC}/${src},\"${CLIENT_REPO_FROM_SRC}/${dst},g" "${target}"
0000000000000000000000000000000000000000;;	    # rewrite import invocation
0000000000000000000000000000000000000000;;	    if [ "${src_package}" != "${dst_package}" ]; then
0000000000000000000000000000000000000000;;	      ${SED} -i "s,\<${src_package}\.\([a-zA-Z]\),${dst_package}\.\1,g" "${target}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	mvfolder "pkg/client/clientset_generated/${CLIENTSET}" kubernetes
0000000000000000000000000000000000000000;;	rm -f "${CLIENT_REPO_TEMP}/kubernetes/import_known_versions.go"
0000000000000000000000000000000000000000;;	mvfolder "pkg/client/informers/informers_generated/externalversions" informers
0000000000000000000000000000000000000000;;	mvfolder "pkg/client/listers" listers
0000000000000000000000000000000000000000;;	if [ "$(find "${CLIENT_REPO_TEMP}"/pkg/client -type f -name "*.go")" ]; then
0000000000000000000000000000000000000000;;	  echo "${CLIENT_REPO_TEMP}/pkg/client is expected to be empty"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  rm -r "${CLIENT_REPO_TEMP}"/pkg/client
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "running gofmt"
0000000000000000000000000000000000000000;;	find "${CLIENT_REPO_TEMP}" -type f -name "*.go" -print0 | xargs -0 gofmt -w
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "remove black listed files"
0000000000000000000000000000000000000000;;	find "${CLIENT_REPO_TEMP}" -type f \( \
0000000000000000000000000000000000000000;;	  -name "*.json" -not -name "Godeps.json" -o \
0000000000000000000000000000000000000000;;	  -name "*.yaml" -o \
0000000000000000000000000000000000000000;;	  -name "*.yml" -o \
0000000000000000000000000000000000000000;;	  -name "*.sh" \
0000000000000000000000000000000000000000;;	  \) -delete
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ "${FAIL_ON_CHANGES}" = true ]; then
0000000000000000000000000000000000000000;;	  echo "running FAIL_ON_CHANGES"
0000000000000000000000000000000000000000;;	  # ignore base.go in diff
0000000000000000000000000000000000000000;;	  cp "${CLIENT_REPO}/pkg/version/base.go" "${CLIENT_REPO_TEMP}/pkg/version/"
0000000000000000000000000000000000000000;;	  # TODO(mikedanese): figure out what to do with BUILD files here
0000000000000000000000000000000000000000;;	  if diff -NauprB -x '*BUILD' -I '^\s*\"Comment\"' -I "GoVersion.*\|GodepVersion.*" "${CLIENT_REPO}" "${CLIENT_REPO_TEMP}"; then
0000000000000000000000000000000000000000;;	    echo "${CLIENT_REPO} up to date."
0000000000000000000000000000000000000000;;	    exit 0
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "${CLIENT_REPO} is out of date. Please run hack/update-staging-client-go.sh"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# clean the ${CLIENT_REPO}
0000000000000000000000000000000000000000;;	echo "move to the client repo"
0000000000000000000000000000000000000000;;	if [ "${DRY_RUN}" = false ]; then
0000000000000000000000000000000000000000;;	  ls "${CLIENT_REPO}" | { grep -v '_tmp' || true; } | xargs rm -rf
0000000000000000000000000000000000000000;;	  mv "${CLIENT_REPO_TEMP}"/* "${CLIENT_REPO}"
0000000000000000000000000000000000000000;;	  git checkout HEAD -- $(find "${CLIENT_REPO}" -name BUILD) || true
0000000000000000000000000000000000000000;;	fi
