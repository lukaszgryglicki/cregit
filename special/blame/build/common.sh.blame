0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Common utilities, variables and checks for all build scripts.
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	USER_ID=$(id -u)
0000000000000000000000000000000000000000;;	GROUP_ID=$(id -g)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	DOCKER_OPTS=${DOCKER_OPTS:-""}
0000000000000000000000000000000000000000;;	DOCKER=(docker ${DOCKER_OPTS})
0000000000000000000000000000000000000000;;	DOCKER_HOST=${DOCKER_HOST:-""}
0000000000000000000000000000000000000000;;	DOCKER_MACHINE_NAME=${DOCKER_MACHINE_NAME:-"kube-dev"}
0000000000000000000000000000000000000000;;	readonly DOCKER_MACHINE_DRIVER=${DOCKER_MACHINE_DRIVER:-"virtualbox --virtualbox-memory 4096 --virtualbox-cpu-count -1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This will canonicalize the path
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(cd $(dirname "${BASH_SOURCE}")/.. && pwd -P)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Constants
0000000000000000000000000000000000000000;;	readonly KUBE_BUILD_IMAGE_REPO=kube-build
0000000000000000000000000000000000000000;;	readonly KUBE_BUILD_IMAGE_CROSS_TAG="$(cat ${KUBE_ROOT}/build/build-image/cross/VERSION)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This version number is used to cause everyone to rebuild their data containers
0000000000000000000000000000000000000000;;	# and build image.  This is especially useful for automated build systems like
0000000000000000000000000000000000000000;;	# Jenkins.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Increment/change this number if you change the build image (anything under
0000000000000000000000000000000000000000;;	# build/build-image) or change the set of volumes in the data container.
0000000000000000000000000000000000000000;;	readonly KUBE_BUILD_IMAGE_VERSION_BASE="$(cat ${KUBE_ROOT}/build/build-image/VERSION)"
0000000000000000000000000000000000000000;;	readonly KUBE_BUILD_IMAGE_VERSION="${KUBE_BUILD_IMAGE_VERSION_BASE}-${KUBE_BUILD_IMAGE_CROSS_TAG}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Here we map the output directories across both the local and remote _output
0000000000000000000000000000000000000000;;	# directories:
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# *_OUTPUT_ROOT    - the base of all output in that environment.
0000000000000000000000000000000000000000;;	# *_OUTPUT_SUBPATH - location where golang stuff is built/cached.  Also
0000000000000000000000000000000000000000;;	#                    persisted across docker runs with a volume mount.
0000000000000000000000000000000000000000;;	# *_OUTPUT_BINPATH - location where final binaries are placed.  If the remote
0000000000000000000000000000000000000000;;	#                    is really remote, this is the stuff that has to be copied
0000000000000000000000000000000000000000;;	#                    back.
0000000000000000000000000000000000000000;;	# OUT_DIR can come in from the Makefile, so honor it.
0000000000000000000000000000000000000000;;	readonly LOCAL_OUTPUT_ROOT="${KUBE_ROOT}/${OUT_DIR:-_output}"
0000000000000000000000000000000000000000;;	readonly LOCAL_OUTPUT_SUBPATH="${LOCAL_OUTPUT_ROOT}/dockerized"
0000000000000000000000000000000000000000;;	readonly LOCAL_OUTPUT_BINPATH="${LOCAL_OUTPUT_SUBPATH}/bin"
0000000000000000000000000000000000000000;;	readonly LOCAL_OUTPUT_GOPATH="${LOCAL_OUTPUT_SUBPATH}/go"
0000000000000000000000000000000000000000;;	readonly LOCAL_OUTPUT_IMAGE_STAGING="${LOCAL_OUTPUT_ROOT}/images"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is a symlink to binaries for "this platform" (e.g. build tools).
0000000000000000000000000000000000000000;;	readonly THIS_PLATFORM_BIN="${LOCAL_OUTPUT_ROOT}/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly REMOTE_ROOT="/go/src/${KUBE_GO_PACKAGE}"
0000000000000000000000000000000000000000;;	readonly REMOTE_OUTPUT_ROOT="${REMOTE_ROOT}/_output"
0000000000000000000000000000000000000000;;	readonly REMOTE_OUTPUT_SUBPATH="${REMOTE_OUTPUT_ROOT}/dockerized"
0000000000000000000000000000000000000000;;	readonly REMOTE_OUTPUT_BINPATH="${REMOTE_OUTPUT_SUBPATH}/bin"
0000000000000000000000000000000000000000;;	readonly REMOTE_OUTPUT_GOPATH="${REMOTE_OUTPUT_SUBPATH}/go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is the port on the workstation host to expose RSYNC on.  Set this if you
0000000000000000000000000000000000000000;;	# are doing something fancy with ssh tunneling.
0000000000000000000000000000000000000000;;	readonly KUBE_RSYNC_PORT="${KUBE_RSYNC_PORT:-}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is the port that rsync is running on *inside* the container. This may be
0000000000000000000000000000000000000000;;	# mapped to KUBE_RSYNC_PORT via docker networking.
0000000000000000000000000000000000000000;;	readonly KUBE_CONTAINER_RSYNC_PORT=8730
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Get the set of master binaries that run in Docker (on Linux)
0000000000000000000000000000000000000000;;	# Entry format is "<name-of-binary>,<base-image>".
0000000000000000000000000000000000000000;;	# Binaries are placed in /usr/local/bin inside the image.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1 - server architecture
0000000000000000000000000000000000000000;;	kube::build::get_docker_wrapped_binaries() {
0000000000000000000000000000000000000000;;	  debian_iptables_version=v7
0000000000000000000000000000000000000000;;	  ### If you change any of these lists, please also update DOCKERIZED_BINARIES
0000000000000000000000000000000000000000;;	  ### in build/BUILD.
0000000000000000000000000000000000000000;;	  case $1 in
0000000000000000000000000000000000000000;;	    "amd64")
0000000000000000000000000000000000000000;;	        local targets=(
0000000000000000000000000000000000000000;;	          cloud-controller-manager,busybox
0000000000000000000000000000000000000000;;	          kube-apiserver,busybox
0000000000000000000000000000000000000000;;	          kube-controller-manager,busybox
0000000000000000000000000000000000000000;;	          kube-scheduler,busybox
0000000000000000000000000000000000000000;;	          kube-aggregator,busybox
0000000000000000000000000000000000000000;;	          kube-proxy,gcr.io/google-containers/debian-iptables-amd64:${debian_iptables_version}
0000000000000000000000000000000000000000;;	        );;
0000000000000000000000000000000000000000;;	    "arm")
0000000000000000000000000000000000000000;;	        local targets=(
0000000000000000000000000000000000000000;;	          cloud-controller-manager,armel/busybox
0000000000000000000000000000000000000000;;	          kube-apiserver,armel/busybox
0000000000000000000000000000000000000000;;	          kube-controller-manager,armel/busybox
0000000000000000000000000000000000000000;;	          kube-scheduler,armel/busybox
0000000000000000000000000000000000000000;;	          kube-aggregator,armel/busybox
0000000000000000000000000000000000000000;;	          kube-proxy,gcr.io/google-containers/debian-iptables-arm:${debian_iptables_version}
0000000000000000000000000000000000000000;;	        );;
0000000000000000000000000000000000000000;;	    "arm64")
0000000000000000000000000000000000000000;;	        local targets=(
0000000000000000000000000000000000000000;;	          cloud-controller-manager,aarch64/busybox
0000000000000000000000000000000000000000;;	          kube-apiserver,aarch64/busybox
0000000000000000000000000000000000000000;;	          kube-controller-manager,aarch64/busybox
0000000000000000000000000000000000000000;;	          kube-scheduler,aarch64/busybox
0000000000000000000000000000000000000000;;	          kube-aggregator,aarch64/busybox
0000000000000000000000000000000000000000;;	          kube-proxy,gcr.io/google-containers/debian-iptables-arm64:${debian_iptables_version}
0000000000000000000000000000000000000000;;	        );;
0000000000000000000000000000000000000000;;	    "ppc64le")
0000000000000000000000000000000000000000;;	        local targets=(
0000000000000000000000000000000000000000;;	          cloud-controller-manager,ppc64le/busybox
0000000000000000000000000000000000000000;;	          kube-apiserver,ppc64le/busybox
0000000000000000000000000000000000000000;;	          kube-controller-manager,ppc64le/busybox
0000000000000000000000000000000000000000;;	          kube-scheduler,ppc64le/busybox
0000000000000000000000000000000000000000;;	          kube-aggregator,ppc64le/busybox
0000000000000000000000000000000000000000;;	          kube-proxy,gcr.io/google-containers/debian-iptables-ppc64le:${debian_iptables_version}
0000000000000000000000000000000000000000;;	        );;
0000000000000000000000000000000000000000;;	    "s390x")
0000000000000000000000000000000000000000;;	        local targets=(
0000000000000000000000000000000000000000;;	          cloud-controller-manager,s390x/busybox
0000000000000000000000000000000000000000;;	          kube-apiserver,s390x/busybox
0000000000000000000000000000000000000000;;	          kube-controller-manager,s390x/busybox
0000000000000000000000000000000000000000;;	          kube-scheduler,s390x/busybox
0000000000000000000000000000000000000000;;	          kube-aggregator,s390x/busybox
0000000000000000000000000000000000000000;;	          kube-proxy,gcr.io/google-containers/debian-iptables-s390x:${debian_iptables_version}
0000000000000000000000000000000000000000;;	        );;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "${targets[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# ---------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	# Basic setup functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify that the right utilities and such are installed for building Kube. Set
0000000000000000000000000000000000000000;;	# up some dynamic constants.
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#   $1 - boolean of whether to require functioning docker (default true)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Vars set:
0000000000000000000000000000000000000000;;	#   KUBE_ROOT_HASH
0000000000000000000000000000000000000000;;	#   KUBE_BUILD_IMAGE_TAG_BASE
0000000000000000000000000000000000000000;;	#   KUBE_BUILD_IMAGE_TAG
0000000000000000000000000000000000000000;;	#   KUBE_BUILD_IMAGE
0000000000000000000000000000000000000000;;	#   KUBE_BUILD_CONTAINER_NAME_BASE
0000000000000000000000000000000000000000;;	#   KUBE_BUILD_CONTAINER_NAME
0000000000000000000000000000000000000000;;	#   KUBE_DATA_CONTAINER_NAME_BASE
0000000000000000000000000000000000000000;;	#   KUBE_DATA_CONTAINER_NAME
0000000000000000000000000000000000000000;;	#   KUBE_RSYNC_CONTAINER_NAME_BASE
0000000000000000000000000000000000000000;;	#   KUBE_RSYNC_CONTAINER_NAME
0000000000000000000000000000000000000000;;	#   DOCKER_MOUNT_ARGS
0000000000000000000000000000000000000000;;	#   LOCAL_OUTPUT_BUILD_CONTEXT
0000000000000000000000000000000000000000;;	function kube::build::verify_prereqs() {
0000000000000000000000000000000000000000;;	  local -r require_docker=${1:-true}
0000000000000000000000000000000000000000;;	  kube::log::status "Verifying Prerequisites...."
0000000000000000000000000000000000000000;;	  kube::build::ensure_tar || return 1
0000000000000000000000000000000000000000;;	  kube::build::ensure_rsync || return 1
0000000000000000000000000000000000000000;;	  if ${require_docker}; then
0000000000000000000000000000000000000000;;	    kube::build::ensure_docker_in_path || return 1
0000000000000000000000000000000000000000;;	    if kube::build::is_osx; then
0000000000000000000000000000000000000000;;	        kube::build::docker_available_on_osx || return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    kube::util::ensure_docker_daemon_connectivity || return 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if (( ${KUBE_VERBOSE} > 6 )); then
0000000000000000000000000000000000000000;;	      kube::log::status "Docker Version:"
0000000000000000000000000000000000000000;;	      "${DOCKER[@]}" version | kube::log::info_from_stdin
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBE_GIT_BRANCH=$(git symbolic-ref --short -q HEAD 2>/dev/null || true)
0000000000000000000000000000000000000000;;	  KUBE_ROOT_HASH=$(kube::build::short_hash "${HOSTNAME:-}:${KUBE_ROOT}:${KUBE_GIT_BRANCH}")
0000000000000000000000000000000000000000;;	  KUBE_BUILD_IMAGE_TAG_BASE="build-${KUBE_ROOT_HASH}"
0000000000000000000000000000000000000000;;	  KUBE_BUILD_IMAGE_TAG="${KUBE_BUILD_IMAGE_TAG_BASE}-${KUBE_BUILD_IMAGE_VERSION}"
0000000000000000000000000000000000000000;;	  KUBE_BUILD_IMAGE="${KUBE_BUILD_IMAGE_REPO}:${KUBE_BUILD_IMAGE_TAG}"
0000000000000000000000000000000000000000;;	  KUBE_BUILD_CONTAINER_NAME_BASE="kube-build-${KUBE_ROOT_HASH}"
0000000000000000000000000000000000000000;;	  KUBE_BUILD_CONTAINER_NAME="${KUBE_BUILD_CONTAINER_NAME_BASE}-${KUBE_BUILD_IMAGE_VERSION}"
0000000000000000000000000000000000000000;;	  KUBE_RSYNC_CONTAINER_NAME_BASE="kube-rsync-${KUBE_ROOT_HASH}"
0000000000000000000000000000000000000000;;	  KUBE_RSYNC_CONTAINER_NAME="${KUBE_RSYNC_CONTAINER_NAME_BASE}-${KUBE_BUILD_IMAGE_VERSION}"
0000000000000000000000000000000000000000;;	  KUBE_DATA_CONTAINER_NAME_BASE="kube-build-data-${KUBE_ROOT_HASH}"
0000000000000000000000000000000000000000;;	  KUBE_DATA_CONTAINER_NAME="${KUBE_DATA_CONTAINER_NAME_BASE}-${KUBE_BUILD_IMAGE_VERSION}"
0000000000000000000000000000000000000000;;	  DOCKER_MOUNT_ARGS=(--volumes-from "${KUBE_DATA_CONTAINER_NAME}")
0000000000000000000000000000000000000000;;	  LOCAL_OUTPUT_BUILD_CONTEXT="${LOCAL_OUTPUT_IMAGE_STAGING}/${KUBE_BUILD_IMAGE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::version::get_version_vars
0000000000000000000000000000000000000000;;	  kube::version::save_version_vars "${KUBE_ROOT}/.dockerized-kube-version-defs"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# ---------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	# Utility functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::docker_available_on_osx() {
0000000000000000000000000000000000000000;;	  if [[ -z "${DOCKER_HOST}" ]]; then
0000000000000000000000000000000000000000;;	    if [[ -S "/var/run/docker.sock" ]]; then
0000000000000000000000000000000000000000;;	      kube::log::status "Using Docker for MacOS"
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::log::status "No docker host is set. Checking options for setting one..."
0000000000000000000000000000000000000000;;	    if [[ -z "$(which docker-machine)" ]]; then
0000000000000000000000000000000000000000;;	      kube::log::status "It looks like you're running Mac OS X, yet neither Docker for Mac nor docker-machine can be found."
0000000000000000000000000000000000000000;;	      kube::log::status "See: https://docs.docker.com/engine/installation/mac/ for installation instructions."
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    elif [[ -n "$(which docker-machine)" ]]; then
0000000000000000000000000000000000000000;;	      kube::build::prepare_docker_machine
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::prepare_docker_machine() {
0000000000000000000000000000000000000000;;	  kube::log::status "docker-machine was found."
0000000000000000000000000000000000000000;;	  docker-machine inspect "${DOCKER_MACHINE_NAME}" &> /dev/null || {
0000000000000000000000000000000000000000;;	    kube::log::status "Creating a machine to build Kubernetes"
0000000000000000000000000000000000000000;;	    docker-machine create --driver ${DOCKER_MACHINE_DRIVER} \
0000000000000000000000000000000000000000;;	      --engine-env HTTP_PROXY="${KUBERNETES_HTTP_PROXY:-}" \
0000000000000000000000000000000000000000;;	      --engine-env HTTPS_PROXY="${KUBERNETES_HTTPS_PROXY:-}" \
0000000000000000000000000000000000000000;;	      --engine-env NO_PROXY="${KUBERNETES_NO_PROXY:-127.0.0.1}" \
0000000000000000000000000000000000000000;;	      "${DOCKER_MACHINE_NAME}" > /dev/null || {
0000000000000000000000000000000000000000;;	      kube::log::error "Something went wrong creating a machine."
0000000000000000000000000000000000000000;;	      kube::log::error "Try the following: "
0000000000000000000000000000000000000000;;	      kube::log::error "docker-machine create -d ${DOCKER_MACHINE_DRIVER} ${DOCKER_MACHINE_NAME}"
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	  docker-machine start "${DOCKER_MACHINE_NAME}" &> /dev/null
0000000000000000000000000000000000000000;;	  # it takes `docker-machine env` a few seconds to work if the machine was just started
0000000000000000000000000000000000000000;;	  local docker_machine_out
0000000000000000000000000000000000000000;;	  while ! docker_machine_out=$(docker-machine env "${DOCKER_MACHINE_NAME}" 2>&1); do
0000000000000000000000000000000000000000;;	    if [[ ${docker_machine_out} =~ "Error checking TLS connection" ]]; then
0000000000000000000000000000000000000000;;	      echo ${docker_machine_out}
0000000000000000000000000000000000000000;;	      docker-machine regenerate-certs ${DOCKER_MACHINE_NAME}
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      sleep 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  eval $(docker-machine env "${DOCKER_MACHINE_NAME}")
0000000000000000000000000000000000000000;;	  kube::log::status "A Docker host using docker-machine named '${DOCKER_MACHINE_NAME}' is ready to go!"
0000000000000000000000000000000000000000;;	  return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::is_osx() {
0000000000000000000000000000000000000000;;	  [[ "$(uname)" == "Darwin" ]]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::is_gnu_sed() {
0000000000000000000000000000000000000000;;	  [[ $(sed --version 2>&1) == *GNU* ]]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::ensure_rsync() {
0000000000000000000000000000000000000000;;	  if [[ -z "$(which rsync)" ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "Can't find 'rsync' in PATH, please fix and retry."
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::update_dockerfile() {
0000000000000000000000000000000000000000;;	  if kube::build::is_gnu_sed; then
0000000000000000000000000000000000000000;;	    sed_opts=(-i)
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    sed_opts=(-i '')
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  sed "${sed_opts[@]}" "s/KUBE_BUILD_IMAGE_CROSS_TAG/${KUBE_BUILD_IMAGE_CROSS_TAG}/" "${LOCAL_OUTPUT_BUILD_CONTEXT}/Dockerfile"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::ensure_docker_in_path() {
0000000000000000000000000000000000000000;;	  if [[ -z "$(which docker)" ]]; then
0000000000000000000000000000000000000000;;	    kube::log::error "Can't find 'docker' in PATH, please fix and retry."
0000000000000000000000000000000000000000;;	    kube::log::error "See https://docs.docker.com/installation/#installation for installation instructions."
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::ensure_tar() {
0000000000000000000000000000000000000000;;	  if [[ -n "${TAR:-}" ]]; then
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Find gnu tar if it is available, bomb out if not.
0000000000000000000000000000000000000000;;	  TAR=tar
0000000000000000000000000000000000000000;;	  if which gtar &>/dev/null; then
0000000000000000000000000000000000000000;;	      TAR=gtar
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	      if which gnutar &>/dev/null; then
0000000000000000000000000000000000000000;;		  TAR=gnutar
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if ! "${TAR}" --version | grep -q GNU; then
0000000000000000000000000000000000000000;;	    echo "  !!! Cannot find GNU tar. Build on Linux or install GNU tar"
0000000000000000000000000000000000000000;;	    echo "      on Mac OS X (brew install gnu-tar)."
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::has_docker() {
0000000000000000000000000000000000000000;;	  which docker &> /dev/null
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Detect if a specific image exists
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1 - image repo name
0000000000000000000000000000000000000000;;	# #2 - image tag
0000000000000000000000000000000000000000;;	function kube::build::docker_image_exists() {
0000000000000000000000000000000000000000;;	  [[ -n $1 && -n $2 ]] || {
0000000000000000000000000000000000000000;;	    kube::log::error "Internal error. Image not specified in docker_image_exists."
0000000000000000000000000000000000000000;;	    exit 2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  [[ $("${DOCKER[@]}" images -q "${1}:${2}") ]]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Delete all images that match a tag prefix except for the "current" version
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1: The image repo/name
0000000000000000000000000000000000000000;;	# $2: The tag base. We consider any image that matches $2*
0000000000000000000000000000000000000000;;	# $3: The current image not to delete if provided
0000000000000000000000000000000000000000;;	function kube::build::docker_delete_old_images() {
0000000000000000000000000000000000000000;;	  # In Docker 1.12, we can replace this with
0000000000000000000000000000000000000000;;	  #    docker images "$1" --format "{{.Tag}}"
0000000000000000000000000000000000000000;;	  for tag in $("${DOCKER[@]}" images ${1} | tail -n +2 | awk '{print $2}') ; do
0000000000000000000000000000000000000000;;	    if [[ "${tag}" != "${2}"* ]] ; then
0000000000000000000000000000000000000000;;	      V=3 kube::log::status "Keeping image ${1}:${tag}"
0000000000000000000000000000000000000000;;	      continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -z "${3:-}" || "${tag}" != "${3}" ]] ; then
0000000000000000000000000000000000000000;;	      V=2 kube::log::status "Deleting image ${1}:${tag}"
0000000000000000000000000000000000000000;;	      "${DOCKER[@]}" rmi "${1}:${tag}" >/dev/null
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      V=3 kube::log::status "Keeping image ${1}:${tag}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Stop and delete all containers that match a pattern
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# $1: The base container prefix
0000000000000000000000000000000000000000;;	# $2: The current container to keep, if provided
0000000000000000000000000000000000000000;;	function kube::build::docker_delete_old_containers() {
0000000000000000000000000000000000000000;;	  # In Docker 1.12 we can replace this line with
0000000000000000000000000000000000000000;;	  #   docker ps -a --format="{{.Names}}"
0000000000000000000000000000000000000000;;	  for container in $("${DOCKER[@]}" ps -a | tail -n +2 | awk '{print $NF}') ; do
0000000000000000000000000000000000000000;;	    if [[ "${container}" != "${1}"* ]] ; then
0000000000000000000000000000000000000000;;	      V=3 kube::log::status "Keeping container ${container}"
0000000000000000000000000000000000000000;;	      continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ -z "${2:-}" || "${container}" != "${2}" ]] ; then
0000000000000000000000000000000000000000;;	      V=2 kube::log::status "Deleting container ${container}"
0000000000000000000000000000000000000000;;	      kube::build::destroy_container "${container}"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      V=3 kube::log::status "Keeping container ${container}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Takes $1 and computes a short has for it. Useful for unique tag generation
0000000000000000000000000000000000000000;;	function kube::build::short_hash() {
0000000000000000000000000000000000000000;;	  [[ $# -eq 1 ]] || {
0000000000000000000000000000000000000000;;	    kube::log::error "Internal error.  No data based to short_hash."
0000000000000000000000000000000000000000;;	    exit 2
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local short_hash
0000000000000000000000000000000000000000;;	  if which md5 >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    short_hash=$(md5 -q -s "$1")
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    short_hash=$(echo -n "$1" | md5sum)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo ${short_hash:0:10}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Pedantically kill, wait-on and remove a container. The -f -v options
0000000000000000000000000000000000000000;;	# to rm don't actually seem to get the job done, so force kill the
0000000000000000000000000000000000000000;;	# container, wait to ensure it's stopped, then try the remove. This is
0000000000000000000000000000000000000000;;	# a workaround for bug https://github.com/docker/docker/issues/3968.
0000000000000000000000000000000000000000;;	function kube::build::destroy_container() {
0000000000000000000000000000000000000000;;	  "${DOCKER[@]}" kill "$1" >/dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	  if [[ $("${DOCKER[@]}" version --format '{{.Server.Version}}') = 17.06.0* ]]; then
0000000000000000000000000000000000000000;;	    # Workaround https://github.com/moby/moby/issues/33948.
0000000000000000000000000000000000000000;;	    # TODO: remove when 17.06.0 is not relevant anymore
0000000000000000000000000000000000000000;;	    DOCKER_API_VERSION=v1.29 "${DOCKER[@]}" wait "$1" >/dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    "${DOCKER[@]}" wait "$1" >/dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  "${DOCKER[@]}" rm -f -v "$1" >/dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# ---------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	# Building
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::clean() {
0000000000000000000000000000000000000000;;	  if kube::build::has_docker ; then
0000000000000000000000000000000000000000;;	    kube::build::docker_delete_old_containers "${KUBE_BUILD_CONTAINER_NAME_BASE}"
0000000000000000000000000000000000000000;;	    kube::build::docker_delete_old_containers "${KUBE_RSYNC_CONTAINER_NAME_BASE}"
0000000000000000000000000000000000000000;;	    kube::build::docker_delete_old_containers "${KUBE_DATA_CONTAINER_NAME_BASE}"
0000000000000000000000000000000000000000;;	    kube::build::docker_delete_old_images "${KUBE_BUILD_IMAGE_REPO}" "${KUBE_BUILD_IMAGE_TAG_BASE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    V=2 kube::log::status "Cleaning all untagged docker images"
0000000000000000000000000000000000000000;;	    "${DOCKER[@]}" rmi $("${DOCKER[@]}" images -q --filter 'dangling=true') 2> /dev/null || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Removing _output directory"
0000000000000000000000000000000000000000;;	  rm -rf "${LOCAL_OUTPUT_ROOT}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Set up the context directory for the kube-build image and build it.
0000000000000000000000000000000000000000;;	function kube::build::build_image() {
0000000000000000000000000000000000000000;;	  mkdir -p "${LOCAL_OUTPUT_BUILD_CONTEXT}"
0000000000000000000000000000000000000000;;	  # Make sure the context directory owned by the right user for syncing sources to container.
0000000000000000000000000000000000000000;;	  chown -R ${USER_ID}:${GROUP_ID} "${LOCAL_OUTPUT_BUILD_CONTEXT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cp /etc/localtime "${LOCAL_OUTPUT_BUILD_CONTEXT}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cp build/build-image/Dockerfile "${LOCAL_OUTPUT_BUILD_CONTEXT}/Dockerfile"
0000000000000000000000000000000000000000;;	  cp build/build-image/rsyncd.sh "${LOCAL_OUTPUT_BUILD_CONTEXT}/"
0000000000000000000000000000000000000000;;	  dd if=/dev/urandom bs=512 count=1 2>/dev/null | LC_ALL=C tr -dc 'A-Za-z0-9' | dd bs=32 count=1 2>/dev/null > "${LOCAL_OUTPUT_BUILD_CONTEXT}/rsyncd.password"
0000000000000000000000000000000000000000;;	  chmod go= "${LOCAL_OUTPUT_BUILD_CONTEXT}/rsyncd.password"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::build::update_dockerfile
0000000000000000000000000000000000000000;;	  kube::build::docker_build "${KUBE_BUILD_IMAGE}" "${LOCAL_OUTPUT_BUILD_CONTEXT}" 'false'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Clean up old versions of everything
0000000000000000000000000000000000000000;;	  kube::build::docker_delete_old_containers "${KUBE_BUILD_CONTAINER_NAME_BASE}" "${KUBE_BUILD_CONTAINER_NAME}"
0000000000000000000000000000000000000000;;	  kube::build::docker_delete_old_containers "${KUBE_RSYNC_CONTAINER_NAME_BASE}" "${KUBE_RSYNC_CONTAINER_NAME}"
0000000000000000000000000000000000000000;;	  kube::build::docker_delete_old_containers "${KUBE_DATA_CONTAINER_NAME_BASE}" "${KUBE_DATA_CONTAINER_NAME}"
0000000000000000000000000000000000000000;;	  kube::build::docker_delete_old_images "${KUBE_BUILD_IMAGE_REPO}" "${KUBE_BUILD_IMAGE_TAG_BASE}" "${KUBE_BUILD_IMAGE_TAG}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::build::ensure_data_container
0000000000000000000000000000000000000000;;	  kube::build::sync_to_container
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Build a docker image from a Dockerfile.
0000000000000000000000000000000000000000;;	# $1 is the name of the image to build
0000000000000000000000000000000000000000;;	# $2 is the location of the "context" directory, with the Dockerfile at the root.
0000000000000000000000000000000000000000;;	# $3 is the value to set the --pull flag for docker build; true by default
0000000000000000000000000000000000000000;;	function kube::build::docker_build() {
0000000000000000000000000000000000000000;;	  local -r image=$1
0000000000000000000000000000000000000000;;	  local -r context_dir=$2
0000000000000000000000000000000000000000;;	  local -r pull="${3:-true}"
0000000000000000000000000000000000000000;;	  local -ra build_cmd=("${DOCKER[@]}" build -t "${image}" "--pull=${pull}" "${context_dir}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Building Docker image ${image}"
0000000000000000000000000000000000000000;;	  local docker_output
0000000000000000000000000000000000000000;;	  docker_output=$("${build_cmd[@]}" 2>&1) || {
0000000000000000000000000000000000000000;;	    cat <<EOF >&2
0000000000000000000000000000000000000000;;	+++ Docker build command failed for ${image}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	${docker_output}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To retry manually, run:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	${build_cmd[*]}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::ensure_data_container() {
0000000000000000000000000000000000000000;;	  # If the data container exists AND exited successfully, we can use it.
0000000000000000000000000000000000000000;;	  # Otherwise nuke it and start over.
0000000000000000000000000000000000000000;;	  local ret=0
0000000000000000000000000000000000000000;;	  local code=$(docker inspect \
0000000000000000000000000000000000000000;;	      -f '{{.State.ExitCode}}' \
0000000000000000000000000000000000000000;;	      "${KUBE_DATA_CONTAINER_NAME}" 2>/dev/null || ret=$?)
0000000000000000000000000000000000000000;;	  if [[ "${ret}" == 0 && "${code}" != 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::build::destroy_container "${KUBE_DATA_CONTAINER_NAME}"
0000000000000000000000000000000000000000;;	    ret=1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ "${ret}" != 0 ]]; then
0000000000000000000000000000000000000000;;	    kube::log::status "Creating data container ${KUBE_DATA_CONTAINER_NAME}"
0000000000000000000000000000000000000000;;	    # We have to ensure the directory exists, or else the docker run will
0000000000000000000000000000000000000000;;	    # create it as root.
0000000000000000000000000000000000000000;;	    mkdir -p "${LOCAL_OUTPUT_GOPATH}"
0000000000000000000000000000000000000000;;	    # We want this to run as root to be able to chown, so non-root users can
0000000000000000000000000000000000000000;;	    # later use the result as a data container.  This run both creates the data
0000000000000000000000000000000000000000;;	    # container and chowns the GOPATH.
0000000000000000000000000000000000000000;;	    #
0000000000000000000000000000000000000000;;	    # The data container creates volumes for all of the directories that store
0000000000000000000000000000000000000000;;	    # intermediates for the Go build. This enables incremental builds across
0000000000000000000000000000000000000000;;	    # Docker sessions. The *_cgo paths are re-compiled versions of the go std
0000000000000000000000000000000000000000;;	    # libraries for true static building.
0000000000000000000000000000000000000000;;	    local -ra docker_cmd=(
0000000000000000000000000000000000000000;;	      "${DOCKER[@]}" run
0000000000000000000000000000000000000000;;	      --volume "${REMOTE_ROOT}"   # white-out the whole output dir
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/linux_386_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/linux_amd64_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/linux_arm_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/linux_arm64_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/linux_ppc64le_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/darwin_amd64_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/darwin_386_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/windows_amd64_cgo
0000000000000000000000000000000000000000;;	      --volume /usr/local/go/pkg/windows_386_cgo
0000000000000000000000000000000000000000;;	      --name "${KUBE_DATA_CONTAINER_NAME}"
0000000000000000000000000000000000000000;;	      --hostname "${HOSTNAME}"
0000000000000000000000000000000000000000;;	      "${KUBE_BUILD_IMAGE}"
0000000000000000000000000000000000000000;;	      chown -R ${USER_ID}:${GROUP_ID}
0000000000000000000000000000000000000000;;	        "${REMOTE_ROOT}"
0000000000000000000000000000000000000000;;	        /usr/local/go/pkg/
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	    "${docker_cmd[@]}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run a command in the kube-build image.  This assumes that the image has
0000000000000000000000000000000000000000;;	# already been built.
0000000000000000000000000000000000000000;;	function kube::build::run_build_command() {
0000000000000000000000000000000000000000;;	  kube::log::status "Running build command..."
0000000000000000000000000000000000000000;;	  kube::build::run_build_command_ex "${KUBE_BUILD_CONTAINER_NAME}" -- "$@"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run a command in the kube-build image.  This assumes that the image has
0000000000000000000000000000000000000000;;	# already been built.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Arguments are in the form of
0000000000000000000000000000000000000000;;	#  <container name> <extra docker args> -- <command>
0000000000000000000000000000000000000000;;	function kube::build::run_build_command_ex() {
0000000000000000000000000000000000000000;;	  [[ $# != 0 ]] || { echo "Invalid input - please specify a container name." >&2; return 4; }
0000000000000000000000000000000000000000;;	  local container_name="${1}"
0000000000000000000000000000000000000000;;	  shift
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local -a docker_run_opts=(
0000000000000000000000000000000000000000;;	    "--name=${container_name}"
0000000000000000000000000000000000000000;;	    "--user=$(id -u):$(id -g)"
0000000000000000000000000000000000000000;;	    "--hostname=${HOSTNAME}"
0000000000000000000000000000000000000000;;	    "${DOCKER_MOUNT_ARGS[@]}"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local detach=false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  [[ $# != 0 ]] || { echo "Invalid input - please specify docker arguments followed by --." >&2; return 4; }
0000000000000000000000000000000000000000;;	  # Everything before "--" is an arg to docker
0000000000000000000000000000000000000000;;	  until [ -z "${1-}" ] ; do
0000000000000000000000000000000000000000;;	    if [[ "$1" == "--" ]]; then
0000000000000000000000000000000000000000;;	      shift
0000000000000000000000000000000000000000;;	      break
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    docker_run_opts+=("$1")
0000000000000000000000000000000000000000;;	    if [[ "$1" == "-d" || "$1" == "--detach" ]] ; then
0000000000000000000000000000000000000000;;	      detach=true
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    shift
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Everything after "--" is the command to run
0000000000000000000000000000000000000000;;	  [[ $# != 0 ]] || { echo "Invalid input - please specify a command to run." >&2; return 4; }
0000000000000000000000000000000000000000;;	  local -a cmd=()
0000000000000000000000000000000000000000;;	  until [ -z "${1-}" ] ; do
0000000000000000000000000000000000000000;;	    cmd+=("$1")
0000000000000000000000000000000000000000;;	    shift
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  docker_run_opts+=(
0000000000000000000000000000000000000000;;	    --env "KUBE_FASTBUILD=${KUBE_FASTBUILD:-false}"
0000000000000000000000000000000000000000;;	    --env "KUBE_BUILDER_OS=${OSTYPE:-notdetected}"
0000000000000000000000000000000000000000;;	    --env "KUBE_VERBOSE=${KUBE_VERBOSE}"
0000000000000000000000000000000000000000;;	    --env "GOFLAGS=${GOFLAGS:-}"
0000000000000000000000000000000000000000;;	    --env "GOLDFLAGS=${GOLDFLAGS:-}"
0000000000000000000000000000000000000000;;	    --env "GOGCFLAGS=${GOGCFLAGS:-}"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If we have stdin we can run interactive.  This allows things like 'shell.sh'
0000000000000000000000000000000000000000;;	  # to work.  However, if we run this way and don't have stdin, then it ends up
0000000000000000000000000000000000000000;;	  # running in a daemon-ish mode.  So if we don't have a stdin, we explicitly
0000000000000000000000000000000000000000;;	  # attach stderr/stdout but don't bother asking for a tty.
0000000000000000000000000000000000000000;;	  if [[ -t 0 ]]; then
0000000000000000000000000000000000000000;;	    docker_run_opts+=(--interactive --tty)
0000000000000000000000000000000000000000;;	  elif [[ "${detach}" == false ]]; then
0000000000000000000000000000000000000000;;	    docker_run_opts+=(--attach=stdout --attach=stderr)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local -ra docker_cmd=(
0000000000000000000000000000000000000000;;	    "${DOCKER[@]}" run "${docker_run_opts[@]}" "${KUBE_BUILD_IMAGE}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Clean up container from any previous run
0000000000000000000000000000000000000000;;	  kube::build::destroy_container "${container_name}"
0000000000000000000000000000000000000000;;	  "${docker_cmd[@]}" "${cmd[@]}"
0000000000000000000000000000000000000000;;	  if [[ "${detach}" == false ]]; then
0000000000000000000000000000000000000000;;	    kube::build::destroy_container "${container_name}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::rsync_probe {
0000000000000000000000000000000000000000;;	  # Wait unil rsync is up and running.
0000000000000000000000000000000000000000;;	  local tries=20
0000000000000000000000000000000000000000;;	  while (( ${tries} > 0 )) ; do
0000000000000000000000000000000000000000;;	    if rsync "rsync://k8s@${1}:${2}/" \
0000000000000000000000000000000000000000;;	         --password-file="${LOCAL_OUTPUT_BUILD_CONTEXT}/rsyncd.password" \
0000000000000000000000000000000000000000;;	         &> /dev/null ; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    tries=$(( ${tries} - 1))
0000000000000000000000000000000000000000;;	    sleep 0.1
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Start up the rsync container in the background. This should be explicitly
0000000000000000000000000000000000000000;;	# stopped with kube::build::stop_rsyncd_container.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# This will set the global var KUBE_RSYNC_ADDR to the effective port that the
0000000000000000000000000000000000000000;;	# rsync daemon can be reached out.
0000000000000000000000000000000000000000;;	function kube::build::start_rsyncd_container() {
0000000000000000000000000000000000000000;;	  kube::build::stop_rsyncd_container
0000000000000000000000000000000000000000;;	  V=3 kube::log::status "Starting rsyncd container"
0000000000000000000000000000000000000000;;	  kube::build::run_build_command_ex \
0000000000000000000000000000000000000000;;	    "${KUBE_RSYNC_CONTAINER_NAME}" -p 127.0.0.1:${KUBE_RSYNC_PORT}:${KUBE_CONTAINER_RSYNC_PORT} -d \
0000000000000000000000000000000000000000;;	    -- /rsyncd.sh >/dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local mapped_port
0000000000000000000000000000000000000000;;	  if ! mapped_port=$("${DOCKER[@]}" port "${KUBE_RSYNC_CONTAINER_NAME}" ${KUBE_CONTAINER_RSYNC_PORT} 2> /dev/null | cut -d: -f 2) ; then
0000000000000000000000000000000000000000;;	    kube::log::error "Could not get effective rsync port"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local container_ip
0000000000000000000000000000000000000000;;	  container_ip=$("${DOCKER[@]}" inspect --format '{{ .NetworkSettings.IPAddress }}' "${KUBE_RSYNC_CONTAINER_NAME}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Sometimes we can reach rsync through localhost and a NAT'd port.  Other
0000000000000000000000000000000000000000;;	  # times (when we are running in another docker container on the Jenkins
0000000000000000000000000000000000000000;;	  # machines) we have to talk directly to the container IP.  There is no one
0000000000000000000000000000000000000000;;	  # strategy that works in all cases so we test to figure out which situation we
0000000000000000000000000000000000000000;;	  # are in.
0000000000000000000000000000000000000000;;	  if kube::build::rsync_probe 127.0.0.1 ${mapped_port}; then
0000000000000000000000000000000000000000;;	    KUBE_RSYNC_ADDR="127.0.0.1:${mapped_port}"
0000000000000000000000000000000000000000;;	    return 0
0000000000000000000000000000000000000000;;	  elif kube::build::rsync_probe "${container_ip}" ${KUBE_CONTAINER_RSYNC_PORT}; then
0000000000000000000000000000000000000000;;	    KUBE_RSYNC_ADDR="${container_ip}:${KUBE_CONTAINER_RSYNC_PORT}"
0000000000000000000000000000000000000000;;	    return 0
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::error "Could not connect to rsync container. See build/README.md for setting up remote Docker engine."
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::stop_rsyncd_container() {
0000000000000000000000000000000000000000;;	  V=3 kube::log::status "Stopping any currently running rsyncd container"
0000000000000000000000000000000000000000;;	  unset KUBE_RSYNC_ADDR
0000000000000000000000000000000000000000;;	  kube::build::destroy_container "${KUBE_RSYNC_CONTAINER_NAME}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::build::rsync {
0000000000000000000000000000000000000000;;	  local -a rsync_opts=(
0000000000000000000000000000000000000000;;	    --archive
0000000000000000000000000000000000000000;;	    --prune-empty-dirs
0000000000000000000000000000000000000000;;	    --password-file="${LOCAL_OUTPUT_BUILD_CONTEXT}/rsyncd.password"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  if (( ${KUBE_VERBOSE} >= 6 )); then
0000000000000000000000000000000000000000;;	    rsync_opts+=("-iv")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if (( ${KUBE_RSYNC_COMPRESS} > 0 )); then
0000000000000000000000000000000000000000;;	     rsync_opts+=("--compress-level=${KUBE_RSYNC_COMPRESS}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  V=3 kube::log::status "Running rsync"
0000000000000000000000000000000000000000;;	  rsync "${rsync_opts[@]}" "$@"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This will launch rsyncd in a container and then sync the source tree to the
0000000000000000000000000000000000000000;;	# container over the local network.
0000000000000000000000000000000000000000;;	function kube::build::sync_to_container() {
0000000000000000000000000000000000000000;;	  kube::log::status "Syncing sources to container"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::build::start_rsyncd_container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # rsync filters are a bit confusing.  Here we are syncing everything except
0000000000000000000000000000000000000000;;	  # output only directories and things that are not necessary like the git
0000000000000000000000000000000000000000;;	  # directory and generated files. The '- /' filter prevents rsync
0000000000000000000000000000000000000000;;	  # from trying to set the uid/gid/perms on the root of the sync tree.
0000000000000000000000000000000000000000;;	  # As an exception, we need to sync generated files in staging/, because
0000000000000000000000000000000000000000;;	  # they will not be re-generated by 'make'.
0000000000000000000000000000000000000000;;	  kube::build::rsync \
0000000000000000000000000000000000000000;;	    --delete \
0000000000000000000000000000000000000000;;	    --filter='+ /staging/**' \
0000000000000000000000000000000000000000;;	    --filter='- /.git/' \
0000000000000000000000000000000000000000;;	    --filter='- /.make/' \
0000000000000000000000000000000000000000;;	    --filter='- /_tmp/' \
0000000000000000000000000000000000000000;;	    --filter='- /_output/' \
0000000000000000000000000000000000000000;;	    --filter='- /' \
0000000000000000000000000000000000000000;;	    --filter='- zz_generated.*' \
0000000000000000000000000000000000000000;;	    --filter='- generated.proto' \
0000000000000000000000000000000000000000;;	    "${KUBE_ROOT}/" "rsync://k8s@${KUBE_RSYNC_ADDR}/k8s/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::build::stop_rsyncd_container
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copy all build results back out.
0000000000000000000000000000000000000000;;	function kube::build::copy_output() {
0000000000000000000000000000000000000000;;	  kube::log::status "Syncing out of container"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::build::start_rsyncd_container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local rsync_extra=""
0000000000000000000000000000000000000000;;	  if (( ${KUBE_VERBOSE} >= 6 )); then
0000000000000000000000000000000000000000;;	    rsync_extra="-iv"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # The filter syntax for rsync is a little obscure. It filters on files and
0000000000000000000000000000000000000000;;	  # directories.  If you don't go in to a directory you won't find any files
0000000000000000000000000000000000000000;;	  # there.  Rules are evaluated in order.  The last two rules are a little
0000000000000000000000000000000000000000;;	  # magic. '+ */' says to go in to every directory and '- /**' says to ignore
0000000000000000000000000000000000000000;;	  # any file or directory that isn't already specifically allowed.
0000000000000000000000000000000000000000;;	  #
0000000000000000000000000000000000000000;;	  # We are looking to copy out all of the built binaries along with various
0000000000000000000000000000000000000000;;	  # generated files.
0000000000000000000000000000000000000000;;	  kube::build::rsync \
0000000000000000000000000000000000000000;;	    --filter='- /vendor/' \
0000000000000000000000000000000000000000;;	    --filter='- /_temp/' \
0000000000000000000000000000000000000000;;	    --filter='+ /_output/dockerized/bin/**' \
0000000000000000000000000000000000000000;;	    --filter='+ zz_generated.*' \
0000000000000000000000000000000000000000;;	    --filter='+ generated.proto' \
0000000000000000000000000000000000000000;;	    --filter='+ *.pb.go' \
0000000000000000000000000000000000000000;;	    --filter='+ types.go' \
0000000000000000000000000000000000000000;;	    --filter='+ */' \
0000000000000000000000000000000000000000;;	    --filter='- /**' \
0000000000000000000000000000000000000000;;	    "rsync://k8s@${KUBE_RSYNC_ADDR}/k8s/" "${KUBE_ROOT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::build::stop_rsyncd_container
0000000000000000000000000000000000000000;;	}
