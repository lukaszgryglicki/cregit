0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This file creates release artifacts (tar files, container images) that are
0000000000000000000000000000000000000000;;	# ready to distribute to install or distribute to end users.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###############################################################################
0000000000000000000000000000000000000000;;	# Most of the ::release:: namespace functions have been moved to
0000000000000000000000000000000000000000;;	# github.com/kubernetes/release.  Have a look in that repo and specifically in
0000000000000000000000000000000000000000;;	# lib/releaselib.sh for ::release::-related functionality.
0000000000000000000000000000000000000000;;	###############################################################################
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is where the final release artifacts are created locally
0000000000000000000000000000000000000000;;	readonly RELEASE_STAGE="${LOCAL_OUTPUT_ROOT}/release-stage"
0000000000000000000000000000000000000000;;	readonly RELEASE_TARS="${LOCAL_OUTPUT_ROOT}/release-tars"
0000000000000000000000000000000000000000;;	readonly RELEASE_IMAGES="${LOCAL_OUTPUT_ROOT}/release-images"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_BUILD_HYPERKUBE=${KUBE_BUILD_HYPERKUBE:-n}
0000000000000000000000000000000000000000;;	if [[ -n "${KUBE_DOCKER_IMAGE_TAG-}" && -n "${KUBE_DOCKER_REGISTRY-}" ]]; then
0000000000000000000000000000000000000000;;	  # retain legacy behavior of automatically building hyperkube during releases
0000000000000000000000000000000000000000;;	  KUBE_BUILD_HYPERKUBE=y
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Validate a ci version
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Globals:
0000000000000000000000000000000000000000;;	#   None
0000000000000000000000000000000000000000;;	# Arguments:
0000000000000000000000000000000000000000;;	#   version
0000000000000000000000000000000000000000;;	# Returns:
0000000000000000000000000000000000000000;;	#   If version is a valid ci version
0000000000000000000000000000000000000000;;	# Sets:                    (e.g. for '1.2.3-alpha.4.56+abcdef12345678')
0000000000000000000000000000000000000000;;	#   VERSION_MAJOR          (e.g. '1')
0000000000000000000000000000000000000000;;	#   VERSION_MINOR          (e.g. '2')
0000000000000000000000000000000000000000;;	#   VERSION_PATCH          (e.g. '3')
0000000000000000000000000000000000000000;;	#   VERSION_PRERELEASE     (e.g. 'alpha')
0000000000000000000000000000000000000000;;	#   VERSION_PRERELEASE_REV (e.g. '4')
0000000000000000000000000000000000000000;;	#   VERSION_BUILD_INFO     (e.g. '.56+abcdef12345678')
0000000000000000000000000000000000000000;;	#   VERSION_COMMITS        (e.g. '56')
0000000000000000000000000000000000000000;;	function kube::release::parse_and_validate_ci_version() {
0000000000000000000000000000000000000000;;	  # Accept things like "v1.2.3-alpha.4.56+abcdef12345678" or "v1.2.3-beta.4"
0000000000000000000000000000000000000000;;	  local -r version_regex="^v(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)\\.(0|[1-9][0-9]*)-([a-zA-Z0-9]+)\\.(0|[1-9][0-9]*)(\\.(0|[1-9][0-9]*)\\+[0-9a-f]{7,40})?$"
0000000000000000000000000000000000000000;;	  local -r version="${1-}"
0000000000000000000000000000000000000000;;	  [[ "${version}" =~ ${version_regex} ]] || {
0000000000000000000000000000000000000000;;	    kube::log::error "Invalid ci version: '${version}', must match regex ${version_regex}"
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	  VERSION_MAJOR="${BASH_REMATCH[1]}"
0000000000000000000000000000000000000000;;	  VERSION_MINOR="${BASH_REMATCH[2]}"
0000000000000000000000000000000000000000;;	  VERSION_PATCH="${BASH_REMATCH[3]}"
0000000000000000000000000000000000000000;;	  VERSION_PRERELEASE="${BASH_REMATCH[4]}"
0000000000000000000000000000000000000000;;	  VERSION_PRERELEASE_REV="${BASH_REMATCH[5]}"
0000000000000000000000000000000000000000;;	  VERSION_BUILD_INFO="${BASH_REMATCH[6]}"
0000000000000000000000000000000000000000;;	  VERSION_COMMITS="${BASH_REMATCH[7]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# ---------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	# Build final release artifacts
0000000000000000000000000000000000000000;;	function kube::release::clean_cruft() {
0000000000000000000000000000000000000000;;	  # Clean out cruft
0000000000000000000000000000000000000000;;	  find ${RELEASE_STAGE} -name '*~' -exec rm {} \;
0000000000000000000000000000000000000000;;	  find ${RELEASE_STAGE} -name '#*#' -exec rm {} \;
0000000000000000000000000000000000000000;;	  find ${RELEASE_STAGE} -name '.DS*' -exec rm {} \;
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::release::package_tarballs() {
0000000000000000000000000000000000000000;;	  # Clean out any old releases
0000000000000000000000000000000000000000;;	  rm -rf "${RELEASE_STAGE}" "${RELEASE_TARS}" "${RELEASE_IMAGES}"
0000000000000000000000000000000000000000;;	  mkdir -p "${RELEASE_TARS}"
0000000000000000000000000000000000000000;;	  kube::release::package_src_tarball &
0000000000000000000000000000000000000000;;	  kube::release::package_client_tarballs &
0000000000000000000000000000000000000000;;	  kube::release::package_salt_tarball &
0000000000000000000000000000000000000000;;	  kube::release::package_kube_manifests_tarball &
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || { kube::log::error "previous tarball phase failed"; return 1; }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # _node and _server tarballs depend on _src tarball
0000000000000000000000000000000000000000;;	  kube::release::package_node_tarballs &
0000000000000000000000000000000000000000;;	  kube::release::package_server_tarballs &
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || { kube::log::error "previous tarball phase failed"; return 1; }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::release::package_final_tarball & # _final depends on some of the previous phases
0000000000000000000000000000000000000000;;	  kube::release::package_test_tarball & # _test doesn't depend on anything
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || { kube::log::error "previous tarball phase failed"; return 1; }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Package the source code we built, for compliance/licensing/audit/yadda.
0000000000000000000000000000000000000000;;	function kube::release::package_src_tarball() {
0000000000000000000000000000000000000000;;	  kube::log::status "Building tarball: src"
0000000000000000000000000000000000000000;;	  local source_files=(
0000000000000000000000000000000000000000;;	    $(cd "${KUBE_ROOT}" && find . -mindepth 1 -maxdepth 1 \
0000000000000000000000000000000000000000;;	      -not \( \
0000000000000000000000000000000000000000;;	        \( -path ./_\*        -o \
0000000000000000000000000000000000000000;;	           -path ./.git\*     -o \
0000000000000000000000000000000000000000;;	           -path ./.config\* -o \
0000000000000000000000000000000000000000;;	           -path ./.gsutil\*    \
0000000000000000000000000000000000000000;;	        \) -prune \
0000000000000000000000000000000000000000;;	      \))
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  "${TAR}" czf "${RELEASE_TARS}/kubernetes-src.tar.gz" -C "${KUBE_ROOT}" "${source_files[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Package up all of the cross compiled clients. Over time this should grow into
0000000000000000000000000000000000000000;;	# a full SDK
0000000000000000000000000000000000000000;;	function kube::release::package_client_tarballs() {
0000000000000000000000000000000000000000;;	   # Find all of the built client binaries
0000000000000000000000000000000000000000;;	  local platform platforms
0000000000000000000000000000000000000000;;	  platforms=($(cd "${LOCAL_OUTPUT_BINPATH}" ; echo */*))
0000000000000000000000000000000000000000;;	  for platform in "${platforms[@]}"; do
0000000000000000000000000000000000000000;;	    local platform_tag=${platform/\//-} # Replace a "/" for a "-"
0000000000000000000000000000000000000000;;	    kube::log::status "Starting tarball: client $platform_tag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    (
0000000000000000000000000000000000000000;;	      local release_stage="${RELEASE_STAGE}/client/${platform_tag}/kubernetes"
0000000000000000000000000000000000000000;;	      rm -rf "${release_stage}"
0000000000000000000000000000000000000000;;	      mkdir -p "${release_stage}/client/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      local client_bins=("${KUBE_CLIENT_BINARIES[@]}")
0000000000000000000000000000000000000000;;	      if [[ "${platform%/*}" == "windows" ]]; then
0000000000000000000000000000000000000000;;	        client_bins=("${KUBE_CLIENT_BINARIES_WIN[@]}")
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      # This fancy expression will expand to prepend a path
0000000000000000000000000000000000000000;;	      # (${LOCAL_OUTPUT_BINPATH}/${platform}/) to every item in the
0000000000000000000000000000000000000000;;	      # KUBE_CLIENT_BINARIES array.
0000000000000000000000000000000000000000;;	      cp "${client_bins[@]/#/${LOCAL_OUTPUT_BINPATH}/${platform}/}" \
0000000000000000000000000000000000000000;;	        "${release_stage}/client/bin/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      kube::release::clean_cruft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      local package_name="${RELEASE_TARS}/kubernetes-client-${platform_tag}.tar.gz"
0000000000000000000000000000000000000000;;	      kube::release::create_tarball "${package_name}" "${release_stage}/.."
0000000000000000000000000000000000000000;;	    ) &
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Waiting on tarballs"
0000000000000000000000000000000000000000;;	  kube::util::wait-for-jobs || { kube::log::error "client tarball creation failed"; exit 1; }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Package up all of the node binaries
0000000000000000000000000000000000000000;;	function kube::release::package_node_tarballs() {
0000000000000000000000000000000000000000;;	  local platform
0000000000000000000000000000000000000000;;	  for platform in "${KUBE_NODE_PLATFORMS[@]}"; do
0000000000000000000000000000000000000000;;	    local platform_tag=${platform/\//-} # Replace a "/" for a "-"
0000000000000000000000000000000000000000;;	    local arch=$(basename ${platform})
0000000000000000000000000000000000000000;;	    kube::log::status "Building tarball: node $platform_tag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local release_stage="${RELEASE_STAGE}/node/${platform_tag}/kubernetes"
0000000000000000000000000000000000000000;;	    rm -rf "${release_stage}"
0000000000000000000000000000000000000000;;	    mkdir -p "${release_stage}/node/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local node_bins=("${KUBE_NODE_BINARIES[@]}")
0000000000000000000000000000000000000000;;	    if [[ "${platform%/*}" == "windows" ]]; then
0000000000000000000000000000000000000000;;	      node_bins=("${KUBE_NODE_BINARIES_WIN[@]}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    # This fancy expression will expand to prepend a path
0000000000000000000000000000000000000000;;	    # (${LOCAL_OUTPUT_BINPATH}/${platform}/) to every item in the
0000000000000000000000000000000000000000;;	    # KUBE_NODE_BINARIES array.
0000000000000000000000000000000000000000;;	    cp "${node_bins[@]/#/${LOCAL_OUTPUT_BINPATH}/${platform}/}" \
0000000000000000000000000000000000000000;;	      "${release_stage}/node/bin/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # TODO: Docker images here
0000000000000000000000000000000000000000;;	    # kube::release::create_docker_images_for_server "${release_stage}/server/bin" "${arch}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Include the client binaries here too as they are useful debugging tools.
0000000000000000000000000000000000000000;;	    local client_bins=("${KUBE_CLIENT_BINARIES[@]}")
0000000000000000000000000000000000000000;;	    if [[ "${platform%/*}" == "windows" ]]; then
0000000000000000000000000000000000000000;;	      client_bins=("${KUBE_CLIENT_BINARIES_WIN[@]}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    cp "${client_bins[@]/#/${LOCAL_OUTPUT_BINPATH}/${platform}/}" \
0000000000000000000000000000000000000000;;	      "${release_stage}/node/bin/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    cp "${KUBE_ROOT}/Godeps/LICENSES" "${release_stage}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    cp "${RELEASE_TARS}/kubernetes-src.tar.gz" "${release_stage}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::release::clean_cruft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local package_name="${RELEASE_TARS}/kubernetes-node-${platform_tag}.tar.gz"
0000000000000000000000000000000000000000;;	    kube::release::create_tarball "${package_name}" "${release_stage}/.."
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Package up all of the server binaries
0000000000000000000000000000000000000000;;	function kube::release::package_server_tarballs() {
0000000000000000000000000000000000000000;;	  local platform
0000000000000000000000000000000000000000;;	  for platform in "${KUBE_SERVER_PLATFORMS[@]}"; do
0000000000000000000000000000000000000000;;	    local platform_tag=${platform/\//-} # Replace a "/" for a "-"
0000000000000000000000000000000000000000;;	    local arch=$(basename ${platform})
0000000000000000000000000000000000000000;;	    kube::log::status "Building tarball: server $platform_tag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local release_stage="${RELEASE_STAGE}/server/${platform_tag}/kubernetes"
0000000000000000000000000000000000000000;;	    rm -rf "${release_stage}"
0000000000000000000000000000000000000000;;	    mkdir -p "${release_stage}/server/bin"
0000000000000000000000000000000000000000;;	    mkdir -p "${release_stage}/addons"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # This fancy expression will expand to prepend a path
0000000000000000000000000000000000000000;;	    # (${LOCAL_OUTPUT_BINPATH}/${platform}/) to every item in the
0000000000000000000000000000000000000000;;	    # KUBE_SERVER_BINARIES array.
0000000000000000000000000000000000000000;;	    cp "${KUBE_SERVER_BINARIES[@]/#/${LOCAL_OUTPUT_BINPATH}/${platform}/}" \
0000000000000000000000000000000000000000;;	      "${release_stage}/server/bin/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::release::create_docker_images_for_server "${release_stage}/server/bin" "${arch}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Include the client binaries here too as they are useful debugging tools.
0000000000000000000000000000000000000000;;	    local client_bins=("${KUBE_CLIENT_BINARIES[@]}")
0000000000000000000000000000000000000000;;	    if [[ "${platform%/*}" == "windows" ]]; then
0000000000000000000000000000000000000000;;	      client_bins=("${KUBE_CLIENT_BINARIES_WIN[@]}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    cp "${client_bins[@]/#/${LOCAL_OUTPUT_BINPATH}/${platform}/}" \
0000000000000000000000000000000000000000;;	      "${release_stage}/server/bin/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    cp "${KUBE_ROOT}/Godeps/LICENSES" "${release_stage}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    cp "${RELEASE_TARS}/kubernetes-src.tar.gz" "${release_stage}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::release::clean_cruft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local package_name="${RELEASE_TARS}/kubernetes-server-${platform_tag}.tar.gz"
0000000000000000000000000000000000000000;;	    kube::release::create_tarball "${package_name}" "${release_stage}/.."
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::release::md5() {
0000000000000000000000000000000000000000;;	  if which md5 >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    md5 -q "$1"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    md5sum "$1" | awk '{ print $1 }'
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::release::sha1() {
0000000000000000000000000000000000000000;;	  if which sha1sum >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    sha1sum "$1" | awk '{ print $1 }'
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    shasum -a1 "$1" | awk '{ print $1 }'
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function kube::release::build_hyperkube_image() {
0000000000000000000000000000000000000000;;	  local -r arch="$1"
0000000000000000000000000000000000000000;;	  local -r registry="$2"
0000000000000000000000000000000000000000;;	  local -r version="$3"
0000000000000000000000000000000000000000;;	  local -r save_dir="${4-}"
0000000000000000000000000000000000000000;;	  kube::log::status "Building hyperkube image for arch: ${arch}"
0000000000000000000000000000000000000000;;	  ARCH="${arch}" REGISTRY="${registry}" VERSION="${version}" \
0000000000000000000000000000000000000000;;	    make -C cluster/images/hyperkube/ build >/dev/null
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local hyperkube_tag="${docker_registry}/hyperkube-${arch}:${docker_tag}"
0000000000000000000000000000000000000000;;	  if [[ -n "${save_dir}" ]]; then
0000000000000000000000000000000000000000;;	    "${DOCKER[@]}" save "${hyperkube_tag}" > "${save_dir}/hyperkube-${arch}.tar"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_DOCKER_IMAGE_TAG-}" || -z "${KUBE_DOCKER_REGISTRY-}" ]]; then
0000000000000000000000000000000000000000;;	    # not a release
0000000000000000000000000000000000000000;;	    kube::log::status "Deleting hyperkube image ${hyperkube_tag}"
0000000000000000000000000000000000000000;;	    "${DOCKER[@]}" rmi "${hyperkube_tag}" &>/dev/null || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This will take binaries that run on master and creates Docker images
0000000000000000000000000000000000000000;;	# that wrap the binary in them. (One docker image per binary)
0000000000000000000000000000000000000000;;	# Args:
0000000000000000000000000000000000000000;;	#  $1 - binary_dir, the directory to save the tared images to.
0000000000000000000000000000000000000000;;	#  $2 - arch, architecture for which we are building docker images.
0000000000000000000000000000000000000000;;	function kube::release::create_docker_images_for_server() {
0000000000000000000000000000000000000000;;	  # Create a sub-shell so that we don't pollute the outer environment
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    local binary_dir="$1"
0000000000000000000000000000000000000000;;	    local arch="$2"
0000000000000000000000000000000000000000;;	    local binary_name
0000000000000000000000000000000000000000;;	    local binaries=($(kube::build::get_docker_wrapped_binaries ${arch}))
0000000000000000000000000000000000000000;;	    local images_dir="${RELEASE_IMAGES}/${arch}"
0000000000000000000000000000000000000000;;	    mkdir -p "${images_dir}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local docker_registry="${KUBE_DOCKER_REGISTRY:-gcr.io/google_containers}"
0000000000000000000000000000000000000000;;	    # Docker tags cannot contain '+'
0000000000000000000000000000000000000000;;	    local docker_tag="${KUBE_GIT_VERSION/+/_}"
0000000000000000000000000000000000000000;;	    if [[ -z "${docker_tag}" ]]; then
0000000000000000000000000000000000000000;;	      kube::log::error "git version information missing; cannot create Docker tag"
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    for wrappable in "${binaries[@]}"; do
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      local oldifs=$IFS
0000000000000000000000000000000000000000;;	      IFS=","
0000000000000000000000000000000000000000;;	      set $wrappable
0000000000000000000000000000000000000000;;	      IFS=$oldifs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      local binary_name="$1"
0000000000000000000000000000000000000000;;	      local base_image="$2"
0000000000000000000000000000000000000000;;	      local docker_build_path="${binary_dir}/${binary_name}.dockerbuild"
0000000000000000000000000000000000000000;;	      local docker_file_path="${docker_build_path}/Dockerfile"
0000000000000000000000000000000000000000;;	      local binary_file_path="${binary_dir}/${binary_name}"
0000000000000000000000000000000000000000;;	      local docker_image_tag="${docker_registry}"
0000000000000000000000000000000000000000;;	      if [[ ${arch} == "amd64" ]]; then
0000000000000000000000000000000000000000;;	        # If we are building a amd64 docker image, preserve the original
0000000000000000000000000000000000000000;;	        # image name
0000000000000000000000000000000000000000;;	        docker_image_tag+="/${binary_name}:${docker_tag}"
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        # If we are building a docker image for another architecture,
0000000000000000000000000000000000000000;;	        # append the arch in the image tag
0000000000000000000000000000000000000000;;	        docker_image_tag+="/${binary_name}-${arch}:${docker_tag}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      kube::log::status "Starting docker build for image: ${binary_name}-${arch}"
0000000000000000000000000000000000000000;;	      (
0000000000000000000000000000000000000000;;	        rm -rf ${docker_build_path}
0000000000000000000000000000000000000000;;	        mkdir -p ${docker_build_path}
0000000000000000000000000000000000000000;;	        ln ${binary_dir}/${binary_name} ${docker_build_path}/${binary_name}
0000000000000000000000000000000000000000;;	        printf " FROM ${base_image} \n ADD ${binary_name} /usr/local/bin/${binary_name}\n" > ${docker_file_path}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        "${DOCKER[@]}" build --pull -q -t "${docker_image_tag}" ${docker_build_path} >/dev/null
0000000000000000000000000000000000000000;;	        "${DOCKER[@]}" save "${docker_image_tag}" > "${binary_dir}/${binary_name}.tar"
0000000000000000000000000000000000000000;;	        echo "${docker_tag}" > ${binary_dir}/${binary_name}.docker_tag
0000000000000000000000000000000000000000;;	        rm -rf ${docker_build_path}
0000000000000000000000000000000000000000;;	        ln "${binary_dir}/${binary_name}.tar" "${images_dir}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        # If we are building an official/alpha/beta release we want to keep
0000000000000000000000000000000000000000;;	        # docker images and tag them appropriately.
0000000000000000000000000000000000000000;;	        if [[ -n "${KUBE_DOCKER_IMAGE_TAG-}" && -n "${KUBE_DOCKER_REGISTRY-}" ]]; then
0000000000000000000000000000000000000000;;	          local release_docker_image_tag="${KUBE_DOCKER_REGISTRY}/${binary_name}-${arch}:${KUBE_DOCKER_IMAGE_TAG}"
0000000000000000000000000000000000000000;;	          # Only rmi and tag if name is different
0000000000000000000000000000000000000000;;	          if [[ $docker_image_tag != $release_docker_image_tag ]]; then
0000000000000000000000000000000000000000;;	            kube::log::status "Tagging docker image ${docker_image_tag} as ${release_docker_image_tag}"
0000000000000000000000000000000000000000;;	            "${DOCKER[@]}" rmi "${release_docker_image_tag}" 2>/dev/null || true
0000000000000000000000000000000000000000;;	            "${DOCKER[@]}" tag "${docker_image_tag}" "${release_docker_image_tag}" 2>/dev/null
0000000000000000000000000000000000000000;;	          fi
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	          # not a release
0000000000000000000000000000000000000000;;	          kube::log::status "Deleting docker image ${docker_image_tag}"
0000000000000000000000000000000000000000;;	          "${DOCKER[@]}" rmi ${docker_image_tag} &>/dev/null || true
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	      ) &
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ "${KUBE_BUILD_HYPERKUBE}" =~ [yY] ]]; then
0000000000000000000000000000000000000000;;	      kube::release::build_hyperkube_image "${arch}" "${docker_registry}" \
0000000000000000000000000000000000000000;;	        "${docker_tag}" "${images_dir}" &
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::util::wait-for-jobs || { kube::log::error "previous Docker build failed"; return 1; }
0000000000000000000000000000000000000000;;	    kube::log::status "Docker builds done"
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Package up the salt configuration tree.  This is an optional helper to getting
0000000000000000000000000000000000000000;;	# a cluster up and running.
0000000000000000000000000000000000000000;;	function kube::release::package_salt_tarball() {
0000000000000000000000000000000000000000;;	  kube::log::status "Building tarball: salt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local release_stage="${RELEASE_STAGE}/salt/kubernetes"
0000000000000000000000000000000000000000;;	  rm -rf "${release_stage}"
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/cluster/saltbase" "${release_stage}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO(#3579): This is a temporary hack. It gathers up the yaml,
0000000000000000000000000000000000000000;;	  # yaml.in, json files in cluster/addons (minus any demos) and overlays
0000000000000000000000000000000000000000;;	  # them into kube-addons, where we expect them. (This pipeline is a
0000000000000000000000000000000000000000;;	  # fancy copy, stripping anything but the files we don't want.)
0000000000000000000000000000000000000000;;	  local objects
0000000000000000000000000000000000000000;;	  objects=$(cd "${KUBE_ROOT}/cluster/addons" && find . \( -name \*.yaml -or -name \*.yaml.in -or -name \*.json \) | grep -v demo)
0000000000000000000000000000000000000000;;	  tar c -C "${KUBE_ROOT}/cluster/addons" ${objects} | tar x -C "${release_stage}/saltbase/salt/kube-addons"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::release::clean_cruft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local package_name="${RELEASE_TARS}/kubernetes-salt.tar.gz"
0000000000000000000000000000000000000000;;	  kube::release::create_tarball "${package_name}" "${release_stage}/.."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This will pack kube-system manifests files for distros without using salt
0000000000000000000000000000000000000000;;	# such as GCI and Ubuntu Trusty. We directly copy manifests from
0000000000000000000000000000000000000000;;	# cluster/addons and cluster/saltbase/salt. The script of cluster initialization
0000000000000000000000000000000000000000;;	# will remove the salt configuration and evaluate the variables in the manifests.
0000000000000000000000000000000000000000;;	function kube::release::package_kube_manifests_tarball() {
0000000000000000000000000000000000000000;;	  kube::log::status "Building tarball: manifests"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local salt_dir="${KUBE_ROOT}/cluster/saltbase/salt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local release_stage="${RELEASE_STAGE}/manifests/kubernetes"
0000000000000000000000000000000000000000;;	  rm -rf "${release_stage}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/kube-registry-proxy/kube-registry-proxy.yaml" "${release_stage}/"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/kube-proxy/kube-proxy.manifest" "${release_stage}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local gci_dst_dir="${release_stage}/gci-trusty"
0000000000000000000000000000000000000000;;	  mkdir -p "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/cluster-autoscaler/cluster-autoscaler.manifest" "${gci_dst_dir}/"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/etcd/etcd.manifest" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/kube-scheduler/kube-scheduler.manifest" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/kube-apiserver/kube-apiserver.manifest" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/kube-apiserver/abac-authz-policy.jsonl" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/kube-controller-manager/kube-controller-manager.manifest" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/kube-addons/kube-addon-manager.yaml" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/l7-gcp/glbc.manifest" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/rescheduler/rescheduler.manifest" "${gci_dst_dir}/"
0000000000000000000000000000000000000000;;	  cp "${salt_dir}/e2e-image-puller/e2e-image-puller.manifest" "${gci_dst_dir}/"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/cluster/gce/gci/configure-helper.sh" "${gci_dst_dir}/gci-configure-helper.sh"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/cluster/gce/gci/mounter/mounter" "${gci_dst_dir}/gci-mounter"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/cluster/gce/gci/health-monitor.sh" "${gci_dst_dir}/health-monitor.sh"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/cluster/gce/container-linux/configure-helper.sh" "${gci_dst_dir}/container-linux-configure-helper.sh"
0000000000000000000000000000000000000000;;	  cp -r "${salt_dir}/kube-admission-controls/limit-range" "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	  local objects
0000000000000000000000000000000000000000;;	  objects=$(cd "${KUBE_ROOT}/cluster/addons" && find . \( -name \*.yaml -or -name \*.yaml.in -or -name \*.json \) | grep -v demo)
0000000000000000000000000000000000000000;;	  tar c -C "${KUBE_ROOT}/cluster/addons" ${objects} | tar x -C "${gci_dst_dir}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::release::clean_cruft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local package_name="${RELEASE_TARS}/kubernetes-manifests.tar.gz"
0000000000000000000000000000000000000000;;	  kube::release::create_tarball "${package_name}" "${release_stage}/.."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is the stuff you need to run tests from the binary distribution.
0000000000000000000000000000000000000000;;	function kube::release::package_test_tarball() {
0000000000000000000000000000000000000000;;	  kube::log::status "Building tarball: test"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local release_stage="${RELEASE_STAGE}/test/kubernetes"
0000000000000000000000000000000000000000;;	  rm -rf "${release_stage}"
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local platform
0000000000000000000000000000000000000000;;	  for platform in "${KUBE_TEST_PLATFORMS[@]}"; do
0000000000000000000000000000000000000000;;	    local test_bins=("${KUBE_TEST_BINARIES[@]}")
0000000000000000000000000000000000000000;;	    if [[ "${platform%/*}" == "windows" ]]; then
0000000000000000000000000000000000000000;;	      test_bins=("${KUBE_TEST_BINARIES_WIN[@]}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    mkdir -p "${release_stage}/platforms/${platform}"
0000000000000000000000000000000000000000;;	    cp "${test_bins[@]/#/${LOCAL_OUTPUT_BINPATH}/${platform}/}" \
0000000000000000000000000000000000000000;;	      "${release_stage}/platforms/${platform}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  for platform in "${KUBE_TEST_SERVER_PLATFORMS[@]}"; do
0000000000000000000000000000000000000000;;	    mkdir -p "${release_stage}/platforms/${platform}"
0000000000000000000000000000000000000000;;	    cp "${KUBE_TEST_SERVER_BINARIES[@]/#/${LOCAL_OUTPUT_BINPATH}/${platform}/}" \
0000000000000000000000000000000000000000;;	      "${release_stage}/platforms/${platform}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Add the test image files
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}/test/images"
0000000000000000000000000000000000000000;;	  cp -fR "${KUBE_ROOT}/test/images" "${release_stage}/test/"
0000000000000000000000000000000000000000;;	  tar c ${KUBE_TEST_PORTABLE[@]} | tar x -C ${release_stage}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::release::clean_cruft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local package_name="${RELEASE_TARS}/kubernetes-test.tar.gz"
0000000000000000000000000000000000000000;;	  kube::release::create_tarball "${package_name}" "${release_stage}/.."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is all the platform-independent stuff you need to run/install kubernetes.
0000000000000000000000000000000000000000;;	# Arch-specific binaries will need to be downloaded separately (possibly by
0000000000000000000000000000000000000000;;	# using the bundled cluster/get-kube-binaries.sh script).
0000000000000000000000000000000000000000;;	# Included in this tarball:
0000000000000000000000000000000000000000;;	#   - Cluster spin up/down scripts and configs for various cloud providers
0000000000000000000000000000000000000000;;	#   - Tarballs for salt configs that are ready to be uploaded
0000000000000000000000000000000000000000;;	#     to master by whatever means appropriate.
0000000000000000000000000000000000000000;;	#   - Examples (which may or may not still work)
0000000000000000000000000000000000000000;;	#   - The remnants of the docs/ directory
0000000000000000000000000000000000000000;;	function kube::release::package_final_tarball() {
0000000000000000000000000000000000000000;;	  kube::log::status "Building tarball: final"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # This isn't a "full" tarball anymore, but the release lib still expects
0000000000000000000000000000000000000000;;	  # artifacts under "full/kubernetes/"
0000000000000000000000000000000000000000;;	  local release_stage="${RELEASE_STAGE}/full/kubernetes"
0000000000000000000000000000000000000000;;	  rm -rf "${release_stage}"
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}/client"
0000000000000000000000000000000000000000;;	  cat <<EOF > "${release_stage}/client/README"
0000000000000000000000000000000000000000;;	Client binaries are no longer included in the Kubernetes final tarball.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Run cluster/get-kube-binaries.sh to download client and server binaries.
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # We want everything in /cluster except saltbase.  That is only needed on the
0000000000000000000000000000000000000000;;	  # server.
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/cluster" "${release_stage}/"
0000000000000000000000000000000000000000;;	  rm -rf "${release_stage}/cluster/saltbase"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}/server"
0000000000000000000000000000000000000000;;	  cp "${RELEASE_TARS}/kubernetes-salt.tar.gz" "${release_stage}/server/"
0000000000000000000000000000000000000000;;	  cp "${RELEASE_TARS}/kubernetes-manifests.tar.gz" "${release_stage}/server/"
0000000000000000000000000000000000000000;;	  cat <<EOF > "${release_stage}/server/README"
0000000000000000000000000000000000000000;;	Server binary tarballs are no longer included in the Kubernetes final tarball.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Run cluster/get-kube-binaries.sh to download client and server binaries.
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}/third_party"
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/third_party/htpasswd" "${release_stage}/third_party/htpasswd"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Include only federation/cluster, federation/manifests and federation/deploy
0000000000000000000000000000000000000000;;	  mkdir "${release_stage}/federation"
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/federation/cluster" "${release_stage}/federation/"
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/federation/manifests" "${release_stage}/federation/"
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/federation/deploy" "${release_stage}/federation/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Include hack/lib as a dependency for the cluster/ scripts
0000000000000000000000000000000000000000;;	  mkdir -p "${release_stage}/hack"
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/hack/lib" "${release_stage}/hack/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/examples" "${release_stage}/"
0000000000000000000000000000000000000000;;	  cp -R "${KUBE_ROOT}/docs" "${release_stage}/"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/README.md" "${release_stage}/"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/Godeps/LICENSES" "${release_stage}/"
0000000000000000000000000000000000000000;;	  cp "${KUBE_ROOT}/Vagrantfile" "${release_stage}/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "${KUBE_GIT_VERSION}" > "${release_stage}/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::release::clean_cruft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local package_name="${RELEASE_TARS}/kubernetes.tar.gz"
0000000000000000000000000000000000000000;;	  kube::release::create_tarball "${package_name}" "${release_stage}/.."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Build a release tarball.  $1 is the output tar name.  $2 is the base directory
0000000000000000000000000000000000000000;;	# of the files to be packaged.  This assumes that ${2}/kubernetes is what is
0000000000000000000000000000000000000000;;	# being packaged.
0000000000000000000000000000000000000000;;	function kube::release::create_tarball() {
0000000000000000000000000000000000000000;;	  kube::build::ensure_tar
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local tarfile=$1
0000000000000000000000000000000000000000;;	  local stagingdir=$2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  "${TAR}" czf "${tarfile}" -C "${stagingdir}" kubernetes --owner=0 --group=0
0000000000000000000000000000000000000000;;	}
