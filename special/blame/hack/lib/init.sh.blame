0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The root of the build/dist directory
0000000000000000000000000000000000000000;;	KUBE_ROOT="$(cd "$(dirname "${BASH_SOURCE}")/../.." && pwd -P)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_OUTPUT_SUBPATH="${KUBE_OUTPUT_SUBPATH:-_output/local}"
0000000000000000000000000000000000000000;;	KUBE_OUTPUT="${KUBE_ROOT}/${KUBE_OUTPUT_SUBPATH}"
0000000000000000000000000000000000000000;;	KUBE_OUTPUT_BINPATH="${KUBE_OUTPUT}/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This controls rsync compression. Set to a value > 0 to enable rsync
0000000000000000000000000000000000000000;;	# compression for build container
0000000000000000000000000000000000000000;;	KUBE_RSYNC_COMPRESS="${KUBE_RSYNC_COMPRESS:-0}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Set no_proxy for localhost if behind a proxy, otherwise,
0000000000000000000000000000000000000000;;	# the connections to localhost in scripts will time out
0000000000000000000000000000000000000000;;	export no_proxy=127.0.0.1,localhost
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is a symlink to binaries for "this platform", e.g. build tools.
0000000000000000000000000000000000000000;;	THIS_PLATFORM_BIN="${KUBE_ROOT}/_output/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/util.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/cluster/lib/logging.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::log::install_errexit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/version.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/golang.sh"
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/etcd.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_OUTPUT_HOSTBIN="${KUBE_OUTPUT_BINPATH}/$(kube::util::host_platform)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# list of all available group versions.  This should be used when generated code
0000000000000000000000000000000000000000;;	# or when starting an API server that you want to have everything.
0000000000000000000000000000000000000000;;	# most preferred version for a group should appear first
0000000000000000000000000000000000000000;;	KUBE_AVAILABLE_GROUP_VERSIONS="${KUBE_AVAILABLE_GROUP_VERSIONS:-\
0000000000000000000000000000000000000000;;	v1 \
0000000000000000000000000000000000000000;;	admissionregistration.k8s.io/v1alpha1 \
0000000000000000000000000000000000000000;;	admission.k8s.io/v1alpha1 \
0000000000000000000000000000000000000000;;	apps/v1beta1 \
0000000000000000000000000000000000000000;;	authentication.k8s.io/v1 \
0000000000000000000000000000000000000000;;	authentication.k8s.io/v1beta1 \
0000000000000000000000000000000000000000;;	authorization.k8s.io/v1 \
0000000000000000000000000000000000000000;;	authorization.k8s.io/v1beta1 \
0000000000000000000000000000000000000000;;	autoscaling/v1 \
0000000000000000000000000000000000000000;;	autoscaling/v2alpha1 \
0000000000000000000000000000000000000000;;	batch/v1 \
0000000000000000000000000000000000000000;;	batch/v2alpha1 \
0000000000000000000000000000000000000000;;	certificates.k8s.io/v1beta1 \
0000000000000000000000000000000000000000;;	extensions/v1beta1 \
0000000000000000000000000000000000000000;;	imagepolicy.k8s.io/v1alpha1 \
0000000000000000000000000000000000000000;;	networking.k8s.io/v1 \
0000000000000000000000000000000000000000;;	policy/v1beta1 \
0000000000000000000000000000000000000000;;	rbac.authorization.k8s.io/v1beta1 \
0000000000000000000000000000000000000000;;	rbac.authorization.k8s.io/v1alpha1 \
0000000000000000000000000000000000000000;;	settings.k8s.io/v1alpha1 \
0000000000000000000000000000000000000000;;	storage.k8s.io/v1beta1 \
0000000000000000000000000000000000000000;;	storage.k8s.io/v1\
0000000000000000000000000000000000000000;;	}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# not all group versions are exposed by the server.  This list contains those
0000000000000000000000000000000000000000;;	# which are not available so we don't generate clients or swagger for them
0000000000000000000000000000000000000000;;	KUBE_NONSERVER_GROUP_VERSIONS="
0000000000000000000000000000000000000000;;	 abac.authorization.kubernetes.io/v0 \
0000000000000000000000000000000000000000;;	 abac.authorization.kubernetes.io/v1beta1 \
0000000000000000000000000000000000000000;;	 componentconfig/v1alpha1 \
0000000000000000000000000000000000000000;;	 imagepolicy.k8s.io/v1alpha1\
0000000000000000000000000000000000000000;;	 admission.k8s.io/v1alpha1\
0000000000000000000000000000000000000000;;	"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This emulates "readlink -f" which is not available on MacOS X.
0000000000000000000000000000000000000000;;	# Test:
0000000000000000000000000000000000000000;;	# T=/tmp/$$.$RANDOM
0000000000000000000000000000000000000000;;	# mkdir $T
0000000000000000000000000000000000000000;;	# touch $T/file
0000000000000000000000000000000000000000;;	# mkdir $T/dir
0000000000000000000000000000000000000000;;	# ln -s $T/file $T/linkfile
0000000000000000000000000000000000000000;;	# ln -s $T/dir $T/linkdir
0000000000000000000000000000000000000000;;	# function testone() {
0000000000000000000000000000000000000000;;	#   X=$(readlink -f $1 2>&1)
0000000000000000000000000000000000000000;;	#   Y=$(kube::readlinkdashf $1 2>&1)
0000000000000000000000000000000000000000;;	#   if [ "$X" != "$Y" ]; then
0000000000000000000000000000000000000000;;	#     echo readlinkdashf $1: expected "$X", got "$Y"
0000000000000000000000000000000000000000;;	#   fi
0000000000000000000000000000000000000000;;	# }
0000000000000000000000000000000000000000;;	# testone /
0000000000000000000000000000000000000000;;	# testone /tmp
0000000000000000000000000000000000000000;;	# testone $T
0000000000000000000000000000000000000000;;	# testone $T/file
0000000000000000000000000000000000000000;;	# testone $T/dir
0000000000000000000000000000000000000000;;	# testone $T/linkfile
0000000000000000000000000000000000000000;;	# testone $T/linkdir
0000000000000000000000000000000000000000;;	# testone $T/nonexistant
0000000000000000000000000000000000000000;;	# testone $T/linkdir/file
0000000000000000000000000000000000000000;;	# testone $T/linkdir/dir
0000000000000000000000000000000000000000;;	# testone $T/linkdir/linkfile
0000000000000000000000000000000000000000;;	# testone $T/linkdir/linkdir
0000000000000000000000000000000000000000;;	function kube::readlinkdashf {
0000000000000000000000000000000000000000;;	  # run in a subshell for simpler 'cd'
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    if [[ -d "$1" ]]; then # This also catch symlinks to dirs.
0000000000000000000000000000000000000000;;	      cd "$1"
0000000000000000000000000000000000000000;;	      pwd -P
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      cd $(dirname "$1")
0000000000000000000000000000000000000000;;	      local f
0000000000000000000000000000000000000000;;	      f=$(basename "$1")
0000000000000000000000000000000000000000;;	      if [[ -L "$f" ]]; then
0000000000000000000000000000000000000000;;	        readlink "$f"
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        echo "$(pwd -P)/${f}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This emulates "realpath" which is not available on MacOS X
0000000000000000000000000000000000000000;;	# Test:
0000000000000000000000000000000000000000;;	# T=/tmp/$$.$RANDOM
0000000000000000000000000000000000000000;;	# mkdir $T
0000000000000000000000000000000000000000;;	# touch $T/file
0000000000000000000000000000000000000000;;	# mkdir $T/dir
0000000000000000000000000000000000000000;;	# ln -s $T/file $T/linkfile
0000000000000000000000000000000000000000;;	# ln -s $T/dir $T/linkdir
0000000000000000000000000000000000000000;;	# function testone() {
0000000000000000000000000000000000000000;;	#   X=$(realpath $1 2>&1)
0000000000000000000000000000000000000000;;	#   Y=$(kube::realpath $1 2>&1)
0000000000000000000000000000000000000000;;	#   if [ "$X" != "$Y" ]; then
0000000000000000000000000000000000000000;;	#     echo realpath $1: expected "$X", got "$Y"
0000000000000000000000000000000000000000;;	#   fi
0000000000000000000000000000000000000000;;	# }
0000000000000000000000000000000000000000;;	# testone /
0000000000000000000000000000000000000000;;	# testone /tmp
0000000000000000000000000000000000000000;;	# testone $T
0000000000000000000000000000000000000000;;	# testone $T/file
0000000000000000000000000000000000000000;;	# testone $T/dir
0000000000000000000000000000000000000000;;	# testone $T/linkfile
0000000000000000000000000000000000000000;;	# testone $T/linkdir
0000000000000000000000000000000000000000;;	# testone $T/nonexistant
0000000000000000000000000000000000000000;;	# testone $T/linkdir/file
0000000000000000000000000000000000000000;;	# testone $T/linkdir/dir
0000000000000000000000000000000000000000;;	# testone $T/linkdir/linkfile
0000000000000000000000000000000000000000;;	# testone $T/linkdir/linkdir
0000000000000000000000000000000000000000;;	kube::realpath() {
0000000000000000000000000000000000000000;;	  if [[ ! -e "$1" ]]; then
0000000000000000000000000000000000000000;;	    echo "$1: No such file or directory" >&2
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  kube::readlinkdashf "$1"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
