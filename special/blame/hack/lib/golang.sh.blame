0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The golang package that we are building.
0000000000000000000000000000000000000000;;	readonly KUBE_GO_PACKAGE=k8s.io/kubernetes
0000000000000000000000000000000000000000;;	readonly KUBE_GOPATH="${KUBE_OUTPUT}/go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The set of server targets that we are only building for Linux
0000000000000000000000000000000000000000;;	# If you update this list, please also update build/BUILD.
0000000000000000000000000000000000000000;;	kube::golang::server_targets() {
0000000000000000000000000000000000000000;;	  local targets=(
0000000000000000000000000000000000000000;;	    cmd/kube-proxy
0000000000000000000000000000000000000000;;	    cmd/kube-apiserver
0000000000000000000000000000000000000000;;	    cmd/kube-controller-manager
0000000000000000000000000000000000000000;;	    cmd/cloud-controller-manager
0000000000000000000000000000000000000000;;	    cmd/kubelet
0000000000000000000000000000000000000000;;	    cmd/kubeadm
0000000000000000000000000000000000000000;;	    cmd/hyperkube
0000000000000000000000000000000000000000;;	    vendor/k8s.io/kube-aggregator
0000000000000000000000000000000000000000;;	    vendor/k8s.io/apiextensions-apiserver
0000000000000000000000000000000000000000;;	    plugin/cmd/kube-scheduler
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  echo "${targets[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly KUBE_SERVER_TARGETS=($(kube::golang::server_targets))
0000000000000000000000000000000000000000;;	readonly KUBE_SERVER_BINARIES=("${KUBE_SERVER_TARGETS[@]##*/}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The set of server targets that we are only building for Kubernetes nodes
0000000000000000000000000000000000000000;;	# If you update this list, please also update build/BUILD.
0000000000000000000000000000000000000000;;	kube::golang::node_targets() {
0000000000000000000000000000000000000000;;	  local targets=(
0000000000000000000000000000000000000000;;	    cmd/kube-proxy
0000000000000000000000000000000000000000;;	    cmd/kubelet
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  echo "${targets[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly KUBE_NODE_TARGETS=($(kube::golang::node_targets))
0000000000000000000000000000000000000000;;	readonly KUBE_NODE_BINARIES=("${KUBE_NODE_TARGETS[@]##*/}")
0000000000000000000000000000000000000000;;	readonly KUBE_NODE_BINARIES_WIN=("${KUBE_NODE_BINARIES[@]/%/.exe}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${KUBE_FASTBUILD:-}" == "true" ]]; then
0000000000000000000000000000000000000000;;	  readonly KUBE_SERVER_PLATFORMS=(linux/amd64)
0000000000000000000000000000000000000000;;	  readonly KUBE_NODE_PLATFORMS=(linux/amd64)
0000000000000000000000000000000000000000;;	  if [[ "${KUBE_BUILDER_OS:-}" == "darwin"* ]]; then
0000000000000000000000000000000000000000;;	    readonly KUBE_TEST_PLATFORMS=(
0000000000000000000000000000000000000000;;	      darwin/amd64
0000000000000000000000000000000000000000;;	      linux/amd64
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	    readonly KUBE_CLIENT_PLATFORMS=(
0000000000000000000000000000000000000000;;	      darwin/amd64
0000000000000000000000000000000000000000;;	      linux/amd64
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    readonly KUBE_TEST_PLATFORMS=(linux/amd64)
0000000000000000000000000000000000000000;;	    readonly KUBE_CLIENT_PLATFORMS=(linux/amd64)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # The server platform we are building on.
0000000000000000000000000000000000000000;;	  readonly KUBE_SERVER_PLATFORMS=(
0000000000000000000000000000000000000000;;	    linux/amd64
0000000000000000000000000000000000000000;;	    linux/arm
0000000000000000000000000000000000000000;;	    linux/arm64
0000000000000000000000000000000000000000;;	    linux/s390x
0000000000000000000000000000000000000000;;	    linux/ppc64le
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # The node platforms we build for
0000000000000000000000000000000000000000;;	  readonly KUBE_NODE_PLATFORMS=(
0000000000000000000000000000000000000000;;	    linux/amd64
0000000000000000000000000000000000000000;;	    linux/arm
0000000000000000000000000000000000000000;;	    linux/arm64
0000000000000000000000000000000000000000;;	    linux/s390x
0000000000000000000000000000000000000000;;	    linux/ppc64le
0000000000000000000000000000000000000000;;	    windows/amd64
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If we update this we should also update the set of platforms whose standard library is precompiled for in build/build-image/cross/Dockerfile
0000000000000000000000000000000000000000;;	  readonly KUBE_CLIENT_PLATFORMS=(
0000000000000000000000000000000000000000;;	    linux/amd64
0000000000000000000000000000000000000000;;	    linux/386
0000000000000000000000000000000000000000;;	    linux/arm
0000000000000000000000000000000000000000;;	    linux/arm64
0000000000000000000000000000000000000000;;	    linux/s390x
0000000000000000000000000000000000000000;;	    linux/ppc64le
0000000000000000000000000000000000000000;;	    darwin/amd64
0000000000000000000000000000000000000000;;	    darwin/386
0000000000000000000000000000000000000000;;	    windows/amd64
0000000000000000000000000000000000000000;;	    windows/386
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Which platforms we should compile test targets for. Not all client platforms need these tests
0000000000000000000000000000000000000000;;	  readonly KUBE_TEST_PLATFORMS=(
0000000000000000000000000000000000000000;;	    linux/amd64
0000000000000000000000000000000000000000;;	    darwin/amd64
0000000000000000000000000000000000000000;;	    windows/amd64
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The set of client targets that we are building for all platforms
0000000000000000000000000000000000000000;;	# If you update this list, please also update build/BUILD.
0000000000000000000000000000000000000000;;	readonly KUBE_CLIENT_TARGETS=(
0000000000000000000000000000000000000000;;	  cmd/kubectl
0000000000000000000000000000000000000000;;	  federation/cmd/kubefed
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	readonly KUBE_CLIENT_BINARIES=("${KUBE_CLIENT_TARGETS[@]##*/}")
0000000000000000000000000000000000000000;;	readonly KUBE_CLIENT_BINARIES_WIN=("${KUBE_CLIENT_BINARIES[@]/%/.exe}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The set of test targets that we are building for all platforms
0000000000000000000000000000000000000000;;	# If you update this list, please also update build/BUILD.
0000000000000000000000000000000000000000;;	kube::golang::test_targets() {
0000000000000000000000000000000000000000;;	  local targets=(
0000000000000000000000000000000000000000;;	    cmd/gendocs
0000000000000000000000000000000000000000;;	    cmd/genkubedocs
0000000000000000000000000000000000000000;;	    cmd/genman
0000000000000000000000000000000000000000;;	    cmd/genyaml
0000000000000000000000000000000000000000;;	    cmd/mungedocs
0000000000000000000000000000000000000000;;	    cmd/genswaggertypedocs
0000000000000000000000000000000000000000;;	    cmd/linkcheck
0000000000000000000000000000000000000000;;	    federation/cmd/genfeddocs
0000000000000000000000000000000000000000;;	    vendor/github.com/onsi/ginkgo/ginkgo
0000000000000000000000000000000000000000;;	    test/e2e/e2e.test
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	  echo "${targets[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	readonly KUBE_TEST_TARGETS=($(kube::golang::test_targets))
0000000000000000000000000000000000000000;;	readonly KUBE_TEST_BINARIES=("${KUBE_TEST_TARGETS[@]##*/}")
0000000000000000000000000000000000000000;;	readonly KUBE_TEST_BINARIES_WIN=("${KUBE_TEST_BINARIES[@]/%/.exe}")
0000000000000000000000000000000000000000;;	# If you update this list, please also update build/BUILD.
0000000000000000000000000000000000000000;;	readonly KUBE_TEST_PORTABLE=(
0000000000000000000000000000000000000000;;	  test/e2e/testing-manifests
0000000000000000000000000000000000000000;;	  test/kubemark
0000000000000000000000000000000000000000;;	  federation/develop
0000000000000000000000000000000000000000;;	  hack/e2e.go
0000000000000000000000000000000000000000;;	  hack/e2e-internal
0000000000000000000000000000000000000000;;	  hack/get-build.sh
0000000000000000000000000000000000000000;;	  hack/ginkgo-e2e.sh
0000000000000000000000000000000000000000;;	  hack/federated-ginkgo-e2e.sh
0000000000000000000000000000000000000000;;	  hack/lib
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Test targets which run on the Kubernetes clusters directly, so we only
0000000000000000000000000000000000000000;;	# need to target server platforms.
0000000000000000000000000000000000000000;;	# These binaries will be distributed in the kubernetes-test tarball.
0000000000000000000000000000000000000000;;	# If you update this list, please also update build/BUILD.
0000000000000000000000000000000000000000;;	kube::golang::server_test_targets() {
0000000000000000000000000000000000000000;;	  local targets=(
0000000000000000000000000000000000000000;;	    cmd/kubemark
0000000000000000000000000000000000000000;;	    vendor/github.com/onsi/ginkgo/ginkgo
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${OSTYPE:-}" == "linux"* ]]; then
0000000000000000000000000000000000000000;;	    targets+=( test/e2e_node/e2e_node.test )
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "${targets[@]}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly KUBE_TEST_SERVER_TARGETS=($(kube::golang::server_test_targets))
0000000000000000000000000000000000000000;;	readonly KUBE_TEST_SERVER_BINARIES=("${KUBE_TEST_SERVER_TARGETS[@]##*/}")
0000000000000000000000000000000000000000;;	readonly KUBE_TEST_SERVER_PLATFORMS=("${KUBE_SERVER_PLATFORMS[@]}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Gigabytes desired for parallel platform builds. 11 is fairly
0000000000000000000000000000000000000000;;	# arbitrary, but is a reasonable splitting point for 2015
0000000000000000000000000000000000000000;;	# laptops-versus-not.
0000000000000000000000000000000000000000;;	readonly KUBE_PARALLEL_BUILD_MEMORY=11
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TODO(pipejakob) gke-certificates-controller is included here to exercise its
0000000000000000000000000000000000000000;;	# compilation, but it doesn't need to be distributed in any of our tars. Its
0000000000000000000000000000000000000000;;	# code is only living in this repo temporarily until it finds a new home.
0000000000000000000000000000000000000000;;	readonly KUBE_ALL_TARGETS=(
0000000000000000000000000000000000000000;;	  "${KUBE_SERVER_TARGETS[@]}"
0000000000000000000000000000000000000000;;	  "${KUBE_CLIENT_TARGETS[@]}"
0000000000000000000000000000000000000000;;	  "${KUBE_TEST_TARGETS[@]}"
0000000000000000000000000000000000000000;;	  "${KUBE_TEST_SERVER_TARGETS[@]}"
0000000000000000000000000000000000000000;;	  cmd/gke-certificates-controller
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	readonly KUBE_ALL_BINARIES=("${KUBE_ALL_TARGETS[@]##*/}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly KUBE_STATIC_LIBRARIES=(
0000000000000000000000000000000000000000;;	  cloud-controller-manager
0000000000000000000000000000000000000000;;	  kube-apiserver
0000000000000000000000000000000000000000;;	  kube-controller-manager
0000000000000000000000000000000000000000;;	  kube-scheduler
0000000000000000000000000000000000000000;;	  kube-proxy
0000000000000000000000000000000000000000;;	  kube-aggregator
0000000000000000000000000000000000000000;;	  kubeadm
0000000000000000000000000000000000000000;;	  kubectl
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Add any files with those //generate annotations in the array below.
0000000000000000000000000000000000000000;;	readonly KUBE_BINDATAS=(
0000000000000000000000000000000000000000;;	  test/e2e/generated/gobindata_util.go
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::golang::is_statically_linked_library() {
0000000000000000000000000000000000000000;;	  local e
0000000000000000000000000000000000000000;;	  for e in "${KUBE_STATIC_LIBRARIES[@]}"; do [[ "$1" == *"/$e" ]] && return 0; done;
0000000000000000000000000000000000000000;;	  # Allow individual overrides--e.g., so that you can get a static build of
0000000000000000000000000000000000000000;;	  # kubectl for inclusion in a container.
0000000000000000000000000000000000000000;;	  if [ -n "${KUBE_STATIC_OVERRIDES:+x}" ]; then
0000000000000000000000000000000000000000;;	    for e in "${KUBE_STATIC_OVERRIDES[@]}"; do [[ "$1" == *"/$e" ]] && return 0; done;
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  return 1;
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# kube::binaries_from_targets take a list of build targets and return the
0000000000000000000000000000000000000000;;	# full go package to be built
0000000000000000000000000000000000000000;;	kube::golang::binaries_from_targets() {
0000000000000000000000000000000000000000;;	  local target
0000000000000000000000000000000000000000;;	  for target; do
0000000000000000000000000000000000000000;;	    # If the target starts with what looks like a domain name, assume it has a
0000000000000000000000000000000000000000;;	    # fully-qualified package name rather than one that needs the Kubernetes
0000000000000000000000000000000000000000;;	    # package prepended.
0000000000000000000000000000000000000000;;	    if [[ "${target}" =~ ^([[:alnum:]]+".")+[[:alnum:]]+"/" ]]; then
0000000000000000000000000000000000000000;;	      echo "${target}"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      echo "${KUBE_GO_PACKAGE}/${target}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Asks golang what it thinks the host platform is. The go tool chain does some
0000000000000000000000000000000000000000;;	# slightly different things when the target platform matches the host platform.
0000000000000000000000000000000000000000;;	kube::golang::host_platform() {
0000000000000000000000000000000000000000;;	  echo "$(go env GOHOSTOS)/$(go env GOHOSTARCH)"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::golang::current_platform() {
0000000000000000000000000000000000000000;;	  local os="${GOOS-}"
0000000000000000000000000000000000000000;;	  if [[ -z $os ]]; then
0000000000000000000000000000000000000000;;	    os=$(go env GOHOSTOS)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local arch="${GOARCH-}"
0000000000000000000000000000000000000000;;	  if [[ -z $arch ]]; then
0000000000000000000000000000000000000000;;	    arch=$(go env GOHOSTARCH)
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "$os/$arch"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Takes the the platform name ($1) and sets the appropriate golang env variables
0000000000000000000000000000000000000000;;	# for that platform.
0000000000000000000000000000000000000000;;	kube::golang::set_platform_envs() {
0000000000000000000000000000000000000000;;	  [[ -n ${1-} ]] || {
0000000000000000000000000000000000000000;;	    kube::log::error_exit "!!! Internal error. No platform set in kube::golang::set_platform_envs"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export GOOS=${platform%/*}
0000000000000000000000000000000000000000;;	  export GOARCH=${platform##*/}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Do not set CC when building natively on a platform, only if cross-compiling from linux/amd64
0000000000000000000000000000000000000000;;	  if [[ $(kube::golang::host_platform) == "linux/amd64" ]]; then
0000000000000000000000000000000000000000;;	    # Dynamic CGO linking for other server architectures than linux/amd64 goes here
0000000000000000000000000000000000000000;;	    # If you want to include support for more server platforms than these, add arch-specific gcc names here
0000000000000000000000000000000000000000;;	    case "${platform}" in
0000000000000000000000000000000000000000;;	      "linux/arm")
0000000000000000000000000000000000000000;;	        export CGO_ENABLED=1
0000000000000000000000000000000000000000;;	        export CC=arm-linux-gnueabihf-gcc
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      "linux/arm64")
0000000000000000000000000000000000000000;;	        export CGO_ENABLED=1
0000000000000000000000000000000000000000;;	        export CC=aarch64-linux-gnu-gcc
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      "linux/ppc64le")
0000000000000000000000000000000000000000;;	        export CGO_ENABLED=1
0000000000000000000000000000000000000000;;	        export CC=powerpc64le-linux-gnu-gcc
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      "linux/s390x")
0000000000000000000000000000000000000000;;	        export CGO_ENABLED=1
0000000000000000000000000000000000000000;;	        export CC=s390x-linux-gnu-gcc
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::golang::unset_platform_envs() {
0000000000000000000000000000000000000000;;	  unset GOOS
0000000000000000000000000000000000000000;;	  unset GOARCH
0000000000000000000000000000000000000000;;	  unset GOROOT
0000000000000000000000000000000000000000;;	  unset CGO_ENABLED
0000000000000000000000000000000000000000;;	  unset CC
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create the GOPATH tree under $KUBE_OUTPUT
0000000000000000000000000000000000000000;;	kube::golang::create_gopath_tree() {
0000000000000000000000000000000000000000;;	  local go_pkg_dir="${KUBE_GOPATH}/src/${KUBE_GO_PACKAGE}"
0000000000000000000000000000000000000000;;	  local go_pkg_basedir=$(dirname "${go_pkg_dir}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p "${go_pkg_basedir}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # TODO: This symlink should be relative.
0000000000000000000000000000000000000000;;	  if [[ ! -e "${go_pkg_dir}" || "$(readlink ${go_pkg_dir})" != "${KUBE_ROOT}" ]]; then
0000000000000000000000000000000000000000;;	    ln -snf "${KUBE_ROOT}" "${go_pkg_dir}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cat >"${KUBE_GOPATH}/BUILD" <<EOF
0000000000000000000000000000000000000000;;	# This dummy BUILD file prevents Bazel from trying to descend through the
0000000000000000000000000000000000000000;;	# infinite loop created by the symlink at
0000000000000000000000000000000000000000;;	# ${go_pkg_dir}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Ensure the go tool exists and is a viable version.
0000000000000000000000000000000000000000;;	kube::golang::verify_go_version() {
0000000000000000000000000000000000000000;;	  if [[ -z "$(which go)" ]]; then
0000000000000000000000000000000000000000;;	    kube::log::usage_from_stdin <<EOF
0000000000000000000000000000000000000000;;	Can't find 'go' in PATH, please fix and retry.
0000000000000000000000000000000000000000;;	See http://golang.org/doc/install for installation instructions.
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    return 2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local go_version
0000000000000000000000000000000000000000;;	  go_version=($(go version))
0000000000000000000000000000000000000000;;	  if [[ "${go_version[2]}" < "go1.6" && "${go_version[2]}" != "devel" ]]; then
0000000000000000000000000000000000000000;;	    kube::log::usage_from_stdin <<EOF
0000000000000000000000000000000000000000;;	Detected go version: ${go_version[*]}.
0000000000000000000000000000000000000000;;	Kubernetes requires go version 1.6 or greater.
0000000000000000000000000000000000000000;;	Please install Go version 1.6 or later.
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	    return 2
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# kube::golang::setup_env will check that the `go` commands is available in
0000000000000000000000000000000000000000;;	# ${PATH}. It will also check that the Go version is good enough for the
0000000000000000000000000000000000000000;;	# Kubernetes build.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Inputs:
0000000000000000000000000000000000000000;;	#   KUBE_EXTRA_GOPATH - If set, this is included in created GOPATH
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Outputs:
0000000000000000000000000000000000000000;;	#   env-var GOPATH points to our local output dir
0000000000000000000000000000000000000000;;	#   env-var GOBIN is unset (we want binaries in a predictable place)
0000000000000000000000000000000000000000;;	#   env-var GO15VENDOREXPERIMENT=1
0000000000000000000000000000000000000000;;	#   current directory is within GOPATH
0000000000000000000000000000000000000000;;	kube::golang::setup_env() {
0000000000000000000000000000000000000000;;	  kube::golang::verify_go_version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::golang::create_gopath_tree
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export GOPATH=${KUBE_GOPATH}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Append KUBE_EXTRA_GOPATH to the GOPATH if it is defined.
0000000000000000000000000000000000000000;;	  if [[ -n ${KUBE_EXTRA_GOPATH:-} ]]; then
0000000000000000000000000000000000000000;;	    GOPATH="${GOPATH}:${KUBE_EXTRA_GOPATH}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Change directories so that we are within the GOPATH.  Some tools get really
0000000000000000000000000000000000000000;;	  # upset if this is not true.  We use a whole fake GOPATH here to collect the
0000000000000000000000000000000000000000;;	  # resultant binaries.  Go will not let us use GOBIN with `go install` and
0000000000000000000000000000000000000000;;	  # cross-compiling, and `go install -o <file>` only works for a single pkg.
0000000000000000000000000000000000000000;;	  local subdir
0000000000000000000000000000000000000000;;	  subdir=$(kube::realpath . | sed "s|$KUBE_ROOT||")
0000000000000000000000000000000000000000;;	  cd "${KUBE_GOPATH}/src/${KUBE_GO_PACKAGE}/${subdir}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Set GOROOT so binaries that parse code can work properly.
0000000000000000000000000000000000000000;;	  export GOROOT=$(go env GOROOT)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Unset GOBIN in case it already exists in the current session.
0000000000000000000000000000000000000000;;	  unset GOBIN
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # This seems to matter to some tools (godep, ugorji, ginkgo...)
0000000000000000000000000000000000000000;;	  export GO15VENDOREXPERIMENT=1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This will take binaries from $GOPATH/bin and copy them to the appropriate
0000000000000000000000000000000000000000;;	# place in ${KUBE_OUTPUT_BINDIR}
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Ideally this wouldn't be necessary and we could just set GOBIN to
0000000000000000000000000000000000000000;;	# KUBE_OUTPUT_BINDIR but that won't work in the face of cross compilation.  'go
0000000000000000000000000000000000000000;;	# install' will place binaries that match the host platform directly in $GOBIN
0000000000000000000000000000000000000000;;	# while placing cross compiled binaries into `platform_arch` subdirs.  This
0000000000000000000000000000000000000000;;	# complicates pretty much everything else we do around packaging and such.
0000000000000000000000000000000000000000;;	kube::golang::place_bins() {
0000000000000000000000000000000000000000;;	  local host_platform
0000000000000000000000000000000000000000;;	  host_platform=$(kube::golang::host_platform)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  V=2 kube::log::status "Placing binaries"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local platform
0000000000000000000000000000000000000000;;	  for platform in "${KUBE_CLIENT_PLATFORMS[@]}"; do
0000000000000000000000000000000000000000;;	    # The substitution on platform_src below will replace all slashes with
0000000000000000000000000000000000000000;;	    # underscores.  It'll transform darwin/amd64 -> darwin_amd64.
0000000000000000000000000000000000000000;;	    local platform_src="/${platform//\//_}"
0000000000000000000000000000000000000000;;	    if [[ $platform == $host_platform ]]; then
0000000000000000000000000000000000000000;;	      platform_src=""
0000000000000000000000000000000000000000;;	      rm -f "${THIS_PLATFORM_BIN}"
0000000000000000000000000000000000000000;;	      ln -s "${KUBE_OUTPUT_BINPATH}/${platform}" "${THIS_PLATFORM_BIN}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local full_binpath_src="${KUBE_GOPATH}/bin${platform_src}"
0000000000000000000000000000000000000000;;	    if [[ -d "${full_binpath_src}" ]]; then
0000000000000000000000000000000000000000;;	      mkdir -p "${KUBE_OUTPUT_BINPATH}/${platform}"
0000000000000000000000000000000000000000;;	      find "${full_binpath_src}" -maxdepth 1 -type f -exec \
0000000000000000000000000000000000000000;;	        rsync -pc {} "${KUBE_OUTPUT_BINPATH}/${platform}" \;
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::golang::fallback_if_stdlib_not_installable() {
0000000000000000000000000000000000000000;;	  local go_root_dir=$(go env GOROOT);
0000000000000000000000000000000000000000;;	  local go_host_os=$(go env GOHOSTOS);
0000000000000000000000000000000000000000;;	  local go_host_arch=$(go env GOHOSTARCH);
0000000000000000000000000000000000000000;;	  local cgo_pkg_dir=${go_root_dir}/pkg/${go_host_os}_${go_host_arch}_cgo;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ -e ${cgo_pkg_dir} ]; then
0000000000000000000000000000000000000000;;	    return 0;
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ -w ${go_root_dir}/pkg ]; then
0000000000000000000000000000000000000000;;	    return 0;
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "+++ Warning: stdlib pkg with cgo flag not found.";
0000000000000000000000000000000000000000;;	  kube::log::status "+++ Warning: stdlib pkg cannot be rebuilt since ${go_root_dir}/pkg is not writable by `whoami`";
0000000000000000000000000000000000000000;;	  kube::log::status "+++ Warning: Make ${go_root_dir}/pkg writable for `whoami` for a one-time stdlib install, Or"
0000000000000000000000000000000000000000;;	  kube::log::status "+++ Warning: Rebuild stdlib using the command 'CGO_ENABLED=0 go install -a -installsuffix cgo std'";
0000000000000000000000000000000000000000;;	  kube::log::status "+++ Falling back to go build, which is slower";
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  use_go_build=true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Builds the toolchain necessary for building kube. This needs to be
0000000000000000000000000000000000000000;;	# built only on the host platform.
0000000000000000000000000000000000000000;;	# TODO: Find this a proper home.
0000000000000000000000000000000000000000;;	# Ideally, not a shell script because testing shell scripts is painful.
0000000000000000000000000000000000000000;;	kube::golang::build_kube_toolchain() {
0000000000000000000000000000000000000000;;	  local targets=(
0000000000000000000000000000000000000000;;	    hack/cmd/teststale
0000000000000000000000000000000000000000;;	    vendor/github.com/jteeuwen/go-bindata/go-bindata
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local binaries
0000000000000000000000000000000000000000;;	  binaries=($(kube::golang::binaries_from_targets "${targets[@]}"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Building the toolchain targets:" "${binaries[@]}"
0000000000000000000000000000000000000000;;	  go install "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	        -gcflags "${gogcflags}" \
0000000000000000000000000000000000000000;;	        -ldflags "${goldflags}" \
0000000000000000000000000000000000000000;;	        "${binaries[@]:+${binaries[@]}}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Try and replicate the native binary placement of go install without
0000000000000000000000000000000000000000;;	# calling go install.
0000000000000000000000000000000000000000;;	kube::golang::output_filename_for_binary() {
0000000000000000000000000000000000000000;;	  local binary=$1
0000000000000000000000000000000000000000;;	  local platform=$2
0000000000000000000000000000000000000000;;	  local output_path="${KUBE_GOPATH}/bin"
0000000000000000000000000000000000000000;;	  if [[ $platform != $host_platform ]]; then
0000000000000000000000000000000000000000;;	    output_path="${output_path}/${platform//\//_}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  local bin=$(basename "${binary}")
0000000000000000000000000000000000000000;;	  if [[ ${GOOS} == "windows" ]]; then
0000000000000000000000000000000000000000;;	    bin="${bin}.exe"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "${output_path}/${bin}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::golang::build_binaries_for_platform() {
0000000000000000000000000000000000000000;;	  local platform=$1
0000000000000000000000000000000000000000;;	  local use_go_build=${2-}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local -a statics=()
0000000000000000000000000000000000000000;;	  local -a nonstatics=()
0000000000000000000000000000000000000000;;	  local -a tests=()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  V=2 kube::log::info "Env for ${platform}: GOOS=${GOOS-} GOARCH=${GOARCH-} GOROOT=${GOROOT-} CGO_ENABLED=${CGO_ENABLED-} CC=${CC-}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for binary in "${binaries[@]}"; do
0000000000000000000000000000000000000000;;	    if [[ "${binary}" =~ ".test"$ ]]; then
0000000000000000000000000000000000000000;;	      tests+=($binary)
0000000000000000000000000000000000000000;;	    elif kube::golang::is_statically_linked_library "${binary}"; then
0000000000000000000000000000000000000000;;	      statics+=($binary)
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      nonstatics+=($binary)
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "${#statics[@]}" != 0 ]]; then
0000000000000000000000000000000000000000;;	      kube::golang::fallback_if_stdlib_not_installable;
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -n ${use_go_build:-} ]]; then
0000000000000000000000000000000000000000;;	    kube::log::progress "    "
0000000000000000000000000000000000000000;;	    for binary in "${statics[@]:+${statics[@]}}"; do
0000000000000000000000000000000000000000;;	      local outfile=$(kube::golang::output_filename_for_binary "${binary}" "${platform}")
0000000000000000000000000000000000000000;;	      CGO_ENABLED=0 go build -o "${outfile}" \
0000000000000000000000000000000000000000;;	        "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	        -gcflags "${gogcflags}" \
0000000000000000000000000000000000000000;;	        -ldflags "${goldflags}" \
0000000000000000000000000000000000000000;;	        "${binary}"
0000000000000000000000000000000000000000;;	      kube::log::progress "*"
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    for binary in "${nonstatics[@]:+${nonstatics[@]}}"; do
0000000000000000000000000000000000000000;;	      local outfile=$(kube::golang::output_filename_for_binary "${binary}" "${platform}")
0000000000000000000000000000000000000000;;	      go build -o "${outfile}" \
0000000000000000000000000000000000000000;;	        "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	        -gcflags "${gogcflags}" \
0000000000000000000000000000000000000000;;	        -ldflags "${goldflags}" \
0000000000000000000000000000000000000000;;	        "${binary}"
0000000000000000000000000000000000000000;;	      kube::log::progress "*"
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    kube::log::progress "\n"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    # Use go install.
0000000000000000000000000000000000000000;;	    if [[ "${#nonstatics[@]}" != 0 ]]; then
0000000000000000000000000000000000000000;;	      go install "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	        -gcflags "${gogcflags}" \
0000000000000000000000000000000000000000;;	        -ldflags "${goldflags}" \
0000000000000000000000000000000000000000;;	        "${nonstatics[@]:+${nonstatics[@]}}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ "${#statics[@]}" != 0 ]]; then
0000000000000000000000000000000000000000;;	      CGO_ENABLED=0 go install -installsuffix cgo "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	        -gcflags "${gogcflags}" \
0000000000000000000000000000000000000000;;	        -ldflags "${goldflags}" \
0000000000000000000000000000000000000000;;	        "${statics[@]:+${statics[@]}}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for test in "${tests[@]:+${tests[@]}}"; do
0000000000000000000000000000000000000000;;	    local outfile=$(kube::golang::output_filename_for_binary "${test}" \
0000000000000000000000000000000000000000;;	      "${platform}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local testpkg="$(dirname ${test})"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Staleness check always happens on the host machine, so we don't
0000000000000000000000000000000000000000;;	    # have to locate the `teststale` binaries for the other platforms.
0000000000000000000000000000000000000000;;	    # Since we place the host binaries in `$KUBE_GOPATH/bin`, we can
0000000000000000000000000000000000000000;;	    # assume that the binary exists there, if it exists at all.
0000000000000000000000000000000000000000;;	    # Otherwise, something has gone wrong with building the `teststale`
0000000000000000000000000000000000000000;;	    # binary and we should safely proceed building the test binaries
0000000000000000000000000000000000000000;;	    # assuming that they are stale. There is no good reason to error
0000000000000000000000000000000000000000;;	    # out.
0000000000000000000000000000000000000000;;	    if test -x "${KUBE_GOPATH}/bin/teststale" && ! "${KUBE_GOPATH}/bin/teststale" -binary "${outfile}" -package "${testpkg}"
0000000000000000000000000000000000000000;;	    then
0000000000000000000000000000000000000000;;	      continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # `go test -c` below directly builds the binary. It builds the packages,
0000000000000000000000000000000000000000;;	    # but it never installs them. `go test -i` only installs the dependencies
0000000000000000000000000000000000000000;;	    # of the test, but not the test package itself. So neither `go test -c`
0000000000000000000000000000000000000000;;	    # nor `go test -i` installs, for example, test/e2e.a. And without that,
0000000000000000000000000000000000000000;;	    # doing a staleness check on k8s.io/kubernetes/test/e2e package always
0000000000000000000000000000000000000000;;	    # returns true (always stale). And that's why we need to install the
0000000000000000000000000000000000000000;;	    # test package.
0000000000000000000000000000000000000000;;	    go install "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	        -gcflags "${gogcflags}" \
0000000000000000000000000000000000000000;;	        -ldflags "${goldflags}" \
0000000000000000000000000000000000000000;;	        "${testpkg}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    mkdir -p "$(dirname ${outfile})"
0000000000000000000000000000000000000000;;	    go test -i -c \
0000000000000000000000000000000000000000;;	      "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	      -gcflags "${gogcflags}" \
0000000000000000000000000000000000000000;;	      -ldflags "${goldflags}" \
0000000000000000000000000000000000000000;;	      -o "${outfile}" \
0000000000000000000000000000000000000000;;	      "${testpkg}"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Return approximate physical memory available in gigabytes.
0000000000000000000000000000000000000000;;	kube::golang::get_physmem() {
0000000000000000000000000000000000000000;;	  local mem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Linux kernel version >=3.14, in kb
0000000000000000000000000000000000000000;;	  if mem=$(grep MemAvailable /proc/meminfo | awk '{ print $2 }'); then
0000000000000000000000000000000000000000;;	    echo $(( ${mem} / 1048576 ))
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Linux, in kb
0000000000000000000000000000000000000000;;	  if mem=$(grep MemTotal /proc/meminfo | awk '{ print $2 }'); then
0000000000000000000000000000000000000000;;	    echo $(( ${mem} / 1048576 ))
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # OS X, in bytes. Note that get_physmem, as used, should only ever
0000000000000000000000000000000000000000;;	  # run in a Linux container (because it's only used in the multiple
0000000000000000000000000000000000000000;;	  # platform case, which is a Dockerized build), but this is provided
0000000000000000000000000000000000000000;;	  # for completeness.
0000000000000000000000000000000000000000;;	  if mem=$(sysctl -n hw.memsize 2>/dev/null); then
0000000000000000000000000000000000000000;;	    echo $(( ${mem} / 1073741824 ))
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If we can't infer it, just give up and assume a low memory system
0000000000000000000000000000000000000000;;	  echo 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Build binaries targets specified
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Input:
0000000000000000000000000000000000000000;;	#   $@ - targets and go flags.  If no targets are set then all binaries targets
0000000000000000000000000000000000000000;;	#     are built.
0000000000000000000000000000000000000000;;	#   KUBE_BUILD_PLATFORMS - Incoming variable of targets to build for.  If unset
0000000000000000000000000000000000000000;;	#     then just the host architecture is built.
0000000000000000000000000000000000000000;;	kube::golang::build_binaries() {
0000000000000000000000000000000000000000;;	  # Create a sub-shell so that we don't pollute the outer environment
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    # Check for `go` binary and set ${GOPATH}.
0000000000000000000000000000000000000000;;	    kube::golang::setup_env
0000000000000000000000000000000000000000;;	    V=2 kube::log::info "Go version: $(go version)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local host_platform
0000000000000000000000000000000000000000;;	    host_platform=$(kube::golang::host_platform)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Use eval to preserve embedded quoted strings.
0000000000000000000000000000000000000000;;	    local goflags goldflags gogcflags
0000000000000000000000000000000000000000;;	    eval "goflags=(${GOFLAGS:-})"
0000000000000000000000000000000000000000;;	    goldflags="${GOLDFLAGS:-} $(kube::version::ldflags)"
0000000000000000000000000000000000000000;;	    gogcflags="${GOGCFLAGS:-}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local use_go_build
0000000000000000000000000000000000000000;;	    local -a targets=()
0000000000000000000000000000000000000000;;	    local arg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    for arg; do
0000000000000000000000000000000000000000;;	      if [[ "${arg}" == "--use_go_build" ]]; then
0000000000000000000000000000000000000000;;	        use_go_build=true
0000000000000000000000000000000000000000;;	      elif [[ "${arg}" == -* ]]; then
0000000000000000000000000000000000000000;;	        # Assume arguments starting with a dash are flags to pass to go.
0000000000000000000000000000000000000000;;	        goflags+=("${arg}")
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        targets+=("${arg}")
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ ${#targets[@]} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	      targets=("${KUBE_ALL_TARGETS[@]}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local -a platforms=(${KUBE_BUILD_PLATFORMS:-})
0000000000000000000000000000000000000000;;	    if [[ ${#platforms[@]} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	      platforms=("${host_platform}")
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local binaries
0000000000000000000000000000000000000000;;	    binaries=($(kube::golang::binaries_from_targets "${targets[@]}"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    local parallel=false
0000000000000000000000000000000000000000;;	    if [[ ${#platforms[@]} -gt 1 ]]; then
0000000000000000000000000000000000000000;;	      local gigs
0000000000000000000000000000000000000000;;	      gigs=$(kube::golang::get_physmem)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      if [[ ${gigs} -ge ${KUBE_PARALLEL_BUILD_MEMORY} ]]; then
0000000000000000000000000000000000000000;;	        kube::log::status "Multiple platforms requested and available ${gigs}G >= threshold ${KUBE_PARALLEL_BUILD_MEMORY}G, building platforms in parallel"
0000000000000000000000000000000000000000;;	        parallel=true
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	        kube::log::status "Multiple platforms requested, but available ${gigs}G < threshold ${KUBE_PARALLEL_BUILD_MEMORY}G, building platforms in serial"
0000000000000000000000000000000000000000;;	        parallel=false
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # First build the toolchain before building any other targets
0000000000000000000000000000000000000000;;	    kube::golang::build_kube_toolchain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kube::log::status "Generating bindata:" "${KUBE_BINDATAS[@]}"
0000000000000000000000000000000000000000;;	    for bindata in ${KUBE_BINDATAS[@]}; do
0000000000000000000000000000000000000000;;	      # Only try to generate bindata if the file exists, since in some cases
0000000000000000000000000000000000000000;;	      # one-off builds of individual directories may exclude some files.
0000000000000000000000000000000000000000;;	      if [[ -f "${KUBE_ROOT}/${bindata}" ]]; then
0000000000000000000000000000000000000000;;	        go generate "${goflags[@]:+${goflags[@]}}" "${KUBE_ROOT}/${bindata}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ "${parallel}" == "true" ]]; then
0000000000000000000000000000000000000000;;	      kube::log::status "Building go targets for {${platforms[*]}} in parallel (output will appear in a burst when complete):" "${targets[@]}"
0000000000000000000000000000000000000000;;	      local platform
0000000000000000000000000000000000000000;;	      for platform in "${platforms[@]}"; do (
0000000000000000000000000000000000000000;;	          kube::golang::set_platform_envs "${platform}"
0000000000000000000000000000000000000000;;	          kube::log::status "${platform}: go build started"
0000000000000000000000000000000000000000;;	          kube::golang::build_binaries_for_platform ${platform} ${use_go_build:-}
0000000000000000000000000000000000000000;;	          kube::log::status "${platform}: go build finished"
0000000000000000000000000000000000000000;;	        ) &> "/tmp//${platform//\//_}.build" &
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      local fails=0
0000000000000000000000000000000000000000;;	      for job in $(jobs -p); do
0000000000000000000000000000000000000000;;	        wait ${job} || let "fails+=1"
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      for platform in "${platforms[@]}"; do
0000000000000000000000000000000000000000;;	        cat "/tmp//${platform//\//_}.build"
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      exit ${fails}
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      for platform in "${platforms[@]}"; do
0000000000000000000000000000000000000000;;	        kube::log::status "Building go targets for ${platform}:" "${targets[@]}"
0000000000000000000000000000000000000000;;	        (
0000000000000000000000000000000000000000;;	          kube::golang::set_platform_envs "${platform}"
0000000000000000000000000000000000000000;;	          kube::golang::build_binaries_for_platform ${platform} ${use_go_build:-}
0000000000000000000000000000000000000000;;	        )
0000000000000000000000000000000000000000;;	      done
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	}
