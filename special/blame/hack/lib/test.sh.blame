0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A set of helpers for tests
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly reset=$(tput sgr0)
0000000000000000000000000000000000000000;;	readonly  bold=$(tput bold)
0000000000000000000000000000000000000000;;	readonly black=$(tput setaf 0)
0000000000000000000000000000000000000000;;	readonly   red=$(tput setaf 1)
0000000000000000000000000000000000000000;;	readonly green=$(tput setaf 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::clear_all() {
0000000000000000000000000000000000000000;;	  if kube::test::if_supports_resource "rc" ; then
0000000000000000000000000000000000000000;;	    kubectl delete "${kube_flags[@]}" rc --all --grace-period=0 --force
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  if kube::test::if_supports_resource "pods" ; then
0000000000000000000000000000000000000000;;	    kubectl delete "${kube_flags[@]}" pods --all --grace-period=0 --force
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Prints the calling file and line number $1 levels deep
0000000000000000000000000000000000000000;;	# Defaults to 2 levels so you can call this to find your own caller
0000000000000000000000000000000000000000;;	kube::test::get_caller() {
0000000000000000000000000000000000000000;;	  local levels=${1:-2}
0000000000000000000000000000000000000000;;	  local caller_file="${BASH_SOURCE[$levels]}"
0000000000000000000000000000000000000000;;	  local caller_line="${BASH_LINENO[$levels-1]}"
0000000000000000000000000000000000000000;;	  echo "$(basename "${caller_file}"):${caller_line}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Force exact match of a returned result for a object query.  Wrap this with || to support multiple
0000000000000000000000000000000000000000;;	# valid return types.
0000000000000000000000000000000000000000;;	# This runs `kubectl get` once and asserts that the result is as expected.
0000000000000000000000000000000000000000;;	## $1: Object on which get should be run
0000000000000000000000000000000000000000;;	# $2: The go-template to run on the result
0000000000000000000000000000000000000000;;	# $3: The expected output
0000000000000000000000000000000000000000;;	# $4: Additional args to be passed to kubectl
0000000000000000000000000000000000000000;;	kube::test::get_object_assert() {
0000000000000000000000000000000000000000;;	  kube::test::object_assert 1 "$@"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Asserts that the output of a given get query is as expected.
0000000000000000000000000000000000000000;;	# Runs the query multiple times before failing it.
0000000000000000000000000000000000000000;;	# $1: Object on which get should be run
0000000000000000000000000000000000000000;;	# $2: The go-template to run on the result
0000000000000000000000000000000000000000;;	# $3: The expected output
0000000000000000000000000000000000000000;;	# $4: Additional args to be passed to kubectl
0000000000000000000000000000000000000000;;	kube::test::wait_object_assert() {
0000000000000000000000000000000000000000;;	  kube::test::object_assert 10 "$@"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Asserts that the output of a given get query is as expected.
0000000000000000000000000000000000000000;;	# Can run the query multiple times before failing it.
0000000000000000000000000000000000000000;;	# $1: Number of times the query should be run before failing it.
0000000000000000000000000000000000000000;;	# $2: Object on which get should be run
0000000000000000000000000000000000000000;;	# $3: The go-template to run on the result
0000000000000000000000000000000000000000;;	# $4: The expected output
0000000000000000000000000000000000000000;;	# $5: Additional args to be passed to kubectl
0000000000000000000000000000000000000000;;	kube::test::object_assert() {
0000000000000000000000000000000000000000;;	  local tries=$1
0000000000000000000000000000000000000000;;	  local object=$2
0000000000000000000000000000000000000000;;	  local request=$3
0000000000000000000000000000000000000000;;	  local expected=$4
0000000000000000000000000000000000000000;;	  local args=${5:-}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for j in $(seq 1 ${tries}); do
0000000000000000000000000000000000000000;;	    res=$(eval kubectl get -a "${kube_flags[@]}" ${args} $object -o go-template=\"$request\")
0000000000000000000000000000000000000000;;	    if [[ "$res" =~ ^$expected$ ]]; then
0000000000000000000000000000000000000000;;	        echo -n ${green}
0000000000000000000000000000000000000000;;	        echo "$(kube::test::get_caller 3): Successful get $object $request: $res"
0000000000000000000000000000000000000000;;	        echo -n ${reset}
0000000000000000000000000000000000000000;;	        return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    echo "Waiting for Get $object $request $args: expected: $expected, got: $res"
0000000000000000000000000000000000000000;;	    sleep $((${j}-1))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo ${bold}${red}
0000000000000000000000000000000000000000;;	  echo "$(kube::test::get_caller 3): FAIL!"
0000000000000000000000000000000000000000;;	  echo "Get $object $request"
0000000000000000000000000000000000000000;;	  echo "  Expected: $expected"
0000000000000000000000000000000000000000;;	  echo "  Got:      $res"
0000000000000000000000000000000000000000;;	  echo ${reset}${red}
0000000000000000000000000000000000000000;;	  caller
0000000000000000000000000000000000000000;;	  echo ${reset}
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::get_object_jsonpath_assert() {
0000000000000000000000000000000000000000;;	  local object=$1
0000000000000000000000000000000000000000;;	  local request=$2
0000000000000000000000000000000000000000;;	  local expected=$3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  res=$(eval kubectl get -a "${kube_flags[@]}" $object -o jsonpath=\"$request\")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "$res" =~ ^$expected$ ]]; then
0000000000000000000000000000000000000000;;	      echo -n ${green}
0000000000000000000000000000000000000000;;	      echo "$(kube::test::get_caller): Successful get $object $request: $res"
0000000000000000000000000000000000000000;;	      echo -n ${reset}
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	      echo ${bold}${red}
0000000000000000000000000000000000000000;;	      echo "$(kube::test::get_caller): FAIL!"
0000000000000000000000000000000000000000;;	      echo "Get $object $request"
0000000000000000000000000000000000000000;;	      echo "  Expected: $expected"
0000000000000000000000000000000000000000;;	      echo "  Got:      $res"
0000000000000000000000000000000000000000;;	      echo ${reset}${red}
0000000000000000000000000000000000000000;;	      caller
0000000000000000000000000000000000000000;;	      echo ${reset}
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::describe_object_assert() {
0000000000000000000000000000000000000000;;	  local resource=$1
0000000000000000000000000000000000000000;;	  local object=$2
0000000000000000000000000000000000000000;;	  local matches=${@:3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  result=$(eval kubectl describe "${kube_flags[@]}" $resource $object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for match in ${matches}; do
0000000000000000000000000000000000000000;;	    if [[ ! $(echo "$result" | grep ${match}) ]]; then
0000000000000000000000000000000000000000;;	      echo ${bold}${red}
0000000000000000000000000000000000000000;;	      echo "$(kube::test::get_caller): FAIL!"
0000000000000000000000000000000000000000;;	      echo "Describe $resource $object"
0000000000000000000000000000000000000000;;	      echo "  Expected Match: $match"
0000000000000000000000000000000000000000;;	      echo "  Not found in:"
0000000000000000000000000000000000000000;;	      echo "$result"
0000000000000000000000000000000000000000;;	      echo ${reset}${red}
0000000000000000000000000000000000000000;;	      caller
0000000000000000000000000000000000000000;;	      echo ${reset}
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo -n ${green}
0000000000000000000000000000000000000000;;	  echo "$(kube::test::get_caller): Successful describe $resource $object:"
0000000000000000000000000000000000000000;;	  echo "$result"
0000000000000000000000000000000000000000;;	  echo -n ${reset}
0000000000000000000000000000000000000000;;	  return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::describe_object_events_assert() {
0000000000000000000000000000000000000000;;	    local resource=$1
0000000000000000000000000000000000000000;;	    local object=$2
0000000000000000000000000000000000000000;;	    local showevents=${3:-"true"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -z "${3:-}" ]]; then
0000000000000000000000000000000000000000;;	        result=$(eval kubectl describe "${kube_flags[@]}" $resource $object)
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        result=$(eval kubectl describe "${kube_flags[@]}" "--show-events=$showevents" $resource $object)
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -n $(echo "$result" | grep "No events.\|Events:") ]]; then
0000000000000000000000000000000000000000;;	        local has_events="true"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        local has_events="false"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ $showevents == $has_events ]]; then
0000000000000000000000000000000000000000;;	        echo -n ${green}
0000000000000000000000000000000000000000;;	        echo "$(kube::test::get_caller): Successful describe"
0000000000000000000000000000000000000000;;	        echo "$result"
0000000000000000000000000000000000000000;;	        echo ${reset}
0000000000000000000000000000000000000000;;	        return 0
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        echo ${bold}${red}
0000000000000000000000000000000000000000;;	        echo "$(kube::test::get_caller): FAIL"
0000000000000000000000000000000000000000;;	        if [[ $showevents == "false" ]]; then
0000000000000000000000000000000000000000;;	            echo "  Events information should not be described in:"
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	            echo "  Events information not found in:"
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        echo $result
0000000000000000000000000000000000000000;;	        echo ${reset}${red}
0000000000000000000000000000000000000000;;	        caller
0000000000000000000000000000000000000000;;	        echo ${reset}
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::describe_resource_assert() {
0000000000000000000000000000000000000000;;	  local resource=$1
0000000000000000000000000000000000000000;;	  local matches=${@:2}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  result=$(eval kubectl describe "${kube_flags[@]}" $resource)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for match in ${matches}; do
0000000000000000000000000000000000000000;;	    if [[ ! $(echo "$result" | grep ${match}) ]]; then
0000000000000000000000000000000000000000;;	      echo ${bold}${red}
0000000000000000000000000000000000000000;;	      echo "FAIL!"
0000000000000000000000000000000000000000;;	      echo "Describe $resource"
0000000000000000000000000000000000000000;;	      echo "  Expected Match: $match"
0000000000000000000000000000000000000000;;	      echo "  Not found in:"
0000000000000000000000000000000000000000;;	      echo "$result"
0000000000000000000000000000000000000000;;	      echo ${reset}${red}
0000000000000000000000000000000000000000;;	      caller
0000000000000000000000000000000000000000;;	      echo ${reset}
0000000000000000000000000000000000000000;;	      return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo -n ${green}
0000000000000000000000000000000000000000;;	  echo "Successful describe $resource:"
0000000000000000000000000000000000000000;;	  echo "$result"
0000000000000000000000000000000000000000;;	  echo -n ${reset}
0000000000000000000000000000000000000000;;	  return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::describe_resource_events_assert() {
0000000000000000000000000000000000000000;;	    local resource=$1
0000000000000000000000000000000000000000;;	    local showevents=${2:-"true"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    result=$(eval kubectl describe "${kube_flags[@]}" "--show-events=$showevents" $resource)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ $(echo "$result" | grep "No events.\|Events:") ]]; then
0000000000000000000000000000000000000000;;	        local has_events="true"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        local has_events="false"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ $showevents == $has_events ]]; then
0000000000000000000000000000000000000000;;	        echo -n ${green}
0000000000000000000000000000000000000000;;	        echo "Successful describe"
0000000000000000000000000000000000000000;;	        echo "$result"
0000000000000000000000000000000000000000;;	        echo -n ${reset}
0000000000000000000000000000000000000000;;	        return 0
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        echo ${bold}${red}
0000000000000000000000000000000000000000;;	        echo "FAIL"
0000000000000000000000000000000000000000;;	        if [[ $showevents == "false" ]]; then
0000000000000000000000000000000000000000;;	            echo "  Events information should not be described in:"
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	            echo "  Events information not found in:"
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	        echo $result
0000000000000000000000000000000000000000;;	        caller
0000000000000000000000000000000000000000;;	        echo ${reset}
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::if_has_string() {
0000000000000000000000000000000000000000;;	  local message=$1
0000000000000000000000000000000000000000;;	  local match=$2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if echo "$message" | grep -q "$match"; then
0000000000000000000000000000000000000000;;	    echo "Successful"
0000000000000000000000000000000000000000;;	    echo "message:$message"
0000000000000000000000000000000000000000;;	    echo "has:$match"
0000000000000000000000000000000000000000;;	    return 0
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "FAIL!"
0000000000000000000000000000000000000000;;	    echo "message:$message"
0000000000000000000000000000000000000000;;	    echo "has not:$match"
0000000000000000000000000000000000000000;;	    caller
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::if_has_not_string() {
0000000000000000000000000000000000000000;;	  local message=$1
0000000000000000000000000000000000000000;;	  local match=$2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if echo "$message" | grep -q "$match"; then
0000000000000000000000000000000000000000;;	    echo "FAIL!"
0000000000000000000000000000000000000000;;	    echo "message:$message"
0000000000000000000000000000000000000000;;	    echo "has:$match"
0000000000000000000000000000000000000000;;	    caller
0000000000000000000000000000000000000000;;	    return 1
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Successful"
0000000000000000000000000000000000000000;;	    echo "message:$message"
0000000000000000000000000000000000000000;;	    echo "has not:$match"
0000000000000000000000000000000000000000;;	    return 0
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Returns true if the required resource is part of supported resources.
0000000000000000000000000000000000000000;;	# Expects env vars:
0000000000000000000000000000000000000000;;	#   SUPPORTED_RESOURCES: Array of all resources supported by the apiserver. "*"
0000000000000000000000000000000000000000;;	#   means it supports all resources. For ex: ("*") or ("rc" "*") both mean that
0000000000000000000000000000000000000000;;	#   all resources are supported.
0000000000000000000000000000000000000000;;	#   $1: Name of the resource to be tested.
0000000000000000000000000000000000000000;;	kube::test::if_supports_resource() {
0000000000000000000000000000000000000000;;	  SUPPORTED_RESOURCES=${SUPPORTED_RESOURCES:-""}
0000000000000000000000000000000000000000;;	  REQUIRED_RESOURCE=${1:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for r in "${SUPPORTED_RESOURCES[@]}"; do
0000000000000000000000000000000000000000;;	    if [[ "${r}" == "*" || "${r}" == "${REQUIRED_RESOURCE}" ]]; then
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::version::object_to_file() {
0000000000000000000000000000000000000000;;	  name=$1
0000000000000000000000000000000000000000;;	  flags=${2:-""}
0000000000000000000000000000000000000000;;	  file=$3
0000000000000000000000000000000000000000;;	  kubectl version $flags | grep "$name Version:" | sed -e s/"$name Version: version.Info{"/'/' -e s/'}'/'/' -e s/', '/','/g -e s/':'/'=/g' -e s/'"'/""/g | tr , '\n' > "${file}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::version::json_object_to_file() {
0000000000000000000000000000000000000000;;	  flags=$1
0000000000000000000000000000000000000000;;	  file=$2
0000000000000000000000000000000000000000;;	  kubectl version $flags --output json | sed -e s/'\"'/''/g -e s/'}'/''/g -e s/'{'/''/g -e s/'clientVersion:'/'clientVersion:,'/ -e s/'serverVersion:'/'serverVersion:,'/ | tr , '\n' > "${file}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::version::json_client_server_object_to_file() {
0000000000000000000000000000000000000000;;	  flags=$1
0000000000000000000000000000000000000000;;	  name=$2
0000000000000000000000000000000000000000;;	  file=$3
0000000000000000000000000000000000000000;;	  kubectl version $flags --output json | jq -r ".${name}" | sed -e s/'\"'/''/g -e s/'}'/''/g -e s/'{'/''/g -e /^$/d -e s/','/''/g  -e s/':'/'='/g > "${file}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::version::yaml_object_to_file() {
0000000000000000000000000000000000000000;;	  flags=$1
0000000000000000000000000000000000000000;;	  file=$2
0000000000000000000000000000000000000000;;	  kubectl version $flags --output yaml | sed -e s/' '/''/g -e s/'\"'/''/g -e /^$/d > "${file}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::version::diff_assert() {
0000000000000000000000000000000000000000;;	  local original=$1
0000000000000000000000000000000000000000;;	  local comparator=${2:-"eq"}
0000000000000000000000000000000000000000;;	  local latest=$3
0000000000000000000000000000000000000000;;	  local diff_msg=${4:-""}
0000000000000000000000000000000000000000;;	  local res=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ ! -f $original ]; then
0000000000000000000000000000000000000000;;	        echo ${bold}${red}
0000000000000000000000000000000000000000;;	        echo "FAIL! ${diff_msg}"
0000000000000000000000000000000000000000;;	        echo "the file '${original}' does not exit"
0000000000000000000000000000000000000000;;	        echo ${reset}${red}
0000000000000000000000000000000000000000;;	        caller
0000000000000000000000000000000000000000;;	        echo ${reset}
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ ! -f $latest ]; then
0000000000000000000000000000000000000000;;	        echo ${bold}${red}
0000000000000000000000000000000000000000;;	        echo "FAIL! ${diff_msg}"
0000000000000000000000000000000000000000;;	        echo "the file '${latest}' does not exit"
0000000000000000000000000000000000000000;;	        echo ${reset}${red}
0000000000000000000000000000000000000000;;	        caller
0000000000000000000000000000000000000000;;	        echo ${reset}
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  sort ${original} > "${original}.sorted"
0000000000000000000000000000000000000000;;	  sort ${latest} > "${latest}.sorted"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ "$comparator" == "eq" ]; then
0000000000000000000000000000000000000000;;	    if [ "$(diff -iwB ${original}.sorted ${latest}.sorted)" == "" ] ; then
0000000000000000000000000000000000000000;;	        echo -n ${green}
0000000000000000000000000000000000000000;;	        echo "Successful: ${diff_msg}"
0000000000000000000000000000000000000000;;	        echo -n ${reset}
0000000000000000000000000000000000000000;;	        return 0
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        echo ${bold}${red}
0000000000000000000000000000000000000000;;	        echo "FAIL! ${diff_msg}"
0000000000000000000000000000000000000000;;	        echo "  Expected: "
0000000000000000000000000000000000000000;;	        echo "$(cat ${original})"
0000000000000000000000000000000000000000;;	        echo "  Got: "
0000000000000000000000000000000000000000;;	        echo "$(cat ${latest})"
0000000000000000000000000000000000000000;;	        echo ${reset}${red}
0000000000000000000000000000000000000000;;	        caller
0000000000000000000000000000000000000000;;	        echo ${reset}
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    if [ ! -z "$(diff -iwB ${original}.sorted ${latest}.sorted)" ] ; then
0000000000000000000000000000000000000000;;	        echo -n ${green}
0000000000000000000000000000000000000000;;	        echo "Successful: ${diff_msg}"
0000000000000000000000000000000000000000;;	        echo -n ${reset}
0000000000000000000000000000000000000000;;	        return 0
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        echo ${bold}${red}
0000000000000000000000000000000000000000;;	        echo "FAIL! ${diff_msg}"
0000000000000000000000000000000000000000;;	        echo "  Expected: "
0000000000000000000000000000000000000000;;	        echo "$(cat ${original})"
0000000000000000000000000000000000000000;;	        echo "  Got: "
0000000000000000000000000000000000000000;;	        echo "$(cat ${latest})"
0000000000000000000000000000000000000000;;	        echo ${reset}${red}
0000000000000000000000000000000000000000;;	        caller
0000000000000000000000000000000000000000;;	        echo ${reset}
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
