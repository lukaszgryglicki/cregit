0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Script to test cluster/update-storage-objects.sh works as expected.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The api version in which objects are currently stored in etcd.
0000000000000000000000000000000000000000;;	KUBE_OLD_API_VERSION=${KUBE_OLD_API_VERSION:-"v1"}
0000000000000000000000000000000000000000;;	# The api version in which our etcd objects should be converted to.
0000000000000000000000000000000000000000;;	# The new api version
0000000000000000000000000000000000000000;;	KUBE_NEW_API_VERSION=${KUBE_NEW_API_VERSION:-"v1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_OLD_STORAGE_VERSIONS=${KUBE_OLD_STORAGE_VERSIONS:-""}
0000000000000000000000000000000000000000;;	KUBE_NEW_STORAGE_VERSIONS=${KUBE_NEW_STORAGE_VERSIONS:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	STORAGE_BACKEND_ETCD2="etcd2"
0000000000000000000000000000000000000000;;	STORAGE_BACKEND_ETCD3="etcd3"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_STORAGE_MEDIA_TYPE_JSON="application/json"
0000000000000000000000000000000000000000;;	KUBE_STORAGE_MEDIA_TYPE_PROTOBUF="application/vnd.kubernetes.protobuf"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	ETCD_HOST=${ETCD_HOST:-127.0.0.1}
0000000000000000000000000000000000000000;;	ETCD_PORT=${ETCD_PORT:-2379}
0000000000000000000000000000000000000000;;	ETCD_PREFIX=${ETCD_PREFIX:-randomPrefix}
0000000000000000000000000000000000000000;;	API_PORT=${API_PORT:-8080}
0000000000000000000000000000000000000000;;	API_HOST=${API_HOST:-127.0.0.1}
0000000000000000000000000000000000000000;;	KUBE_API_VERSIONS=""
0000000000000000000000000000000000000000;;	RUNTIME_CONFIG=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	ETCDCTL=$(which etcdctl)
0000000000000000000000000000000000000000;;	KUBECTL="${KUBE_OUTPUT_HOSTBIN}/kubectl"
0000000000000000000000000000000000000000;;	UPDATE_ETCD_OBJECTS_SCRIPT="${KUBE_ROOT}/cluster/update-storage-objects.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function startApiServer() {
0000000000000000000000000000000000000000;;	  local storage_backend=${1:-"${STORAGE_BACKEND_ETCD2}"}
0000000000000000000000000000000000000000;;	  local storage_versions=${2:-""}
0000000000000000000000000000000000000000;;	  local storage_media_type=${3:-""}
0000000000000000000000000000000000000000;;	  kube::log::status "Starting kube-apiserver with KUBE_API_VERSIONS: ${KUBE_API_VERSIONS}"
0000000000000000000000000000000000000000;;	  kube::log::status "                           and storage-backend: ${storage_backend}"
0000000000000000000000000000000000000000;;	  kube::log::status "                        and storage-media-type: ${storage_media_type}"
0000000000000000000000000000000000000000;;	  kube::log::status "                            and runtime-config: ${RUNTIME_CONFIG}"
0000000000000000000000000000000000000000;;	  kube::log::status "                 and storage-version overrides: ${storage_versions}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  KUBE_API_VERSIONS="${KUBE_API_VERSIONS}" \
0000000000000000000000000000000000000000;;	    "${KUBE_OUTPUT_HOSTBIN}/kube-apiserver" \
0000000000000000000000000000000000000000;;	    --insecure-bind-address="${API_HOST}" \
0000000000000000000000000000000000000000;;	    --bind-address="${API_HOST}" \
0000000000000000000000000000000000000000;;	    --insecure-port="${API_PORT}" \
0000000000000000000000000000000000000000;;	    --storage-backend="${storage_backend}" \
0000000000000000000000000000000000000000;;	    --etcd-servers="http://${ETCD_HOST}:${ETCD_PORT}" \
0000000000000000000000000000000000000000;;	    --etcd-prefix="/${ETCD_PREFIX}" \
0000000000000000000000000000000000000000;;	    --runtime-config="${RUNTIME_CONFIG}" \
0000000000000000000000000000000000000000;;	    --cert-dir="${TMPDIR:-/tmp/}" \
0000000000000000000000000000000000000000;;	    --service-cluster-ip-range="10.0.0.0/24" \
0000000000000000000000000000000000000000;;	    --storage-versions="${storage_versions}" \
0000000000000000000000000000000000000000;;	    --storage-media-type=${storage_media_type} 1>&2 &
0000000000000000000000000000000000000000;;	  APISERVER_PID=$!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # url, prefix, wait, times
0000000000000000000000000000000000000000;;	  kube::util::wait_for_url "http://${API_HOST}:${API_PORT}/healthz" "apiserver: " 1 120
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function killApiServer() {
0000000000000000000000000000000000000000;;	  kube::log::status "Killing api server"
0000000000000000000000000000000000000000;;	  if [[ -n ${APISERVER_PID-} ]]; then
0000000000000000000000000000000000000000;;	    kill ${APISERVER_PID} 1>&2 2>/dev/null
0000000000000000000000000000000000000000;;	    wait ${APISERVER_PID} || true
0000000000000000000000000000000000000000;;	    kube::log::status "api server exited"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  unset APISERVER_PID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function cleanup() {
0000000000000000000000000000000000000000;;	  killApiServer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::etcd::cleanup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Clean up complete"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	trap cleanup EXIT SIGINT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	make -C "${KUBE_ROOT}" WHAT=cmd/kube-apiserver
0000000000000000000000000000000000000000;;	make -C "${KUBE_ROOT}" WHAT=cluster/images/etcd/attachlease
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::etcd::start
0000000000000000000000000000000000000000;;	echo "${ETCD_VERSION}/${STORAGE_BACKEND_ETCD2}" > "${ETCD_DIR}/version.txt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### BEGIN TEST DEFINITION CUSTOMIZATION ###
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# source_file,resource,namespace,name,old_version,new_version
0000000000000000000000000000000000000000;;	tests=(
0000000000000000000000000000000000000000;;	examples/persistent-volume-provisioning/rbd/rbd-storage-class.yaml,storageclasses,,slow,v1beta1,v1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_OLD_API_VERSION="storage.k8s.io/v1beta1,extensions/v1beta1"
0000000000000000000000000000000000000000;;	KUBE_NEW_API_VERSION="storage.k8s.io/v1,extensions/v1beta1"
0000000000000000000000000000000000000000;;	KUBE_OLD_STORAGE_VERSIONS="storage.k8s.io/v1beta1"
0000000000000000000000000000000000000000;;	KUBE_NEW_STORAGE_VERSIONS="storage.k8s.io/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### END TEST DEFINITION CUSTOMIZATION ###
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	# Step 1: Start a server which supports both the old and new api versions,
0000000000000000000000000000000000000000;;	# but KUBE_OLD_API_VERSION is the latest (storage) version.
0000000000000000000000000000000000000000;;	# Additionally use KUBE_STORAGE_MEDIA_TYPE_JSON for storage encoding.
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	KUBE_API_VERSIONS="v1,${KUBE_OLD_API_VERSION},${KUBE_NEW_API_VERSION}"
0000000000000000000000000000000000000000;;	RUNTIME_CONFIG="api/all=false,api/v1=true,${KUBE_OLD_API_VERSION}=true,${KUBE_NEW_API_VERSION}=true"
0000000000000000000000000000000000000000;;	startApiServer ${STORAGE_BACKEND_ETCD2} ${KUBE_OLD_STORAGE_VERSIONS} ${KUBE_STORAGE_MEDIA_TYPE_JSON}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Create object(s)
0000000000000000000000000000000000000000;;	for test in ${tests[@]}; do
0000000000000000000000000000000000000000;;	  IFS=',' read -ra test_data <<<"$test"
0000000000000000000000000000000000000000;;	  source_file=${test_data[0]}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  kube::log::status "Creating ${source_file}"
0000000000000000000000000000000000000000;;	  ${KUBECTL} create -f "${source_file}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Verify that the storage version is the old version
0000000000000000000000000000000000000000;;	  resource=${test_data[1]}
0000000000000000000000000000000000000000;;	  namespace=${test_data[2]}
0000000000000000000000000000000000000000;;	  name=${test_data[3]}
0000000000000000000000000000000000000000;;	  old_storage_version=${test_data[4]}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ -n "${namespace}" ]; then
0000000000000000000000000000000000000000;;	    namespace="${namespace}/"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  kube::log::status "Verifying ${resource}/${namespace}${name} has storage version ${old_storage_version} in etcd"
0000000000000000000000000000000000000000;;	  curl -s http://${ETCD_HOST}:${ETCD_PORT}/v2/keys/${ETCD_PREFIX}/${resource}/${namespace}${name} | grep ${old_storage_version}
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	killApiServer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	# Step 2: Perform etcd2 -> etcd3 migration.
0000000000000000000000000000000000000000;;	# We always perform offline migration, so we need to stop etcd.
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::etcd::stop
0000000000000000000000000000000000000000;;	TARGET_STORAGE="etcd3" \
0000000000000000000000000000000000000000;;	  TARGET_VERSION="3.0.17" \
0000000000000000000000000000000000000000;;	  DATA_DIRECTORY="${ETCD_DIR}" \
0000000000000000000000000000000000000000;;	  ETCD=$(which etcd) \
0000000000000000000000000000000000000000;;	  ETCDCTL=$(which etcdctl) \
0000000000000000000000000000000000000000;;	  ATTACHLEASE="${KUBE_OUTPUT_HOSTBIN}/attachlease" \
0000000000000000000000000000000000000000;;	  DO_NOT_MOVE_BINARIES="true" \
0000000000000000000000000000000000000000;;	  ${KUBE_ROOT}/cluster/images/etcd/migrate-if-needed.sh
0000000000000000000000000000000000000000;;	kube::etcd::start
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	# Step 3: Start a server which supports both the old and new api versions,
0000000000000000000000000000000000000000;;	# but KUBE_NEW_API_VERSION is the latest (storage) version.
0000000000000000000000000000000000000000;;	# Still use KUBE_STORAGE_MEDIA_TYPE_JSON for storage encoding.
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_API_VERSIONS="v1,${KUBE_NEW_API_VERSION},${KUBE_OLD_API_VERSION}"
0000000000000000000000000000000000000000;;	RUNTIME_CONFIG="api/all=false,api/v1=true,${KUBE_OLD_API_VERSION}=true,${KUBE_NEW_API_VERSION}=true"
0000000000000000000000000000000000000000;;	startApiServer ${STORAGE_BACKEND_ETCD3} ${KUBE_NEW_STORAGE_VERSIONS} ${KUBE_STORAGE_MEDIA_TYPE_JSON}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Update etcd objects, so that will now be stored in the new api version.
0000000000000000000000000000000000000000;;	kube::log::status "Updating storage versions in etcd"
0000000000000000000000000000000000000000;;	${UPDATE_ETCD_OBJECTS_SCRIPT}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Verify that the storage version was changed in etcd
0000000000000000000000000000000000000000;;	for test in ${tests[@]}; do
0000000000000000000000000000000000000000;;	  IFS=',' read -ra test_data <<<"$test"
0000000000000000000000000000000000000000;;	  resource=${test_data[1]}
0000000000000000000000000000000000000000;;	  namespace=${test_data[2]}
0000000000000000000000000000000000000000;;	  name=${test_data[3]}
0000000000000000000000000000000000000000;;	  new_storage_version=${test_data[5]}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [ -n "${namespace}" ]; then
0000000000000000000000000000000000000000;;	    namespace="${namespace}/"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  kube::log::status "Verifying ${resource}/${namespace}${name} has updated storage version ${new_storage_version} in etcd"
0000000000000000000000000000000000000000;;	  ETCDCTL_API=3 ${ETCDCTL} --endpoints="${ETCD_HOST}:${ETCD_PORT}" get "/${ETCD_PREFIX}/${resource}/${namespace}${name}" | grep ${new_storage_version}
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	killApiServer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	# Step 4 : Start a server which supports only the new api version.
0000000000000000000000000000000000000000;;	# However, change storage encoding to KUBE_STORAGE_MEDIA_TYPE_PROTOBUF.
0000000000000000000000000000000000000000;;	#######################################################
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_API_VERSIONS="v1,${KUBE_NEW_API_VERSION}"
0000000000000000000000000000000000000000;;	RUNTIME_CONFIG="api/all=false,api/v1=true,${KUBE_NEW_API_VERSION}=true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This seems to reduce flakiness.
0000000000000000000000000000000000000000;;	sleep 1
0000000000000000000000000000000000000000;;	startApiServer ${STORAGE_BACKEND_ETCD3} ${KUBE_NEW_STORAGE_VERSIONS} ${KUBE_STORAGE_MEDIA_TYPE_PROTOBUF}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	for test in ${tests[@]}; do
0000000000000000000000000000000000000000;;	  IFS=',' read -ra test_data <<<"$test"
0000000000000000000000000000000000000000;;	  resource=${test_data[1]}
0000000000000000000000000000000000000000;;	  namespace=${test_data[2]}
0000000000000000000000000000000000000000;;	  name=${test_data[3]}
0000000000000000000000000000000000000000;;	  namespace_flag=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Verify that the server is able to read the object.
0000000000000000000000000000000000000000;;	  if [ -n "${namespace}" ]; then
0000000000000000000000000000000000000000;;	    namespace_flag="--namespace=${namespace}"
0000000000000000000000000000000000000000;;	    namespace="${namespace}/"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  kube::log::status "Verifying we can retrieve ${resource}/${namespace}${name} via kubectl"
0000000000000000000000000000000000000000;;	  # We have to remove the cached discovery information about the old version; otherwise,
0000000000000000000000000000000000000000;;	  # the 'kubectl get' will use that and fail to find the resource.
0000000000000000000000000000000000000000;;	  rm -rf ${HOME}/.kube/cache/discovery/localhost_8080/${KUBE_OLD_STORAGE_VERSIONS}
0000000000000000000000000000000000000000;;	  ${KUBECTL} get ${namespace_flag} ${resource}/${name}
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	killApiServer
