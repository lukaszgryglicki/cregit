0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This script uploads metadata and test results to Google Cloud Storage, in the
0000000000000000000000000000000000000000;;	# location indicated by JENKINS_GCS_LOGS_PATH. By default, we use the Google
0000000000000000000000000000000000000000;;	# kubernetes-jenkins bucket.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The script looks for one of two environment variables to be set:
0000000000000000000000000000000000000000;;	#   JENKINS_BUILD_STARTED: set to a nonempty string to upload version
0000000000000000000000000000000000000000;;	#     information to 'started.json'. The value of the variable is not
0000000000000000000000000000000000000000;;	#     currently used.
0000000000000000000000000000000000000000;;	#   JENKINS_BUILD_FINISHED: set to the Jenkins build result to upload the build
0000000000000000000000000000000000000000;;	#     result to 'finished.json', any test artifacts, and update the
0000000000000000000000000000000000000000;;	#     'latest-build.txt' file pointer. Since this script uses gsutil directly,
0000000000000000000000000000000000000000;;	#     it's a bit faster at uploading large numbers of files than the GCS Jenkins
0000000000000000000000000000000000000000;;	#     plugin. It also makes use of gsutil's gzip functionality.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Note: for magicfile support to work correctly, the "file" utility must be
0000000000000000000000000000000000000000;;	# installed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TODO(rmmh): rewrite this script in Python so we can actually test it!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ -n "${JENKINS_BUILD_STARTED:-}" && -n "${JENKINS_BUILD_FINISHED:-}" ]]; then
0000000000000000000000000000000000000000;;	  echo "Error: JENKINS_BUILD_STARTED and JENKINS_BUILD_FINISHED should not both be set!"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ ! ${JENKINS_UPLOAD_TO_GCS:-y} =~ ^[yY]$ ]]; then
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Attempt to determine if we're running against a repo other than
0000000000000000000000000000000000000000;;	# kubernetes/kubernetes to determine whether to place PR logs in a different
0000000000000000000000000000000000000000;;	# location.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# In the current CI system, the tracked repo is named remote. This is not true
0000000000000000000000000000000000000000;;	# in general for most devs, where origin and upstream are more common.
0000000000000000000000000000000000000000;;	GCS_SUBDIR=""
0000000000000000000000000000000000000000;;	readonly remote_git_repo=$(git config --get remote.remote.url | sed 's:.*github.com/::' || true)
0000000000000000000000000000000000000000;;	if [[ -n "${remote_git_repo}" ]]; then
0000000000000000000000000000000000000000;;	  case "${remote_git_repo}" in
0000000000000000000000000000000000000000;;	    # main repo: nothing extra
0000000000000000000000000000000000000000;;	    kubernetes/kubernetes) GCS_SUBDIR="" ;;
0000000000000000000000000000000000000000;;	    # a different repo on the k8s org: just the repo name (strip kubernetes/)
0000000000000000000000000000000000000000;;	    kubernetes/*) GCS_SUBDIR="${remote_git_repo#kubernetes/}/" ;;
0000000000000000000000000000000000000000;;	    # any other repo: ${org}_${repo} (replace / with _)
0000000000000000000000000000000000000000;;	    *) GCS_SUBDIR="${remote_git_repo/\//_}/" ;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	  if [[ "${remote_git_repo}" != "kubernetes/kubernetes" ]]; then
0000000000000000000000000000000000000000;;	    # also store the repo in started.json, so Gubernator can link it properly.
0000000000000000000000000000000000000000;;	    export BUILD_METADATA_REPO="${remote_git_repo}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ ${JOB_NAME} =~ -pull- ]]; then
0000000000000000000000000000000000000000;;	  : ${JENKINS_GCS_LOGS_PATH:="gs://kubernetes-jenkins/pr-logs/pull/${GCS_SUBDIR}${ghprbPullId:-unknown}"}
0000000000000000000000000000000000000000;;	  : ${JENKINS_GCS_LATEST_PATH:="gs://kubernetes-jenkins/pr-logs/directory"}
0000000000000000000000000000000000000000;;	  : ${JENKINS_GCS_LOGS_INDIRECT:="gs://kubernetes-jenkins/pr-logs/directory/${JOB_NAME}"}
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  : ${JENKINS_GCS_LOGS_PATH:="gs://kubernetes-jenkins/logs"}
0000000000000000000000000000000000000000;;	  : ${JENKINS_GCS_LATEST_PATH:="gs://kubernetes-jenkins/logs"}
0000000000000000000000000000000000000000;;	  : ${JENKINS_GCS_LOGS_INDIRECT:=""}
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	readonly artifacts_path="${WORKSPACE}/_artifacts"
0000000000000000000000000000000000000000;;	readonly gcs_job_path="${JENKINS_GCS_LOGS_PATH}/${JOB_NAME}"
0000000000000000000000000000000000000000;;	readonly gcs_build_path="${gcs_job_path}/${BUILD_NUMBER}"
0000000000000000000000000000000000000000;;	readonly gcs_latest_path="${JENKINS_GCS_LATEST_PATH}/${JOB_NAME}"
0000000000000000000000000000000000000000;;	readonly gcs_indirect_path="${JENKINS_GCS_LOGS_INDIRECT}"
0000000000000000000000000000000000000000;;	readonly gcs_acl="public-read"
0000000000000000000000000000000000000000;;	readonly results_url=${gcs_build_path//"gs:/"/"https://console.cloud.google.com/storage/browser"}
0000000000000000000000000000000000000000;;	readonly timestamp=$(date +%s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#########################################################################
0000000000000000000000000000000000000000;;	# $0 is called from different contexts so figure out where kubernetes is.
0000000000000000000000000000000000000000;;	# Sets non-exported global kubernetes_base_path and defaults to "."
0000000000000000000000000000000000000000;;	function set_kubernetes_base_path () {
0000000000000000000000000000000000000000;;	  for kubernetes_base_path in kubernetes go/src/k8s.io/kubernetes .; do
0000000000000000000000000000000000000000;;	    # Pick a canonical item to find in a kubernetes tree which could be a
0000000000000000000000000000000000000000;;	    # raw source tree or an expanded tarball.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    [[ -f ${kubernetes_base_path}/cluster/common.sh ]] && break
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#########################################################################
0000000000000000000000000000000000000000;;	# Try to discover the kubernetes version.
0000000000000000000000000000000000000000;;	# prints version
0000000000000000000000000000000000000000;;	function find_version() {
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	  # Where are we?
0000000000000000000000000000000000000000;;	  # This could be set in the global scope at some point if we need to 
0000000000000000000000000000000000000000;;	  # discover the kubernetes path elsewhere.
0000000000000000000000000000000000000000;;	  set_kubernetes_base_path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cd ${kubernetes_base_path}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -e "version" ]]; then
0000000000000000000000000000000000000000;;	    cat version
0000000000000000000000000000000000000000;;	  elif [[ -e "hack/lib/version.sh" ]]; then
0000000000000000000000000000000000000000;;	    export KUBE_ROOT="."
0000000000000000000000000000000000000000;;	    source "hack/lib/version.sh"
0000000000000000000000000000000000000000;;	    kube::version::get_version_vars
0000000000000000000000000000000000000000;;	    echo "${KUBE_GIT_VERSION-}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    # Last resort from the started.json
0000000000000000000000000000000000000000;;	    gsutil cat ${gcs_build_path}/started.json 2>/dev/null |\
0000000000000000000000000000000000000000;;	     sed -n 's/ *"version": *"\([^"]*\)",*/\1/p'
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Output started.json. Use test function below!
0000000000000000000000000000000000000000;;	function print_started() {
0000000000000000000000000000000000000000;;	  local metadata_keys=$(compgen -e | grep ^BUILD_METADATA_)
0000000000000000000000000000000000000000;;	  echo "{"
0000000000000000000000000000000000000000;;	  echo "    \"version\": \"${version}\","  # TODO(fejta): retire
0000000000000000000000000000000000000000;;	  echo "    \"job-version\": \"${version}\","
0000000000000000000000000000000000000000;;	  echo "    \"timestamp\": ${timestamp},"
0000000000000000000000000000000000000000;;	  if [[ -n "${metadata_keys}" ]]; then
0000000000000000000000000000000000000000;;	    # Any exported variables of the form BUILD_METADATA_KEY=VALUE
0000000000000000000000000000000000000000;;	    # will be available as started["metadata"][KEY.lower()].
0000000000000000000000000000000000000000;;	    echo "    \"metadata\": {"
0000000000000000000000000000000000000000;;	    local sep=""  # leading commas are easy to track
0000000000000000000000000000000000000000;;	    for env_var in $metadata_keys; do
0000000000000000000000000000000000000000;;	      local var_upper="${env_var#BUILD_METADATA_}"
0000000000000000000000000000000000000000;;	      echo "        $sep\"${var_upper,,}\": \"${!env_var}\""
0000000000000000000000000000000000000000;;	      sep=","
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	    echo "    },"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo "    \"jenkins-node\": \"${NODE_NAME:-}\""
0000000000000000000000000000000000000000;;	  echo "}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Use this to test changes to print_started.
0000000000000000000000000000000000000000;;	if [[ -n "${TEST_STARTED_JSON:-}" ]]; then
0000000000000000000000000000000000000000;;	  version=$(find_version)
0000000000000000000000000000000000000000;;	  cat <(print_started) | jq .
0000000000000000000000000000000000000000;;	  exit
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function upload_version() {
0000000000000000000000000000000000000000;;	  local -r version=$(find_version)
0000000000000000000000000000000000000000;;	  local upload_attempt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo -n 'Run starting at '; date -d "@${timestamp}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -n "${version}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Found Kubernetes version: ${version}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Could not find Kubernetes version"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local -r json_file="${gcs_build_path}/started.json"
0000000000000000000000000000000000000000;;	  for upload_attempt in {1..3}; do
0000000000000000000000000000000000000000;;	    echo "Uploading version to: ${json_file} (attempt ${upload_attempt})"
0000000000000000000000000000000000000000;;	    gsutil -q -h "Content-Type:application/json" cp -a "${gcs_acl}" <(print_started) "${json_file}" || continue
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#########################################################################
0000000000000000000000000000000000000000;;	# Maintain a single file storing the full build version, Jenkins' job number
0000000000000000000000000000000000000000;;	# build state.  Limit its size so it does not grow unbounded.
0000000000000000000000000000000000000000;;	# This is primarily used for and by the
0000000000000000000000000000000000000000;;	# github.com/kubernetes/release/find_green_build tool.
0000000000000000000000000000000000000000;;	# @param build_result - the state of the build
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	function update_job_result_cache() {
0000000000000000000000000000000000000000;;	  local -r build_result=$1
0000000000000000000000000000000000000000;;	  local -r version=$(find_version)
0000000000000000000000000000000000000000;;	  local -r job_results=${gcs_job_path}/jobResultsCache.json
0000000000000000000000000000000000000000;;	  local -r tmp_results="${WORKSPACE}/_tmp/jobResultsCache.tmp"
0000000000000000000000000000000000000000;;	  # TODO: This constraint is insufficient.  The boundary for secondary
0000000000000000000000000000000000000000;;	  #       job cache should be date based on the last primary build.
0000000000000000000000000000000000000000;;	  #       The issue is we are trying to find a matched green set of results
0000000000000000000000000000000000000000;;	  #       at a given hash, but all of the jobs run at wildly different lengths.
0000000000000000000000000000000000000000;;	  local -r cache_size=300
0000000000000000000000000000000000000000;;	  local upload_attempt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -n "${version}" ]]; then
0000000000000000000000000000000000000000;;	    echo "Found Kubernetes version: ${version}"
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "Could not find Kubernetes version"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  mkdir -p ${tmp_results%/*}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Construct a valid json file
0000000000000000000000000000000000000000;;	  echo "[" > ${tmp_results}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for upload_attempt in $(seq 3); do
0000000000000000000000000000000000000000;;	    echo "Copying ${job_results} to ${tmp_results} (attempt ${upload_attempt})"
0000000000000000000000000000000000000000;;	    # The sed construct below is stripping out only the "version" lines
0000000000000000000000000000000000000000;;	    # and then ensuring there's a single comma at the end of the line.
0000000000000000000000000000000000000000;;	    gsutil -q cat ${job_results} 2>&- |\
0000000000000000000000000000000000000000;;	     sed -n 's/^\({"version".*}\),*/\1,/p' |\
0000000000000000000000000000000000000000;;	     tail -${cache_size} >> ${tmp_results} || continue
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "{\"version\": \"${version}\", \"buildnumber\": \"${BUILD_NUMBER}\"," \
0000000000000000000000000000000000000000;;	       "\"result\": \"${build_result}\"}" >> ${tmp_results}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "]" >> ${tmp_results}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for upload_attempt in $(seq 3); do
0000000000000000000000000000000000000000;;	    echo "Copying ${tmp_results} to ${job_results} (attempt ${upload_attempt})"
0000000000000000000000000000000000000000;;	    gsutil -q -h "Content-Type:application/json" cp -a "${gcs_acl}" \
0000000000000000000000000000000000000000;;	           ${tmp_results} ${job_results} || continue
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  rm -f ${tmp_results}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function upload_artifacts_and_build_result() {
0000000000000000000000000000000000000000;;	  local -r build_result=$1
0000000000000000000000000000000000000000;;	  local upload_attempt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo -n 'Run finished at '; date -d "@${timestamp}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  for upload_attempt in {1..3}; do
0000000000000000000000000000000000000000;;	    echo "Uploading to ${gcs_build_path} (attempt ${upload_attempt})"
0000000000000000000000000000000000000000;;	    echo "Uploading build result: ${build_result}"
0000000000000000000000000000000000000000;;	    gsutil -q -h "Content-Type:application/json" cp -a "${gcs_acl}" <(
0000000000000000000000000000000000000000;;	      echo "{"
0000000000000000000000000000000000000000;;	      echo "    \"result\": \"${build_result}\","
0000000000000000000000000000000000000000;;	      echo "    \"timestamp\": ${timestamp}"
0000000000000000000000000000000000000000;;	      echo "}"
0000000000000000000000000000000000000000;;	    ) "${gcs_build_path}/finished.json" || continue
0000000000000000000000000000000000000000;;	    if [[ -d "${artifacts_path}" && -n $(ls -A "${artifacts_path}") ]]; then
0000000000000000000000000000000000000000;;	      echo "Uploading artifacts"
0000000000000000000000000000000000000000;;	      gsutil -m -q -o "GSUtil:use_magicfile=True" cp -a "${gcs_acl}" -r -c \
0000000000000000000000000000000000000000;;	        -z log,txt,xml "${artifacts_path}" "${gcs_build_path}/artifacts" || continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ -e "${WORKSPACE}/build-log.txt" ]]; then
0000000000000000000000000000000000000000;;	      echo "Uploading build log"
0000000000000000000000000000000000000000;;	      gsutil -q cp -Z -a "${gcs_acl}" "${WORKSPACE}/build-log.txt" "${gcs_build_path}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # For pull jobs, keep a canonical ordering for tools that want to examine
0000000000000000000000000000000000000000;;	    # the output.
0000000000000000000000000000000000000000;;	    if [[ "${gcs_indirect_path}" != "" ]]; then
0000000000000000000000000000000000000000;;	      echo "Writing ${gcs_build_path} to ${gcs_indirect_path}/${BUILD_NUMBER}.txt"
0000000000000000000000000000000000000000;;	      echo "${gcs_build_path}" | \
0000000000000000000000000000000000000000;;	        gsutil -q -h "Content-Type:text/plain" \
0000000000000000000000000000000000000000;;	          cp -a "${gcs_acl}" - "${gcs_indirect_path}/${BUILD_NUMBER}.txt" || continue
0000000000000000000000000000000000000000;;	      echo "Marking build ${BUILD_NUMBER} as the latest completed build for this PR"
0000000000000000000000000000000000000000;;	      echo "${BUILD_NUMBER}" | \
0000000000000000000000000000000000000000;;	        gsutil -q -h "Content-Type:text/plain" -h "Cache-Control:private, max-age=0, no-transform" \
0000000000000000000000000000000000000000;;	          cp -a "${gcs_acl}" - "${gcs_job_path}/latest-build.txt" || continue
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Mark this build as the latest completed.
0000000000000000000000000000000000000000;;	    echo "Marking build ${BUILD_NUMBER} as the latest completed build"
0000000000000000000000000000000000000000;;	    echo "${BUILD_NUMBER}" | \
0000000000000000000000000000000000000000;;	      gsutil -q -h "Content-Type:text/plain" -h "Cache-Control:private, max-age=0, no-transform" \
0000000000000000000000000000000000000000;;	        cp -a "${gcs_acl}" - "${gcs_latest_path}/latest-build.txt" || continue
0000000000000000000000000000000000000000;;	    break  # all uploads succeeded if we hit this point
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo -e "\n\n\n*** View logs and artifacts at ${results_url} ***\n\n"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ -z "${BOOTSTRAP_MIGRATION:-}" ]]; then
0000000000000000000000000000000000000000;;	  if [[ -n "${JENKINS_BUILD_STARTED:-}" ]]; then
0000000000000000000000000000000000000000;;	    upload_version
0000000000000000000000000000000000000000;;	  elif [[ -n "${JENKINS_BUILD_FINISHED:-}" ]]; then
0000000000000000000000000000000000000000;;	    upload_artifacts_and_build_result ${JENKINS_BUILD_FINISHED}
0000000000000000000000000000000000000000;;	    update_job_result_cache ${JENKINS_BUILD_FINISHED}
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    echo "ERROR: Called without JENKINS_BUILD_STARTED or JENKINS_BUILD_FINISHED set."
0000000000000000000000000000000000000000;;	    echo "ERROR: this should not happen"
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
