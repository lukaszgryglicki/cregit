0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/..
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This command builds and runs a local kubernetes cluster.
0000000000000000000000000000000000000000;;	# You may need to run this as root to allow kubelet to open docker's socket,
0000000000000000000000000000000000000000;;	# and to write the test CA in /var/run/kubernetes.
0000000000000000000000000000000000000000;;	DOCKER_OPTS=${DOCKER_OPTS:-""}
0000000000000000000000000000000000000000;;	DOCKER=(docker ${DOCKER_OPTS})
0000000000000000000000000000000000000000;;	DOCKERIZE_KUBELET=${DOCKERIZE_KUBELET:-""}
0000000000000000000000000000000000000000;;	ALLOW_PRIVILEGED=${ALLOW_PRIVILEGED:-""}
0000000000000000000000000000000000000000;;	ALLOW_SECURITY_CONTEXT=${ALLOW_SECURITY_CONTEXT:-""}
0000000000000000000000000000000000000000;;	PSP_ADMISSION=${PSP_ADMISSION:-""}
0000000000000000000000000000000000000000;;	NODE_ADMISSION=${NODE_ADMISSION:-""}
0000000000000000000000000000000000000000;;	RUNTIME_CONFIG=${RUNTIME_CONFIG:-""}
0000000000000000000000000000000000000000;;	KUBELET_AUTHORIZATION_WEBHOOK=${KUBELET_AUTHORIZATION_WEBHOOK:-""}
0000000000000000000000000000000000000000;;	KUBELET_AUTHENTICATION_WEBHOOK=${KUBELET_AUTHENTICATION_WEBHOOK:-""}
0000000000000000000000000000000000000000;;	POD_MANIFEST_PATH=${POD_MANIFEST_PATH:-"/var/run/kubernetes/static-pods"}
0000000000000000000000000000000000000000;;	KUBELET_FLAGS=${KUBELET_FLAGS:-""}
0000000000000000000000000000000000000000;;	# Name of the network plugin, eg: "kubenet"
0000000000000000000000000000000000000000;;	NET_PLUGIN=${NET_PLUGIN:-""}
0000000000000000000000000000000000000000;;	# Place the config files and binaries required by NET_PLUGIN in these directory,
0000000000000000000000000000000000000000;;	# eg: "/etc/cni/net.d" for config files, and "/opt/cni/bin" for binaries.
0000000000000000000000000000000000000000;;	CNI_CONF_DIR=${CNI_CONF_DIR:-""}
0000000000000000000000000000000000000000;;	CNI_BIN_DIR=${CNI_BIN_DIR:-""}
0000000000000000000000000000000000000000;;	SERVICE_CLUSTER_IP_RANGE=${SERVICE_CLUSTER_IP_RANGE:-10.0.0.0/24}
0000000000000000000000000000000000000000;;	FIRST_SERVICE_CLUSTER_IP=${FIRST_SERVICE_CLUSTER_IP:-10.0.0.1}
0000000000000000000000000000000000000000;;	# if enabled, must set CGROUP_ROOT
0000000000000000000000000000000000000000;;	CGROUPS_PER_QOS=${CGROUPS_PER_QOS:-true}
0000000000000000000000000000000000000000;;	# name of the cgroup driver, i.e. cgroupfs or systemd
0000000000000000000000000000000000000000;;	CGROUP_DRIVER=${CGROUP_DRIVER:-""}
0000000000000000000000000000000000000000;;	# owner of client certs, default to current user if not specified
0000000000000000000000000000000000000000;;	USER=${USER:-$(whoami)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# enables testing eviction scenarios locally.
0000000000000000000000000000000000000000;;	EVICTION_HARD=${EVICTION_HARD:-"memory.available<100Mi,nodefs.available<10%,nodefs.inodesFree<5%"}
0000000000000000000000000000000000000000;;	EVICTION_SOFT=${EVICTION_SOFT:-""}
0000000000000000000000000000000000000000;;	EVICTION_PRESSURE_TRANSITION_PERIOD=${EVICTION_PRESSURE_TRANSITION_PERIOD:-"1m"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This script uses docker0 (or whatever container bridge docker is currently using)
0000000000000000000000000000000000000000;;	# and we don't know the IP of the DNS pod to pass in as --cluster-dns.
0000000000000000000000000000000000000000;;	# To set this up by hand, set this flag and change DNS_SERVER_IP.
0000000000000000000000000000000000000000;;	# Note also that you need API_HOST (defined above) for correct DNS.
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_DNS=${KUBE_ENABLE_CLUSTER_DNS:-true}
0000000000000000000000000000000000000000;;	DNS_SERVER_IP=${KUBE_DNS_SERVER_IP:-10.0.0.10}
0000000000000000000000000000000000000000;;	DNS_DOMAIN=${KUBE_DNS_NAME:-"cluster.local"}
0000000000000000000000000000000000000000;;	KUBECTL=${KUBECTL:-cluster/kubectl.sh}
0000000000000000000000000000000000000000;;	WAIT_FOR_URL_API_SERVER=${WAIT_FOR_URL_API_SERVER:-10}
0000000000000000000000000000000000000000;;	ENABLE_DAEMON=${ENABLE_DAEMON:-false}
0000000000000000000000000000000000000000;;	HOSTNAME_OVERRIDE=${HOSTNAME_OVERRIDE:-"127.0.0.1"}
0000000000000000000000000000000000000000;;	CLOUD_PROVIDER=${CLOUD_PROVIDER:-""}
0000000000000000000000000000000000000000;;	CLOUD_CONFIG=${CLOUD_CONFIG:-""}
0000000000000000000000000000000000000000;;	FEATURE_GATES=${FEATURE_GATES:-"AllAlpha=false"}
0000000000000000000000000000000000000000;;	STORAGE_BACKEND=${STORAGE_BACKEND:-"etcd3"}
0000000000000000000000000000000000000000;;	# enable swagger ui
0000000000000000000000000000000000000000;;	ENABLE_SWAGGER_UI=${ENABLE_SWAGGER_UI:-false}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# enable kubernetes dashboard
0000000000000000000000000000000000000000;;	ENABLE_CLUSTER_DASHBOARD=${KUBE_ENABLE_CLUSTER_DASHBOARD:-false}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# enable audit log
0000000000000000000000000000000000000000;;	ENABLE_APISERVER_BASIC_AUDIT=${ENABLE_APISERVER_BASIC_AUDIT:-false}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# RBAC Mode options
0000000000000000000000000000000000000000;;	ALLOW_ANY_TOKEN=${ALLOW_ANY_TOKEN:-false}
0000000000000000000000000000000000000000;;	ENABLE_RBAC=${ENABLE_RBAC:-false}
0000000000000000000000000000000000000000;;	AUTHORIZATION_MODE=${AUTHORIZATION_MODE:-""}
0000000000000000000000000000000000000000;;	KUBECONFIG_TOKEN=${KUBECONFIG_TOKEN:-""}
0000000000000000000000000000000000000000;;	AUTH_ARGS=${AUTH_ARGS:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Install a default storage class (enabled by default)
0000000000000000000000000000000000000000;;	DEFAULT_STORAGE_CLASS=${KUBE_DEFAULT_STORAGE_CLASS:-true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# start the cache mutation detector by default so that cache mutators will be found
0000000000000000000000000000000000000000;;	KUBE_CACHE_MUTATION_DETECTOR="${KUBE_CACHE_MUTATION_DETECTOR:-true}"
0000000000000000000000000000000000000000;;	export KUBE_CACHE_MUTATION_DETECTOR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# panic the server on watch decode errors since they are considered coder mistakes
0000000000000000000000000000000000000000;;	KUBE_PANIC_WATCH_DECODE_ERROR="${KUBE_PANIC_WATCH_DECODE_ERROR:-true}"
0000000000000000000000000000000000000000;;	export KUBE_PANIC_WATCH_DECODE_ERROR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	ADMISSION_CONTROL_CONFIG_FILE=${ADMISSION_CONTROL_CONFIG_FILE:-""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# START_MODE can be 'all', 'kubeletonly', or 'nokubelet'
0000000000000000000000000000000000000000;;	START_MODE=${START_MODE:-"all"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A list of controllers to enable
0000000000000000000000000000000000000000;;	KUBE_CONTROLLERS="${KUBE_CONTROLLERS:-"*"}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# sanity check for OpenStack provider
0000000000000000000000000000000000000000;;	if [ "${CLOUD_PROVIDER}" == "openstack" ]; then
0000000000000000000000000000000000000000;;	    if [ "${CLOUD_CONFIG}" == "" ]; then
0000000000000000000000000000000000000000;;	        echo "Missing CLOUD_CONFIG env for OpenStack provider!"
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [ ! -f "${CLOUD_CONFIG}" ]; then
0000000000000000000000000000000000000000;;	        echo "Cloud config ${CLOUD_CONFIG} doesn't exist"
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ "$(id -u)" != "0" ]; then
0000000000000000000000000000000000000000;;	    echo "WARNING : This script MAY be run as root for docker socket / iptables functionality; if failures occur, retry as root." 2>&1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Stop right away if the build fails
0000000000000000000000000000000000000000;;	set -e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function usage {
0000000000000000000000000000000000000000;;	            echo "This script starts a local kube cluster. "
0000000000000000000000000000000000000000;;	            echo "Example 0: hack/local-up-cluster.sh -h  (this 'help' usage description)"
0000000000000000000000000000000000000000;;	            echo "Example 1: hack/local-up-cluster.sh -o _output/dockerized/bin/linux/amd64/ (run from docker output)"
0000000000000000000000000000000000000000;;	            echo "Example 2: hack/local-up-cluster.sh -O (auto-guess the bin path for your platform)"
0000000000000000000000000000000000000000;;	            echo "Example 3: hack/local-up-cluster.sh (build a local copy of the source)"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This function guesses where the existing cached binary build is for the `-O`
0000000000000000000000000000000000000000;;	# flag
0000000000000000000000000000000000000000;;	function guess_built_binary_path {
0000000000000000000000000000000000000000;;	  local hyperkube_path=$(kube::util::find-binary "hyperkube")
0000000000000000000000000000000000000000;;	  if [[ -z "${hyperkube_path}" ]]; then
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo -n "$(dirname "${hyperkube_path}")"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Allow user to supply the source directory.
0000000000000000000000000000000000000000;;	GO_OUT=${GO_OUT:-}
0000000000000000000000000000000000000000;;	while getopts "ho:O" OPTION
0000000000000000000000000000000000000000;;	do
0000000000000000000000000000000000000000;;	    case $OPTION in
0000000000000000000000000000000000000000;;	        o)
0000000000000000000000000000000000000000;;	            echo "skipping build"
0000000000000000000000000000000000000000;;	            GO_OUT="$OPTARG"
0000000000000000000000000000000000000000;;	            echo "using source $GO_OUT"
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        O)
0000000000000000000000000000000000000000;;	            GO_OUT=$(guess_built_binary_path)
0000000000000000000000000000000000000000;;	            if [ "$GO_OUT" == "" ]; then
0000000000000000000000000000000000000000;;	                echo "Could not guess the correct output directory to use."
0000000000000000000000000000000000000000;;	                exit 1
0000000000000000000000000000000000000000;;	            fi
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        h)
0000000000000000000000000000000000000000;;	            usage
0000000000000000000000000000000000000000;;	            exit
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        ?)
0000000000000000000000000000000000000000;;	            usage
0000000000000000000000000000000000000000;;	            exit
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ "x$GO_OUT" == "x" ]; then
0000000000000000000000000000000000000000;;	    make -C "${KUBE_ROOT}" WHAT="cmd/kubectl cmd/hyperkube"
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	    echo "skipped the build."
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function test_rkt {
0000000000000000000000000000000000000000;;	    if [[ -n "${RKT_PATH}" ]]; then
0000000000000000000000000000000000000000;;	      ${RKT_PATH} list 2> /dev/null 1> /dev/null
0000000000000000000000000000000000000000;;	      if [ "$?" != "0" ]; then
0000000000000000000000000000000000000000;;	        echo "Failed to successfully run 'rkt list', please verify that ${RKT_PATH} is the path of rkt binary."
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      rkt list 2> /dev/null 1> /dev/null
0000000000000000000000000000000000000000;;	      if [ "$?" != "0" ]; then
0000000000000000000000000000000000000000;;	        echo "Failed to successfully run 'rkt list', please verify that rkt is in \$PATH."
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Shut down anyway if there's an error.
0000000000000000000000000000000000000000;;	set +e
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	API_PORT=${API_PORT:-8080}
0000000000000000000000000000000000000000;;	API_SECURE_PORT=${API_SECURE_PORT:-6443}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# WARNING: For DNS to work on most setups you should export API_HOST as the docker0 ip address,
0000000000000000000000000000000000000000;;	API_HOST=${API_HOST:-localhost}
0000000000000000000000000000000000000000;;	API_HOST_IP=${API_HOST_IP:-"127.0.0.1"}
0000000000000000000000000000000000000000;;	API_BIND_ADDR=${API_BIND_ADDR:-"0.0.0.0"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBELET_HOST=${KUBELET_HOST:-"127.0.0.1"}
0000000000000000000000000000000000000000;;	# By default only allow CORS for requests on localhost
0000000000000000000000000000000000000000;;	API_CORS_ALLOWED_ORIGINS=${API_CORS_ALLOWED_ORIGINS:-/127.0.0.1(:[0-9]+)?$,/localhost(:[0-9]+)?$}
0000000000000000000000000000000000000000;;	KUBELET_PORT=${KUBELET_PORT:-10250}
0000000000000000000000000000000000000000;;	LOG_LEVEL=${LOG_LEVEL:-3}
0000000000000000000000000000000000000000;;	# Use to increase verbosity on particular files, e.g. LOG_SPEC=token_controller*=5,other_controller*=4
0000000000000000000000000000000000000000;;	LOG_SPEC=${LOG_SPEC:-""}
0000000000000000000000000000000000000000;;	LOG_DIR=${LOG_DIR:-"/tmp"}
0000000000000000000000000000000000000000;;	CONTAINER_RUNTIME=${CONTAINER_RUNTIME:-"docker"}
0000000000000000000000000000000000000000;;	CONTAINER_RUNTIME_ENDPOINT=${CONTAINER_RUNTIME_ENDPOINT:-""}
0000000000000000000000000000000000000000;;	IMAGE_SERVICE_ENDPOINT=${IMAGE_SERVICE_ENDPOINT:-""}
0000000000000000000000000000000000000000;;	ENABLE_CRI=${ENABLE_CRI:-"true"}
0000000000000000000000000000000000000000;;	RKT_PATH=${RKT_PATH:-""}
0000000000000000000000000000000000000000;;	RKT_STAGE1_IMAGE=${RKT_STAGE1_IMAGE:-""}
0000000000000000000000000000000000000000;;	CHAOS_CHANCE=${CHAOS_CHANCE:-0.0}
0000000000000000000000000000000000000000;;	CPU_CFS_QUOTA=${CPU_CFS_QUOTA:-true}
0000000000000000000000000000000000000000;;	ENABLE_HOSTPATH_PROVISIONER=${ENABLE_HOSTPATH_PROVISIONER:-"false"}
0000000000000000000000000000000000000000;;	CLAIM_BINDER_SYNC_PERIOD=${CLAIM_BINDER_SYNC_PERIOD:-"15s"} # current k8s default
0000000000000000000000000000000000000000;;	ENABLE_CONTROLLER_ATTACH_DETACH=${ENABLE_CONTROLLER_ATTACH_DETACH:-"true"} # current default
0000000000000000000000000000000000000000;;	KEEP_TERMINATED_POD_VOLUMES=${KEEP_TERMINATED_POD_VOLUMES:-"true"}
0000000000000000000000000000000000000000;;	# This is the default dir and filename where the apiserver will generate a self-signed cert
0000000000000000000000000000000000000000;;	# which should be able to be used as the CA to verify itself
0000000000000000000000000000000000000000;;	CERT_DIR=${CERT_DIR:-"/var/run/kubernetes"}
0000000000000000000000000000000000000000;;	ROOT_CA_FILE=${CERT_DIR}/server-ca.crt
0000000000000000000000000000000000000000;;	ROOT_CA_KEY=${CERT_DIR}/server-ca.key
0000000000000000000000000000000000000000;;	CLUSTER_SIGNING_CERT_FILE=${CLUSTER_SIGNING_CERT_FILE:-"${ROOT_CA_FILE}"}
0000000000000000000000000000000000000000;;	CLUSTER_SIGNING_KEY_FILE=${CLUSTER_SIGNING_KEY_FILE:-"${ROOT_CA_KEY}"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# name of the cgroup driver, i.e. cgroupfs or systemd
0000000000000000000000000000000000000000;;	if [[ ${CONTAINER_RUNTIME} == "docker" ]]; then
0000000000000000000000000000000000000000;;	  # default cgroup driver to match what is reported by docker to simplify local development
0000000000000000000000000000000000000000;;	  if [[ -z ${CGROUP_DRIVER} ]]; then
0000000000000000000000000000000000000000;;	    # match driver with docker runtime reported value (they must match)
0000000000000000000000000000000000000000;;	    CGROUP_DRIVER=$(docker info | grep "Cgroup Driver:" | cut -f3- -d' ')
0000000000000000000000000000000000000000;;	    echo "Kubelet cgroup driver defaulted to use: ${CGROUP_DRIVER}"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Ensure CERT_DIR is created for auto-generated crt/key and kubeconfig
0000000000000000000000000000000000000000;;	mkdir -p "${CERT_DIR}" &>/dev/null || sudo mkdir -p "${CERT_DIR}"
0000000000000000000000000000000000000000;;	CONTROLPLANE_SUDO=$(test -w "${CERT_DIR}" || echo "sudo -E")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function test_apiserver_off {
0000000000000000000000000000000000000000;;	    # For the common local scenario, fail fast if server is already running.
0000000000000000000000000000000000000000;;	    # this can happen if you run local-up-cluster.sh twice and kill etcd in between.
0000000000000000000000000000000000000000;;	    if [[ "${API_PORT}" -gt "0" ]]; then
0000000000000000000000000000000000000000;;	        curl --silent -g $API_HOST:$API_PORT
0000000000000000000000000000000000000000;;	        if [ ! $? -eq 0 ]; then
0000000000000000000000000000000000000000;;	            echo "API SERVER insecure port is free, proceeding..."
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	            echo "ERROR starting API SERVER, exiting. Some process on $API_HOST is serving already on $API_PORT"
0000000000000000000000000000000000000000;;	            exit 1
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    curl --silent -k -g $API_HOST:$API_SECURE_PORT
0000000000000000000000000000000000000000;;	    if [ ! $? -eq 0 ]; then
0000000000000000000000000000000000000000;;	        echo "API SERVER secure port is free, proceeding..."
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        echo "ERROR starting API SERVER, exiting. Some process on $API_HOST is serving already on $API_SECURE_PORT"
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function detect_binary {
0000000000000000000000000000000000000000;;	    # Detect the OS name/arch so that we can find our binary
0000000000000000000000000000000000000000;;	    case "$(uname -s)" in
0000000000000000000000000000000000000000;;	      Darwin)
0000000000000000000000000000000000000000;;	        host_os=darwin
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      Linux)
0000000000000000000000000000000000000000;;	        host_os=linux
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      *)
0000000000000000000000000000000000000000;;	        echo "Unsupported host OS.  Must be Linux or Mac OS X." >&2
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    case "$(uname -m)" in
0000000000000000000000000000000000000000;;	      x86_64*)
0000000000000000000000000000000000000000;;	        host_arch=amd64
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      i?86_64*)
0000000000000000000000000000000000000000;;	        host_arch=amd64
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      amd64*)
0000000000000000000000000000000000000000;;	        host_arch=amd64
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      aarch64*)
0000000000000000000000000000000000000000;;	        host_arch=arm64
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      arm64*)
0000000000000000000000000000000000000000;;	        host_arch=arm64
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      arm*)
0000000000000000000000000000000000000000;;	        host_arch=arm
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      i?86*)
0000000000000000000000000000000000000000;;	        host_arch=x86
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      s390x*)
0000000000000000000000000000000000000000;;	        host_arch=s390x
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      ppc64le*)
0000000000000000000000000000000000000000;;	        host_arch=ppc64le
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      *)
0000000000000000000000000000000000000000;;	        echo "Unsupported host arch. Must be x86_64, 386, arm, arm64, s390x or ppc64le." >&2
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	   GO_OUT="${KUBE_ROOT}/_output/local/bin/${host_os}/${host_arch}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	cleanup_dockerized_kubelet()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  if [[ -e $KUBELET_CIDFILE ]]; then
0000000000000000000000000000000000000000;;	    docker kill $(<$KUBELET_CIDFILE) > /dev/null
0000000000000000000000000000000000000000;;	    rm -f $KUBELET_CIDFILE
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	cleanup()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  echo "Cleaning up..."
0000000000000000000000000000000000000000;;	  # delete running images
0000000000000000000000000000000000000000;;	  # if [[ "${ENABLE_CLUSTER_DNS}" == true ]]; then
0000000000000000000000000000000000000000;;	  # Still need to figure why this commands throw an error: Error from server: client: etcd cluster is unavailable or misconfigured
0000000000000000000000000000000000000000;;	  #     ${KUBECTL} --namespace=kube-system delete service kube-dns
0000000000000000000000000000000000000000;;	  # And this one hang forever:
0000000000000000000000000000000000000000;;	  #     ${KUBECTL} --namespace=kube-system delete rc kube-dns-v10
0000000000000000000000000000000000000000;;	  # fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Check if the API server is still running
0000000000000000000000000000000000000000;;	  [[ -n "${APISERVER_PID-}" ]] && APISERVER_PIDS=$(pgrep -P ${APISERVER_PID} ; ps -o pid= -p ${APISERVER_PID})
0000000000000000000000000000000000000000;;	  [[ -n "${APISERVER_PIDS-}" ]] && sudo kill ${APISERVER_PIDS}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Check if the controller-manager is still running
0000000000000000000000000000000000000000;;	  [[ -n "${CTLRMGR_PID-}" ]] && CTLRMGR_PIDS=$(pgrep -P ${CTLRMGR_PID} ; ps -o pid= -p ${CTLRMGR_PID})
0000000000000000000000000000000000000000;;	  [[ -n "${CTLRMGR_PIDS-}" ]] && sudo kill ${CTLRMGR_PIDS}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -n "$DOCKERIZE_KUBELET" ]]; then
0000000000000000000000000000000000000000;;	    cleanup_dockerized_kubelet
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    # Check if the kubelet is still running
0000000000000000000000000000000000000000;;	    [[ -n "${KUBELET_PID-}" ]] && KUBELET_PIDS=$(pgrep -P ${KUBELET_PID} ; ps -o pid= -p ${KUBELET_PID})
0000000000000000000000000000000000000000;;	    [[ -n "${KUBELET_PIDS-}" ]] && sudo kill ${KUBELET_PIDS}
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Check if the proxy is still running
0000000000000000000000000000000000000000;;	  [[ -n "${PROXY_PID-}" ]] && PROXY_PIDS=$(pgrep -P ${PROXY_PID} ; ps -o pid= -p ${PROXY_PID})
0000000000000000000000000000000000000000;;	  [[ -n "${PROXY_PIDS-}" ]] && sudo kill ${PROXY_PIDS}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Check if the scheduler is still running
0000000000000000000000000000000000000000;;	  [[ -n "${SCHEDULER_PID-}" ]] && SCHEDULER_PIDS=$(pgrep -P ${SCHEDULER_PID} ; ps -o pid= -p ${SCHEDULER_PID})
0000000000000000000000000000000000000000;;	  [[ -n "${SCHEDULER_PIDS-}" ]] && sudo kill ${SCHEDULER_PIDS}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Check if the etcd is still running
0000000000000000000000000000000000000000;;	  [[ -n "${ETCD_PID-}" ]] && kube::etcd::stop
0000000000000000000000000000000000000000;;	  [[ -n "${ETCD_DIR-}" ]] && kube::etcd::clean_etcd_dir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function warning {
0000000000000000000000000000000000000000;;	  message=$1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo $(tput bold)$(tput setaf 1)
0000000000000000000000000000000000000000;;	  echo "WARNING: ${message}"
0000000000000000000000000000000000000000;;	  echo $(tput sgr0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function start_etcd {
0000000000000000000000000000000000000000;;	    echo "Starting etcd"
0000000000000000000000000000000000000000;;	    kube::etcd::start
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function set_service_accounts {
0000000000000000000000000000000000000000;;	    SERVICE_ACCOUNT_LOOKUP=${SERVICE_ACCOUNT_LOOKUP:-true}
0000000000000000000000000000000000000000;;	    SERVICE_ACCOUNT_KEY=${SERVICE_ACCOUNT_KEY:-/tmp/kube-serviceaccount.key}
0000000000000000000000000000000000000000;;	    # Generate ServiceAccount key if needed
0000000000000000000000000000000000000000;;	    if [[ ! -f "${SERVICE_ACCOUNT_KEY}" ]]; then
0000000000000000000000000000000000000000;;	      mkdir -p "$(dirname ${SERVICE_ACCOUNT_KEY})"
0000000000000000000000000000000000000000;;	      openssl genrsa -out "${SERVICE_ACCOUNT_KEY}" 2048 2>/dev/null
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function start_apiserver {
0000000000000000000000000000000000000000;;	    security_admission=""
0000000000000000000000000000000000000000;;	    if [[ -z "${ALLOW_SECURITY_CONTEXT}" ]]; then
0000000000000000000000000000000000000000;;	      security_admission=",SecurityContextDeny"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ -n "${PSP_ADMISSION}" ]]; then
0000000000000000000000000000000000000000;;	      security_admission=",PodSecurityPolicy"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ -n "${NODE_ADMISSION}" ]]; then
0000000000000000000000000000000000000000;;	      security_admission=",NodeRestriction"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Admission Controllers to invoke prior to persisting objects in cluster
0000000000000000000000000000000000000000;;	    ADMISSION_CONTROL=Initializers,NamespaceLifecycle,LimitRanger,ServiceAccount${security_admission},ResourceQuota,DefaultStorageClass,DefaultTolerationSeconds
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # This is the default dir and filename where the apiserver will generate a self-signed cert
0000000000000000000000000000000000000000;;	    # which should be able to be used as the CA to verify itself
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    audit_arg=""
0000000000000000000000000000000000000000;;	    APISERVER_BASIC_AUDIT_LOG=""
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_APISERVER_BASIC_AUDIT:-}" = true ]]; then
0000000000000000000000000000000000000000;;	        # We currently only support enabling with a fixed path and with built-in log
0000000000000000000000000000000000000000;;	        # rotation "disabled" (large value) so it behaves like kube-apiserver.log.
0000000000000000000000000000000000000000;;	        # External log rotation should be set up the same as for kube-apiserver.log.
0000000000000000000000000000000000000000;;	        APISERVER_BASIC_AUDIT_LOG=/tmp/kube-apiserver-audit.log
0000000000000000000000000000000000000000;;	        audit_arg=" --audit-log-path=${APISERVER_BASIC_AUDIT_LOG}"
0000000000000000000000000000000000000000;;	        audit_arg+=" --audit-log-maxage=0"
0000000000000000000000000000000000000000;;	        audit_arg+=" --audit-log-maxbackup=0"
0000000000000000000000000000000000000000;;	        # Lumberjack doesn't offer any way to disable size-based rotation. It also
0000000000000000000000000000000000000000;;	        # has an in-memory counter that doesn't notice if you truncate the file.
0000000000000000000000000000000000000000;;	        # 2000000000 (in MiB) is a large number that fits in 31 bits. If the log
0000000000000000000000000000000000000000;;	        # grows at 10MiB/s (~30K QPS), it will rotate after ~6 years if apiserver
0000000000000000000000000000000000000000;;	        # never restarts. Please manually restart apiserver before this time.
0000000000000000000000000000000000000000;;	        audit_arg+=" --audit-log-maxsize=2000000000"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    swagger_arg=""
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_SWAGGER_UI}" = true ]]; then
0000000000000000000000000000000000000000;;	      swagger_arg="--enable-swagger-ui=true "
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    anytoken_arg=""
0000000000000000000000000000000000000000;;	    if [[ "${ALLOW_ANY_TOKEN}" = true ]]; then
0000000000000000000000000000000000000000;;	      anytoken_arg="--insecure-allow-any-token "
0000000000000000000000000000000000000000;;	      KUBECONFIG_TOKEN="${KUBECONFIG_TOKEN:-system:admin/system:masters}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    authorizer_arg=""
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_RBAC}" = true ]]; then
0000000000000000000000000000000000000000;;	      authorizer_arg="--authorization-mode=RBAC "
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ -n "${AUTHORIZATION_MODE}" ]]; then
0000000000000000000000000000000000000000;;	      if [[ "${ENABLE_RBAC}" = true ]]; then
0000000000000000000000000000000000000000;;	        warning "AUTHORIZATION_MODE=$AUTHORIZATION_MODE overrode ENABLE_RBAC=true"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      authorizer_arg="--authorization-mode=${AUTHORIZATION_MODE} "
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    priv_arg=""
0000000000000000000000000000000000000000;;	    if [[ -n "${ALLOW_PRIVILEGED}" ]]; then
0000000000000000000000000000000000000000;;	      priv_arg="--allow-privileged "
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    runtime_config=""
0000000000000000000000000000000000000000;;	    if [[ -n "${RUNTIME_CONFIG}" ]]; then
0000000000000000000000000000000000000000;;	      runtime_config="--runtime-config=${RUNTIME_CONFIG}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Let the API server pick a default address when API_HOST_IP
0000000000000000000000000000000000000000;;	    # is set to 127.0.0.1
0000000000000000000000000000000000000000;;	    advertise_address=""
0000000000000000000000000000000000000000;;	    if [[ "${API_HOST_IP}" != "127.0.0.1" ]]; then
0000000000000000000000000000000000000000;;	        advertise_address="--advertise_address=${API_HOST_IP}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Create CA signers
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_SINGLE_CA_SIGNER:-}" = true ]]; then
0000000000000000000000000000000000000000;;	        kube::util::create_signing_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" server '"client auth","server auth"'
0000000000000000000000000000000000000000;;	        sudo cp "${CERT_DIR}/server-ca.key" "${CERT_DIR}/client-ca.key"
0000000000000000000000000000000000000000;;	        sudo cp "${CERT_DIR}/server-ca.crt" "${CERT_DIR}/client-ca.crt"
0000000000000000000000000000000000000000;;	        sudo cp "${CERT_DIR}/server-ca-config.json" "${CERT_DIR}/client-ca-config.json"
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        kube::util::create_signing_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" server '"server auth"'
0000000000000000000000000000000000000000;;	        kube::util::create_signing_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" client '"client auth"'
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Create auth proxy client ca
0000000000000000000000000000000000000000;;	    kube::util::create_signing_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" request-header '"client auth"'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # serving cert for kube-apiserver
0000000000000000000000000000000000000000;;	    kube::util::create_serving_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "server-ca" kube-apiserver kubernetes.default kubernetes.default.svc "localhost" ${API_HOST_IP} ${API_HOST} ${FIRST_SERVICE_CLUSTER_IP}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Create client certs signed with client-ca, given id, given CN and a number of groups
0000000000000000000000000000000000000000;;	    kube::util::create_client_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" 'client-ca' kubelet system:node:${HOSTNAME_OVERRIDE} system:nodes
0000000000000000000000000000000000000000;;	    kube::util::create_client_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" 'client-ca' kube-proxy system:kube-proxy system:nodes
0000000000000000000000000000000000000000;;	    kube::util::create_client_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" 'client-ca' controller system:kube-controller-manager
0000000000000000000000000000000000000000;;	    kube::util::create_client_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" 'client-ca' scheduler  system:kube-scheduler
0000000000000000000000000000000000000000;;	    kube::util::create_client_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" 'client-ca' admin system:admin system:masters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Create matching certificates for kube-aggregator
0000000000000000000000000000000000000000;;	    kube::util::create_serving_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "server-ca" kube-aggregator api.kube-public.svc "localhost" ${API_HOST_IP}
0000000000000000000000000000000000000000;;	    kube::util::create_client_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" request-header-ca auth-proxy system:auth-proxy
0000000000000000000000000000000000000000;;	    # TODO remove masters and add rolebinding
0000000000000000000000000000000000000000;;	    kube::util::create_client_certkey "${CONTROLPLANE_SUDO}" "${CERT_DIR}" 'client-ca' kube-aggregator system:kube-aggregator system:masters
0000000000000000000000000000000000000000;;	    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" kube-aggregator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    APISERVER_LOG=${LOG_DIR}/kube-apiserver.log
0000000000000000000000000000000000000000;;	    ${CONTROLPLANE_SUDO} "${GO_OUT}/hyperkube" apiserver ${swagger_arg} ${audit_arg} ${anytoken_arg} ${authorizer_arg} ${priv_arg} ${runtime_config}\
0000000000000000000000000000000000000000;;	      ${advertise_address} \
0000000000000000000000000000000000000000;;	      --v=${LOG_LEVEL} \
0000000000000000000000000000000000000000;;	      --vmodule="${LOG_SPEC}" \
0000000000000000000000000000000000000000;;	      --cert-dir="${CERT_DIR}" \
0000000000000000000000000000000000000000;;	      --client-ca-file="${CERT_DIR}/client-ca.crt" \
0000000000000000000000000000000000000000;;	      --service-account-key-file="${SERVICE_ACCOUNT_KEY}" \
0000000000000000000000000000000000000000;;	      --service-account-lookup="${SERVICE_ACCOUNT_LOOKUP}" \
0000000000000000000000000000000000000000;;	      --admission-control="${ADMISSION_CONTROL}" \
0000000000000000000000000000000000000000;;	      --admission-control-config-file="${ADMISSION_CONTROL_CONFIG_FILE}" \
0000000000000000000000000000000000000000;;	      --bind-address="${API_BIND_ADDR}" \
0000000000000000000000000000000000000000;;	      --secure-port="${API_SECURE_PORT}" \
0000000000000000000000000000000000000000;;	      --tls-cert-file="${CERT_DIR}/serving-kube-apiserver.crt" \
0000000000000000000000000000000000000000;;	      --tls-private-key-file="${CERT_DIR}/serving-kube-apiserver.key" \
0000000000000000000000000000000000000000;;	      --tls-ca-file="${CERT_DIR}/server-ca.crt" \
0000000000000000000000000000000000000000;;	      --insecure-bind-address="${API_HOST_IP}" \
0000000000000000000000000000000000000000;;	      --insecure-port="${API_PORT}" \
0000000000000000000000000000000000000000;;	      --storage-backend=${STORAGE_BACKEND} \
0000000000000000000000000000000000000000;;	      --etcd-servers="http://${ETCD_HOST}:${ETCD_PORT}" \
0000000000000000000000000000000000000000;;	      --service-cluster-ip-range="${SERVICE_CLUSTER_IP_RANGE}" \
0000000000000000000000000000000000000000;;	      --feature-gates="${FEATURE_GATES}" \
0000000000000000000000000000000000000000;;	      --cloud-provider="${CLOUD_PROVIDER}" \
0000000000000000000000000000000000000000;;	      --cloud-config="${CLOUD_CONFIG}" \
0000000000000000000000000000000000000000;;	      --requestheader-username-headers=X-Remote-User \
0000000000000000000000000000000000000000;;	      --requestheader-group-headers=X-Remote-Group \
0000000000000000000000000000000000000000;;	      --requestheader-extra-headers-prefix=X-Remote-Extra- \
0000000000000000000000000000000000000000;;	      --requestheader-client-ca-file="${CERT_DIR}/request-header-ca.crt" \
0000000000000000000000000000000000000000;;	      --requestheader-allowed-names=system:auth-proxy \
0000000000000000000000000000000000000000;;	      --proxy-client-cert-file="${CERT_DIR}/client-auth-proxy.crt" \
0000000000000000000000000000000000000000;;	      --proxy-client-key-file="${CERT_DIR}/client-auth-proxy.key" \
0000000000000000000000000000000000000000;;	      --cors-allowed-origins="${API_CORS_ALLOWED_ORIGINS}" >"${APISERVER_LOG}" 2>&1 &
0000000000000000000000000000000000000000;;	    APISERVER_PID=$!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Wait for kube-apiserver to come up before launching the rest of the components.
0000000000000000000000000000000000000000;;	    echo "Waiting for apiserver to come up"
0000000000000000000000000000000000000000;;	    # this uses the API port because if you don't have any authenticator, you can't seem to use the secure port at all.
0000000000000000000000000000000000000000;;	    # this matches what happened with the combination in 1.4.
0000000000000000000000000000000000000000;;	    # TODO change this conditionally based on whether API_PORT is on or off
0000000000000000000000000000000000000000;;	    kube::util::wait_for_url "http://${API_HOST_IP}:${API_SECURE_PORT}/healthz" "apiserver: " 1 ${WAIT_FOR_URL_API_SERVER} \
0000000000000000000000000000000000000000;;	        || { echo "check apiserver logs: ${APISERVER_LOG}" ; exit 1 ; }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Create kubeconfigs for all components, using client certs
0000000000000000000000000000000000000000;;	    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" admin
0000000000000000000000000000000000000000;;	    ${CONTROLPLANE_SUDO} chown "${USER}" "${CERT_DIR}/client-admin.key" # make readable for kubectl
0000000000000000000000000000000000000000;;	    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" kubelet
0000000000000000000000000000000000000000;;	    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" kube-proxy
0000000000000000000000000000000000000000;;	    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" controller
0000000000000000000000000000000000000000;;	    kube::util::write_client_kubeconfig "${CONTROLPLANE_SUDO}" "${CERT_DIR}" "${ROOT_CA_FILE}" "${API_HOST}" "${API_SECURE_PORT}" scheduler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ -z "${AUTH_ARGS}" ]]; then
0000000000000000000000000000000000000000;;	        if [[ "${ALLOW_ANY_TOKEN}" = true ]]; then
0000000000000000000000000000000000000000;;	            # use token authentication
0000000000000000000000000000000000000000;;	            if [[ -n "${KUBECONFIG_TOKEN}" ]]; then
0000000000000000000000000000000000000000;;	                AUTH_ARGS="--token=${KUBECONFIG_TOKEN}"
0000000000000000000000000000000000000000;;	            else
0000000000000000000000000000000000000000;;	                AUTH_ARGS="--token=system:admin/system:masters"
0000000000000000000000000000000000000000;;	            fi
0000000000000000000000000000000000000000;;	        else
0000000000000000000000000000000000000000;;	            # default to the admin client cert/key
0000000000000000000000000000000000000000;;	            AUTH_ARGS="--client-key=${CERT_DIR}/client-admin.key --client-certificate=${CERT_DIR}/client-admin.crt"
0000000000000000000000000000000000000000;;	        fi
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    ${CONTROLPLANE_SUDO} cp "${CERT_DIR}/admin.kubeconfig" "${CERT_DIR}/admin-kube-aggregator.kubeconfig"
0000000000000000000000000000000000000000;;	    ${CONTROLPLANE_SUDO} chown $(whoami) "${CERT_DIR}/admin-kube-aggregator.kubeconfig"
0000000000000000000000000000000000000000;;	    ${KUBECTL} config set-cluster local-up-cluster --kubeconfig="${CERT_DIR}/admin-kube-aggregator.kubeconfig" --server="https://${API_HOST_IP}:31090"
0000000000000000000000000000000000000000;;	    echo "use 'kubectl --kubeconfig=${CERT_DIR}/admin-kube-aggregator.kubeconfig' to use the aggregated API server"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function start_controller_manager {
0000000000000000000000000000000000000000;;	    node_cidr_args=""
0000000000000000000000000000000000000000;;	    if [[ "${NET_PLUGIN}" == "kubenet" ]]; then
0000000000000000000000000000000000000000;;	      node_cidr_args="--allocate-node-cidrs=true --cluster-cidr=10.1.0.0/16 "
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    CTLRMGR_LOG=${LOG_DIR}/kube-controller-manager.log
0000000000000000000000000000000000000000;;	    ${CONTROLPLANE_SUDO} "${GO_OUT}/hyperkube" controller-manager \
0000000000000000000000000000000000000000;;	      --v=${LOG_LEVEL} \
0000000000000000000000000000000000000000;;	      --vmodule="${LOG_SPEC}" \
0000000000000000000000000000000000000000;;	      --service-account-private-key-file="${SERVICE_ACCOUNT_KEY}" \
0000000000000000000000000000000000000000;;	      --root-ca-file="${ROOT_CA_FILE}" \
0000000000000000000000000000000000000000;;	      --cluster-signing-cert-file="${CLUSTER_SIGNING_CERT_FILE}" \
0000000000000000000000000000000000000000;;	      --cluster-signing-key-file="${CLUSTER_SIGNING_KEY_FILE}" \
0000000000000000000000000000000000000000;;	      --enable-hostpath-provisioner="${ENABLE_HOSTPATH_PROVISIONER}" \
0000000000000000000000000000000000000000;;	      ${node_cidr_args} \
0000000000000000000000000000000000000000;;	      --pvclaimbinder-sync-period="${CLAIM_BINDER_SYNC_PERIOD}" \
0000000000000000000000000000000000000000;;	      --feature-gates="${FEATURE_GATES}" \
0000000000000000000000000000000000000000;;	      --cloud-provider="${CLOUD_PROVIDER}" \
0000000000000000000000000000000000000000;;	      --cloud-config="${CLOUD_CONFIG}" \
0000000000000000000000000000000000000000;;	      --kubeconfig "$CERT_DIR"/controller.kubeconfig \
0000000000000000000000000000000000000000;;	      --use-service-account-credentials \
0000000000000000000000000000000000000000;;	      --controllers="${KUBE_CONTROLLERS}" \
0000000000000000000000000000000000000000;;	      --master="https://${API_HOST}:${API_SECURE_PORT}" >"${CTLRMGR_LOG}" 2>&1 &
0000000000000000000000000000000000000000;;	    CTLRMGR_PID=$!
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function start_kubelet {
0000000000000000000000000000000000000000;;	    KUBELET_LOG=${LOG_DIR}/kubelet.log
0000000000000000000000000000000000000000;;	    mkdir -p ${POD_MANIFEST_PATH} || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    priv_arg=""
0000000000000000000000000000000000000000;;	    if [[ -n "${ALLOW_PRIVILEGED}" ]]; then
0000000000000000000000000000000000000000;;	      priv_arg="--allow-privileged "
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    mkdir -p /var/lib/kubelet
0000000000000000000000000000000000000000;;	    if [[ -z "${DOCKERIZE_KUBELET}" ]]; then
0000000000000000000000000000000000000000;;	      # Enable dns
0000000000000000000000000000000000000000;;	      if [[ "${ENABLE_CLUSTER_DNS}" = true ]]; then
0000000000000000000000000000000000000000;;	         dns_args="--cluster-dns=${DNS_SERVER_IP} --cluster-domain=${DNS_DOMAIN}"
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;	         # To start a private DNS server set ENABLE_CLUSTER_DNS and
0000000000000000000000000000000000000000;;	         # DNS_SERVER_IP/DOMAIN. This will at least provide a working
0000000000000000000000000000000000000000;;	         # DNS server for real world hostnames.
0000000000000000000000000000000000000000;;	         dns_args="--cluster-dns=8.8.8.8"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      net_plugin_args=""
0000000000000000000000000000000000000000;;	      if [[ -n "${NET_PLUGIN}" ]]; then
0000000000000000000000000000000000000000;;	        net_plugin_args="--network-plugin=${NET_PLUGIN}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      auth_args=""
0000000000000000000000000000000000000000;;	      if [[ -n "${KUBELET_AUTHORIZATION_WEBHOOK:-}" ]]; then
0000000000000000000000000000000000000000;;	        auth_args="${auth_args} --authorization-mode=Webhook"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if [[ -n "${KUBELET_AUTHENTICATION_WEBHOOK:-}" ]]; then
0000000000000000000000000000000000000000;;	        auth_args="${auth_args} --authentication-token-webhook"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if [[ -n "${CLIENT_CA_FILE:-}" ]]; then
0000000000000000000000000000000000000000;;	        auth_args="${auth_args} --client-ca-file=${CLIENT_CA_FILE}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      cni_conf_dir_args=""
0000000000000000000000000000000000000000;;	      if [[ -n "${CNI_CONF_DIR}" ]]; then
0000000000000000000000000000000000000000;;	        cni_conf_dir_args="--cni-conf-dir=${CNI_CONF_DIR}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      cni_bin_dir_args=""
0000000000000000000000000000000000000000;;	      if [[ -n "${CNI_BIN_DIR}" ]]; then
0000000000000000000000000000000000000000;;	        cni_bin_dir_args="--cni-bin-dir=${CNI_BIN_DIR}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      container_runtime_endpoint_args=""
0000000000000000000000000000000000000000;;	      if [[ -n "${CONTAINER_RUNTIME_ENDPOINT}" ]]; then
0000000000000000000000000000000000000000;;	        container_runtime_endpoint_args="--container-runtime-endpoint=${CONTAINER_RUNTIME_ENDPOINT}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      image_service_endpoint_args=""
0000000000000000000000000000000000000000;;	      if [[ -n "${IMAGE_SERVICE_ENDPOINT}" ]]; then
0000000000000000000000000000000000000000;;	        image_service_endpoint_args="--image-service-endpoint=${IMAGE_SERVICE_ENDPOINT}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      sudo -E "${GO_OUT}/hyperkube" kubelet ${priv_arg}\
0000000000000000000000000000000000000000;;	        --v=${LOG_LEVEL} \
0000000000000000000000000000000000000000;;	        --vmodule="${LOG_SPEC}" \
0000000000000000000000000000000000000000;;	        --chaos-chance="${CHAOS_CHANCE}" \
0000000000000000000000000000000000000000;;	        --container-runtime="${CONTAINER_RUNTIME}" \
0000000000000000000000000000000000000000;;	        --rkt-path="${RKT_PATH}" \
0000000000000000000000000000000000000000;;	        --rkt-stage1-image="${RKT_STAGE1_IMAGE}" \
0000000000000000000000000000000000000000;;	        --hostname-override="${HOSTNAME_OVERRIDE}" \
0000000000000000000000000000000000000000;;	        --cloud-provider="${CLOUD_PROVIDER}" \
0000000000000000000000000000000000000000;;	        --cloud-config="${CLOUD_CONFIG}" \
0000000000000000000000000000000000000000;;	        --address="${KUBELET_HOST}" \
0000000000000000000000000000000000000000;;	        --require-kubeconfig \
0000000000000000000000000000000000000000;;	        --kubeconfig "$CERT_DIR"/kubelet.kubeconfig \
0000000000000000000000000000000000000000;;	        --feature-gates="${FEATURE_GATES}" \
0000000000000000000000000000000000000000;;	        --cpu-cfs-quota=${CPU_CFS_QUOTA} \
0000000000000000000000000000000000000000;;	        --enable-controller-attach-detach="${ENABLE_CONTROLLER_ATTACH_DETACH}" \
0000000000000000000000000000000000000000;;	        --cgroups-per-qos=${CGROUPS_PER_QOS} \
0000000000000000000000000000000000000000;;	        --cgroup-driver=${CGROUP_DRIVER} \
0000000000000000000000000000000000000000;;	        --keep-terminated-pod-volumes=${KEEP_TERMINATED_POD_VOLUMES} \
0000000000000000000000000000000000000000;;	        --eviction-hard=${EVICTION_HARD} \
0000000000000000000000000000000000000000;;	        --eviction-soft=${EVICTION_SOFT} \
0000000000000000000000000000000000000000;;	        --eviction-pressure-transition-period=${EVICTION_PRESSURE_TRANSITION_PERIOD} \
0000000000000000000000000000000000000000;;	        --pod-manifest-path="${POD_MANIFEST_PATH}" \
0000000000000000000000000000000000000000;;	        ${auth_args} \
0000000000000000000000000000000000000000;;	        ${dns_args} \
0000000000000000000000000000000000000000;;	        ${cni_conf_dir_args} \
0000000000000000000000000000000000000000;;	        ${cni_bin_dir_args} \
0000000000000000000000000000000000000000;;	        ${net_plugin_args} \
0000000000000000000000000000000000000000;;	        ${container_runtime_endpoint_args} \
0000000000000000000000000000000000000000;;	        ${image_service_endpoint_args} \
0000000000000000000000000000000000000000;;	        --port="$KUBELET_PORT" \
0000000000000000000000000000000000000000;;		${KUBELET_FLAGS} >"${KUBELET_LOG}" 2>&1 &
0000000000000000000000000000000000000000;;	      KUBELET_PID=$!
0000000000000000000000000000000000000000;;	      # Quick check that kubelet is running.
0000000000000000000000000000000000000000;;	      if ps -p $KUBELET_PID > /dev/null ; then
0000000000000000000000000000000000000000;;		echo "kubelet ( $KUBELET_PID ) is running."
0000000000000000000000000000000000000000;;	      else
0000000000000000000000000000000000000000;;		cat ${KUBELET_LOG} ; exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	      # Docker won't run a container with a cidfile (container id file)
0000000000000000000000000000000000000000;;	      # unless that file does not already exist; clean up an existing
0000000000000000000000000000000000000000;;	      # dockerized kubelet that might be running.
0000000000000000000000000000000000000000;;	      cleanup_dockerized_kubelet
0000000000000000000000000000000000000000;;	      cred_bind=""
0000000000000000000000000000000000000000;;	      # path to cloud credentials.
0000000000000000000000000000000000000000;;	      cloud_cred=""
0000000000000000000000000000000000000000;;	      if [ "${CLOUD_PROVIDER}" == "aws" ]; then
0000000000000000000000000000000000000000;;	          cloud_cred="${HOME}/.aws/credentials"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if [ "${CLOUD_PROVIDER}" == "gce" ]; then
0000000000000000000000000000000000000000;;	          cloud_cred="${HOME}/.config/gcloud"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if [ "${CLOUD_PROVIDER}" == "openstack" ]; then
0000000000000000000000000000000000000000;;	          cloud_cred="${CLOUD_CONFIG}"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      if  [[ -n "${cloud_cred}" ]]; then
0000000000000000000000000000000000000000;;	          cred_bind="--volume=${cloud_cred}:${cloud_cred}:ro"
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	      docker run \
0000000000000000000000000000000000000000;;	        --volume=/:/rootfs:ro \
0000000000000000000000000000000000000000;;	        --volume=/var/run:/var/run:rw \
0000000000000000000000000000000000000000;;	        --volume=/sys:/sys:ro \
0000000000000000000000000000000000000000;;	        --volume=/var/lib/docker/:/var/lib/docker:ro \
0000000000000000000000000000000000000000;;	        --volume=/var/lib/kubelet/:/var/lib/kubelet:rw \
0000000000000000000000000000000000000000;;	        --volume=/dev:/dev \
0000000000000000000000000000000000000000;;	        --volume=/run/xtables.lock:/run/xtables.lock:rw \
0000000000000000000000000000000000000000;;	        ${cred_bind} \
0000000000000000000000000000000000000000;;	        --net=host \
0000000000000000000000000000000000000000;;	        --privileged=true \
0000000000000000000000000000000000000000;;	        -i \
0000000000000000000000000000000000000000;;	        --cidfile=$KUBELET_CIDFILE \
0000000000000000000000000000000000000000;;	        gcr.io/google_containers/kubelet \
0000000000000000000000000000000000000000;;	        /kubelet --v=${LOG_LEVEL} --containerized ${priv_arg}--chaos-chance="${CHAOS_CHANCE}" --pod-manifest-path="${POD_MANIFEST_PATH}" --hostname-override="${HOSTNAME_OVERRIDE}" --cloud-provider="${CLOUD_PROVIDER}" --cloud-config="${CLOUD_CONFIG}" \ --address="127.0.0.1" --require-kubeconfig --kubeconfig "$CERT_DIR"/kubelet.kubeconfig --api-servers="https://${API_HOST}:${API_SECURE_PORT}" --port="$KUBELET_PORT"  --enable-controller-attach-detach="${ENABLE_CONTROLLER_ATTACH_DETACH}" &> $KUBELET_LOG &
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function start_kubeproxy {
0000000000000000000000000000000000000000;;	    PROXY_LOG=${LOG_DIR}/kube-proxy.log
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    cat <<EOF > /tmp/kube-proxy.yaml
0000000000000000000000000000000000000000;;	apiVersion: componentconfig/v1alpha1
0000000000000000000000000000000000000000;;	kind: KubeProxyConfiguration
0000000000000000000000000000000000000000;;	clientConnection:
0000000000000000000000000000000000000000;;	  kubeconfig: ${CERT_DIR}/kube-proxy.kubeconfig
0000000000000000000000000000000000000000;;	hostnameOverride: ${HOSTNAME_OVERRIDE}
0000000000000000000000000000000000000000;;	featureGates: ${FEATURE_GATES}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    sudo "${GO_OUT}/hyperkube" proxy \
0000000000000000000000000000000000000000;;	      --config=/tmp/kube-proxy.yaml \
0000000000000000000000000000000000000000;;	      --master="https://${API_HOST}:${API_SECURE_PORT}" >"${PROXY_LOG}" \
0000000000000000000000000000000000000000;;	      --v=${LOG_LEVEL} 2>&1 &
0000000000000000000000000000000000000000;;	    PROXY_PID=$!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    SCHEDULER_LOG=${LOG_DIR}/kube-scheduler.log
0000000000000000000000000000000000000000;;	    ${CONTROLPLANE_SUDO} "${GO_OUT}/hyperkube" scheduler \
0000000000000000000000000000000000000000;;	      --v=${LOG_LEVEL} \
0000000000000000000000000000000000000000;;	      --kubeconfig "$CERT_DIR"/scheduler.kubeconfig \
0000000000000000000000000000000000000000;;	      --master="https://${API_HOST}:${API_SECURE_PORT}" >"${SCHEDULER_LOG}" 2>&1 &
0000000000000000000000000000000000000000;;	    SCHEDULER_PID=$!
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function start_kubedns {
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_CLUSTER_DNS}" = true ]]; then
0000000000000000000000000000000000000000;;	        echo "Creating kube-system namespace"
0000000000000000000000000000000000000000;;	        sed -e "s/{{ pillar\['dns_domain'\] }}/${DNS_DOMAIN}/g" "${KUBE_ROOT}/cluster/addons/dns/kubedns-controller.yaml.in" >| kubedns-deployment.yaml
0000000000000000000000000000000000000000;;	        sed -e "s/{{ pillar\['dns_server'\] }}/${DNS_SERVER_IP}/g" "${KUBE_ROOT}/cluster/addons/dns/kubedns-svc.yaml.in" >| kubedns-svc.yaml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        # TODO update to dns role once we have one.
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create clusterrolebinding system:kube-dns --clusterrole=cluster-admin --serviceaccount=kube-system:default
0000000000000000000000000000000000000000;;	        # use kubectl to create kubedns deployment and service
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" --namespace=kube-system create -f ${KUBE_ROOT}/cluster/addons/dns/kubedns-sa.yaml
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" --namespace=kube-system create -f ${KUBE_ROOT}/cluster/addons/dns/kubedns-cm.yaml
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" --namespace=kube-system create -f kubedns-deployment.yaml
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" --namespace=kube-system create -f kubedns-svc.yaml
0000000000000000000000000000000000000000;;	        echo "Kube-dns deployment and service successfully deployed."
0000000000000000000000000000000000000000;;	        rm  kubedns-deployment.yaml kubedns-svc.yaml
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function start_kubedashboard {
0000000000000000000000000000000000000000;;	    if [[ "${ENABLE_CLUSTER_DASHBOARD}" = true ]]; then
0000000000000000000000000000000000000000;;	        echo "Creating kubernetes-dashboard"
0000000000000000000000000000000000000000;;	        # use kubectl to create the dashboard
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create -f ${KUBE_ROOT}/cluster/addons/dashboard/dashboard-controller.yaml
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create -f ${KUBE_ROOT}/cluster/addons/dashboard/dashboard-service.yaml
0000000000000000000000000000000000000000;;	        echo "kubernetes-dashboard deployment and service successfully deployed."
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create_psp_policy {
0000000000000000000000000000000000000000;;	    echo "Create podsecuritypolicy policies for RBAC."
0000000000000000000000000000000000000000;;	    ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create -f ${KUBE_ROOT}/examples/podsecuritypolicy/rbac/policies.yaml
0000000000000000000000000000000000000000;;	    ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create -f ${KUBE_ROOT}/examples/podsecuritypolicy/rbac/roles.yaml
0000000000000000000000000000000000000000;;	    ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create -f ${KUBE_ROOT}/examples/podsecuritypolicy/rbac/bindings.yaml
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function create_storage_class {
0000000000000000000000000000000000000000;;	    if [ -z "$CLOUD_PROVIDER" ]; then
0000000000000000000000000000000000000000;;	        CLASS_FILE=${KUBE_ROOT}/cluster/addons/storage-class/local/default.yaml
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        CLASS_FILE=${KUBE_ROOT}/cluster/addons/storage-class/${CLOUD_PROVIDER}/default.yaml
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [ -e $CLASS_FILE ]; then
0000000000000000000000000000000000000000;;	        echo "Create default storage class for $CLOUD_PROVIDER"
0000000000000000000000000000000000000000;;	        ${KUBECTL} --kubeconfig="${CERT_DIR}/admin.kubeconfig" create -f $CLASS_FILE
0000000000000000000000000000000000000000;;	    else
0000000000000000000000000000000000000000;;	        echo "No storage class available for $CLOUD_PROVIDER."
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function print_success {
0000000000000000000000000000000000000000;;	if [[ "${START_MODE}" != "kubeletonly" ]]; then
0000000000000000000000000000000000000000;;	  cat <<EOF
0000000000000000000000000000000000000000;;	Local Kubernetes cluster is running. Press Ctrl-C to shut it down.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Logs:
0000000000000000000000000000000000000000;;	  ${APISERVER_LOG:-}
0000000000000000000000000000000000000000;;	  ${CTLRMGR_LOG:-}
0000000000000000000000000000000000000000;;	  ${PROXY_LOG:-}
0000000000000000000000000000000000000000;;	  ${SCHEDULER_LOG:-}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${ENABLE_APISERVER_BASIC_AUDIT:-}" = true ]]; then
0000000000000000000000000000000000000000;;	  echo "  ${APISERVER_BASIC_AUDIT_LOG}"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${START_MODE}" == "all" ]]; then
0000000000000000000000000000000000000000;;	  echo "  ${KUBELET_LOG}"
0000000000000000000000000000000000000000;;	elif [[ "${START_MODE}" == "nokubelet" ]]; then
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "No kubelet was started because you set START_MODE=nokubelet"
0000000000000000000000000000000000000000;;	  echo "Run this script again with START_MODE=kubeletonly to run a kubelet"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${START_MODE}" != "kubeletonly" ]]; then
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  cat <<EOF
0000000000000000000000000000000000000000;;	To start using your cluster, you can open up another terminal/tab and run:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export KUBECONFIG=${CERT_DIR}/admin.kubeconfig
0000000000000000000000000000000000000000;;	  cluster/kubectl.sh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Alternatively, you can write to the default kubeconfig:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  export KUBERNETES_PROVIDER=local
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  cluster/kubectl.sh config set-cluster local --server=https://${API_HOST}:${API_SECURE_PORT} --certificate-authority=${ROOT_CA_FILE}
0000000000000000000000000000000000000000;;	  cluster/kubectl.sh config set-credentials myself ${AUTH_ARGS}
0000000000000000000000000000000000000000;;	  cluster/kubectl.sh config set-context local --cluster=local --user=myself
0000000000000000000000000000000000000000;;	  cluster/kubectl.sh config use-context local
0000000000000000000000000000000000000000;;	  cluster/kubectl.sh
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  cat <<EOF
0000000000000000000000000000000000000000;;	The kubelet was started.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Logs:
0000000000000000000000000000000000000000;;	  ${KUBELET_LOG}
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# validate that etcd is: not running, in path, and has minimum required version.
0000000000000000000000000000000000000000;;	if [[ "${START_MODE}" != "kubeletonly" ]]; then
0000000000000000000000000000000000000000;;	  kube::etcd::validate
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ "${CONTAINER_RUNTIME}" == "docker" ] && ! kube::util::ensure_docker_daemon_connectivity; then
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${CONTAINER_RUNTIME}" == "rkt" ]]; then
0000000000000000000000000000000000000000;;	  test_rkt
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${START_MODE}" != "kubeletonly" ]]; then
0000000000000000000000000000000000000000;;	  test_apiserver_off
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::util::test_openssl_installed
0000000000000000000000000000000000000000;;	kube::util::ensure-cfssl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### IF the user didn't supply an output/ for the build... Then we detect.
0000000000000000000000000000000000000000;;	if [ "$GO_OUT" == "" ]; then
0000000000000000000000000000000000000000;;	  detect_binary
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	echo "Detected host and ready to start services.  Doing some housekeeping first..."
0000000000000000000000000000000000000000;;	echo "Using GO_OUT $GO_OUT"
0000000000000000000000000000000000000000;;	KUBELET_CIDFILE=/tmp/kubelet.cid
0000000000000000000000000000000000000000;;	if [[ "${ENABLE_DAEMON}" = false ]]; then
0000000000000000000000000000000000000000;;	  trap cleanup EXIT
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "Starting services now!"
0000000000000000000000000000000000000000;;	if [[ "${START_MODE}" != "kubeletonly" ]]; then
0000000000000000000000000000000000000000;;	  start_etcd
0000000000000000000000000000000000000000;;	  set_service_accounts
0000000000000000000000000000000000000000;;	  start_apiserver
0000000000000000000000000000000000000000;;	  start_controller_manager
0000000000000000000000000000000000000000;;	  start_kubeproxy
0000000000000000000000000000000000000000;;	  start_kubedns
0000000000000000000000000000000000000000;;	  start_kubedashboard
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${START_MODE}" != "nokubelet" ]]; then
0000000000000000000000000000000000000000;;	  ## TODO remove this check if/when kubelet is supported on darwin
0000000000000000000000000000000000000000;;	  # Detect the OS name/arch and display appropriate error.
0000000000000000000000000000000000000000;;	    case "$(uname -s)" in
0000000000000000000000000000000000000000;;	      Darwin)
0000000000000000000000000000000000000000;;	        warning "kubelet is not currently supported in darwin, kubelet aborted."
0000000000000000000000000000000000000000;;	        KUBELET_LOG=""
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      Linux)
0000000000000000000000000000000000000000;;	        start_kubelet
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	      *)
0000000000000000000000000000000000000000;;	        warning "Unsupported host OS.  Must be Linux or Mac OS X, kubelet aborted."
0000000000000000000000000000000000000000;;	        ;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ -n "${PSP_ADMISSION}" && ("${ENABLE_RBAC}" = true || "${AUTHORIZATION_MODE}" = *RBAC* ) ]]; then
0000000000000000000000000000000000000000;;	  create_psp_policy
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "$DEFAULT_STORAGE_CLASS" = "true" ]]; then
0000000000000000000000000000000000000000;;	  create_storage_class
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	print_success
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "${ENABLE_DAEMON}" = false ]]; then
0000000000000000000000000000000000000000;;	  while true; do sleep 1; done
0000000000000000000000000000000000000000;;	fi
