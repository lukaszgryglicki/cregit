0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_ROOT=$(dirname "${BASH_SOURCE}")/../..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::golang::setup_env
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# start the cache mutation detector by default so that cache mutators will be found
0000000000000000000000000000000000000000;;	KUBE_CACHE_MUTATION_DETECTOR="${KUBE_CACHE_MUTATION_DETECTOR:-true}"
0000000000000000000000000000000000000000;;	export KUBE_CACHE_MUTATION_DETECTOR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# panic the server on watch decode errors since they are considered coder mistakes
0000000000000000000000000000000000000000;;	KUBE_PANIC_WATCH_DECODE_ERROR="${KUBE_PANIC_WATCH_DECODE_ERROR:-true}"
0000000000000000000000000000000000000000;;	export KUBE_PANIC_WATCH_DECODE_ERROR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Handle case where OS has sha#sum commands, instead of shasum.
0000000000000000000000000000000000000000;;	if which shasum >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	  SHA1SUM="shasum -a1"
0000000000000000000000000000000000000000;;	elif which sha1sum >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	  SHA1SUM="sha1sum"
0000000000000000000000000000000000000000;;	else
0000000000000000000000000000000000000000;;	  echo "Failed to find shasum or sha1sum utility." >&2
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::find_dirs() {
0000000000000000000000000000000000000000;;	  (
0000000000000000000000000000000000000000;;	    cd ${KUBE_ROOT}
0000000000000000000000000000000000000000;;	    find -L . -not \( \
0000000000000000000000000000000000000000;;	        \( \
0000000000000000000000000000000000000000;;	          -path './_artifacts/*' \
0000000000000000000000000000000000000000;;	          -o -path './bazel-*/*' \
0000000000000000000000000000000000000000;;	          -o -path './_output/*' \
0000000000000000000000000000000000000000;;	          -o -path './_gopath/*' \
0000000000000000000000000000000000000000;;	          -o -path './cmd/kubeadm/test/*' \
0000000000000000000000000000000000000000;;	          -o -path './contrib/podex/*' \
0000000000000000000000000000000000000000;;	          -o -path './output/*' \
0000000000000000000000000000000000000000;;	          -o -path './release/*' \
0000000000000000000000000000000000000000;;	          -o -path './target/*' \
0000000000000000000000000000000000000000;;	          -o -path './test/e2e/*' \
0000000000000000000000000000000000000000;;	          -o -path './test/e2e_node/*' \
0000000000000000000000000000000000000000;;	          -o -path './test/integration/*' \
0000000000000000000000000000000000000000;;	          -o -path './third_party/*' \
0000000000000000000000000000000000000000;;	          -o -path './staging/*' \
0000000000000000000000000000000000000000;;	          -o -path './vendor/*' \
0000000000000000000000000000000000000000;;	        \) -prune \
0000000000000000000000000000000000000000;;	      \) -name '*_test.go' -print0 | xargs -0n1 dirname | sed "s|^\./|${KUBE_GO_PACKAGE}/|" | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    find -L . \
0000000000000000000000000000000000000000;;	        -path './_output' -prune \
0000000000000000000000000000000000000000;;	        -o -path './vendor/k8s.io/client-go/*' \
0000000000000000000000000000000000000000;;	        -o -path './vendor/k8s.io/apiserver/*' \
0000000000000000000000000000000000000000;;	        -o -path './test/e2e_node/system/*' \
0000000000000000000000000000000000000000;;	      -name '*_test.go' -print0 | xargs -0n1 dirname | sed "s|^\./|${KUBE_GO_PACKAGE}/|" | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # run tests for client-go
0000000000000000000000000000000000000000;;	    find ./staging/src/k8s.io/client-go -name '*_test.go' \
0000000000000000000000000000000000000000;;	      -name '*_test.go' -print0 | xargs -0n1 dirname | sed 's|^\./staging/src/|./vendor/|' | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # run tests for apiserver
0000000000000000000000000000000000000000;;	    find ./staging/src/k8s.io/apiserver -name '*_test.go' \
0000000000000000000000000000000000000000;;	      -name '*_test.go' -print0 | xargs -0n1 dirname | sed 's|^\./staging/src/|./vendor/|' | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # run tests for apimachinery
0000000000000000000000000000000000000000;;	    find ./staging/src/k8s.io/apimachinery -name '*_test.go' \
0000000000000000000000000000000000000000;;	      -name '*_test.go' -print0 | xargs -0n1 dirname | sed 's|^\./staging/src/|./vendor/|' | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    find ./staging/src/k8s.io/kube-aggregator -name '*_test.go' \
0000000000000000000000000000000000000000;;	      -name '*_test.go' -print0 | xargs -0n1 dirname | sed 's|^\./staging/src/|./vendor/|' | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    find ./staging/src/k8s.io/apiextensions-apiserver -not \( \
0000000000000000000000000000000000000000;;	        \( \
0000000000000000000000000000000000000000;;	          -path '*/test/integration/*' \
0000000000000000000000000000000000000000;;	        \) -prune \
0000000000000000000000000000000000000000;;	      \) -name '*_test.go' \
0000000000000000000000000000000000000000;;	      -name '*_test.go' -print0 | xargs -0n1 dirname | sed 's|^\./staging/src/|./vendor/|' | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    find ./staging/src/k8s.io/sample-apiserver -name '*_test.go' \
0000000000000000000000000000000000000000;;	      -name '*_test.go' -print0 | xargs -0n1 dirname | sed 's|^\./staging/src/|./vendor/|' | LC_ALL=C sort -u
0000000000000000000000000000000000000000;;	  )
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_TIMEOUT=${KUBE_TIMEOUT:--timeout 120s}
0000000000000000000000000000000000000000;;	KUBE_COVER=${KUBE_COVER:-n} # set to 'y' to enable coverage collection
0000000000000000000000000000000000000000;;	KUBE_COVERMODE=${KUBE_COVERMODE:-atomic}
0000000000000000000000000000000000000000;;	# How many 'go test' instances to run simultaneously when running tests in
0000000000000000000000000000000000000000;;	# coverage mode.
0000000000000000000000000000000000000000;;	KUBE_COVERPROCS=${KUBE_COVERPROCS:-4}
0000000000000000000000000000000000000000;;	KUBE_RACE=${KUBE_RACE:-}   # use KUBE_RACE="-race" to enable race testing
0000000000000000000000000000000000000000;;	# Set to the goveralls binary path to report coverage results to Coveralls.io.
0000000000000000000000000000000000000000;;	KUBE_GOVERALLS_BIN=${KUBE_GOVERALLS_BIN:-}
0000000000000000000000000000000000000000;;	# Lists of API Versions of each groups that should be tested, groups are
0000000000000000000000000000000000000000;;	# separated by comma, lists are separated by semicolon. e.g.,
0000000000000000000000000000000000000000;;	# "v1,compute/v1alpha1,experimental/v1alpha2;v1,compute/v2,experimental/v1alpha3"
0000000000000000000000000000000000000000;;	# FIXME: due to current implementation of a test client (see: pkg/api/testapi/testapi.go)
0000000000000000000000000000000000000000;;	# ONLY the last version is tested in each group.
0000000000000000000000000000000000000000;;	ALL_VERSIONS_CSV=$(IFS=',';echo "${KUBE_AVAILABLE_GROUP_VERSIONS[*]// /,}";IFS=$),federation/v1beta1
0000000000000000000000000000000000000000;;	KUBE_TEST_API_VERSIONS="${KUBE_TEST_API_VERSIONS:-${ALL_VERSIONS_CSV}}"
0000000000000000000000000000000000000000;;	# once we have multiple group supports
0000000000000000000000000000000000000000;;	# Create a junit-style XML test report in this directory if set.
0000000000000000000000000000000000000000;;	KUBE_JUNIT_REPORT_DIR=${KUBE_JUNIT_REPORT_DIR:-}
0000000000000000000000000000000000000000;;	# Set to 'y' to keep the verbose stdout from tests when KUBE_JUNIT_REPORT_DIR is
0000000000000000000000000000000000000000;;	# set.
0000000000000000000000000000000000000000;;	KUBE_KEEP_VERBOSE_TEST_OUTPUT=${KUBE_KEEP_VERBOSE_TEST_OUTPUT:-n}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::test::usage() {
0000000000000000000000000000000000000000;;	  kube::log::usage_from_stdin <<EOF
0000000000000000000000000000000000000000;;	usage: $0 [OPTIONS] [TARGETS]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	OPTIONS:
0000000000000000000000000000000000000000;;	  -p <number>   : number of parallel workers, must be >= 1
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	isnum() {
0000000000000000000000000000000000000000;;	  [[ "$1" =~ ^[0-9]+$ ]]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	PARALLEL="${PARALLEL:-1}"
0000000000000000000000000000000000000000;;	while getopts "hp:i:" opt ; do
0000000000000000000000000000000000000000;;	  case $opt in
0000000000000000000000000000000000000000;;	    h)
0000000000000000000000000000000000000000;;	      kube::test::usage
0000000000000000000000000000000000000000;;	      exit 0
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    p)
0000000000000000000000000000000000000000;;	      PARALLEL="$OPTARG"
0000000000000000000000000000000000000000;;	      if ! isnum "${PARALLEL}" || [[ "${PARALLEL}" -le 0 ]]; then
0000000000000000000000000000000000000000;;	        kube::log::usage "'$0': argument to -p must be numeric and greater than 0"
0000000000000000000000000000000000000000;;	        kube::test::usage
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    i)
0000000000000000000000000000000000000000;;	      kube::log::usage "'$0': use GOFLAGS='-count <num-iterations>'"
0000000000000000000000000000000000000000;;	      kube::test::usage
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    ?)
0000000000000000000000000000000000000000;;	      kube::test::usage
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	    :)
0000000000000000000000000000000000000000;;	      kube::log::usage "Option -$OPTARG <value>"
0000000000000000000000000000000000000000;;	      kube::test::usage
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	      ;;
0000000000000000000000000000000000000000;;	  esac
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	shift $((OPTIND - 1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Use eval to preserve embedded quoted strings.
0000000000000000000000000000000000000000;;	eval "goflags=(${GOFLAGS:-})"
0000000000000000000000000000000000000000;;	eval "testargs=(${KUBE_TEST_ARGS:-})"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Used to filter verbose test output.
0000000000000000000000000000000000000000;;	go_test_grep_pattern=".*"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The go-junit-report tool needs full test case information to produce a
0000000000000000000000000000000000000000;;	# meaningful report.
0000000000000000000000000000000000000000;;	if [[ -n "${KUBE_JUNIT_REPORT_DIR}" ]] ; then
0000000000000000000000000000000000000000;;	  goflags+=(-v)
0000000000000000000000000000000000000000;;	  # Show only summary lines by matching lines like "status package/test"
0000000000000000000000000000000000000000;;	  go_test_grep_pattern="^[^[:space:]]\+[[:space:]]\+[^[:space:]]\+/[^[[:space:]]\+"
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Filter out arguments that start with "-" and move them to goflags.
0000000000000000000000000000000000000000;;	testcases=()
0000000000000000000000000000000000000000;;	for arg; do
0000000000000000000000000000000000000000;;	  if [[ "${arg}" == -* ]]; then
0000000000000000000000000000000000000000;;	    goflags+=("${arg}")
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    testcases+=("${arg}")
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	if [[ ${#testcases[@]} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	  testcases=($(kube::test::find_dirs))
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	set -- "${testcases[@]+${testcases[@]}}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	junitFilenamePrefix() {
0000000000000000000000000000000000000000;;	  if [[ -z "${KUBE_JUNIT_REPORT_DIR}" ]]; then
0000000000000000000000000000000000000000;;	    echo ""
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  mkdir -p "${KUBE_JUNIT_REPORT_DIR}"
0000000000000000000000000000000000000000;;	  # This filename isn't parsed by anything, and we must avoid
0000000000000000000000000000000000000000;;	  # exceeding 255 character filename limit. KUBE_TEST_API
0000000000000000000000000000000000000000;;	  # barely fits there and in coverage mode test names are
0000000000000000000000000000000000000000;;	  # appended to generated file names, easily exceeding
0000000000000000000000000000000000000000;;	  # 255 chars in length. So let's just use a sha1 hash of it.
0000000000000000000000000000000000000000;;	  local KUBE_TEST_API_HASH="$(echo -n "${KUBE_TEST_API//\//-}"| ${SHA1SUM} |awk '{print $1}')"
0000000000000000000000000000000000000000;;	  echo "${KUBE_JUNIT_REPORT_DIR}/junit_${KUBE_TEST_API_HASH}_$(kube::util::sortable_date)"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	produceJUnitXMLReport() {
0000000000000000000000000000000000000000;;	  local -r junit_filename_prefix=$1
0000000000000000000000000000000000000000;;	  if [[ -z "${junit_filename_prefix}" ]]; then
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  local test_stdout_filenames
0000000000000000000000000000000000000000;;	  local junit_xml_filename
0000000000000000000000000000000000000000;;	  test_stdout_filenames=$(ls ${junit_filename_prefix}*.stdout)
0000000000000000000000000000000000000000;;	  junit_xml_filename="${junit_filename_prefix}.xml"
0000000000000000000000000000000000000000;;	  if ! command -v go-junit-report >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	    kube::log::error "go-junit-report not found; please install with " \
0000000000000000000000000000000000000000;;	      "go get -u github.com/jstemmer/go-junit-report"
0000000000000000000000000000000000000000;;	    return
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  cat ${test_stdout_filenames} | go-junit-report > "${junit_xml_filename}"
0000000000000000000000000000000000000000;;	  if [[ ! ${KUBE_KEEP_VERBOSE_TEST_OUTPUT} =~ ^[yY]$ ]]; then
0000000000000000000000000000000000000000;;	    rm ${test_stdout_filenames}
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  kube::log::status "Saved JUnit XML test report to ${junit_xml_filename}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	runTests() {
0000000000000000000000000000000000000000;;	  local junit_filename_prefix
0000000000000000000000000000000000000000;;	  junit_filename_prefix=$(junitFilenamePrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # If we're not collecting coverage, run all requested tests with one 'go test'
0000000000000000000000000000000000000000;;	  # command, which is much faster.
0000000000000000000000000000000000000000;;	  if [[ ! ${KUBE_COVER} =~ ^[yY]$ ]]; then
0000000000000000000000000000000000000000;;	    kube::log::status "Running tests without code coverage"
0000000000000000000000000000000000000000;;	    # `go test` does not install the things it builds. `go test -i` installs
0000000000000000000000000000000000000000;;	    # the build artifacts but doesn't run the tests.  The two together provide
0000000000000000000000000000000000000000;;	    # a large speedup for tests that do not need to be rebuilt.
0000000000000000000000000000000000000000;;	    go test -i "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	      ${KUBE_RACE} ${KUBE_TIMEOUT} "${@}" \
0000000000000000000000000000000000000000;;	     "${testargs[@]:+${testargs[@]}}"
0000000000000000000000000000000000000000;;	    go test "${goflags[@]:+${goflags[@]}}" \
0000000000000000000000000000000000000000;;	      ${KUBE_RACE} ${KUBE_TIMEOUT} "${@}" \
0000000000000000000000000000000000000000;;	     "${testargs[@]:+${testargs[@]}}" \
0000000000000000000000000000000000000000;;	     | tee ${junit_filename_prefix:+"${junit_filename_prefix}.stdout"} \
0000000000000000000000000000000000000000;;	     | grep "${go_test_grep_pattern}" && rc=$? || rc=$?
0000000000000000000000000000000000000000;;	    produceJUnitXMLReport "${junit_filename_prefix}"
0000000000000000000000000000000000000000;;	    return ${rc}
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Create coverage report directories.
0000000000000000000000000000000000000000;;	  KUBE_TEST_API_HASH="$(echo -n "${KUBE_TEST_API//\//-}"| ${SHA1SUM} |awk '{print $1}')"
0000000000000000000000000000000000000000;;	  cover_report_dir="/tmp/k8s_coverage/${KUBE_TEST_API_HASH}/$(kube::util::sortable_date)"
0000000000000000000000000000000000000000;;	  cover_profile="coverage.out"  # Name for each individual coverage profile
0000000000000000000000000000000000000000;;	  kube::log::status "Saving coverage output in '${cover_report_dir}'"
0000000000000000000000000000000000000000;;	  mkdir -p "${@+${@/#/${cover_report_dir}/}}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # Run all specified tests, collecting coverage results. Go currently doesn't
0000000000000000000000000000000000000000;;	  # support collecting coverage across multiple packages at once, so we must issue
0000000000000000000000000000000000000000;;	  # separate 'go test' commands for each package and then combine at the end.
0000000000000000000000000000000000000000;;	  # To speed things up considerably, we can at least use xargs -P to run multiple
0000000000000000000000000000000000000000;;	  # 'go test' commands at once.
0000000000000000000000000000000000000000;;	  # To properly parse the test results if generating a JUnit test report, we
0000000000000000000000000000000000000000;;	  # must make sure the output from PARALLEL runs is not mixed. To achieve this,
0000000000000000000000000000000000000000;;	  # we spawn a subshell for each PARALLEL process, redirecting the output to
0000000000000000000000000000000000000000;;	  # separate files.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # ignore paths:
0000000000000000000000000000000000000000;;	  # cmd/libs/go2idl/generator: is fragile when run under coverage, so ignore it for now.
0000000000000000000000000000000000000000;;	  #                            https://github.com/kubernetes/kubernetes/issues/24967
0000000000000000000000000000000000000000;;	  # vendor/k8s.io/client-go/1.4/rest: causes cover internal errors
0000000000000000000000000000000000000000;;	  #                            https://github.com/golang/go/issues/16540
0000000000000000000000000000000000000000;;	  cover_ignore_dirs="cmd/libs/go2idl/generator|vendor/k8s.io/client-go/1.4/rest"
0000000000000000000000000000000000000000;;	  for path in $(echo $cover_ignore_dirs | sed 's/|/ /g'); do
0000000000000000000000000000000000000000;;	      echo -e "skipped\tk8s.io/kubernetes/$path"
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  #
0000000000000000000000000000000000000000;;	  # `go test` does not install the things it builds. `go test -i` installs
0000000000000000000000000000000000000000;;	  # the build artifacts but doesn't run the tests.  The two together provide
0000000000000000000000000000000000000000;;	  # a large speedup for tests that do not need to be rebuilt.
0000000000000000000000000000000000000000;;	  printf "%s\n" "${@}" \
0000000000000000000000000000000000000000;;	    | grep -Ev $cover_ignore_dirs \
0000000000000000000000000000000000000000;;	    | xargs -I{} -n 1 -P ${KUBE_COVERPROCS} \
0000000000000000000000000000000000000000;;	    bash -c "set -o pipefail; _pkg=\"\$0\"; _pkg_out=\${_pkg//\//_}; \
0000000000000000000000000000000000000000;;	      go test -i ${goflags[@]:+${goflags[@]}} \
0000000000000000000000000000000000000000;;	        ${KUBE_RACE} \
0000000000000000000000000000000000000000;;	        ${KUBE_TIMEOUT} \
0000000000000000000000000000000000000000;;	        -cover -covermode=\"${KUBE_COVERMODE}\" \
0000000000000000000000000000000000000000;;	        -coverprofile=\"${cover_report_dir}/\${_pkg}/${cover_profile}\" \
0000000000000000000000000000000000000000;;	        \"\${_pkg}\" \
0000000000000000000000000000000000000000;;	        ${testargs[@]:+${testargs[@]}}
0000000000000000000000000000000000000000;;	      go test ${goflags[@]:+${goflags[@]}} \
0000000000000000000000000000000000000000;;	        ${KUBE_RACE} \
0000000000000000000000000000000000000000;;	        ${KUBE_TIMEOUT} \
0000000000000000000000000000000000000000;;	        -cover -covermode=\"${KUBE_COVERMODE}\" \
0000000000000000000000000000000000000000;;	        -coverprofile=\"${cover_report_dir}/\${_pkg}/${cover_profile}\" \
0000000000000000000000000000000000000000;;	        \"\${_pkg}\" \
0000000000000000000000000000000000000000;;	        ${testargs[@]:+${testargs[@]}} \
0000000000000000000000000000000000000000;;	      | tee ${junit_filename_prefix:+\"${junit_filename_prefix}-\$_pkg_out.stdout\"} \
0000000000000000000000000000000000000000;;	      | grep \"${go_test_grep_pattern}\"" \
0000000000000000000000000000000000000000;;	    {} \
0000000000000000000000000000000000000000;;	    && test_result=$? || test_result=$?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  produceJUnitXMLReport "${junit_filename_prefix}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  COMBINED_COVER_PROFILE="${cover_report_dir}/combined-coverage.out"
0000000000000000000000000000000000000000;;	  {
0000000000000000000000000000000000000000;;	    # The combined coverage profile needs to start with a line indicating which
0000000000000000000000000000000000000000;;	    # coverage mode was used (set, count, or atomic). This line is included in
0000000000000000000000000000000000000000;;	    # each of the coverage profiles generated when running 'go test -cover', but
0000000000000000000000000000000000000000;;	    # we strip these lines out when combining so that there's only one.
0000000000000000000000000000000000000000;;	    echo "mode: ${KUBE_COVERMODE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # Include all coverage reach data in the combined profile, but exclude the
0000000000000000000000000000000000000000;;	    # 'mode' lines, as there should be only one.
0000000000000000000000000000000000000000;;	    for x in `find "${cover_report_dir}" -name "${cover_profile}"`; do
0000000000000000000000000000000000000000;;	      cat $x | grep -h -v "^mode:" || true
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	  } >"${COMBINED_COVER_PROFILE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  coverage_html_file="${cover_report_dir}/combined-coverage.html"
0000000000000000000000000000000000000000;;	  go tool cover -html="${COMBINED_COVER_PROFILE}" -o="${coverage_html_file}"
0000000000000000000000000000000000000000;;	  kube::log::status "Combined coverage report: ${coverage_html_file}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  return ${test_result}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	reportCoverageToCoveralls() {
0000000000000000000000000000000000000000;;	  if [[ ${KUBE_COVER} =~ ^[yY]$ ]] && [[ -x "${KUBE_GOVERALLS_BIN}" ]]; then
0000000000000000000000000000000000000000;;	    kube::log::status "Reporting coverage results to Coveralls for service ${CI_NAME:-}"
0000000000000000000000000000000000000000;;	    ${KUBE_GOVERALLS_BIN} -coverprofile="${COMBINED_COVER_PROFILE}" \
0000000000000000000000000000000000000000;;	    ${CI_NAME:+"-service=${CI_NAME}"} \
0000000000000000000000000000000000000000;;	    ${COVERALLS_REPO_TOKEN:+"-repotoken=${COVERALLS_REPO_TOKEN}"} \
0000000000000000000000000000000000000000;;	      || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	checkFDs() {
0000000000000000000000000000000000000000;;	  # several unittests panic when httptest cannot open more sockets
0000000000000000000000000000000000000000;;	  # due to the low default files limit on OS X.  Warn about low limit.
0000000000000000000000000000000000000000;;	  local fileslimit="$(ulimit -n)"
0000000000000000000000000000000000000000;;	  if [[ $fileslimit -lt 1000 ]]; then
0000000000000000000000000000000000000000;;	    echo "WARNING: ulimit -n (files) should be at least 1000, is $fileslimit, may cause test failure";
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	checkFDs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Convert the CSVs to arrays.
0000000000000000000000000000000000000000;;	IFS=';' read -a apiVersions <<< "${KUBE_TEST_API_VERSIONS}"
0000000000000000000000000000000000000000;;	apiVersionsCount=${#apiVersions[@]}
0000000000000000000000000000000000000000;;	for (( i=0; i<${apiVersionsCount}; i++ )); do
0000000000000000000000000000000000000000;;	  apiVersion=${apiVersions[i]}
0000000000000000000000000000000000000000;;	  echo "Running tests for APIVersion: $apiVersion"
0000000000000000000000000000000000000000;;	  # KUBE_TEST_API sets the version of each group to be tested.
0000000000000000000000000000000000000000;;	  KUBE_TEST_API="${apiVersion}" runTests "$@"
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# We might run the tests for multiple versions, but we want to report only
0000000000000000000000000000000000000000;;	# one of them to coveralls. Here we report coverage from the last run.
0000000000000000000000000000000000000000;;	reportCoverageToCoveralls
