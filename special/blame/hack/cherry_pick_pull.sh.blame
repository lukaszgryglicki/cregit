0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Checkout a PR from GitHub. (Yes, this is sitting in a Git tree. How
0000000000000000000000000000000000000000;;	# meta.) Assumes you care about pulls from remote "upstream" and
0000000000000000000000000000000000000000;;	# checks thems out to a branch named:
0000000000000000000000000000000000000000;;	#  automated-cherry-pick-of-<pr>-<target branch>-<timestamp>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	declare -r KUBE_ROOT="$(dirname "${BASH_SOURCE}")/.."
0000000000000000000000000000000000000000;;	cd "${KUBE_ROOT}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	declare -r STARTINGBRANCH=$(git symbolic-ref --short HEAD)
0000000000000000000000000000000000000000;;	declare -r REBASEMAGIC="${KUBE_ROOT}/.git/rebase-apply"
0000000000000000000000000000000000000000;;	DRY_RUN=${DRY_RUN:-""}
0000000000000000000000000000000000000000;;	UPSTREAM_REMOTE=${UPSTREAM_REMOTE:-upstream}
0000000000000000000000000000000000000000;;	FORK_REMOTE=${FORK_REMOTE:-origin}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ -z ${GITHUB_USER:-} ]]; then
0000000000000000000000000000000000000000;;	  echo "Please export GITHUB_USER=<your-user> (or GH organization, if that's where your fork lives)"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if ! which hub > /dev/null; then
0000000000000000000000000000000000000000;;	  echo "Can't find 'hub' tool in PATH, please install from https://github.com/github/hub"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ "$#" -lt 2 ]]; then
0000000000000000000000000000000000000000;;	  echo "${0} <remote branch> <pr-number>...: cherry pick one or more <pr> onto <remote branch> and leave instructions for proposing pull request"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  Checks out <remote branch> and handles the cherry-pick of <pr> (possibly multiple) for you."
0000000000000000000000000000000000000000;;	  echo "  Examples:"
0000000000000000000000000000000000000000;;	  echo "    $0 upstream/release-3.14 12345        # Cherry-picks PR 12345 onto upstream/release-3.14 and proposes that as a PR."
0000000000000000000000000000000000000000;;	  echo "    $0 upstream/release-3.14 12345 56789  # Cherry-picks PR 12345, then 56789 and proposes the combination as a single PR."
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  Set the DRY_RUN environment var to skip git push and creating PR."
0000000000000000000000000000000000000000;;	  echo "  This is useful for creating patches to a release branch without making a PR."
0000000000000000000000000000000000000000;;	  echo "  When DRY_RUN is set the script will leave you in a branch containing the commits you cherry-picked."
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo " Set UPSTREAM_REMOTE (default: upstream) and FORK_REMOTE (default: origin)"
0000000000000000000000000000000000000000;;	  echo " To override the default remote names to what you have locally."
0000000000000000000000000000000000000000;;	  exit 2
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if git_status=$(git status --porcelain --untracked=no 2>/dev/null) && [[ -n "${git_status}" ]]; then
0000000000000000000000000000000000000000;;	  echo "!!! Dirty tree. Clean up and try again."
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ -e "${REBASEMAGIC}" ]]; then
0000000000000000000000000000000000000000;;	  echo "!!! 'git rebase' or 'git am' in progress. Clean up and try again."
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	declare -r BRANCH="$1"
0000000000000000000000000000000000000000;;	shift 1
0000000000000000000000000000000000000000;;	declare -r PULLS=( "$@" )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function join { local IFS="$1"; shift; echo "$*"; }
0000000000000000000000000000000000000000;;	declare -r PULLDASH=$(join - "${PULLS[@]/#/#}") # Generates something like "#12345-#56789"
0000000000000000000000000000000000000000;;	declare -r PULLSUBJ=$(join " " "${PULLS[@]/#/#}") # Generates something like "#12345 #56789"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "+++ Updating remotes..."
0000000000000000000000000000000000000000;;	git remote update "${UPSTREAM_REMOTE}" "${FORK_REMOTE}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if ! git log -n1 --format=%H "${BRANCH}" >/dev/null 2>&1; then
0000000000000000000000000000000000000000;;	  echo "!!! '${BRANCH}' not found. The second argument should be something like ${UPSTREAM_REMOTE}/release-0.21."
0000000000000000000000000000000000000000;;	  echo "    (In particular, it needs to be a valid, existing remote branch that I can 'git checkout'.)"
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	declare -r NEWBRANCHREQ="automated-cherry-pick-of-${PULLDASH}" # "Required" portion for tools.
0000000000000000000000000000000000000000;;	declare -r NEWBRANCH="$(echo "${NEWBRANCHREQ}-${BRANCH}" | sed 's/\//-/g')"
0000000000000000000000000000000000000000;;	declare -r NEWBRANCHUNIQ="${NEWBRANCH}-$(date +%s)"
0000000000000000000000000000000000000000;;	echo "+++ Creating local branch ${NEWBRANCHUNIQ}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	cleanbranch=""
0000000000000000000000000000000000000000;;	prtext=""
0000000000000000000000000000000000000000;;	gitamcleanup=false
0000000000000000000000000000000000000000;;	function return_to_kansas {
0000000000000000000000000000000000000000;;	  if [[ "${gitamcleanup}" == "true" ]]; then
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "+++ Aborting in-progress git am."
0000000000000000000000000000000000000000;;	    git am --abort >/dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # return to the starting branch and delete the PR text file
0000000000000000000000000000000000000000;;	  if [[ -z "${DRY_RUN}" ]]; then
0000000000000000000000000000000000000000;;	    echo
0000000000000000000000000000000000000000;;	    echo "+++ Returning you to the ${STARTINGBRANCH} branch and cleaning up."
0000000000000000000000000000000000000000;;	    git checkout -f "${STARTINGBRANCH}" >/dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	    if [[ -n "${cleanbranch}" ]]; then
0000000000000000000000000000000000000000;;	      git branch -D "${cleanbranch}" >/dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    if [[ -n "${prtext}" ]]; then
0000000000000000000000000000000000000000;;	      rm "${prtext}"
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	trap return_to_kansas EXIT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	SUBJECTS=()
0000000000000000000000000000000000000000;;	function make-a-pr() {
0000000000000000000000000000000000000000;;	  local rel="$(basename "${BRANCH}")"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "+++ Creating a pull request on GitHub at ${GITHUB_USER}:${NEWBRANCH}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # This looks like an unnecessary use of a tmpfile, but it avoids
0000000000000000000000000000000000000000;;	  # https://github.com/github/hub/issues/976 Otherwise stdin is stolen
0000000000000000000000000000000000000000;;	  # when we shove the heredoc at hub directly, tickling the ioctl
0000000000000000000000000000000000000000;;	  # crash.
0000000000000000000000000000000000000000;;	  prtext="$(mktemp -t prtext.XXXX)" # cleaned in return_to_kansas
0000000000000000000000000000000000000000;;	  cat >"${prtext}" <<EOF
0000000000000000000000000000000000000000;;	Automated cherry pick of ${PULLSUBJ}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cherry pick of ${PULLSUBJ} on ${rel}.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	$(printf '%s\n' "${SUBJECTS[@]}")
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  hub pull-request -F "${prtext}" -h "${GITHUB_USER}:${NEWBRANCH}" -b "kubernetes:${rel}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	git checkout -b "${NEWBRANCHUNIQ}" "${BRANCH}"
0000000000000000000000000000000000000000;;	cleanbranch="${NEWBRANCHUNIQ}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	gitamcleanup=true
0000000000000000000000000000000000000000;;	for pull in "${PULLS[@]}"; do
0000000000000000000000000000000000000000;;	  echo "+++ Downloading patch to /tmp/${pull}.patch (in case you need to do this again)"
0000000000000000000000000000000000000000;;	  curl -o "/tmp/${pull}.patch" -sSL "http://pr.k8s.io/${pull}.patch"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "+++ About to attempt cherry pick of PR. To reattempt:"
0000000000000000000000000000000000000000;;	  echo "  $ git am -3 /tmp/${pull}.patch"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  git am -3 "/tmp/${pull}.patch" || {
0000000000000000000000000000000000000000;;	    conflicts=false
0000000000000000000000000000000000000000;;	    while unmerged=$(git status --porcelain | grep ^U) && [[ -n ${unmerged} ]] \
0000000000000000000000000000000000000000;;	      || [[ -e "${REBASEMAGIC}" ]]; do
0000000000000000000000000000000000000000;;	      conflicts=true # <-- We should have detected conflicts once
0000000000000000000000000000000000000000;;	      echo
0000000000000000000000000000000000000000;;	      echo "+++ Conflicts detected:"
0000000000000000000000000000000000000000;;	      echo
0000000000000000000000000000000000000000;;	      (git status --porcelain | grep ^U) || echo "!!! None. Did you git am --continue?"
0000000000000000000000000000000000000000;;	      echo
0000000000000000000000000000000000000000;;	      echo "+++ Please resolve the conflicts in another window (and remember to 'git add / git am --continue')"
0000000000000000000000000000000000000000;;	      read -p "+++ Proceed (anything but 'y' aborts the cherry-pick)? [y/n] " -r
0000000000000000000000000000000000000000;;	      echo
0000000000000000000000000000000000000000;;	      if ! [[ "${REPLY}" =~ ^[yY]$ ]]; then
0000000000000000000000000000000000000000;;	        echo "Aborting." >&2
0000000000000000000000000000000000000000;;	        exit 1
0000000000000000000000000000000000000000;;	      fi
0000000000000000000000000000000000000000;;	    done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    if [[ "${conflicts}" != "true" ]]; then
0000000000000000000000000000000000000000;;	      echo "!!! git am failed, likely because of an in-progress 'git am' or 'git rebase'"
0000000000000000000000000000000000000000;;	      exit 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # set the subject
0000000000000000000000000000000000000000;;	  subject=$(grep -m 1 "^Subject" "/tmp/${pull}.patch" | sed -e 's/Subject: \[PATCH//g' | sed 's/.*] //')
0000000000000000000000000000000000000000;;	  SUBJECTS+=("#${pull}: ${subject}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # remove the patch file from /tmp
0000000000000000000000000000000000000000;;	  rm -f "/tmp/${pull}.patch"
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	gitamcleanup=false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Re-generate docs (if needed)
0000000000000000000000000000000000000000;;	echo
0000000000000000000000000000000000000000;;	echo "Regenerating docs..."
0000000000000000000000000000000000000000;;	if ! hack/generate-docs.sh; then
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "hack/generate-docs.sh FAILED to complete."
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [[ -n "${DRY_RUN}" ]]; then
0000000000000000000000000000000000000000;;	  echo "!!! Skipping git push and PR creation because you set DRY_RUN."
0000000000000000000000000000000000000000;;	  echo "To return to the branch you were in when you invoked this script:"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  git checkout ${STARTINGBRANCH}"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "To delete this branch:"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  git branch -D ${NEWBRANCHUNIQ}"
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if git remote -v | grep ^${FORK_REMOTE} | grep kubernetes/kubernetes.git; then
0000000000000000000000000000000000000000;;	  echo "!!! You have ${FORK_REMOTE} configured as your kubernetes/kubernetes.git"
0000000000000000000000000000000000000000;;	  echo "This isn't normal. Leaving you with push instructions:"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "+++ First manually push the branch this script created:"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "  git push REMOTE ${NEWBRANCHUNIQ}:${NEWBRANCH}"
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  echo "where REMOTE is your personal fork (maybe ${UPSTREAM_REMOTE}? Consider swapping those.)."
0000000000000000000000000000000000000000;;	  echo "OR consider setting UPSTREAM_REMOTE and FORK_REMOTE to different values."
0000000000000000000000000000000000000000;;	  echo
0000000000000000000000000000000000000000;;	  make-a-pr
0000000000000000000000000000000000000000;;	  cleanbranch=""
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo
0000000000000000000000000000000000000000;;	echo "+++ I'm about to do the following to push to GitHub (and I'm assuming ${FORK_REMOTE} is your personal fork):"
0000000000000000000000000000000000000000;;	echo
0000000000000000000000000000000000000000;;	echo "  git push ${FORK_REMOTE} ${NEWBRANCHUNIQ}:${NEWBRANCH}"
0000000000000000000000000000000000000000;;	echo
0000000000000000000000000000000000000000;;	read -p "+++ Proceed (anything but 'y' aborts the cherry-pick)? [y/n] " -r
0000000000000000000000000000000000000000;;	if ! [[ "${REPLY}" =~ ^[yY]$ ]]; then
0000000000000000000000000000000000000000;;	  echo "Aborting." >&2
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	git push "${FORK_REMOTE}" -f "${NEWBRANCHUNIQ}:${NEWBRANCH}"
0000000000000000000000000000000000000000;;	make-a-pr
