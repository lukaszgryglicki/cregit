0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bf37a47e5e0bf35392951e3bdc2dfd9c66a76118;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// seed for rand.Source to generate data for files
0000000000000000000000000000000000000000;;		seed int64 = 42
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1K binary file
0000000000000000000000000000000000000000;;		binLen = 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Directory of the test package relative to $GOPATH
0000000000000000000000000000000000000000;;		testImportDir = "example.com/proj/pkg"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		pastHour = time.Now().Add(-1 * time.Hour)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The test package we are testing against
0000000000000000000000000000000000000000;;		testPkg = path.Join(testImportDir, "test")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakegolist implements the `golist` interface providing fake package information for testing.
0000000000000000000000000000000000000000;;	type fakegolist struct {
0000000000000000000000000000000000000000;;		dir       string
0000000000000000000000000000000000000000;;		importMap map[string]pkg
0000000000000000000000000000000000000000;;		testFiles []string
0000000000000000000000000000000000000000;;		binfile   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakegolist() (*fakegolist, error) {
0000000000000000000000000000000000000000;;		dir, err := ioutil.TempDir("", "teststale")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// test can't proceed without a temp directory.
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create a temp directory for testing: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the temp directory as the $GOPATH
0000000000000000000000000000000000000000;;		if err := os.Setenv("GOPATH", dir); err != nil {
0000000000000000000000000000000000000000;;			// can't proceed without pointing the $GOPATH to the temp directory.
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to set \"$GOPATH\" pointing to %q: %v", dir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup $GOPATH directory layout.
0000000000000000000000000000000000000000;;		// Yeah! I am bored of repeatedly writing "if err != nil {}"!
0000000000000000000000000000000000000000;;		if os.MkdirAll(filepath.Join(dir, "bin"), 0750) != nil ||
0000000000000000000000000000000000000000;;			os.MkdirAll(filepath.Join(dir, "pkg", "linux_amd64"), 0750) != nil ||
0000000000000000000000000000000000000000;;			os.MkdirAll(filepath.Join(dir, "src"), 0750) != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to setup the $GOPATH directory structure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a temp file to represent the test binary.
0000000000000000000000000000000000000000;;		binfile, err := ioutil.TempFile("", "testbin")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create the temp file to represent the test binary: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Could have used crypto/rand instead, but it doesn't matter.
0000000000000000000000000000000000000000;;		rr := rand.New(rand.NewSource(42))
0000000000000000000000000000000000000000;;		bin := make([]byte, binLen)
0000000000000000000000000000000000000000;;		if _, err = rr.Read(bin); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't read from the random source: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := binfile.Write(bin); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't write to the binary file %q: %v", binfile.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binfile.Close(); err != nil {
0000000000000000000000000000000000000000;;			// It is arguable whether this should be fatal.
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to close the binary file %q: %v", binfile.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.Chtimes(binfile.Name(), time.Now(), time.Now()); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to modify the mtime of the binary file %q: %v", binfile.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create test source files directory.
0000000000000000000000000000000000000000;;		testdir := filepath.Join(dir, "src", testPkg)
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(testdir, 0750); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create test source directory %q: %v", testdir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fgl := &fakegolist{
0000000000000000000000000000000000000000;;			dir: dir,
0000000000000000000000000000000000000000;;			importMap: map[string]pkg{
0000000000000000000000000000000000000000;;				"example.com/proj/pkg/test": {
0000000000000000000000000000000000000000;;					Dir:        path.Join(dir, "src", testPkg),
0000000000000000000000000000000000000000;;					ImportPath: testPkg,
0000000000000000000000000000000000000000;;					Target:     path.Join(dir, "pkg", "linux_amd64", testImportDir, "test.a"),
0000000000000000000000000000000000000000;;					Stale:      false,
0000000000000000000000000000000000000000;;					TestGoFiles: []string{
0000000000000000000000000000000000000000;;						"foo_test.go",
0000000000000000000000000000000000000000;;						"bar_test.go",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					TestImports: []string{
0000000000000000000000000000000000000000;;						"example.com/proj/pkg/p1",
0000000000000000000000000000000000000000;;						"example.com/proj/pkg/p1/c11",
0000000000000000000000000000000000000000;;						"example.com/proj/pkg/p2",
0000000000000000000000000000000000000000;;						"example.com/proj/cmd/p3/c12/c23",
0000000000000000000000000000000000000000;;						"strings",
0000000000000000000000000000000000000000;;						"testing",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					XTestGoFiles: []string{
0000000000000000000000000000000000000000;;						"xfoo_test.go",
0000000000000000000000000000000000000000;;						"xbar_test.go",
0000000000000000000000000000000000000000;;						"xbaz_test.go",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					XTestImports: []string{
0000000000000000000000000000000000000000;;						"example.com/proj/pkg/test",
0000000000000000000000000000000000000000;;						"example.com/proj/pkg/p1",
0000000000000000000000000000000000000000;;						"example.com/proj/cmd/p3/c12/c23",
0000000000000000000000000000000000000000;;						"os",
0000000000000000000000000000000000000000;;						"testing",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				"example.com/proj/pkg/p1":         {Stale: false},
0000000000000000000000000000000000000000;;				"example.com/proj/pkg/p1/c11":     {Stale: false},
0000000000000000000000000000000000000000;;				"example.com/proj/pkg/p2":         {Stale: false},
0000000000000000000000000000000000000000;;				"example.com/proj/cmd/p3/c12/c23": {Stale: false},
0000000000000000000000000000000000000000;;				"strings":                         {Stale: false},
0000000000000000000000000000000000000000;;				"testing":                         {Stale: false},
0000000000000000000000000000000000000000;;				"os":                              {Stale: false},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			testFiles: []string{
0000000000000000000000000000000000000000;;				"foo_test.go",
0000000000000000000000000000000000000000;;				"bar_test.go",
0000000000000000000000000000000000000000;;				"xfoo_test.go",
0000000000000000000000000000000000000000;;				"xbar_test.go",
0000000000000000000000000000000000000000;;				"xbaz_test.go",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			binfile: binfile.Name(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create test source files.
0000000000000000000000000000000000000000;;		for _, fn := range fgl.testFiles {
0000000000000000000000000000000000000000;;			fp := filepath.Join(testdir, fn)
0000000000000000000000000000000000000000;;			if _, err := os.Create(fp); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to create the test file %q: %v", fp, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := os.Chtimes(fp, time.Now(), pastHour); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to modify the mtime of the test file %q: %v", binfile.Name(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fgl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fgl *fakegolist) pkgInfo(pkgPaths []string) ([]pkg, error) {
0000000000000000000000000000000000000000;;		var pkgs []pkg
0000000000000000000000000000000000000000;;		for _, path := range pkgPaths {
0000000000000000000000000000000000000000;;			p, ok := fgl.importMap[path]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("package %q not found", path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pkgs = append(pkgs, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pkgs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fgl *fakegolist) chMtime(filename string, mtime time.Time) error {
0000000000000000000000000000000000000000;;		for _, fn := range fgl.testFiles {
0000000000000000000000000000000000000000;;			if fn == filename {
0000000000000000000000000000000000000000;;				fp := filepath.Join(fgl.dir, "src", testPkg, fn)
0000000000000000000000000000000000000000;;				if err := os.Chtimes(fp, time.Now(), mtime); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to modify the mtime of %q: %v", filename, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("file %q not found", filename)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fgl *fakegolist) chStale(pkg string, stale bool) error {
0000000000000000000000000000000000000000;;		if p, ok := fgl.importMap[pkg]; ok {
0000000000000000000000000000000000000000;;			p.Stale = stale
0000000000000000000000000000000000000000;;			fgl.importMap[pkg] = p
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("package %q not found", pkg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fgl *fakegolist) cleanup() {
0000000000000000000000000000000000000000;;		os.RemoveAll(fgl.dir)
0000000000000000000000000000000000000000;;		os.Remove(fgl.binfile)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsTestStale(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			fileMtime    map[string]time.Time
0000000000000000000000000000000000000000;;			pkgStaleness map[string]bool
0000000000000000000000000000000000000000;;			result       bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Basic test: binary is fresh, all modifications were before the binary was built.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				result: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// A local test file is new, hence binary must be stale.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fileMtime: map[string]time.Time{
0000000000000000000000000000000000000000;;					"foo_test.go": time.Now().Add(1 * time.Hour),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Test package is new, so binary must be stale.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pkgStaleness: map[string]bool{
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/test": true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Test package dependencies are new, so binary must be stale.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pkgStaleness: map[string]bool{
0000000000000000000000000000000000000000;;					"example.com/proj/cmd/p3/c12/c23": true,
0000000000000000000000000000000000000000;;					"strings":                         true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// External test files are new, hence binary must be stale.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fileMtime: map[string]time.Time{
0000000000000000000000000000000000000000;;					"xfoo_test.go": time.Now().Add(1 * time.Hour),
0000000000000000000000000000000000000000;;					"xbar_test.go": time.Now().Add(2 * time.Hour),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// External test dependency is new, so binary must be stale.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pkgStaleness: map[string]bool{
0000000000000000000000000000000000000000;;					"os": true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Multiple source files and dependencies are new, so binary must be stale.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fileMtime: map[string]time.Time{
0000000000000000000000000000000000000000;;					"foo_test.go":  time.Now().Add(1 * time.Hour),
0000000000000000000000000000000000000000;;					"xfoo_test.go": time.Now().Add(2 * time.Hour),
0000000000000000000000000000000000000000;;					"xbar_test.go": time.Now().Add(3 * time.Hour),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pkgStaleness: map[string]bool{
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/p1":         true,
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/p1/c11":     true,
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/p2":         true,
0000000000000000000000000000000000000000;;					"example.com/proj/cmd/p3/c12/c23": true,
0000000000000000000000000000000000000000;;					"strings":                         true,
0000000000000000000000000000000000000000;;					"os":                              true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Everything is new, so binary must be stale.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				fileMtime: map[string]time.Time{
0000000000000000000000000000000000000000;;					"foo_test.go":  time.Now().Add(3 * time.Hour),
0000000000000000000000000000000000000000;;					"bar_test.go":  time.Now().Add(1 * time.Hour),
0000000000000000000000000000000000000000;;					"xfoo_test.go": time.Now().Add(2 * time.Hour),
0000000000000000000000000000000000000000;;					"xbar_test.go": time.Now().Add(1 * time.Hour),
0000000000000000000000000000000000000000;;					"xbaz_test.go": time.Now().Add(2 * time.Hour),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				pkgStaleness: map[string]bool{
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/p1":         true,
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/p1/c11":     true,
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/p2":         true,
0000000000000000000000000000000000000000;;					"example.com/proj/cmd/p3/c12/c23": true,
0000000000000000000000000000000000000000;;					"example.com/proj/pkg/test":       true,
0000000000000000000000000000000000000000;;					"strings":                         true,
0000000000000000000000000000000000000000;;					"testing":                         true,
0000000000000000000000000000000000000000;;					"os":                              true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			fgl, err := newFakegolist()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("failed to setup the test: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer fgl.cleanup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for fn, mtime := range tc.fileMtime {
0000000000000000000000000000000000000000;;				if err := fgl.chMtime(fn, mtime); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("failed to change the mtime of %q: %v", fn, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for pkg, stale := range tc.pkgStaleness {
0000000000000000000000000000000000000000;;				if err := fgl.chStale(pkg, stale); err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("failed to change the staleness of %q: %v", pkg, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tc.result != isTestStale(fgl, fgl.binfile, testPkg) {
0000000000000000000000000000000000000000;;				if tc.result {
0000000000000000000000000000000000000000;;					t.Errorf("Expected test package %q to be stale", testPkg)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("Expected test package %q to be not stale", testPkg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
