0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6ce6adbcd88bcc6c7376c31d47a897dd31c2ab8f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// teststale checks the staleness of a test binary. go test -c builds a test
0000000000000000000000000000000000000000;;	// binary but it does no staleness check. In other words, every time one runs
0000000000000000000000000000000000000000;;	// go test -c, it compiles the test packages and links the binary even when
0000000000000000000000000000000000000000;;	// nothing has changed. This program helps to mitigate that problem by allowing
0000000000000000000000000000000000000000;;	// to check the staleness of a given test package and its binary.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const usageHelp = "" +
0000000000000000000000000000000000000000;;		`This program checks the staleness of a given test package and its test
0000000000000000000000000000000000000000;;	binary so that one can make a decision about re-building the test binary.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Usage:
0000000000000000000000000000000000000000;;	  teststale -binary=/path/to/test/binary -package=package
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	  teststale -binary="$HOME/gosrc/bin/e2e.test" -package="k8s.io/kubernetes/test/e2e"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		binary  = flag.String("binary", "", "filesystem path to the test binary file. Example: \"$HOME/gosrc/bin/e2e.test\"")
0000000000000000000000000000000000000000;;		pkgPath = flag.String("package", "", "import path of the test package in the format used while importing packages. Example: \"k8s.io/kubernetes/test/e2e\"")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func usage() {
0000000000000000000000000000000000000000;;		fmt.Fprintln(os.Stderr, usageHelp)
0000000000000000000000000000000000000000;;		fmt.Fprintln(os.Stderr, "Flags:")
0000000000000000000000000000000000000000;;		flag.PrintDefaults()
0000000000000000000000000000000000000000;;		os.Exit(2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// golist is an interface emulating the `go list` command to get package information.
0000000000000000000000000000000000000000;;	// TODO: Evaluate using `go/build` package instead. It doesn't provide staleness
0000000000000000000000000000000000000000;;	// information, but we can probably run `go list` and `go/build.Import()` concurrently
0000000000000000000000000000000000000000;;	// in goroutines and merge the results. Evaluate if that's faster.
0000000000000000000000000000000000000000;;	type golist interface {
0000000000000000000000000000000000000000;;		pkgInfo(pkgPaths []string) ([]pkg, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// execmd implements the `golist` interface.
0000000000000000000000000000000000000000;;	type execcmd struct {
0000000000000000000000000000000000000000;;		cmd  string
0000000000000000000000000000000000000000;;		args []string
0000000000000000000000000000000000000000;;		env  []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *execcmd) pkgInfo(pkgPaths []string) ([]pkg, error) {
0000000000000000000000000000000000000000;;		args := append(e.args, pkgPaths...)
0000000000000000000000000000000000000000;;		cmd := exec.Command(e.cmd, args...)
0000000000000000000000000000000000000000;;		cmd.Env = e.env
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stdout, err := cmd.StdoutPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to obtain the metadata output stream: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(stdout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start executing the command
0000000000000000000000000000000000000000;;		if err := cmd.Start(); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("command did not start: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pkgs []pkg
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var p pkg
0000000000000000000000000000000000000000;;			if err := dec.Decode(&p); err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to unmarshal metadata for package %s: %v", p.ImportPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pkgs = append(pkgs, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := cmd.Wait(); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("command did not complete: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pkgs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pkg struct {
0000000000000000000000000000000000000000;;		Dir          string
0000000000000000000000000000000000000000;;		ImportPath   string
0000000000000000000000000000000000000000;;		Target       string
0000000000000000000000000000000000000000;;		Stale        bool
0000000000000000000000000000000000000000;;		TestGoFiles  []string
0000000000000000000000000000000000000000;;		TestImports  []string
0000000000000000000000000000000000000000;;		XTestGoFiles []string
0000000000000000000000000000000000000000;;		XTestImports []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pkg) isNewerThan(cmd golist, buildTime time.Time) bool {
0000000000000000000000000000000000000000;;		// If the package itself is stale, then we have to rebuild the whole thing anyway.
0000000000000000000000000000000000000000;;		if p.Stale {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test for file staleness
0000000000000000000000000000000000000000;;		for _, f := range p.TestGoFiles {
0000000000000000000000000000000000000000;;			if isNewerThan(filepath.Join(p.Dir, f), buildTime) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("test Go file %s is stale", f)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, f := range p.XTestGoFiles {
0000000000000000000000000000000000000000;;			if isNewerThan(filepath.Join(p.Dir, f), buildTime) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("external test Go file %s is stale", f)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imps := []string{}
0000000000000000000000000000000000000000;;		imps = append(imps, p.TestImports...)
0000000000000000000000000000000000000000;;		imps = append(imps, p.XTestImports...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This calls `go list` the second time. This is required because the first
0000000000000000000000000000000000000000;;		// call to `go list` checks the staleness of the package in question by
0000000000000000000000000000000000000000;;		// looking the non-test dependencies, but it doesn't look at the test
0000000000000000000000000000000000000000;;		// dependencies. However, it returns the list of test dependencies. This
0000000000000000000000000000000000000000;;		// second call to `go list` checks the staleness of all the test
0000000000000000000000000000000000000000;;		// dependencies.
0000000000000000000000000000000000000000;;		pkgs, err := cmd.pkgInfo(imps)
0000000000000000000000000000000000000000;;		if err != nil || len(pkgs) < 1 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("failed to obtain metadata for packages %s: %v", imps, err)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range pkgs {
0000000000000000000000000000000000000000;;			if p.Stale {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("import %q is stale", p.ImportPath)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNewerThan(filename string, buildTime time.Time) bool {
0000000000000000000000000000000000000000;;		stat, err := os.Stat(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stat.ModTime().After(buildTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTestStale checks if the test binary is stale and needs to rebuilt.
0000000000000000000000000000000000000000;;	// Some of the ideas here are inspired by how Go does staleness checks.
0000000000000000000000000000000000000000;;	func isTestStale(cmd golist, binPath, pkgPath string) bool {
0000000000000000000000000000000000000000;;		bStat, err := os.Stat(binPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Couldn't obtain the modified time of the binary %s: %v", binPath, err)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buildTime := bStat.ModTime()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pkgs, err := cmd.pkgInfo([]string{pkgPath})
0000000000000000000000000000000000000000;;		if err != nil || len(pkgs) < 1 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Couldn't retrieve test package information for package %s: %v", pkgPath, err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pkgs[0].isNewerThan(cmd, buildTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Usage = usage
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &execcmd{
0000000000000000000000000000000000000000;;			cmd: "go",
0000000000000000000000000000000000000000;;			args: []string{
0000000000000000000000000000000000000000;;				"list",
0000000000000000000000000000000000000000;;				"-json",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			env: os.Environ(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isTestStale(cmd, *binary, *pkgPath) {
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
