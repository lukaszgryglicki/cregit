0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2015 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This is an example script that creates a fully functional vitess cluster.
0000000000000000000000000000000000000000;;	# It performs the following steps:
0000000000000000000000000000000000000000;;	#   - Create etcd clusters
0000000000000000000000000000000000000000;;	#   - Create vtctld pod
0000000000000000000000000000000000000000;;	#   - Create vttablet pods
0000000000000000000000000000000000000000;;	#   - Perform vtctl initialization:
0000000000000000000000000000000000000000;;	#       SetKeyspaceShardingInfo, Rebuild Keyspace, Reparent Shard, Apply Schema
0000000000000000000000000000000000000000;;	#   - Create vtgate pods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	script_root=`dirname "${BASH_SOURCE}"`
0000000000000000000000000000000000000000;;	source $script_root/env.sh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	cells=`echo $CELLS | tr ',' ' '`
0000000000000000000000000000000000000000;;	num_cells=`echo $cells | wc -w`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function update_spinner_value () {
0000000000000000000000000000000000000000;;	  spinner='-\|/'
0000000000000000000000000000000000000000;;	  cur_spinner=${spinner:$(($1%${#spinner})):1}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function wait_for_running_tasks () {
0000000000000000000000000000000000000000;;	  # This function waits for pods to be in the "Running" state
0000000000000000000000000000000000000000;;	  # 1. task_name: Name that the desired task begins with
0000000000000000000000000000000000000000;;	  # 2. num_tasks: Number of tasks to wait for
0000000000000000000000000000000000000000;;	  # Returns:
0000000000000000000000000000000000000000;;	  #   0 if successful, -1 if timed out
0000000000000000000000000000000000000000;;	  task_name=$1
0000000000000000000000000000000000000000;;	  num_tasks=$2
0000000000000000000000000000000000000000;;	  counter=0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  echo "Waiting for ${num_tasks}x $task_name to enter state Running"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  while [ $counter -lt $MAX_TASK_WAIT_RETRIES ]; do
0000000000000000000000000000000000000000;;	    # Get status column of pods with name starting with $task_name,
0000000000000000000000000000000000000000;;	    # count how many are in state Running
0000000000000000000000000000000000000000;;	    num_running=`$KUBECTL get pods | grep ^$task_name | grep Running | wc -l`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    echo -en "\r$task_name: $num_running out of $num_tasks in state Running..."
0000000000000000000000000000000000000000;;	    if [ $num_running -eq $num_tasks ]
0000000000000000000000000000000000000000;;	    then
0000000000000000000000000000000000000000;;	      echo Complete
0000000000000000000000000000000000000000;;	      return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    update_spinner_value $counter
0000000000000000000000000000000000000000;;	    echo -n $cur_spinner
0000000000000000000000000000000000000000;;	    let counter=counter+1
0000000000000000000000000000000000000000;;	    sleep 1
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo Timed out
0000000000000000000000000000000000000000;;	  return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ -z "$GOPATH" ]; then
0000000000000000000000000000000000000000;;	  echo "ERROR: GOPATH undefined, can't obtain vtctlclient"
0000000000000000000000000000000000000000;;	  exit -1
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	export KUBECTL='kubectl'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "Downloading and installing vtctlclient..."
0000000000000000000000000000000000000000;;	go get -u github.com/youtube/vitess/go/cmd/vtctlclient
0000000000000000000000000000000000000000;;	num_shards=`echo $SHARDS | tr "," " " | wc -w`
0000000000000000000000000000000000000000;;	total_tablet_count=$(($num_shards*$TABLETS_PER_SHARD*$num_cells))
0000000000000000000000000000000000000000;;	vtgate_count=$VTGATE_COUNT
0000000000000000000000000000000000000000;;	if [ $vtgate_count -eq 0 ]; then
0000000000000000000000000000000000000000;;	  vtgate_count=$(($total_tablet_count/4>3?$total_tablet_count/4:3))
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "****************************"
0000000000000000000000000000000000000000;;	echo "*Creating vitess cluster:"
0000000000000000000000000000000000000000;;	echo "*  Shards: $SHARDS"
0000000000000000000000000000000000000000;;	echo "*  Tablets per shard: $TABLETS_PER_SHARD"
0000000000000000000000000000000000000000;;	echo "*  Rdonly per shard: $RDONLY_COUNT"
0000000000000000000000000000000000000000;;	echo "*  VTGate count: $vtgate_count"
0000000000000000000000000000000000000000;;	echo "*  Cells: $cells"
0000000000000000000000000000000000000000;;	echo "****************************"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo 'Running etcd-up.sh' && CELLS=$CELLS ./etcd-up.sh
0000000000000000000000000000000000000000;;	wait_for_running_tasks etcd-global 3
0000000000000000000000000000000000000000;;	for cell in $cells; do
0000000000000000000000000000000000000000;;	  wait_for_running_tasks etcd-$cell 3
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo 'Running vtctld-up.sh' && ./vtctld-up.sh
0000000000000000000000000000000000000000;;	echo 'Running vttablet-up.sh' && CELLS=$CELLS ./vttablet-up.sh
0000000000000000000000000000000000000000;;	echo 'Running vtgate-up.sh' && ./vtgate-up.sh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	wait_for_running_tasks vtctld 1
0000000000000000000000000000000000000000;;	wait_for_running_tasks vttablet $total_tablet_count
0000000000000000000000000000000000000000;;	wait_for_running_tasks vtgate $vtgate_count
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	vtctld_port=30001
0000000000000000000000000000000000000000;;	vtctld_ip=`kubectl get -o yaml nodes | grep 'type: ExternalIP' -B 1 | head -1 | awk '{print $NF}'`
0000000000000000000000000000000000000000;;	vtctl_server="$vtctld_ip:$vtctld_port"
0000000000000000000000000000000000000000;;	kvtctl="$GOPATH/bin/vtctlclient -server $vtctl_server"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo Waiting for tablets to be visible in the topology
0000000000000000000000000000000000000000;;	counter=0
0000000000000000000000000000000000000000;;	while [ $counter -lt $MAX_VTTABLET_TOPO_WAIT_RETRIES ]; do
0000000000000000000000000000000000000000;;	  num_tablets=0
0000000000000000000000000000000000000000;;	  for cell in $cells; do
0000000000000000000000000000000000000000;;	    num_tablets=$(($num_tablets+`$kvtctl ListAllTablets $cell | wc -l`))
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	  echo -en "\r$num_tablets out of $total_tablet_count in topology..."
0000000000000000000000000000000000000000;;	  if [ $num_tablets -eq $total_tablet_count ]
0000000000000000000000000000000000000000;;	  then
0000000000000000000000000000000000000000;;	    echo Complete
0000000000000000000000000000000000000000;;	    break
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  update_spinner_value $counter
0000000000000000000000000000000000000000;;	  echo -n $cur_spinner
0000000000000000000000000000000000000000;;	  let counter=counter+1
0000000000000000000000000000000000000000;;	  sleep 1
0000000000000000000000000000000000000000;;	  if [ $counter -eq $MAX_VTTABLET_TOPO_WAIT_RETRIES ]
0000000000000000000000000000000000000000;;	  then
0000000000000000000000000000000000000000;;	    echo Timed out
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# split_shard_count = num_shards for sharded keyspace, 0 for unsharded
0000000000000000000000000000000000000000;;	split_shard_count=$num_shards
0000000000000000000000000000000000000000;;	if [ $split_shard_count -eq 1 ]; then
0000000000000000000000000000000000000000;;	  split_shard_count=0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo -n Setting Keyspace Sharding Info...
0000000000000000000000000000000000000000;;	$kvtctl SetKeyspaceShardingInfo -force -split_shard_count $split_shard_count test_keyspace keyspace_id uint64
0000000000000000000000000000000000000000;;	echo Done
0000000000000000000000000000000000000000;;	echo -n Rebuilding Keyspace Graph...
0000000000000000000000000000000000000000;;	$kvtctl RebuildKeyspaceGraph test_keyspace
0000000000000000000000000000000000000000;;	echo Done
0000000000000000000000000000000000000000;;	echo -n Reparenting...
0000000000000000000000000000000000000000;;	shard_num=1
0000000000000000000000000000000000000000;;	for shard in $(echo $SHARDS | tr "," " "); do
0000000000000000000000000000000000000000;;	  $kvtctl InitShardMaster -force test_keyspace/$shard `echo $cells | awk '{print $1}'`-0000000${shard_num}00
0000000000000000000000000000000000000000;;	  let shard_num=shard_num+1
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	echo Done
0000000000000000000000000000000000000000;;	echo -n Applying Schema...
0000000000000000000000000000000000000000;;	$kvtctl ApplySchema -sql "$(cat create_test_table.sql)" test_keyspace
0000000000000000000000000000000000000000;;	echo Done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "****************************"
0000000000000000000000000000000000000000;;	echo "* Complete!"
0000000000000000000000000000000000000000;;	echo "* Use the following line to make an alias to kvtctl:"
0000000000000000000000000000000000000000;;	echo "* alias kvtctl='\$GOPATH/bin/vtctlclient -server $vtctl_server'"
0000000000000000000000000000000000000000;;	echo "* See the vtctld UI at: http://${vtctld_ip}:30000"
0000000000000000000000000000000000000000;;	echo "****************************"
0000000000000000000000000000000000000000;;	
