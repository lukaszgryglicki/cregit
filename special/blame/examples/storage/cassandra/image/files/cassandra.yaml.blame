0000000000000000000000000000000000000000;;	# Cassandra storage config YAML
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# NOTE:
0000000000000000000000000000000000000000;;	#   See http://wiki.apache.org/cassandra/StorageConfiguration for
0000000000000000000000000000000000000000;;	#   full explanations of configuration directives
0000000000000000000000000000000000000000;;	# /NOTE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The name of the cluster. This is mainly used to prevent machines in
0000000000000000000000000000000000000000;;	# one logical cluster from joining another.
0000000000000000000000000000000000000000;;	cluster_name: 'Test Cluster'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This defines the number of tokens randomly assigned to this node on the ring
0000000000000000000000000000000000000000;;	# The more tokens, relative to other nodes, the larger the proportion of data
0000000000000000000000000000000000000000;;	# that this node will store. You probably want all nodes to have the same number
0000000000000000000000000000000000000000;;	# of tokens assuming they have equal hardware capability.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If you leave this unspecified, Cassandra will use the default of 1 token for legacy compatibility,
0000000000000000000000000000000000000000;;	# and will use the initial_token as described below.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Specifying initial_token will override this setting on the node's initial start,
0000000000000000000000000000000000000000;;	# on subsequent starts, this setting will apply even if initial token is set.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If you already have a cluster with 1 token per node, and wish to migrate to
0000000000000000000000000000000000000000;;	# multiple tokens per node, see http://wiki.apache.org/cassandra/Operations
0000000000000000000000000000000000000000;;	num_tokens: 256
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Triggers automatic allocation of num_tokens tokens for this node. The allocation
0000000000000000000000000000000000000000;;	# algorithm attempts to choose tokens in a way that optimizes replicated load over
0000000000000000000000000000000000000000;;	# the nodes in the datacenter for the replication strategy used by the specified
0000000000000000000000000000000000000000;;	# keyspace.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The load assigned to each node will be close to proportional to its number of
0000000000000000000000000000000000000000;;	# vnodes.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Only supported with the Murmur3Partitioner.
0000000000000000000000000000000000000000;;	# allocate_tokens_for_keyspace: KEYSPACE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# initial_token allows you to specify tokens manually.  While you can use # it with
0000000000000000000000000000000000000000;;	# vnodes (num_tokens > 1, above) -- in which case you should provide a
0000000000000000000000000000000000000000;;	# comma-separated list -- it's primarily used when adding nodes # to legacy clusters
0000000000000000000000000000000000000000;;	# that do not have vnodes enabled.
0000000000000000000000000000000000000000;;	# initial_token:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# See http://wiki.apache.org/cassandra/HintedHandoff
0000000000000000000000000000000000000000;;	# May either be "true" or "false" to enable globally
0000000000000000000000000000000000000000;;	hinted_handoff_enabled: true
0000000000000000000000000000000000000000;;	# When hinted_handoff_enabled is true, a black list of data centers that will not
0000000000000000000000000000000000000000;;	# perform hinted handoff
0000000000000000000000000000000000000000;;	# hinted_handoff_disabled_datacenters:
0000000000000000000000000000000000000000;;	#    - DC1
0000000000000000000000000000000000000000;;	#    - DC2
0000000000000000000000000000000000000000;;	# this defines the maximum amount of time a dead host will have hints
0000000000000000000000000000000000000000;;	# generated.  After it has been dead this long, new hints for it will not be
0000000000000000000000000000000000000000;;	# created until it has been seen alive and gone down again.
0000000000000000000000000000000000000000;;	max_hint_window_in_ms: 10800000 # 3 hours
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Maximum throttle in KBs per second, per delivery thread.  This will be
0000000000000000000000000000000000000000;;	# reduced proportionally to the number of nodes in the cluster.  (If there
0000000000000000000000000000000000000000;;	# are two nodes in the cluster, each delivery thread will use the maximum
0000000000000000000000000000000000000000;;	# rate; if there are three, each will throttle to half of the maximum,
0000000000000000000000000000000000000000;;	# since we expect two nodes to be delivering hints simultaneously.)
0000000000000000000000000000000000000000;;	hinted_handoff_throttle_in_kb: 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Number of threads with which to deliver hints;
0000000000000000000000000000000000000000;;	# Consider increasing this number when you have multi-dc deployments, since
0000000000000000000000000000000000000000;;	# cross-dc handoff tends to be slower
0000000000000000000000000000000000000000;;	max_hints_delivery_threads: 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Directory where Cassandra should store hints.
0000000000000000000000000000000000000000;;	# If not set, the default directory is $CASSANDRA_HOME/data/hints.
0000000000000000000000000000000000000000;;	hints_directory: /cassandra_data/hints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# How often hints should be flushed from the internal buffers to disk.
0000000000000000000000000000000000000000;;	# Will *not* trigger fsync.
0000000000000000000000000000000000000000;;	hints_flush_period_in_ms: 10000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Maximum size for a single hints file, in megabytes.
0000000000000000000000000000000000000000;;	max_hints_file_size_in_mb: 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Compression to apply to the hint files. If omitted, hints files
0000000000000000000000000000000000000000;;	# will be written uncompressed. LZ4, Snappy, and Deflate compressors
0000000000000000000000000000000000000000;;	# are supported.
0000000000000000000000000000000000000000;;	#hints_compression:
0000000000000000000000000000000000000000;;	#   - class_name: LZ4Compressor
0000000000000000000000000000000000000000;;	#     parameters:
0000000000000000000000000000000000000000;;	#         -
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Maximum throttle in KBs per second, total. This will be
0000000000000000000000000000000000000000;;	# reduced proportionally to the number of nodes in the cluster.
0000000000000000000000000000000000000000;;	batchlog_replay_throttle_in_kb: 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Authentication backend, implementing IAuthenticator; used to identify users
0000000000000000000000000000000000000000;;	# Out of the box, Cassandra provides org.apache.cassandra.auth.{AllowAllAuthenticator,
0000000000000000000000000000000000000000;;	# PasswordAuthenticator}.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# - AllowAllAuthenticator performs no checks - set it to disable authentication.
0000000000000000000000000000000000000000;;	# - PasswordAuthenticator relies on username/password pairs to authenticate
0000000000000000000000000000000000000000;;	#   users. It keeps usernames and hashed passwords in system_auth.credentials table.
0000000000000000000000000000000000000000;;	#   Please increase system_auth keyspace replication factor if you use this authenticator.
0000000000000000000000000000000000000000;;	#   If using PasswordAuthenticator, CassandraRoleManager must also be used (see below)
0000000000000000000000000000000000000000;;	authenticator: AllowAllAuthenticator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Authorization backend, implementing IAuthorizer; used to limit access/provide permissions
0000000000000000000000000000000000000000;;	# Out of the box, Cassandra provides org.apache.cassandra.auth.{AllowAllAuthorizer,
0000000000000000000000000000000000000000;;	# CassandraAuthorizer}.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# - AllowAllAuthorizer allows any action to any user - set it to disable authorization.
0000000000000000000000000000000000000000;;	# - CassandraAuthorizer stores permissions in system_auth.permissions table. Please
0000000000000000000000000000000000000000;;	#   increase system_auth keyspace replication factor if you use this authorizer.
0000000000000000000000000000000000000000;;	authorizer: AllowAllAuthorizer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Part of the Authentication & Authorization backend, implementing IRoleManager; used
0000000000000000000000000000000000000000;;	# to maintain grants and memberships between roles.
0000000000000000000000000000000000000000;;	# Out of the box, Cassandra provides org.apache.cassandra.auth.CassandraRoleManager,
0000000000000000000000000000000000000000;;	# which stores role information in the system_auth keyspace. Most functions of the
0000000000000000000000000000000000000000;;	# IRoleManager require an authenticated login, so unless the configured IAuthenticator
0000000000000000000000000000000000000000;;	# actually implements authentication, most of this functionality will be unavailable.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# - CassandraRoleManager stores role data in the system_auth keyspace. Please
0000000000000000000000000000000000000000;;	#   increase system_auth keyspace replication factor if you use this role manager.
0000000000000000000000000000000000000000;;	role_manager: CassandraRoleManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Validity period for roles cache (fetching granted roles can be an expensive
0000000000000000000000000000000000000000;;	# operation depending on the role manager, CassandraRoleManager is one example)
0000000000000000000000000000000000000000;;	# Granted roles are cached for authenticated sessions in AuthenticatedUser and
0000000000000000000000000000000000000000;;	# after the period specified here, become eligible for (async) reload.
0000000000000000000000000000000000000000;;	# Defaults to 2000, set to 0 to disable caching entirely.
0000000000000000000000000000000000000000;;	# Will be disabled automatically for AllowAllAuthenticator.
0000000000000000000000000000000000000000;;	roles_validity_in_ms: 2000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Refresh interval for roles cache (if enabled).
0000000000000000000000000000000000000000;;	# After this interval, cache entries become eligible for refresh. Upon next
0000000000000000000000000000000000000000;;	# access, an async reload is scheduled and the old value returned until it
0000000000000000000000000000000000000000;;	# completes. If roles_validity_in_ms is non-zero, then this must be
0000000000000000000000000000000000000000;;	# also.
0000000000000000000000000000000000000000;;	# Defaults to the same value as roles_validity_in_ms.
0000000000000000000000000000000000000000;;	# roles_update_interval_in_ms: 2000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Validity period for permissions cache (fetching permissions can be an
0000000000000000000000000000000000000000;;	# expensive operation depending on the authorizer, CassandraAuthorizer is
0000000000000000000000000000000000000000;;	# one example). Defaults to 2000, set to 0 to disable.
0000000000000000000000000000000000000000;;	# Will be disabled automatically for AllowAllAuthorizer.
0000000000000000000000000000000000000000;;	permissions_validity_in_ms: 2000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Refresh interval for permissions cache (if enabled).
0000000000000000000000000000000000000000;;	# After this interval, cache entries become eligible for refresh. Upon next
0000000000000000000000000000000000000000;;	# access, an async reload is scheduled and the old value returned until it
0000000000000000000000000000000000000000;;	# completes. If permissions_validity_in_ms is non-zero, then this must be
0000000000000000000000000000000000000000;;	# also.
0000000000000000000000000000000000000000;;	# Defaults to the same value as permissions_validity_in_ms.
0000000000000000000000000000000000000000;;	# permissions_update_interval_in_ms: 2000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Validity period for credentials cache. This cache is tightly coupled to
0000000000000000000000000000000000000000;;	# the provided PasswordAuthenticator implementation of IAuthenticator. If
0000000000000000000000000000000000000000;;	# another IAuthenticator implementation is configured, this cache will not
0000000000000000000000000000000000000000;;	# be automatically used and so the following settings will have no effect.
0000000000000000000000000000000000000000;;	# Please note, credentials are cached in their encrypted form, so while
0000000000000000000000000000000000000000;;	# activating this cache may reduce the number of queries made to the
0000000000000000000000000000000000000000;;	# underlying table, it may not  bring a significant reduction in the
0000000000000000000000000000000000000000;;	# latency of individual authentication attempts.
0000000000000000000000000000000000000000;;	# Defaults to 2000, set to 0 to disable credentials caching.
0000000000000000000000000000000000000000;;	credentials_validity_in_ms: 2000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Refresh interval for credentials cache (if enabled).
0000000000000000000000000000000000000000;;	# After this interval, cache entries become eligible for refresh. Upon next
0000000000000000000000000000000000000000;;	# access, an async reload is scheduled and the old value returned until it
0000000000000000000000000000000000000000;;	# completes. If credentials_validity_in_ms is non-zero, then this must be
0000000000000000000000000000000000000000;;	# also.
0000000000000000000000000000000000000000;;	# Defaults to the same value as credentials_validity_in_ms.
0000000000000000000000000000000000000000;;	# credentials_update_interval_in_ms: 2000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The partitioner is responsible for distributing groups of rows (by
0000000000000000000000000000000000000000;;	# partition key) across nodes in the cluster.  You should leave this
0000000000000000000000000000000000000000;;	# alone for new clusters.  The partitioner can NOT be changed without
0000000000000000000000000000000000000000;;	# reloading all data, so when upgrading you should set this to the
0000000000000000000000000000000000000000;;	# same partitioner you were already using.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Besides Murmur3Partitioner, partitioners included for backwards
0000000000000000000000000000000000000000;;	# compatibility include RandomPartitioner, ByteOrderedPartitioner, and
0000000000000000000000000000000000000000;;	# OrderPreservingPartitioner.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	partitioner: org.apache.cassandra.dht.Murmur3Partitioner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Directories where Cassandra should store data on disk.  Cassandra
0000000000000000000000000000000000000000;;	# will spread data evenly across them, subject to the granularity of
0000000000000000000000000000000000000000;;	# the configured compaction strategy.
0000000000000000000000000000000000000000;;	# If not set, the default directory is $CASSANDRA_HOME/data/data.
0000000000000000000000000000000000000000;;	data_file_directories:
0000000000000000000000000000000000000000;;	    - /cassandra_data/data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# commit log.  when running on magnetic HDD, this should be a
0000000000000000000000000000000000000000;;	# separate spindle than the data directories.
0000000000000000000000000000000000000000;;	# If not set, the default directory is $CASSANDRA_HOME/data/commitlog.
0000000000000000000000000000000000000000;;	commitlog_directory: /cassandra_data/commitlog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# policy for data disk failures:
0000000000000000000000000000000000000000;;	# die: shut down gossip and client transports and kill the JVM for any fs errors or
0000000000000000000000000000000000000000;;	#      single-sstable errors, so the node can be replaced.
0000000000000000000000000000000000000000;;	# stop_paranoid: shut down gossip and client transports even for single-sstable errors,
0000000000000000000000000000000000000000;;	#                kill the JVM for errors during startup.
0000000000000000000000000000000000000000;;	# stop: shut down gossip and client transports, leaving the node effectively dead, but
0000000000000000000000000000000000000000;;	#       can still be inspected via JMX, kill the JVM for errors during startup.
0000000000000000000000000000000000000000;;	# best_effort: stop using the failed disk and respond to requests based on
0000000000000000000000000000000000000000;;	#              remaining available sstables.  This means you WILL see obsolete
0000000000000000000000000000000000000000;;	#              data at CL.ONE!
0000000000000000000000000000000000000000;;	# ignore: ignore fatal errors and let requests fail, as in pre-1.2 Cassandra
0000000000000000000000000000000000000000;;	disk_failure_policy: stop
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# policy for commit disk failures:
0000000000000000000000000000000000000000;;	# die: shut down gossip and Thrift and kill the JVM, so the node can be replaced.
0000000000000000000000000000000000000000;;	# stop: shut down gossip and Thrift, leaving the node effectively dead, but
0000000000000000000000000000000000000000;;	#       can still be inspected via JMX.
0000000000000000000000000000000000000000;;	# stop_commit: shutdown the commit log, letting writes collect but
0000000000000000000000000000000000000000;;	#              continuing to service reads, as in pre-2.0.5 Cassandra
0000000000000000000000000000000000000000;;	# ignore: ignore fatal errors and let the batches fail
0000000000000000000000000000000000000000;;	commit_failure_policy: stop
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Maximum size of the key cache in memory.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Each key cache hit saves 1 seek and each row cache hit saves 2 seeks at the
0000000000000000000000000000000000000000;;	# minimum, sometimes more. The key cache is fairly tiny for the amount of
0000000000000000000000000000000000000000;;	# time it saves, so it's worthwhile to use it at large numbers.
0000000000000000000000000000000000000000;;	# The row cache saves even more time, but must contain the entire row,
0000000000000000000000000000000000000000;;	# so it is extremely space-intensive. It's best to only use the
0000000000000000000000000000000000000000;;	# row cache if you have hot rows or static rows.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE: if you reduce the size, you may not get you hottest keys loaded on startup.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Default value is empty to make it "auto" (min(5% of Heap (in MB), 100MB)). Set to 0 to disable key cache.
0000000000000000000000000000000000000000;;	key_cache_size_in_mb:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Duration in seconds after which Cassandra should
0000000000000000000000000000000000000000;;	# save the key cache. Caches are saved to saved_caches_directory as
0000000000000000000000000000000000000000;;	# specified in this configuration file.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Saved caches greatly improve cold-start speeds, and is relatively cheap in
0000000000000000000000000000000000000000;;	# terms of I/O for the key cache. Row cache saving is much more expensive and
0000000000000000000000000000000000000000;;	# has limited use.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Default is 14400 or 4 hours.
0000000000000000000000000000000000000000;;	key_cache_save_period: 14400
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Number of keys from the key cache to save
0000000000000000000000000000000000000000;;	# Disabled by default, meaning all keys are going to be saved
0000000000000000000000000000000000000000;;	# key_cache_keys_to_save: 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Row cache implementation class name.
0000000000000000000000000000000000000000;;	# Available implementations:
0000000000000000000000000000000000000000;;	#   org.apache.cassandra.cache.OHCProvider                Fully off-heap row cache implementation (default).
0000000000000000000000000000000000000000;;	#   org.apache.cassandra.cache.SerializingCacheProvider   This is the row cache implementation availabile
0000000000000000000000000000000000000000;;	#                                                         in previous releases of Cassandra.
0000000000000000000000000000000000000000;;	# row_cache_class_name: org.apache.cassandra.cache.OHCProvider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Maximum size of the row cache in memory.
0000000000000000000000000000000000000000;;	# Please note that OHC cache implementation requires some additional off-heap memory to manage
0000000000000000000000000000000000000000;;	# the map structures and some in-flight memory during operations before/after cache entries can be
0000000000000000000000000000000000000000;;	# accounted against the cache capacity. This overhead is usually small compared to the whole capacity.
0000000000000000000000000000000000000000;;	# Do not specify more memory that the system can afford in the worst usual situation and leave some
0000000000000000000000000000000000000000;;	# headroom for OS block level cache. Do never allow your system to swap.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Default value is 0, to disable row caching.
0000000000000000000000000000000000000000;;	row_cache_size_in_mb: 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Duration in seconds after which Cassandra should save the row cache.
0000000000000000000000000000000000000000;;	# Caches are saved to saved_caches_directory as specified in this configuration file.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Saved caches greatly improve cold-start speeds, and is relatively cheap in
0000000000000000000000000000000000000000;;	# terms of I/O for the key cache. Row cache saving is much more expensive and
0000000000000000000000000000000000000000;;	# has limited use.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Default is 0 to disable saving the row cache.
0000000000000000000000000000000000000000;;	row_cache_save_period: 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Number of keys from the row cache to save.
0000000000000000000000000000000000000000;;	# Specify 0 (which is the default), meaning all keys are going to be saved
0000000000000000000000000000000000000000;;	# row_cache_keys_to_save: 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Maximum size of the counter cache in memory.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Counter cache helps to reduce counter locks' contention for hot counter cells.
0000000000000000000000000000000000000000;;	# In case of RF = 1 a counter cache hit will cause Cassandra to skip the read before
0000000000000000000000000000000000000000;;	# write entirely. With RF > 1 a counter cache hit will still help to reduce the duration
0000000000000000000000000000000000000000;;	# of the lock hold, helping with hot counter cell updates, but will not allow skipping
0000000000000000000000000000000000000000;;	# the read entirely. Only the local (clock, count) tuple of a counter cell is kept
0000000000000000000000000000000000000000;;	# in memory, not the whole counter, so it's relatively cheap.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE: if you reduce the size, you may not get you hottest keys loaded on startup.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Default value is empty to make it "auto" (min(2.5% of Heap (in MB), 50MB)). Set to 0 to disable counter cache.
0000000000000000000000000000000000000000;;	# NOTE: if you perform counter deletes and rely on low gcgs, you should disable the counter cache.
0000000000000000000000000000000000000000;;	counter_cache_size_in_mb:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Duration in seconds after which Cassandra should
0000000000000000000000000000000000000000;;	# save the counter cache (keys only). Caches are saved to saved_caches_directory as
0000000000000000000000000000000000000000;;	# specified in this configuration file.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Default is 7200 or 2 hours.
0000000000000000000000000000000000000000;;	counter_cache_save_period: 7200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Number of keys from the counter cache to save
0000000000000000000000000000000000000000;;	# Disabled by default, meaning all keys are going to be saved
0000000000000000000000000000000000000000;;	# counter_cache_keys_to_save: 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# saved caches
0000000000000000000000000000000000000000;;	# If not set, the default directory is $CASSANDRA_HOME/data/saved_caches.
0000000000000000000000000000000000000000;;	saved_caches_directory: /cassandra_data/saved_caches
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# commitlog_sync may be either "periodic" or "batch."
0000000000000000000000000000000000000000;;	# 
0000000000000000000000000000000000000000;;	# When in batch mode, Cassandra won't ack writes until the commit log
0000000000000000000000000000000000000000;;	# has been fsynced to disk.  It will wait
0000000000000000000000000000000000000000;;	# commitlog_sync_batch_window_in_ms milliseconds between fsyncs.
0000000000000000000000000000000000000000;;	# This window should be kept short because the writer threads will
0000000000000000000000000000000000000000;;	# be unable to do extra work while waiting.  (You may need to increase
0000000000000000000000000000000000000000;;	# concurrent_writes for the same reason.)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# commitlog_sync: batch
0000000000000000000000000000000000000000;;	# commitlog_sync_batch_window_in_ms: 2
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# the other option is "periodic" where writes may be acked immediately
0000000000000000000000000000000000000000;;	# and the CommitLog is simply synced every commitlog_sync_period_in_ms
0000000000000000000000000000000000000000;;	# milliseconds.
0000000000000000000000000000000000000000;;	commitlog_sync: periodic
0000000000000000000000000000000000000000;;	commitlog_sync_period_in_ms: 10000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The size of the individual commitlog file segments.  A commitlog
0000000000000000000000000000000000000000;;	# segment may be archived, deleted, or recycled once all the data
0000000000000000000000000000000000000000;;	# in it (potentially from each columnfamily in the system) has been
0000000000000000000000000000000000000000;;	# flushed to sstables.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The default size is 32, which is almost always fine, but if you are
0000000000000000000000000000000000000000;;	# archiving commitlog segments (see commitlog_archiving.properties),
0000000000000000000000000000000000000000;;	# then you probably want a finer granularity of archiving; 8 or 16 MB
0000000000000000000000000000000000000000;;	# is reasonable.
0000000000000000000000000000000000000000;;	# Max mutation size is also configurable via max_mutation_size_in_kb setting in
0000000000000000000000000000000000000000;;	# cassandra.yaml. The default is half the size commitlog_segment_size_in_mb * 1024.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# NOTE: If max_mutation_size_in_kb is set explicitly then commitlog_segment_size_in_mb must
0000000000000000000000000000000000000000;;	# be set to at least twice the size of max_mutation_size_in_kb / 1024
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	commitlog_segment_size_in_mb: 32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Compression to apply to the commit log. If omitted, the commit log
0000000000000000000000000000000000000000;;	# will be written uncompressed.  LZ4, Snappy, and Deflate compressors
0000000000000000000000000000000000000000;;	# are supported.
0000000000000000000000000000000000000000;;	#commitlog_compression:
0000000000000000000000000000000000000000;;	#   - class_name: LZ4Compressor
0000000000000000000000000000000000000000;;	#     parameters:
0000000000000000000000000000000000000000;;	#         -
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# any class that implements the SeedProvider interface and has a
0000000000000000000000000000000000000000;;	# constructor that takes a Map<String, String> of parameters will do.
0000000000000000000000000000000000000000;;	seed_provider:
0000000000000000000000000000000000000000;;	    # Addresses of hosts that are deemed contact points.
0000000000000000000000000000000000000000;;	    # Cassandra nodes use this list of hosts to find each other and learn
0000000000000000000000000000000000000000;;	    # the topology of the ring.  You must change this if you are running
0000000000000000000000000000000000000000;;	    # multiple nodes!
0000000000000000000000000000000000000000;;	    #- class_name: io.k8s.cassandra.KubernetesSeedProvider
0000000000000000000000000000000000000000;;	    - class_name: SEED_PROVIDER
0000000000000000000000000000000000000000;;	      parameters:
0000000000000000000000000000000000000000;;	          # seeds is actually a comma-delimited list of addresses.
0000000000000000000000000000000000000000;;	          # Ex: "<ip1>,<ip2>,<ip3>"
0000000000000000000000000000000000000000;;	          - seeds: "127.0.0.1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# For workloads with more data than can fit in memory, Cassandra's
0000000000000000000000000000000000000000;;	# bottleneck will be reads that need to fetch data from
0000000000000000000000000000000000000000;;	# disk. "concurrent_reads" should be set to (16 * number_of_drives) in
0000000000000000000000000000000000000000;;	# order to allow the operations to enqueue low enough in the stack
0000000000000000000000000000000000000000;;	# that the OS and drives can reorder them. Same applies to
0000000000000000000000000000000000000000;;	# "concurrent_counter_writes", since counter writes read the current
0000000000000000000000000000000000000000;;	# values before incrementing and writing them back.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# On the other hand, since writes are almost never IO bound, the ideal
0000000000000000000000000000000000000000;;	# number of "concurrent_writes" is dependent on the number of cores in
0000000000000000000000000000000000000000;;	# your system; (8 * number_of_cores) is a good rule of thumb.
0000000000000000000000000000000000000000;;	concurrent_reads: 32
0000000000000000000000000000000000000000;;	concurrent_writes: 32
0000000000000000000000000000000000000000;;	concurrent_counter_writes: 32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# For materialized view writes, as there is a read involved, so this should
0000000000000000000000000000000000000000;;	# be limited by the less of concurrent reads or concurrent writes.
0000000000000000000000000000000000000000;;	concurrent_materialized_view_writes: 32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Maximum memory to use for pooling sstable buffers. Defaults to the smaller
0000000000000000000000000000000000000000;;	# of 1/4 of heap or 512MB. This pool is allocated off-heap, so is in addition
0000000000000000000000000000000000000000;;	# to the memory allocated for heap. Memory is only allocated as needed.
0000000000000000000000000000000000000000;;	# file_cache_size_in_mb: 512
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Flag indicating whether to allocate on or off heap when the sstable buffer
0000000000000000000000000000000000000000;;	# pool is exhausted, that is when it has exceeded the maximum memory
0000000000000000000000000000000000000000;;	# file_cache_size_in_mb, beyond which it will not cache buffers but allocate on request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# buffer_pool_use_heap_if_exhausted: true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The strategy for optimizing disk read
0000000000000000000000000000000000000000;;	# Possible values are:
0000000000000000000000000000000000000000;;	# ssd (for solid state disks, the default)
0000000000000000000000000000000000000000;;	# spinning (for spinning disks)
0000000000000000000000000000000000000000;;	# disk_optimization_strategy: ssd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Total permitted memory to use for memtables. Cassandra will stop
0000000000000000000000000000000000000000;;	# accepting writes when the limit is exceeded until a flush completes,
0000000000000000000000000000000000000000;;	# and will trigger a flush based on memtable_cleanup_threshold
0000000000000000000000000000000000000000;;	# If omitted, Cassandra will set both to 1/4 the size of the heap.
0000000000000000000000000000000000000000;;	# memtable_heap_space_in_mb: 2048
0000000000000000000000000000000000000000;;	# memtable_offheap_space_in_mb: 2048
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Ratio of occupied non-flushing memtable size to total permitted size
0000000000000000000000000000000000000000;;	# that will trigger a flush of the largest memtable. Larger mct will
0000000000000000000000000000000000000000;;	# mean larger flushes and hence less compaction, but also less concurrent
0000000000000000000000000000000000000000;;	# flush activity which can make it difficult to keep your disks fed
0000000000000000000000000000000000000000;;	# under heavy write load.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# memtable_cleanup_threshold defaults to 1 / (memtable_flush_writers + 1)
0000000000000000000000000000000000000000;;	# memtable_cleanup_threshold: 0.11
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Specify the way Cassandra allocates and manages memtable memory.
0000000000000000000000000000000000000000;;	# Options are:
0000000000000000000000000000000000000000;;	#   heap_buffers:    on heap nio buffers
0000000000000000000000000000000000000000;;	#   offheap_buffers: off heap (direct) nio buffers
0000000000000000000000000000000000000000;;	#   offheap_objects: off heap objects
0000000000000000000000000000000000000000;;	memtable_allocation_type: heap_buffers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Total space to use for commit logs on disk.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If space gets above this value, Cassandra will flush every dirty CF
0000000000000000000000000000000000000000;;	# in the oldest segment and remove it.  So a small total commitlog space
0000000000000000000000000000000000000000;;	# will tend to cause more flush activity on less-active columnfamilies.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The default value is the smaller of 8192, and 1/4 of the total space
0000000000000000000000000000000000000000;;	# of the commitlog volume.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# commitlog_total_space_in_mb: 8192
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# This sets the amount of memtable flush writer threads.  These will
0000000000000000000000000000000000000000;;	# be blocked by disk io, and each one will hold a memtable in memory
0000000000000000000000000000000000000000;;	# while blocked.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# memtable_flush_writers defaults to one per data_file_directory.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If your data directories are backed by SSD, you can increase this, but
0000000000000000000000000000000000000000;;	# avoid having memtable_flush_writers * data_file_directories > number of cores
0000000000000000000000000000000000000000;;	#memtable_flush_writers: 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A fixed memory pool size in MB for for SSTable index summaries. If left
0000000000000000000000000000000000000000;;	# empty, this will default to 5% of the heap size. If the memory usage of
0000000000000000000000000000000000000000;;	# all index summaries exceeds this limit, SSTables with low read rates will
0000000000000000000000000000000000000000;;	# shrink their index summaries in order to meet this limit.  However, this
0000000000000000000000000000000000000000;;	# is a best-effort process. In extreme conditions Cassandra may need to use
0000000000000000000000000000000000000000;;	# more than this amount of memory.
0000000000000000000000000000000000000000;;	index_summary_capacity_in_mb:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# How frequently index summaries should be resampled.  This is done
0000000000000000000000000000000000000000;;	# periodically to redistribute memory from the fixed-size pool to sstables
0000000000000000000000000000000000000000;;	# proportional their recent read rates.  Setting to -1 will disable this
0000000000000000000000000000000000000000;;	# process, leaving existing index summaries at their current sampling level.
0000000000000000000000000000000000000000;;	index_summary_resize_interval_in_minutes: 60
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Whether to, when doing sequential writing, fsync() at intervals in
0000000000000000000000000000000000000000;;	# order to force the operating system to flush the dirty
0000000000000000000000000000000000000000;;	# buffers. Enable this to avoid sudden dirty buffer flushing from
0000000000000000000000000000000000000000;;	# impacting read latencies. Almost always a good idea on SSDs; not
0000000000000000000000000000000000000000;;	# necessarily on platters.
0000000000000000000000000000000000000000;;	trickle_fsync: false
0000000000000000000000000000000000000000;;	trickle_fsync_interval_in_kb: 10240
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TCP port, for commands and data
0000000000000000000000000000000000000000;;	# For security reasons, you should not expose this port to the internet.  Firewall it if needed.
0000000000000000000000000000000000000000;;	storage_port: 7000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# SSL port, for encrypted communication.  Unused unless enabled in
0000000000000000000000000000000000000000;;	# encryption_options
0000000000000000000000000000000000000000;;	# For security reasons, you should not expose this port to the internet.  Firewall it if needed.
0000000000000000000000000000000000000000;;	ssl_storage_port: 7001
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Address or interface to bind to and tell other Cassandra nodes to connect to.
0000000000000000000000000000000000000000;;	# You _must_ change this if you want multiple nodes to be able to communicate!
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Set listen_address OR listen_interface, not both. Interfaces must correspond
0000000000000000000000000000000000000000;;	# to a single address, IP aliasing is not supported.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Leaving it blank leaves it up to InetAddress.getLocalHost(). This
0000000000000000000000000000000000000000;;	# will always do the Right Thing _if_ the node is properly configured
0000000000000000000000000000000000000000;;	# (hostname, name resolution, etc), and the Right Thing is to use the
0000000000000000000000000000000000000000;;	# address associated with the hostname (it might not be).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Setting listen_address to 0.0.0.0 is always wrong.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If you choose to specify the interface by name and the interface has an ipv4 and an ipv6 address
0000000000000000000000000000000000000000;;	# you can specify which should be chosen using listen_interface_prefer_ipv6. If false the first ipv4
0000000000000000000000000000000000000000;;	# address will be used. If true the first ipv6 address will be used. Defaults to false preferring
0000000000000000000000000000000000000000;;	# ipv4. If there is only one address it will be selected regardless of ipv4/ipv6.
0000000000000000000000000000000000000000;;	listen_address: localhost
0000000000000000000000000000000000000000;;	# listen_interface: eth0
0000000000000000000000000000000000000000;;	# listen_interface_prefer_ipv6: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Address to broadcast to other Cassandra nodes
0000000000000000000000000000000000000000;;	# Leaving this blank will set it to the same value as listen_address
0000000000000000000000000000000000000000;;	# broadcast_address: 1.2.3.4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# When using multiple physical network interfaces, set this
0000000000000000000000000000000000000000;;	# to true to listen on broadcast_address in addition to
0000000000000000000000000000000000000000;;	# the listen_address, allowing nodes to communicate in both
0000000000000000000000000000000000000000;;	# interfaces.
0000000000000000000000000000000000000000;;	# Ignore this property if the network configuration automatically
0000000000000000000000000000000000000000;;	# routes  between the public and private networks such as EC2.
0000000000000000000000000000000000000000;;	# listen_on_broadcast_address: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Internode authentication backend, implementing IInternodeAuthenticator;
0000000000000000000000000000000000000000;;	# used to allow/disallow connections from peer nodes.
0000000000000000000000000000000000000000;;	# internode_authenticator: org.apache.cassandra.auth.AllowAllInternodeAuthenticator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Whether to start the native transport server.
0000000000000000000000000000000000000000;;	# Please note that the address on which the native transport is bound is the
0000000000000000000000000000000000000000;;	# same as the rpc_address. The port however is different and specified below.
0000000000000000000000000000000000000000;;	start_native_transport: true
0000000000000000000000000000000000000000;;	# port for the CQL native transport to listen for clients on
0000000000000000000000000000000000000000;;	# For security reasons, you should not expose this port to the internet.  Firewall it if needed.
0000000000000000000000000000000000000000;;	native_transport_port: 9042
0000000000000000000000000000000000000000;;	# Enabling native transport encryption in client_encryption_options allows you to either use
0000000000000000000000000000000000000000;;	# encryption for the standard port or to use a dedicated, additional port along with the unencrypted
0000000000000000000000000000000000000000;;	# standard native_transport_port.
0000000000000000000000000000000000000000;;	# Enabling client encryption and keeping native_transport_port_ssl disabled will use encryption
0000000000000000000000000000000000000000;;	# for native_transport_port. Setting native_transport_port_ssl to a different value
0000000000000000000000000000000000000000;;	# from native_transport_port will use encryption for native_transport_port_ssl while
0000000000000000000000000000000000000000;;	# keeping native_transport_port unencrypted.
0000000000000000000000000000000000000000;;	# native_transport_port_ssl: 9142
0000000000000000000000000000000000000000;;	# The maximum threads for handling requests when the native transport is used.
0000000000000000000000000000000000000000;;	# This is similar to rpc_max_threads though the default differs slightly (and
0000000000000000000000000000000000000000;;	# there is no native_transport_min_threads, idle threads will always be stopped
0000000000000000000000000000000000000000;;	# after 30 seconds).
0000000000000000000000000000000000000000;;	# native_transport_max_threads: 128
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The maximum size of allowed frame. Frame (requests) larger than this will
0000000000000000000000000000000000000000;;	# be rejected as invalid. The default is 256MB.
0000000000000000000000000000000000000000;;	# native_transport_max_frame_size_in_mb: 256
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The maximum number of concurrent client connections.
0000000000000000000000000000000000000000;;	# The default is -1, which means unlimited.
0000000000000000000000000000000000000000;;	# native_transport_max_concurrent_connections: -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The maximum number of concurrent client connections per source ip.
0000000000000000000000000000000000000000;;	# The default is -1, which means unlimited.
0000000000000000000000000000000000000000;;	# native_transport_max_concurrent_connections_per_ip: -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Whether to start the thrift rpc server.
0000000000000000000000000000000000000000;;	start_rpc: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The address or interface to bind the Thrift RPC service and native transport
0000000000000000000000000000000000000000;;	# server to.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Set rpc_address OR rpc_interface, not both. Interfaces must correspond
0000000000000000000000000000000000000000;;	# to a single address, IP aliasing is not supported.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Leaving rpc_address blank has the same effect as on listen_address
0000000000000000000000000000000000000000;;	# (i.e. it will be based on the configured hostname of the node).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Note that unlike listen_address, you can specify 0.0.0.0, but you must also
0000000000000000000000000000000000000000;;	# set broadcast_rpc_address to a value other than 0.0.0.0.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# For security reasons, you should not expose this port to the internet.  Firewall it if needed.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If you choose to specify the interface by name and the interface has an ipv4 and an ipv6 address
0000000000000000000000000000000000000000;;	# you can specify which should be chosen using rpc_interface_prefer_ipv6. If false the first ipv4
0000000000000000000000000000000000000000;;	# address will be used. If true the first ipv6 address will be used. Defaults to false preferring
0000000000000000000000000000000000000000;;	# ipv4. If there is only one address it will be selected regardless of ipv4/ipv6.
0000000000000000000000000000000000000000;;	rpc_address: localhost
0000000000000000000000000000000000000000;;	# rpc_interface: eth1
0000000000000000000000000000000000000000;;	# rpc_interface_prefer_ipv6: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# port for Thrift to listen for clients on
0000000000000000000000000000000000000000;;	rpc_port: 9160
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# RPC address to broadcast to drivers and other Cassandra nodes. This cannot
0000000000000000000000000000000000000000;;	# be set to 0.0.0.0. If left blank, this will be set to the value of
0000000000000000000000000000000000000000;;	# rpc_address. If rpc_address is set to 0.0.0.0, broadcast_rpc_address must
0000000000000000000000000000000000000000;;	# be set.
0000000000000000000000000000000000000000;;	# broadcast_rpc_address: 1.2.3.4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# enable or disable keepalive on rpc/native connections
0000000000000000000000000000000000000000;;	rpc_keepalive: true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Cassandra provides two out-of-the-box options for the RPC Server:
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# sync  -> One thread per thrift connection. For a very large number of clients, memory
0000000000000000000000000000000000000000;;	#          will be your limiting factor. On a 64 bit JVM, 180KB is the minimum stack size
0000000000000000000000000000000000000000;;	#          per thread, and that will correspond to your use of virtual memory (but physical memory
0000000000000000000000000000000000000000;;	#          may be limited depending on use of stack space).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# hsha  -> Stands for "half synchronous, half asynchronous." All thrift clients are handled
0000000000000000000000000000000000000000;;	#          asynchronously using a small number of threads that does not vary with the amount
0000000000000000000000000000000000000000;;	#          of thrift clients (and thus scales well to many clients). The rpc requests are still
0000000000000000000000000000000000000000;;	#          synchronous (one thread per active request). If hsha is selected then it is essential
0000000000000000000000000000000000000000;;	#          that rpc_max_threads is changed from the default value of unlimited.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The default is sync because on Windows hsha is about 30% slower.  On Linux,
0000000000000000000000000000000000000000;;	# sync/hsha performance is about the same, with hsha of course using less memory.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Alternatively,  can provide your own RPC server by providing the fully-qualified class name
0000000000000000000000000000000000000000;;	# of an o.a.c.t.TServerFactory that can create an instance of it.
0000000000000000000000000000000000000000;;	rpc_server_type: sync
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Uncomment rpc_min|max_thread to set request pool size limits.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Regardless of your choice of RPC server (see above), the number of maximum requests in the
0000000000000000000000000000000000000000;;	# RPC thread pool dictates how many concurrent requests are possible (but if you are using the sync
0000000000000000000000000000000000000000;;	# RPC server, it also dictates the number of clients that can be connected at all).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The default is unlimited and thus provides no protection against clients overwhelming the server. You are
0000000000000000000000000000000000000000;;	# encouraged to set a maximum that makes sense for you in production, but do keep in mind that
0000000000000000000000000000000000000000;;	# rpc_max_threads represents the maximum number of client requests this server may execute concurrently.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# rpc_min_threads: 16
0000000000000000000000000000000000000000;;	# rpc_max_threads: 2048
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# uncomment to set socket buffer sizes on rpc connections
0000000000000000000000000000000000000000;;	# rpc_send_buff_size_in_bytes:
0000000000000000000000000000000000000000;;	# rpc_recv_buff_size_in_bytes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Uncomment to set socket buffer size for internode communication
0000000000000000000000000000000000000000;;	# Note that when setting this, the buffer size is limited by net.core.wmem_max
0000000000000000000000000000000000000000;;	# and when not setting it it is defined by net.ipv4.tcp_wmem
0000000000000000000000000000000000000000;;	# See:
0000000000000000000000000000000000000000;;	# /proc/sys/net/core/wmem_max
0000000000000000000000000000000000000000;;	# /proc/sys/net/core/rmem_max
0000000000000000000000000000000000000000;;	# /proc/sys/net/ipv4/tcp_wmem
0000000000000000000000000000000000000000;;	# /proc/sys/net/ipv4/tcp_wmem
0000000000000000000000000000000000000000;;	# and: man tcp
0000000000000000000000000000000000000000;;	# internode_send_buff_size_in_bytes:
0000000000000000000000000000000000000000;;	# internode_recv_buff_size_in_bytes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Frame size for thrift (maximum message length).
0000000000000000000000000000000000000000;;	thrift_framed_transport_size_in_mb: 15
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Set to true to have Cassandra create a hard link to each sstable
0000000000000000000000000000000000000000;;	# flushed or streamed locally in a backups/ subdirectory of the
0000000000000000000000000000000000000000;;	# keyspace data.  Removing these links is the operator's
0000000000000000000000000000000000000000;;	# responsibility.
0000000000000000000000000000000000000000;;	incremental_backups: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Whether or not to take a snapshot before each compaction.  Be
0000000000000000000000000000000000000000;;	# careful using this option, since Cassandra won't clean up the
0000000000000000000000000000000000000000;;	# snapshots for you.  Mostly useful if you're paranoid when there
0000000000000000000000000000000000000000;;	# is a data format change.
0000000000000000000000000000000000000000;;	snapshot_before_compaction: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Whether or not a snapshot is taken of the data before keyspace truncation
0000000000000000000000000000000000000000;;	# or dropping of column families. The STRONGLY advised default of true
0000000000000000000000000000000000000000;;	# should be used to provide data safety. If you set this flag to false, you will
0000000000000000000000000000000000000000;;	# lose data on truncation or drop.
0000000000000000000000000000000000000000;;	auto_snapshot: true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# When executing a scan, within or across a partition, we need to keep the
0000000000000000000000000000000000000000;;	# tombstones seen in memory so we can return them to the coordinator, which
0000000000000000000000000000000000000000;;	# will use them to make sure other replicas also know about the deleted rows.
0000000000000000000000000000000000000000;;	# With workloads that generate a lot of tombstones, this can cause performance
0000000000000000000000000000000000000000;;	# problems and even exaust the server heap.
0000000000000000000000000000000000000000;;	# (http://www.datastax.com/dev/blog/cassandra-anti-patterns-queues-and-queue-like-datasets)
0000000000000000000000000000000000000000;;	# Adjust the thresholds here if you understand the dangers and want to
0000000000000000000000000000000000000000;;	# scan more tombstones anyway.  These thresholds may also be adjusted at runtime
0000000000000000000000000000000000000000;;	# using the StorageService mbean.
0000000000000000000000000000000000000000;;	tombstone_warn_threshold: 1000
0000000000000000000000000000000000000000;;	tombstone_failure_threshold: 100000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Granularity of the collation index of rows within a partition.
0000000000000000000000000000000000000000;;	# Increase if your rows are large, or if you have a very large
0000000000000000000000000000000000000000;;	# number of rows per partition.  The competing goals are these:
0000000000000000000000000000000000000000;;	#   1) a smaller granularity means more index entries are generated
0000000000000000000000000000000000000000;;	#      and looking up rows within the partition by collation column
0000000000000000000000000000000000000000;;	#      is faster
0000000000000000000000000000000000000000;;	#   2) but, Cassandra will keep the collation index in memory for hot
0000000000000000000000000000000000000000;;	#      rows (as part of the key cache), so a larger granularity means
0000000000000000000000000000000000000000;;	#      you can cache more hot rows
0000000000000000000000000000000000000000;;	column_index_size_in_kb: 64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Log WARN on any batch size exceeding this value. 5kb per batch by default.
0000000000000000000000000000000000000000;;	# Caution should be taken on increasing the size of this threshold as it can lead to node instability.
0000000000000000000000000000000000000000;;	batch_size_warn_threshold_in_kb: 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Fail any batch exceeding this value. 50kb (10x warn threshold) by default.
0000000000000000000000000000000000000000;;	batch_size_fail_threshold_in_kb: 50
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Number of simultaneous compactions to allow, NOT including
0000000000000000000000000000000000000000;;	# validation "compactions" for anti-entropy repair.  Simultaneous
0000000000000000000000000000000000000000;;	# compactions can help preserve read performance in a mixed read/write
0000000000000000000000000000000000000000;;	# workload, by mitigating the tendency of small sstables to accumulate
0000000000000000000000000000000000000000;;	# during a single long running compactions. The default is usually
0000000000000000000000000000000000000000;;	# fine and if you experience problems with compaction running too
0000000000000000000000000000000000000000;;	# slowly or too fast, you should look at
0000000000000000000000000000000000000000;;	# compaction_throughput_mb_per_sec first.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# concurrent_compactors defaults to the smaller of (number of disks,
0000000000000000000000000000000000000000;;	# number of cores), with a minimum of 2 and a maximum of 8.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If your data directories are backed by SSD, you should increase this
0000000000000000000000000000000000000000;;	# to the number of cores.
0000000000000000000000000000000000000000;;	#concurrent_compactors: 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Throttles compaction to the given total throughput across the entire
0000000000000000000000000000000000000000;;	# system. The faster you insert data, the faster you need to compact in
0000000000000000000000000000000000000000;;	# order to keep the sstable count down, but in general, setting this to
0000000000000000000000000000000000000000;;	# 16 to 32 times the rate you are inserting data is more than sufficient.
0000000000000000000000000000000000000000;;	# Setting this to 0 disables throttling. Note that this account for all types
0000000000000000000000000000000000000000;;	# of compaction, including validation compaction.
0000000000000000000000000000000000000000;;	compaction_throughput_mb_per_sec: 16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Log a warning when compacting partitions larger than this value
0000000000000000000000000000000000000000;;	compaction_large_partition_warning_threshold_mb: 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# When compacting, the replacement sstable(s) can be opened before they
0000000000000000000000000000000000000000;;	# are completely written, and used in place of the prior sstables for
0000000000000000000000000000000000000000;;	# any range that has been written. This helps to smoothly transfer reads
0000000000000000000000000000000000000000;;	# between the sstables, reducing page cache churn and keeping hot rows hot
0000000000000000000000000000000000000000;;	sstable_preemptive_open_interval_in_mb: 50
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Throttles all outbound streaming file transfers on this node to the
0000000000000000000000000000000000000000;;	# given total throughput in Mbps. This is necessary because Cassandra does
0000000000000000000000000000000000000000;;	# mostly sequential IO when streaming data during bootstrap or repair, which
0000000000000000000000000000000000000000;;	# can lead to saturating the network connection and degrading rpc performance.
0000000000000000000000000000000000000000;;	# When unset, the default is 200 Mbps or 25 MB/s.
0000000000000000000000000000000000000000;;	# stream_throughput_outbound_megabits_per_sec: 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Throttles all streaming file transfer between the datacenters,
0000000000000000000000000000000000000000;;	# this setting allows users to throttle inter dc stream throughput in addition
0000000000000000000000000000000000000000;;	# to throttling all network stream traffic as configured with
0000000000000000000000000000000000000000;;	# stream_throughput_outbound_megabits_per_sec
0000000000000000000000000000000000000000;;	# When unset, the default is 200 Mbps or 25 MB/s
0000000000000000000000000000000000000000;;	# inter_dc_stream_throughput_outbound_megabits_per_sec: 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# How long the coordinator should wait for read operations to complete
0000000000000000000000000000000000000000;;	read_request_timeout_in_ms: 5000
0000000000000000000000000000000000000000;;	# How long the coordinator should wait for seq or index scans to complete
0000000000000000000000000000000000000000;;	range_request_timeout_in_ms: 10000
0000000000000000000000000000000000000000;;	# How long the coordinator should wait for writes to complete
0000000000000000000000000000000000000000;;	write_request_timeout_in_ms: 2000
0000000000000000000000000000000000000000;;	# How long the coordinator should wait for counter writes to complete
0000000000000000000000000000000000000000;;	counter_write_request_timeout_in_ms: 5000
0000000000000000000000000000000000000000;;	# How long a coordinator should continue to retry a CAS operation
0000000000000000000000000000000000000000;;	# that contends with other proposals for the same row
0000000000000000000000000000000000000000;;	cas_contention_timeout_in_ms: 1000
0000000000000000000000000000000000000000;;	# How long the coordinator should wait for truncates to complete
0000000000000000000000000000000000000000;;	# (This can be much longer, because unless auto_snapshot is disabled
0000000000000000000000000000000000000000;;	# we need to flush first so we can snapshot before removing the data.)
0000000000000000000000000000000000000000;;	truncate_request_timeout_in_ms: 60000
0000000000000000000000000000000000000000;;	# The default timeout for other, miscellaneous operations
0000000000000000000000000000000000000000;;	request_timeout_in_ms: 10000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Enable operation timeout information exchange between nodes to accurately
0000000000000000000000000000000000000000;;	# measure request timeouts.  If disabled, replicas will assume that requests
0000000000000000000000000000000000000000;;	# were forwarded to them instantly by the coordinator, which means that
0000000000000000000000000000000000000000;;	# under overload conditions we will waste that much extra time processing
0000000000000000000000000000000000000000;;	# already-timed-out requests.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Warning: before enabling this property make sure to ntp is installed
0000000000000000000000000000000000000000;;	# and the times are synchronized between the nodes.
0000000000000000000000000000000000000000;;	cross_node_timeout: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Set socket timeout for streaming operation.
0000000000000000000000000000000000000000;;	# The stream session is failed if no data is received by any of the
0000000000000000000000000000000000000000;;	# participants within that period.
0000000000000000000000000000000000000000;;	# Default value is 3600000, which means streams timeout after an hour.
0000000000000000000000000000000000000000;;	# streaming_socket_timeout_in_ms: 3600000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# phi value that must be reached for a host to be marked down.
0000000000000000000000000000000000000000;;	# most users should never need to adjust this.
0000000000000000000000000000000000000000;;	# phi_convict_threshold: 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# endpoint_snitch -- Set this to a class that implements
0000000000000000000000000000000000000000;;	# IEndpointSnitch.  The snitch has two functions:
0000000000000000000000000000000000000000;;	# - it teaches Cassandra enough about your network topology to route
0000000000000000000000000000000000000000;;	#   requests efficiently
0000000000000000000000000000000000000000;;	# - it allows Cassandra to spread replicas around your cluster to avoid
0000000000000000000000000000000000000000;;	#   correlated failures. It does this by grouping machines into
0000000000000000000000000000000000000000;;	#   "datacenters" and "racks."  Cassandra will do its best not to have
0000000000000000000000000000000000000000;;	#   more than one replica on the same "rack" (which may not actually
0000000000000000000000000000000000000000;;	#   be a physical location)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# IF YOU CHANGE THE SNITCH AFTER DATA IS INSERTED INTO THE CLUSTER,
0000000000000000000000000000000000000000;;	# YOU MUST RUN A FULL REPAIR, SINCE THE SNITCH AFFECTS WHERE REPLICAS
0000000000000000000000000000000000000000;;	# ARE PLACED.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# IF THE RACK A REPLICA IS PLACED IN CHANGES AFTER THE REPLICA HAS BEEN
0000000000000000000000000000000000000000;;	# ADDED TO A RING, THE NODE MUST BE DECOMMISSIONED AND REBOOTSTRAPPED.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Out of the box, Cassandra provides
0000000000000000000000000000000000000000;;	#  - SimpleSnitch:
0000000000000000000000000000000000000000;;	#    Treats Strategy order as proximity. This can improve cache
0000000000000000000000000000000000000000;;	#    locality when disabling read repair.  Only appropriate for
0000000000000000000000000000000000000000;;	#    single-datacenter deployments.
0000000000000000000000000000000000000000;;	#  - GossipingPropertyFileSnitch
0000000000000000000000000000000000000000;;	#    This should be your go-to snitch for production use.  The rack
0000000000000000000000000000000000000000;;	#    and datacenter for the local node are defined in
0000000000000000000000000000000000000000;;	#    cassandra-rackdc.properties and propagated to other nodes via
0000000000000000000000000000000000000000;;	#    gossip.  If cassandra-topology.properties exists, it is used as a
0000000000000000000000000000000000000000;;	#    fallback, allowing migration from the PropertyFileSnitch.
0000000000000000000000000000000000000000;;	#  - PropertyFileSnitch:
0000000000000000000000000000000000000000;;	#    Proximity is determined by rack and data center, which are
0000000000000000000000000000000000000000;;	#    explicitly configured in cassandra-topology.properties.
0000000000000000000000000000000000000000;;	#  - Ec2Snitch:
0000000000000000000000000000000000000000;;	#    Appropriate for EC2 deployments in a single Region. Loads Region
0000000000000000000000000000000000000000;;	#    and Availability Zone information from the EC2 API. The Region is
0000000000000000000000000000000000000000;;	#    treated as the datacenter, and the Availability Zone as the rack.
0000000000000000000000000000000000000000;;	#    Only private IPs are used, so this will not work across multiple
0000000000000000000000000000000000000000;;	#    Regions.
0000000000000000000000000000000000000000;;	#  - Ec2MultiRegionSnitch:
0000000000000000000000000000000000000000;;	#    Uses public IPs as broadcast_address to allow cross-region
0000000000000000000000000000000000000000;;	#    connectivity.  (Thus, you should set seed addresses to the public
0000000000000000000000000000000000000000;;	#    IP as well.) You will need to open the storage_port or
0000000000000000000000000000000000000000;;	#    ssl_storage_port on the public IP firewall.  (For intra-Region
0000000000000000000000000000000000000000;;	#    traffic, Cassandra will switch to the private IP after
0000000000000000000000000000000000000000;;	#    establishing a connection.)
0000000000000000000000000000000000000000;;	#  - RackInferringSnitch:
0000000000000000000000000000000000000000;;	#    Proximity is determined by rack and data center, which are
0000000000000000000000000000000000000000;;	#    assumed to correspond to the 3rd and 2nd octet of each node's IP
0000000000000000000000000000000000000000;;	#    address, respectively.  Unless this happens to match your
0000000000000000000000000000000000000000;;	#    deployment conventions, this is best used as an example of
0000000000000000000000000000000000000000;;	#    writing a custom Snitch class and is provided in that spirit.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# You can use a custom Snitch by setting this to the full class name
0000000000000000000000000000000000000000;;	# of the snitch, which will be assumed to be on your classpath.
0000000000000000000000000000000000000000;;	endpoint_snitch: SimpleSnitch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# controls how often to perform the more expensive part of host score
0000000000000000000000000000000000000000;;	# calculation
0000000000000000000000000000000000000000;;	dynamic_snitch_update_interval_in_ms: 100
0000000000000000000000000000000000000000;;	# controls how often to reset all host scores, allowing a bad host to
0000000000000000000000000000000000000000;;	# possibly recover
0000000000000000000000000000000000000000;;	dynamic_snitch_reset_interval_in_ms: 600000
0000000000000000000000000000000000000000;;	# if set greater than zero and read_repair_chance is < 1.0, this will allow
0000000000000000000000000000000000000000;;	# 'pinning' of replicas to hosts in order to increase cache capacity.
0000000000000000000000000000000000000000;;	# The badness threshold will control how much worse the pinned host has to be
0000000000000000000000000000000000000000;;	# before the dynamic snitch will prefer other replicas over it.  This is
0000000000000000000000000000000000000000;;	# expressed as a double which represents a percentage.  Thus, a value of
0000000000000000000000000000000000000000;;	# 0.2 means Cassandra would continue to prefer the static snitch values
0000000000000000000000000000000000000000;;	# until the pinned host was 20% worse than the fastest.
0000000000000000000000000000000000000000;;	dynamic_snitch_badness_threshold: 0.1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# request_scheduler -- Set this to a class that implements
0000000000000000000000000000000000000000;;	# RequestScheduler, which will schedule incoming client requests
0000000000000000000000000000000000000000;;	# according to the specific policy. This is useful for multi-tenancy
0000000000000000000000000000000000000000;;	# with a single Cassandra cluster.
0000000000000000000000000000000000000000;;	# NOTE: This is specifically for requests from the client and does
0000000000000000000000000000000000000000;;	# not affect inter node communication.
0000000000000000000000000000000000000000;;	# org.apache.cassandra.scheduler.NoScheduler - No scheduling takes place
0000000000000000000000000000000000000000;;	# org.apache.cassandra.scheduler.RoundRobinScheduler - Round robin of
0000000000000000000000000000000000000000;;	# client requests to a node with a separate queue for each
0000000000000000000000000000000000000000;;	# request_scheduler_id. The scheduler is further customized by
0000000000000000000000000000000000000000;;	# request_scheduler_options as described below.
0000000000000000000000000000000000000000;;	request_scheduler: org.apache.cassandra.scheduler.NoScheduler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Scheduler Options vary based on the type of scheduler
0000000000000000000000000000000000000000;;	# NoScheduler - Has no options
0000000000000000000000000000000000000000;;	# RoundRobin
0000000000000000000000000000000000000000;;	#  - throttle_limit -- The throttle_limit is the number of in-flight
0000000000000000000000000000000000000000;;	#                      requests per client.  Requests beyond
0000000000000000000000000000000000000000;;	#                      that limit are queued up until
0000000000000000000000000000000000000000;;	#                      running requests can complete.
0000000000000000000000000000000000000000;;	#                      The value of 80 here is twice the number of
0000000000000000000000000000000000000000;;	#                      concurrent_reads + concurrent_writes.
0000000000000000000000000000000000000000;;	#  - default_weight -- default_weight is optional and allows for
0000000000000000000000000000000000000000;;	#                      overriding the default which is 1.
0000000000000000000000000000000000000000;;	#  - weights -- Weights are optional and will default to 1 or the
0000000000000000000000000000000000000000;;	#               overridden default_weight. The weight translates into how
0000000000000000000000000000000000000000;;	#               many requests are handled during each turn of the
0000000000000000000000000000000000000000;;	#               RoundRobin, based on the scheduler id.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# request_scheduler_options:
0000000000000000000000000000000000000000;;	#    throttle_limit: 80
0000000000000000000000000000000000000000;;	#    default_weight: 5
0000000000000000000000000000000000000000;;	#    weights:
0000000000000000000000000000000000000000;;	#      Keyspace1: 1
0000000000000000000000000000000000000000;;	#      Keyspace2: 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# request_scheduler_id -- An identifier based on which to perform
0000000000000000000000000000000000000000;;	# the request scheduling. Currently the only valid option is keyspace.
0000000000000000000000000000000000000000;;	# request_scheduler_id: keyspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Enable or disable inter-node encryption
0000000000000000000000000000000000000000;;	# Default settings are TLS v1, RSA 1024-bit keys (it is imperative that
0000000000000000000000000000000000000000;;	# users generate their own keys) TLS_RSA_WITH_AES_128_CBC_SHA as the cipher
0000000000000000000000000000000000000000;;	# suite for authentication, key exchange and encryption of the actual data transfers.
0000000000000000000000000000000000000000;;	# Use the DHE/ECDHE ciphers if running in FIPS 140 compliant mode.
0000000000000000000000000000000000000000;;	# NOTE: No custom encryption options are enabled at the moment
0000000000000000000000000000000000000000;;	# The available internode options are : all, none, dc, rack
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# If set to dc cassandra will encrypt the traffic between the DCs
0000000000000000000000000000000000000000;;	# If set to rack cassandra will encrypt the traffic between the racks
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# The passwords used in these options must match the passwords used when generating
0000000000000000000000000000000000000000;;	# the keystore and truststore.  For instructions on generating these files, see:
0000000000000000000000000000000000000000;;	# http://download.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#CreateKeystore
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	server_encryption_options:
0000000000000000000000000000000000000000;;	    internode_encryption: none
0000000000000000000000000000000000000000;;	    keystore: conf/.keystore
0000000000000000000000000000000000000000;;	    keystore_password: cassandra
0000000000000000000000000000000000000000;;	    truststore: conf/.truststore
0000000000000000000000000000000000000000;;	    truststore_password: cassandra
0000000000000000000000000000000000000000;;	    # More advanced defaults below:
0000000000000000000000000000000000000000;;	    # protocol: TLS
0000000000000000000000000000000000000000;;	    # algorithm: SunX509
0000000000000000000000000000000000000000;;	    # store_type: JKS
0000000000000000000000000000000000000000;;	    # cipher_suites: [TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA]
0000000000000000000000000000000000000000;;	    # require_client_auth: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# enable or disable client/server encryption.
0000000000000000000000000000000000000000;;	client_encryption_options:
0000000000000000000000000000000000000000;;	    enabled: false
0000000000000000000000000000000000000000;;	    # If enabled and optional is set to true encrypted and unencrypted connections are handled.
0000000000000000000000000000000000000000;;	    optional: false
0000000000000000000000000000000000000000;;	    keystore: conf/.keystore
0000000000000000000000000000000000000000;;	    keystore_password: cassandra
0000000000000000000000000000000000000000;;	    # require_client_auth: false
0000000000000000000000000000000000000000;;	    # Set trustore and truststore_password if require_client_auth is true
0000000000000000000000000000000000000000;;	    # truststore: conf/.truststore
0000000000000000000000000000000000000000;;	    # truststore_password: cassandra
0000000000000000000000000000000000000000;;	    # More advanced defaults below:
0000000000000000000000000000000000000000;;	    # protocol: TLS
0000000000000000000000000000000000000000;;	    # algorithm: SunX509
0000000000000000000000000000000000000000;;	    # store_type: JKS
0000000000000000000000000000000000000000;;	    # cipher_suites: [TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_DHE_RSA_WITH_AES_128_CBC_SHA,TLS_DHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# internode_compression controls whether traffic between nodes is
0000000000000000000000000000000000000000;;	# compressed.
0000000000000000000000000000000000000000;;	# can be:  all  - all traffic is compressed
0000000000000000000000000000000000000000;;	#          dc   - traffic between different datacenters is compressed
0000000000000000000000000000000000000000;;	#          none - nothing is compressed.
0000000000000000000000000000000000000000;;	internode_compression: all
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Enable or disable tcp_nodelay for inter-dc communication.
0000000000000000000000000000000000000000;;	# Disabling it will result in larger (but fewer) network packets being sent,
0000000000000000000000000000000000000000;;	# reducing overhead from the TCP protocol itself, at the cost of increasing
0000000000000000000000000000000000000000;;	# latency if you block for cross-datacenter responses.
0000000000000000000000000000000000000000;;	inter_dc_tcp_nodelay: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# TTL for different trace types used during logging of the repair process.
0000000000000000000000000000000000000000;;	tracetype_query_ttl: 86400
0000000000000000000000000000000000000000;;	tracetype_repair_ttl: 604800
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# GC Pauses greater than gc_warn_threshold_in_ms will be logged at WARN level
0000000000000000000000000000000000000000;;	# Adjust the threshold based on your application throughput requirement
0000000000000000000000000000000000000000;;	# By default, Cassandra logs GC Pauses greater than 200 ms at INFO level
0000000000000000000000000000000000000000;;	gc_warn_threshold_in_ms: 1000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# UDFs (user defined functions) are disabled by default.
0000000000000000000000000000000000000000;;	# As of Cassandra 3.0 there is a sandbox in place that should prevent execution of evil code.
0000000000000000000000000000000000000000;;	enable_user_defined_functions: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Enables scripted UDFs (JavaScript UDFs).
0000000000000000000000000000000000000000;;	# Java UDFs are always enabled, if enable_user_defined_functions is true.
0000000000000000000000000000000000000000;;	# Enable this option to be able to use UDFs with "language javascript" or any custom JSR-223 provider.
0000000000000000000000000000000000000000;;	# This option has no effect, if enable_user_defined_functions is false.
0000000000000000000000000000000000000000;;	enable_scripted_user_defined_functions: false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The default Windows kernel timer and scheduling resolution is 15.6ms for power conservation.
0000000000000000000000000000000000000000;;	# Lowering this value on Windows can provide much tighter latency and better throughput, however
0000000000000000000000000000000000000000;;	# some virtualized environments may see a negative performance impact from changing this setting
0000000000000000000000000000000000000000;;	# below their system default. The sysinternals 'clockres' tool can confirm your system's default
0000000000000000000000000000000000000000;;	# setting.
0000000000000000000000000000000000000000;;	windows_timer_interval: 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Enables encrypting data at-rest (on disk). Different key providers can be plugged in, but the default reads from
0000000000000000000000000000000000000000;;	# a JCE-style keystore. A single keystore can hold multiple keys, but the one referenced by
0000000000000000000000000000000000000000;;	# the "key_alias" is the only key that will be used for encrypt opertaions; previously used keys
0000000000000000000000000000000000000000;;	# can still (and should!) be in the keystore and will be used on decrypt operations
0000000000000000000000000000000000000000;;	# (to handle the case of key rotation).
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# It is strongly recommended to download and install Java Cryptography Extension (JCE)
0000000000000000000000000000000000000000;;	# Unlimited Strength Jurisdiction Policy Files for your version of the JDK.
0000000000000000000000000000000000000000;;	# (current link: http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Currently, only the following file types are supported for transparent data encryption, although
0000000000000000000000000000000000000000;;	# more are coming in future cassandra releases: commitlog, hints
0000000000000000000000000000000000000000;;	transparent_data_encryption_options:
0000000000000000000000000000000000000000;;	    enabled: false
0000000000000000000000000000000000000000;;	    chunk_length_kb: 64
0000000000000000000000000000000000000000;;	    cipher: AES/CBC/PKCS5Padding
0000000000000000000000000000000000000000;;	    key_alias: testing:1
0000000000000000000000000000000000000000;;	    # CBC IV length for AES needs to be 16 bytes (which is also the default size)
0000000000000000000000000000000000000000;;	    # iv_length: 16
0000000000000000000000000000000000000000;;	    key_provider: 
0000000000000000000000000000000000000000;;	      - class_name: org.apache.cassandra.security.JKSKeyProvider
0000000000000000000000000000000000000000;;	        parameters: 
0000000000000000000000000000000000000000;;	          - keystore: conf/.keystore
0000000000000000000000000000000000000000;;	            keystore_password: cassandra
0000000000000000000000000000000000000000;;	            store_type: JCEKS
0000000000000000000000000000000000000000;;	            key_password: cassandra
0000000000000000000000000000000000000000;;	
