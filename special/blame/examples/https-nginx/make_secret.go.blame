0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
927a5c73858f305ce8fd757d1e4dafa24bc72569;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A small script that converts the given open ssl public/private keys to
0000000000000000000000000000000000000000;;	// a secret that it writes to stdout as json. Most common use case is to
0000000000000000000000000000000000000000;;	// create a secret from self signed certificates used to authenticate with
0000000000000000000000000000000000000000;;	// a devserver. Usage: go run make_secret.go -crt ca.crt -key priv.key > secret.json
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This installs the legacy v1 API
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/api/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	// Add a -o flag that writes to the specified destination file.
0000000000000000000000000000000000000000;;	// Teach the script to create crt and key if -crt and -key aren't specified.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		crt = flag.String("crt", "", "path to nginx certificates.")
0000000000000000000000000000000000000000;;		key = flag.String("key", "", "path to nginx private key.")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func read(file string) []byte {
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("Cannot read file %v, %v", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;		if *crt == "" || *key == "" {
0000000000000000000000000000000000000000;;			log.Fatalf("Need to specify -crt -key and -template")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nginxCrt := read(*crt)
0000000000000000000000000000000000000000;;		nginxKey := read(*key)
0000000000000000000000000000000000000000;;		secret := &api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "nginxsecret",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"nginx.crt": nginxCrt,
0000000000000000000000000000000000000000;;				"nginx.key": nginxKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Printf(runtime.EncodeOrDie(api.Codecs.LegacyCodec(api.Registry.EnabledVersions()...), secret))
0000000000000000000000000000000000000000;;	}
