0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6500db57949cbd8df90efbdff3251d221998769c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package core
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/externalversions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/quota/generic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pvcResources are the set of static resources managed by quota associated with pvcs.
0000000000000000000000000000000000000000;;	// for each resouce in this list, it may be refined dynamically based on storage class.
0000000000000000000000000000000000000000;;	var pvcResources = []api.ResourceName{
0000000000000000000000000000000000000000;;		api.ResourcePersistentVolumeClaims,
0000000000000000000000000000000000000000;;		api.ResourceRequestsStorage,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// storageClassSuffix is the suffix to the qualified portion of storage class resource name.
0000000000000000000000000000000000000000;;	// For example, if you want to quota storage by storage class, you would have a declaration
0000000000000000000000000000000000000000;;	// that follows <storage-class>.storageclass.storage.k8s.io/<resource>.
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// * gold.storageclass.storage.k8s.io/: 500Gi
0000000000000000000000000000000000000000;;	// * bronze.storageclass.storage.k8s.io/requests.storage: 500Gi
0000000000000000000000000000000000000000;;	const storageClassSuffix string = ".storageclass.storage.k8s.io/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceByStorageClass returns a quota resource name by storage class.
0000000000000000000000000000000000000000;;	func ResourceByStorageClass(storageClass string, resourceName api.ResourceName) api.ResourceName {
0000000000000000000000000000000000000000;;		return api.ResourceName(string(storageClass + storageClassSuffix + string(resourceName)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// V1ResourceByStorageClass returns a quota resource name by storage class.
0000000000000000000000000000000000000000;;	func V1ResourceByStorageClass(storageClass string, resourceName v1.ResourceName) v1.ResourceName {
0000000000000000000000000000000000000000;;		return v1.ResourceName(string(storageClass + storageClassSuffix + string(resourceName)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listPersistentVolumeClaimsByNamespaceFuncUsingClient returns a pvc listing function based on the provided client.
0000000000000000000000000000000000000000;;	func listPersistentVolumeClaimsByNamespaceFuncUsingClient(kubeClient clientset.Interface) generic.ListFuncByNamespace {
0000000000000000000000000000000000000000;;		// TODO: ideally, we could pass dynamic client pool down into this code, and have one way of doing this.
0000000000000000000000000000000000000000;;		// unfortunately, dynamic client works with Unstructured objects, and when we calculate Usage, we require
0000000000000000000000000000000000000000;;		// structured objects.
0000000000000000000000000000000000000000;;		return func(namespace string, options metav1.ListOptions) ([]runtime.Object, error) {
0000000000000000000000000000000000000000;;			itemList, err := kubeClient.Core().PersistentVolumeClaims(namespace).List(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			results := make([]runtime.Object, 0, len(itemList.Items))
0000000000000000000000000000000000000000;;			for i := range itemList.Items {
0000000000000000000000000000000000000000;;				results = append(results, &itemList.Items[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return results, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPersistentVolumeClaimEvaluator returns an evaluator that can evaluate persistent volume claims
0000000000000000000000000000000000000000;;	// if the specified shared informer factory is not nil, evaluator may use it to support listing functions.
0000000000000000000000000000000000000000;;	func NewPersistentVolumeClaimEvaluator(kubeClient clientset.Interface, f informers.SharedInformerFactory) quota.Evaluator {
0000000000000000000000000000000000000000;;		listFuncByNamespace := listPersistentVolumeClaimsByNamespaceFuncUsingClient(kubeClient)
0000000000000000000000000000000000000000;;		if f != nil {
0000000000000000000000000000000000000000;;			listFuncByNamespace = generic.ListResourceUsingInformerFunc(f, v1.SchemeGroupVersion.WithResource("persistentvolumeclaims"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &pvcEvaluator{
0000000000000000000000000000000000000000;;			listFuncByNamespace: listFuncByNamespace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pvcEvaluator knows how to evaluate quota usage for persistent volume claims
0000000000000000000000000000000000000000;;	type pvcEvaluator struct {
0000000000000000000000000000000000000000;;		// listFuncByNamespace knows how to list pvc claims
0000000000000000000000000000000000000000;;		listFuncByNamespace generic.ListFuncByNamespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constraints verifies that all required resources are present on the item.
0000000000000000000000000000000000000000;;	func (p *pvcEvaluator) Constraints(required []api.ResourceName, item runtime.Object) error {
0000000000000000000000000000000000000000;;		pvc, ok := item.(*api.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected input object %v", item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// these are the items that we will be handling based on the objects actual storage-class
0000000000000000000000000000000000000000;;		pvcRequiredSet := append([]api.ResourceName{}, pvcResources...)
0000000000000000000000000000000000000000;;		if storageClassRef := helper.GetPersistentVolumeClaimClass(pvc); len(storageClassRef) > 0 {
0000000000000000000000000000000000000000;;			pvcRequiredSet = append(pvcRequiredSet, ResourceByStorageClass(storageClassRef, api.ResourcePersistentVolumeClaims))
0000000000000000000000000000000000000000;;			pvcRequiredSet = append(pvcRequiredSet, ResourceByStorageClass(storageClassRef, api.ResourceRequestsStorage))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// in effect, this will remove things from the required set that are not tied to this pvcs storage class
0000000000000000000000000000000000000000;;		// for example, if a quota has bronze and gold storage class items defined, we should not error a bronze pvc for not being gold.
0000000000000000000000000000000000000000;;		// but we should error a bronze pvc if it doesn't make a storage request size...
0000000000000000000000000000000000000000;;		requiredResources := quota.Intersection(required, pvcRequiredSet)
0000000000000000000000000000000000000000;;		requiredSet := quota.ToSet(requiredResources)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// usage for this pvc will only include global pvc items + this storage class specific items
0000000000000000000000000000000000000000;;		pvcUsage, err := p.Usage(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// determine what required resources were not tracked by usage.
0000000000000000000000000000000000000000;;		missingSet := sets.NewString()
0000000000000000000000000000000000000000;;		pvcSet := quota.ToSet(quota.ResourceNames(pvcUsage))
0000000000000000000000000000000000000000;;		if diff := requiredSet.Difference(pvcSet); len(diff) > 0 {
0000000000000000000000000000000000000000;;			missingSet.Insert(diff.List()...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(missingSet) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("must specify %s", strings.Join(missingSet.List(), ","))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupKind that this evaluator tracks
0000000000000000000000000000000000000000;;	func (p *pvcEvaluator) GroupKind() schema.GroupKind {
0000000000000000000000000000000000000000;;		return api.Kind("PersistentVolumeClaim")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handles returns true if the evaluator should handle the specified operation.
0000000000000000000000000000000000000000;;	func (p *pvcEvaluator) Handles(operation admission.Operation) bool {
0000000000000000000000000000000000000000;;		return admission.Create == operation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matches returns true if the evaluator matches the specified quota with the provided input item
0000000000000000000000000000000000000000;;	func (p *pvcEvaluator) Matches(resourceQuota *api.ResourceQuota, item runtime.Object) (bool, error) {
0000000000000000000000000000000000000000;;		return generic.Matches(resourceQuota, item, p.MatchingResources, generic.MatchesNoScopeFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchingResources takes the input specified list of resources and returns the set of resources it matches.
0000000000000000000000000000000000000000;;	func (p *pvcEvaluator) MatchingResources(items []api.ResourceName) []api.ResourceName {
0000000000000000000000000000000000000000;;		result := []api.ResourceName{}
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if quota.Contains(pvcResources, item) {
0000000000000000000000000000000000000000;;				result = append(result, item)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// match pvc resources scoped by storage class (<storage-class-name>.storage-class.kubernetes.io/<resource>)
0000000000000000000000000000000000000000;;			for _, resource := range pvcResources {
0000000000000000000000000000000000000000;;				byStorageClass := storageClassSuffix + string(resource)
0000000000000000000000000000000000000000;;				if strings.HasSuffix(string(item), byStorageClass) {
0000000000000000000000000000000000000000;;					result = append(result, item)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usage knows how to measure usage associated with item.
0000000000000000000000000000000000000000;;	func (p *pvcEvaluator) Usage(item runtime.Object) (api.ResourceList, error) {
0000000000000000000000000000000000000000;;		result := api.ResourceList{}
0000000000000000000000000000000000000000;;		pvc, err := toInternalPersistentVolumeClaimOrError(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return result, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storageClassRef := helper.GetPersistentVolumeClaimClass(pvc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// charge for claim
0000000000000000000000000000000000000000;;		result[api.ResourcePersistentVolumeClaims] = resource.MustParse("1")
0000000000000000000000000000000000000000;;		if len(storageClassRef) > 0 {
0000000000000000000000000000000000000000;;			storageClassClaim := api.ResourceName(storageClassRef + storageClassSuffix + string(api.ResourcePersistentVolumeClaims))
0000000000000000000000000000000000000000;;			result[storageClassClaim] = resource.MustParse("1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// charge for storage
0000000000000000000000000000000000000000;;		if request, found := pvc.Spec.Resources.Requests[api.ResourceStorage]; found {
0000000000000000000000000000000000000000;;			result[api.ResourceRequestsStorage] = request
0000000000000000000000000000000000000000;;			// charge usage to the storage class (if present)
0000000000000000000000000000000000000000;;			if len(storageClassRef) > 0 {
0000000000000000000000000000000000000000;;				storageClassStorage := api.ResourceName(storageClassRef + storageClassSuffix + string(api.ResourceRequestsStorage))
0000000000000000000000000000000000000000;;				result[storageClassStorage] = request
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UsageStats calculates aggregate usage for the object.
0000000000000000000000000000000000000000;;	func (p *pvcEvaluator) UsageStats(options quota.UsageStatsOptions) (quota.UsageStats, error) {
0000000000000000000000000000000000000000;;		return generic.CalculateUsageStats(options, p.listFuncByNamespace, generic.MatchesNoScopeFunc, p.Usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensure we implement required interface
0000000000000000000000000000000000000000;;	var _ quota.Evaluator = &pvcEvaluator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toInternalPersistentVolumeClaimOrError(obj runtime.Object) (*api.PersistentVolumeClaim, error) {
0000000000000000000000000000000000000000;;		pvc := &api.PersistentVolumeClaim{}
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *v1.PersistentVolumeClaim:
0000000000000000000000000000000000000000;;			if err := k8s_api_v1.Convert_v1_PersistentVolumeClaim_To_api_PersistentVolumeClaim(t, pvc, nil); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *api.PersistentVolumeClaim:
0000000000000000000000000000000000000000;;			pvc = t
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expect *api.PersistentVolumeClaim or *v1.PersistentVolumeClaim, got %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pvc, nil
0000000000000000000000000000000000000000;;	}
