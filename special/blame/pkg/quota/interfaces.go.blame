0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6500db57949cbd8df90efbdff3251d221998769c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package quota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UsageStatsOptions is an options structs that describes how stats should be calculated
0000000000000000000000000000000000000000;;	type UsageStatsOptions struct {
0000000000000000000000000000000000000000;;		// Namespace where stats should be calculate
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		// Scopes that must match counted objects
0000000000000000000000000000000000000000;;		Scopes []api.ResourceQuotaScope
0000000000000000000000000000000000000000;;		// Resources are the set of resources to include in the measurement
0000000000000000000000000000000000000000;;		Resources []api.ResourceName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UsageStats is result of measuring observed resource use in the system
0000000000000000000000000000000000000000;;	type UsageStats struct {
0000000000000000000000000000000000000000;;		// Used maps resource to quantity used
0000000000000000000000000000000000000000;;		Used api.ResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Evaluator knows how to evaluate quota usage for a particular group kind
0000000000000000000000000000000000000000;;	type Evaluator interface {
0000000000000000000000000000000000000000;;		// Constraints ensures that each required resource is present on item
0000000000000000000000000000000000000000;;		Constraints(required []api.ResourceName, item runtime.Object) error
0000000000000000000000000000000000000000;;		// GroupKind returns the groupKind that this object knows how to evaluate
0000000000000000000000000000000000000000;;		GroupKind() schema.GroupKind
0000000000000000000000000000000000000000;;		// Handles determines if quota could be impacted by the specified operation.
0000000000000000000000000000000000000000;;		// If true, admission control must perform quota processing for the operation, otherwise it is safe to ignore quota.
0000000000000000000000000000000000000000;;		Handles(operation admission.Operation) bool
0000000000000000000000000000000000000000;;		// Matches returns true if the specified quota matches the input item
0000000000000000000000000000000000000000;;		Matches(resourceQuota *api.ResourceQuota, item runtime.Object) (bool, error)
0000000000000000000000000000000000000000;;		// MatchingResources takes the input specified list of resources and returns the set of resources evaluator matches.
0000000000000000000000000000000000000000;;		MatchingResources(input []api.ResourceName) []api.ResourceName
0000000000000000000000000000000000000000;;		// Usage returns the resource usage for the specified object
0000000000000000000000000000000000000000;;		Usage(item runtime.Object) (api.ResourceList, error)
0000000000000000000000000000000000000000;;		// UsageStats calculates latest observed usage stats for all objects
0000000000000000000000000000000000000000;;		UsageStats(options UsageStatsOptions) (UsageStats, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Registry holds the list of evaluators associated to a particular group kind
0000000000000000000000000000000000000000;;	type Registry interface {
0000000000000000000000000000000000000000;;		// Evaluators returns the set Evaluator objects registered to a groupKind
0000000000000000000000000000000000000000;;		Evaluators() map[schema.GroupKind]Evaluator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnionRegistry combines multiple registries.  Order matters because first registry to claim a GroupKind
0000000000000000000000000000000000000000;;	// is the "winner"
0000000000000000000000000000000000000000;;	type UnionRegistry []Registry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Evaluators returns a mapping of evaluators by group kind.
0000000000000000000000000000000000000000;;	func (r UnionRegistry) Evaluators() map[schema.GroupKind]Evaluator {
0000000000000000000000000000000000000000;;		ret := map[schema.GroupKind]Evaluator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := len(r) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			for k, v := range r[i].Evaluators() {
0000000000000000000000000000000000000000;;				ret[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
