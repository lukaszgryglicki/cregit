0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
14a1530ccc358b93e7ac1647a4ed044bd0e6378a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		apiserverserviceaccount "k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		serviceaccountcontroller "k8s.io/kubernetes/pkg/controller/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const otherPublicKey = `-----BEGIN PUBLIC KEY-----
0000000000000000000000000000000000000000;;	MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArXz0QkIG1B5Bj2/W69GH
0000000000000000000000000000000000000000;;	rsm5e+RC3kE+VTgocge0atqlLBek35tRqLgUi3AcIrBZ/0YctMSWDVcRt5fkhWwe
0000000000000000000000000000000000000000;;	Lqjj6qvAyNyOkrkBi1NFDpJBjYJtuKHgRhNxXbOzTSNpdSKXTfOkzqv56MwHOP25
0000000000000000000000000000000000000000;;	yP/NNAODUtr92D5ySI5QX8RbXW+uDn+ixul286PBW/BCrE4tuS88dA0tYJPf8LCu
0000000000000000000000000000000000000000;;	sqQOwlXYH/rNUg4Pyl9xxhR5DIJR0OzNNfChjw60zieRIt2LfM83fXhwk8IxRGkc
0000000000000000000000000000000000000000;;	gPZm7ZsipmfbZK2Tkhnpsa4QxDg7zHJPMsB5kxRXW0cQipXcC3baDyN9KBApNXa0
0000000000000000000000000000000000000000;;	PwIDAQAB
0000000000000000000000000000000000000000;;	-----END PUBLIC KEY-----`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const rsaPublicKey = `-----BEGIN PUBLIC KEY-----
0000000000000000000000000000000000000000;;	MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA249XwEo9k4tM8fMxV7zx
0000000000000000000000000000000000000000;;	OhcrP+WvXn917koM5Qr2ZXs4vo26e4ytdlrV0bQ9SlcLpQVSYjIxNfhTZdDt+ecI
0000000000000000000000000000000000000000;;	zshKuv1gKIxbbLQMOuK1eA/4HALyEkFgmS/tleLJrhc65tKPMGD+pKQ/xhmzRuCG
0000000000000000000000000000000000000000;;	51RoiMgbQxaCyYxGfNLpLAZK9L0Tctv9a0mJmGIYnIOQM4kC1A1I1n3EsXMWmeJU
0000000000000000000000000000000000000000;;	j7OTh/AjjCnMnkgvKT2tpKxYQ59PgDgU8Ssc7RDSmSkLxnrv+OrN80j6xrw0OjEi
0000000000000000000000000000000000000000;;	B4Ycr0PqfzZcvy8efTtFQ/Jnc4Bp1zUtFXt7+QeevePtQ2EcyELXE0i63T1CujRM
0000000000000000000000000000000000000000;;	WwIDAQAB
0000000000000000000000000000000000000000;;	-----END PUBLIC KEY-----
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const rsaPrivateKey = `-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIEowIBAAKCAQEA249XwEo9k4tM8fMxV7zxOhcrP+WvXn917koM5Qr2ZXs4vo26
0000000000000000000000000000000000000000;;	e4ytdlrV0bQ9SlcLpQVSYjIxNfhTZdDt+ecIzshKuv1gKIxbbLQMOuK1eA/4HALy
0000000000000000000000000000000000000000;;	EkFgmS/tleLJrhc65tKPMGD+pKQ/xhmzRuCG51RoiMgbQxaCyYxGfNLpLAZK9L0T
0000000000000000000000000000000000000000;;	ctv9a0mJmGIYnIOQM4kC1A1I1n3EsXMWmeJUj7OTh/AjjCnMnkgvKT2tpKxYQ59P
0000000000000000000000000000000000000000;;	gDgU8Ssc7RDSmSkLxnrv+OrN80j6xrw0OjEiB4Ycr0PqfzZcvy8efTtFQ/Jnc4Bp
0000000000000000000000000000000000000000;;	1zUtFXt7+QeevePtQ2EcyELXE0i63T1CujRMWwIDAQABAoIBAHJx8GqyCBDNbqk7
0000000000000000000000000000000000000000;;	e7/hI9iE1S10Wwol5GH2RWxqX28cYMKq+8aE2LI1vPiXO89xOgelk4DN6urX6xjK
0000000000000000000000000000000000000000;;	ZBF8RRIMQy/e/O2F4+3wl+Nl4vOXV1u6iVXMsD6JRg137mqJf1Fr9elg1bsaRofL
0000000000000000000000000000000000000000;;	Q7CxPoB8dhS+Qb+hj0DhlqhgA9zG345CQCAds0ZYAZe8fP7bkwrLqZpMn7Dz9WVm
0000000000000000000000000000000000000000;;	++YgYYKjuE95kPuup/LtWfA9rJyE/Fws8/jGvRSpVn1XglMLSMKhLd27sE8ZUSV0
0000000000000000000000000000000000000000;;	2KUzbfRGE0+AnRULRrjpYaPu0XQ2JjdNvtkjBnv27RB89W9Gklxq821eH1Y8got8
0000000000000000000000000000000000000000;;	FZodjxECgYEA93pz7AQZ2xDs67d1XLCzpX84GxKzttirmyj3OIlxgzVHjEMsvw8v
0000000000000000000000000000000000000000;;	sjFiBU5xEEQDosrBdSknnlJqyiq1YwWG/WDckr13d8G2RQWoySN7JVmTQfXcLoTu
0000000000000000000000000000000000000000;;	YGRiiTuoEi3ab3ZqrgGrFgX7T/cHuasbYvzCvhM2b4VIR3aSxU2DTUMCgYEA4x7J
0000000000000000000000000000000000000000;;	T/ErP6GkU5nKstu/mIXwNzayEO1BJvPYsy7i7EsxTm3xe/b8/6cYOz5fvJLGH5mT
0000000000000000000000000000000000000000;;	Q8YvuLqBcMwZardrYcwokD55UvNLOyfADDFZ6l3WntIqbA640Ok2g1X4U8J09xIq
0000000000000000000000000000000000000000;;	ZLIWK1yWbbvi4QCeN5hvWq47e8sIj5QHjIIjRwkCgYEAyNqjltxFN9zmzPDa2d24
0000000000000000000000000000000000000000;;	EAvOt3pYTYBQ1t9KtqImdL0bUqV6fZ6PsWoPCgt+DBuHb+prVPGP7Bkr/uTmznU/
0000000000000000000000000000000000000000;;	+AlTO+12NsYLbr2HHagkXE31DEXE7CSLa8RNjN/UKtz4Ohq7vnowJvG35FCz/mb3
0000000000000000000000000000000000000000;;	FUHbtHTXa2+bGBUOTf/5Hw0CgYBxw0r9EwUhw1qnUYJ5op7OzFAtp+T7m4ul8kCa
0000000000000000000000000000000000000000;;	SCL8TxGsgl+SQ34opE775dtYfoBk9a0RJqVit3D8yg71KFjOTNAIqHJm/Vyyjc+h
0000000000000000000000000000000000000000;;	i9rJDSXiuczsAVfLtPVMRfS0J9QkqeG4PIfkQmVLI/CZ2ZBmsqEcX+eFs4ZfPLun
0000000000000000000000000000000000000000;;	Qsxe2QKBgGuPilIbLeIBDIaPiUI0FwU8v2j8CEQBYvoQn34c95hVQsig/o5z7zlo
0000000000000000000000000000000000000000;;	UsO0wlTngXKlWdOcCs1kqEhTLrstf48djDxAYAxkw40nzeJOt7q52ib/fvf4/UBy
0000000000000000000000000000000000000000;;	X024wzbiw1q07jFCyfQmODzURAx1VNT7QVUMdz/N8vy47/H40AZJ
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openssl ecparam -name prime256v1 -genkey -out ecdsa256params.pem
0000000000000000000000000000000000000000;;	const ecdsaPrivateKeyWithParams = `-----BEGIN EC PARAMETERS-----
0000000000000000000000000000000000000000;;	BggqhkjOPQMBBw==
0000000000000000000000000000000000000000;;	-----END EC PARAMETERS-----
0000000000000000000000000000000000000000;;	-----BEGIN EC PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MHcCAQEEIJ9LWDj3ZWe9CksPV7mZjD2dYXG9icfzxadCRwd3vr1toAoGCCqGSM49
0000000000000000000000000000000000000000;;	AwEHoUQDQgAEaLNEpzbaaNTCkKjBVj7sxpfJ1ifJQGNvcck4nrzcwFRuujwVDDJh
0000000000000000000000000000000000000000;;	95iIGwKCQeSg+yhdN6Q/p2XaxNIZlYmUhg==
0000000000000000000000000000000000000000;;	-----END EC PRIVATE KEY-----
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openssl ecparam -name prime256v1 -genkey -noout -out ecdsa256.pem
0000000000000000000000000000000000000000;;	const ecdsaPrivateKey = `-----BEGIN EC PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MHcCAQEEIEZmTmUhuanLjPA2CLquXivuwBDHTt5XYwgIr/kA1LtRoAoGCCqGSM49
0000000000000000000000000000000000000000;;	AwEHoUQDQgAEH6cuzP8XuD5wal6wf9M6xDljTOPLX2i8uIp/C/ASqiIGUeeKQtX0
0000000000000000000000000000000000000000;;	/IR3qCXyThP/dbCiHrF3v1cuhBOHY8CLVg==
0000000000000000000000000000000000000000;;	-----END EC PRIVATE KEY-----`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openssl ec -in ecdsa256.pem -pubout -out ecdsa256pub.pem
0000000000000000000000000000000000000000;;	const ecdsaPublicKey = `-----BEGIN PUBLIC KEY-----
0000000000000000000000000000000000000000;;	MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEH6cuzP8XuD5wal6wf9M6xDljTOPL
0000000000000000000000000000000000000000;;	X2i8uIp/C/ASqiIGUeeKQtX0/IR3qCXyThP/dbCiHrF3v1cuhBOHY8CLVg==
0000000000000000000000000000000000000000;;	-----END PUBLIC KEY-----`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPrivateKey(data string) interface{} {
0000000000000000000000000000000000000000;;		key, _ := cert.ParsePrivateKeyPEM([]byte(data))
0000000000000000000000000000000000000000;;		return key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPublicKey(data string) interface{} {
0000000000000000000000000000000000000000;;		keys, _ := serviceaccount.ReadPublicKeysFromPEM([]byte(data))
0000000000000000000000000000000000000000;;		return keys[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestReadPrivateKey(t *testing.T) {
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(f.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := serviceaccount.ReadPrivateKey(f.Name()); err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected error reading key from empty file, got none")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(rsaPrivateKey), os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error writing private key to tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := serviceaccount.ReadPrivateKey(f.Name()); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error reading private RSA key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(ecdsaPrivateKey), os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error writing private key to tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := serviceaccount.ReadPrivateKey(f.Name()); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error reading private ECDSA key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(ecdsaPrivateKeyWithParams), os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error writing private key to tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := serviceaccount.ReadPrivateKey(f.Name()); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error reading private ECDSA key with params: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadPublicKeys(t *testing.T) {
0000000000000000000000000000000000000000;;		f, err := ioutil.TempFile("", "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(f.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := serviceaccount.ReadPublicKeys(f.Name()); err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected error reading keys from empty file, got none")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(rsaPublicKey), os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error writing public key to tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if keys, err := serviceaccount.ReadPublicKeys(f.Name()); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error reading RSA public key: %v", err)
0000000000000000000000000000000000000000;;		} else if len(keys) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 1 key, got %d", len(keys))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(ecdsaPublicKey), os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error writing public key to tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if keys, err := serviceaccount.ReadPublicKeys(f.Name()); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error reading ECDSA public key: %v", err)
0000000000000000000000000000000000000000;;		} else if len(keys) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 1 key, got %d", len(keys))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f.Name(), []byte(rsaPublicKey+"\n"+ecdsaPublicKey), os.FileMode(0600)); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error writing public key to tmpfile: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if keys, err := serviceaccount.ReadPublicKeys(f.Name()); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error reading combined RSA/ECDSA public key file: %v", err)
0000000000000000000000000000000000000000;;		} else if len(keys) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected 2 keys, got %d", len(keys))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTokenGenerateAndValidate(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedUserName := "system:serviceaccount:test:my-service-account"
0000000000000000000000000000000000000000;;		expectedUserUID := "12345"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Related API objects
0000000000000000000000000000000000000000;;		serviceAccount := &v1.ServiceAccount{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "my-service-account",
0000000000000000000000000000000000000000;;				UID:       "12345",
0000000000000000000000000000000000000000;;				Namespace: "test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsaSecret := &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "my-rsa-secret",
0000000000000000000000000000000000000000;;				Namespace: "test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ecdsaSecret := &v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "my-ecdsa-secret",
0000000000000000000000000000000000000000;;				Namespace: "test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the RSA token
0000000000000000000000000000000000000000;;		rsaGenerator := serviceaccount.JWTTokenGenerator(getPrivateKey(rsaPrivateKey))
0000000000000000000000000000000000000000;;		rsaToken, err := rsaGenerator.GenerateToken(*serviceAccount, *rsaSecret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error generating token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rsaToken) == 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("no token generated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsaSecret.Data = map[string][]byte{
0000000000000000000000000000000000000000;;			"token": []byte(rsaToken),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the ECDSA token
0000000000000000000000000000000000000000;;		ecdsaGenerator := serviceaccount.JWTTokenGenerator(getPrivateKey(ecdsaPrivateKey))
0000000000000000000000000000000000000000;;		ecdsaToken, err := ecdsaGenerator.GenerateToken(*serviceAccount, *ecdsaSecret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error generating token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ecdsaToken) == 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("no token generated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ecdsaSecret.Data = map[string][]byte{
0000000000000000000000000000000000000000;;			"token": []byte(ecdsaToken),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			Client clientset.Interface
0000000000000000000000000000000000000000;;			Keys   []interface{}
0000000000000000000000000000000000000000;;			Token  string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectedErr      bool
0000000000000000000000000000000000000000;;			ExpectedOK       bool
0000000000000000000000000000000000000000;;			ExpectedUserName string
0000000000000000000000000000000000000000;;			ExpectedUserUID  string
0000000000000000000000000000000000000000;;			ExpectedGroups   []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no keys": {
0000000000000000000000000000000000000000;;				Token:       rsaToken,
0000000000000000000000000000000000000000;;				Client:      nil,
0000000000000000000000000000000000000000;;				Keys:        []interface{}{},
0000000000000000000000000000000000000000;;				ExpectedErr: false,
0000000000000000000000000000000000000000;;				ExpectedOK:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid keys (rsa)": {
0000000000000000000000000000000000000000;;				Token:       rsaToken,
0000000000000000000000000000000000000000;;				Client:      nil,
0000000000000000000000000000000000000000;;				Keys:        []interface{}{getPublicKey(otherPublicKey), getPublicKey(ecdsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr: true,
0000000000000000000000000000000000000000;;				ExpectedOK:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid keys (ecdsa)": {
0000000000000000000000000000000000000000;;				Token:       ecdsaToken,
0000000000000000000000000000000000000000;;				Client:      nil,
0000000000000000000000000000000000000000;;				Keys:        []interface{}{getPublicKey(otherPublicKey), getPublicKey(rsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr: true,
0000000000000000000000000000000000000000;;				ExpectedOK:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid key (rsa)": {
0000000000000000000000000000000000000000;;				Token:            rsaToken,
0000000000000000000000000000000000000000;;				Client:           nil,
0000000000000000000000000000000000000000;;				Keys:             []interface{}{getPublicKey(rsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr:      false,
0000000000000000000000000000000000000000;;				ExpectedOK:       true,
0000000000000000000000000000000000000000;;				ExpectedUserName: expectedUserName,
0000000000000000000000000000000000000000;;				ExpectedUserUID:  expectedUserUID,
0000000000000000000000000000000000000000;;				ExpectedGroups:   []string{"system:serviceaccounts", "system:serviceaccounts:test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid key (ecdsa)": {
0000000000000000000000000000000000000000;;				Token:            ecdsaToken,
0000000000000000000000000000000000000000;;				Client:           nil,
0000000000000000000000000000000000000000;;				Keys:             []interface{}{getPublicKey(ecdsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr:      false,
0000000000000000000000000000000000000000;;				ExpectedOK:       true,
0000000000000000000000000000000000000000;;				ExpectedUserName: expectedUserName,
0000000000000000000000000000000000000000;;				ExpectedUserUID:  expectedUserUID,
0000000000000000000000000000000000000000;;				ExpectedGroups:   []string{"system:serviceaccounts", "system:serviceaccounts:test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"rotated keys (rsa)": {
0000000000000000000000000000000000000000;;				Token:            rsaToken,
0000000000000000000000000000000000000000;;				Client:           nil,
0000000000000000000000000000000000000000;;				Keys:             []interface{}{getPublicKey(otherPublicKey), getPublicKey(ecdsaPublicKey), getPublicKey(rsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr:      false,
0000000000000000000000000000000000000000;;				ExpectedOK:       true,
0000000000000000000000000000000000000000;;				ExpectedUserName: expectedUserName,
0000000000000000000000000000000000000000;;				ExpectedUserUID:  expectedUserUID,
0000000000000000000000000000000000000000;;				ExpectedGroups:   []string{"system:serviceaccounts", "system:serviceaccounts:test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"rotated keys (ecdsa)": {
0000000000000000000000000000000000000000;;				Token:            ecdsaToken,
0000000000000000000000000000000000000000;;				Client:           nil,
0000000000000000000000000000000000000000;;				Keys:             []interface{}{getPublicKey(otherPublicKey), getPublicKey(rsaPublicKey), getPublicKey(ecdsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr:      false,
0000000000000000000000000000000000000000;;				ExpectedOK:       true,
0000000000000000000000000000000000000000;;				ExpectedUserName: expectedUserName,
0000000000000000000000000000000000000000;;				ExpectedUserUID:  expectedUserUID,
0000000000000000000000000000000000000000;;				ExpectedGroups:   []string{"system:serviceaccounts", "system:serviceaccounts:test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"valid lookup": {
0000000000000000000000000000000000000000;;				Token:            rsaToken,
0000000000000000000000000000000000000000;;				Client:           fake.NewSimpleClientset(serviceAccount, rsaSecret, ecdsaSecret),
0000000000000000000000000000000000000000;;				Keys:             []interface{}{getPublicKey(rsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr:      false,
0000000000000000000000000000000000000000;;				ExpectedOK:       true,
0000000000000000000000000000000000000000;;				ExpectedUserName: expectedUserName,
0000000000000000000000000000000000000000;;				ExpectedUserUID:  expectedUserUID,
0000000000000000000000000000000000000000;;				ExpectedGroups:   []string{"system:serviceaccounts", "system:serviceaccounts:test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid secret lookup": {
0000000000000000000000000000000000000000;;				Token:       rsaToken,
0000000000000000000000000000000000000000;;				Client:      fake.NewSimpleClientset(serviceAccount),
0000000000000000000000000000000000000000;;				Keys:        []interface{}{getPublicKey(rsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr: true,
0000000000000000000000000000000000000000;;				ExpectedOK:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invalid serviceaccount lookup": {
0000000000000000000000000000000000000000;;				Token:       rsaToken,
0000000000000000000000000000000000000000;;				Client:      fake.NewSimpleClientset(rsaSecret, ecdsaSecret),
0000000000000000000000000000000000000000;;				Keys:        []interface{}{getPublicKey(rsaPublicKey)},
0000000000000000000000000000000000000000;;				ExpectedErr: true,
0000000000000000000000000000000000000000;;				ExpectedOK:  false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, tc := range testCases {
0000000000000000000000000000000000000000;;			getter := serviceaccountcontroller.NewGetterFromClient(tc.Client)
0000000000000000000000000000000000000000;;			authenticator := serviceaccount.JWTTokenAuthenticator(tc.Keys, tc.Client != nil, getter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// An invalid, non-JWT token should always fail
0000000000000000000000000000000000000000;;			if _, ok, err := authenticator.AuthenticateToken("invalid token"); err != nil || ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected err=nil, ok=false for non-JWT token", k)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			user, ok, err := authenticator.AuthenticateToken(tc.Token)
0000000000000000000000000000000000000000;;			if (err != nil) != tc.ExpectedErr {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected error=%v, got %v", k, tc.ExpectedErr, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ok != tc.ExpectedOK {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected ok=%v, got %v", k, tc.ExpectedOK, ok)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil || !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if user.GetName() != tc.ExpectedUserName {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected username=%v, got %v", k, tc.ExpectedUserName, user.GetName())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if user.GetUID() != tc.ExpectedUserUID {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected userUID=%v, got %v", k, tc.ExpectedUserUID, user.GetUID())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(user.GetGroups(), tc.ExpectedGroups) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected groups=%v, got %v", k, tc.ExpectedGroups, user.GetGroups())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakeSplitUsername(t *testing.T) {
0000000000000000000000000000000000000000;;		username := apiserverserviceaccount.MakeUsername("ns", "name")
0000000000000000000000000000000000000000;;		ns, name, err := apiserverserviceaccount.SplitUsername(username)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ns != "ns" || name != "name" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected ns/name, got %s/%s", ns, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		invalid := []string{"test", "system:serviceaccount", "system:serviceaccount:", "system:serviceaccount:ns", "system:serviceaccount:ns:name:extra"}
0000000000000000000000000000000000000000;;		for _, n := range invalid {
0000000000000000000000000000000000000000;;			_, _, err := apiserverserviceaccount.SplitUsername("test")
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error for %s", n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
