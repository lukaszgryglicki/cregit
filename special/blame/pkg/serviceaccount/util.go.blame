0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c119e2ed54bc9c4629261b88ee42dc72ca9c5d90;pkg/controller/serviceaccount/util.go[pkg/controller/serviceaccount/util.go][pkg/serviceaccount/util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiserverserviceaccount "k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UserInfo returns a user.Info interface for the given namespace, service account name and UID
0000000000000000000000000000000000000000;;	func UserInfo(namespace, name, uid string) user.Info {
0000000000000000000000000000000000000000;;		return &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name:   apiserverserviceaccount.MakeUsername(namespace, name),
0000000000000000000000000000000000000000;;			UID:    uid,
0000000000000000000000000000000000000000;;			Groups: apiserverserviceaccount.MakeGroupNames(namespace, name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsServiceAccountToken returns true if the secret is a valid api token for the service account
0000000000000000000000000000000000000000;;	func IsServiceAccountToken(secret *v1.Secret, sa *v1.ServiceAccount) bool {
0000000000000000000000000000000000000000;;		if secret.Type != v1.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := secret.Annotations[v1.ServiceAccountNameKey]
0000000000000000000000000000000000000000;;		uid := secret.Annotations[v1.ServiceAccountUIDKey]
0000000000000000000000000000000000000000;;		if name != sa.Name {
0000000000000000000000000000000000000000;;			// Name must match
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(uid) > 0 && uid != string(sa.UID) {
0000000000000000000000000000000000000000;;			// If UID is specified, it must match
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove the duplicate code
0000000000000000000000000000000000000000;;	// InternalIsServiceAccountToken returns true if the secret is a valid api token for the service account
0000000000000000000000000000000000000000;;	func InternalIsServiceAccountToken(secret *api.Secret, sa *api.ServiceAccount) bool {
0000000000000000000000000000000000000000;;		if secret.Type != api.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := secret.Annotations[api.ServiceAccountNameKey]
0000000000000000000000000000000000000000;;		uid := secret.Annotations[api.ServiceAccountUIDKey]
0000000000000000000000000000000000000000;;		if name != sa.Name {
0000000000000000000000000000000000000000;;			// Name must match
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(uid) > 0 && uid != string(sa.UID) {
0000000000000000000000000000000000000000;;			// If UID is specified, it must match
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
