0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
14a1530ccc358b93e7ac1647a4ed044bd0e6378a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serviceaccount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		apiserverserviceaccount "k8s.io/apiserver/pkg/authentication/serviceaccount"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jwt "github.com/dgrijalva/jwt-go"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Issuer = "kubernetes/serviceaccount"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SubjectClaim            = "sub"
0000000000000000000000000000000000000000;;		IssuerClaim             = "iss"
0000000000000000000000000000000000000000;;		ServiceAccountNameClaim = "kubernetes.io/serviceaccount/service-account.name"
0000000000000000000000000000000000000000;;		ServiceAccountUIDClaim  = "kubernetes.io/serviceaccount/service-account.uid"
0000000000000000000000000000000000000000;;		SecretNameClaim         = "kubernetes.io/serviceaccount/secret.name"
0000000000000000000000000000000000000000;;		NamespaceClaim          = "kubernetes.io/serviceaccount/namespace"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountTokenGetter defines functions to retrieve a named service account and secret
0000000000000000000000000000000000000000;;	type ServiceAccountTokenGetter interface {
0000000000000000000000000000000000000000;;		GetServiceAccount(namespace, name string) (*v1.ServiceAccount, error)
0000000000000000000000000000000000000000;;		GetSecret(namespace, name string) (*v1.Secret, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TokenGenerator interface {
0000000000000000000000000000000000000000;;		// GenerateToken generates a token which will identify the given ServiceAccount.
0000000000000000000000000000000000000000;;		// The returned token will be stored in the given (and yet-unpersisted) Secret.
0000000000000000000000000000000000000000;;		GenerateToken(serviceAccount v1.ServiceAccount, secret v1.Secret) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadPrivateKey is a helper function for reading a private key from a PEM-encoded file
0000000000000000000000000000000000000000;;	func ReadPrivateKey(file string) (interface{}, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := cert.ParsePrivateKeyPEM(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading private key file %s: %v", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadPublicKeys is a helper function for reading an array of rsa.PublicKey or ecdsa.PublicKey from a PEM-encoded file.
0000000000000000000000000000000000000000;;	// Reads public keys from both public and private key files.
0000000000000000000000000000000000000000;;	func ReadPublicKeys(file string) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keys, err := ReadPublicKeysFromPEM(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading public key file %s: %v", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadPublicKeysFromPEM is a helper function for reading an array of rsa.PublicKey or ecdsa.PublicKey from a PEM-encoded byte array.
0000000000000000000000000000000000000000;;	// Reads public keys from both public and private key files.
0000000000000000000000000000000000000000;;	func ReadPublicKeysFromPEM(data []byte) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		var block *pem.Block
0000000000000000000000000000000000000000;;		keys := []interface{}{}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// read the next block
0000000000000000000000000000000000000000;;			block, data = pem.Decode(data)
0000000000000000000000000000000000000000;;			if block == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// get PEM bytes for just this block
0000000000000000000000000000000000000000;;			blockData := pem.EncodeToMemory(block)
0000000000000000000000000000000000000000;;			if privateKey, err := jwt.ParseRSAPrivateKeyFromPEM(blockData); err == nil {
0000000000000000000000000000000000000000;;				keys = append(keys, &privateKey.PublicKey)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if publicKey, err := jwt.ParseRSAPublicKeyFromPEM(blockData); err == nil {
0000000000000000000000000000000000000000;;				keys = append(keys, publicKey)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if privateKey, err := jwt.ParseECPrivateKeyFromPEM(blockData); err == nil {
0000000000000000000000000000000000000000;;				keys = append(keys, &privateKey.PublicKey)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if publicKey, err := jwt.ParseECPublicKeyFromPEM(blockData); err == nil {
0000000000000000000000000000000000000000;;				keys = append(keys, publicKey)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// tolerate non-key PEM blocks for backwards compatibility
0000000000000000000000000000000000000000;;			// originally, only the first PEM block was parsed and expected to be a key block
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(keys) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("data does not contain a valid RSA or ECDSA key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JWTTokenGenerator returns a TokenGenerator that generates signed JWT tokens, using the given privateKey.
0000000000000000000000000000000000000000;;	// privateKey is a PEM-encoded byte array of a private RSA key.
0000000000000000000000000000000000000000;;	// JWTTokenAuthenticator()
0000000000000000000000000000000000000000;;	func JWTTokenGenerator(privateKey interface{}) TokenGenerator {
0000000000000000000000000000000000000000;;		return &jwtTokenGenerator{privateKey}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jwtTokenGenerator struct {
0000000000000000000000000000000000000000;;		privateKey interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *jwtTokenGenerator) GenerateToken(serviceAccount v1.ServiceAccount, secret v1.Secret) (string, error) {
0000000000000000000000000000000000000000;;		var method jwt.SigningMethod
0000000000000000000000000000000000000000;;		switch privateKey := j.privateKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			method = jwt.SigningMethodRS256
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			switch privateKey.Curve {
0000000000000000000000000000000000000000;;			case elliptic.P256():
0000000000000000000000000000000000000000;;				method = jwt.SigningMethodES256
0000000000000000000000000000000000000000;;			case elliptic.P384():
0000000000000000000000000000000000000000;;				method = jwt.SigningMethodES384
0000000000000000000000000000000000000000;;			case elliptic.P521():
0000000000000000000000000000000000000000;;				method = jwt.SigningMethodES512
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("unknown private key curve, must be 256, 384, or 521")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unknown private key type %T, must be *rsa.PrivateKey or *ecdsa.PrivateKey", j.privateKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := jwt.New(method)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claims, _ := token.Claims.(jwt.MapClaims)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Identify the issuer
0000000000000000000000000000000000000000;;		claims[IssuerClaim] = Issuer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Username
0000000000000000000000000000000000000000;;		claims[SubjectClaim] = apiserverserviceaccount.MakeUsername(serviceAccount.Namespace, serviceAccount.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Persist enough structured info for the authenticator to be able to look up the service account and secret
0000000000000000000000000000000000000000;;		claims[NamespaceClaim] = serviceAccount.Namespace
0000000000000000000000000000000000000000;;		claims[ServiceAccountNameClaim] = serviceAccount.Name
0000000000000000000000000000000000000000;;		claims[ServiceAccountUIDClaim] = serviceAccount.UID
0000000000000000000000000000000000000000;;		claims[SecretNameClaim] = secret.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sign and get the complete encoded token as a string
0000000000000000000000000000000000000000;;		return token.SignedString(j.privateKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JWTTokenAuthenticator authenticates tokens as JWT tokens produced by JWTTokenGenerator
0000000000000000000000000000000000000000;;	// Token signatures are verified using each of the given public keys until one works (allowing key rotation)
0000000000000000000000000000000000000000;;	// If lookup is true, the service account and secret referenced as claims inside the token are retrieved and verified with the provided ServiceAccountTokenGetter
0000000000000000000000000000000000000000;;	func JWTTokenAuthenticator(keys []interface{}, lookup bool, getter ServiceAccountTokenGetter) authenticator.Token {
0000000000000000000000000000000000000000;;		return &jwtTokenAuthenticator{keys, lookup, getter}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jwtTokenAuthenticator struct {
0000000000000000000000000000000000000000;;		keys   []interface{}
0000000000000000000000000000000000000000;;		lookup bool
0000000000000000000000000000000000000000;;		getter ServiceAccountTokenGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errMismatchedSigningMethod = errors.New("invalid signing method")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *jwtTokenAuthenticator) AuthenticateToken(token string) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		var validationError error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, key := range j.keys {
0000000000000000000000000000000000000000;;			// Attempt to verify with each key until we find one that works
0000000000000000000000000000000000000000;;			parsedToken, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {
0000000000000000000000000000000000000000;;				switch token.Method.(type) {
0000000000000000000000000000000000000000;;				case *jwt.SigningMethodRSA:
0000000000000000000000000000000000000000;;					if _, ok := key.(*rsa.PublicKey); ok {
0000000000000000000000000000000000000000;;						return key, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, errMismatchedSigningMethod
0000000000000000000000000000000000000000;;				case *jwt.SigningMethodECDSA:
0000000000000000000000000000000000000000;;					if _, ok := key.(*ecdsa.PublicKey); ok {
0000000000000000000000000000000000000000;;						return key, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, errMismatchedSigningMethod
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				switch err := err.(type) {
0000000000000000000000000000000000000000;;				case *jwt.ValidationError:
0000000000000000000000000000000000000000;;					if (err.Errors & jwt.ValidationErrorMalformed) != 0 {
0000000000000000000000000000000000000000;;						// Not a JWT, no point in continuing
0000000000000000000000000000000000000000;;						return nil, false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if (err.Errors & jwt.ValidationErrorSignatureInvalid) != 0 {
0000000000000000000000000000000000000000;;						// Signature error, perhaps one of the other keys will verify the signature
0000000000000000000000000000000000000000;;						// If not, we want to return this error
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Signature error (key %d): %v", i, err)
0000000000000000000000000000000000000000;;						validationError = err
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// This key doesn't apply to the given signature type
0000000000000000000000000000000000000000;;					// Perhaps one of the other keys will verify the signature
0000000000000000000000000000000000000000;;					// If not, we want to return this error
0000000000000000000000000000000000000000;;					if err.Inner == errMismatchedSigningMethod {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Mismatched key type (key %d): %v", i, err)
0000000000000000000000000000000000000000;;						validationError = err
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Other errors should just return as errors
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we get here, we have a token with a recognized signature
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			claims, _ := parsedToken.Claims.(jwt.MapClaims)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make sure we issued the token
0000000000000000000000000000000000000000;;			iss, _ := claims[IssuerClaim].(string)
0000000000000000000000000000000000000000;;			if iss != Issuer {
0000000000000000000000000000000000000000;;				return nil, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make sure the claims we need exist
0000000000000000000000000000000000000000;;			sub, _ := claims[SubjectClaim].(string)
0000000000000000000000000000000000000000;;			if len(sub) == 0 {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("sub claim is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			namespace, _ := claims[NamespaceClaim].(string)
0000000000000000000000000000000000000000;;			if len(namespace) == 0 {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("namespace claim is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secretName, _ := claims[SecretNameClaim].(string)
0000000000000000000000000000000000000000;;			if len(namespace) == 0 {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("secretName claim is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceAccountName, _ := claims[ServiceAccountNameClaim].(string)
0000000000000000000000000000000000000000;;			if len(serviceAccountName) == 0 {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("serviceAccountName claim is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serviceAccountUID, _ := claims[ServiceAccountUIDClaim].(string)
0000000000000000000000000000000000000000;;			if len(serviceAccountUID) == 0 {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("serviceAccountUID claim is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			subjectNamespace, subjectName, err := apiserverserviceaccount.SplitUsername(sub)
0000000000000000000000000000000000000000;;			if err != nil || subjectNamespace != namespace || subjectName != serviceAccountName {
0000000000000000000000000000000000000000;;				return nil, false, errors.New("sub claim is invalid")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if j.lookup {
0000000000000000000000000000000000000000;;				// Make sure token hasn't been invalidated by deletion of the secret
0000000000000000000000000000000000000000;;				secret, err := j.getter.GetSecret(namespace, secretName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Could not retrieve token %s/%s for service account %s/%s: %v", namespace, secretName, namespace, serviceAccountName, err)
0000000000000000000000000000000000000000;;					return nil, false, errors.New("Token has been invalidated")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if secret.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Token is deleted and awaiting removal: %s/%s for service account %s/%s", namespace, secretName, namespace, serviceAccountName)
0000000000000000000000000000000000000000;;					return nil, false, errors.New("Token has been invalidated")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if bytes.Compare(secret.Data[v1.ServiceAccountTokenKey], []byte(token)) != 0 {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Token contents no longer matches %s/%s for service account %s/%s", namespace, secretName, namespace, serviceAccountName)
0000000000000000000000000000000000000000;;					return nil, false, errors.New("Token does not match server's copy")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Make sure service account still exists (name and UID)
0000000000000000000000000000000000000000;;				serviceAccount, err := j.getter.GetServiceAccount(namespace, serviceAccountName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Could not retrieve service account %s/%s: %v", namespace, serviceAccountName, err)
0000000000000000000000000000000000000000;;					return nil, false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if serviceAccount.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Service account has been deleted %s/%s", namespace, serviceAccountName)
0000000000000000000000000000000000000000;;					return nil, false, fmt.Errorf("ServiceAccount %s/%s has been deleted", namespace, serviceAccountName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if string(serviceAccount.UID) != serviceAccountUID {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Service account UID no longer matches %s/%s: %q != %q", namespace, serviceAccountName, string(serviceAccount.UID), serviceAccountUID)
0000000000000000000000000000000000000000;;					return nil, false, fmt.Errorf("ServiceAccount UID (%s) does not match claim (%s)", serviceAccount.UID, serviceAccountUID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return UserInfo(namespace, serviceAccountName, serviceAccountUID), true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, validationError
0000000000000000000000000000000000000000;;	}
