0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
693da95b5b03db47c040457cc2c2552a54c1d8a1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package api_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/ugorji/go/codec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/streaming"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		kapitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		k8s_v1beta1 "k8s.io/kubernetes/pkg/apis/extensions/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fuzzInternalObject fuzzes an arbitrary runtime object using the appropriate
0000000000000000000000000000000000000000;;	// fuzzer registered with the apitesting package.
0000000000000000000000000000000000000000;;	func fuzzInternalObject(t *testing.T, forVersion schema.GroupVersion, item runtime.Object, seed int64) runtime.Object {
0000000000000000000000000000000000000000;;		apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(seed)).Fuzz(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j, err := meta.TypeAccessor(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v for %#v", err, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j.SetKind("")
0000000000000000000000000000000000000000;;		j.SetAPIVersion("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dataAsString returns the given byte array as a string; handles detecting
0000000000000000000000000000000000000000;;	// protocol buffers.
0000000000000000000000000000000000000000;;	func dataAsString(data []byte) string {
0000000000000000000000000000000000000000;;		dataString := string(data)
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(dataString, "{") {
0000000000000000000000000000000000000000;;			dataString = "\n" + hex.Dump(data)
0000000000000000000000000000000000000000;;			proto.NewBuffer(make([]byte, 0, 1024)).DebugPrint("decoded object", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dataString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_v1beta1_ReplicaSet_to_api_ReplicationController(in *v1beta1.ReplicaSet, out *api.ReplicationController, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		intermediate1 := &extensions.ReplicaSet{}
0000000000000000000000000000000000000000;;		if err := k8s_v1beta1.Convert_v1beta1_ReplicaSet_To_extensions_ReplicaSet(in, intermediate1, s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		intermediate2 := &v1.ReplicationController{}
0000000000000000000000000000000000000000;;		if err := k8s_api_v1.Convert_extensions_ReplicaSet_to_v1_ReplicationController(intermediate1, intermediate2, s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return k8s_api_v1.Convert_v1_ReplicationController_To_api_ReplicationController(intermediate2, out, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetControllerConversion(t *testing.T) {
0000000000000000000000000000000000000000;;		if err := api.Scheme.AddConversionFuncs(Convert_v1beta1_ReplicaSet_to_api_ReplicationController); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs := &extensions.ReplicaSet{}
0000000000000000000000000000000000000000;;		rc := &api.ReplicationController{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extGroup := testapi.Extensions
0000000000000000000000000000000000000000;;		defaultGroup := testapi.Default
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fuzzInternalObject(t, extGroup.InternalGroupVersion(), rs, rand.Int63())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("rs._internal.extensions -> rs.v1beta1.extensions")
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(extGroup.Codec(), rs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected encoding error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := api.Codecs.DecoderToVersion(
0000000000000000000000000000000000000000;;			api.Codecs.UniversalDeserializer(),
0000000000000000000000000000000000000000;;			runtime.NewMultiGroupVersioner(
0000000000000000000000000000000000000000;;				*defaultGroup.GroupVersion(),
0000000000000000000000000000000000000000;;				schema.GroupKind{Group: defaultGroup.GroupVersion().Group},
0000000000000000000000000000000000000000;;				schema.GroupKind{Group: extGroup.GroupVersion().Group},
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("rs.v1beta1.extensions -> rc._internal")
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(decoder, data, rc); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected decoding error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("rc._internal -> rc.v1")
0000000000000000000000000000000000000000;;		data, err = runtime.Encode(defaultGroup.Codec(), rc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected encoding error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("rc.v1 -> rs._internal.extensions")
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(decoder, data, rs); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected decoding error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSpecificKind round-trips a single specific kind and is intended to help
0000000000000000000000000000000000000000;;	// debug issues that arise while adding a new API type.
0000000000000000000000000000000000000000;;	func TestSpecificKind(t *testing.T) {
0000000000000000000000000000000000000000;;		// Uncomment the following line to enable logging of which conversions
0000000000000000000000000000000000000000;;		// api.Scheme.Log(t)
0000000000000000000000000000000000000000;;		internalGVK := schema.GroupVersionKind{Group: "extensions", Version: runtime.APIVersionInternal, Kind: "DaemonSet"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seed := rand.Int63()
0000000000000000000000000000000000000000;;		fuzzer := apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(seed))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apitesting.RoundTripSpecificKind(t, internalGVK, api.Scheme, api.Codecs, fuzzer, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nonRoundTrippableTypes = sets.NewString(
0000000000000000000000000000000000000000;;		"ExportOptions",
0000000000000000000000000000000000000000;;		"GetOptions",
0000000000000000000000000000000000000000;;		// WatchEvent does not include kind and version and can only be deserialized
0000000000000000000000000000000000000000;;		// implicitly (if the caller expects the specific object). The watch call defines
0000000000000000000000000000000000000000;;		// the schema by content type, rather than via kind/version included in each
0000000000000000000000000000000000000000;;		// object.
0000000000000000000000000000000000000000;;		"WatchEvent",
0000000000000000000000000000000000000000;;		// ListOptions is now part of the meta group
0000000000000000000000000000000000000000;;		"ListOptions",
0000000000000000000000000000000000000000;;		// Delete options is only read in metav1
0000000000000000000000000000000000000000;;		"DeleteOptions",
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var commonKinds = []string{"Status", "ListOptions", "DeleteOptions", "ExportOptions"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestCommonKindsRegistered verifies that all group/versions registered with
0000000000000000000000000000000000000000;;	// the testapi package have the common kinds.
0000000000000000000000000000000000000000;;	func TestCommonKindsRegistered(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, kind := range commonKinds {
0000000000000000000000000000000000000000;;			for _, group := range testapi.Groups {
0000000000000000000000000000000000000000;;				gv := group.GroupVersion()
0000000000000000000000000000000000000000;;				gvk := gv.WithKind(kind)
0000000000000000000000000000000000000000;;				obj, err := api.Scheme.New(gvk)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defaults := gv.WithKind("")
0000000000000000000000000000000000000000;;				var got *schema.GroupVersionKind
0000000000000000000000000000000000000000;;				if obj, got, err = api.Codecs.LegacyCodec().Decode([]byte(`{"kind":"`+kind+`"}`), &defaults, obj); err != nil || gvk != *got {
0000000000000000000000000000000000000000;;					t.Errorf("expected %v: %v %v", gvk, got, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				data, err := runtime.Encode(api.Codecs.LegacyCodec(*gv), obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("expected %v: %v\n%s", gvk, err, string(data))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !bytes.Contains(data, []byte(`"kind":"`+kind+`","apiVersion":"`+gv.String()+`"`)) {
0000000000000000000000000000000000000000;;					if kind != "Status" {
0000000000000000000000000000000000000000;;						t.Errorf("expected %v: %v\n%s", gvk, err, string(data))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// TODO: this is wrong, but legacy clients expect it
0000000000000000000000000000000000000000;;					if !bytes.Contains(data, []byte(`"kind":"`+kind+`","apiVersion":"v1"`)) {
0000000000000000000000000000000000000000;;						t.Errorf("expected %v: %v\n%s", gvk, err, string(data))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestRoundTripTypes applies the round-trip test to all round-trippable Kinds
0000000000000000000000000000000000000000;;	// in all of the API groups registered for test in the testapi package.
0000000000000000000000000000000000000000;;	func TestRoundTripTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		seed := rand.Int63()
0000000000000000000000000000000000000000;;		fuzzer := apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(seed))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nonRoundTrippableTypes := map[schema.GroupVersionKind]bool{
0000000000000000000000000000000000000000;;			{Group: "componentconfig", Version: runtime.APIVersionInternal, Kind: "KubeletConfiguration"}:       true,
0000000000000000000000000000000000000000;;			{Group: "componentconfig", Version: runtime.APIVersionInternal, Kind: "KubeProxyConfiguration"}:     true,
0000000000000000000000000000000000000000;;			{Group: "componentconfig", Version: runtime.APIVersionInternal, Kind: "KubeSchedulerConfiguration"}: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apitesting.RoundTripTypes(t, api.Scheme, api.Codecs, fuzzer, nonRoundTrippableTypes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestEncodePtr tests that a pointer to a golang type can be encoded and
0000000000000000000000000000000000000000;;	// decoded without information loss or mutation.
0000000000000000000000000000000000000000;;	func TestEncodePtr(t *testing.T) {
0000000000000000000000000000000000000000;;		grace := int64(30)
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Labels: map[string]string{"name": "foo"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;				DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				TerminationGracePeriodSeconds: &grace,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				SecurityContext: &api.PodSecurityContext{},
0000000000000000000000000000000000000000;;				SchedulerName:   api.DefaultSchedulerName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := runtime.Object(pod)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(testapi.Default.Codec(), obj)
0000000000000000000000000000000000000000;;		obj2, err2 := runtime.Decode(testapi.Default.Codec(), data)
0000000000000000000000000000000000000000;;		if err != nil || err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failure: '%v' '%v'", err, err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := obj2.(*api.Pod); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Got wrong type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(obj2, pod) {
0000000000000000000000000000000000000000;;			t.Errorf("\nExpected:\n\n %#v,\n\nGot:\n\n %#vDiff: %v\n\n", pod, obj2, diff.ObjectDiff(obj2, pod))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestBadJSONRejection establishes that a JSON object without a kind or with
0000000000000000000000000000000000000000;;	// an unknown kind will not be decoded without error.
0000000000000000000000000000000000000000;;	func TestBadJSONRejection(t *testing.T) {
0000000000000000000000000000000000000000;;		badJSONMissingKind := []byte(`{ }`)
0000000000000000000000000000000000000000;;		if _, err := runtime.Decode(testapi.Default.Codec(), badJSONMissingKind); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not reject despite lack of kind field: %s", badJSONMissingKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		badJSONUnknownType := []byte(`{"kind": "bar"}`)
0000000000000000000000000000000000000000;;		if _, err1 := runtime.Decode(testapi.Default.Codec(), badJSONUnknownType); err1 == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not reject despite use of unknown type: %s", badJSONUnknownType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		/*badJSONKindMismatch := []byte(`{"kind": "Pod"}`)
0000000000000000000000000000000000000000;;		if err2 := DecodeInto(badJSONKindMismatch, &Node{}); err2 == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Kind is set but doesn't match the object type: %s", badJSONKindMismatch)
0000000000000000000000000000000000000000;;		}*/
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestUnversionedTypes establishes that the default codec can encode and
0000000000000000000000000000000000000000;;	// decode unversioned objects.
0000000000000000000000000000000000000000;;	func TestUnversionedTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		testcases := []runtime.Object{
0000000000000000000000000000000000000000;;			&metav1.Status{Status: "Failure", Message: "something went wrong"},
0000000000000000000000000000000000000000;;			&metav1.APIVersions{Versions: []string{"A", "B", "C"}},
0000000000000000000000000000000000000000;;			&metav1.APIGroupList{Groups: []metav1.APIGroup{{Name: "mygroup"}}},
0000000000000000000000000000000000000000;;			&metav1.APIGroup{Name: "mygroup"},
0000000000000000000000000000000000000000;;			&metav1.APIResourceList{GroupVersion: "mygroup/myversion"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, obj := range testcases {
0000000000000000000000000000000000000000;;			// Make sure the unversioned codec can encode
0000000000000000000000000000000000000000;;			unversionedJSON, err := runtime.Encode(testapi.Default.Codec(), obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", obj, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make sure the versioned codec under test can decode
0000000000000000000000000000000000000000;;			versionDecodedObject, err := runtime.Decode(testapi.Default.Codec(), unversionedJSON)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", obj, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make sure it decodes correctly
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(obj, versionDecodedObject) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %#v, got %#v", obj, obj, versionDecodedObject)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestObjectWatchFraming establishes that a watch event can be encoded and
0000000000000000000000000000000000000000;;	// decoded correctly through each of the supported RFC2046 media types.
0000000000000000000000000000000000000000;;	func TestObjectWatchFraming(t *testing.T) {
0000000000000000000000000000000000000000;;		f := apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(benchmarkSeed))
0000000000000000000000000000000000000000;;		secret := &api.Secret{}
0000000000000000000000000000000000000000;;		f.Fuzz(secret)
0000000000000000000000000000000000000000;;		secret.Data["binary"] = []byte{0x00, 0x10, 0x30, 0x55, 0xff, 0x00}
0000000000000000000000000000000000000000;;		secret.Data["utf8"] = []byte("a string with \u0345 characters")
0000000000000000000000000000000000000000;;		secret.Data["long"] = bytes.Repeat([]byte{0x01, 0x02, 0x03, 0x00}, 1000)
0000000000000000000000000000000000000000;;		converted, _ := api.Scheme.ConvertToVersion(secret, v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		v1secret := converted.(*v1.Secret)
0000000000000000000000000000000000000000;;		for _, info := range api.Codecs.SupportedMediaTypes() {
0000000000000000000000000000000000000000;;			if info.StreamSerializer == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s := info.StreamSerializer
0000000000000000000000000000000000000000;;			framer := s.Framer
0000000000000000000000000000000000000000;;			embedded := info.Serializer
0000000000000000000000000000000000000000;;			if embedded == nil {
0000000000000000000000000000000000000000;;				t.Errorf("no embedded serializer for %s", info.MediaType)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			innerDecode := api.Codecs.DecoderToVersion(embedded, api.SchemeGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// write a single object through the framer and back out
0000000000000000000000000000000000000000;;			obj := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			if err := s.Encode(v1secret, obj); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			w := framer.NewFrameWriter(out)
0000000000000000000000000000000000000000;;			if n, err := w.Write(obj.Bytes()); err != nil || n != len(obj.Bytes()) {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sr := streaming.NewDecoder(framer.NewFrameReader(ioutil.NopCloser(out)), s)
0000000000000000000000000000000000000000;;			resultSecret := &v1.Secret{}
0000000000000000000000000000000000000000;;			res, _, err := sr.Decode(nil, resultSecret)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%v:\n%s", err, hex.Dump(obj.Bytes()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resultSecret.Kind = "Secret"
0000000000000000000000000000000000000000;;			resultSecret.APIVersion = "v1"
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(v1secret, res) {
0000000000000000000000000000000000000000;;				t.Fatalf("objects did not match: %s", diff.ObjectGoPrintDiff(v1secret, res))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// write a watch event through the frame writer and read it back in
0000000000000000000000000000000000000000;;			// via the frame reader for this media type
0000000000000000000000000000000000000000;;			obj = &bytes.Buffer{}
0000000000000000000000000000000000000000;;			if err := embedded.Encode(v1secret, obj); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			event := &metav1.WatchEvent{Type: string(watch.Added)}
0000000000000000000000000000000000000000;;			event.Object.Raw = obj.Bytes()
0000000000000000000000000000000000000000;;			obj = &bytes.Buffer{}
0000000000000000000000000000000000000000;;			if err := s.Encode(event, obj); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = &bytes.Buffer{}
0000000000000000000000000000000000000000;;			w = framer.NewFrameWriter(out)
0000000000000000000000000000000000000000;;			if n, err := w.Write(obj.Bytes()); err != nil || n != len(obj.Bytes()) {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sr = streaming.NewDecoder(framer.NewFrameReader(ioutil.NopCloser(out)), s)
0000000000000000000000000000000000000000;;			outEvent := &metav1.WatchEvent{}
0000000000000000000000000000000000000000;;			res, _, err = sr.Decode(nil, outEvent)
0000000000000000000000000000000000000000;;			if err != nil || outEvent.Type != string(watch.Added) {
0000000000000000000000000000000000000000;;				t.Fatalf("%v: %#v", err, outEvent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if outEvent.Object.Object == nil && outEvent.Object.Raw != nil {
0000000000000000000000000000000000000000;;				outEvent.Object.Object, err = runtime.Decode(innerDecode, outEvent.Object.Raw)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("%v:\n%s", err, hex.Dump(outEvent.Object.Raw))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(secret, outEvent.Object.Object) {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: did not match after frame decoding: %s", info.MediaType, diff.ObjectGoPrintDiff(secret, outEvent.Object.Object))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const benchmarkSeed = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func benchmarkItems(b *testing.B) []v1.Pod {
0000000000000000000000000000000000000000;;		apiObjectFuzzer := apitesting.FuzzerFor(kapitesting.FuzzerFuncs(b, api.Codecs), rand.NewSource(benchmarkSeed))
0000000000000000000000000000000000000000;;		items := make([]v1.Pod, 10)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			var pod api.Pod
0000000000000000000000000000000000000000;;			apiObjectFuzzer.Fuzz(&pod)
0000000000000000000000000000000000000000;;			pod.Spec.InitContainers, pod.Status.InitContainerStatuses = nil, nil
0000000000000000000000000000000000000000;;			out, err := api.Scheme.ConvertToVersion(&pod, v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			items[i] = *out.(*v1.Pod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return items
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkEncodeCodec measures the cost of performing a codec encode, which includes
0000000000000000000000000000000000000000;;	// reflection (to clear APIVersion and Kind)
0000000000000000000000000000000000000000;;	func BenchmarkEncodeCodec(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := runtime.Encode(testapi.Default.Codec(), &items[i%width]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkEncodeCodecFromInternal measures the cost of performing a codec encode,
0000000000000000000000000000000000000000;;	// including conversions.
0000000000000000000000000000000000000000;;	func BenchmarkEncodeCodecFromInternal(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encodable := make([]api.Pod, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			if err := api.Scheme.Convert(&items[i], &encodable[i], nil); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := runtime.Encode(testapi.Default.Codec(), &encodable[i%width]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkEncodeJSONMarshal provides a baseline for regular JSON encode performance
0000000000000000000000000000000000000000;;	func BenchmarkEncodeJSONMarshal(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := json.Marshal(&items[i%width]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkDecodeCodec(b *testing.B) {
0000000000000000000000000000000000000000;;		codec := testapi.Default.Codec()
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encoded := make([][]byte, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(codec, &items[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded[i] = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := runtime.Decode(codec, encoded[i%width]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkDecodeIntoExternalCodec(b *testing.B) {
0000000000000000000000000000000000000000;;		codec := testapi.Default.Codec()
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encoded := make([][]byte, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(codec, &items[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded[i] = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			obj := v1.Pod{}
0000000000000000000000000000000000000000;;			if err := runtime.DecodeInto(codec, encoded[i%width], &obj); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkDecodeIntoInternalCodec(b *testing.B) {
0000000000000000000000000000000000000000;;		codec := testapi.Default.Codec()
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encoded := make([][]byte, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(codec, &items[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded[i] = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			obj := api.Pod{}
0000000000000000000000000000000000000000;;			if err := runtime.DecodeInto(codec, encoded[i%width], &obj); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkDecodeJSON provides a baseline for regular JSON decode performance
0000000000000000000000000000000000000000;;	func BenchmarkDecodeIntoJSON(b *testing.B) {
0000000000000000000000000000000000000000;;		codec := testapi.Default.Codec()
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encoded := make([][]byte, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(codec, &items[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded[i] = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			obj := v1.Pod{}
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(encoded[i%width], &obj); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkDecodeJSON provides a baseline for codecgen JSON decode performance
0000000000000000000000000000000000000000;;	func BenchmarkDecodeIntoJSONCodecGen(b *testing.B) {
0000000000000000000000000000000000000000;;		kcodec := testapi.Default.Codec()
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encoded := make([][]byte, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(kcodec, &items[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded[i] = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler := &codec.JsonHandle{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			obj := v1.Pod{}
0000000000000000000000000000000000000000;;			if err := codec.NewDecoderBytes(encoded[i%width], handler).Decode(&obj); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
