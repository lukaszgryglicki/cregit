0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9472c561825dd219ec6085421403b772dfa76a1f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package testapi provides a helper for retrieving the KUBE_TEST_API environment variable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(lavalamp): this package is a huge disaster at the moment. I intend to
0000000000000000000000000000000000000000;;	// refactor. All code currently using this package should change:
0000000000000000000000000000000000000000;;	// 1. Declare your own api.Registry.APIGroupRegistrationManager in your own test code.
0000000000000000000000000000000000000000;;	// 2. Import the relevant install packages.
0000000000000000000000000000000000000000;;	// 3. Register the types you need, from the announced.APIGroupAnnouncementManager.
0000000000000000000000000000000000000000;;	package testapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/recognizer"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/admission"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/admissionregistration"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/authorization"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/autoscaling"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/certificates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/imagepolicy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/networking"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/policy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/settings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/storage"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/federation/apis/federation/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/api/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/admission/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/admissionregistration/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/apps/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/authentication/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/authorization/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/autoscaling/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/batch/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/certificates/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/componentconfig/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/extensions/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/imagepolicy/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/networking/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/policy/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/rbac/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/settings/install"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/storage/install"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		Groups        = make(map[string]TestGroup)
0000000000000000000000000000000000000000;;		Default       TestGroup
0000000000000000000000000000000000000000;;		Authorization TestGroup
0000000000000000000000000000000000000000;;		Autoscaling   TestGroup
0000000000000000000000000000000000000000;;		Batch         TestGroup
0000000000000000000000000000000000000000;;		Extensions    TestGroup
0000000000000000000000000000000000000000;;		Apps          TestGroup
0000000000000000000000000000000000000000;;		Policy        TestGroup
0000000000000000000000000000000000000000;;		Federation    TestGroup
0000000000000000000000000000000000000000;;		Rbac          TestGroup
0000000000000000000000000000000000000000;;		Certificates  TestGroup
0000000000000000000000000000000000000000;;		Settings      TestGroup
0000000000000000000000000000000000000000;;		Storage       TestGroup
0000000000000000000000000000000000000000;;		ImagePolicy   TestGroup
0000000000000000000000000000000000000000;;		Admission     TestGroup
0000000000000000000000000000000000000000;;		Networking    TestGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializer        runtime.SerializerInfo
0000000000000000000000000000000000000000;;		storageSerializer runtime.SerializerInfo
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestGroup struct {
0000000000000000000000000000000000000000;;		externalGroupVersion schema.GroupVersion
0000000000000000000000000000000000000000;;		internalGroupVersion schema.GroupVersion
0000000000000000000000000000000000000000;;		internalTypes        map[string]reflect.Type
0000000000000000000000000000000000000000;;		externalTypes        map[string]reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if apiMediaType := os.Getenv("KUBE_TEST_API_TYPE"); len(apiMediaType) > 0 {
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			mediaType, _, err := mime.ParseMediaType(apiMediaType)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serializer, ok = runtime.SerializerInfoForMediaType(api.Codecs.SupportedMediaTypes(), mediaType)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("no serializer for %s", apiMediaType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if storageMediaType := StorageMediaType(); len(storageMediaType) > 0 {
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			mediaType, _, err := mime.ParseMediaType(storageMediaType)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			storageSerializer, ok = runtime.SerializerInfoForMediaType(api.Codecs.SupportedMediaTypes(), mediaType)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("no serializer for %s", storageMediaType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeTestAPI := os.Getenv("KUBE_TEST_API")
0000000000000000000000000000000000000000;;		if len(kubeTestAPI) != 0 {
0000000000000000000000000000000000000000;;			// priority is "first in list preferred", so this has to run in reverse order
0000000000000000000000000000000000000000;;			testGroupVersions := strings.Split(kubeTestAPI, ",")
0000000000000000000000000000000000000000;;			for i := len(testGroupVersions) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				gvString := testGroupVersions[i]
0000000000000000000000000000000000000000;;				groupVersion, err := schema.ParseGroupVersion(gvString)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("Error parsing groupversion %v: %v", gvString, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				internalGroupVersion := schema.GroupVersion{Group: groupVersion.Group, Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;				Groups[groupVersion.Group] = TestGroup{
0000000000000000000000000000000000000000;;					externalGroupVersion: groupVersion,
0000000000000000000000000000000000000000;;					internalGroupVersion: internalGroupVersion,
0000000000000000000000000000000000000000;;					internalTypes:        api.Scheme.KnownTypes(internalGroupVersion),
0000000000000000000000000000000000000000;;					externalTypes:        api.Scheme.KnownTypes(groupVersion),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := Groups[api.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: api.GroupName, Version: api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[api.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: api.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(api.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[extensions.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: extensions.GroupName, Version: api.Registry.GroupOrDie(extensions.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[extensions.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: extensions.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(extensions.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[autoscaling.GroupName]; !ok {
0000000000000000000000000000000000000000;;			internalTypes := make(map[string]reflect.Type)
0000000000000000000000000000000000000000;;			for k, t := range api.Scheme.KnownTypes(extensions.SchemeGroupVersion) {
0000000000000000000000000000000000000000;;				if k == "Scale" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				internalTypes[k] = t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: autoscaling.GroupName, Version: api.Registry.GroupOrDie(autoscaling.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[autoscaling.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: extensions.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        internalTypes,
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[autoscaling.GroupName+"IntraGroup"]; !ok {
0000000000000000000000000000000000000000;;			internalTypes := make(map[string]reflect.Type)
0000000000000000000000000000000000000000;;			for k, t := range api.Scheme.KnownTypes(extensions.SchemeGroupVersion) {
0000000000000000000000000000000000000000;;				if k == "Scale" {
0000000000000000000000000000000000000000;;					internalTypes[k] = t
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: autoscaling.GroupName, Version: api.Registry.GroupOrDie(autoscaling.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[autoscaling.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: autoscaling.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        internalTypes,
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[batch.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: batch.GroupName, Version: api.Registry.GroupOrDie(batch.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[batch.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: batch.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(batch.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[apps.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: apps.GroupName, Version: api.Registry.GroupOrDie(apps.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[apps.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: apps.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(apps.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[policy.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: policy.GroupName, Version: api.Registry.GroupOrDie(policy.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[policy.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: policy.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(policy.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[federation.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: federation.GroupName, Version: api.Registry.GroupOrDie(federation.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[federation.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: federation.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(federation.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[rbac.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: rbac.GroupName, Version: api.Registry.GroupOrDie(rbac.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[rbac.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: rbac.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(rbac.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[settings.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: settings.GroupName, Version: api.Registry.GroupOrDie(settings.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[settings.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: settings.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(settings.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[storage.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: storage.GroupName, Version: api.Registry.GroupOrDie(storage.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[storage.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: storage.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(storage.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[certificates.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: certificates.GroupName, Version: api.Registry.GroupOrDie(certificates.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[certificates.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: certificates.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(certificates.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[imagepolicy.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: imagepolicy.GroupName, Version: api.Registry.GroupOrDie(imagepolicy.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[imagepolicy.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: imagepolicy.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(imagepolicy.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[authorization.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: authorization.GroupName, Version: api.Registry.GroupOrDie(authorization.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[authorization.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: authorization.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(authorization.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[admissionregistration.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: admissionregistration.GroupName, Version: api.Registry.GroupOrDie(admissionregistration.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[admissionregistration.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: admissionregistration.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(admissionregistration.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[admission.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: admission.GroupName, Version: api.Registry.GroupOrDie(admission.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[admission.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: admission.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(admission.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := Groups[networking.GroupName]; !ok {
0000000000000000000000000000000000000000;;			externalGroupVersion := schema.GroupVersion{Group: networking.GroupName, Version: api.Registry.GroupOrDie(networking.GroupName).GroupVersion.Version}
0000000000000000000000000000000000000000;;			Groups[networking.GroupName] = TestGroup{
0000000000000000000000000000000000000000;;				externalGroupVersion: externalGroupVersion,
0000000000000000000000000000000000000000;;				internalGroupVersion: networking.SchemeGroupVersion,
0000000000000000000000000000000000000000;;				internalTypes:        api.Scheme.KnownTypes(networking.SchemeGroupVersion),
0000000000000000000000000000000000000000;;				externalTypes:        api.Scheme.KnownTypes(externalGroupVersion),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Default = Groups[api.GroupName]
0000000000000000000000000000000000000000;;		Autoscaling = Groups[autoscaling.GroupName]
0000000000000000000000000000000000000000;;		Batch = Groups[batch.GroupName]
0000000000000000000000000000000000000000;;		Apps = Groups[apps.GroupName]
0000000000000000000000000000000000000000;;		Policy = Groups[policy.GroupName]
0000000000000000000000000000000000000000;;		Certificates = Groups[certificates.GroupName]
0000000000000000000000000000000000000000;;		Extensions = Groups[extensions.GroupName]
0000000000000000000000000000000000000000;;		Federation = Groups[federation.GroupName]
0000000000000000000000000000000000000000;;		Rbac = Groups[rbac.GroupName]
0000000000000000000000000000000000000000;;		Settings = Groups[settings.GroupName]
0000000000000000000000000000000000000000;;		Storage = Groups[storage.GroupName]
0000000000000000000000000000000000000000;;		ImagePolicy = Groups[imagepolicy.GroupName]
0000000000000000000000000000000000000000;;		Authorization = Groups[authorization.GroupName]
0000000000000000000000000000000000000000;;		Admission = Groups[admission.GroupName]
0000000000000000000000000000000000000000;;		Networking = Groups[networking.GroupName]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g TestGroup) ContentConfig() (string, *schema.GroupVersion, runtime.Codec) {
0000000000000000000000000000000000000000;;		return "application/json", g.GroupVersion(), g.Codec()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g TestGroup) GroupVersion() *schema.GroupVersion {
0000000000000000000000000000000000000000;;		copyOfGroupVersion := g.externalGroupVersion
0000000000000000000000000000000000000000;;		return &copyOfGroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalGroupVersion returns the group,version used to identify the internal
0000000000000000000000000000000000000000;;	// types for this API
0000000000000000000000000000000000000000;;	func (g TestGroup) InternalGroupVersion() schema.GroupVersion {
0000000000000000000000000000000000000000;;		return g.internalGroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalTypes returns a map of internal API types' kind names to their Go types.
0000000000000000000000000000000000000000;;	func (g TestGroup) InternalTypes() map[string]reflect.Type {
0000000000000000000000000000000000000000;;		return g.internalTypes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalTypes returns a map of external API types' kind names to their Go types.
0000000000000000000000000000000000000000;;	func (g TestGroup) ExternalTypes() map[string]reflect.Type {
0000000000000000000000000000000000000000;;		return g.externalTypes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Codec returns the codec for the API version to test against, as set by the
0000000000000000000000000000000000000000;;	// KUBE_TEST_API_TYPE env var.
0000000000000000000000000000000000000000;;	func (g TestGroup) Codec() runtime.Codec {
0000000000000000000000000000000000000000;;		if serializer.Serializer == nil {
0000000000000000000000000000000000000000;;			return api.Codecs.LegacyCodec(g.externalGroupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return api.Codecs.CodecForVersions(serializer.Serializer, api.Codecs.UniversalDeserializer(), schema.GroupVersions{g.externalGroupVersion}, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NegotiatedSerializer returns the negotiated serializer for the server.
0000000000000000000000000000000000000000;;	func (g TestGroup) NegotiatedSerializer() runtime.NegotiatedSerializer {
0000000000000000000000000000000000000000;;		return api.Codecs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StorageMediaType() string {
0000000000000000000000000000000000000000;;		return os.Getenv("KUBE_TEST_API_STORAGE_TYPE")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageCodec returns the codec for the API version to store in etcd, as set by the
0000000000000000000000000000000000000000;;	// KUBE_TEST_API_STORAGE_TYPE env var.
0000000000000000000000000000000000000000;;	func (g TestGroup) StorageCodec() runtime.Codec {
0000000000000000000000000000000000000000;;		s := storageSerializer.Serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return api.Codecs.LegacyCodec(g.externalGroupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// etcd2 only supports string data - we must wrap any result before returning
0000000000000000000000000000000000000000;;		// TODO: remove for etcd3 / make parameterizable
0000000000000000000000000000000000000000;;		if !storageSerializer.EncodesAsText {
0000000000000000000000000000000000000000;;			s = runtime.NewBase64Serializer(s, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds := recognizer.NewDecoder(s, api.Codecs.UniversalDeserializer())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return api.Codecs.CodecForVersions(s, ds, schema.GroupVersions{g.externalGroupVersion}, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converter returns the api.Scheme for the API version to test against, as set by the
0000000000000000000000000000000000000000;;	// KUBE_TEST_API env var.
0000000000000000000000000000000000000000;;	func (g TestGroup) Converter() runtime.ObjectConvertor {
0000000000000000000000000000000000000000;;		interfaces, err := api.Registry.GroupOrDie(g.externalGroupVersion.Group).InterfacesFor(g.externalGroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return interfaces.ObjectConvertor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadataAccessor returns the MetadataAccessor for the API version to test against,
0000000000000000000000000000000000000000;;	// as set by the KUBE_TEST_API env var.
0000000000000000000000000000000000000000;;	func (g TestGroup) MetadataAccessor() meta.MetadataAccessor {
0000000000000000000000000000000000000000;;		interfaces, err := api.Registry.GroupOrDie(g.externalGroupVersion.Group).InterfacesFor(g.externalGroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return interfaces.MetadataAccessor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelfLink returns a self link that will appear to be for the version Version().
0000000000000000000000000000000000000000;;	// 'resource' should be the resource path, e.g. "pods" for the Pod type. 'name' should be
0000000000000000000000000000000000000000;;	// empty for lists.
0000000000000000000000000000000000000000;;	func (g TestGroup) SelfLink(resource, name string) string {
0000000000000000000000000000000000000000;;		if g.externalGroupVersion.Group == api.GroupName {
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("/api/%s/%s", g.externalGroupVersion.Version, resource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("/api/%s/%s/%s", g.externalGroupVersion.Version, resource, name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: will need a /apis prefix once we have proper multi-group
0000000000000000000000000000000000000000;;			// support
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("/apis/%s/%s/%s", g.externalGroupVersion.Group, g.externalGroupVersion.Version, resource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("/apis/%s/%s/%s/%s", g.externalGroupVersion.Group, g.externalGroupVersion.Version, resource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcePathWithPrefix returns the appropriate path for the given prefix (watch, proxy, redirect, etc), resource, namespace and name.
0000000000000000000000000000000000000000;;	// For ex, this is of the form:
0000000000000000000000000000000000000000;;	// /api/v1/watch/namespaces/foo/pods/pod0 for v1.
0000000000000000000000000000000000000000;;	func (g TestGroup) ResourcePathWithPrefix(prefix, resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		var path string
0000000000000000000000000000000000000000;;		if g.externalGroupVersion.Group == api.GroupName {
0000000000000000000000000000000000000000;;			path = "/api/" + g.externalGroupVersion.Version
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: switch back once we have proper multiple group support
0000000000000000000000000000000000000000;;			// path = "/apis/" + g.Group + "/" + Version(group...)
0000000000000000000000000000000000000000;;			path = "/apis/" + g.externalGroupVersion.Group + "/" + g.externalGroupVersion.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if prefix != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + prefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if namespace != "" {
0000000000000000000000000000000000000000;;			path = path + "/namespaces/" + namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Resource names are lower case.
0000000000000000000000000000000000000000;;		resource = strings.ToLower(resource)
0000000000000000000000000000000000000000;;		if resource != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcePath returns the appropriate path for the given resource, namespace and name.
0000000000000000000000000000000000000000;;	// For example, this is of the form:
0000000000000000000000000000000000000000;;	// /api/v1/namespaces/foo/pods/pod0 for v1.
0000000000000000000000000000000000000000;;	func (g TestGroup) ResourcePath(resource, namespace, name string) string {
0000000000000000000000000000000000000000;;		return g.ResourcePathWithPrefix("", resource, namespace, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubResourcePath returns the appropriate path for the given resource, namespace,
0000000000000000000000000000000000000000;;	// name and subresource.
0000000000000000000000000000000000000000;;	func (g TestGroup) SubResourcePath(resource, namespace, name, sub string) string {
0000000000000000000000000000000000000000;;		path := g.ResourcePathWithPrefix("", resource, namespace, name)
0000000000000000000000000000000000000000;;		if sub != "" {
0000000000000000000000000000000000000000;;			path = path + "/" + sub
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMapper returns RESTMapper in api.Registry.
0000000000000000000000000000000000000000;;	func (g TestGroup) RESTMapper() meta.RESTMapper {
0000000000000000000000000000000000000000;;		return api.Registry.RESTMapper()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalGroupVersions returns all external group versions allowed for the server.
0000000000000000000000000000000000000000;;	func ExternalGroupVersions() schema.GroupVersions {
0000000000000000000000000000000000000000;;		versions := []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		for _, g := range Groups {
0000000000000000000000000000000000000000;;			gv := g.GroupVersion()
0000000000000000000000000000000000000000;;			versions = append(versions, *gv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return versions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCodecForObject gets codec based on runtime.Object
0000000000000000000000000000000000000000;;	func GetCodecForObject(obj runtime.Object) (runtime.Codec, error) {
0000000000000000000000000000000000000000;;		kinds, _, err := api.Scheme.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected encoding error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kind := kinds[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, group := range Groups {
0000000000000000000000000000000000000000;;			if group.GroupVersion().Group != kind.Group {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if api.Scheme.Recognizes(kind) {
0000000000000000000000000000000000000000;;				return group.Codec(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Codec used for unversioned types
0000000000000000000000000000000000000000;;		if api.Scheme.Recognizes(kind) {
0000000000000000000000000000000000000000;;			serializer, ok := runtime.SerializerInfoForMediaType(api.Codecs.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("no serializer registered for json")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return serializer.Serializer, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unexpected kind: %v", kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTestGroup creates a new TestGroup.
0000000000000000000000000000000000000000;;	func NewTestGroup(external, internal schema.GroupVersion, internalTypes map[string]reflect.Type, externalTypes map[string]reflect.Type) TestGroup {
0000000000000000000000000000000000000000;;		return TestGroup{external, internal, internalTypes, externalTypes}
0000000000000000000000000000000000000000;;	}
