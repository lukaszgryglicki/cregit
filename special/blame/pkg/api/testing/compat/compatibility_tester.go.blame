0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a037c1cd4ed54ef71811886e8429f2fdb40a16b6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package compat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Based on: https://github.com/openshift/origin/blob/master/pkg/api/compatibility_test.go
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TestCompatibility reencodes the input using the codec for the given
0000000000000000000000000000000000000000;;	// version and checks for the presence of the expected keys and absent
0000000000000000000000000000000000000000;;	// keys in the resulting JSON.
0000000000000000000000000000000000000000;;	func TestCompatibility(
0000000000000000000000000000000000000000;;		t *testing.T,
0000000000000000000000000000000000000000;;		version schema.GroupVersion,
0000000000000000000000000000000000000000;;		input []byte,
0000000000000000000000000000000000000000;;		validator func(obj runtime.Object) field.ErrorList,
0000000000000000000000000000000000000000;;		expectedKeys map[string]string,
0000000000000000000000000000000000000000;;		absentKeys []string,
0000000000000000000000000000000000000000;;	) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decode
0000000000000000000000000000000000000000;;		codec := api.Codecs.LegacyCodec(version)
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(codec, input)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate
0000000000000000000000000000000000000000;;		errs := validator(obj)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected validation errors: %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Encode
0000000000000000000000000000000000000000;;		output, err := runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate old and new fields are encoded
0000000000000000000000000000000000000000;;		generic := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(output, &generic); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasError := false
0000000000000000000000000000000000000000;;		for k, expectedValue := range expectedKeys {
0000000000000000000000000000000000000000;;			keys := strings.Split(k, ".")
0000000000000000000000000000000000000000;;			if actualValue, ok, err := getJSONValue(generic, keys...); err != nil || !ok {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error for %s: %v", k, err)
0000000000000000000000000000000000000000;;				hasError = true
0000000000000000000000000000000000000000;;			} else if !reflect.DeepEqual(expectedValue, fmt.Sprintf("%v", actualValue)) {
0000000000000000000000000000000000000000;;				hasError = true
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected value for %v: expected %v, got %v", k, expectedValue, actualValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, absentKey := range absentKeys {
0000000000000000000000000000000000000000;;			keys := strings.Split(absentKey, ".")
0000000000000000000000000000000000000000;;			actualValue, ok, err := getJSONValue(generic, keys...)
0000000000000000000000000000000000000000;;			if err == nil || ok {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected value found for key %s: %v", absentKey, actualValue)
0000000000000000000000000000000000000000;;				hasError = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasError {
0000000000000000000000000000000000000000;;			printer := &printers.JSONPrinter{}
0000000000000000000000000000000000000000;;			printer.PrintObj(obj, os.Stdout)
0000000000000000000000000000000000000000;;			t.Logf("2: Encoded value: %#v", string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getJSONValue(data map[string]interface{}, keys ...string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		// No keys, current value is it
0000000000000000000000000000000000000000;;		if len(keys) == 0 {
0000000000000000000000000000000000000000;;			return data, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the key (and optional index)
0000000000000000000000000000000000000000;;		key := keys[0]
0000000000000000000000000000000000000000;;		index := -1
0000000000000000000000000000000000000000;;		if matches := regexp.MustCompile(`^(.*)\[(\d+)\]$`).FindStringSubmatch(key); len(matches) > 0 {
0000000000000000000000000000000000000000;;			key = matches[1]
0000000000000000000000000000000000000000;;			index, _ = strconv.Atoi(matches[2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Look up the value
0000000000000000000000000000000000000000;;		value, ok := data[key]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("No key %s found", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the indexed value if an index is specified
0000000000000000000000000000000000000000;;		if index >= 0 {
0000000000000000000000000000000000000000;;			valueSlice, ok := value.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("Key %s did not hold a slice", key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if index >= len(valueSlice) {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("Index %d out of bounds for slice at key: %v", index, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value = valueSlice[index]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(keys) == 1 {
0000000000000000000000000000000000000000;;			return value, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		childData, ok := value.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("Key %s did not hold a map", keys[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return getJSONValue(childData, keys[1:]...)
0000000000000000000000000000000000000000;;	}
