0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
9fbdd758c00a160e902805405146a779d3acf5d8;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package api
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Common string formats
0000000000000000000000000000000000000000;;	// ---------------------
0000000000000000000000000000000000000000;;	// Many fields in this API have formatting requirements.  The commonly used
0000000000000000000000000000000000000000;;	// formats are defined here.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// C_IDENTIFIER:  This is a string that conforms to the definition of an "identifier"
0000000000000000000000000000000000000000;;	//     in the C language.  This is captured by the following regex:
0000000000000000000000000000000000000000;;	//         [A-Za-z_][A-Za-z0-9_]*
0000000000000000000000000000000000000000;;	//     This defines the format, but not the length restriction, which should be
0000000000000000000000000000000000000000;;	//     specified at the definition of any field of this type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DNS_LABEL:  This is a string, no more than 63 characters long, that conforms
0000000000000000000000000000000000000000;;	//     to the definition of a "label" in RFCs 1035 and 1123.  This is captured
0000000000000000000000000000000000000000;;	//     by the following regex:
0000000000000000000000000000000000000000;;	//         [a-z0-9]([-a-z0-9]*[a-z0-9])?
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DNS_SUBDOMAIN:  This is a string, no more than 253 characters long, that conforms
0000000000000000000000000000000000000000;;	//      to the definition of a "subdomain" in RFCs 1035 and 1123.  This is captured
0000000000000000000000000000000000000000;;	//      by the following regex:
0000000000000000000000000000000000000000;;	//         [a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*
0000000000000000000000000000000000000000;;	//     or more simply:
0000000000000000000000000000000000000000;;	//         DNS_LABEL(\.DNS_LABEL)*
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// IANA_SVC_NAME: This is a string, no more than 15 characters long, that
0000000000000000000000000000000000000000;;	//      conforms to the definition of IANA service name in RFC 6335.
0000000000000000000000000000000000000000;;	//      It must contains at least one letter [a-z] and it must contains only [a-z0-9-].
0000000000000000000000000000000000000000;;	//      Hypens ('-') cannot be leading or trailing character of the string
0000000000000000000000000000000000000000;;	//      and cannot be adjacent to other hyphens.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
0000000000000000000000000000000000000000;;	// users must create.
0000000000000000000000000000000000000000;;	// DEPRECATED: Use k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta instead - this type will be removed soon.
0000000000000000000000000000000000000000;;	type ObjectMeta struct {
0000000000000000000000000000000000000000;;		// Name is unique within a namespace.  Name is required when creating resources, although
0000000000000000000000000000000000000000;;		// some resources may allow a client to request the generation of an appropriate name
0000000000000000000000000000000000000000;;		// automatically. Name is primarily intended for creation idempotence and configuration
0000000000000000000000000000000000000000;;		// definition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GenerateName indicates that the name should be made unique by the server prior to persisting
0000000000000000000000000000000000000000;;		// it. A non-empty value for the field indicates the name will be made unique (and the name
0000000000000000000000000000000000000000;;		// returned to the client will be different than the name passed). The value of this field will
0000000000000000000000000000000000000000;;		// be combined with a unique suffix on the server if the Name field has not been provided.
0000000000000000000000000000000000000000;;		// The provided value must be valid within the rules for Name, and may be truncated by the length
0000000000000000000000000000000000000000;;		// of the suffix required to make the value unique on the server.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If this field is specified, and Name is not present, the server will NOT return a 409 if the
0000000000000000000000000000000000000000;;		// generated name exists - instead, it will either return 201 Created or 500 with Reason
0000000000000000000000000000000000000000;;		// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
0000000000000000000000000000000000000000;;		// should retry (optionally after the time indicated in the Retry-After header).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GenerateName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Namespace defines the space within which name must be unique. An empty namespace is
0000000000000000000000000000000000000000;;		// equivalent to the "default" namespace, but "default" is the canonical representation.
0000000000000000000000000000000000000000;;		// Not all objects are required to be scoped to a namespace - the value of this field for
0000000000000000000000000000000000000000;;		// those objects will be empty.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SelfLink is a URL representing this object.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SelfLink string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UID is the unique in time and space value for this object. It is typically generated by
0000000000000000000000000000000000000000;;		// the server on successful creation of a resource and is not allowed to change on PUT
0000000000000000000000000000000000000000;;		// operations.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID types.UID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An opaque value that represents the version of this resource. May be used for optimistic
0000000000000000000000000000000000000000;;		// concurrency, change detection, and the watch operation on a resource or set of resources.
0000000000000000000000000000000000000000;;		// Clients must treat these values as opaque and values may only be valid for a particular
0000000000000000000000000000000000000000;;		// resource or set of resources. Only servers will generate resource versions.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A sequence number representing a specific generation of the desired state.
0000000000000000000000000000000000000000;;		// Populated by the system. Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Generation int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreationTimestamp is a timestamp representing the server time when this object was
0000000000000000000000000000000000000000;;		// created. It is not guaranteed to be set in happens-before order across separate operations.
0000000000000000000000000000000000000000;;		// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CreationTimestamp metav1.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
0000000000000000000000000000000000000000;;		// field is set by the server when a graceful deletion is requested by the user, and is not
0000000000000000000000000000000000000000;;		// directly settable by a client. The resource is expected to be deleted (no longer visible
0000000000000000000000000000000000000000;;		// from resource lists, and not reachable by name) after the time in this field. Once set,
0000000000000000000000000000000000000000;;		// this value may not be unset or be set further into the future, although it may be shortened
0000000000000000000000000000000000000000;;		// or the resource may be deleted prior to this time. For example, a user may request that
0000000000000000000000000000000000000000;;		// a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination
0000000000000000000000000000000000000000;;		// signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard
0000000000000000000000000000000000000000;;		// termination signal (SIGKILL) to the container and after cleanup, remove the pod from the
0000000000000000000000000000000000000000;;		// API. In the presence of network partitions, this object may still exist after this
0000000000000000000000000000000000000000;;		// timestamp, until an administrator or automated process can determine the resource is
0000000000000000000000000000000000000000;;		// fully terminated.
0000000000000000000000000000000000000000;;		// If not set, graceful deletion of the object has not been requested.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system when a graceful deletion is requested.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DeletionTimestamp *metav1.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeletionGracePeriodSeconds records the graceful deletion value set when graceful deletion
0000000000000000000000000000000000000000;;		// was requested. Represents the most recent grace period, and may only be shortened once set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DeletionGracePeriodSeconds *int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Labels are key value pairs that may be used to scope and select individual resources.
0000000000000000000000000000000000000000;;		// Label keys are of the form:
0000000000000000000000000000000000000000;;		//     label-key ::= prefixed-name | name
0000000000000000000000000000000000000000;;		//     prefixed-name ::= prefix '/' name
0000000000000000000000000000000000000000;;		//     prefix ::= DNS_SUBDOMAIN
0000000000000000000000000000000000000000;;		//     name ::= DNS_LABEL
0000000000000000000000000000000000000000;;		// The prefix is optional.  If the prefix is not specified, the key is assumed to be private
0000000000000000000000000000000000000000;;		// to the user.  Other system components that wish to use labels must specify a prefix.  The
0000000000000000000000000000000000000000;;		// "kubernetes.io/" prefix is reserved for use by kubernetes components.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Labels map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Annotations are unstructured key value data stored with a resource that may be set by
0000000000000000000000000000000000000000;;		// external tooling. They are not queryable and should be preserved when modifying
0000000000000000000000000000000000000000;;		// objects.  Annotation keys have the same formatting restrictions as Label keys. See the
0000000000000000000000000000000000000000;;		// comments on Labels for details.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Annotations map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of objects depended by this object. If ALL objects in the list have
0000000000000000000000000000000000000000;;		// been deleted, this object will be garbage collected. If this object is managed by a controller,
0000000000000000000000000000000000000000;;		// then an entry in this list will point to this controller, with the controller field set to true.
0000000000000000000000000000000000000000;;		// There cannot be more than one managing controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		OwnerReferences []metav1.OwnerReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An initializer is a controller which enforces some system invariant at object creation time.
0000000000000000000000000000000000000000;;		// This field is a list of initializers that have not yet acted on this object. If nil or empty,
0000000000000000000000000000000000000000;;		// this object has been completely initialized. Otherwise, the object is considered uninitialized
0000000000000000000000000000000000000000;;		// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
0000000000000000000000000000000000000000;;		// observe uninitialized objects.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When an object is created, the system will populate this list with the current set of initializers.
0000000000000000000000000000000000000000;;		// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
0000000000000000000000000000000000000000;;		// by any user.
0000000000000000000000000000000000000000;;		Initializers *metav1.Initializers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be empty before the object is deleted from the registry. Each entry
0000000000000000000000000000000000000000;;		// is an identifier for the responsible component that will remove the entry
0000000000000000000000000000000000000000;;		// from the list. If the deletionTimestamp of the object is non-nil, entries
0000000000000000000000000000000000000000;;		// in this list can only be removed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Finalizers []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The name of the cluster which the object belongs to.
0000000000000000000000000000000000000000;;		// This is used to distinguish resources with same name and namespace in different clusters.
0000000000000000000000000000000000000000;;		// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ClusterName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NamespaceDefault means the object is in the default namespace which is applied when not specified by clients
0000000000000000000000000000000000000000;;		NamespaceDefault string = "default"
0000000000000000000000000000000000000000;;		// NamespaceAll is the default argument to specify on a context when you want to list or filter resources across all namespaces
0000000000000000000000000000000000000000;;		NamespaceAll string = ""
0000000000000000000000000000000000000000;;		// NamespaceNone is the argument for a context when there is no namespace.
0000000000000000000000000000000000000000;;		NamespaceNone string = ""
0000000000000000000000000000000000000000;;		// NamespaceSystem is the system namespace where we place system components.
0000000000000000000000000000000000000000;;		NamespaceSystem string = "kube-system"
0000000000000000000000000000000000000000;;		// NamespacePublic is the namespace where we place public info (ConfigMaps)
0000000000000000000000000000000000000000;;		NamespacePublic string = "kube-public"
0000000000000000000000000000000000000000;;		// TerminationMessagePathDefault means the default path to capture the application termination message running in a container
0000000000000000000000000000000000000000;;		TerminationMessagePathDefault string = "/dev/termination-log"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volume represents a named volume in a pod that may be accessed by any containers in the pod.
0000000000000000000000000000000000000000;;	type Volume struct {
0000000000000000000000000000000000000000;;		// Required: This must be a DNS_LABEL.  Each volume in a pod must have
0000000000000000000000000000000000000000;;		// a unique name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// The VolumeSource represents the location and type of a volume to mount.
0000000000000000000000000000000000000000;;		// This is optional for now. If not specified, the Volume is implied to be an EmptyDir.
0000000000000000000000000000000000000000;;		// This implied behavior is deprecated and will be removed in a future version.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeSource represents the source location of a volume to mount.
0000000000000000000000000000000000000000;;	// Only one of its members may be specified.
0000000000000000000000000000000000000000;;	type VolumeSource struct {
0000000000000000000000000000000000000000;;		// HostPath represents file or directory on the host machine that is
0000000000000000000000000000000000000000;;		// directly exposed to the container. This is generally used for system
0000000000000000000000000000000000000000;;		// agents or other privileged things that are allowed to see the host
0000000000000000000000000000000000000000;;		// machine. Most containers will NOT need this.
0000000000000000000000000000000000000000;;		// ---
0000000000000000000000000000000000000000;;		// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
0000000000000000000000000000000000000000;;		// mount host directories as read/write.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPath *HostPathVolumeSource
0000000000000000000000000000000000000000;;		// EmptyDir represents a temporary directory that shares a pod's lifetime.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		EmptyDir *EmptyDirVolumeSource
0000000000000000000000000000000000000000;;		// GCEPersistentDisk represents a GCE Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GCEPersistentDisk *GCEPersistentDiskVolumeSource
0000000000000000000000000000000000000000;;		// AWSElasticBlockStore represents an AWS EBS disk that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource
0000000000000000000000000000000000000000;;		// GitRepo represents a git repository at a particular revision.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GitRepo *GitRepoVolumeSource
0000000000000000000000000000000000000000;;		// Secret represents a secret that should populate this volume.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Secret *SecretVolumeSource
0000000000000000000000000000000000000000;;		// NFS represents an NFS mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NFS *NFSVolumeSource
0000000000000000000000000000000000000000;;		// ISCSIVolumeSource represents an ISCSI Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ISCSI *ISCSIVolumeSource
0000000000000000000000000000000000000000;;		// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Glusterfs *GlusterfsVolumeSource
0000000000000000000000000000000000000000;;		// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PersistentVolumeClaim *PersistentVolumeClaimVolumeSource
0000000000000000000000000000000000000000;;		// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RBD *RBDVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Quobyte *QuobyteVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FlexVolume represents a generic volume resource that is
0000000000000000000000000000000000000000;;		// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FlexVolume *FlexVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cinder represents a cinder volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Cinder *CinderVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CephFS represents a Cephfs mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CephFS *CephFSVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Flocker *FlockerVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DownwardAPI represents metadata about the pod that should populate this volume
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DownwardAPI *DownwardAPIVolumeSource
0000000000000000000000000000000000000000;;		// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FC *FCVolumeSource
0000000000000000000000000000000000000000;;		// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureFile *AzureFileVolumeSource
0000000000000000000000000000000000000000;;		// ConfigMap represents a configMap that should populate this volume
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ConfigMap *ConfigMapVolumeSource
0000000000000000000000000000000000000000;;		// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VsphereVolume *VsphereVirtualDiskVolumeSource
0000000000000000000000000000000000000000;;		// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureDisk *AzureDiskVolumeSource
0000000000000000000000000000000000000000;;		// PhotonPersistentDisk represents a Photon Controller persistent disk attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		PhotonPersistentDisk *PhotonPersistentDiskVolumeSource
0000000000000000000000000000000000000000;;		// Items for all in one resources secrets, configmaps, and downward API
0000000000000000000000000000000000000000;;		Projected *ProjectedVolumeSource
0000000000000000000000000000000000000000;;		// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PortworxVolume *PortworxVolumeSource
0000000000000000000000000000000000000000;;		// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ScaleIO *ScaleIOVolumeSource
0000000000000000000000000000000000000000;;		// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageOS *StorageOSVolumeSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Similar to VolumeSource but meant for the administrator who creates PVs.
0000000000000000000000000000000000000000;;	// Exactly one of its members must be set.
0000000000000000000000000000000000000000;;	type PersistentVolumeSource struct {
0000000000000000000000000000000000000000;;		// GCEPersistentDisk represents a GCE Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GCEPersistentDisk *GCEPersistentDiskVolumeSource
0000000000000000000000000000000000000000;;		// AWSElasticBlockStore represents an AWS EBS disk that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource
0000000000000000000000000000000000000000;;		// HostPath represents a directory on the host.
0000000000000000000000000000000000000000;;		// Provisioned by a developer or tester.
0000000000000000000000000000000000000000;;		// This is useful for single-node development and testing only!
0000000000000000000000000000000000000000;;		// On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPath *HostPathVolumeSource
0000000000000000000000000000000000000000;;		// Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Glusterfs *GlusterfsVolumeSource
0000000000000000000000000000000000000000;;		// NFS represents an NFS mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NFS *NFSVolumeSource
0000000000000000000000000000000000000000;;		// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RBD *RBDVolumeSource
0000000000000000000000000000000000000000;;		// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Quobyte *QuobyteVolumeSource
0000000000000000000000000000000000000000;;		// ISCSIVolumeSource represents an ISCSI resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ISCSI *ISCSIVolumeSource
0000000000000000000000000000000000000000;;		// FlexVolume represents a generic volume resource that is
0000000000000000000000000000000000000000;;		// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FlexVolume *FlexVolumeSource
0000000000000000000000000000000000000000;;		// Cinder represents a cinder volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Cinder *CinderVolumeSource
0000000000000000000000000000000000000000;;		// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CephFS *CephFSVolumeSource
0000000000000000000000000000000000000000;;		// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FC *FCVolumeSource
0000000000000000000000000000000000000000;;		// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Flocker *FlockerVolumeSource
0000000000000000000000000000000000000000;;		// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureFile *AzureFileVolumeSource
0000000000000000000000000000000000000000;;		// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VsphereVolume *VsphereVirtualDiskVolumeSource
0000000000000000000000000000000000000000;;		// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureDisk *AzureDiskVolumeSource
0000000000000000000000000000000000000000;;		// PhotonPersistentDisk represents a Photon Controller persistent disk attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		PhotonPersistentDisk *PhotonPersistentDiskVolumeSource
0000000000000000000000000000000000000000;;		// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PortworxVolume *PortworxVolumeSource
0000000000000000000000000000000000000000;;		// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ScaleIO *ScaleIOVolumeSource
0000000000000000000000000000000000000000;;		// Local represents directly-attached storage with node affinity
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Local *LocalVolumeSource
0000000000000000000000000000000000000000;;		// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/storageos/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageOS *StorageOSPersistentVolumeSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimVolumeSource struct {
0000000000000000000000000000000000000000;;		// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume
0000000000000000000000000000000000000000;;		ClaimName string
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write).  ReadOnly here
0000000000000000000000000000000000000000;;		// will force the ReadOnly setting in VolumeMounts
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// BetaStorageClassAnnotation represents the beta/previous StorageClass annotation.
0000000000000000000000000000000000000000;;		// It's currently still used and will be held for backwards compatibility
0000000000000000000000000000000000000000;;		BetaStorageClassAnnotation = "volume.beta.kubernetes.io/storage-class"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MountOptionAnnotation defines mount option annotation used in PVs
0000000000000000000000000000000000000000;;		MountOptionAnnotation = "volume.beta.kubernetes.io/mount-options"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AlphaStorageNodeAffinityAnnotation defines node affinity policies for a PersistentVolume.
0000000000000000000000000000000000000000;;		// Value is a string of the json representation of type NodeAffinity
0000000000000000000000000000000000000000;;		AlphaStorageNodeAffinityAnnotation = "volume.alpha.kubernetes.io/node-affinity"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolume struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//Spec defines a persistent volume owned by the cluster
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PersistentVolumeSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status represents the current information about persistent volume.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PersistentVolumeStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeSpec struct {
0000000000000000000000000000000000000000;;		// Resources represents the actual resources of the volume
0000000000000000000000000000000000000000;;		Capacity ResourceList
0000000000000000000000000000000000000000;;		// Source represents the location and type of a volume to mount.
0000000000000000000000000000000000000000;;		PersistentVolumeSource
0000000000000000000000000000000000000000;;		// AccessModes contains all ways the volume can be mounted
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AccessModes []PersistentVolumeAccessMode
0000000000000000000000000000000000000000;;		// ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
0000000000000000000000000000000000000000;;		// ClaimRef is expected to be non-nil when bound.
0000000000000000000000000000000000000000;;		// claim.VolumeName is the authoritative bind between PV and PVC.
0000000000000000000000000000000000000000;;		// When set to non-nil value, PVC.Spec.Selector of the referenced PVC is
0000000000000000000000000000000000000000;;		// ignored, i.e. labels of this PV do not need to match PVC selector.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ClaimRef *ObjectReference
0000000000000000000000000000000000000000;;		// Optional: what happens to a persistent volume when released from its claim.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimPolicy PersistentVolumeReclaimPolicy
0000000000000000000000000000000000000000;;		// Name of StorageClass to which this persistent volume belongs. Empty value
0000000000000000000000000000000000000000;;		// means that this volume does not belong to any StorageClass.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageClassName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeReclaimPolicy describes a policy for end-of-life maintenance of persistent volumes
0000000000000000000000000000000000000000;;	type PersistentVolumeReclaimPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PersistentVolumeReclaimRecycle means the volume will be recycled back into the pool of unbound persistent volumes on release from its claim.
0000000000000000000000000000000000000000;;		// The volume plugin must support Recycling.
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimRecycle PersistentVolumeReclaimPolicy = "Recycle"
0000000000000000000000000000000000000000;;		// PersistentVolumeReclaimDelete means the volume will be deleted from Kubernetes on release from its claim.
0000000000000000000000000000000000000000;;		// The volume plugin must support Deletion.
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimDelete PersistentVolumeReclaimPolicy = "Delete"
0000000000000000000000000000000000000000;;		// PersistentVolumeReclaimRetain means the volume will be left in its current phase (Released) for manual reclamation by the administrator.
0000000000000000000000000000000000000000;;		// The default policy is Retain.
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimRetain PersistentVolumeReclaimPolicy = "Retain"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeStatus struct {
0000000000000000000000000000000000000000;;		// Phase indicates if a volume is available, bound to a claim, or released by a claim
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase PersistentVolumePhase
0000000000000000000000000000000000000000;;		// A human-readable message indicating details about why the volume is in this state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;		// Reason is a brief CamelCase string that describes any failure and is meant for machine parsing and tidy display in the CLI
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;		Items []PersistentVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaim is a user's request for and claim to a persistent volume
0000000000000000000000000000000000000000;;	type PersistentVolumeClaim struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the volume requested by a pod author
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PersistentVolumeClaimSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status represents the current information about a claim
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PersistentVolumeClaimStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;		Items []PersistentVolumeClaim
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimSpec describes the common attributes of storage devices
0000000000000000000000000000000000000000;;	// and allows a Source for provider-specific attributes
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimSpec struct {
0000000000000000000000000000000000000000;;		// Contains the types of access modes required
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AccessModes []PersistentVolumeAccessMode
0000000000000000000000000000000000000000;;		// A label query over volumes to consider for binding. This selector is
0000000000000000000000000000000000000000;;		// ignored when VolumeName is set
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector
0000000000000000000000000000000000000000;;		// Resources represents the minimum resources required
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resources ResourceRequirements
0000000000000000000000000000000000000000;;		// VolumeName is the binding reference to the PersistentVolume backing this
0000000000000000000000000000000000000000;;		// claim. When set to non-empty value Selector is not evaluated
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeName string
0000000000000000000000000000000000000000;;		// Name of the StorageClass required by the claim.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#class-1
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageClassName *string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimStatus struct {
0000000000000000000000000000000000000000;;		// Phase represents the current phase of PersistentVolumeClaim
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase PersistentVolumeClaimPhase
0000000000000000000000000000000000000000;;		// AccessModes contains all ways the volume backing the PVC can be mounted
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AccessModes []PersistentVolumeAccessMode
0000000000000000000000000000000000000000;;		// Represents the actual resources of the underlying volume
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capacity ResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeAccessMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// can be mounted read/write mode to exactly 1 host
0000000000000000000000000000000000000000;;		ReadWriteOnce PersistentVolumeAccessMode = "ReadWriteOnce"
0000000000000000000000000000000000000000;;		// can be mounted in read-only mode to many hosts
0000000000000000000000000000000000000000;;		ReadOnlyMany PersistentVolumeAccessMode = "ReadOnlyMany"
0000000000000000000000000000000000000000;;		// can be mounted in read/write mode to many hosts
0000000000000000000000000000000000000000;;		ReadWriteMany PersistentVolumeAccessMode = "ReadWriteMany"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumePhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that are not available
0000000000000000000000000000000000000000;;		VolumePending PersistentVolumePhase = "Pending"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that are not yet bound
0000000000000000000000000000000000000000;;		// Available volumes are held by the binder and matched to PersistentVolumeClaims
0000000000000000000000000000000000000000;;		VolumeAvailable PersistentVolumePhase = "Available"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that are bound
0000000000000000000000000000000000000000;;		VolumeBound PersistentVolumePhase = "Bound"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes where the bound PersistentVolumeClaim was deleted
0000000000000000000000000000000000000000;;		// released volumes must be recycled before becoming available again
0000000000000000000000000000000000000000;;		// this phase is used by the persistent volume claim binder to signal to another process to reclaim the resource
0000000000000000000000000000000000000000;;		VolumeReleased PersistentVolumePhase = "Released"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that failed to be correctly recycled or deleted after being released from a claim
0000000000000000000000000000000000000000;;		VolumeFailed PersistentVolumePhase = "Failed"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimPhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// used for PersistentVolumeClaims that are not yet bound
0000000000000000000000000000000000000000;;		ClaimPending PersistentVolumeClaimPhase = "Pending"
0000000000000000000000000000000000000000;;		// used for PersistentVolumeClaims that are bound
0000000000000000000000000000000000000000;;		ClaimBound PersistentVolumeClaimPhase = "Bound"
0000000000000000000000000000000000000000;;		// used for PersistentVolumeClaims that lost their underlying
0000000000000000000000000000000000000000;;		// PersistentVolume. The claim was bound to a PersistentVolume and this
0000000000000000000000000000000000000000;;		// volume does not exist any longer and all data on it was lost.
0000000000000000000000000000000000000000;;		ClaimLost PersistentVolumeClaimPhase = "Lost"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a host path mapped into a pod.
0000000000000000000000000000000000000000;;	// Host path volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type HostPathVolumeSource struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents an empty directory for a pod.
0000000000000000000000000000000000000000;;	// Empty directory volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type EmptyDirVolumeSource struct {
0000000000000000000000000000000000000000;;		// TODO: Longer term we want to represent the selection of underlying
0000000000000000000000000000000000000000;;		// media more like a scheduling problem - user says what traits they
0000000000000000000000000000000000000000;;		// need, we give them a backing store that satisfies that.  For now
0000000000000000000000000000000000000000;;		// this will cover the most common needs.
0000000000000000000000000000000000000000;;		// Optional: what type of storage medium should back this directory.
0000000000000000000000000000000000000000;;		// The default is "" which means to use the node's default medium.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Medium StorageMedium
0000000000000000000000000000000000000000;;		// Total amount of local storage required for this EmptyDir volume.
0000000000000000000000000000000000000000;;		// The size limit is also applicable for memory medium.
0000000000000000000000000000000000000000;;		// The maximum usage on memory medium EmptyDir would be the minimum value between
0000000000000000000000000000000000000000;;		// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
0000000000000000000000000000000000000000;;		// The default is nil which means that the limit is undefined.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SizeLimit resource.Quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageMedium defines ways that storage can be allocated to a volume.
0000000000000000000000000000000000000000;;	type StorageMedium string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		StorageMediumDefault StorageMedium = ""       // use whatever the default is for the node
0000000000000000000000000000000000000000;;		StorageMediumMemory  StorageMedium = "Memory" // use memory (tmpfs)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Protocol defines network protocols supported for things like container ports.
0000000000000000000000000000000000000000;;	type Protocol string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ProtocolTCP is the TCP protocol.
0000000000000000000000000000000000000000;;		ProtocolTCP Protocol = "TCP"
0000000000000000000000000000000000000000;;		// ProtocolUDP is the UDP protocol.
0000000000000000000000000000000000000000;;		ProtocolUDP Protocol = "UDP"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Persistent Disk resource in Google Compute Engine.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A GCE PD must exist before mounting to a container. The disk must
0000000000000000000000000000000000000000;;	// also be in the same GCE project and zone as the kubelet. A GCE PD
0000000000000000000000000000000000000000;;	// can only be mounted as read/write once or read-only many times. GCE
0000000000000000000000000000000000000000;;	// PDs support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type GCEPersistentDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// Unique name of the PD resource. Used to identify the disk in GCE
0000000000000000000000000000000000000000;;		PDName string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Optional: Partition on the disk to mount.
0000000000000000000000000000000000000000;;		// If omitted, kubelet will attempt to mount the device name.
0000000000000000000000000000000000000000;;		// Ex. For /dev/sda1, this field is "1", for /dev/sda, this field is 0 or empty.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Partition int32
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents an ISCSI disk.
0000000000000000000000000000000000000000;;	// ISCSI volumes can only be mounted as read/write once.
0000000000000000000000000000000000000000;;	// ISCSI volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type ISCSIVolumeSource struct {
0000000000000000000000000000000000000000;;		// Required: iSCSI target portal
0000000000000000000000000000000000000000;;		// the portal is either an IP or ip_addr:port if port is other than default (typically TCP ports 860 and 3260)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TargetPortal string
0000000000000000000000000000000000000000;;		// Required:  target iSCSI Qualified Name
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		IQN string
0000000000000000000000000000000000000000;;		// Required: iSCSI target lun number
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Lun int32
0000000000000000000000000000000000000000;;		// Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ISCSIInterface string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		// Optional: list of iSCSI target portal ips for high availability.
0000000000000000000000000000000000000000;;		// the portal is either an IP or ip_addr:port if port is other than default (typically TCP ports 860 and 3260)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Portals []string
0000000000000000000000000000000000000000;;		// Optional: whether support iSCSI Discovery CHAP authentication
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DiscoveryCHAPAuth bool
0000000000000000000000000000000000000000;;		// Optional: whether support iSCSI Session CHAP authentication
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SessionCHAPAuth bool
0000000000000000000000000000000000000000;;		// Optional: CHAP secret for iSCSI target and initiator authentication.
0000000000000000000000000000000000000000;;		// The secret is used if either DiscoveryCHAPAuth or SessionCHAPAuth is true
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Fibre Channel volume.
0000000000000000000000000000000000000000;;	// Fibre Channel volumes can only be mounted as read/write once.
0000000000000000000000000000000000000000;;	// Fibre Channel volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type FCVolumeSource struct {
0000000000000000000000000000000000000000;;		// Required: FC target worldwide names (WWNs)
0000000000000000000000000000000000000000;;		TargetWWNs []string
0000000000000000000000000000000000000000;;		// Required: FC target lun number
0000000000000000000000000000000000000000;;		Lun *int32
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlexVolume represents a generic volume resource that is
0000000000000000000000000000000000000000;;	// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
0000000000000000000000000000000000000000;;	type FlexVolumeSource struct {
0000000000000000000000000000000000000000;;		// Driver is the name of the driver to use for this volume.
0000000000000000000000000000000000000000;;		Driver string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Optional: SecretRef is reference to the secret object containing
0000000000000000000000000000000000000000;;		// sensitive information to pass to the plugin scripts. This may be
0000000000000000000000000000000000000000;;		// empty if no secret object is specified. If the secret object
0000000000000000000000000000000000000000;;		// contains more than one secret, all secrets are passed to the plugin
0000000000000000000000000000000000000000;;		// scripts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		// Optional: Extra driver options if any.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Options map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Persistent Disk resource in AWS.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An AWS EBS disk must exist before mounting to a container. The disk
0000000000000000000000000000000000000000;;	// must also be in the same AWS zone as the kubelet. An AWS EBS disk
0000000000000000000000000000000000000000;;	// can only be mounted as read/write once. AWS EBS volumes support
0000000000000000000000000000000000000000;;	// ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type AWSElasticBlockStoreVolumeSource struct {
0000000000000000000000000000000000000000;;		// Unique id of the persistent disk resource. Used to identify the disk in AWS
0000000000000000000000000000000000000000;;		VolumeID string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Optional: Partition on the disk to mount.
0000000000000000000000000000000000000000;;		// If omitted, kubelet will attempt to mount the device name.
0000000000000000000000000000000000000000;;		// Ex. For /dev/sda1, this field is "1", for /dev/sda, this field is 0 or empty.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Partition int32
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a volume that is populated with the contents of a git repository.
0000000000000000000000000000000000000000;;	// Git repo volumes do not support ownership management.
0000000000000000000000000000000000000000;;	// Git repo volumes support SELinux relabeling.
0000000000000000000000000000000000000000;;	type GitRepoVolumeSource struct {
0000000000000000000000000000000000000000;;		// Repository URL
0000000000000000000000000000000000000000;;		Repository string
0000000000000000000000000000000000000000;;		// Commit hash, this is optional
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Revision string
0000000000000000000000000000000000000000;;		// Clone target, this is optional
0000000000000000000000000000000000000000;;		// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
0000000000000000000000000000000000000000;;		// git repository.  Otherwise, if specified, the volume will contain the git repository in
0000000000000000000000000000000000000000;;		// the subdirectory with the given name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Directory string
0000000000000000000000000000000000000000;;		// TODO: Consider credentials here.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a Secret into a volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target Secret's Data field will be presented in a volume
0000000000000000000000000000000000000000;;	// as files using the keys in the Data field as the file names.
0000000000000000000000000000000000000000;;	// Secret volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type SecretVolumeSource struct {
0000000000000000000000000000000000000000;;		// Name of the secret in the pod's namespace to use.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretName string
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// Secret will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the Secret,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath
0000000000000000000000000000000000000000;;		// Mode bits to use on created files by default. Must be a value between
0000000000000000000000000000000000000000;;		// 0 and 0777.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32
0000000000000000000000000000000000000000;;		// Specify whether the Secret or its key must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a secret into a projected volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target Secret's Data field will be presented in a
0000000000000000000000000000000000000000;;	// projected volume as files using the keys in the Data field as the file names.
0000000000000000000000000000000000000000;;	// Note that this is identical to a secret volume source without the default
0000000000000000000000000000000000000000;;	// mode.
0000000000000000000000000000000000000000;;	type SecretProjection struct {
0000000000000000000000000000000000000000;;		LocalObjectReference
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// Secret will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the Secret,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath
0000000000000000000000000000000000000000;;		// Specify whether the Secret or its key must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents an NFS mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// NFS volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type NFSVolumeSource struct {
0000000000000000000000000000000000000000;;		// Server is the hostname or IP address of the NFS server
0000000000000000000000000000000000000000;;		Server string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the exported NFS share
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the NFS export to be mounted with read-only permissions
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Quobyte mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// Quobyte volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type QuobyteVolumeSource struct {
0000000000000000000000000000000000000000;;		// Registry represents a single or multiple Quobyte Registry services
0000000000000000000000000000000000000000;;		// specified as a string as host:port pair (multiple entries are separated with commas)
0000000000000000000000000000000000000000;;		// which acts as the central registry for volumes
0000000000000000000000000000000000000000;;		Registry string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Volume is a string that references an already created Quobyte volume by name.
0000000000000000000000000000000000000000;;		Volume string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the Quobyte to be mounted with read-only permissions
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// User to map volume access to
0000000000000000000000000000000000000000;;		// Defaults to the root user
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		User string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Group to map volume access to
0000000000000000000000000000000000000000;;		// Default is no group
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Group string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Glusterfs mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// Glusterfs volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type GlusterfsVolumeSource struct {
0000000000000000000000000000000000000000;;		// Required: EndpointsName is the endpoint name that details Glusterfs topology
0000000000000000000000000000000000000000;;		EndpointsName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Required: Path is the Glusterfs volume path
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the Glusterfs to be mounted with read-only permissions
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Rados Block Device mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// RBD volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type RBDVolumeSource struct {
0000000000000000000000000000000000000000;;		// Required: CephMonitors is a collection of Ceph monitors
0000000000000000000000000000000000000000;;		CephMonitors []string
0000000000000000000000000000000000000000;;		// Required: RBDImage is the rados image name
0000000000000000000000000000000000000000;;		RBDImage string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Optional: RadosPool is the rados pool name,default is rbd
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RBDPool string
0000000000000000000000000000000000000000;;		// Optional: RBDUser is the rados user name, default is admin
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RadosUser string
0000000000000000000000000000000000000000;;		// Optional: Keyring is the path to key ring for RBDUser, default is /etc/ceph/keyring
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Keyring string
0000000000000000000000000000000000000000;;		// Optional: SecretRef is name of the authentication secret for RBDUser, default is nil.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a cinder volume resource in Openstack. A Cinder volume
0000000000000000000000000000000000000000;;	// must exist before mounting to a container. The volume must also be
0000000000000000000000000000000000000000;;	// in the same region as the kubelet. Cinder volumes support ownership
0000000000000000000000000000000000000000;;	// management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type CinderVolumeSource struct {
0000000000000000000000000000000000000000;;		// Unique id of the volume used to identify the cinder volume
0000000000000000000000000000000000000000;;		VolumeID string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
0000000000000000000000000000000000000000;;	// Cephfs volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type CephFSVolumeSource struct {
0000000000000000000000000000000000000000;;		// Required: Monitors is a collection of Ceph monitors
0000000000000000000000000000000000000000;;		Monitors []string
0000000000000000000000000000000000000000;;		// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		// Optional: User is the rados user name, default is admin
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		User string
0000000000000000000000000000000000000000;;		// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretFile string
0000000000000000000000000000000000000000;;		// Optional: SecretRef is reference to the authentication secret for User, default is empty.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Flocker volume mounted by the Flocker agent.
0000000000000000000000000000000000000000;;	// One and only one of datasetName and datasetUUID should be set.
0000000000000000000000000000000000000000;;	// Flocker volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type FlockerVolumeSource struct {
0000000000000000000000000000000000000000;;		// Name of the dataset stored as metadata -> name on the dataset for Flocker
0000000000000000000000000000000000000000;;		// should be considered as deprecated
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DatasetName string
0000000000000000000000000000000000000000;;		// UUID of the dataset. This is unique identifier of a Flocker dataset
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DatasetUUID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a volume containing downward API info.
0000000000000000000000000000000000000000;;	// Downward API volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type DownwardAPIVolumeSource struct {
0000000000000000000000000000000000000000;;		// Items is a list of DownwardAPIVolume file
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []DownwardAPIVolumeFile
0000000000000000000000000000000000000000;;		// Mode bits to use on created files by default. Must be a value between
0000000000000000000000000000000000000000;;		// 0 and 0777.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a single file containing information from the downward API
0000000000000000000000000000000000000000;;	type DownwardAPIVolumeFile struct {
0000000000000000000000000000000000000000;;		// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		// Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldRef *ObjectFieldSelector
0000000000000000000000000000000000000000;;		// Selects a resource of the container: only resources limits and requests
0000000000000000000000000000000000000000;;		// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceFieldRef *ResourceFieldSelector
0000000000000000000000000000000000000000;;		// Optional: mode bits to use on this file, must be a value between 0
0000000000000000000000000000000000000000;;		// and 0777. If not specified, the volume defaultMode will be used.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Mode *int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents downward API info for projecting into a projected volume.
0000000000000000000000000000000000000000;;	// Note that this is identical to a downwardAPI volume source without the default
0000000000000000000000000000000000000000;;	// mode.
0000000000000000000000000000000000000000;;	type DownwardAPIProjection struct {
0000000000000000000000000000000000000000;;		// Items is a list of DownwardAPIVolume file
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []DownwardAPIVolumeFile
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;	type AzureFileVolumeSource struct {
0000000000000000000000000000000000000000;;		// the name of secret that contains Azure Storage Account Name and Key
0000000000000000000000000000000000000000;;		SecretName string
0000000000000000000000000000000000000000;;		// Share Name
0000000000000000000000000000000000000000;;		ShareName string
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a vSphere volume resource.
0000000000000000000000000000000000000000;;	type VsphereVirtualDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// Path that identifies vSphere volume vmdk
0000000000000000000000000000000000000000;;		VolumePath string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Storage Policy Based Management (SPBM) profile name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StoragePolicyName string
0000000000000000000000000000000000000000;;		// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StoragePolicyID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Photon Controller persistent disk resource.
0000000000000000000000000000000000000000;;	type PhotonPersistentDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// ID that identifies Photon Controller persistent disk
0000000000000000000000000000000000000000;;		PdID string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortworxVolumeSource represents a Portworx volume resource.
0000000000000000000000000000000000000000;;	type PortworxVolumeSource struct {
0000000000000000000000000000000000000000;;		// VolumeID uniquely identifies a Portworx volume
0000000000000000000000000000000000000000;;		VolumeID string
0000000000000000000000000000000000000000;;		// FSType represents the filesystem type to mount
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AzureDataDiskCachingMode string
0000000000000000000000000000000000000000;;	type AzureDataDiskKind string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AzureDataDiskCachingNone      AzureDataDiskCachingMode = "None"
0000000000000000000000000000000000000000;;		AzureDataDiskCachingReadOnly  AzureDataDiskCachingMode = "ReadOnly"
0000000000000000000000000000000000000000;;		AzureDataDiskCachingReadWrite AzureDataDiskCachingMode = "ReadWrite"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AzureSharedBlobDisk    AzureDataDiskKind = "Shared"
0000000000000000000000000000000000000000;;		AzureDedicatedBlobDisk AzureDataDiskKind = "Dedicated"
0000000000000000000000000000000000000000;;		AzureManagedDisk       AzureDataDiskKind = "Managed"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;	type AzureDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// The Name of the data disk in the blob storage
0000000000000000000000000000000000000000;;		DiskName string
0000000000000000000000000000000000000000;;		// The URI of the data disk in the blob storage
0000000000000000000000000000000000000000;;		DataDiskURI string
0000000000000000000000000000000000000000;;		// Host Caching mode: None, Read Only, Read Write.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CachingMode *AzureDataDiskCachingMode
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType *string
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly *bool
0000000000000000000000000000000000000000;;		// Expected values Shared: mulitple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
0000000000000000000000000000000000000000;;		Kind *AzureDataDiskKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleIOVolumeSource represents a persistent ScaleIO volume
0000000000000000000000000000000000000000;;	type ScaleIOVolumeSource struct {
0000000000000000000000000000000000000000;;		// The host address of the ScaleIO API Gateway.
0000000000000000000000000000000000000000;;		Gateway string
0000000000000000000000000000000000000000;;		// The name of the storage system as configured in ScaleIO.
0000000000000000000000000000000000000000;;		System string
0000000000000000000000000000000000000000;;		// SecretRef references to the secret for ScaleIO user and other
0000000000000000000000000000000000000000;;		// sensitive information. If this is not provided, Login operation will fail.
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference
0000000000000000000000000000000000000000;;		// Flag to enable/disable SSL communication with Gateway, default false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SSLEnabled bool
0000000000000000000000000000000000000000;;		// The name of the Protection Domain for the configured storage (defaults to "default").
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ProtectionDomain string
0000000000000000000000000000000000000000;;		// The Storage Pool associated with the protection domain (defaults to "default").
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StoragePool string
0000000000000000000000000000000000000000;;		// Indicates whether the storage for a volume should be thick or thin (defaults to "thin").
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageMode string
0000000000000000000000000000000000000000;;		// The name of a volume already created in the ScaleIO system
0000000000000000000000000000000000000000;;		// that is associated with this volume source.
0000000000000000000000000000000000000000;;		VolumeName string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a StorageOS persistent volume resource.
0000000000000000000000000000000000000000;;	type StorageOSVolumeSource struct {
0000000000000000000000000000000000000000;;		// VolumeName is the human-readable name of the StorageOS volume.  Volume
0000000000000000000000000000000000000000;;		// names are only unique within a namespace.
0000000000000000000000000000000000000000;;		VolumeName string
0000000000000000000000000000000000000000;;		// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
0000000000000000000000000000000000000000;;		// namespace is specified then the Pod's namespace will be used.  This allows the
0000000000000000000000000000000000000000;;		// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
0000000000000000000000000000000000000000;;		// Set VolumeName to any name to override the default behaviour.
0000000000000000000000000000000000000000;;		// Set to "default" if you are not using namespaces within StorageOS.
0000000000000000000000000000000000000000;;		// Namespaces that do not pre-exist within StorageOS will be created.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeNamespace string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		// SecretRef specifies the secret to use for obtaining the StorageOS API
0000000000000000000000000000000000000000;;		// credentials.  If not specified, default values will be attempted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a StorageOS persistent volume resource.
0000000000000000000000000000000000000000;;	type StorageOSPersistentVolumeSource struct {
0000000000000000000000000000000000000000;;		// VolumeName is the human-readable name of the StorageOS volume.  Volume
0000000000000000000000000000000000000000;;		// names are only unique within a namespace.
0000000000000000000000000000000000000000;;		VolumeName string
0000000000000000000000000000000000000000;;		// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
0000000000000000000000000000000000000000;;		// namespace is specified then the Pod's namespace will be used.  This allows the
0000000000000000000000000000000000000000;;		// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
0000000000000000000000000000000000000000;;		// Set VolumeName to any name to override the default behaviour.
0000000000000000000000000000000000000000;;		// Set to "default" if you are not using namespaces within StorageOS.
0000000000000000000000000000000000000000;;		// Namespaces that do not pre-exist within StorageOS will be created.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeNamespace string
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		// SecretRef specifies the secret to use for obtaining the StorageOS API
0000000000000000000000000000000000000000;;		// credentials.  If not specified, default values will be attempted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *ObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a ConfigMap into a volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target ConfigMap's Data field will be presented in a
0000000000000000000000000000000000000000;;	// volume as files using the keys in the Data field as the file names, unless
0000000000000000000000000000000000000000;;	// the items element is populated with specific mappings of keys to paths.
0000000000000000000000000000000000000000;;	// ConfigMap volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type ConfigMapVolumeSource struct {
0000000000000000000000000000000000000000;;		LocalObjectReference
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// ConfigMap will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the ConfigMap,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath
0000000000000000000000000000000000000000;;		// Mode bits to use on created files by default. Must be a value between
0000000000000000000000000000000000000000;;		// 0 and 0777.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap or it's keys must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a ConfigMap into a projected volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target ConfigMap's Data field will be presented in a
0000000000000000000000000000000000000000;;	// projected volume as files using the keys in the Data field as the file names,
0000000000000000000000000000000000000000;;	// unless the items element is populated with specific mappings of keys to paths.
0000000000000000000000000000000000000000;;	// Note that this is identical to a configmap volume source without the default
0000000000000000000000000000000000000000;;	// mode.
0000000000000000000000000000000000000000;;	type ConfigMapProjection struct {
0000000000000000000000000000000000000000;;		LocalObjectReference
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// ConfigMap will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the ConfigMap,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap or it's keys must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a projected volume source
0000000000000000000000000000000000000000;;	type ProjectedVolumeSource struct {
0000000000000000000000000000000000000000;;		// list of volume projections
0000000000000000000000000000000000000000;;		Sources []VolumeProjection
0000000000000000000000000000000000000000;;		// Mode bits to use on created files by default. Must be a value between
0000000000000000000000000000000000000000;;		// 0 and 0777.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Projection that may be projected along with other supported volume types
0000000000000000000000000000000000000000;;	type VolumeProjection struct {
0000000000000000000000000000000000000000;;		// all types below are the supported types for projection into the same volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// information about the secret data to project
0000000000000000000000000000000000000000;;		Secret *SecretProjection
0000000000000000000000000000000000000000;;		// information about the downwardAPI data to project
0000000000000000000000000000000000000000;;		DownwardAPI *DownwardAPIProjection
0000000000000000000000000000000000000000;;		// information about the configMap data to project
0000000000000000000000000000000000000000;;		ConfigMap *ConfigMapProjection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Maps a string key to a path within a volume.
0000000000000000000000000000000000000000;;	type KeyToPath struct {
0000000000000000000000000000000000000000;;		// The key to project.
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The relative path of the file to map the key to.
0000000000000000000000000000000000000000;;		// May not be an absolute path.
0000000000000000000000000000000000000000;;		// May not contain the path element '..'.
0000000000000000000000000000000000000000;;		// May not start with the string '..'.
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		// Optional: mode bits to use on this file, should be a value between 0
0000000000000000000000000000000000000000;;		// and 0777. If not specified, the volume defaultMode will be used.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Mode *int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Local represents directly-attached storage with node affinity
0000000000000000000000000000000000000000;;	type LocalVolumeSource struct {
0000000000000000000000000000000000000000;;		// The full path to the volume on the node
0000000000000000000000000000000000000000;;		// For alpha, this path must be a directory
0000000000000000000000000000000000000000;;		// Once block as a source is supported, then this path can point to a block device
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerPort represents a network port in a single container
0000000000000000000000000000000000000000;;	type ContainerPort struct {
0000000000000000000000000000000000000000;;		// Optional: If specified, this must be an IANA_SVC_NAME  Each named port
0000000000000000000000000000000000000000;;		// in a pod must have a unique name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Optional: If specified, this must be a valid port number, 0 < x < 65536.
0000000000000000000000000000000000000000;;		// If HostNetwork is specified, this must match ContainerPort.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPort int32
0000000000000000000000000000000000000000;;		// Required: This must be a valid port number, 0 < x < 65536.
0000000000000000000000000000000000000000;;		ContainerPort int32
0000000000000000000000000000000000000000;;		// Required: Supports "TCP" and "UDP".
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Protocol Protocol
0000000000000000000000000000000000000000;;		// Optional: What host IP to bind the external port to.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostIP string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeMount describes a mounting of a Volume within a container.
0000000000000000000000000000000000000000;;	type VolumeMount struct {
0000000000000000000000000000000000000000;;		// Required: This must match the Name of a Volume [above].
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read-write).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		// Required. Must not contain ':'.
0000000000000000000000000000000000000000;;		MountPath string
0000000000000000000000000000000000000000;;		// Path within the volume from which the container's volume should be mounted.
0000000000000000000000000000000000000000;;		// Defaults to "" (volume's root).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SubPath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvVar represents an environment variable present in a Container.
0000000000000000000000000000000000000000;;	type EnvVar struct {
0000000000000000000000000000000000000000;;		// Required: This must be a C_IDENTIFIER.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Optional: no more than one of the following may be specified.
0000000000000000000000000000000000000000;;		// Optional: Defaults to ""; variable references $(VAR_NAME) are expanded
0000000000000000000000000000000000000000;;		// using the previous defined environment variables in the container and
0000000000000000000000000000000000000000;;		// any service environment variables.  If a variable cannot be resolved,
0000000000000000000000000000000000000000;;		// the reference in the input string will be unchanged.  The $(VAR_NAME)
0000000000000000000000000000000000000000;;		// syntax can be escaped with a double $$, ie: $$(VAR_NAME).  Escaped
0000000000000000000000000000000000000000;;		// references will never be expanded, regardless of whether the variable
0000000000000000000000000000000000000000;;		// exists or not.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;		// Optional: Specifies a source the value of this var should come from.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ValueFrom *EnvVarSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvVarSource represents a source for the value of an EnvVar.
0000000000000000000000000000000000000000;;	// Only one of its fields may be set.
0000000000000000000000000000000000000000;;	type EnvVarSource struct {
0000000000000000000000000000000000000000;;		// Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations,
0000000000000000000000000000000000000000;;		// metadata.uid, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldRef *ObjectFieldSelector
0000000000000000000000000000000000000000;;		// Selects a resource of the container: only resources limits and requests
0000000000000000000000000000000000000000;;		// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceFieldRef *ResourceFieldSelector
0000000000000000000000000000000000000000;;		// Selects a key of a ConfigMap.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ConfigMapKeyRef *ConfigMapKeySelector
0000000000000000000000000000000000000000;;		// Selects a key of a secret in the pod's namespace.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretKeyRef *SecretKeySelector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectFieldSelector selects an APIVersioned field of an object.
0000000000000000000000000000000000000000;;	type ObjectFieldSelector struct {
0000000000000000000000000000000000000000;;		// Required: Version of the schema the FieldPath is written in terms of.
0000000000000000000000000000000000000000;;		// If no value is specified, it will be defaulted to the APIVersion of the
0000000000000000000000000000000000000000;;		// enclosing object.
0000000000000000000000000000000000000000;;		APIVersion string
0000000000000000000000000000000000000000;;		// Required: Path of the field to select in the specified API version
0000000000000000000000000000000000000000;;		FieldPath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceFieldSelector represents container resources (cpu, memory) and their output format
0000000000000000000000000000000000000000;;	type ResourceFieldSelector struct {
0000000000000000000000000000000000000000;;		// Container name: required for volumes, optional for env vars
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerName string
0000000000000000000000000000000000000000;;		// Required: resource to select
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;		// Specifies the output format of the exposed resources, defaults to "1"
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Divisor resource.Quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Selects a key from a ConfigMap.
0000000000000000000000000000000000000000;;	type ConfigMapKeySelector struct {
0000000000000000000000000000000000000000;;		// The ConfigMap to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference
0000000000000000000000000000000000000000;;		// The key to select.
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap or it's key must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretKeySelector selects a key of a Secret.
0000000000000000000000000000000000000000;;	type SecretKeySelector struct {
0000000000000000000000000000000000000000;;		// The name of the secret in the pod's namespace to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference
0000000000000000000000000000000000000000;;		// The key of the secret to select from.  Must be a valid secret key.
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;		// Specify whether the Secret or it's key must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvFromSource represents the source of a set of ConfigMaps
0000000000000000000000000000000000000000;;	type EnvFromSource struct {
0000000000000000000000000000000000000000;;		// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Prefix string
0000000000000000000000000000000000000000;;		// The ConfigMap to select from.
0000000000000000000000000000000000000000;;		//+optional
0000000000000000000000000000000000000000;;		ConfigMapRef *ConfigMapEnvSource
0000000000000000000000000000000000000000;;		// The Secret to select from.
0000000000000000000000000000000000000000;;		//+optional
0000000000000000000000000000000000000000;;		SecretRef *SecretEnvSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMapEnvSource selects a ConfigMap to populate the environment
0000000000000000000000000000000000000000;;	// variables with.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target ConfigMap's Data field will represent the
0000000000000000000000000000000000000000;;	// key-value pairs as environment variables.
0000000000000000000000000000000000000000;;	type ConfigMapEnvSource struct {
0000000000000000000000000000000000000000;;		// The ConfigMap to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretEnvSource selects a Secret to populate the environment
0000000000000000000000000000000000000000;;	// variables with.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target Secret's Data field will represent the
0000000000000000000000000000000000000000;;	// key-value pairs as environment variables.
0000000000000000000000000000000000000000;;	type SecretEnvSource struct {
0000000000000000000000000000000000000000;;		// The Secret to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference
0000000000000000000000000000000000000000;;		// Specify whether the Secret must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPHeader describes a custom header to be used in HTTP probes
0000000000000000000000000000000000000000;;	type HTTPHeader struct {
0000000000000000000000000000000000000000;;		// The header field name
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// The header field value
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPGetAction describes an action based on HTTP Get requests.
0000000000000000000000000000000000000000;;	type HTTPGetAction struct {
0000000000000000000000000000000000000000;;		// Optional: Path to access on the HTTP server.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		// Required: Name or number of the port to access on the container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Port intstr.IntOrString
0000000000000000000000000000000000000000;;		// Optional: Host name to connect to, defaults to the pod IP. You
0000000000000000000000000000000000000000;;		// probably want to set "Host" in httpHeaders instead.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Host string
0000000000000000000000000000000000000000;;		// Optional: Scheme to use for connecting to the host, defaults to HTTP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Scheme URIScheme
0000000000000000000000000000000000000000;;		// Optional: Custom headers to set in the request. HTTP allows repeated headers.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HTTPHeaders []HTTPHeader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URIScheme identifies the scheme used for connection to a host for Get actions
0000000000000000000000000000000000000000;;	type URIScheme string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// URISchemeHTTP means that the scheme used will be http://
0000000000000000000000000000000000000000;;		URISchemeHTTP URIScheme = "HTTP"
0000000000000000000000000000000000000000;;		// URISchemeHTTPS means that the scheme used will be https://
0000000000000000000000000000000000000000;;		URISchemeHTTPS URIScheme = "HTTPS"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TCPSocketAction describes an action based on opening a socket
0000000000000000000000000000000000000000;;	type TCPSocketAction struct {
0000000000000000000000000000000000000000;;		// Required: Port to connect to.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Port intstr.IntOrString
0000000000000000000000000000000000000000;;		// Optional: Host name to connect to, defaults to the pod IP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Host string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecAction describes a "run in container" action.
0000000000000000000000000000000000000000;;	type ExecAction struct {
0000000000000000000000000000000000000000;;		// Command is the command line to execute inside the container, the working directory for the
0000000000000000000000000000000000000000;;		// command  is root ('/') in the container's filesystem.  The command is simply exec'd, it is
0000000000000000000000000000000000000000;;		// not run inside a shell, so traditional shell instructions ('|', etc) won't work.  To use
0000000000000000000000000000000000000000;;		// a shell, you need to explicitly call out to that shell.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Command []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Probe describes a health check to be performed against a container to determine whether it is
0000000000000000000000000000000000000000;;	// alive or ready to receive traffic.
0000000000000000000000000000000000000000;;	type Probe struct {
0000000000000000000000000000000000000000;;		// The action taken to determine the health of a container
0000000000000000000000000000000000000000;;		Handler
0000000000000000000000000000000000000000;;		// Length of time before health checking is activated.  In seconds.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		InitialDelaySeconds int32
0000000000000000000000000000000000000000;;		// Length of time before health checking times out.  In seconds.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TimeoutSeconds int32
0000000000000000000000000000000000000000;;		// How often (in seconds) to perform the probe.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PeriodSeconds int32
0000000000000000000000000000000000000000;;		// Minimum consecutive successes for the probe to be considered successful after having failed.
0000000000000000000000000000000000000000;;		// Must be 1 for liveness.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SuccessThreshold int32
0000000000000000000000000000000000000000;;		// Minimum consecutive failures for the probe to be considered failed after having succeeded.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FailureThreshold int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PullPolicy describes a policy for if/when to pull a container image
0000000000000000000000000000000000000000;;	type PullPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PullAlways means that kubelet always attempts to pull the latest image.  Container will fail If the pull fails.
0000000000000000000000000000000000000000;;		PullAlways PullPolicy = "Always"
0000000000000000000000000000000000000000;;		// PullNever means that kubelet never pulls an image, but only uses a local image.  Container will fail if the image isn't present
0000000000000000000000000000000000000000;;		PullNever PullPolicy = "Never"
0000000000000000000000000000000000000000;;		// PullIfNotPresent means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
0000000000000000000000000000000000000000;;		PullIfNotPresent PullPolicy = "IfNotPresent"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TerminationMessagePolicy describes how termination messages are retrieved from a container.
0000000000000000000000000000000000000000;;	type TerminationMessagePolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TerminationMessageReadFile is the default behavior and will set the container status message to
0000000000000000000000000000000000000000;;		// the contents of the container's terminationMessagePath when the container exits.
0000000000000000000000000000000000000000;;		TerminationMessageReadFile TerminationMessagePolicy = "File"
0000000000000000000000000000000000000000;;		// TerminationMessageFallbackToLogsOnError will read the most recent contents of the container logs
0000000000000000000000000000000000000000;;		// for the container status message when the container exits with an error and the
0000000000000000000000000000000000000000;;		// terminationMessagePath has no contents.
0000000000000000000000000000000000000000;;		TerminationMessageFallbackToLogsOnError TerminationMessagePolicy = "FallbackToLogsOnError"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Capability represent POSIX capabilities type
0000000000000000000000000000000000000000;;	type Capability string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Capabilities represent POSIX capabilities that can be added or removed to a running container.
0000000000000000000000000000000000000000;;	type Capabilities struct {
0000000000000000000000000000000000000000;;		// Added capabilities
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Add []Capability
0000000000000000000000000000000000000000;;		// Removed capabilities
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Drop []Capability
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceRequirements describes the compute resource requirements.
0000000000000000000000000000000000000000;;	type ResourceRequirements struct {
0000000000000000000000000000000000000000;;		// Limits describes the maximum amount of compute resources allowed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Limits ResourceList
0000000000000000000000000000000000000000;;		// Requests describes the minimum amount of compute resources required.
0000000000000000000000000000000000000000;;		// If Request is omitted for a container, it defaults to Limits if that is explicitly specified,
0000000000000000000000000000000000000000;;		// otherwise to an implementation-defined value
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Requests ResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container represents a single container that is expected to be run on the host.
0000000000000000000000000000000000000000;;	type Container struct {
0000000000000000000000000000000000000000;;		// Required: This must be a DNS_LABEL.  Each container in a pod must
0000000000000000000000000000000000000000;;		// have a unique name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Required.
0000000000000000000000000000000000000000;;		Image string
0000000000000000000000000000000000000000;;		// Optional: The docker image's entrypoint is used if this is not provided; cannot be updated.
0000000000000000000000000000000000000000;;		// Variable references $(VAR_NAME) are expanded using the container's environment.  If a variable
0000000000000000000000000000000000000000;;		// cannot be resolved, the reference in the input string will be unchanged.  The $(VAR_NAME) syntax
0000000000000000000000000000000000000000;;		// can be escaped with a double $$, ie: $$(VAR_NAME).  Escaped references will never be expanded,
0000000000000000000000000000000000000000;;		// regardless of whether the variable exists or not.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Command []string
0000000000000000000000000000000000000000;;		// Optional: The docker image's cmd is used if this is not provided; cannot be updated.
0000000000000000000000000000000000000000;;		// Variable references $(VAR_NAME) are expanded using the container's environment.  If a variable
0000000000000000000000000000000000000000;;		// cannot be resolved, the reference in the input string will be unchanged.  The $(VAR_NAME) syntax
0000000000000000000000000000000000000000;;		// can be escaped with a double $$, ie: $$(VAR_NAME).  Escaped references will never be expanded,
0000000000000000000000000000000000000000;;		// regardless of whether the variable exists or not.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Args []string
0000000000000000000000000000000000000000;;		// Optional: Defaults to Docker's default.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		WorkingDir string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ports []ContainerPort
0000000000000000000000000000000000000000;;		// List of sources to populate environment variables in the container.
0000000000000000000000000000000000000000;;		// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
0000000000000000000000000000000000000000;;		// will be reported as an event when the container is starting. When a key exists in multiple
0000000000000000000000000000000000000000;;		// sources, the value associated with the last source will take precedence.
0000000000000000000000000000000000000000;;		// Values defined by an Env with a duplicate key will take precedence.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		EnvFrom []EnvFromSource
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Env []EnvVar
0000000000000000000000000000000000000000;;		// Compute resource requirements.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resources ResourceRequirements
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeMounts []VolumeMount
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LivenessProbe *Probe
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadinessProbe *Probe
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Lifecycle *Lifecycle
0000000000000000000000000000000000000000;;		// Required.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TerminationMessagePath string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TerminationMessagePolicy TerminationMessagePolicy
0000000000000000000000000000000000000000;;		// Required: Policy for pulling images for this container
0000000000000000000000000000000000000000;;		ImagePullPolicy PullPolicy
0000000000000000000000000000000000000000;;		// Optional: SecurityContext defines the security options the container should be run with.
0000000000000000000000000000000000000000;;		// If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecurityContext *SecurityContext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
0000000000000000000000000000000000000000;;		// and shouldn't be used for general purpose containers.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdin bool
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StdinOnce bool
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TTY bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler defines a specific action that should be taken
0000000000000000000000000000000000000000;;	// TODO: pass structured data to these actions, and document that data here.
0000000000000000000000000000000000000000;;	type Handler struct {
0000000000000000000000000000000000000000;;		// One and only one of the following should be specified.
0000000000000000000000000000000000000000;;		// Exec specifies the action to take.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Exec *ExecAction
0000000000000000000000000000000000000000;;		// HTTPGet specifies the http request to perform.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HTTPGet *HTTPGetAction
0000000000000000000000000000000000000000;;		// TCPSocket specifies an action involving a TCP port.
0000000000000000000000000000000000000000;;		// TODO: implement a realistic TCP lifecycle hook
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TCPSocket *TCPSocketAction
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lifecycle describes actions that the management system should take in response to container lifecycle
0000000000000000000000000000000000000000;;	// events.  For the PostStart and PreStop lifecycle handlers, management of the container blocks
0000000000000000000000000000000000000000;;	// until the action is complete, unless the container process fails, in which case the handler is aborted.
0000000000000000000000000000000000000000;;	type Lifecycle struct {
0000000000000000000000000000000000000000;;		// PostStart is called immediately after a container is created.  If the handler fails, the container
0000000000000000000000000000000000000000;;		// is terminated and restarted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PostStart *Handler
0000000000000000000000000000000000000000;;		// PreStop is called immediately before a container is terminated.  The reason for termination is
0000000000000000000000000000000000000000;;		// passed to the handler.  Regardless of the outcome of the handler, the container is eventually terminated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreStop *Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The below types are used by kube_client and api_server.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConditionStatus string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid condition statuses. "ConditionTrue" means a resource is in the condition;
0000000000000000000000000000000000000000;;	// "ConditionFalse" means a resource is not in the condition; "ConditionUnknown" means kubernetes
0000000000000000000000000000000000000000;;	// can't decide if a resource is in the condition or not. In the future, we could add other
0000000000000000000000000000000000000000;;	// intermediate conditions, e.g. ConditionDegraded.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ConditionTrue    ConditionStatus = "True"
0000000000000000000000000000000000000000;;		ConditionFalse   ConditionStatus = "False"
0000000000000000000000000000000000000000;;		ConditionUnknown ConditionStatus = "Unknown"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerStateWaiting struct {
0000000000000000000000000000000000000000;;		// A brief CamelCase string indicating details about why the container is in waiting state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// A human-readable message indicating details about why the container is in waiting state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerStateRunning struct {
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StartedAt metav1.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerStateTerminated struct {
0000000000000000000000000000000000000000;;		ExitCode int32
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Signal int32
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StartedAt metav1.Time
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FinishedAt metav1.Time
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerState holds a possible state of container.
0000000000000000000000000000000000000000;;	// Only one of its members may be specified.
0000000000000000000000000000000000000000;;	// If none of them is specified, the default one is ContainerStateWaiting.
0000000000000000000000000000000000000000;;	type ContainerState struct {
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Waiting *ContainerStateWaiting
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Running *ContainerStateRunning
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Terminated *ContainerStateTerminated
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerStatus struct {
0000000000000000000000000000000000000000;;		// Each container in a pod must have a unique name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		State ContainerState
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTerminationState ContainerState
0000000000000000000000000000000000000000;;		// Ready specifies whether the container has passed its readiness check.
0000000000000000000000000000000000000000;;		Ready bool
0000000000000000000000000000000000000000;;		// Note that this is calculated from dead containers.  But those containers are subject to
0000000000000000000000000000000000000000;;		// garbage collection.  This value will get capped at 5 by GC.
0000000000000000000000000000000000000000;;		RestartCount int32
0000000000000000000000000000000000000000;;		Image        string
0000000000000000000000000000000000000000;;		ImageID      string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodPhase is a label for the condition of a pod at the current time.
0000000000000000000000000000000000000000;;	type PodPhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid statuses of pods.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PodPending means the pod has been accepted by the system, but one or more of the containers
0000000000000000000000000000000000000000;;		// has not been started. This includes time before being bound to a node, as well as time spent
0000000000000000000000000000000000000000;;		// pulling images onto the host.
0000000000000000000000000000000000000000;;		PodPending PodPhase = "Pending"
0000000000000000000000000000000000000000;;		// PodRunning means the pod has been bound to a node and all of the containers have been started.
0000000000000000000000000000000000000000;;		// At least one container is still running or is in the process of being restarted.
0000000000000000000000000000000000000000;;		PodRunning PodPhase = "Running"
0000000000000000000000000000000000000000;;		// PodSucceeded means that all containers in the pod have voluntarily terminated
0000000000000000000000000000000000000000;;		// with a container exit code of 0, and the system is not going to restart any of these containers.
0000000000000000000000000000000000000000;;		PodSucceeded PodPhase = "Succeeded"
0000000000000000000000000000000000000000;;		// PodFailed means that all containers in the pod have terminated, and at least one container has
0000000000000000000000000000000000000000;;		// terminated in a failure (exited with a non-zero exit code or was stopped by the system).
0000000000000000000000000000000000000000;;		PodFailed PodPhase = "Failed"
0000000000000000000000000000000000000000;;		// PodUnknown means that for some reason the state of the pod could not be obtained, typically due
0000000000000000000000000000000000000000;;		// to an error in communicating with the host of the pod.
0000000000000000000000000000000000000000;;		PodUnknown PodPhase = "Unknown"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PodConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of pod.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PodScheduled represents status of the scheduling process for this pod.
0000000000000000000000000000000000000000;;		PodScheduled PodConditionType = "PodScheduled"
0000000000000000000000000000000000000000;;		// PodReady means the pod is able to service requests and should be added to the
0000000000000000000000000000000000000000;;		// load balancing pools of all matching services.
0000000000000000000000000000000000000000;;		PodReady PodConditionType = "Ready"
0000000000000000000000000000000000000000;;		// PodInitialized means that all init containers in the pod have started successfully.
0000000000000000000000000000000000000000;;		PodInitialized PodConditionType = "Initialized"
0000000000000000000000000000000000000000;;		// PodReasonUnschedulable reason in PodScheduled PodCondition means that the scheduler
0000000000000000000000000000000000000000;;		// can't schedule the pod right now, for example due to insufficient resources in the cluster.
0000000000000000000000000000000000000000;;		PodReasonUnschedulable = "Unschedulable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PodCondition struct {
0000000000000000000000000000000000000000;;		Type   PodConditionType
0000000000000000000000000000000000000000;;		Status ConditionStatus
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastProbeTime metav1.Time
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestartPolicy describes how the container should be restarted.
0000000000000000000000000000000000000000;;	// Only one of the following restart policies may be specified.
0000000000000000000000000000000000000000;;	// If none of the following policies is specified, the default one
0000000000000000000000000000000000000000;;	// is RestartPolicyAlways.
0000000000000000000000000000000000000000;;	type RestartPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		RestartPolicyAlways    RestartPolicy = "Always"
0000000000000000000000000000000000000000;;		RestartPolicyOnFailure RestartPolicy = "OnFailure"
0000000000000000000000000000000000000000;;		RestartPolicyNever     RestartPolicy = "Never"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodList is a list of Pods.
0000000000000000000000000000000000000000;;	type PodList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DNSPolicy defines how a pod's DNS will be configured.
0000000000000000000000000000000000000000;;	type DNSPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DNSClusterFirstWithHostNet indicates that the pod should use cluster DNS
0000000000000000000000000000000000000000;;		// first, if it is available, then fall back on the default
0000000000000000000000000000000000000000;;		// (as determined by kubelet) DNS settings.
0000000000000000000000000000000000000000;;		DNSClusterFirstWithHostNet DNSPolicy = "ClusterFirstWithHostNet"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DNSClusterFirst indicates that the pod should use cluster DNS
0000000000000000000000000000000000000000;;		// first unless hostNetwork is true, if it is available, then
0000000000000000000000000000000000000000;;		// fall back on the default (as determined by kubelet) DNS settings.
0000000000000000000000000000000000000000;;		DNSClusterFirst DNSPolicy = "ClusterFirst"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DNSDefault indicates that the pod should use the default (as
0000000000000000000000000000000000000000;;		// determined by kubelet) DNS settings.
0000000000000000000000000000000000000000;;		DNSDefault DNSPolicy = "Default"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A node selector represents the union of the results of one or more label queries
0000000000000000000000000000000000000000;;	// over a set of nodes; that is, it represents the OR of the selectors represented
0000000000000000000000000000000000000000;;	// by the node selector terms.
0000000000000000000000000000000000000000;;	type NodeSelector struct {
0000000000000000000000000000000000000000;;		//Required. A list of node selector terms. The terms are ORed.
0000000000000000000000000000000000000000;;		NodeSelectorTerms []NodeSelectorTerm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A null or empty node selector term matches no objects.
0000000000000000000000000000000000000000;;	type NodeSelectorTerm struct {
0000000000000000000000000000000000000000;;		//Required. A list of node selector requirements. The requirements are ANDed.
0000000000000000000000000000000000000000;;		MatchExpressions []NodeSelectorRequirement
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A node selector requirement is a selector that contains values, a key, and an operator
0000000000000000000000000000000000000000;;	// that relates the key and values.
0000000000000000000000000000000000000000;;	type NodeSelectorRequirement struct {
0000000000000000000000000000000000000000;;		// The label key that the selector applies to.
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;		// Represents a key's relationship to a set of values.
0000000000000000000000000000000000000000;;		// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
0000000000000000000000000000000000000000;;		Operator NodeSelectorOperator
0000000000000000000000000000000000000000;;		// An array of string values. If the operator is In or NotIn,
0000000000000000000000000000000000000000;;		// the values array must be non-empty. If the operator is Exists or DoesNotExist,
0000000000000000000000000000000000000000;;		// the values array must be empty. If the operator is Gt or Lt, the values
0000000000000000000000000000000000000000;;		// array must have a single element, which will be interpreted as an integer.
0000000000000000000000000000000000000000;;		// This array is replaced during a strategic merge patch.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Values []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A node selector operator is the set of operators that can be used in
0000000000000000000000000000000000000000;;	// a node selector requirement.
0000000000000000000000000000000000000000;;	type NodeSelectorOperator string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NodeSelectorOpIn           NodeSelectorOperator = "In"
0000000000000000000000000000000000000000;;		NodeSelectorOpNotIn        NodeSelectorOperator = "NotIn"
0000000000000000000000000000000000000000;;		NodeSelectorOpExists       NodeSelectorOperator = "Exists"
0000000000000000000000000000000000000000;;		NodeSelectorOpDoesNotExist NodeSelectorOperator = "DoesNotExist"
0000000000000000000000000000000000000000;;		NodeSelectorOpGt           NodeSelectorOperator = "Gt"
0000000000000000000000000000000000000000;;		NodeSelectorOpLt           NodeSelectorOperator = "Lt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Affinity is a group of affinity scheduling rules.
0000000000000000000000000000000000000000;;	type Affinity struct {
0000000000000000000000000000000000000000;;		// Describes node affinity scheduling rules for the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeAffinity *NodeAffinity
0000000000000000000000000000000000000000;;		// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodAffinity *PodAffinity
0000000000000000000000000000000000000000;;		// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodAntiAffinity *PodAntiAffinity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod affinity is a group of inter pod affinity scheduling rules.
0000000000000000000000000000000000000000;;	type PodAffinity struct {
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system will try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system may or may not try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm
0000000000000000000000000000000000000000;;		// The scheduler will prefer to schedule pods to nodes that satisfy
0000000000000000000000000000000000000000;;		// the affinity expressions specified by this field, but it may choose
0000000000000000000000000000000000000000;;		// a node that violates one or more of the expressions. The node that is
0000000000000000000000000000000000000000;;		// most preferred is the one with the greatest sum of weights, i.e.
0000000000000000000000000000000000000000;;		// for each node that meets all of the scheduling requirements (resource
0000000000000000000000000000000000000000;;		// request, requiredDuringScheduling affinity expressions, etc.),
0000000000000000000000000000000000000000;;		// compute a sum by iterating through the elements of this field and adding
0000000000000000000000000000000000000000;;		// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
0000000000000000000000000000000000000000;;		// node(s) with the highest sum are the most preferred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
0000000000000000000000000000000000000000;;	type PodAntiAffinity struct {
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system will try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system may or may not try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm
0000000000000000000000000000000000000000;;		// The scheduler will prefer to schedule pods to nodes that satisfy
0000000000000000000000000000000000000000;;		// the anti-affinity expressions specified by this field, but it may choose
0000000000000000000000000000000000000000;;		// a node that violates one or more of the expressions. The node that is
0000000000000000000000000000000000000000;;		// most preferred is the one with the greatest sum of weights, i.e.
0000000000000000000000000000000000000000;;		// for each node that meets all of the scheduling requirements (resource
0000000000000000000000000000000000000000;;		// request, requiredDuringScheduling anti-affinity expressions, etc.),
0000000000000000000000000000000000000000;;		// compute a sum by iterating through the elements of this field and adding
0000000000000000000000000000000000000000;;		// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
0000000000000000000000000000000000000000;;		// node(s) with the highest sum are the most preferred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
0000000000000000000000000000000000000000;;	type WeightedPodAffinityTerm struct {
0000000000000000000000000000000000000000;;		// weight associated with matching the corresponding podAffinityTerm,
0000000000000000000000000000000000000000;;		// in the range 1-100.
0000000000000000000000000000000000000000;;		Weight int32
0000000000000000000000000000000000000000;;		// Required. A pod affinity term, associated with the corresponding weight.
0000000000000000000000000000000000000000;;		PodAffinityTerm PodAffinityTerm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Defines a set of pods (namely those matching the labelSelector
0000000000000000000000000000000000000000;;	// relative to the given namespace(s)) that this pod should be
0000000000000000000000000000000000000000;;	// co-located (affinity) or not co-located (anti-affinity) with,
0000000000000000000000000000000000000000;;	// where co-located is defined as running on a node whose value of
0000000000000000000000000000000000000000;;	// the label with key <topologyKey> matches that of any node on which
0000000000000000000000000000000000000000;;	// a pod of the set of pods is running.
0000000000000000000000000000000000000000;;	type PodAffinityTerm struct {
0000000000000000000000000000000000000000;;		// A label query over a set of resources, in this case pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LabelSelector *metav1.LabelSelector
0000000000000000000000000000000000000000;;		// namespaces specifies which namespaces the labelSelector applies to (matches against);
0000000000000000000000000000000000000000;;		// null or empty list means "this pod's namespace"
0000000000000000000000000000000000000000;;		Namespaces []string
0000000000000000000000000000000000000000;;		// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
0000000000000000000000000000000000000000;;		// the labelSelector in the specified namespaces, where co-located is defined as running on a node
0000000000000000000000000000000000000000;;		// whose value of the label with key topologyKey matches that of any node on which any of the
0000000000000000000000000000000000000000;;		// selected pods is running.
0000000000000000000000000000000000000000;;		// For PreferredDuringScheduling pod anti-affinity, empty topologyKey is interpreted as "all topologies"
0000000000000000000000000000000000000000;;		// ("all topologies" here means all the topologyKeys indicated by scheduler command-line argument --failure-domains);
0000000000000000000000000000000000000000;;		// for affinity and for RequiredDuringScheduling pod anti-affinity, empty topologyKey is not allowed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TopologyKey string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node affinity is a group of node affinity scheduling rules.
0000000000000000000000000000000000000000;;	type NodeAffinity struct {
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to an update), the system
0000000000000000000000000000000000000000;;		// will try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// RequiredDuringSchedulingRequiredDuringExecution *NodeSelector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to an update), the system
0000000000000000000000000000000000000000;;		// may or may not try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequiredDuringSchedulingIgnoredDuringExecution *NodeSelector
0000000000000000000000000000000000000000;;		// The scheduler will prefer to schedule pods to nodes that satisfy
0000000000000000000000000000000000000000;;		// the affinity expressions specified by this field, but it may choose
0000000000000000000000000000000000000000;;		// a node that violates one or more of the expressions. The node that is
0000000000000000000000000000000000000000;;		// most preferred is the one with the greatest sum of weights, i.e.
0000000000000000000000000000000000000000;;		// for each node that meets all of the scheduling requirements (resource
0000000000000000000000000000000000000000;;		// request, requiredDuringScheduling affinity expressions, etc.),
0000000000000000000000000000000000000000;;		// compute a sum by iterating through the elements of this field and adding
0000000000000000000000000000000000000000;;		// "weight" to the sum if the node matches the corresponding matchExpressions; the
0000000000000000000000000000000000000000;;		// node(s) with the highest sum are the most preferred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferredDuringSchedulingIgnoredDuringExecution []PreferredSchedulingTerm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An empty preferred scheduling term matches all objects with implicit weight 0
0000000000000000000000000000000000000000;;	// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
0000000000000000000000000000000000000000;;	type PreferredSchedulingTerm struct {
0000000000000000000000000000000000000000;;		// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
0000000000000000000000000000000000000000;;		Weight int32
0000000000000000000000000000000000000000;;		// A node selector term, associated with the corresponding weight.
0000000000000000000000000000000000000000;;		Preference NodeSelectorTerm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The node this Taint is attached to has the effect "effect" on
0000000000000000000000000000000000000000;;	// any pod that that does not tolerate the Taint.
0000000000000000000000000000000000000000;;	type Taint struct {
0000000000000000000000000000000000000000;;		// Required. The taint key to be applied to a node.
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;		// Required. The taint value corresponding to the taint key.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;		// Required. The effect of the taint on pods
0000000000000000000000000000000000000000;;		// that do not tolerate the taint.
0000000000000000000000000000000000000000;;		// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
0000000000000000000000000000000000000000;;		Effect TaintEffect
0000000000000000000000000000000000000000;;		// TimeAdded represents the time at which the taint was added.
0000000000000000000000000000000000000000;;		// It is only written for NoExecute taints.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TimeAdded metav1.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TaintEffect string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Do not allow new pods to schedule onto the node unless they tolerate the taint,
0000000000000000000000000000000000000000;;		// but allow all pods submitted to Kubelet without going through the scheduler
0000000000000000000000000000000000000000;;		// to start, and allow all already-running pods to continue running.
0000000000000000000000000000000000000000;;		// Enforced by the scheduler.
0000000000000000000000000000000000000000;;		TaintEffectNoSchedule TaintEffect = "NoSchedule"
0000000000000000000000000000000000000000;;		// Like TaintEffectNoSchedule, but the scheduler tries not to schedule
0000000000000000000000000000000000000000;;		// new pods onto the node, rather than prohibiting new pods from scheduling
0000000000000000000000000000000000000000;;		// onto the node entirely. Enforced by the scheduler.
0000000000000000000000000000000000000000;;		TaintEffectPreferNoSchedule TaintEffect = "PreferNoSchedule"
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// Like TaintEffectNoSchedule, but additionally do not allow pods submitted to
0000000000000000000000000000000000000000;;		// Kubelet without going through the scheduler to start.
0000000000000000000000000000000000000000;;		// Enforced by Kubelet and the scheduler.
0000000000000000000000000000000000000000;;		// TaintEffectNoScheduleNoAdmit TaintEffect = "NoScheduleNoAdmit"
0000000000000000000000000000000000000000;;		// Evict any already-running pods that do not tolerate the taint.
0000000000000000000000000000000000000000;;		// Currently enforced by NodeController.
0000000000000000000000000000000000000000;;		TaintEffectNoExecute TaintEffect = "NoExecute"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The pod this Toleration is attached to tolerates any taint that matches
0000000000000000000000000000000000000000;;	// the triple <key,value,effect> using the matching operator <operator>.
0000000000000000000000000000000000000000;;	type Toleration struct {
0000000000000000000000000000000000000000;;		// Key is the taint key that the toleration applies to. Empty means match all taint keys.
0000000000000000000000000000000000000000;;		// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;		// Operator represents a key's relationship to the value.
0000000000000000000000000000000000000000;;		// Valid operators are Exists and Equal. Defaults to Equal.
0000000000000000000000000000000000000000;;		// Exists is equivalent to wildcard for value, so that a pod can
0000000000000000000000000000000000000000;;		// tolerate all taints of a particular category.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Operator TolerationOperator
0000000000000000000000000000000000000000;;		// Value is the taint value the toleration matches to.
0000000000000000000000000000000000000000;;		// If the operator is Exists, the value should be empty, otherwise just a regular string.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;		// Effect indicates the taint effect to match. Empty means match all taint effects.
0000000000000000000000000000000000000000;;		// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Effect TaintEffect
0000000000000000000000000000000000000000;;		// TolerationSeconds represents the period of time the toleration (which must be
0000000000000000000000000000000000000000;;		// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
0000000000000000000000000000000000000000;;		// it is not set, which means tolerate the taint forever (do not evict). Zero and
0000000000000000000000000000000000000000;;		// negative values will be treated as 0 (evict immediately) by the system.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TolerationSeconds *int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A toleration operator is the set of operators that can be used in a toleration.
0000000000000000000000000000000000000000;;	type TolerationOperator string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TolerationOpExists TolerationOperator = "Exists"
0000000000000000000000000000000000000000;;		TolerationOpEqual  TolerationOperator = "Equal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSpec is a description of a pod
0000000000000000000000000000000000000000;;	type PodSpec struct {
0000000000000000000000000000000000000000;;		Volumes []Volume
0000000000000000000000000000000000000000;;		// List of initialization containers belonging to the pod.
0000000000000000000000000000000000000000;;		InitContainers []Container
0000000000000000000000000000000000000000;;		// List of containers belonging to the pod.
0000000000000000000000000000000000000000;;		Containers []Container
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RestartPolicy RestartPolicy
0000000000000000000000000000000000000000;;		// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
0000000000000000000000000000000000000000;;		// Value must be non-negative integer. The value zero indicates delete immediately.
0000000000000000000000000000000000000000;;		// If this value is nil, the default grace period will be used instead.
0000000000000000000000000000000000000000;;		// The grace period is the duration in seconds after the processes running in the pod are sent
0000000000000000000000000000000000000000;;		// a termination signal and the time when the processes are forcibly halted with a kill signal.
0000000000000000000000000000000000000000;;		// Set this value longer than the expected cleanup time for your process.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TerminationGracePeriodSeconds *int64
0000000000000000000000000000000000000000;;		// Optional duration in seconds relative to the StartTime that the pod may be active on a node
0000000000000000000000000000000000000000;;		// before the system actively tries to terminate the pod; value must be positive integer
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ActiveDeadlineSeconds *int64
0000000000000000000000000000000000000000;;		// Required: Set DNS policy.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DNSPolicy DNSPolicy
0000000000000000000000000000000000000000;;		// NodeSelector is a selector which must be true for the pod to fit on a node
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeSelector map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceAccountName is the name of the ServiceAccount to use to run this pod
0000000000000000000000000000000000000000;;		// The pod will be allowed to use secrets referenced by the ServiceAccount
0000000000000000000000000000000000000000;;		ServiceAccountName string
0000000000000000000000000000000000000000;;		// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AutomountServiceAccountToken *bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NodeName is a request to schedule this pod onto a specific node.  If it is non-empty,
0000000000000000000000000000000000000000;;		// the scheduler simply schedules this pod onto that node, assuming that it fits resource
0000000000000000000000000000000000000000;;		// requirements.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeName string
0000000000000000000000000000000000000000;;		// SecurityContext holds pod-level security attributes and common container settings.
0000000000000000000000000000000000000000;;		// Optional: Defaults to empty.  See type description for default values of each field.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecurityContext *PodSecurityContext
0000000000000000000000000000000000000000;;		// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
0000000000000000000000000000000000000000;;		// If specified, these secrets will be passed to individual puller implementations for them to use.  For example,
0000000000000000000000000000000000000000;;		// in the case of docker, only DockerConfig type secrets are honored.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ImagePullSecrets []LocalObjectReference
0000000000000000000000000000000000000000;;		// Specifies the hostname of the Pod.
0000000000000000000000000000000000000000;;		// If not specified, the pod's hostname will be set to a system-defined value.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hostname string
0000000000000000000000000000000000000000;;		// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
0000000000000000000000000000000000000000;;		// If not specified, the pod will not have a domainname at all.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Subdomain string
0000000000000000000000000000000000000000;;		// If specified, the pod's scheduling constraints
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Affinity *Affinity
0000000000000000000000000000000000000000;;		// If specified, the pod will be dispatched by specified scheduler.
0000000000000000000000000000000000000000;;		// If not specified, the pod will be dispatched by default scheduler.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SchedulerName string
0000000000000000000000000000000000000000;;		// If specified, the pod's tolerations.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Tolerations []Toleration
0000000000000000000000000000000000000000;;		// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
0000000000000000000000000000000000000000;;		// file if specified. This is only valid for non-hostNetwork pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostAliases []HostAlias
0000000000000000000000000000000000000000;;		// If specified, indicates the pod's priority. "SYSTEM" is a special keyword
0000000000000000000000000000000000000000;;		// which indicates the highest priority. Any other name must be defined by
0000000000000000000000000000000000000000;;		// creating a PriorityClass object with that name.
0000000000000000000000000000000000000000;;		// If not specified, the pod priority will be default or zero if there is no
0000000000000000000000000000000000000000;;		// default.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PriorityClassName string
0000000000000000000000000000000000000000;;		// The priority value. Various system components use this field to find the
0000000000000000000000000000000000000000;;		// priority of the pod. When Priority Admission Controller is enabled, it
0000000000000000000000000000000000000000;;		// prevents users from setting this field. The admission controller populates
0000000000000000000000000000000000000000;;		// this field from PriorityClassName.
0000000000000000000000000000000000000000;;		// The higher the value, the higher the priority.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Priority *int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
0000000000000000000000000000000000000000;;	// pod's hosts file.
0000000000000000000000000000000000000000;;	type HostAlias struct {
0000000000000000000000000000000000000000;;		IP        string
0000000000000000000000000000000000000000;;		Hostnames []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sysctl defines a kernel parameter to be set
0000000000000000000000000000000000000000;;	type Sysctl struct {
0000000000000000000000000000000000000000;;		// Name of a property to set
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Value of a property to set
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSecurityContext holds pod-level security attributes and common container settings.
0000000000000000000000000000000000000000;;	// Some fields are also present in container.securityContext.  Field values of
0000000000000000000000000000000000000000;;	// container.securityContext take precedence over field values of PodSecurityContext.
0000000000000000000000000000000000000000;;	type PodSecurityContext struct {
0000000000000000000000000000000000000000;;		// Use the host's network namespace.  If this option is set, the ports that will be
0000000000000000000000000000000000000000;;		// used must be specified.
0000000000000000000000000000000000000000;;		// Optional: Default to false
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostNetwork bool
0000000000000000000000000000000000000000;;		// Use the host's pid namespace.
0000000000000000000000000000000000000000;;		// Optional: Default to false.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPID bool
0000000000000000000000000000000000000000;;		// Use the host's ipc namespace.
0000000000000000000000000000000000000000;;		// Optional: Default to false.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostIPC bool
0000000000000000000000000000000000000000;;		// The SELinux context to be applied to all containers.
0000000000000000000000000000000000000000;;		// If unspecified, the container runtime will allocate a random SELinux context for each
0000000000000000000000000000000000000000;;		// container.  May also be set in SecurityContext.  If set in
0000000000000000000000000000000000000000;;		// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
0000000000000000000000000000000000000000;;		// takes precedence for that container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SELinuxOptions *SELinuxOptions
0000000000000000000000000000000000000000;;		// The UID to run the entrypoint of the container process.
0000000000000000000000000000000000000000;;		// Defaults to user specified in image metadata if unspecified.
0000000000000000000000000000000000000000;;		// May also be set in SecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence
0000000000000000000000000000000000000000;;		// for that container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsUser *int64
0000000000000000000000000000000000000000;;		// Indicates that the container must run as a non-root user.
0000000000000000000000000000000000000000;;		// If true, the Kubelet will validate the image at runtime to ensure that it
0000000000000000000000000000000000000000;;		// does not run as UID 0 (root) and fail to start the container if it does.
0000000000000000000000000000000000000000;;		// If unset or false, no such validation will be performed.
0000000000000000000000000000000000000000;;		// May also be set in SecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsNonRoot *bool
0000000000000000000000000000000000000000;;		// A list of groups applied to the first process run in each container, in addition
0000000000000000000000000000000000000000;;		// to the container's primary GID.  If unspecified, no groups will be added to
0000000000000000000000000000000000000000;;		// any container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SupplementalGroups []int64
0000000000000000000000000000000000000000;;		// A special supplemental group that applies to all containers in a pod.
0000000000000000000000000000000000000000;;		// Some volume types allow the Kubelet to change the ownership of that volume
0000000000000000000000000000000000000000;;		// to be owned by the pod:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 1. The owning GID will be the FSGroup
0000000000000000000000000000000000000000;;		// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
0000000000000000000000000000000000000000;;		// 3. The permission bits are OR'd with rw-rw----
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If unset, the Kubelet will not modify the ownership and permissions of any volume.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSGroup *int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodQOSClass defines the supported qos classes of Pods.
0000000000000000000000000000000000000000;;	type PodQOSClass string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PodQOSGuaranteed is the Guaranteed qos class.
0000000000000000000000000000000000000000;;		PodQOSGuaranteed PodQOSClass = "Guaranteed"
0000000000000000000000000000000000000000;;		// PodQOSBurstable is the Burstable qos class.
0000000000000000000000000000000000000000;;		PodQOSBurstable PodQOSClass = "Burstable"
0000000000000000000000000000000000000000;;		// PodQOSBestEffort is the BestEffort qos class.
0000000000000000000000000000000000000000;;		PodQOSBestEffort PodQOSClass = "BestEffort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodStatus represents information about the status of a pod. Status may trail the actual
0000000000000000000000000000000000000000;;	// state of a system.
0000000000000000000000000000000000000000;;	type PodStatus struct {
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase PodPhase
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Conditions []PodCondition
0000000000000000000000000000000000000000;;		// A human readable message indicating details about why the pod is in this state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;		// A brief CamelCase message indicating details about why the pod is in this state. e.g. 'OutOfDisk'
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostIP string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodIP string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Date and time at which the object was acknowledged by the Kubelet.
0000000000000000000000000000000000000000;;		// This is before the Kubelet pulled the container image(s) for the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StartTime *metav1.Time
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		QOSClass PodQOSClass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The list has one entry per init container in the manifest. The most recent successful
0000000000000000000000000000000000000000;;		// init container will have ready = true, the most recently started container will have
0000000000000000000000000000000000000000;;		// startTime set.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-and-container-status
0000000000000000000000000000000000000000;;		InitContainerStatuses []ContainerStatus
0000000000000000000000000000000000000000;;		// The list has one entry per container in the manifest. Each entry is
0000000000000000000000000000000000000000;;		// currently the output of `docker inspect`. This output format is *not*
0000000000000000000000000000000000000000;;		// final and should not be relied upon.
0000000000000000000000000000000000000000;;		// TODO: Make real decisions about what our info should look like. Re-enable fuzz test
0000000000000000000000000000000000000000;;		// when we have done this.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerStatuses []ContainerStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
0000000000000000000000000000000000000000;;	type PodStatusResult struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;		// Status represents the current information about a pod. This data may not be up
0000000000000000000000000000000000000000;;		// to date.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PodStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod is a collection of containers, used as either input (create, update) or as output (list, get).
0000000000000000000000000000000000000000;;	type Pod struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of a pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PodSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status represents the current information about a pod. This data may not be up
0000000000000000000000000000000000000000;;		// to date.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PodStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodTemplateSpec describes the data a pod should have when created from a template
0000000000000000000000000000000000000000;;	type PodTemplateSpec struct {
0000000000000000000000000000000000000000;;		// Metadata of the pods created from this template.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of a pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PodSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodTemplate describes a template for creating copies of a predefined pod.
0000000000000000000000000000000000000000;;	type PodTemplate struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Template defines the pods that will be created from this pod template
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Template PodTemplateSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodTemplateList is a list of PodTemplates.
0000000000000000000000000000000000000000;;	type PodTemplateList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []PodTemplate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerSpec is the specification of a replication controller.
0000000000000000000000000000000000000000;;	// As the internal representation of a replication controller, it may have either
0000000000000000000000000000000000000000;;	// a TemplateRef or a Template set.
0000000000000000000000000000000000000000;;	type ReplicationControllerSpec struct {
0000000000000000000000000000000000000000;;		// Replicas is the number of desired replicas.
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum number of seconds for which a newly created pod should be ready
0000000000000000000000000000000000000000;;		// without any of its container crashing, for it to be considered available.
0000000000000000000000000000000000000000;;		// Defaults to 0 (pod will be considered available as soon as it is ready)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MinReadySeconds int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Selector is a label query over pods that should match the Replicas count.
0000000000000000000000000000000000000000;;		Selector map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TemplateRef is a reference to an object that describes the pod that will be created if
0000000000000000000000000000000000000000;;		// insufficient replicas are detected. This reference is ignored if a Template is set.
0000000000000000000000000000000000000000;;		// Must be set before converting to a versioned API object
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		//TemplateRef *ObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Template is the object that describes the pod that will be created if
0000000000000000000000000000000000000000;;		// insufficient replicas are detected. Internally, this takes precedence over a
0000000000000000000000000000000000000000;;		// TemplateRef.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Template *PodTemplateSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerStatus represents the current status of a replication
0000000000000000000000000000000000000000;;	// controller.
0000000000000000000000000000000000000000;;	type ReplicationControllerStatus struct {
0000000000000000000000000000000000000000;;		// Replicas is the number of actual replicas.
0000000000000000000000000000000000000000;;		Replicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of pods that have labels matching the labels of the pod template of the replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FullyLabeledReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of ready replicas for this replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadyReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of available replicas (ready for at least minReadySeconds) for this replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AvailableReplicas int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ObservedGeneration is the most recent generation observed by the controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObservedGeneration int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Represents the latest available observations of a replication controller's current state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Conditions []ReplicationControllerCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReplicationControllerConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of a replication controller.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ReplicationControllerReplicaFailure is added in a replication controller when one of its pods
0000000000000000000000000000000000000000;;		// fails to be created due to insufficient quota, limit ranges, pod security policy, node selectors,
0000000000000000000000000000000000000000;;		// etc. or deleted due to kubelet being down or finalizers are failing.
0000000000000000000000000000000000000000;;		ReplicationControllerReplicaFailure ReplicationControllerConditionType = "ReplicaFailure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerCondition describes the state of a replication controller at a certain point.
0000000000000000000000000000000000000000;;	type ReplicationControllerCondition struct {
0000000000000000000000000000000000000000;;		// Type of replication controller condition.
0000000000000000000000000000000000000000;;		Type ReplicationControllerConditionType
0000000000000000000000000000000000000000;;		// Status of the condition, one of True, False, Unknown.
0000000000000000000000000000000000000000;;		Status ConditionStatus
0000000000000000000000000000000000000000;;		// The last time the condition transitioned from one status to another.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time
0000000000000000000000000000000000000000;;		// The reason for the condition's last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// A human readable message indicating details about the transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationController represents the configuration of a replication controller.
0000000000000000000000000000000000000000;;	type ReplicationController struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the desired behavior of this replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ReplicationControllerSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status is the current status of this replication controller. This data may be
0000000000000000000000000000000000000000;;		// out of date by some window of time.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ReplicationControllerStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerList is a collection of replication controllers.
0000000000000000000000000000000000000000;;	type ReplicationControllerList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []ReplicationController
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ClusterIPNone - do not assign a cluster IP
0000000000000000000000000000000000000000;;		// no proxying required and no environment variables should be created for pods
0000000000000000000000000000000000000000;;		ClusterIPNone = "None"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceList holds a list of services.
0000000000000000000000000000000000000000;;	type ServiceList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Session Affinity Type string
0000000000000000000000000000000000000000;;	type ServiceAffinity string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ServiceAffinityClientIP is the Client IP based.
0000000000000000000000000000000000000000;;		ServiceAffinityClientIP ServiceAffinity = "ClientIP"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceAffinityNone - no session affinity.
0000000000000000000000000000000000000000;;		ServiceAffinityNone ServiceAffinity = "None"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service Type string describes ingress methods for a service
0000000000000000000000000000000000000000;;	type ServiceType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ServiceTypeClusterIP means a service will only be accessible inside the
0000000000000000000000000000000000000000;;		// cluster, via the ClusterIP.
0000000000000000000000000000000000000000;;		ServiceTypeClusterIP ServiceType = "ClusterIP"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceTypeNodePort means a service will be exposed on one port of
0000000000000000000000000000000000000000;;		// every node, in addition to 'ClusterIP' type.
0000000000000000000000000000000000000000;;		ServiceTypeNodePort ServiceType = "NodePort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceTypeLoadBalancer means a service will be exposed via an
0000000000000000000000000000000000000000;;		// external load balancer (if the cloud provider supports it), in addition
0000000000000000000000000000000000000000;;		// to 'NodePort' type.
0000000000000000000000000000000000000000;;		ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceTypeExternalName means a service consists of only a reference to
0000000000000000000000000000000000000000;;		// an external name that kubedns or equivalent will return as a CNAME
0000000000000000000000000000000000000000;;		// record, with no exposing or proxying of any pods involved.
0000000000000000000000000000000000000000;;		ServiceTypeExternalName ServiceType = "ExternalName"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service External Traffic Policy Type string
0000000000000000000000000000000000000000;;	type ServiceExternalTrafficPolicyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ServiceExternalTrafficPolicyTypeLocal specifies node-local endpoints behavior.
0000000000000000000000000000000000000000;;		ServiceExternalTrafficPolicyTypeLocal ServiceExternalTrafficPolicyType = "Local"
0000000000000000000000000000000000000000;;		// ServiceExternalTrafficPolicyTypeCluster specifies cluster-wide (legacy) behavior.
0000000000000000000000000000000000000000;;		ServiceExternalTrafficPolicyTypeCluster ServiceExternalTrafficPolicyType = "Cluster"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceStatus represents the current status of a service
0000000000000000000000000000000000000000;;	type ServiceStatus struct {
0000000000000000000000000000000000000000;;		// LoadBalancer contains the current status of the load-balancer,
0000000000000000000000000000000000000000;;		// if one is present.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LoadBalancer LoadBalancerStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancerStatus represents the status of a load-balancer
0000000000000000000000000000000000000000;;	type LoadBalancerStatus struct {
0000000000000000000000000000000000000000;;		// Ingress is a list containing ingress points for the load-balancer;
0000000000000000000000000000000000000000;;		// traffic intended for the service should be sent to these ingress points.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ingress []LoadBalancerIngress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancerIngress represents the status of a load-balancer ingress point:
0000000000000000000000000000000000000000;;	// traffic intended for the service should be sent to an ingress point.
0000000000000000000000000000000000000000;;	type LoadBalancerIngress struct {
0000000000000000000000000000000000000000;;		// IP is set for load-balancer ingress points that are IP based
0000000000000000000000000000000000000000;;		// (typically GCE or OpenStack load-balancers)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		IP string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hostname is set for load-balancer ingress points that are DNS based
0000000000000000000000000000000000000000;;		// (typically AWS load-balancers)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hostname string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceSpec describes the attributes that a user creates on a service
0000000000000000000000000000000000000000;;	type ServiceSpec struct {
0000000000000000000000000000000000000000;;		// Type determines how the Service is exposed. Defaults to ClusterIP. Valid
0000000000000000000000000000000000000000;;		// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
0000000000000000000000000000000000000000;;		// "ExternalName" maps to the specified externalName.
0000000000000000000000000000000000000000;;		// "ClusterIP" allocates a cluster-internal IP address for load-balancing to
0000000000000000000000000000000000000000;;		// endpoints. Endpoints are determined by the selector or if that is not
0000000000000000000000000000000000000000;;		// specified, by manual construction of an Endpoints object. If clusterIP is
0000000000000000000000000000000000000000;;		// "None", no virtual IP is allocated and the endpoints are published as a
0000000000000000000000000000000000000000;;		// set of endpoints rather than a stable IP.
0000000000000000000000000000000000000000;;		// "NodePort" builds on ClusterIP and allocates a port on every node which
0000000000000000000000000000000000000000;;		// routes to the clusterIP.
0000000000000000000000000000000000000000;;		// "LoadBalancer" builds on NodePort and creates an
0000000000000000000000000000000000000000;;		// external load-balancer (if supported in the current cloud) which routes
0000000000000000000000000000000000000000;;		// to the clusterIP.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type ServiceType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Required: The list of ports that are exposed by this service.
0000000000000000000000000000000000000000;;		Ports []ServicePort
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Route service traffic to pods with label keys and values matching this
0000000000000000000000000000000000000000;;		// selector. If empty or not present, the service is assumed to have an
0000000000000000000000000000000000000000;;		// external process managing its endpoints, which Kubernetes will not
0000000000000000000000000000000000000000;;		// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
0000000000000000000000000000000000000000;;		// Ignored if type is ExternalName.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/
0000000000000000000000000000000000000000;;		Selector map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClusterIP is the IP address of the service and is usually assigned
0000000000000000000000000000000000000000;;		// randomly by the master. If an address is specified manually and is not in
0000000000000000000000000000000000000000;;		// use by others, it will be allocated to the service; otherwise, creation
0000000000000000000000000000000000000000;;		// of the service will fail. This field can not be changed through updates.
0000000000000000000000000000000000000000;;		// Valid values are "None", empty string (""), or a valid IP address. "None"
0000000000000000000000000000000000000000;;		// can be specified for headless services when proxying is not required.
0000000000000000000000000000000000000000;;		// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
0000000000000000000000000000000000000000;;		// type is ExternalName.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ClusterIP string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExternalName is the external reference that kubedns or equivalent will
0000000000000000000000000000000000000000;;		// return as a CNAME record for this service. No proxying will be involved.
0000000000000000000000000000000000000000;;		// Must be a valid DNS name and requires Type to be ExternalName.
0000000000000000000000000000000000000000;;		ExternalName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExternalIPs are used by external load balancers, or can be set by
0000000000000000000000000000000000000000;;		// users to handle external traffic that arrives at a node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ExternalIPs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only applies to Service Type: LoadBalancer
0000000000000000000000000000000000000000;;		// LoadBalancer will get created with the IP specified in this field.
0000000000000000000000000000000000000000;;		// This feature depends on whether the underlying cloud-provider supports specifying
0000000000000000000000000000000000000000;;		// the loadBalancerIP when a load balancer is created.
0000000000000000000000000000000000000000;;		// This field will be ignored if the cloud-provider does not support the feature.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LoadBalancerIP string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional: Supports "ClientIP" and "None".  Used to maintain session affinity.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SessionAffinity ServiceAffinity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional: If specified and supported by the platform, this will restrict traffic through the cloud-provider
0000000000000000000000000000000000000000;;		// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
0000000000000000000000000000000000000000;;		// cloud-provider does not support the feature."
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LoadBalancerSourceRanges []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// externalTrafficPolicy denotes if this Service desires to route external
0000000000000000000000000000000000000000;;		// traffic to node-local or cluster-wide endpoints. "Local" preserves the
0000000000000000000000000000000000000000;;		// client source IP and avoids a second hop for LoadBalancer and Nodeport
0000000000000000000000000000000000000000;;		// type services, but risks potentially imbalanced traffic spreading.
0000000000000000000000000000000000000000;;		// "Cluster" obscures the client source IP and may cause a second hop to
0000000000000000000000000000000000000000;;		// another node, but should have good overall load-spreading.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ExternalTrafficPolicy ServiceExternalTrafficPolicyType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// healthCheckNodePort specifies the healthcheck nodePort for the service.
0000000000000000000000000000000000000000;;		// If not specified, HealthCheckNodePort is created by the service api
0000000000000000000000000000000000000000;;		// backend with the allocated nodePort. Will use user-specified nodePort value
0000000000000000000000000000000000000000;;		// if specified by the client. Only effects when Type is set to LoadBalancer
0000000000000000000000000000000000000000;;		// and ExternalTrafficPolicy is set to Local.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HealthCheckNodePort int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ServicePort struct {
0000000000000000000000000000000000000000;;		// Optional if only one ServicePort is defined on this service: The
0000000000000000000000000000000000000000;;		// name of this port within the service.  This must be a DNS_LABEL.
0000000000000000000000000000000000000000;;		// All ports within a ServiceSpec must have unique names.  This maps to
0000000000000000000000000000000000000000;;		// the 'Name' field in EndpointPort objects.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The IP protocol for this port.  Supports "TCP" and "UDP".
0000000000000000000000000000000000000000;;		Protocol Protocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The port that will be exposed on the service.
0000000000000000000000000000000000000000;;		Port int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional: The target port on pods selected by this service.  If this
0000000000000000000000000000000000000000;;		// is a string, it will be looked up as a named port in the target
0000000000000000000000000000000000000000;;		// Pod's container ports.  If this is not specified, the value
0000000000000000000000000000000000000000;;		// of the 'port' field is used (an identity map).
0000000000000000000000000000000000000000;;		// This field is ignored for services with clusterIP=None, and should be
0000000000000000000000000000000000000000;;		// omitted or set equal to the 'port' field.
0000000000000000000000000000000000000000;;		TargetPort intstr.IntOrString
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The port on each node on which this service is exposed.
0000000000000000000000000000000000000000;;		// Default is to auto-allocate a port if the ServiceType of this Service requires one.
0000000000000000000000000000000000000000;;		NodePort int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service is a named abstraction of software service (for example, mysql) consisting of local port
0000000000000000000000000000000000000000;;	// (for example 3306) that the proxy listens on, and the selector that determines which pods
0000000000000000000000000000000000000000;;	// will answer requests sent through the proxy.
0000000000000000000000000000000000000000;;	type Service struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of a service.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ServiceSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status represents the current status of a service.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ServiceStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccount binds together:
0000000000000000000000000000000000000000;;	// * a name, understood by users, and perhaps by peripheral systems, for an identity
0000000000000000000000000000000000000000;;	// * a principal that can be authenticated and authorized
0000000000000000000000000000000000000000;;	// * a set of secrets
0000000000000000000000000000000000000000;;	type ServiceAccount struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount
0000000000000000000000000000000000000000;;		Secrets []ObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
0000000000000000000000000000000000000000;;		// in pods that reference this ServiceAccount.  ImagePullSecrets are distinct from Secrets because Secrets
0000000000000000000000000000000000000000;;		// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ImagePullSecrets []LocalObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
0000000000000000000000000000000000000000;;		// Can be overridden at the pod level.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AutomountServiceAccountToken *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountList is a list of ServiceAccount objects
0000000000000000000000000000000000000000;;	type ServiceAccountList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []ServiceAccount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoints is a collection of endpoints that implement the actual service.  Example:
0000000000000000000000000000000000000000;;	//   Name: "mysvc",
0000000000000000000000000000000000000000;;	//   Subsets: [
0000000000000000000000000000000000000000;;	//     {
0000000000000000000000000000000000000000;;	//       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
0000000000000000000000000000000000000000;;	//       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
0000000000000000000000000000000000000000;;	//     },
0000000000000000000000000000000000000000;;	//     {
0000000000000000000000000000000000000000;;	//       Addresses: [{"ip": "10.10.3.3"}],
0000000000000000000000000000000000000000;;	//       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
0000000000000000000000000000000000000000;;	//     },
0000000000000000000000000000000000000000;;	//  ]
0000000000000000000000000000000000000000;;	type Endpoints struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The set of all endpoints is the union of all subsets.
0000000000000000000000000000000000000000;;		Subsets []EndpointSubset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointSubset is a group of addresses with a common set of ports.  The
0000000000000000000000000000000000000000;;	// expanded set of endpoints is the Cartesian product of Addresses x Ports.
0000000000000000000000000000000000000000;;	// For example, given:
0000000000000000000000000000000000000000;;	//   {
0000000000000000000000000000000000000000;;	//     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
0000000000000000000000000000000000000000;;	//     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	// The resulting set of endpoints can be viewed as:
0000000000000000000000000000000000000000;;	//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
0000000000000000000000000000000000000000;;	//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
0000000000000000000000000000000000000000;;	type EndpointSubset struct {
0000000000000000000000000000000000000000;;		Addresses         []EndpointAddress
0000000000000000000000000000000000000000;;		NotReadyAddresses []EndpointAddress
0000000000000000000000000000000000000000;;		Ports             []EndpointPort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointAddress is a tuple that describes single IP address.
0000000000000000000000000000000000000000;;	type EndpointAddress struct {
0000000000000000000000000000000000000000;;		// The IP of this endpoint.
0000000000000000000000000000000000000000;;		// IPv6 is also accepted but not fully supported on all platforms. Also, certain
0000000000000000000000000000000000000000;;		// kubernetes components, like kube-proxy, are not IPv6 ready.
0000000000000000000000000000000000000000;;		// TODO: This should allow hostname or IP, see #4447.
0000000000000000000000000000000000000000;;		IP string
0000000000000000000000000000000000000000;;		// Optional: Hostname of this endpoint
0000000000000000000000000000000000000000;;		// Meant to be used by DNS servers etc.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hostname string
0000000000000000000000000000000000000000;;		// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeName *string
0000000000000000000000000000000000000000;;		// Optional: The kubernetes object related to the entry point.
0000000000000000000000000000000000000000;;		TargetRef *ObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointPort is a tuple that describes a single port.
0000000000000000000000000000000000000000;;	type EndpointPort struct {
0000000000000000000000000000000000000000;;		// The name of this port (corresponds to ServicePort.Name).  Optional
0000000000000000000000000000000000000000;;		// if only one port is defined.  Must be a DNS_LABEL.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The port number.
0000000000000000000000000000000000000000;;		Port int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The IP protocol for this port.
0000000000000000000000000000000000000000;;		Protocol Protocol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointsList is a list of endpoints.
0000000000000000000000000000000000000000;;	type EndpointsList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Endpoints
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeSpec describes the attributes that a node is created with.
0000000000000000000000000000000000000000;;	type NodeSpec struct {
0000000000000000000000000000000000000000;;		// PodCIDR represents the pod IP range assigned to the node
0000000000000000000000000000000000000000;;		// Note: assigning IP ranges to nodes might need to be revisited when we support migratable IPs.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodCIDR string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// External ID of the node assigned by some machine database (e.g. a cloud provider)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ExternalID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ID of the node assigned by the cloud provider
0000000000000000000000000000000000000000;;		// Note: format is "<ProviderName>://<ProviderSpecificNodeID>"
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ProviderID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unschedulable controls node schedulability of new pods. By default node is schedulable.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Unschedulable bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If specified, the node's taints.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Taints []Taint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DaemonEndpoint contains information about a single Daemon endpoint.
0000000000000000000000000000000000000000;;	type DaemonEndpoint struct {
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			The port tag was not properly in quotes in earlier releases, so it must be
0000000000000000000000000000000000000000;;			uppercased for backwards compat (since it was falling back to var name of
0000000000000000000000000000000000000000;;			'Port').
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Port number of the given endpoint.
0000000000000000000000000000000000000000;;		Port int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
0000000000000000000000000000000000000000;;	type NodeDaemonEndpoints struct {
0000000000000000000000000000000000000000;;		// Endpoint on which Kubelet is listening.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		KubeletEndpoint DaemonEndpoint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
0000000000000000000000000000000000000000;;	type NodeSystemInfo struct {
0000000000000000000000000000000000000000;;		// MachineID reported by the node. For unique machine identification
0000000000000000000000000000000000000000;;		// in the cluster this field is preferred. Learn more from man(5)
0000000000000000000000000000000000000000;;		// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
0000000000000000000000000000000000000000;;		MachineID string
0000000000000000000000000000000000000000;;		// SystemUUID reported by the node. For unique machine identification
0000000000000000000000000000000000000000;;		// MachineID is preferred. This field is specific to Red Hat hosts
0000000000000000000000000000000000000000;;		// https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
0000000000000000000000000000000000000000;;		SystemUUID string
0000000000000000000000000000000000000000;;		// Boot ID reported by the node.
0000000000000000000000000000000000000000;;		BootID string
0000000000000000000000000000000000000000;;		// Kernel Version reported by the node.
0000000000000000000000000000000000000000;;		KernelVersion string
0000000000000000000000000000000000000000;;		// OS Image reported by the node.
0000000000000000000000000000000000000000;;		OSImage string
0000000000000000000000000000000000000000;;		// ContainerRuntime Version reported by the node.
0000000000000000000000000000000000000000;;		ContainerRuntimeVersion string
0000000000000000000000000000000000000000;;		// Kubelet Version reported by the node.
0000000000000000000000000000000000000000;;		KubeletVersion string
0000000000000000000000000000000000000000;;		// KubeProxy Version reported by the node.
0000000000000000000000000000000000000000;;		KubeProxyVersion string
0000000000000000000000000000000000000000;;		// The Operating System reported by the node
0000000000000000000000000000000000000000;;		OperatingSystem string
0000000000000000000000000000000000000000;;		// The Architecture reported by the node
0000000000000000000000000000000000000000;;		Architecture string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeStatus is information about the current status of a node.
0000000000000000000000000000000000000000;;	type NodeStatus struct {
0000000000000000000000000000000000000000;;		// Capacity represents the total resources of a node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capacity ResourceList
0000000000000000000000000000000000000000;;		// Allocatable represents the resources of a node that are available for scheduling.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Allocatable ResourceList
0000000000000000000000000000000000000000;;		// NodePhase is the current lifecycle phase of the node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase NodePhase
0000000000000000000000000000000000000000;;		// Conditions is an array of current node conditions.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Conditions []NodeCondition
0000000000000000000000000000000000000000;;		// Queried from cloud provider, if available.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Addresses []NodeAddress
0000000000000000000000000000000000000000;;		// Endpoints of daemons running on the Node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DaemonEndpoints NodeDaemonEndpoints
0000000000000000000000000000000000000000;;		// Set of ids/uuids to uniquely identify the node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeInfo NodeSystemInfo
0000000000000000000000000000000000000000;;		// List of container images on this node
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Images []ContainerImage
0000000000000000000000000000000000000000;;		// List of attachable volumes in use (mounted) by the node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumesInUse []UniqueVolumeName
0000000000000000000000000000000000000000;;		// List of volumes that are attached to the node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumesAttached []AttachedVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UniqueVolumeName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachedVolume describes a volume attached to a node
0000000000000000000000000000000000000000;;	type AttachedVolume struct {
0000000000000000000000000000000000000000;;		// Name of the attached volume
0000000000000000000000000000000000000000;;		Name UniqueVolumeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DevicePath represents the device path where the volume should be available
0000000000000000000000000000000000000000;;		DevicePath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AvoidPods describes pods that should avoid this node. This is the value for a
0000000000000000000000000000000000000000;;	// Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
0000000000000000000000000000000000000000;;	// will eventually become a field of NodeStatus.
0000000000000000000000000000000000000000;;	type AvoidPods struct {
0000000000000000000000000000000000000000;;		// Bounded-sized list of signatures of pods that should avoid this node, sorted
0000000000000000000000000000000000000000;;		// in timestamp order from oldest to newest. Size of the slice is unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferAvoidPods []PreferAvoidPodsEntry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describes a class of pods that should avoid this node.
0000000000000000000000000000000000000000;;	type PreferAvoidPodsEntry struct {
0000000000000000000000000000000000000000;;		// The class of pods.
0000000000000000000000000000000000000000;;		PodSignature PodSignature
0000000000000000000000000000000000000000;;		// Time at which this entry was added to the list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		EvictionTime metav1.Time
0000000000000000000000000000000000000000;;		// (brief) reason why this entry was added to the list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// Human readable message indicating why this entry was added to the list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describes the class of pods that should avoid this node.
0000000000000000000000000000000000000000;;	// Exactly one field should be set.
0000000000000000000000000000000000000000;;	type PodSignature struct {
0000000000000000000000000000000000000000;;		// Reference to controller whose pods should avoid this node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodController *metav1.OwnerReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describe a container image
0000000000000000000000000000000000000000;;	type ContainerImage struct {
0000000000000000000000000000000000000000;;		// Names by which this image is known.
0000000000000000000000000000000000000000;;		Names []string
0000000000000000000000000000000000000000;;		// The size of the image in bytes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SizeBytes int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodePhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid phases of node.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NodePending means the node has been created/added by the system, but not configured.
0000000000000000000000000000000000000000;;		NodePending NodePhase = "Pending"
0000000000000000000000000000000000000000;;		// NodeRunning means the node has been configured and has Kubernetes components running.
0000000000000000000000000000000000000000;;		NodeRunning NodePhase = "Running"
0000000000000000000000000000000000000000;;		// NodeTerminated means the node has been removed from the cluster.
0000000000000000000000000000000000000000;;		NodeTerminated NodePhase = "Terminated"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of node. Currently, we don't have enough information to decide
0000000000000000000000000000000000000000;;	// node condition. In the future, we will add more. The proposed set of conditions are:
0000000000000000000000000000000000000000;;	// NodeReady, NodeReachable
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NodeReady means kubelet is healthy and ready to accept pods.
0000000000000000000000000000000000000000;;		NodeReady NodeConditionType = "Ready"
0000000000000000000000000000000000000000;;		// NodeOutOfDisk means the kubelet will not accept new pods due to insufficient free disk
0000000000000000000000000000000000000000;;		// space on the node.
0000000000000000000000000000000000000000;;		NodeOutOfDisk NodeConditionType = "OutOfDisk"
0000000000000000000000000000000000000000;;		// NodeMemoryPressure means the kubelet is under pressure due to insufficient available memory.
0000000000000000000000000000000000000000;;		NodeMemoryPressure NodeConditionType = "MemoryPressure"
0000000000000000000000000000000000000000;;		// NodeDiskPressure means the kubelet is under pressure due to insufficient available disk.
0000000000000000000000000000000000000000;;		NodeDiskPressure NodeConditionType = "DiskPressure"
0000000000000000000000000000000000000000;;		// NodeNetworkUnavailable means that network for the node is not correctly configured.
0000000000000000000000000000000000000000;;		NodeNetworkUnavailable NodeConditionType = "NetworkUnavailable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeCondition struct {
0000000000000000000000000000000000000000;;		Type   NodeConditionType
0000000000000000000000000000000000000000;;		Status ConditionStatus
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastHeartbeatTime metav1.Time
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeAddressType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NodeHostName    NodeAddressType = "Hostname"
0000000000000000000000000000000000000000;;		NodeExternalIP  NodeAddressType = "ExternalIP"
0000000000000000000000000000000000000000;;		NodeInternalIP  NodeAddressType = "InternalIP"
0000000000000000000000000000000000000000;;		NodeExternalDNS NodeAddressType = "ExternalDNS"
0000000000000000000000000000000000000000;;		NodeInternalDNS NodeAddressType = "InternalDNS"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeAddress struct {
0000000000000000000000000000000000000000;;		Type    NodeAddressType
0000000000000000000000000000000000000000;;		Address string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeResources is an object for conveying resource information about a node.
0000000000000000000000000000000000000000;;	// see http://releases.k8s.io/HEAD/docs/design/resources.md for more details.
0000000000000000000000000000000000000000;;	type NodeResources struct {
0000000000000000000000000000000000000000;;		// Capacity represents the available resources of a node
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capacity ResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceName is the name identifying various resources in a ResourceList.
0000000000000000000000000000000000000000;;	type ResourceName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resource names must be not more than 63 characters, consisting of upper- or lower-case alphanumeric characters,
0000000000000000000000000000000000000000;;	// with the -, _, and . characters allowed anywhere, except the first or last character.
0000000000000000000000000000000000000000;;	// The default convention, matching that for annotations, is to use lower-case names, with dashes, rather than
0000000000000000000000000000000000000000;;	// camel case, separating compound words.
0000000000000000000000000000000000000000;;	// Fully-qualified resource typenames are constructed from a DNS-style subdomain, followed by a slash `/` and a name.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// CPU, in cores. (500m = .5 cores)
0000000000000000000000000000000000000000;;		ResourceCPU ResourceName = "cpu"
0000000000000000000000000000000000000000;;		// Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceMemory ResourceName = "memory"
0000000000000000000000000000000000000000;;		// Volume size, in bytes (e,g. 5Gi = 5GiB = 5 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceStorage ResourceName = "storage"
0000000000000000000000000000000000000000;;		// Local Storage for overlay filesystem, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		// The resource name for ResourceStorageOverlay is alpha and it can change across releases.
0000000000000000000000000000000000000000;;		ResourceStorageOverlay ResourceName = "storage.kubernetes.io/overlay"
0000000000000000000000000000000000000000;;		// Local Storage for scratch space, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		// The resource name for ResourceStorageScratch is alpha and it can change across releases.
0000000000000000000000000000000000000000;;		ResourceStorageScratch ResourceName = "storage.kubernetes.io/scratch"
0000000000000000000000000000000000000000;;		// NVIDIA GPU, in devices. Alpha, might change: although fractional and allowing values >1, only one whole device per node is assigned.
0000000000000000000000000000000000000000;;		ResourceNvidiaGPU ResourceName = "alpha.kubernetes.io/nvidia-gpu"
0000000000000000000000000000000000000000;;		// Number of Pods that may be running on this Node: see ResourcePods
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Namespace prefix for opaque counted resources (alpha).
0000000000000000000000000000000000000000;;		ResourceOpaqueIntPrefix = "pod.alpha.kubernetes.io/opaque-int-resource-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceList is a set of (resource name, quantity) pairs.
0000000000000000000000000000000000000000;;	type ResourceList map[ResourceName]resource.Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node is a worker node in Kubernetes
0000000000000000000000000000000000000000;;	// The name of the node according to etcd is in ObjectMeta.Name.
0000000000000000000000000000000000000000;;	type Node struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of a node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec NodeSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status describes the current status of a Node
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status NodeStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeList is a list of nodes.
0000000000000000000000000000000000000000;;	type NodeList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceSpec describes the attributes on a Namespace
0000000000000000000000000000000000000000;;	type NamespaceSpec struct {
0000000000000000000000000000000000000000;;		// Finalizers is an opaque list of values that must be empty to permanently remove object from storage
0000000000000000000000000000000000000000;;		Finalizers []FinalizerName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FinalizerName is the name identifying a finalizer during namespace lifecycle.
0000000000000000000000000000000000000000;;	type FinalizerName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are internal finalizer values to Kubernetes, must be qualified name unless defined here or
0000000000000000000000000000000000000000;;	// in metav1.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FinalizerKubernetes FinalizerName = "kubernetes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceStatus is information about the current status of a Namespace.
0000000000000000000000000000000000000000;;	type NamespaceStatus struct {
0000000000000000000000000000000000000000;;		// Phase is the current lifecycle phase of the namespace.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase NamespacePhase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamespacePhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid phases of a namespace.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NamespaceActive means the namespace is available for use in the system
0000000000000000000000000000000000000000;;		NamespaceActive NamespacePhase = "Active"
0000000000000000000000000000000000000000;;		// NamespaceTerminating means the namespace is undergoing graceful termination
0000000000000000000000000000000000000000;;		NamespaceTerminating NamespacePhase = "Terminating"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A namespace provides a scope for Names.
0000000000000000000000000000000000000000;;	// Use of multiple namespaces is optional
0000000000000000000000000000000000000000;;	type Namespace struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of the Namespace.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec NamespaceSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status describes the current status of a Namespace
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status NamespaceStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceList is a list of Namespaces.
0000000000000000000000000000000000000000;;	type NamespaceList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Namespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
0000000000000000000000000000000000000000;;	// Deprecated in 1.7, please use the bindings subresource of pods instead.
0000000000000000000000000000000000000000;;	type Binding struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// ObjectMeta describes the object that is being bound.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Target is the object to bind to.
0000000000000000000000000000000000000000;;		Target ObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
0000000000000000000000000000000000000000;;	type Preconditions struct {
0000000000000000000000000000000000000000;;		// Specifies the target UID.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID *types.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletionPropagation decides whether and how garbage collection will be performed.
0000000000000000000000000000000000000000;;	type DeletionPropagation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Orphans the dependents.
0000000000000000000000000000000000000000;;		DeletePropagationOrphan DeletionPropagation = "Orphan"
0000000000000000000000000000000000000000;;		// Deletes the object from the key-value store, the garbage collector will delete the dependents in the background.
0000000000000000000000000000000000000000;;		DeletePropagationBackground DeletionPropagation = "Background"
0000000000000000000000000000000000000000;;		// The object exists in the key-value store until the garbage collector deletes all the dependents whose ownerReference.blockOwnerDeletion=true from the key-value store.
0000000000000000000000000000000000000000;;		// API sever will put the "DeletingDependents" finalizer on the object, and sets its deletionTimestamp.
0000000000000000000000000000000000000000;;		// This policy is cascading, i.e., the dependents will be deleted with Foreground.
0000000000000000000000000000000000000000;;		DeletePropagationForeground DeletionPropagation = "Foreground"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteOptions may be provided when deleting an API object
0000000000000000000000000000000000000000;;	// DEPRECATED: This type has been moved to meta/v1 and will be removed soon.
0000000000000000000000000000000000000000;;	type DeleteOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional duration in seconds before the object should be deleted. Value must be non-negative integer.
0000000000000000000000000000000000000000;;		// The value zero indicates delete immediately. If this value is nil, the default grace period for the
0000000000000000000000000000000000000000;;		// specified type will be used.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GracePeriodSeconds *int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
0000000000000000000000000000000000000000;;		// returned.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Preconditions *Preconditions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
0000000000000000000000000000000000000000;;		// Should the dependent objects be orphaned. If true/false, the "orphan"
0000000000000000000000000000000000000000;;		// finalizer will be added to/removed from the object's finalizers list.
0000000000000000000000000000000000000000;;		// Either this field or PropagationPolicy may be set, but not both.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		OrphanDependents *bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether and how garbage collection will be performed.
0000000000000000000000000000000000000000;;		// Either this field or OrphanDependents may be set, but not both.
0000000000000000000000000000000000000000;;		// The default policy is decided by the existing finalizer set in the
0000000000000000000000000000000000000000;;		// metadata.finalizers and the resource-specific default policy.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PropagationPolicy *DeletionPropagation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListOptions is the query options to a standard REST list call, and has future support for
0000000000000000000000000000000000000000;;	// watch calls.
0000000000000000000000000000000000000000;;	// DEPRECATED: This type has been moved to meta/v1 and will be removed soon.
0000000000000000000000000000000000000000;;	type ListOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A selector based on labels
0000000000000000000000000000000000000000;;		LabelSelector labels.Selector
0000000000000000000000000000000000000000;;		// A selector based on fields
0000000000000000000000000000000000000000;;		FieldSelector fields.Selector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, partially initialized resources are included in the response.
0000000000000000000000000000000000000000;;		IncludeUninitialized bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, watch for changes to this list
0000000000000000000000000000000000000000;;		Watch bool
0000000000000000000000000000000000000000;;		// When specified with a watch call, shows changes that occur after that particular version of a resource.
0000000000000000000000000000000000000000;;		// Defaults to changes from the beginning of history.
0000000000000000000000000000000000000000;;		// When specified for list:
0000000000000000000000000000000000000000;;		// - if unset, then the result is returned from remote storage based on quorum-read flag;
0000000000000000000000000000000000000000;;		// - if it's 0, then we simply return what we currently have in cache, no guarantee;
0000000000000000000000000000000000000000;;		// - if set to non zero, then the result is at least as fresh as given rv.
0000000000000000000000000000000000000000;;		ResourceVersion string
0000000000000000000000000000000000000000;;		// Timeout for the list/watch call.
0000000000000000000000000000000000000000;;		TimeoutSeconds *int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodLogOptions is the query options for a Pod's logs REST call
0000000000000000000000000000000000000000;;	type PodLogOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Container for which to return logs
0000000000000000000000000000000000000000;;		Container string
0000000000000000000000000000000000000000;;		// If true, follow the logs for the pod
0000000000000000000000000000000000000000;;		Follow bool
0000000000000000000000000000000000000000;;		// If true, return previous terminated container logs
0000000000000000000000000000000000000000;;		Previous bool
0000000000000000000000000000000000000000;;		// A relative time in seconds before the current time from which to show logs. If this value
0000000000000000000000000000000000000000;;		// precedes the time a pod was started, only logs since the pod start will be returned.
0000000000000000000000000000000000000000;;		// If this value is in the future, no logs will be returned.
0000000000000000000000000000000000000000;;		// Only one of sinceSeconds or sinceTime may be specified.
0000000000000000000000000000000000000000;;		SinceSeconds *int64
0000000000000000000000000000000000000000;;		// An RFC3339 timestamp from which to show logs. If this value
0000000000000000000000000000000000000000;;		// precedes the time a pod was started, only logs since the pod start will be returned.
0000000000000000000000000000000000000000;;		// If this value is in the future, no logs will be returned.
0000000000000000000000000000000000000000;;		// Only one of sinceSeconds or sinceTime may be specified.
0000000000000000000000000000000000000000;;		SinceTime *metav1.Time
0000000000000000000000000000000000000000;;		// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
0000000000000000000000000000000000000000;;		// of log output.
0000000000000000000000000000000000000000;;		Timestamps bool
0000000000000000000000000000000000000000;;		// If set, the number of lines from the end of the logs to show. If not specified,
0000000000000000000000000000000000000000;;		// logs are shown from the creation of the container or sinceSeconds or sinceTime
0000000000000000000000000000000000000000;;		TailLines *int64
0000000000000000000000000000000000000000;;		// If set, the number of bytes to read from the server before terminating the
0000000000000000000000000000000000000000;;		// log output. This may not display a complete final line of logging, and may return
0000000000000000000000000000000000000000;;		// slightly more or slightly less than the specified limit.
0000000000000000000000000000000000000000;;		LimitBytes *int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodAttachOptions is the query options to a Pod's remote attach call
0000000000000000000000000000000000000000;;	// TODO: merge w/ PodExecOptions below for stdin, stdout, etc
0000000000000000000000000000000000000000;;	type PodAttachOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stdin if true indicates that stdin is to be redirected for the attach call
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdin bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stdout if true indicates that stdout is to be redirected for the attach call
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdout bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stderr if true indicates that stderr is to be redirected for the attach call
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stderr bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTY if true indicates that a tty will be allocated for the attach call
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TTY bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Container to attach to.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Container string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodExecOptions is the query options to a Pod's remote exec call
0000000000000000000000000000000000000000;;	type PodExecOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stdin if true indicates that stdin is to be redirected for the exec call
0000000000000000000000000000000000000000;;		Stdin bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stdout if true indicates that stdout is to be redirected for the exec call
0000000000000000000000000000000000000000;;		Stdout bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stderr if true indicates that stderr is to be redirected for the exec call
0000000000000000000000000000000000000000;;		Stderr bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTY if true indicates that a tty will be allocated for the exec call
0000000000000000000000000000000000000000;;		TTY bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Container in which to execute the command.
0000000000000000000000000000000000000000;;		Container string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Command is the remote command to execute; argv array; not executed within a shell.
0000000000000000000000000000000000000000;;		Command []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodPortForwardOptions is the query options to a Pod's port forward call
0000000000000000000000000000000000000000;;	type PodPortForwardOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The list of ports to forward
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ports []int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodProxyOptions is the query options to a Pod's proxy call
0000000000000000000000000000000000000000;;	type PodProxyOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the URL path to use for the current proxy request
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeProxyOptions is the query options to a Node's proxy call
0000000000000000000000000000000000000000;;	type NodeProxyOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the URL path to use for the current proxy request
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceProxyOptions is the query options to a Service's proxy call.
0000000000000000000000000000000000000000;;	type ServiceProxyOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the part of URLs that include service endpoints, suffixes,
0000000000000000000000000000000000000000;;		// and parameters to use for the current proxy request to service.
0000000000000000000000000000000000000000;;		// For example, the whole request URL is
0000000000000000000000000000000000000000;;		// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
0000000000000000000000000000000000000000;;		// Path is _search?q=user:kimchy.
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectReference contains enough information to let you inspect or modify the referred object.
0000000000000000000000000000000000000000;;	type ObjectReference struct {
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Kind string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID types.UID
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIVersion string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional. If referring to a piece of an object instead of an entire object, this string
0000000000000000000000000000000000000000;;		// should contain information to identify the sub-object. For example, if the object
0000000000000000000000000000000000000000;;		// reference is to a container within a pod, this would take on a value like:
0000000000000000000000000000000000000000;;		// "spec.containers{name}" (where "name" refers to the name of the container that triggered
0000000000000000000000000000000000000000;;		// the event) or if no container name is specified "spec.containers[2]" (container with
0000000000000000000000000000000000000000;;		// index 2 in this pod). This syntax is chosen only to have some well-defined way of
0000000000000000000000000000000000000000;;		// referencing a part of an object.
0000000000000000000000000000000000000000;;		// TODO: this design is not final and this field is subject to change in the future.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldPath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
0000000000000000000000000000000000000000;;	type LocalObjectReference struct {
0000000000000000000000000000000000000000;;		//TODO: Add other useful fields.  apiVersion, kind, uid?
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SerializedReference struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reference ObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EventSource struct {
0000000000000000000000000000000000000000;;		// Component from which the event is generated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Component string
0000000000000000000000000000000000000000;;		// Node name on which the event is generated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Host string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid values for event types (new types could be added in future)
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Information only and will not cause any problems
0000000000000000000000000000000000000000;;		EventTypeNormal string = "Normal"
0000000000000000000000000000000000000000;;		// These events are to warn that something might go wrong
0000000000000000000000000000000000000000;;		EventTypeWarning string = "Warning"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event is a report of an event somewhere in the cluster.
0000000000000000000000000000000000000000;;	// TODO: Decide whether to store these separately or with the object they apply to.
0000000000000000000000000000000000000000;;	type Event struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Required. The object that this event is about.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		InvolvedObject ObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional; this should be a short, machine understandable string that gives the reason
0000000000000000000000000000000000000000;;		// for this event being generated. For example, if the event is reporting that a container
0000000000000000000000000000000000000000;;		// can't start, the Reason might be "ImageNotFound".
0000000000000000000000000000000000000000;;		// TODO: provide exact specification for format.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional. A human-readable description of the status of this operation.
0000000000000000000000000000000000000000;;		// TODO: decide on maximum length.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional. The component reporting this event. Should be a short machine understandable string.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Source EventSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FirstTimestamp metav1.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The time at which the most recent occurrence of this event was recorded.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTimestamp metav1.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of times this event has occurred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Count int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Type of this event (Normal, Warning), new types could be added in the future.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventList is a list of events.
0000000000000000000000000000000000000000;;	type EventList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List holds a list of objects, which may not be known by the server.
0000000000000000000000000000000000000000;;	type List struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A type of object that is limited
0000000000000000000000000000000000000000;;	type LimitType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Limit that applies to all pods in a namespace
0000000000000000000000000000000000000000;;		LimitTypePod LimitType = "Pod"
0000000000000000000000000000000000000000;;		// Limit that applies to all containers in a namespace
0000000000000000000000000000000000000000;;		LimitTypeContainer LimitType = "Container"
0000000000000000000000000000000000000000;;		// Limit that applies to all persistent volume claims in a namespace
0000000000000000000000000000000000000000;;		LimitTypePersistentVolumeClaim LimitType = "PersistentVolumeClaim"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRangeItem defines a min/max usage limit for any resource that matches on kind
0000000000000000000000000000000000000000;;	type LimitRangeItem struct {
0000000000000000000000000000000000000000;;		// Type of resource that this limit applies to
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type LimitType
0000000000000000000000000000000000000000;;		// Max usage constraints on this kind by resource name
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Max ResourceList
0000000000000000000000000000000000000000;;		// Min usage constraints on this kind by resource name
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Min ResourceList
0000000000000000000000000000000000000000;;		// Default resource requirement limit value by resource name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Default ResourceList
0000000000000000000000000000000000000000;;		// DefaultRequest resource requirement request value by resource name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultRequest ResourceList
0000000000000000000000000000000000000000;;		// MaxLimitRequestRatio represents the max burst value for the named resource
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxLimitRequestRatio ResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRangeSpec defines a min/max usage limit for resources that match on kind
0000000000000000000000000000000000000000;;	type LimitRangeSpec struct {
0000000000000000000000000000000000000000;;		// Limits is the list of LimitRangeItem objects that are enforced
0000000000000000000000000000000000000000;;		Limits []LimitRangeItem
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRange sets resource usage limits for each kind of resource in a Namespace
0000000000000000000000000000000000000000;;	type LimitRange struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the limits enforced
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec LimitRangeSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRangeList is a list of LimitRange items.
0000000000000000000000000000000000000000;;	type LimitRangeList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of LimitRange objects
0000000000000000000000000000000000000000;;		Items []LimitRange
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following identify resource constants for Kubernetes object types
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Pods, number
0000000000000000000000000000000000000000;;		ResourcePods ResourceName = "pods"
0000000000000000000000000000000000000000;;		// Services, number
0000000000000000000000000000000000000000;;		ResourceServices ResourceName = "services"
0000000000000000000000000000000000000000;;		// ReplicationControllers, number
0000000000000000000000000000000000000000;;		ResourceReplicationControllers ResourceName = "replicationcontrollers"
0000000000000000000000000000000000000000;;		// ResourceQuotas, number
0000000000000000000000000000000000000000;;		ResourceQuotas ResourceName = "resourcequotas"
0000000000000000000000000000000000000000;;		// ResourceSecrets, number
0000000000000000000000000000000000000000;;		ResourceSecrets ResourceName = "secrets"
0000000000000000000000000000000000000000;;		// ResourceConfigMaps, number
0000000000000000000000000000000000000000;;		ResourceConfigMaps ResourceName = "configmaps"
0000000000000000000000000000000000000000;;		// ResourcePersistentVolumeClaims, number
0000000000000000000000000000000000000000;;		ResourcePersistentVolumeClaims ResourceName = "persistentvolumeclaims"
0000000000000000000000000000000000000000;;		// ResourceServicesNodePorts, number
0000000000000000000000000000000000000000;;		ResourceServicesNodePorts ResourceName = "services.nodeports"
0000000000000000000000000000000000000000;;		// ResourceServicesLoadBalancers, number
0000000000000000000000000000000000000000;;		ResourceServicesLoadBalancers ResourceName = "services.loadbalancers"
0000000000000000000000000000000000000000;;		// CPU request, in cores. (500m = .5 cores)
0000000000000000000000000000000000000000;;		ResourceRequestsCPU ResourceName = "requests.cpu"
0000000000000000000000000000000000000000;;		// Memory request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceRequestsMemory ResourceName = "requests.memory"
0000000000000000000000000000000000000000;;		// Storage request, in bytes
0000000000000000000000000000000000000000;;		ResourceRequestsStorage ResourceName = "requests.storage"
0000000000000000000000000000000000000000;;		// CPU limit, in cores. (500m = .5 cores)
0000000000000000000000000000000000000000;;		ResourceLimitsCPU ResourceName = "limits.cpu"
0000000000000000000000000000000000000000;;		// Memory limit, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceLimitsMemory ResourceName = "limits.memory"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ResourceQuotaScope defines a filter that must match each object tracked by a quota
0000000000000000000000000000000000000000;;	type ResourceQuotaScope string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Match all pod objects where spec.activeDeadlineSeconds
0000000000000000000000000000000000000000;;		ResourceQuotaScopeTerminating ResourceQuotaScope = "Terminating"
0000000000000000000000000000000000000000;;		// Match all pod objects where !spec.activeDeadlineSeconds
0000000000000000000000000000000000000000;;		ResourceQuotaScopeNotTerminating ResourceQuotaScope = "NotTerminating"
0000000000000000000000000000000000000000;;		// Match all pod objects that have best effort quality of service
0000000000000000000000000000000000000000;;		ResourceQuotaScopeBestEffort ResourceQuotaScope = "BestEffort"
0000000000000000000000000000000000000000;;		// Match all pod objects that do not have best effort quality of service
0000000000000000000000000000000000000000;;		ResourceQuotaScopeNotBestEffort ResourceQuotaScope = "NotBestEffort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuotaSpec defines the desired hard limits to enforce for Quota
0000000000000000000000000000000000000000;;	type ResourceQuotaSpec struct {
0000000000000000000000000000000000000000;;		// Hard is the set of desired hard limits for each named resource
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hard ResourceList
0000000000000000000000000000000000000000;;		// A collection of filters that must match each object tracked by a quota.
0000000000000000000000000000000000000000;;		// If not specified, the quota matches all objects.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Scopes []ResourceQuotaScope
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuotaStatus defines the enforced hard limits and observed use
0000000000000000000000000000000000000000;;	type ResourceQuotaStatus struct {
0000000000000000000000000000000000000000;;		// Hard is the set of enforced hard limits for each named resource
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hard ResourceList
0000000000000000000000000000000000000000;;		// Used is the current observed total usage of the resource in the namespace
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Used ResourceList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuota sets aggregate quota restrictions enforced per namespace
0000000000000000000000000000000000000000;;	type ResourceQuota struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the desired quota
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ResourceQuotaSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status defines the actual enforced quota and its current usage
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ResourceQuotaStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuotaList is a list of ResourceQuota items
0000000000000000000000000000000000000000;;	type ResourceQuotaList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of ResourceQuota objects
0000000000000000000000000000000000000000;;		Items []ResourceQuota
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Secret holds secret data of a certain type.  The total bytes of the values in
0000000000000000000000000000000000000000;;	// the Data field must be less than MaxSecretSize bytes.
0000000000000000000000000000000000000000;;	type Secret struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Data contains the secret data. Each key must consist of alphanumeric
0000000000000000000000000000000000000000;;		// characters, '-', '_' or '.'. The serialized form of the secret data is a
0000000000000000000000000000000000000000;;		// base64 encoded string, representing the arbitrary (possibly non-string)
0000000000000000000000000000000000000000;;		// data value here.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Data map[string][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used to facilitate programmatic handling of secret data.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type SecretType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const MaxSecretSize = 1 * 1024 * 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SecretType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// SecretTypeOpaque is the default; arbitrary user-defined data
0000000000000000000000000000000000000000;;		SecretTypeOpaque SecretType = "Opaque"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeServiceAccountToken contains a token that identifies a service account to the API
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Annotations["kubernetes.io/service-account.name"] - the name of the ServiceAccount the token identifies
0000000000000000000000000000000000000000;;		// - Secret.Annotations["kubernetes.io/service-account.uid"] - the UID of the ServiceAccount the token identifies
0000000000000000000000000000000000000000;;		// - Secret.Data["token"] - a token that identifies the service account to the API
0000000000000000000000000000000000000000;;		SecretTypeServiceAccountToken SecretType = "kubernetes.io/service-account-token"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceAccountNameKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountNameKey = "kubernetes.io/service-account.name"
0000000000000000000000000000000000000000;;		// ServiceAccountUIDKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountUIDKey = "kubernetes.io/service-account.uid"
0000000000000000000000000000000000000000;;		// ServiceAccountTokenKey is the key of the required data for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountTokenKey = "token"
0000000000000000000000000000000000000000;;		// ServiceAccountKubeconfigKey is the key of the optional kubeconfig data for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountKubeconfigKey = "kubernetes.kubeconfig"
0000000000000000000000000000000000000000;;		// ServiceAccountRootCAKey is the key of the optional root certificate authority for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountRootCAKey = "ca.crt"
0000000000000000000000000000000000000000;;		// ServiceAccountNamespaceKey is the key of the optional namespace to use as the default for namespaced API calls
0000000000000000000000000000000000000000;;		ServiceAccountNamespaceKey = "namespace"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeDockercfg contains a dockercfg file that follows the same format rules as ~/.dockercfg
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Data[".dockercfg"] - a serialized ~/.dockercfg file
0000000000000000000000000000000000000000;;		SecretTypeDockercfg SecretType = "kubernetes.io/dockercfg"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DockerConfigKey is the key of the required data for SecretTypeDockercfg secrets
0000000000000000000000000000000000000000;;		DockerConfigKey = ".dockercfg"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeDockerConfigJson contains a dockercfg file that follows the same format rules as ~/.docker/config.json
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Data[".dockerconfigjson"] - a serialized ~/.docker/config.json file
0000000000000000000000000000000000000000;;		SecretTypeDockerConfigJson SecretType = "kubernetes.io/dockerconfigjson"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DockerConfigJsonKey is the key of the required data for SecretTypeDockerConfigJson secrets
0000000000000000000000000000000000000000;;		DockerConfigJsonKey = ".dockerconfigjson"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeBasicAuth contains data needed for basic authentication.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required at least one of fields:
0000000000000000000000000000000000000000;;		// - Secret.Data["username"] - username used for authentication
0000000000000000000000000000000000000000;;		// - Secret.Data["password"] - password or token needed for authentication
0000000000000000000000000000000000000000;;		SecretTypeBasicAuth SecretType = "kubernetes.io/basic-auth"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BasicAuthUsernameKey is the key of the username for SecretTypeBasicAuth secrets
0000000000000000000000000000000000000000;;		BasicAuthUsernameKey = "username"
0000000000000000000000000000000000000000;;		// BasicAuthPasswordKey is the key of the password or token for SecretTypeBasicAuth secrets
0000000000000000000000000000000000000000;;		BasicAuthPasswordKey = "password"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeSSHAuth contains data needed for SSH authetication.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required field:
0000000000000000000000000000000000000000;;		// - Secret.Data["ssh-privatekey"] - private SSH key needed for authentication
0000000000000000000000000000000000000000;;		SecretTypeSSHAuth SecretType = "kubernetes.io/ssh-auth"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SSHAuthPrivateKey is the key of the required SSH private key for SecretTypeSSHAuth secrets
0000000000000000000000000000000000000000;;		SSHAuthPrivateKey = "ssh-privatekey"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeTLS contains information about a TLS client or server secret. It
0000000000000000000000000000000000000000;;		// is primarily used with TLS termination of the Ingress resource, but may be
0000000000000000000000000000000000000000;;		// used in other types.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Data["tls.key"] - TLS private key.
0000000000000000000000000000000000000000;;		//   Secret.Data["tls.crt"] - TLS certificate.
0000000000000000000000000000000000000000;;		// TODO: Consider supporting different formats, specifying CA/destinationCA.
0000000000000000000000000000000000000000;;		SecretTypeTLS SecretType = "kubernetes.io/tls"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSCertKey is the key for tls certificates in a TLS secret.
0000000000000000000000000000000000000000;;		TLSCertKey = "tls.crt"
0000000000000000000000000000000000000000;;		// TLSPrivateKeyKey is the key for the private key field in a TLS secret.
0000000000000000000000000000000000000000;;		TLSPrivateKeyKey = "tls.key"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SecretList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []Secret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMap holds configuration data for components or applications to consume.
0000000000000000000000000000000000000000;;	type ConfigMap struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Data contains the configuration data.
0000000000000000000000000000000000000000;;		// Each key must consist of alphanumeric characters, '-', '_' or '.'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Data map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMapList is a resource containing a list of ConfigMap objects.
0000000000000000000000000000000000000000;;	type ConfigMapList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of ConfigMaps.
0000000000000000000000000000000000000000;;		Items []ConfigMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These constants are for remote command execution and port forwarding and are
0000000000000000000000000000000000000000;;	// used by both the client side and server side components.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is probably not the ideal place for them, but it didn't seem worth it
0000000000000000000000000000000000000000;;	// to create pkg/exec and pkg/portforward just to contain a single file with
0000000000000000000000000000000000000000;;	// constants in it.  Suggestions for more appropriate alternatives are
0000000000000000000000000000000000000000;;	// definitely welcome!
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Enable stdin for remote command execution
0000000000000000000000000000000000000000;;		ExecStdinParam = "input"
0000000000000000000000000000000000000000;;		// Enable stdout for remote command execution
0000000000000000000000000000000000000000;;		ExecStdoutParam = "output"
0000000000000000000000000000000000000000;;		// Enable stderr for remote command execution
0000000000000000000000000000000000000000;;		ExecStderrParam = "error"
0000000000000000000000000000000000000000;;		// Enable TTY for remote command execution
0000000000000000000000000000000000000000;;		ExecTTYParam = "tty"
0000000000000000000000000000000000000000;;		// Command to run for remote command execution
0000000000000000000000000000000000000000;;		ExecCommandParamm = "command"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of header that specifies stream type
0000000000000000000000000000000000000000;;		StreamType = "streamType"
0000000000000000000000000000000000000000;;		// Value for streamType header for stdin stream
0000000000000000000000000000000000000000;;		StreamTypeStdin = "stdin"
0000000000000000000000000000000000000000;;		// Value for streamType header for stdout stream
0000000000000000000000000000000000000000;;		StreamTypeStdout = "stdout"
0000000000000000000000000000000000000000;;		// Value for streamType header for stderr stream
0000000000000000000000000000000000000000;;		StreamTypeStderr = "stderr"
0000000000000000000000000000000000000000;;		// Value for streamType header for data stream
0000000000000000000000000000000000000000;;		StreamTypeData = "data"
0000000000000000000000000000000000000000;;		// Value for streamType header for error stream
0000000000000000000000000000000000000000;;		StreamTypeError = "error"
0000000000000000000000000000000000000000;;		// Value for streamType header for terminal resize stream
0000000000000000000000000000000000000000;;		StreamTypeResize = "resize"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of header that specifies the port being forwarded
0000000000000000000000000000000000000000;;		PortHeader = "port"
0000000000000000000000000000000000000000;;		// Name of header that specifies a request ID used to associate the error
0000000000000000000000000000000000000000;;		// and data streams for a single forwarded connection
0000000000000000000000000000000000000000;;		PortForwardRequestIDHeader = "requestID"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type and constants for component health validation.
0000000000000000000000000000000000000000;;	type ComponentConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid conditions for the component.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ComponentHealthy ComponentConditionType = "Healthy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ComponentCondition struct {
0000000000000000000000000000000000000000;;		Type   ComponentConditionType
0000000000000000000000000000000000000000;;		Status ConditionStatus
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Error string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
0000000000000000000000000000000000000000;;	type ComponentStatus struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Conditions []ComponentCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ComponentStatusList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Items []ComponentStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecurityContext holds security configuration that will be applied to a container.
0000000000000000000000000000000000000000;;	// Some fields are present in both SecurityContext and PodSecurityContext.  When both
0000000000000000000000000000000000000000;;	// are set, the values in SecurityContext take precedence.
0000000000000000000000000000000000000000;;	type SecurityContext struct {
0000000000000000000000000000000000000000;;		// The capabilities to add/drop when running containers.
0000000000000000000000000000000000000000;;		// Defaults to the default set of capabilities granted by the container runtime.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capabilities *Capabilities
0000000000000000000000000000000000000000;;		// Run container in privileged mode.
0000000000000000000000000000000000000000;;		// Processes in privileged containers are essentially equivalent to root on the host.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Privileged *bool
0000000000000000000000000000000000000000;;		// The SELinux context to be applied to the container.
0000000000000000000000000000000000000000;;		// If unspecified, the container runtime will allocate a random SELinux context for each
0000000000000000000000000000000000000000;;		// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SELinuxOptions *SELinuxOptions
0000000000000000000000000000000000000000;;		// The UID to run the entrypoint of the container process.
0000000000000000000000000000000000000000;;		// Defaults to user specified in image metadata if unspecified.
0000000000000000000000000000000000000000;;		// May also be set in PodSecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsUser *int64
0000000000000000000000000000000000000000;;		// Indicates that the container must run as a non-root user.
0000000000000000000000000000000000000000;;		// If true, the Kubelet will validate the image at runtime to ensure that it
0000000000000000000000000000000000000000;;		// does not run as UID 0 (root) and fail to start the container if it does.
0000000000000000000000000000000000000000;;		// If unset or false, no such validation will be performed.
0000000000000000000000000000000000000000;;		// May also be set in PodSecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsNonRoot *bool
0000000000000000000000000000000000000000;;		// The read-only root filesystem allows you to restrict the locations that an application can write
0000000000000000000000000000000000000000;;		// files to, ensuring the persistent data can only be written to mounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnlyRootFilesystem *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SELinuxOptions are the labels to be applied to the container.
0000000000000000000000000000000000000000;;	type SELinuxOptions struct {
0000000000000000000000000000000000000000;;		// SELinux user label
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		User string
0000000000000000000000000000000000000000;;		// SELinux role label
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Role string
0000000000000000000000000000000000000000;;		// SELinux type label
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;		// SELinux level label.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Level string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeAllocation is an opaque API object (not exposed to end users) that can be persisted to record
0000000000000000000000000000000000000000;;	// the global allocation state of the cluster. The schema of Range and Data generic, in that Range
0000000000000000000000000000000000000000;;	// should be a string representation of the inputs to a range (for instance, for IP allocation it
0000000000000000000000000000000000000000;;	// might be a CIDR) and Data is an opaque blob understood by an allocator which is typically a
0000000000000000000000000000000000000000;;	// binary range.  Consumers should use annotations to record additional information (schema version,
0000000000000000000000000000000000000000;;	// data encoding hints). A range allocation should *ALWAYS* be recreatable at any time by observation
0000000000000000000000000000000000000000;;	// of the cluster, thus the object is less strongly typed than most.
0000000000000000000000000000000000000000;;	type RangeAllocation struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;		// A string representing a unique label for a range of resources, such as a CIDR "10.0.0.0/8" or
0000000000000000000000000000000000000000;;		// port range "10000-30000". Range is not strongly schema'd here. The Range is expected to define
0000000000000000000000000000000000000000;;		// a start and end unless there is an implicit end.
0000000000000000000000000000000000000000;;		Range string
0000000000000000000000000000000000000000;;		// A byte array representing the serialized state of a range allocation. Additional clarifiers on
0000000000000000000000000000000000000000;;		// the type or format of data should be represented with annotations. For IP allocations, this is
0000000000000000000000000000000000000000;;		// represented as a bit array starting at the base IP of the CIDR in Range, with each bit representing
0000000000000000000000000000000000000000;;		// a single allocated address (the fifth bit on CIDR 10.0.0.0/8 is 10.0.0.4).
0000000000000000000000000000000000000000;;		Data []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// "default-scheduler" is the name of default scheduler.
0000000000000000000000000000000000000000;;		DefaultSchedulerName = "default-scheduler"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
0000000000000000000000000000000000000000;;		// corresponding to every RequiredDuringScheduling affinity rule.
0000000000000000000000000000000000000000;;		// When the --hard-pod-affinity-weight scheduler flag is not specified,
0000000000000000000000000000000000000000;;		// DefaultHardPodAffinityWeight defines the weight of the implicit PreferredDuringScheduling affinity rule.
0000000000000000000000000000000000000000;;		DefaultHardPodAffinitySymmetricWeight int = 1
0000000000000000000000000000000000000000;;	)
