0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a0a6ff3e50600118609309ad715f48c98e5c6c73;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodLogOptions(t *testing.T) {
0000000000000000000000000000000000000000;;		sinceSeconds := int64(1)
0000000000000000000000000000000000000000;;		sinceTime := metav1.NewTime(time.Date(2000, 1, 1, 12, 34, 56, 0, time.UTC).Local())
0000000000000000000000000000000000000000;;		tailLines := int64(2)
0000000000000000000000000000000000000000;;		limitBytes := int64(3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionedLogOptions := &v1.PodLogOptions{
0000000000000000000000000000000000000000;;			Container:    "mycontainer",
0000000000000000000000000000000000000000;;			Follow:       true,
0000000000000000000000000000000000000000;;			Previous:     true,
0000000000000000000000000000000000000000;;			SinceSeconds: &sinceSeconds,
0000000000000000000000000000000000000000;;			SinceTime:    &sinceTime,
0000000000000000000000000000000000000000;;			Timestamps:   true,
0000000000000000000000000000000000000000;;			TailLines:    &tailLines,
0000000000000000000000000000000000000000;;			LimitBytes:   &limitBytes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unversionedLogOptions := &api.PodLogOptions{
0000000000000000000000000000000000000000;;			Container:    "mycontainer",
0000000000000000000000000000000000000000;;			Follow:       true,
0000000000000000000000000000000000000000;;			Previous:     true,
0000000000000000000000000000000000000000;;			SinceSeconds: &sinceSeconds,
0000000000000000000000000000000000000000;;			SinceTime:    &sinceTime,
0000000000000000000000000000000000000000;;			Timestamps:   true,
0000000000000000000000000000000000000000;;			TailLines:    &tailLines,
0000000000000000000000000000000000000000;;			LimitBytes:   &limitBytes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedParameters := url.Values{
0000000000000000000000000000000000000000;;			"container":    {"mycontainer"},
0000000000000000000000000000000000000000;;			"follow":       {"true"},
0000000000000000000000000000000000000000;;			"previous":     {"true"},
0000000000000000000000000000000000000000;;			"sinceSeconds": {"1"},
0000000000000000000000000000000000000000;;			"sinceTime":    {"2000-01-01T12:34:56Z"},
0000000000000000000000000000000000000000;;			"timestamps":   {"true"},
0000000000000000000000000000000000000000;;			"tailLines":    {"2"},
0000000000000000000000000000000000000000;;			"limitBytes":   {"3"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := runtime.NewParameterCodec(api.Scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unversioned -> query params
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			actualParameters, err := codec.EncodeParameters(unversionedLogOptions, v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actualParameters, expectedParameters) {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected\n%#v\ngot\n%#v", expectedParameters, actualParameters)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// versioned -> query params
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			actualParameters, err := codec.EncodeParameters(versionedLogOptions, v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(actualParameters, expectedParameters) {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected\n%#v\ngot\n%#v", expectedParameters, actualParameters)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// query params -> versioned
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			convertedLogOptions := &v1.PodLogOptions{}
0000000000000000000000000000000000000000;;			err := codec.DecodeParameters(expectedParameters, v1.SchemeGroupVersion, convertedLogOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(convertedLogOptions, versionedLogOptions) {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected deserialization:\n%s", diff.ObjectGoPrintSideBySide(versionedLogOptions, convertedLogOptions))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// query params -> unversioned
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			convertedLogOptions := &api.PodLogOptions{}
0000000000000000000000000000000000000000;;			err := codec.DecodeParameters(expectedParameters, v1.SchemeGroupVersion, convertedLogOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(convertedLogOptions, unversionedLogOptions) {
0000000000000000000000000000000000000000;;				t.Fatalf("Unexpected deserialization:\n%s", diff.ObjectGoPrintSideBySide(unversionedLogOptions, convertedLogOptions))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestPodSpecConversion tests that v1.ServiceAccount is an alias for
0000000000000000000000000000000000000000;;	// ServiceAccountName.
0000000000000000000000000000000000000000;;	func TestPodSpecConversion(t *testing.T) {
0000000000000000000000000000000000000000;;		name, other := "foo", "bar"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test internal -> v1. Should have both alias (DeprecatedServiceAccount)
0000000000000000000000000000000000000000;;		// and new field (ServiceAccountName).
0000000000000000000000000000000000000000;;		i := &api.PodSpec{
0000000000000000000000000000000000000000;;			ServiceAccountName: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := v1.PodSpec{}
0000000000000000000000000000000000000000;;		if err := api.Scheme.Convert(i, &v, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.ServiceAccountName != name {
0000000000000000000000000000000000000000;;			t.Fatalf("want v1.ServiceAccountName %q, got %q", name, v.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.DeprecatedServiceAccount != name {
0000000000000000000000000000000000000000;;			t.Fatalf("want v1.DeprecatedServiceAccount %q, got %q", name, v.DeprecatedServiceAccount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test v1 -> internal. Either DeprecatedServiceAccount, ServiceAccountName,
0000000000000000000000000000000000000000;;		// or both should translate to ServiceAccountName. ServiceAccountName wins
0000000000000000000000000000000000000000;;		// if both are set.
0000000000000000000000000000000000000000;;		testCases := []*v1.PodSpec{
0000000000000000000000000000000000000000;;			// New
0000000000000000000000000000000000000000;;			{ServiceAccountName: name},
0000000000000000000000000000000000000000;;			// Alias
0000000000000000000000000000000000000000;;			{DeprecatedServiceAccount: name},
0000000000000000000000000000000000000000;;			// Both: same
0000000000000000000000000000000000000000;;			{ServiceAccountName: name, DeprecatedServiceAccount: name},
0000000000000000000000000000000000000000;;			// Both: different
0000000000000000000000000000000000000000;;			{ServiceAccountName: name, DeprecatedServiceAccount: other},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range testCases {
0000000000000000000000000000000000000000;;			got := api.PodSpec{}
0000000000000000000000000000000000000000;;			err := api.Scheme.Convert(v, &got, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error for case %d: %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if got.ServiceAccountName != name {
0000000000000000000000000000000000000000;;				t.Fatalf("want api.ServiceAccountName %q, got %q", name, got.ServiceAccountName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResourceListConversion(t *testing.T) {
0000000000000000000000000000000000000000;;		bigMilliQuantity := resource.NewQuantity(resource.MaxMilliValue, resource.DecimalSI)
0000000000000000000000000000000000000000;;		bigMilliQuantity.Add(resource.MustParse("12345m"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input    v1.ResourceList
0000000000000000000000000000000000000000;;			expected api.ResourceList
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{ // No changes necessary.
0000000000000000000000000000000000000000;;				input: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceMemory:  resource.MustParse("30M"),
0000000000000000000000000000000000000000;;					v1.ResourceCPU:     resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					v1.ResourceStorage: resource.MustParse("1G"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceMemory:  resource.MustParse("30M"),
0000000000000000000000000000000000000000;;					api.ResourceCPU:     resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					api.ResourceStorage: resource.MustParse("1G"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Nano-scale values should be rounded up to milli-scale.
0000000000000000000000000000000000000000;;				input: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:    resource.MustParse("3.000023m"),
0000000000000000000000000000000000000000;;					v1.ResourceMemory: resource.MustParse("500.000050m"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:    resource.MustParse("4m"),
0000000000000000000000000000000000000000;;					api.ResourceMemory: resource.MustParse("501m"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{ // Large values should still be accurate.
0000000000000000000000000000000000000000;;				input: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceCPU:     *bigMilliQuantity.Copy(),
0000000000000000000000000000000000000000;;					v1.ResourceStorage: *bigMilliQuantity.Copy(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: api.ResourceList{
0000000000000000000000000000000000000000;;					api.ResourceCPU:     *bigMilliQuantity.Copy(),
0000000000000000000000000000000000000000;;					api.ResourceStorage: *bigMilliQuantity.Copy(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			output := api.ResourceList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// defaulting is a separate step from conversion that is applied when reading from the API or from etcd.
0000000000000000000000000000000000000000;;			// perform that step explicitly.
0000000000000000000000000000000000000000;;			k8s_api_v1.SetDefaults_ResourceList(&test.input)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := api.Scheme.Convert(&test.input, &output, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error for case %d: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(test.expected, output) {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected conversion for case %d: Expected\n%+v;\nGot\n%+v", i, test.expected, output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
