0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;pkg/api/v1/ref.go[pkg/api/v1/ref.go][pkg/api/v1/ref/ref.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ref
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Errors that could be returned by GetReference.
0000000000000000000000000000000000000000;;		ErrNilObject  = errors.New("can't reference a nil object")
0000000000000000000000000000000000000000;;		ErrNoSelfLink = errors.New("selfLink was empty, can't make reference")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetReference returns an ObjectReference which refers to the given
0000000000000000000000000000000000000000;;	// object, or an error if the object doesn't follow the conventions
0000000000000000000000000000000000000000;;	// that would allow this.
0000000000000000000000000000000000000000;;	// TODO: should take a meta.Interface see http://issue.k8s.io/7127
0000000000000000000000000000000000000000;;	func GetReference(scheme *runtime.Scheme, obj runtime.Object) (*v1.ObjectReference, error) {
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			return nil, ErrNilObject
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ref, ok := obj.(*v1.ObjectReference); ok {
0000000000000000000000000000000000000000;;			// Don't make a reference to a reference.
0000000000000000000000000000000000000000;;			return ref, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvk := obj.GetObjectKind().GroupVersionKind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the object referenced is actually persisted, we can just get kind from meta
0000000000000000000000000000000000000000;;		// if we are building an object reference to something not yet persisted, we should fallback to scheme
0000000000000000000000000000000000000000;;		kind := gvk.Kind
0000000000000000000000000000000000000000;;		if len(kind) == 0 {
0000000000000000000000000000000000000000;;			// TODO: this is wrong
0000000000000000000000000000000000000000;;			gvks, _, err := scheme.ObjectKinds(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kind = gvks[0].Kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An object that implements only List has enough metadata to build a reference
0000000000000000000000000000000000000000;;		var listMeta meta.List
0000000000000000000000000000000000000000;;		objectMeta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			listMeta, err = meta.ListAccessor(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			listMeta = objectMeta
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the object referenced is actually persisted, we can also get version from meta
0000000000000000000000000000000000000000;;		version := gvk.GroupVersion().String()
0000000000000000000000000000000000000000;;		if len(version) == 0 {
0000000000000000000000000000000000000000;;			selfLink := listMeta.GetSelfLink()
0000000000000000000000000000000000000000;;			if len(selfLink) == 0 {
0000000000000000000000000000000000000000;;				return nil, ErrNoSelfLink
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selfLinkUrl, err := url.Parse(selfLink)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// example paths: /<prefix>/<version>/*
0000000000000000000000000000000000000000;;			parts := strings.Split(selfLinkUrl.Path, "/")
0000000000000000000000000000000000000000;;			if len(parts) < 3 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected self link format: '%v'; got version '%v'", selfLink, version)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			version = parts[2]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only has list metadata
0000000000000000000000000000000000000000;;		if objectMeta == nil {
0000000000000000000000000000000000000000;;			return &v1.ObjectReference{
0000000000000000000000000000000000000000;;				Kind:            kind,
0000000000000000000000000000000000000000;;				APIVersion:      version,
0000000000000000000000000000000000000000;;				ResourceVersion: listMeta.GetResourceVersion(),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.ObjectReference{
0000000000000000000000000000000000000000;;			Kind:            kind,
0000000000000000000000000000000000000000;;			APIVersion:      version,
0000000000000000000000000000000000000000;;			Name:            objectMeta.GetName(),
0000000000000000000000000000000000000000;;			Namespace:       objectMeta.GetNamespace(),
0000000000000000000000000000000000000000;;			UID:             objectMeta.GetUID(),
0000000000000000000000000000000000000000;;			ResourceVersion: objectMeta.GetResourceVersion(),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPartialReference is exactly like GetReference, but allows you to set the FieldPath.
0000000000000000000000000000000000000000;;	func GetPartialReference(scheme *runtime.Scheme, obj runtime.Object, fieldPath string) (*v1.ObjectReference, error) {
0000000000000000000000000000000000000000;;		ref, err := GetReference(scheme, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ref.FieldPath = fieldPath
0000000000000000000000000000000000000000;;		return ref, nil
0000000000000000000000000000000000000000;;	}
