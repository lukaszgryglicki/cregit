0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package endpoints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/md5"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		hashutil "k8s.io/kubernetes/pkg/util/hash"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RepackSubsets takes a slice of EndpointSubset objects, expands it to the full
0000000000000000000000000000000000000000;;	// representation, and then repacks that into the canonical layout.  This
0000000000000000000000000000000000000000;;	// ensures that code which operates on these objects can rely on the common
0000000000000000000000000000000000000000;;	// form for things like comparison.  The result is a newly allocated slice.
0000000000000000000000000000000000000000;;	func RepackSubsets(subsets []v1.EndpointSubset) []v1.EndpointSubset {
0000000000000000000000000000000000000000;;		// First map each unique port definition to the sets of hosts that
0000000000000000000000000000000000000000;;		// offer it.
0000000000000000000000000000000000000000;;		allAddrs := map[addressKey]*v1.EndpointAddress{}
0000000000000000000000000000000000000000;;		portToAddrReadyMap := map[v1.EndpointPort]addressSet{}
0000000000000000000000000000000000000000;;		for i := range subsets {
0000000000000000000000000000000000000000;;			for _, port := range subsets[i].Ports {
0000000000000000000000000000000000000000;;				for k := range subsets[i].Addresses {
0000000000000000000000000000000000000000;;					mapAddressByPort(&subsets[i].Addresses[k], port, true, allAddrs, portToAddrReadyMap)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k := range subsets[i].NotReadyAddresses {
0000000000000000000000000000000000000000;;					mapAddressByPort(&subsets[i].NotReadyAddresses[k], port, false, allAddrs, portToAddrReadyMap)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Next, map the sets of hosts to the sets of ports they offer.
0000000000000000000000000000000000000000;;		// Go does not allow maps or slices as keys to maps, so we have
0000000000000000000000000000000000000000;;		// to synthesize an artificial key and do a sort of 2-part
0000000000000000000000000000000000000000;;		// associative entity.
0000000000000000000000000000000000000000;;		type keyString string
0000000000000000000000000000000000000000;;		keyToAddrReadyMap := map[keyString]addressSet{}
0000000000000000000000000000000000000000;;		addrReadyMapKeyToPorts := map[keyString][]v1.EndpointPort{}
0000000000000000000000000000000000000000;;		for port, addrs := range portToAddrReadyMap {
0000000000000000000000000000000000000000;;			key := keyString(hashAddresses(addrs))
0000000000000000000000000000000000000000;;			keyToAddrReadyMap[key] = addrs
0000000000000000000000000000000000000000;;			addrReadyMapKeyToPorts[key] = append(addrReadyMapKeyToPorts[key], port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Next, build the N-to-M association the API wants.
0000000000000000000000000000000000000000;;		final := []v1.EndpointSubset{}
0000000000000000000000000000000000000000;;		for key, ports := range addrReadyMapKeyToPorts {
0000000000000000000000000000000000000000;;			var readyAddrs, notReadyAddrs []v1.EndpointAddress
0000000000000000000000000000000000000000;;			for addr, ready := range keyToAddrReadyMap[key] {
0000000000000000000000000000000000000000;;				if ready {
0000000000000000000000000000000000000000;;					readyAddrs = append(readyAddrs, *addr)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					notReadyAddrs = append(notReadyAddrs, *addr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			final = append(final, v1.EndpointSubset{Addresses: readyAddrs, NotReadyAddresses: notReadyAddrs, Ports: ports})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finally, sort it.
0000000000000000000000000000000000000000;;		return SortSubsets(final)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The sets of hosts must be de-duped, using IP+UID as the key.
0000000000000000000000000000000000000000;;	type addressKey struct {
0000000000000000000000000000000000000000;;		ip  string
0000000000000000000000000000000000000000;;		uid types.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapAddressByPort adds an address into a map by its ports, registering the address with a unique pointer, and preserving
0000000000000000000000000000000000000000;;	// any existing ready state.
0000000000000000000000000000000000000000;;	func mapAddressByPort(addr *v1.EndpointAddress, port v1.EndpointPort, ready bool, allAddrs map[addressKey]*v1.EndpointAddress, portToAddrReadyMap map[v1.EndpointPort]addressSet) *v1.EndpointAddress {
0000000000000000000000000000000000000000;;		// use addressKey to distinguish between two endpoints that are identical addresses
0000000000000000000000000000000000000000;;		// but may have come from different hosts, for attribution. For instance, Mesos
0000000000000000000000000000000000000000;;		// assigns pods the node IP, but the pods are distinct.
0000000000000000000000000000000000000000;;		key := addressKey{ip: addr.IP}
0000000000000000000000000000000000000000;;		if addr.TargetRef != nil {
0000000000000000000000000000000000000000;;			key.uid = addr.TargetRef.UID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Accumulate the address. The full EndpointAddress structure is preserved for use when
0000000000000000000000000000000000000000;;		// we rebuild the subsets so that the final TargetRef has all of the necessary data.
0000000000000000000000000000000000000000;;		existingAddress := allAddrs[key]
0000000000000000000000000000000000000000;;		if existingAddress == nil {
0000000000000000000000000000000000000000;;			// Make a copy so we don't write to the
0000000000000000000000000000000000000000;;			// input args of this function.
0000000000000000000000000000000000000000;;			existingAddress = &v1.EndpointAddress{}
0000000000000000000000000000000000000000;;			*existingAddress = *addr
0000000000000000000000000000000000000000;;			allAddrs[key] = existingAddress
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remember that this port maps to this address.
0000000000000000000000000000000000000000;;		if _, found := portToAddrReadyMap[port]; !found {
0000000000000000000000000000000000000000;;			portToAddrReadyMap[port] = addressSet{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if we have not yet recorded this port for this address, or if the previous
0000000000000000000000000000000000000000;;		// state was ready, write the current ready state. not ready always trumps
0000000000000000000000000000000000000000;;		// ready.
0000000000000000000000000000000000000000;;		if wasReady, found := portToAddrReadyMap[port][existingAddress]; !found || wasReady {
0000000000000000000000000000000000000000;;			portToAddrReadyMap[port][existingAddress] = ready
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return existingAddress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addressSet map[*v1.EndpointAddress]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addrReady struct {
0000000000000000000000000000000000000000;;		addr  *v1.EndpointAddress
0000000000000000000000000000000000000000;;		ready bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hashAddresses(addrs addressSet) string {
0000000000000000000000000000000000000000;;		// Flatten the list of addresses into a string so it can be used as a
0000000000000000000000000000000000000000;;		// map key.  Unfortunately, DeepHashObject is implemented in terms of
0000000000000000000000000000000000000000;;		// spew, and spew does not handle non-primitive map keys well.  So
0000000000000000000000000000000000000000;;		// first we collapse it into a slice, sort the slice, then hash that.
0000000000000000000000000000000000000000;;		slice := make([]addrReady, 0, len(addrs))
0000000000000000000000000000000000000000;;		for k, ready := range addrs {
0000000000000000000000000000000000000000;;			slice = append(slice, addrReady{k, ready})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(addrsReady(slice))
0000000000000000000000000000000000000000;;		hasher := md5.New()
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(hasher, slice)
0000000000000000000000000000000000000000;;		return hex.EncodeToString(hasher.Sum(nil)[0:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lessAddrReady(a, b addrReady) bool {
0000000000000000000000000000000000000000;;		// ready is not significant to hashing since we can't have duplicate addresses
0000000000000000000000000000000000000000;;		return LessEndpointAddress(a.addr, b.addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addrsReady []addrReady
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sl addrsReady) Len() int      { return len(sl) }
0000000000000000000000000000000000000000;;	func (sl addrsReady) Swap(i, j int) { sl[i], sl[j] = sl[j], sl[i] }
0000000000000000000000000000000000000000;;	func (sl addrsReady) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return lessAddrReady(sl[i], sl[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LessEndpointAddress(a, b *v1.EndpointAddress) bool {
0000000000000000000000000000000000000000;;		ipComparison := bytes.Compare([]byte(a.IP), []byte(b.IP))
0000000000000000000000000000000000000000;;		if ipComparison != 0 {
0000000000000000000000000000000000000000;;			return ipComparison < 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.TargetRef == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.TargetRef == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.TargetRef.UID < b.TargetRef.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addrPtrsByIpAndUID []*v1.EndpointAddress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sl addrPtrsByIpAndUID) Len() int      { return len(sl) }
0000000000000000000000000000000000000000;;	func (sl addrPtrsByIpAndUID) Swap(i, j int) { sl[i], sl[j] = sl[j], sl[i] }
0000000000000000000000000000000000000000;;	func (sl addrPtrsByIpAndUID) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return LessEndpointAddress(sl[i], sl[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SortSubsets sorts an array of EndpointSubset objects in place.  For ease of
0000000000000000000000000000000000000000;;	// use it returns the input slice.
0000000000000000000000000000000000000000;;	func SortSubsets(subsets []v1.EndpointSubset) []v1.EndpointSubset {
0000000000000000000000000000000000000000;;		for i := range subsets {
0000000000000000000000000000000000000000;;			ss := &subsets[i]
0000000000000000000000000000000000000000;;			sort.Sort(addrsByIpAndUID(ss.Addresses))
0000000000000000000000000000000000000000;;			sort.Sort(addrsByIpAndUID(ss.NotReadyAddresses))
0000000000000000000000000000000000000000;;			sort.Sort(portsByHash(ss.Ports))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(subsetsByHash(subsets))
0000000000000000000000000000000000000000;;		return subsets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hashObject(hasher hash.Hash, obj interface{}) []byte {
0000000000000000000000000000000000000000;;		hashutil.DeepHashObject(hasher, obj)
0000000000000000000000000000000000000000;;		return hasher.Sum(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subsetsByHash []v1.EndpointSubset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sl subsetsByHash) Len() int      { return len(sl) }
0000000000000000000000000000000000000000;;	func (sl subsetsByHash) Swap(i, j int) { sl[i], sl[j] = sl[j], sl[i] }
0000000000000000000000000000000000000000;;	func (sl subsetsByHash) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		hasher := md5.New()
0000000000000000000000000000000000000000;;		h1 := hashObject(hasher, sl[i])
0000000000000000000000000000000000000000;;		h2 := hashObject(hasher, sl[j])
0000000000000000000000000000000000000000;;		return bytes.Compare(h1, h2) < 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addrsByIpAndUID []v1.EndpointAddress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sl addrsByIpAndUID) Len() int      { return len(sl) }
0000000000000000000000000000000000000000;;	func (sl addrsByIpAndUID) Swap(i, j int) { sl[i], sl[j] = sl[j], sl[i] }
0000000000000000000000000000000000000000;;	func (sl addrsByIpAndUID) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return LessEndpointAddress(&sl[i], &sl[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portsByHash []v1.EndpointPort
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sl portsByHash) Len() int      { return len(sl) }
0000000000000000000000000000000000000000;;	func (sl portsByHash) Swap(i, j int) { sl[i], sl[j] = sl[j], sl[i] }
0000000000000000000000000000000000000000;;	func (sl portsByHash) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		hasher := md5.New()
0000000000000000000000000000000000000000;;		h1 := hashObject(hasher, sl[i])
0000000000000000000000000000000000000000;;		h2 := hashObject(hasher, sl[j])
0000000000000000000000000000000000000000;;		return bytes.Compare(h1, h2) < 0
0000000000000000000000000000000000000000;;	}
