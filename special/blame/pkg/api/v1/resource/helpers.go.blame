0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;pkg/api/v1/resource_helpers.go[pkg/api/v1/resource_helpers.go][pkg/api/v1/resource/helpers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodRequestsAndLimits returns a dictionary of all defined resources summed up for all
0000000000000000000000000000000000000000;;	// containers of the pod.
0000000000000000000000000000000000000000;;	func PodRequestsAndLimits(pod *v1.Pod) (reqs map[v1.ResourceName]resource.Quantity, limits map[v1.ResourceName]resource.Quantity) {
0000000000000000000000000000000000000000;;		reqs, limits = map[v1.ResourceName]resource.Quantity{}, map[v1.ResourceName]resource.Quantity{}
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Requests {
0000000000000000000000000000000000000000;;				if value, ok := reqs[name]; !ok {
0000000000000000000000000000000000000000;;					reqs[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value.Add(quantity)
0000000000000000000000000000000000000000;;					reqs[name] = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Limits {
0000000000000000000000000000000000000000;;				if value, ok := limits[name]; !ok {
0000000000000000000000000000000000000000;;					limits[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value.Add(quantity)
0000000000000000000000000000000000000000;;					limits[name] = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// init containers define the minimum of any resource
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Requests {
0000000000000000000000000000000000000000;;				value, ok := reqs[name]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					reqs[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quantity.Cmp(value) > 0 {
0000000000000000000000000000000000000000;;					reqs[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Limits {
0000000000000000000000000000000000000000;;				value, ok := limits[name]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					limits[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quantity.Cmp(value) > 0 {
0000000000000000000000000000000000000000;;					limits[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finds and returns the request for a specific resource.
0000000000000000000000000000000000000000;;	func GetResourceRequest(pod *v1.Pod, resource v1.ResourceName) int64 {
0000000000000000000000000000000000000000;;		if resource == v1.ResourcePods {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		totalResources := int64(0)
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if rQuantity, ok := container.Resources.Requests[resource]; ok {
0000000000000000000000000000000000000000;;				if resource == v1.ResourceCPU {
0000000000000000000000000000000000000000;;					totalResources += rQuantity.MilliValue()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					totalResources += rQuantity.Value()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// take max_resource(sum_pod, any_init_container)
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if rQuantity, ok := container.Resources.Requests[resource]; ok {
0000000000000000000000000000000000000000;;				if resource == v1.ResourceCPU && rQuantity.MilliValue() > totalResources {
0000000000000000000000000000000000000000;;					totalResources = rQuantity.MilliValue()
0000000000000000000000000000000000000000;;				} else if rQuantity.Value() > totalResources {
0000000000000000000000000000000000000000;;					totalResources = rQuantity.Value()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return totalResources
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractResourceValueByContainerName extracts the value of a resource
0000000000000000000000000000000000000000;;	// by providing container name
0000000000000000000000000000000000000000;;	func ExtractResourceValueByContainerName(fs *v1.ResourceFieldSelector, pod *v1.Pod, containerName string) (string, error) {
0000000000000000000000000000000000000000;;		container, err := findContainerInPod(pod, containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ExtractContainerResourceValue(fs, container)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deepCopier interface {
0000000000000000000000000000000000000000;;		DeepCopy(interface{}) (interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractResourceValueByContainerNameAndNodeAllocatable extracts the value of a resource
0000000000000000000000000000000000000000;;	// by providing container name and node allocatable
0000000000000000000000000000000000000000;;	func ExtractResourceValueByContainerNameAndNodeAllocatable(copier deepCopier, fs *v1.ResourceFieldSelector, pod *v1.Pod, containerName string, nodeAllocatable v1.ResourceList) (string, error) {
0000000000000000000000000000000000000000;;		realContainer, err := findContainerInPod(pod, containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerCopy, err := copier.DeepCopy(realContainer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to perform a deep copy of container object: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		container, ok := containerCopy.(*v1.Container)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected type returned from deep copy of container object")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		MergeContainerResourceLimits(container, nodeAllocatable)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ExtractContainerResourceValue(fs, container)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractContainerResourceValue extracts the value of a resource
0000000000000000000000000000000000000000;;	// in an already known container
0000000000000000000000000000000000000000;;	func ExtractContainerResourceValue(fs *v1.ResourceFieldSelector, container *v1.Container) (string, error) {
0000000000000000000000000000000000000000;;		divisor := resource.Quantity{}
0000000000000000000000000000000000000000;;		if divisor.Cmp(fs.Divisor) == 0 {
0000000000000000000000000000000000000000;;			divisor = resource.MustParse("1")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			divisor = fs.Divisor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch fs.Resource {
0000000000000000000000000000000000000000;;		case "limits.cpu":
0000000000000000000000000000000000000000;;			return convertResourceCPUToString(container.Resources.Limits.Cpu(), divisor)
0000000000000000000000000000000000000000;;		case "limits.memory":
0000000000000000000000000000000000000000;;			return convertResourceMemoryToString(container.Resources.Limits.Memory(), divisor)
0000000000000000000000000000000000000000;;		case "requests.cpu":
0000000000000000000000000000000000000000;;			return convertResourceCPUToString(container.Resources.Requests.Cpu(), divisor)
0000000000000000000000000000000000000000;;		case "requests.memory":
0000000000000000000000000000000000000000;;			return convertResourceMemoryToString(container.Resources.Requests.Memory(), divisor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("Unsupported container resource : %v", fs.Resource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertResourceCPUToString converts cpu value to the format of divisor and returns
0000000000000000000000000000000000000000;;	// ceiling of the value.
0000000000000000000000000000000000000000;;	func convertResourceCPUToString(cpu *resource.Quantity, divisor resource.Quantity) (string, error) {
0000000000000000000000000000000000000000;;		c := int64(math.Ceil(float64(cpu.MilliValue()) / float64(divisor.MilliValue())))
0000000000000000000000000000000000000000;;		return strconv.FormatInt(c, 10), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertResourceMemoryToString converts memory value to the format of divisor and returns
0000000000000000000000000000000000000000;;	// ceiling of the value.
0000000000000000000000000000000000000000;;	func convertResourceMemoryToString(memory *resource.Quantity, divisor resource.Quantity) (string, error) {
0000000000000000000000000000000000000000;;		m := int64(math.Ceil(float64(memory.Value()) / float64(divisor.Value())))
0000000000000000000000000000000000000000;;		return strconv.FormatInt(m, 10), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findContainerInPod finds a container by its name in the provided pod
0000000000000000000000000000000000000000;;	func findContainerInPod(pod *v1.Pod, containerName string) (*v1.Container, error) {
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if container.Name == containerName {
0000000000000000000000000000000000000000;;				return &container, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("container %s not found", containerName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeContainerResourceLimits checks if a limit is applied for
0000000000000000000000000000000000000000;;	// the container, and if not, it sets the limit to the passed resource list.
0000000000000000000000000000000000000000;;	func MergeContainerResourceLimits(container *v1.Container,
0000000000000000000000000000000000000000;;		allocatable v1.ResourceList) {
0000000000000000000000000000000000000000;;		if container.Resources.Limits == nil {
0000000000000000000000000000000000000000;;			container.Resources.Limits = make(v1.ResourceList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, resource := range []v1.ResourceName{v1.ResourceCPU, v1.ResourceMemory} {
0000000000000000000000000000000000000000;;			if quantity, exists := container.Resources.Limits[resource]; !exists || quantity.IsZero() {
0000000000000000000000000000000000000000;;				if cap, exists := allocatable[resource]; exists {
0000000000000000000000000000000000000000;;					container.Resources.Limits[resource] = *cap.Copy()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
