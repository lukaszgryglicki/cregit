0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
eef3620e3e74c134f44ed5b90fb9526796d86fa0;pkg/api/v1/helpers.go[pkg/api/v1/helpers.go][pkg/api/v1/helper/helpers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package helper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/selection"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsOpaqueIntResourceName returns true if the resource name has the opaque
0000000000000000000000000000000000000000;;	// integer resource prefix.
0000000000000000000000000000000000000000;;	func IsOpaqueIntResourceName(name v1.ResourceName) bool {
0000000000000000000000000000000000000000;;		return strings.HasPrefix(string(name), v1.ResourceOpaqueIntPrefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpaqueIntResourceName returns a ResourceName with the canonical opaque
0000000000000000000000000000000000000000;;	// integer prefix prepended. If the argument already has the prefix, it is
0000000000000000000000000000000000000000;;	// returned unmodified.
0000000000000000000000000000000000000000;;	func OpaqueIntResourceName(name string) v1.ResourceName {
0000000000000000000000000000000000000000;;		if IsOpaqueIntResourceName(v1.ResourceName(name)) {
0000000000000000000000000000000000000000;;			return v1.ResourceName(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.ResourceName(fmt.Sprintf("%s%s", v1.ResourceOpaqueIntPrefix, name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this function aims to check if the service's ClusterIP is set or not
0000000000000000000000000000000000000000;;	// the objective is not to perform validation here
0000000000000000000000000000000000000000;;	func IsServiceIPSet(service *v1.Service) bool {
0000000000000000000000000000000000000000;;		return service.Spec.ClusterIP != v1.ClusterIPNone && service.Spec.ClusterIP != ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this function aims to check if the service's cluster IP is requested or not
0000000000000000000000000000000000000000;;	func IsServiceIPRequested(service *v1.Service) bool {
0000000000000000000000000000000000000000;;		// ExternalName services are CNAME aliases to external ones. Ignore the IP.
0000000000000000000000000000000000000000;;		if service.Spec.Type == v1.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service.Spec.ClusterIP == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddToNodeAddresses appends the NodeAddresses to the passed-by-pointer slice,
0000000000000000000000000000000000000000;;	// only if they do not already exist
0000000000000000000000000000000000000000;;	func AddToNodeAddresses(addresses *[]v1.NodeAddress, addAddresses ...v1.NodeAddress) {
0000000000000000000000000000000000000000;;		for _, add := range addAddresses {
0000000000000000000000000000000000000000;;			exists := false
0000000000000000000000000000000000000000;;			for _, existing := range *addresses {
0000000000000000000000000000000000000000;;				if existing.Address == add.Address && existing.Type == add.Type {
0000000000000000000000000000000000000000;;					exists = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				*addresses = append(*addresses, add)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: make method on LoadBalancerStatus?
0000000000000000000000000000000000000000;;	func LoadBalancerStatusEqual(l, r *v1.LoadBalancerStatus) bool {
0000000000000000000000000000000000000000;;		return ingressSliceEqual(l.Ingress, r.Ingress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ingressSliceEqual(lhs, rhs []v1.LoadBalancerIngress) bool {
0000000000000000000000000000000000000000;;		if len(lhs) != len(rhs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range lhs {
0000000000000000000000000000000000000000;;			if !ingressEqual(&lhs[i], &rhs[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ingressEqual(lhs, rhs *v1.LoadBalancerIngress) bool {
0000000000000000000000000000000000000000;;		if lhs.IP != rhs.IP {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lhs.Hostname != rhs.Hostname {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: make method on LoadBalancerStatus?
0000000000000000000000000000000000000000;;	func LoadBalancerStatusDeepCopy(lb *v1.LoadBalancerStatus) *v1.LoadBalancerStatus {
0000000000000000000000000000000000000000;;		c := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		c.Ingress = make([]v1.LoadBalancerIngress, len(lb.Ingress))
0000000000000000000000000000000000000000;;		for i := range lb.Ingress {
0000000000000000000000000000000000000000;;			c.Ingress[i] = lb.Ingress[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAccessModesAsString returns a string representation of an array of access modes.
0000000000000000000000000000000000000000;;	// modes, when present, are always in the same order: RWO,ROX,RWX.
0000000000000000000000000000000000000000;;	func GetAccessModesAsString(modes []v1.PersistentVolumeAccessMode) string {
0000000000000000000000000000000000000000;;		modes = removeDuplicateAccessModes(modes)
0000000000000000000000000000000000000000;;		modesStr := []string{}
0000000000000000000000000000000000000000;;		if containsAccessMode(modes, v1.ReadWriteOnce) {
0000000000000000000000000000000000000000;;			modesStr = append(modesStr, "RWO")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containsAccessMode(modes, v1.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			modesStr = append(modesStr, "ROX")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containsAccessMode(modes, v1.ReadWriteMany) {
0000000000000000000000000000000000000000;;			modesStr = append(modesStr, "RWX")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(modesStr, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAccessModesAsString returns an array of AccessModes from a string created by GetAccessModesAsString
0000000000000000000000000000000000000000;;	func GetAccessModesFromString(modes string) []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		strmodes := strings.Split(modes, ",")
0000000000000000000000000000000000000000;;		accessModes := []v1.PersistentVolumeAccessMode{}
0000000000000000000000000000000000000000;;		for _, s := range strmodes {
0000000000000000000000000000000000000000;;			s = strings.Trim(s, " ")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case s == "RWO":
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, v1.ReadWriteOnce)
0000000000000000000000000000000000000000;;			case s == "ROX":
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, v1.ReadOnlyMany)
0000000000000000000000000000000000000000;;			case s == "RWX":
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, v1.ReadWriteMany)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return accessModes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeDuplicateAccessModes returns an array of access modes without any duplicates
0000000000000000000000000000000000000000;;	func removeDuplicateAccessModes(modes []v1.PersistentVolumeAccessMode) []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		accessModes := []v1.PersistentVolumeAccessMode{}
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if !containsAccessMode(accessModes, m) {
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return accessModes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containsAccessMode(modes []v1.PersistentVolumeAccessMode, mode v1.PersistentVolumeAccessMode) bool {
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if m == mode {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeSelectorRequirementsAsSelector converts the []NodeSelectorRequirement api type into a struct that implements
0000000000000000000000000000000000000000;;	// labels.Selector.
0000000000000000000000000000000000000000;;	func NodeSelectorRequirementsAsSelector(nsm []v1.NodeSelectorRequirement) (labels.Selector, error) {
0000000000000000000000000000000000000000;;		if len(nsm) == 0 {
0000000000000000000000000000000000000000;;			return labels.Nothing(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector := labels.NewSelector()
0000000000000000000000000000000000000000;;		for _, expr := range nsm {
0000000000000000000000000000000000000000;;			var op selection.Operator
0000000000000000000000000000000000000000;;			switch expr.Operator {
0000000000000000000000000000000000000000;;			case v1.NodeSelectorOpIn:
0000000000000000000000000000000000000000;;				op = selection.In
0000000000000000000000000000000000000000;;			case v1.NodeSelectorOpNotIn:
0000000000000000000000000000000000000000;;				op = selection.NotIn
0000000000000000000000000000000000000000;;			case v1.NodeSelectorOpExists:
0000000000000000000000000000000000000000;;				op = selection.Exists
0000000000000000000000000000000000000000;;			case v1.NodeSelectorOpDoesNotExist:
0000000000000000000000000000000000000000;;				op = selection.DoesNotExist
0000000000000000000000000000000000000000;;			case v1.NodeSelectorOpGt:
0000000000000000000000000000000000000000;;				op = selection.GreaterThan
0000000000000000000000000000000000000000;;			case v1.NodeSelectorOpLt:
0000000000000000000000000000000000000000;;				op = selection.LessThan
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%q is not a valid node selector operator", expr.Operator)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, err := labels.NewRequirement(expr.Key, op, expr.Values)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selector = selector.Add(*r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selector, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddOrUpdateTolerationInPodSpec tries to add a toleration to the toleration list in PodSpec.
0000000000000000000000000000000000000000;;	// Returns true if something was updated, false otherwise.
0000000000000000000000000000000000000000;;	func AddOrUpdateTolerationInPodSpec(spec *v1.PodSpec, toleration *v1.Toleration) bool {
0000000000000000000000000000000000000000;;		podTolerations := spec.Tolerations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var newTolerations []v1.Toleration
0000000000000000000000000000000000000000;;		updated := false
0000000000000000000000000000000000000000;;		for i := range podTolerations {
0000000000000000000000000000000000000000;;			if toleration.MatchToleration(&podTolerations[i]) {
0000000000000000000000000000000000000000;;				if helper.Semantic.DeepEqual(toleration, podTolerations[i]) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newTolerations = append(newTolerations, *toleration)
0000000000000000000000000000000000000000;;				updated = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newTolerations = append(newTolerations, podTolerations[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			newTolerations = append(newTolerations, *toleration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.Tolerations = newTolerations
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddOrUpdateTolerationInPod tries to add a toleration to the pod's toleration list.
0000000000000000000000000000000000000000;;	// Returns true if something was updated, false otherwise.
0000000000000000000000000000000000000000;;	func AddOrUpdateTolerationInPod(pod *v1.Pod, toleration *v1.Toleration) bool {
0000000000000000000000000000000000000000;;		return AddOrUpdateTolerationInPodSpec(&pod.Spec, toleration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TolerationsTolerateTaint checks if taint is tolerated by any of the tolerations.
0000000000000000000000000000000000000000;;	func TolerationsTolerateTaint(tolerations []v1.Toleration, taint *v1.Taint) bool {
0000000000000000000000000000000000000000;;		for i := range tolerations {
0000000000000000000000000000000000000000;;			if tolerations[i].ToleratesTaint(taint) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type taintsFilterFunc func(*v1.Taint) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TolerationsTolerateTaintsWithFilter checks if given tolerations tolerates
0000000000000000000000000000000000000000;;	// all the taints that apply to the filter in given taint list.
0000000000000000000000000000000000000000;;	func TolerationsTolerateTaintsWithFilter(tolerations []v1.Toleration, taints []v1.Taint, applyFilter taintsFilterFunc) bool {
0000000000000000000000000000000000000000;;		if len(taints) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range taints {
0000000000000000000000000000000000000000;;			if applyFilter != nil && !applyFilter(&taints[i]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !TolerationsTolerateTaint(tolerations, &taints[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteTaintsByKey removes all the taints that have the same key to given taintKey
0000000000000000000000000000000000000000;;	func DeleteTaintsByKey(taints []v1.Taint, taintKey string) ([]v1.Taint, bool) {
0000000000000000000000000000000000000000;;		newTaints := []v1.Taint{}
0000000000000000000000000000000000000000;;		deleted := false
0000000000000000000000000000000000000000;;		for i := range taints {
0000000000000000000000000000000000000000;;			if taintKey == taints[i].Key {
0000000000000000000000000000000000000000;;				deleted = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newTaints = append(newTaints, taints[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newTaints, deleted
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteTaint removes all the the taints that have the same key and effect to given taintToDelete.
0000000000000000000000000000000000000000;;	func DeleteTaint(taints []v1.Taint, taintToDelete *v1.Taint) ([]v1.Taint, bool) {
0000000000000000000000000000000000000000;;		newTaints := []v1.Taint{}
0000000000000000000000000000000000000000;;		deleted := false
0000000000000000000000000000000000000000;;		for i := range taints {
0000000000000000000000000000000000000000;;			if taintToDelete.MatchTaint(&taints[i]) {
0000000000000000000000000000000000000000;;				deleted = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newTaints = append(newTaints, taints[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newTaints, deleted
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true and list of Tolerations matching all Taints if all are tolerated, or false otherwise.
0000000000000000000000000000000000000000;;	func GetMatchingTolerations(taints []v1.Taint, tolerations []v1.Toleration) (bool, []v1.Toleration) {
0000000000000000000000000000000000000000;;		if len(taints) == 0 {
0000000000000000000000000000000000000000;;			return true, []v1.Toleration{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tolerations) == 0 && len(taints) > 0 {
0000000000000000000000000000000000000000;;			return false, []v1.Toleration{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := []v1.Toleration{}
0000000000000000000000000000000000000000;;		for i := range taints {
0000000000000000000000000000000000000000;;			tolerated := false
0000000000000000000000000000000000000000;;			for j := range tolerations {
0000000000000000000000000000000000000000;;				if tolerations[j].ToleratesTaint(&taints[i]) {
0000000000000000000000000000000000000000;;					result = append(result, tolerations[j])
0000000000000000000000000000000000000000;;					tolerated = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !tolerated {
0000000000000000000000000000000000000000;;				return false, []v1.Toleration{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetAvoidPodsFromNodeAnnotations(annotations map[string]string) (v1.AvoidPods, error) {
0000000000000000000000000000000000000000;;		var avoidPods v1.AvoidPods
0000000000000000000000000000000000000000;;		if len(annotations) > 0 && annotations[v1.PreferAvoidPodsAnnotationKey] != "" {
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(annotations[v1.PreferAvoidPodsAnnotationKey]), &avoidPods)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return avoidPods, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return avoidPods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SysctlsFromPodAnnotations parses the sysctl annotations into a slice of safe Sysctls
0000000000000000000000000000000000000000;;	// and a slice of unsafe Sysctls. This is only a convenience wrapper around
0000000000000000000000000000000000000000;;	// SysctlsFromPodAnnotation.
0000000000000000000000000000000000000000;;	func SysctlsFromPodAnnotations(a map[string]string) ([]v1.Sysctl, []v1.Sysctl, error) {
0000000000000000000000000000000000000000;;		safe, err := SysctlsFromPodAnnotation(a[v1.SysctlsPodAnnotationKey])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unsafe, err := SysctlsFromPodAnnotation(a[v1.UnsafeSysctlsPodAnnotationKey])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return safe, unsafe, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SysctlsFromPodAnnotation parses an annotation value into a slice of Sysctls.
0000000000000000000000000000000000000000;;	func SysctlsFromPodAnnotation(annotation string) ([]v1.Sysctl, error) {
0000000000000000000000000000000000000000;;		if len(annotation) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kvs := strings.Split(annotation, ",")
0000000000000000000000000000000000000000;;		sysctls := make([]v1.Sysctl, len(kvs))
0000000000000000000000000000000000000000;;		for i, kv := range kvs {
0000000000000000000000000000000000000000;;			cs := strings.Split(kv, "=")
0000000000000000000000000000000000000000;;			if len(cs) != 2 || len(cs[0]) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("sysctl %q not of the format sysctl_name=value", kv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sysctls[i].Name = cs[0]
0000000000000000000000000000000000000000;;			sysctls[i].Value = cs[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sysctls, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodAnnotationsFromSysctls creates an annotation value for a slice of Sysctls.
0000000000000000000000000000000000000000;;	func PodAnnotationsFromSysctls(sysctls []v1.Sysctl) string {
0000000000000000000000000000000000000000;;		if len(sysctls) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kvs := make([]string, len(sysctls))
0000000000000000000000000000000000000000;;		for i := range sysctls {
0000000000000000000000000000000000000000;;			kvs[i] = fmt.Sprintf("%s=%s", sysctls[i].Name, sysctls[i].Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(kvs, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tries to add a taint to annotations list. Returns a new copy of updated Node and true if something was updated
0000000000000000000000000000000000000000;;	// false otherwise.
0000000000000000000000000000000000000000;;	func AddOrUpdateTaint(node *v1.Node, taint *v1.Taint) (*v1.Node, bool, error) {
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.DeepCopy(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNode := objCopy.(*v1.Node)
0000000000000000000000000000000000000000;;		nodeTaints := newNode.Spec.Taints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var newTaints []v1.Taint
0000000000000000000000000000000000000000;;		updated := false
0000000000000000000000000000000000000000;;		for i := range nodeTaints {
0000000000000000000000000000000000000000;;			if taint.MatchTaint(&nodeTaints[i]) {
0000000000000000000000000000000000000000;;				if helper.Semantic.DeepEqual(taint, nodeTaints[i]) {
0000000000000000000000000000000000000000;;					return newNode, false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newTaints = append(newTaints, *taint)
0000000000000000000000000000000000000000;;				updated = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newTaints = append(newTaints, nodeTaints[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			newTaints = append(newTaints, *taint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newNode.Spec.Taints = newTaints
0000000000000000000000000000000000000000;;		return newNode, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TaintExists(taints []v1.Taint, taintToFind *v1.Taint) bool {
0000000000000000000000000000000000000000;;		for _, taint := range taints {
0000000000000000000000000000000000000000;;			if taint.MatchTaint(taintToFind) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tries to remove a taint from annotations list. Returns a new copy of updated Node and true if something was updated
0000000000000000000000000000000000000000;;	// false otherwise.
0000000000000000000000000000000000000000;;	func RemoveTaint(node *v1.Node, taint *v1.Taint) (*v1.Node, bool, error) {
0000000000000000000000000000000000000000;;		objCopy, err := api.Scheme.DeepCopy(node)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNode := objCopy.(*v1.Node)
0000000000000000000000000000000000000000;;		nodeTaints := newNode.Spec.Taints
0000000000000000000000000000000000000000;;		if len(nodeTaints) == 0 {
0000000000000000000000000000000000000000;;			return newNode, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !TaintExists(nodeTaints, taint) {
0000000000000000000000000000000000000000;;			return newNode, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newTaints, _ := DeleteTaint(nodeTaints, taint)
0000000000000000000000000000000000000000;;		newNode.Spec.Taints = newTaints
0000000000000000000000000000000000000000;;		return newNode, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPersistentVolumeClass returns StorageClassName.
0000000000000000000000000000000000000000;;	func GetPersistentVolumeClass(volume *v1.PersistentVolume) string {
0000000000000000000000000000000000000000;;		// Use beta annotation first
0000000000000000000000000000000000000000;;		if class, found := volume.Annotations[v1.BetaStorageClassAnnotation]; found {
0000000000000000000000000000000000000000;;			return class
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume.Spec.StorageClassName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPersistentVolumeClaimClass returns StorageClassName. If no storage class was
0000000000000000000000000000000000000000;;	// requested, it returns "".
0000000000000000000000000000000000000000;;	func GetPersistentVolumeClaimClass(claim *v1.PersistentVolumeClaim) string {
0000000000000000000000000000000000000000;;		// Use beta annotation first
0000000000000000000000000000000000000000;;		if class, found := claim.Annotations[v1.BetaStorageClassAnnotation]; found {
0000000000000000000000000000000000000000;;			return class
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if claim.Spec.StorageClassName != nil {
0000000000000000000000000000000000000000;;			return *claim.Spec.StorageClassName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimHasClass returns true if given claim has set StorageClassName field.
0000000000000000000000000000000000000000;;	func PersistentVolumeClaimHasClass(claim *v1.PersistentVolumeClaim) bool {
0000000000000000000000000000000000000000;;		// Use beta annotation first
0000000000000000000000000000000000000000;;		if _, found := claim.Annotations[v1.BetaStorageClassAnnotation]; found {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if claim.Spec.StorageClassName != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStorageNodeAffinityFromAnnotation gets the json serialized data from PersistentVolume.Annotations
0000000000000000000000000000000000000000;;	// and converts it to the NodeAffinity type in api.
0000000000000000000000000000000000000000;;	// TODO: update when storage node affinity graduates to beta
0000000000000000000000000000000000000000;;	func GetStorageNodeAffinityFromAnnotation(annotations map[string]string) (*v1.NodeAffinity, error) {
0000000000000000000000000000000000000000;;		if len(annotations) > 0 && annotations[v1.AlphaStorageNodeAffinityAnnotation] != "" {
0000000000000000000000000000000000000000;;			var affinity v1.NodeAffinity
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(annotations[v1.AlphaStorageNodeAffinityAnnotation]), &affinity)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &affinity, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts NodeAffinity type to Alpha annotation for use in PersistentVolumes
0000000000000000000000000000000000000000;;	// TODO: update when storage node affinity graduates to beta
0000000000000000000000000000000000000000;;	func StorageNodeAffinityToAlphaAnnotation(annotations map[string]string, affinity *v1.NodeAffinity) error {
0000000000000000000000000000000000000000;;		if affinity == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		json, err := json.Marshal(*affinity)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations[v1.AlphaStorageNodeAffinityAnnotation] = string(json)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
