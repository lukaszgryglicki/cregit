0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
449753a53edbba4135877b398008c5a14f588091;pkg/kubelet/qos/util/qos.go[pkg/kubelet/qos/util/qos.go][pkg/api/v1/helper/qos/qos.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package qos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QOSList is a set of (resource name, QoS class) pairs.
0000000000000000000000000000000000000000;;	type QOSList map[v1.ResourceName]v1.PodQOSClass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedQoSComputeResources = sets.NewString(string(v1.ResourceCPU), string(v1.ResourceMemory))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodQOS returns the QoS class of a pod.
0000000000000000000000000000000000000000;;	// A pod is besteffort if none of its containers have specified any requests or limits.
0000000000000000000000000000000000000000;;	// A pod is guaranteed only when requests and limits are specified for all the containers and they are equal.
0000000000000000000000000000000000000000;;	// A pod is burstable if limits and requests do not match across all containers.
0000000000000000000000000000000000000000;;	func GetPodQOS(pod *v1.Pod) v1.PodQOSClass {
0000000000000000000000000000000000000000;;		requests := v1.ResourceList{}
0000000000000000000000000000000000000000;;		limits := v1.ResourceList{}
0000000000000000000000000000000000000000;;		zeroQuantity := resource.MustParse("0")
0000000000000000000000000000000000000000;;		isGuaranteed := true
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			// process requests
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Requests {
0000000000000000000000000000000000000000;;				if !supportedQoSComputeResources.Has(string(name)) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quantity.Cmp(zeroQuantity) == 1 {
0000000000000000000000000000000000000000;;					delta := quantity.Copy()
0000000000000000000000000000000000000000;;					if _, exists := requests[name]; !exists {
0000000000000000000000000000000000000000;;						requests[name] = *delta
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						delta.Add(requests[name])
0000000000000000000000000000000000000000;;						requests[name] = *delta
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// process limits
0000000000000000000000000000000000000000;;			qosLimitsFound := sets.NewString()
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Limits {
0000000000000000000000000000000000000000;;				if !supportedQoSComputeResources.Has(string(name)) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quantity.Cmp(zeroQuantity) == 1 {
0000000000000000000000000000000000000000;;					qosLimitsFound.Insert(string(name))
0000000000000000000000000000000000000000;;					delta := quantity.Copy()
0000000000000000000000000000000000000000;;					if _, exists := limits[name]; !exists {
0000000000000000000000000000000000000000;;						limits[name] = *delta
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						delta.Add(limits[name])
0000000000000000000000000000000000000000;;						limits[name] = *delta
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(qosLimitsFound) != len(supportedQoSComputeResources) {
0000000000000000000000000000000000000000;;				isGuaranteed = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(requests) == 0 && len(limits) == 0 {
0000000000000000000000000000000000000000;;			return v1.PodQOSBestEffort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check is requests match limits for all resources.
0000000000000000000000000000000000000000;;		if isGuaranteed {
0000000000000000000000000000000000000000;;			for name, req := range requests {
0000000000000000000000000000000000000000;;				if lim, exists := limits[name]; !exists || lim.Cmp(req) != 0 {
0000000000000000000000000000000000000000;;					isGuaranteed = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isGuaranteed &&
0000000000000000000000000000000000000000;;			len(requests) == len(limits) {
0000000000000000000000000000000000000000;;			return v1.PodQOSGuaranteed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.PodQOSBurstable
0000000000000000000000000000000000000000;;	}
