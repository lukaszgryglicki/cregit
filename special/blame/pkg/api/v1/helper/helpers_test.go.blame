0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;pkg/api/v1/helpers_test.go[pkg/api/v1/helpers_test.go][pkg/api/v1/helper/helpers_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package helper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddToNodeAddresses(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			existing []v1.NodeAddress
0000000000000000000000000000000000000000;;			toAdd    []v1.NodeAddress
0000000000000000000000000000000000000000;;			expected []v1.NodeAddress
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []v1.NodeAddress{},
0000000000000000000000000000000000000000;;				toAdd:    []v1.NodeAddress{},
0000000000000000000000000000000000000000;;				expected: []v1.NodeAddress{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []v1.NodeAddress{},
0000000000000000000000000000000000000000;;				toAdd: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []v1.NodeAddress{},
0000000000000000000000000000000000000000;;				toAdd: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeInternalIP, Address: "10.1.1.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				toAdd: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: v1.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeInternalIP, Address: "10.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: v1.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			AddToNodeAddresses(&tc.existing, tc.toAdd...)
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(tc.expected, tc.existing) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d], expected: %v, got: %v", i, tc.expected, tc.existing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAccessModesFromString(t *testing.T) {
0000000000000000000000000000000000000000;;		modes := GetAccessModesFromString("ROX")
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, v1.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", v1.ReadOnlyMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modes = GetAccessModesFromString("ROX,RWX")
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, v1.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", v1.ReadOnlyMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, v1.ReadWriteMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", v1.ReadWriteMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modes = GetAccessModesFromString("RWO,ROX,RWX")
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, v1.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", v1.ReadOnlyMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, v1.ReadWriteMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", v1.ReadWriteMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemoveDuplicateAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		modes := []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce, v1.ReadOnlyMany, v1.ReadOnlyMany, v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modes = removeDuplicateAccessModes(modes)
0000000000000000000000000000000000000000;;		if len(modes) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 2 distinct modes in set but found %v", len(modes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeSelectorRequirementsAsSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		matchExpressions := []v1.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;			Key:      "foo",
0000000000000000000000000000000000000000;;			Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;			Values:   []string{"bar", "baz"},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		mustParse := func(s string) labels.Selector {
0000000000000000000000000000000000000000;;			out, e := labels.Parse(s)
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				panic(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc := []struct {
0000000000000000000000000000000000000000;;			in        []v1.NodeSelectorRequirement
0000000000000000000000000000000000000000;;			out       labels.Selector
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{in: nil, out: labels.Nothing()},
0000000000000000000000000000000000000000;;			{in: []v1.NodeSelectorRequirement{}, out: labels.Nothing()},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  matchExpressions,
0000000000000000000000000000000000000000;;				out: mustParse("foo in (baz,bar)"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in: []v1.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: v1.NodeSelectorOpExists,
0000000000000000000000000000000000000000;;					Values:   []string{"bar", "baz"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in: []v1.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: v1.NodeSelectorOpGt,
0000000000000000000000000000000000000000;;					Values:   []string{"1"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				out: mustParse("foo>1"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in: []v1.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;					Key:      "bar",
0000000000000000000000000000000000000000;;					Operator: v1.NodeSelectorOpLt,
0000000000000000000000000000000000000000;;					Values:   []string{"7"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				out: mustParse("bar<7"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range tc {
0000000000000000000000000000000000000000;;			out, err := NodeSelectorRequirementsAsSelector(tc.in)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none.", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(out, tc.out) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected:\n\t%+v\nbut got:\n\t%+v", i, tc.out, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTolerationsTolerateTaintsWithFilter(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			description     string
0000000000000000000000000000000000000000;;			tolerations     []v1.Toleration
0000000000000000000000000000000000000000;;			taints          []v1.Taint
0000000000000000000000000000000000000000;;			applyFilter     taintsFilterFunc
0000000000000000000000000000000000000000;;			expectTolerated bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description:     "empty tolerations tolerate empty taints",
0000000000000000000000000000000000000000;;				tolerations:     []v1.Toleration{},
0000000000000000000000000000000000000000;;				taints:          []v1.Taint{},
0000000000000000000000000000000000000000;;				applyFilter:     func(t *v1.Taint) bool { return true },
0000000000000000000000000000000000000000;;				expectTolerated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "non-empty tolerations tolerate empty taints",
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:      "foo",
0000000000000000000000000000000000000000;;						Operator: "Exists",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				taints:          []v1.Taint{},
0000000000000000000000000000000000000000;;				applyFilter:     func(t *v1.Taint) bool { return true },
0000000000000000000000000000000000000000;;				expectTolerated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "tolerations match all taints, expect tolerated",
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:      "foo",
0000000000000000000000000000000000000000;;						Operator: "Exists",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				taints: []v1.Taint{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:    "foo",
0000000000000000000000000000000000000000;;						Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				applyFilter:     func(t *v1.Taint) bool { return true },
0000000000000000000000000000000000000000;;				expectTolerated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "tolerations don't match taints, but no taints apply to the filter, expect tolerated",
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:      "foo",
0000000000000000000000000000000000000000;;						Operator: "Exists",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				taints: []v1.Taint{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:    "bar",
0000000000000000000000000000000000000000;;						Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				applyFilter:     func(t *v1.Taint) bool { return false },
0000000000000000000000000000000000000000;;				expectTolerated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "no filterFunc indicated, means all taints apply to the filter, tolerations don't match taints, expect untolerated",
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:      "foo",
0000000000000000000000000000000000000000;;						Operator: "Exists",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				taints: []v1.Taint{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:    "bar",
0000000000000000000000000000000000000000;;						Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				applyFilter:     nil,
0000000000000000000000000000000000000000;;				expectTolerated: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				description: "tolerations match taints, expect tolerated",
0000000000000000000000000000000000000000;;				tolerations: []v1.Toleration{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:      "foo",
0000000000000000000000000000000000000000;;						Operator: "Exists",
0000000000000000000000000000000000000000;;						Effect:   v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				taints: []v1.Taint{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:    "foo",
0000000000000000000000000000000000000000;;						Effect: v1.TaintEffectNoExecute,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Key:    "bar",
0000000000000000000000000000000000000000;;						Effect: v1.TaintEffectNoSchedule,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				applyFilter:     func(t *v1.Taint) bool { return t.Effect == v1.TaintEffectNoExecute },
0000000000000000000000000000000000000000;;				expectTolerated: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			if tc.expectTolerated != TolerationsTolerateTaintsWithFilter(tc.tolerations, tc.taints, tc.applyFilter) {
0000000000000000000000000000000000000000;;				filteredTaints := []v1.Taint{}
0000000000000000000000000000000000000000;;				for _, taint := range tc.taints {
0000000000000000000000000000000000000000;;					if tc.applyFilter != nil && !tc.applyFilter(&taint) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					filteredTaints = append(filteredTaints, taint)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Errorf("[%s] expect tolerations %+v tolerate filtered taints %+v in taints %+v", tc.description, tc.tolerations, filteredTaints, tc.taints)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAvoidPodsFromNode(t *testing.T) {
0000000000000000000000000000000000000000;;		controllerFlag := true
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			node        *v1.Node
0000000000000000000000000000000000000000;;			expectValue v1.AvoidPods
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node:        &v1.Node{},
0000000000000000000000000000000000000000;;				expectValue: v1.AvoidPods{},
0000000000000000000000000000000000000000;;				expectErr:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							v1.PreferAvoidPodsAnnotationKey: `
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;								    "preferAvoidPods": [
0000000000000000000000000000000000000000;;								        {
0000000000000000000000000000000000000000;;								            "podSignature": {
0000000000000000000000000000000000000000;;								                "podController": {
0000000000000000000000000000000000000000;;							                            "apiVersion": "v1",
0000000000000000000000000000000000000000;;							                            "kind": "ReplicationController",
0000000000000000000000000000000000000000;;							                            "name": "foo",
0000000000000000000000000000000000000000;;							                            "uid": "abcdef123456",
0000000000000000000000000000000000000000;;							                            "controller": true
0000000000000000000000000000000000000000;;								                }
0000000000000000000000000000000000000000;;								            },
0000000000000000000000000000000000000000;;								            "reason": "some reason",
0000000000000000000000000000000000000000;;								            "message": "some message"
0000000000000000000000000000000000000000;;								        }
0000000000000000000000000000000000000000;;								    ]
0000000000000000000000000000000000000000;;								}`,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectValue: v1.AvoidPods{
0000000000000000000000000000000000000000;;					PreferAvoidPods: []v1.PreferAvoidPodsEntry{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							PodSignature: v1.PodSignature{
0000000000000000000000000000000000000000;;								PodController: &metav1.OwnerReference{
0000000000000000000000000000000000000000;;									APIVersion: "v1",
0000000000000000000000000000000000000000;;									Kind:       "ReplicationController",
0000000000000000000000000000000000000000;;									Name:       "foo",
0000000000000000000000000000000000000000;;									UID:        "abcdef123456",
0000000000000000000000000000000000000000;;									Controller: &controllerFlag,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Reason:  "some reason",
0000000000000000000000000000000000000000;;							Message: "some message",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				node: &v1.Node{
0000000000000000000000000000000000000000;;					// Missing end symbol of "podController" and "podSignature"
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							v1.PreferAvoidPodsAnnotationKey: `
0000000000000000000000000000000000000000;;								{
0000000000000000000000000000000000000000;;								    "preferAvoidPods": [
0000000000000000000000000000000000000000;;								        {
0000000000000000000000000000000000000000;;								            "podSignature": {
0000000000000000000000000000000000000000;;								                "podController": {
0000000000000000000000000000000000000000;;								                    "kind": "ReplicationController",
0000000000000000000000000000000000000000;;								                    "apiVersion": "v1"
0000000000000000000000000000000000000000;;								            "reason": "some reason",
0000000000000000000000000000000000000000;;								            "message": "some message"
0000000000000000000000000000000000000000;;								        }
0000000000000000000000000000000000000000;;								    ]
0000000000000000000000000000000000000000;;								}`,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectValue: v1.AvoidPods{},
0000000000000000000000000000000000000000;;				expectErr:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			v, err := GetAvoidPodsFromNodeAnnotations(tc.node.Annotations)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none.", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(tc.expectValue, v) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expect value %v but got %v with %v", i, tc.expectValue, v, v.PreferAvoidPods[0].PodSignature.PodController.Controller)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSysctlsFromPodAnnotation(t *testing.T) {
0000000000000000000000000000000000000000;;		type Test struct {
0000000000000000000000000000000000000000;;			annotation  string
0000000000000000000000000000000000000000;;			expectValue []v1.Sysctl
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range []Test{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "",
0000000000000000000000000000000000000000;;				expectValue: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation: "foo.bar",
0000000000000000000000000000000000000000;;				expectErr:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation: "=123",
0000000000000000000000000000000000000000;;				expectErr:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "foo.bar=",
0000000000000000000000000000000000000000;;				expectValue: []v1.Sysctl{{Name: "foo.bar", Value: ""}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "foo.bar=42",
0000000000000000000000000000000000000000;;				expectValue: []v1.Sysctl{{Name: "foo.bar", Value: "42"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation: "foo.bar=42,",
0000000000000000000000000000000000000000;;				expectErr:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "foo.bar=42,abc.def=1",
0000000000000000000000000000000000000000;;				expectValue: []v1.Sysctl{{Name: "foo.bar", Value: "42"}, {Name: "abc.def", Value: "1"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			sysctls, err := SysctlsFromPodAnnotation(test.annotation)
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none", i)
0000000000000000000000000000000000000000;;			} else if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			} else if !reflect.DeepEqual(sysctls, test.expectValue) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expect value %v but got %v", i, test.expectValue, sysctls)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove when alpha support for topology constraints is removed
0000000000000000000000000000000000000000;;	func TestGetNodeAffinityFromAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			annotations map[string]string
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: nil,
0000000000000000000000000000000000000000;;				expectErr:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{},
0000000000000000000000000000000000000000;;				expectErr:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					v1.AlphaStorageNodeAffinityAnnotation: `{
0000000000000000000000000000000000000000;;	                                        "requiredDuringSchedulingIgnoredDuringExecution": {
0000000000000000000000000000000000000000;;	                                                "nodeSelectorTerms": [
0000000000000000000000000000000000000000;;	                                                        { "matchExpressions": [
0000000000000000000000000000000000000000;;	                                                                { "key": "test-key1",
0000000000000000000000000000000000000000;;	                                                                  "operator": "In",
0000000000000000000000000000000000000000;;	                                                                  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;	                                                                },
0000000000000000000000000000000000000000;;	                                                                { "key": "test-key2",
0000000000000000000000000000000000000000;;	                                                                  "operator": "In",
0000000000000000000000000000000000000000;;	                                                                  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;	                                                                }
0000000000000000000000000000000000000000;;	                                                        ]}
0000000000000000000000000000000000000000;;	                                                ]}
0000000000000000000000000000000000000000;;	                                        }`,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					v1.AlphaStorageNodeAffinityAnnotation: `[{
0000000000000000000000000000000000000000;;	                                        "requiredDuringSchedulingIgnoredDuringExecution": {
0000000000000000000000000000000000000000;;	                                                "nodeSelectorTerms": [
0000000000000000000000000000000000000000;;	                                                        { "matchExpressions": [
0000000000000000000000000000000000000000;;	                                                                { "key": "test-key1",
0000000000000000000000000000000000000000;;	                                                                  "operator": "In",
0000000000000000000000000000000000000000;;	                                                                  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;	                                                                },
0000000000000000000000000000000000000000;;	                                                                { "key": "test-key2",
0000000000000000000000000000000000000000;;	                                                                  "operator": "In",
0000000000000000000000000000000000000000;;	                                                                  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;	                                                                }
0000000000000000000000000000000000000000;;	                                                        ]}
0000000000000000000000000000000000000000;;	                                                ]}
0000000000000000000000000000000000000000;;	                                        }]`,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					v1.AlphaStorageNodeAffinityAnnotation: `{
0000000000000000000000000000000000000000;;	                                        "requiredDuringSchedulingIgnoredDuringExecution": {
0000000000000000000000000000000000000000;;	                                                "nodeSelectorTerms":
0000000000000000000000000000000000000000;;	                                                         "matchExpressions": [
0000000000000000000000000000000000000000;;	                                                                { "key": "test-key1",
0000000000000000000000000000000000000000;;	                                                                  "operator": "In",
0000000000000000000000000000000000000000;;	                                                                  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;	                                                                },
0000000000000000000000000000000000000000;;	                                                                { "key": "test-key2",
0000000000000000000000000000000000000000;;	                                                                  "operator": "In",
0000000000000000000000000000000000000000;;	                                                                  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;	                                                                }
0000000000000000000000000000000000000000;;	                                                        ]}
0000000000000000000000000000000000000000;;	                                                }
0000000000000000000000000000000000000000;;	                                        }`,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			_, err := GetStorageNodeAffinityFromAnnotation(tc.annotations)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none.", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
