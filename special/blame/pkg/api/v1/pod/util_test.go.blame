0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8dbfda939a3d19f7ec3ab9e84f462ad209df6c0a;pkg/api/pod/util_test.go[pkg/api/pod/util_test.go][pkg/api/v1/pod/util_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindPort(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name       string
0000000000000000000000000000000000000000;;			containers []v1.Container
0000000000000000000000000000000000000000;;			port       intstr.IntOrString
0000000000000000000000000000000000000000;;			expected   int
0000000000000000000000000000000000000000;;			pass       bool
0000000000000000000000000000000000000000;;		}{{
0000000000000000000000000000000000000000;;			name:       "valid int, no ports",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{}},
0000000000000000000000000000000000000000;;			port:       intstr.FromInt(93),
0000000000000000000000000000000000000000;;			expected:   93,
0000000000000000000000000000000000000000;;			pass:       true,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			name: "valid int, with ports",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;				Name:          "",
0000000000000000000000000000000000000000;;				ContainerPort: 11,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:          "p",
0000000000000000000000000000000000000000;;				ContainerPort: 22,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}}}},
0000000000000000000000000000000000000000;;			port:     intstr.FromInt(93),
0000000000000000000000000000000000000000;;			expected: 93,
0000000000000000000000000000000000000000;;			pass:     true,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			name:       "valid str, no ports",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{}},
0000000000000000000000000000000000000000;;			port:       intstr.FromString("p"),
0000000000000000000000000000000000000000;;			expected:   0,
0000000000000000000000000000000000000000;;			pass:       false,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			name: "valid str, one ctr with ports",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;				Name:          "",
0000000000000000000000000000000000000000;;				ContainerPort: 11,
0000000000000000000000000000000000000000;;				Protocol:      "UDP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:          "p",
0000000000000000000000000000000000000000;;				ContainerPort: 22,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:          "q",
0000000000000000000000000000000000000000;;				ContainerPort: 33,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}}}},
0000000000000000000000000000000000000000;;			port:     intstr.FromString("q"),
0000000000000000000000000000000000000000;;			expected: 33,
0000000000000000000000000000000000000000;;			pass:     true,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			name: "valid str, two ctr with ports",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{}, {Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;				Name:          "",
0000000000000000000000000000000000000000;;				ContainerPort: 11,
0000000000000000000000000000000000000000;;				Protocol:      "UDP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:          "p",
0000000000000000000000000000000000000000;;				ContainerPort: 22,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:          "q",
0000000000000000000000000000000000000000;;				ContainerPort: 33,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}}}},
0000000000000000000000000000000000000000;;			port:     intstr.FromString("q"),
0000000000000000000000000000000000000000;;			expected: 33,
0000000000000000000000000000000000000000;;			pass:     true,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			name: "valid str, two ctr with same port",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{}, {Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;				Name:          "",
0000000000000000000000000000000000000000;;				ContainerPort: 11,
0000000000000000000000000000000000000000;;				Protocol:      "UDP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:          "p",
0000000000000000000000000000000000000000;;				ContainerPort: 22,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				Name:          "q",
0000000000000000000000000000000000000000;;				ContainerPort: 22,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			}}}},
0000000000000000000000000000000000000000;;			port:     intstr.FromString("q"),
0000000000000000000000000000000000000000;;			expected: 22,
0000000000000000000000000000000000000000;;			pass:     true,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			name: "valid str, invalid protocol",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{}, {Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;				Name:          "a",
0000000000000000000000000000000000000000;;				ContainerPort: 11,
0000000000000000000000000000000000000000;;				Protocol:      "snmp",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;			port:     intstr.FromString("a"),
0000000000000000000000000000000000000000;;			expected: 0,
0000000000000000000000000000000000000000;;			pass:     false,
0000000000000000000000000000000000000000;;		}, {
0000000000000000000000000000000000000000;;			name: "valid hostPort",
0000000000000000000000000000000000000000;;			containers: []v1.Container{{}, {Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;				Name:          "a",
0000000000000000000000000000000000000000;;				ContainerPort: 11,
0000000000000000000000000000000000000000;;				HostPort:      81,
0000000000000000000000000000000000000000;;				Protocol:      "TCP",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			}}},
0000000000000000000000000000000000000000;;			port:     intstr.FromString("a"),
0000000000000000000000000000000000000000;;			expected: 11,
0000000000000000000000000000000000000000;;			pass:     true,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "invalid hostPort",
0000000000000000000000000000000000000000;;				containers: []v1.Container{{}, {Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;					Name:          "a",
0000000000000000000000000000000000000000;;					ContainerPort: 11,
0000000000000000000000000000000000000000;;					HostPort:      -1,
0000000000000000000000000000000000000000;;					Protocol:      "TCP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				}}},
0000000000000000000000000000000000000000;;				port:     intstr.FromString("a"),
0000000000000000000000000000000000000000;;				expected: 11,
0000000000000000000000000000000000000000;;				pass:     true,
0000000000000000000000000000000000000000;;				//this should fail but passes.
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "invalid ContainerPort",
0000000000000000000000000000000000000000;;				containers: []v1.Container{{}, {Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;					Name:          "a",
0000000000000000000000000000000000000000;;					ContainerPort: -1,
0000000000000000000000000000000000000000;;					Protocol:      "TCP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				}}},
0000000000000000000000000000000000000000;;				port:     intstr.FromString("a"),
0000000000000000000000000000000000000000;;				expected: -1,
0000000000000000000000000000000000000000;;				pass:     true,
0000000000000000000000000000000000000000;;				//this should fail but passes
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "HostIP Address",
0000000000000000000000000000000000000000;;				containers: []v1.Container{{}, {Ports: []v1.ContainerPort{{
0000000000000000000000000000000000000000;;					Name:          "a",
0000000000000000000000000000000000000000;;					ContainerPort: 11,
0000000000000000000000000000000000000000;;					HostIP:        "192.168.1.1",
0000000000000000000000000000000000000000;;					Protocol:      "TCP",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				}}},
0000000000000000000000000000000000000000;;				port:     intstr.FromString("a"),
0000000000000000000000000000000000000000;;				expected: 11,
0000000000000000000000000000000000000000;;				pass:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			port, err := FindPort(&v1.Pod{Spec: v1.PodSpec{Containers: tc.containers}},
0000000000000000000000000000000000000000;;				&v1.ServicePort{Protocol: "TCP", TargetPort: tc.port})
0000000000000000000000000000000000000000;;			if err != nil && tc.pass {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error for %s: %v", tc.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && !tc.pass {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected non-error for %s: %d", tc.name, port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if port != tc.expected {
0000000000000000000000000000000000000000;;				t.Errorf("wrong result for %s: expected %d, got %d", tc.name, tc.expected, port)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		// Stub containing all possible secret references in a pod.
0000000000000000000000000000000000000000;;		// The names of the referenced secrets match struct paths detected by reflection.
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{{
0000000000000000000000000000000000000000;;						SecretRef: &v1.SecretEnvSource{
0000000000000000000000000000000000000000;;							LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Containers[*].EnvFrom[*].SecretRef"}}}},
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{{
0000000000000000000000000000000000000000;;						ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;							SecretKeyRef: &v1.SecretKeySelector{
0000000000000000000000000000000000000000;;								LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: "Spec.Containers[*].Env[*].ValueFrom.SecretKeyRef"}}}}}}},
0000000000000000000000000000000000000000;;				ImagePullSecrets: []v1.LocalObjectReference{{
0000000000000000000000000000000000000000;;					Name: "Spec.ImagePullSecrets"}},
0000000000000000000000000000000000000000;;				InitContainers: []v1.Container{{
0000000000000000000000000000000000000000;;					EnvFrom: []v1.EnvFromSource{{
0000000000000000000000000000000000000000;;						SecretRef: &v1.SecretEnvSource{
0000000000000000000000000000000000000000;;							LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.InitContainers[*].EnvFrom[*].SecretRef"}}}},
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{{
0000000000000000000000000000000000000000;;						ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;							SecretKeyRef: &v1.SecretKeySelector{
0000000000000000000000000000000000000000;;								LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: "Spec.InitContainers[*].Env[*].ValueFrom.SecretKeyRef"}}}}}}},
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{{
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						AzureFile: &v1.AzureFileVolumeSource{
0000000000000000000000000000000000000000;;							SecretName: "Spec.Volumes[*].VolumeSource.AzureFile.SecretName"}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						CephFS: &v1.CephFSVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.CephFS.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						FlexVolume: &v1.FlexVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.FlexVolume.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						Projected: &v1.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;							Sources: []v1.VolumeProjection{{
0000000000000000000000000000000000000000;;								Secret: &v1.SecretProjection{
0000000000000000000000000000000000000000;;									LocalObjectReference: v1.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: "Spec.Volumes[*].VolumeSource.Projected.Sources[*].Secret"}}}}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.RBD.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;							SecretName: "Spec.Volumes[*].VolumeSource.Secret.SecretName"}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;							SecretName: "Spec.Volumes[*].VolumeSource.Secret"}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						ScaleIO: &v1.ScaleIOVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.ScaleIO.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						ISCSI: &v1.ISCSIVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.ISCSI.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;						StorageOS: &v1.StorageOSVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.StorageOS.SecretRef"}}}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extractedNames := sets.NewString()
0000000000000000000000000000000000000000;;		VisitPodSecretNames(pod, func(name string) bool {
0000000000000000000000000000000000000000;;			extractedNames.Insert(name)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// excludedSecretPaths holds struct paths to fields with "secret" in the name that are not actually references to secret API objects
0000000000000000000000000000000000000000;;		excludedSecretPaths := sets.NewString(
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.CephFS.SecretFile",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// expectedSecretPaths holds struct paths to fields with "secret" in the name that are references to secret API objects.
0000000000000000000000000000000000000000;;		// every path here should be represented as an example in the Pod stub above, with the secret name set to the path.
0000000000000000000000000000000000000000;;		expectedSecretPaths := sets.NewString(
0000000000000000000000000000000000000000;;			"Spec.Containers[*].EnvFrom[*].SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Containers[*].Env[*].ValueFrom.SecretKeyRef",
0000000000000000000000000000000000000000;;			"Spec.ImagePullSecrets",
0000000000000000000000000000000000000000;;			"Spec.InitContainers[*].EnvFrom[*].SecretRef",
0000000000000000000000000000000000000000;;			"Spec.InitContainers[*].Env[*].ValueFrom.SecretKeyRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.AzureFile.SecretName",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.CephFS.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.FlexVolume.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.Projected.Sources[*].Secret",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.RBD.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.Secret",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.Secret.SecretName",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.ScaleIO.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.ISCSI.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.StorageOS.SecretRef",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		secretPaths := collectSecretPaths(t, nil, "", reflect.TypeOf(&v1.Pod{}))
0000000000000000000000000000000000000000;;		secretPaths = secretPaths.Difference(excludedSecretPaths)
0000000000000000000000000000000000000000;;		if missingPaths := expectedSecretPaths.Difference(secretPaths); len(missingPaths) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Missing expected secret paths:\n%s", strings.Join(missingPaths.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Missing expected secret paths. Verify VisitPodSecretNames() is correctly finding the missing paths, then correct expectedSecretPaths")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraPaths := secretPaths.Difference(expectedSecretPaths); len(extraPaths) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Extra secret paths:\n%s", strings.Join(extraPaths.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Extra fields with 'secret' in the name found. Verify VisitPodSecretNames() is including these fields if appropriate, then correct expectedSecretPaths")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if missingNames := expectedSecretPaths.Difference(extractedNames); len(missingNames) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Missing expected secret names:\n%s", strings.Join(missingNames.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Missing expected secret names. Verify the pod stub above includes these references, then verify VisitPodSecretNames() is correctly finding the missing names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraNames := extractedNames.Difference(expectedSecretPaths); len(extraNames) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Extra secret names:\n%s", strings.Join(extraNames.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Extra secret names extracted. Verify VisitPodSecretNames() is correctly extracting secret names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// collectSecretPaths traverses the object, computing all the struct paths that lead to fields with "secret" in the name.
0000000000000000000000000000000000000000;;	func collectSecretPaths(t *testing.T, path *field.Path, name string, tp reflect.Type) sets.String {
0000000000000000000000000000000000000000;;		secretPaths := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tp.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path, name, tp.Elem()).List()...)
0000000000000000000000000000000000000000;;			return secretPaths
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.Contains(strings.ToLower(name), "secret") {
0000000000000000000000000000000000000000;;			secretPaths.Insert(path.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tp.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path, name, tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < tp.NumField(); i++ {
0000000000000000000000000000000000000000;;				field := tp.Field(i)
0000000000000000000000000000000000000000;;				secretPaths.Insert(collectSecretPaths(t, path.Child(field.Name), field.Name, field.Type).List()...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			t.Errorf("cannot find secret fields in interface{} field %s", path.String())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path.Key("*"), "", tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path.Key("*"), "", tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// all primitive types
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return secretPaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(now metav1.Time, ready bool, beforeSec int) *v1.Pod {
0000000000000000000000000000000000000000;;		conditionStatus := v1.ConditionFalse
0000000000000000000000000000000000000000;;		if ready {
0000000000000000000000000000000000000000;;			conditionStatus = v1.ConditionTrue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Conditions: []v1.PodCondition{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:               v1.PodReady,
0000000000000000000000000000000000000000;;						LastTransitionTime: metav1.NewTime(now.Time.Add(-1 * time.Duration(beforeSec) * time.Second)),
0000000000000000000000000000000000000000;;						Status:             conditionStatus,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsPodAvailable(t *testing.T) {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			pod             *v1.Pod
0000000000000000000000000000000000000000;;			minReadySeconds int32
0000000000000000000000000000000000000000;;			expected        bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:             newPod(now, false, 0),
0000000000000000000000000000000000000000;;				minReadySeconds: 0,
0000000000000000000000000000000000000000;;				expected:        false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:             newPod(now, true, 0),
0000000000000000000000000000000000000000;;				minReadySeconds: 1,
0000000000000000000000000000000000000000;;				expected:        false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:             newPod(now, true, 0),
0000000000000000000000000000000000000000;;				minReadySeconds: 0,
0000000000000000000000000000000000000000;;				expected:        true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				pod:             newPod(now, true, 51),
0000000000000000000000000000000000000000;;				minReadySeconds: 50,
0000000000000000000000000000000000000000;;				expected:        true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			isAvailable := IsPodAvailable(test.pod, test.minReadySeconds, now)
0000000000000000000000000000000000000000;;			if isAvailable != test.expected {
0000000000000000000000000000000000000000;;				t.Errorf("[tc #%d] expected available pod: %t, got: %t", i, test.expected, isAvailable)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetInitContainersStatusesAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		testStatuses := []v1.ContainerStatus{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value, _ := json.Marshal(testStatuses)
0000000000000000000000000000000000000000;;		testAnnotation := string(value)
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			pod         *v1.Pod
0000000000000000000000000000000000000000;;			annotations map[string]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Populate annotations from status",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						InitContainerStatuses: testStatuses,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					v1.PodInitContainerStatusesAnnotationKey:     testAnnotation,
0000000000000000000000000000000000000000;;					v1.PodInitContainerStatusesBetaAnnotationKey: testAnnotation,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Clear annotations if no status",
0000000000000000000000000000000000000000;;				pod: &v1.Pod{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							v1.PodInitContainerStatusesAnnotationKey:     testAnnotation,
0000000000000000000000000000000000000000;;							v1.PodInitContainerStatusesBetaAnnotationKey: testAnnotation,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Status: v1.PodStatus{
0000000000000000000000000000000000000000;;						InitContainerStatuses: []v1.ContainerStatus{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				annotations: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			SetInitContainersStatusesAnnotations(test.pod)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.pod.Annotations, test.annotations) {
0000000000000000000000000000000000000000;;				t.Errorf("%v, actual = %v, expected = %v", test.name, test.pod.Annotations, test.annotations)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
