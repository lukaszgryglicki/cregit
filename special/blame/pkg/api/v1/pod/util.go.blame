0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPort locates the container port for the given pod and portName.  If the
0000000000000000000000000000000000000000;;	// targetPort is a number, use that.  If the targetPort is a string, look that
0000000000000000000000000000000000000000;;	// string up in all named ports in all containers in the target pod.  If no
0000000000000000000000000000000000000000;;	// match is found, fail.
0000000000000000000000000000000000000000;;	func FindPort(pod *v1.Pod, svcPort *v1.ServicePort) (int, error) {
0000000000000000000000000000000000000000;;		portName := svcPort.TargetPort
0000000000000000000000000000000000000000;;		switch portName.Type {
0000000000000000000000000000000000000000;;		case intstr.String:
0000000000000000000000000000000000000000;;			name := portName.StrVal
0000000000000000000000000000000000000000;;			for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;				for _, port := range container.Ports {
0000000000000000000000000000000000000000;;					if port.Name == name && port.Protocol == svcPort.Protocol {
0000000000000000000000000000000000000000;;						return int(port.ContainerPort), nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case intstr.Int:
0000000000000000000000000000000000000000;;			return portName.IntValue(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("no suitable port for manifest: %s", pod.UID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove this function when init containers becomes a stable feature
0000000000000000000000000000000000000000;;	func SetInitContainersAndStatuses(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		var initContainersAnnotation string
0000000000000000000000000000000000000000;;		initContainersAnnotation = pod.Annotations[v1.PodInitContainersAnnotationKey]
0000000000000000000000000000000000000000;;		initContainersAnnotation = pod.Annotations[v1.PodInitContainersBetaAnnotationKey]
0000000000000000000000000000000000000000;;		if len(initContainersAnnotation) > 0 {
0000000000000000000000000000000000000000;;			var values []v1.Container
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(initContainersAnnotation), &values); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Spec.InitContainers = values
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var initContainerStatusesAnnotation string
0000000000000000000000000000000000000000;;		initContainerStatusesAnnotation = pod.Annotations[v1.PodInitContainerStatusesAnnotationKey]
0000000000000000000000000000000000000000;;		initContainerStatusesAnnotation = pod.Annotations[v1.PodInitContainerStatusesBetaAnnotationKey]
0000000000000000000000000000000000000000;;		if len(initContainerStatusesAnnotation) > 0 {
0000000000000000000000000000000000000000;;			var values []v1.ContainerStatus
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(initContainerStatusesAnnotation), &values); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Status.InitContainerStatuses = values
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove this function when init containers becomes a stable feature
0000000000000000000000000000000000000000;;	func SetInitContainersAnnotations(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if len(pod.Spec.InitContainers) > 0 {
0000000000000000000000000000000000000000;;			value, err := json.Marshal(pod.Spec.InitContainers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.Annotations == nil {
0000000000000000000000000000000000000000;;				pod.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Annotations[v1.PodInitContainersAnnotationKey] = string(value)
0000000000000000000000000000000000000000;;			pod.Annotations[v1.PodInitContainersBetaAnnotationKey] = string(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove this function when init containers becomes a stable feature
0000000000000000000000000000000000000000;;	func SetInitContainersStatusesAnnotations(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if len(pod.Status.InitContainerStatuses) > 0 {
0000000000000000000000000000000000000000;;			value, err := json.Marshal(pod.Status.InitContainerStatuses)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.Annotations == nil {
0000000000000000000000000000000000000000;;				pod.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Annotations[v1.PodInitContainerStatusesAnnotationKey] = string(value)
0000000000000000000000000000000000000000;;			pod.Annotations[v1.PodInitContainerStatusesBetaAnnotationKey] = string(value)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			delete(pod.Annotations, v1.PodInitContainerStatusesAnnotationKey)
0000000000000000000000000000000000000000;;			delete(pod.Annotations, v1.PodInitContainerStatusesBetaAnnotationKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visitor is called with each object name, and returns true if visiting should continue
0000000000000000000000000000000000000000;;	type Visitor func(name string) (shouldContinue bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitPodSecretNames invokes the visitor function with the name of every secret
0000000000000000000000000000000000000000;;	// referenced by the pod spec. If visitor returns false, visiting is short-circuited.
0000000000000000000000000000000000000000;;	// Transitive references (e.g. pod -> pvc -> pv -> secret) are not visited.
0000000000000000000000000000000000000000;;	// Returns true if visiting completed, false if visiting was short-circuited.
0000000000000000000000000000000000000000;;	func VisitPodSecretNames(pod *v1.Pod, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for _, reference := range pod.Spec.ImagePullSecrets {
0000000000000000000000000000000000000000;;			if !visitor(reference.Name) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if !visitContainerSecretNames(&pod.Spec.InitContainers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if !visitContainerSecretNames(&pod.Spec.Containers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var source *v1.VolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			source = &pod.Spec.Volumes[i].VolumeSource
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case source.AzureFile != nil:
0000000000000000000000000000000000000000;;				if len(source.AzureFile.SecretName) > 0 && !visitor(source.AzureFile.SecretName) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.CephFS != nil:
0000000000000000000000000000000000000000;;				if source.CephFS.SecretRef != nil && !visitor(source.CephFS.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.FlexVolume != nil:
0000000000000000000000000000000000000000;;				if source.FlexVolume.SecretRef != nil && !visitor(source.FlexVolume.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.Projected != nil:
0000000000000000000000000000000000000000;;				for j := range source.Projected.Sources {
0000000000000000000000000000000000000000;;					if source.Projected.Sources[j].Secret != nil {
0000000000000000000000000000000000000000;;						if !visitor(source.Projected.Sources[j].Secret.Name) {
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.RBD != nil:
0000000000000000000000000000000000000000;;				if source.RBD.SecretRef != nil && !visitor(source.RBD.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.Secret != nil:
0000000000000000000000000000000000000000;;				if !visitor(source.Secret.SecretName) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.ScaleIO != nil:
0000000000000000000000000000000000000000;;				if source.ScaleIO.SecretRef != nil && !visitor(source.ScaleIO.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.ISCSI != nil:
0000000000000000000000000000000000000000;;				if source.ISCSI.SecretRef != nil && !visitor(source.ISCSI.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.StorageOS != nil:
0000000000000000000000000000000000000000;;				if source.StorageOS.SecretRef != nil && !visitor(source.StorageOS.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func visitContainerSecretNames(container *v1.Container, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for _, env := range container.EnvFrom {
0000000000000000000000000000000000000000;;			if env.SecretRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(env.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, envVar := range container.Env {
0000000000000000000000000000000000000000;;			if envVar.ValueFrom != nil && envVar.ValueFrom.SecretKeyRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(envVar.ValueFrom.SecretKeyRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitPodConfigmapNames invokes the visitor function with the name of every configmap
0000000000000000000000000000000000000000;;	// referenced by the pod spec. If visitor returns false, visiting is short-circuited.
0000000000000000000000000000000000000000;;	// Transitive references (e.g. pod -> pvc -> pv -> secret) are not visited.
0000000000000000000000000000000000000000;;	// Returns true if visiting completed, false if visiting was short-circuited.
0000000000000000000000000000000000000000;;	func VisitPodConfigmapNames(pod *v1.Pod, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if !visitContainerConfigmapNames(&pod.Spec.InitContainers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if !visitContainerConfigmapNames(&pod.Spec.Containers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var source *v1.VolumeSource
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			source = &pod.Spec.Volumes[i].VolumeSource
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case source.Projected != nil:
0000000000000000000000000000000000000000;;				for j := range source.Projected.Sources {
0000000000000000000000000000000000000000;;					if source.Projected.Sources[j].ConfigMap != nil {
0000000000000000000000000000000000000000;;						if !visitor(source.Projected.Sources[j].ConfigMap.Name) {
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.ConfigMap != nil:
0000000000000000000000000000000000000000;;				if !visitor(source.ConfigMap.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func visitContainerConfigmapNames(container *v1.Container, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for _, env := range container.EnvFrom {
0000000000000000000000000000000000000000;;			if env.ConfigMapRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(env.ConfigMapRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, envVar := range container.Env {
0000000000000000000000000000000000000000;;			if envVar.ValueFrom != nil && envVar.ValueFrom.ConfigMapKeyRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(envVar.ValueFrom.ConfigMapKeyRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetContainerStatus extracts the status of container "name" from "statuses".
0000000000000000000000000000000000000000;;	// It also returns if "name" exists.
0000000000000000000000000000000000000000;;	func GetContainerStatus(statuses []v1.ContainerStatus, name string) (v1.ContainerStatus, bool) {
0000000000000000000000000000000000000000;;		for i := range statuses {
0000000000000000000000000000000000000000;;			if statuses[i].Name == name {
0000000000000000000000000000000000000000;;				return statuses[i], true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExistingContainerStatus extracts the status of container "name" from "statuses",
0000000000000000000000000000000000000000;;	// and returns empty status if "name" does not exist.
0000000000000000000000000000000000000000;;	func GetExistingContainerStatus(statuses []v1.ContainerStatus, name string) v1.ContainerStatus {
0000000000000000000000000000000000000000;;		for i := range statuses {
0000000000000000000000000000000000000000;;			if statuses[i].Name == name {
0000000000000000000000000000000000000000;;				return statuses[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v1.ContainerStatus{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPodAvailable returns true if a pod is available; false otherwise.
0000000000000000000000000000000000000000;;	// Precondition for an available pod is that it must be ready. On top
0000000000000000000000000000000000000000;;	// of that, there are two cases when a pod can be considered available:
0000000000000000000000000000000000000000;;	// 1. minReadySeconds == 0, or
0000000000000000000000000000000000000000;;	// 2. LastTransitionTime (is set) + minReadySeconds < current time
0000000000000000000000000000000000000000;;	func IsPodAvailable(pod *v1.Pod, minReadySeconds int32, now metav1.Time) bool {
0000000000000000000000000000000000000000;;		if !IsPodReady(pod) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := GetPodReadyCondition(pod.Status)
0000000000000000000000000000000000000000;;		minReadySecondsDuration := time.Duration(minReadySeconds) * time.Second
0000000000000000000000000000000000000000;;		if minReadySeconds == 0 || !c.LastTransitionTime.IsZero() && c.LastTransitionTime.Add(minReadySecondsDuration).Before(now.Time) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPodReady returns true if a pod is ready; false otherwise.
0000000000000000000000000000000000000000;;	func IsPodReady(pod *v1.Pod) bool {
0000000000000000000000000000000000000000;;		return IsPodReadyConditionTrue(pod.Status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPodReady retruns true if a pod is ready; false otherwise.
0000000000000000000000000000000000000000;;	func IsPodReadyConditionTrue(status v1.PodStatus) bool {
0000000000000000000000000000000000000000;;		condition := GetPodReadyCondition(status)
0000000000000000000000000000000000000000;;		return condition != nil && condition.Status == v1.ConditionTrue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extracts the pod ready condition from the given status and returns that.
0000000000000000000000000000000000000000;;	// Returns nil if the condition is not present.
0000000000000000000000000000000000000000;;	func GetPodReadyCondition(status v1.PodStatus) *v1.PodCondition {
0000000000000000000000000000000000000000;;		_, condition := GetPodCondition(&status, v1.PodReady)
0000000000000000000000000000000000000000;;		return condition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodCondition extracts the provided condition from the given status and returns that.
0000000000000000000000000000000000000000;;	// Returns nil and -1 if the condition is not present, and the index of the located condition.
0000000000000000000000000000000000000000;;	func GetPodCondition(status *v1.PodStatus, conditionType v1.PodConditionType) (int, *v1.PodCondition) {
0000000000000000000000000000000000000000;;		if status == nil {
0000000000000000000000000000000000000000;;			return -1, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range status.Conditions {
0000000000000000000000000000000000000000;;			if status.Conditions[i].Type == conditionType {
0000000000000000000000000000000000000000;;				return i, &status.Conditions[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Updates existing pod condition or creates a new one. Sets LastTransitionTime to now if the
0000000000000000000000000000000000000000;;	// status has changed.
0000000000000000000000000000000000000000;;	// Returns true if pod condition has changed or has been added.
0000000000000000000000000000000000000000;;	func UpdatePodCondition(status *v1.PodStatus, condition *v1.PodCondition) bool {
0000000000000000000000000000000000000000;;		condition.LastTransitionTime = metav1.Now()
0000000000000000000000000000000000000000;;		// Try to find this pod condition.
0000000000000000000000000000000000000000;;		conditionIndex, oldCondition := GetPodCondition(status, condition.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldCondition == nil {
0000000000000000000000000000000000000000;;			// We are adding new pod condition.
0000000000000000000000000000000000000000;;			status.Conditions = append(status.Conditions, *condition)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We are updating an existing condition, so we need to check if it has changed.
0000000000000000000000000000000000000000;;			if condition.Status == oldCondition.Status {
0000000000000000000000000000000000000000;;				condition.LastTransitionTime = oldCondition.LastTransitionTime
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isEqual := condition.Status == oldCondition.Status &&
0000000000000000000000000000000000000000;;				condition.Reason == oldCondition.Reason &&
0000000000000000000000000000000000000000;;				condition.Message == oldCondition.Message &&
0000000000000000000000000000000000000000;;				condition.LastProbeTime.Equal(oldCondition.LastProbeTime) &&
0000000000000000000000000000000000000000;;				condition.LastTransitionTime.Equal(oldCondition.LastTransitionTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status.Conditions[conditionIndex] = *condition
0000000000000000000000000000000000000000;;			// Return true if one of the fields have changed.
0000000000000000000000000000000000000000;;			return !isEqual
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
