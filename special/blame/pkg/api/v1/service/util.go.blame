0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		netsets "k8s.io/kubernetes/pkg/util/net/sets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultLoadBalancerSourceRanges = "0.0.0.0/0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAllowAll checks whether the netsets.IPNet allows traffic from 0.0.0.0/0
0000000000000000000000000000000000000000;;	func IsAllowAll(ipnets netsets.IPNet) bool {
0000000000000000000000000000000000000000;;		for _, s := range ipnets.StringSlice() {
0000000000000000000000000000000000000000;;			if s == "0.0.0.0/0" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLoadBalancerSourceRanges first try to parse and verify LoadBalancerSourceRanges field from a service.
0000000000000000000000000000000000000000;;	// If the field is not specified, turn to parse and verify the AnnotationLoadBalancerSourceRangesKey annotation from a service,
0000000000000000000000000000000000000000;;	// extracting the source ranges to allow, and if not present returns a default (allow-all) value.
0000000000000000000000000000000000000000;;	func GetLoadBalancerSourceRanges(service *v1.Service) (netsets.IPNet, error) {
0000000000000000000000000000000000000000;;		var ipnets netsets.IPNet
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// if SourceRange field is specified, ignore sourceRange annotation
0000000000000000000000000000000000000000;;		if len(service.Spec.LoadBalancerSourceRanges) > 0 {
0000000000000000000000000000000000000000;;			specs := service.Spec.LoadBalancerSourceRanges
0000000000000000000000000000000000000000;;			ipnets, err = netsets.ParseIPNets(specs...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("service.Spec.LoadBalancerSourceRanges: %v is not valid. Expecting a list of IP ranges. For example, 10.0.0.0/24. Error msg: %v", specs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			val := service.Annotations[v1.AnnotationLoadBalancerSourceRangesKey]
0000000000000000000000000000000000000000;;			val = strings.TrimSpace(val)
0000000000000000000000000000000000000000;;			if val == "" {
0000000000000000000000000000000000000000;;				val = defaultLoadBalancerSourceRanges
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			specs := strings.Split(val, ",")
0000000000000000000000000000000000000000;;			ipnets, err = netsets.ParseIPNets(specs...)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%s: %s is not valid. Expecting a comma-separated list of source IP ranges. For example, 10.0.0.0/24,192.168.2.0/24", v1.AnnotationLoadBalancerSourceRangesKey, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ipnets, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestsOnlyLocalTraffic checks if service requests OnlyLocal traffic.
0000000000000000000000000000000000000000;;	func RequestsOnlyLocalTraffic(service *v1.Service) bool {
0000000000000000000000000000000000000000;;		if service.Spec.Type != v1.ServiceTypeLoadBalancer &&
0000000000000000000000000000000000000000;;			service.Spec.Type != v1.ServiceTypeNodePort {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First check the beta annotation and then the first class field. This is so that
0000000000000000000000000000000000000000;;		// existing Services continue to work till the user decides to transition to the
0000000000000000000000000000000000000000;;		// first class field.
0000000000000000000000000000000000000000;;		if l, ok := service.Annotations[v1.BetaAnnotationExternalTraffic]; ok {
0000000000000000000000000000000000000000;;			switch l {
0000000000000000000000000000000000000000;;			case v1.AnnotationValueExternalTrafficLocal:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case v1.AnnotationValueExternalTrafficGlobal:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				glog.Errorf("Invalid value for annotation %v: %v", v1.BetaAnnotationExternalTraffic, l)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service.Spec.ExternalTrafficPolicy == v1.ServiceExternalTrafficPolicyTypeLocal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeedsHealthCheck Check if service needs health check.
0000000000000000000000000000000000000000;;	func NeedsHealthCheck(service *v1.Service) bool {
0000000000000000000000000000000000000000;;		if service.Spec.Type != v1.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RequestsOnlyLocalTraffic(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetServiceHealthCheckNodePort Return health check node port for service, if one exists
0000000000000000000000000000000000000000;;	func GetServiceHealthCheckNodePort(service *v1.Service) int32 {
0000000000000000000000000000000000000000;;		// First check the beta annotation and then the first class field. This is so that
0000000000000000000000000000000000000000;;		// existing Services continue to work till the user decides to transition to the
0000000000000000000000000000000000000000;;		// first class field.
0000000000000000000000000000000000000000;;		if l, ok := service.Annotations[v1.BetaAnnotationHealthCheckNodePort]; ok {
0000000000000000000000000000000000000000;;			p, err := strconv.Atoi(l)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to parse annotation %v: %v", v1.BetaAnnotationHealthCheckNodePort, err)
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int32(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service.Spec.HealthCheckNodePort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearExternalTrafficPolicy resets the ExternalTrafficPolicy field.
0000000000000000000000000000000000000000;;	func ClearExternalTrafficPolicy(service *v1.Service) {
0000000000000000000000000000000000000000;;		// First check the beta annotation and then the first class field. This is so existing
0000000000000000000000000000000000000000;;		// Services continue to work till the user decides to transition to the first class field.
0000000000000000000000000000000000000000;;		if _, ok := service.Annotations[v1.BetaAnnotationExternalTraffic]; ok {
0000000000000000000000000000000000000000;;			delete(service.Annotations, v1.BetaAnnotationExternalTraffic)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service.Spec.ExternalTrafficPolicy = v1.ServiceExternalTrafficPolicyType("")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetServiceHealthCheckNodePort sets the given health check node port on service.
0000000000000000000000000000000000000000;;	// It does not check whether this service needs healthCheckNodePort.
0000000000000000000000000000000000000000;;	func SetServiceHealthCheckNodePort(service *v1.Service, hcNodePort int32) {
0000000000000000000000000000000000000000;;		// First check the beta annotation and then the first class field. This is so that
0000000000000000000000000000000000000000;;		// existing Services continue to work till the user decides to transition to the
0000000000000000000000000000000000000000;;		// first class field.
0000000000000000000000000000000000000000;;		if _, ok := service.Annotations[v1.BetaAnnotationExternalTraffic]; ok {
0000000000000000000000000000000000000000;;			if hcNodePort == 0 {
0000000000000000000000000000000000000000;;				delete(service.Annotations, v1.BetaAnnotationHealthCheckNodePort)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				service.Annotations[v1.BetaAnnotationHealthCheckNodePort] = fmt.Sprintf("%d", hcNodePort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service.Spec.HealthCheckNodePort = hcNodePort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetServiceHealthCheckPathPort Return the path and nodePort programmed into the Cloud LB Health Check
0000000000000000000000000000000000000000;;	func GetServiceHealthCheckPathPort(service *v1.Service) (string, int32) {
0000000000000000000000000000000000000000;;		if !NeedsHealthCheck(service) {
0000000000000000000000000000000000000000;;			return "", 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port := GetServiceHealthCheckNodePort(service)
0000000000000000000000000000000000000000;;		if port == 0 {
0000000000000000000000000000000000000000;;			return "", 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "/healthz", port
0000000000000000000000000000000000000000;;	}
