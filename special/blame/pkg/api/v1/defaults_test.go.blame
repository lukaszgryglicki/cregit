0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a0a6ff3e50600118609309ad715f48c98e5c6c73;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func roundTrip(t *testing.T, obj runtime.Object) runtime.Object {
0000000000000000000000000000000000000000;;		codec := api.Codecs.LegacyCodec(v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v\n %#v", err, obj)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2, err := runtime.Decode(codec, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v\nData: %s\nSource: %#v", err, string(data), obj)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj3 := reflect.New(reflect.TypeOf(obj).Elem()).Interface().(runtime.Object)
0000000000000000000000000000000000000000;;		err = api.Scheme.Convert(obj2, obj3, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v\nSource: %#v", err, obj2)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj3
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultReplicationController(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			rc             *v1.ReplicationController
0000000000000000000000000000000000000000;;			expectLabels   bool
0000000000000000000000000000000000000000;;			expectSelector bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				rc: &v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLabels:   true,
0000000000000000000000000000000000000000;;				expectSelector: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				rc: &v1.ReplicationController{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"bar": "foo",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLabels:   false,
0000000000000000000000000000000000000000;;				expectSelector: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				rc: &v1.ReplicationController{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"bar": "foo",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Selector: map[string]string{
0000000000000000000000000000000000000000;;							"some": "other",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLabels:   false,
0000000000000000000000000000000000000000;;				expectSelector: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				rc: &v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Selector: map[string]string{
0000000000000000000000000000000000000000;;							"some": "other",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLabels:   true,
0000000000000000000000000000000000000000;;				expectSelector: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			rc := test.rc
0000000000000000000000000000000000000000;;			obj2 := roundTrip(t, runtime.Object(rc))
0000000000000000000000000000000000000000;;			rc2, ok := obj2.(*v1.ReplicationController)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected object: %v", rc2)
0000000000000000000000000000000000000000;;				t.FailNow()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectSelector != reflect.DeepEqual(rc2.Spec.Selector, rc2.Spec.Template.Labels) {
0000000000000000000000000000000000000000;;				if test.expectSelector {
0000000000000000000000000000000000000000;;					t.Errorf("expected: %v, got: %v", rc2.Spec.Template.Labels, rc2.Spec.Selector)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected equality: %v", rc.Spec.Selector)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectLabels != reflect.DeepEqual(rc2.Labels, rc2.Spec.Template.Labels) {
0000000000000000000000000000000000000000;;				if test.expectLabels {
0000000000000000000000000000000000000000;;					t.Errorf("expected: %v, got: %v", rc2.Spec.Template.Labels, rc2.Labels)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected equality: %v", rc.Labels)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInt(val int32) *int32 {
0000000000000000000000000000000000000000;;		p := new(int32)
0000000000000000000000000000000000000000;;		*p = val
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultReplicationControllerReplicas(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			rc             v1.ReplicationController
0000000000000000000000000000000000000000;;			expectReplicas int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectReplicas: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Replicas: newInt(0),
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectReplicas: 0,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Replicas: newInt(3),
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Labels: map[string]string{
0000000000000000000000000000000000000000;;									"foo": "bar",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectReplicas: 3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			rc := &test.rc
0000000000000000000000000000000000000000;;			obj2 := roundTrip(t, runtime.Object(rc))
0000000000000000000000000000000000000000;;			rc2, ok := obj2.(*v1.ReplicationController)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected object: %v", rc2)
0000000000000000000000000000000000000000;;				t.FailNow()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rc2.Spec.Replicas == nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected nil Replicas")
0000000000000000000000000000000000000000;;			} else if test.expectReplicas != *rc2.Spec.Replicas {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %d replicas, got: %d", test.expectReplicas, *rc2.Spec.Replicas)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InitContainerValidator func(got, expected *v1.Container) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultReplicationControllerInitContainers(t *testing.T) {
0000000000000000000000000000000000000000;;		assertEnvFieldRef := func(got, expected *v1.Container) error {
0000000000000000000000000000000000000000;;			if len(got.Env) != len(expected.Env) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different number of env: got <%v>, expected <%v>", len(got.Env), len(expected.Env))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for j := range got.Env {
0000000000000000000000000000000000000000;;				ge := &got.Env[j]
0000000000000000000000000000000000000000;;				ee := &expected.Env[j]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ge.Name != ee.Name {
0000000000000000000000000000000000000000;;					return fmt.Errorf("different name of env: got <%v>, expected <%v>", ge.Name, ee.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ge.ValueFrom.FieldRef.APIVersion != ee.ValueFrom.FieldRef.APIVersion {
0000000000000000000000000000000000000000;;					return fmt.Errorf("different api version of FieldRef <%v>: got <%v>, expected <%v>",
0000000000000000000000000000000000000000;;						ge.Name, ge.ValueFrom.FieldRef.APIVersion, ee.ValueFrom.FieldRef.APIVersion)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertImagePullPolicy := func(got, expected *v1.Container) error {
0000000000000000000000000000000000000000;;			if got.ImagePullPolicy != expected.ImagePullPolicy {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different image pull poicy: got <%v>, expected <%v>", got.ImagePullPolicy, expected.ImagePullPolicy)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertContainerPort := func(got, expected *v1.Container) error {
0000000000000000000000000000000000000000;;			if len(got.Ports) != len(expected.Ports) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different number of ports: got <%v>, expected <%v>", len(got.Ports), len(expected.Ports))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range got.Ports {
0000000000000000000000000000000000000000;;				gp := &got.Ports[i]
0000000000000000000000000000000000000000;;				ep := &expected.Ports[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if gp.Name != ep.Name {
0000000000000000000000000000000000000000;;					return fmt.Errorf("different name of port: got <%v>, expected <%v>", gp.Name, ep.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if gp.Protocol != ep.Protocol {
0000000000000000000000000000000000000000;;					return fmt.Errorf("different port protocol <%v>: got <%v>, expected <%v>", gp.Name, gp.Protocol, ep.Protocol)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertResource := func(got, expected *v1.Container) error {
0000000000000000000000000000000000000000;;			if len(got.Resources.Limits) != len(expected.Resources.Limits) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different number of resources.Limits: got <%v>, expected <%v>", len(got.Resources.Limits), (expected.Resources.Limits))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, v := range got.Resources.Limits {
0000000000000000000000000000000000000000;;				if ev, found := expected.Resources.Limits[v1.ResourceName(k)]; !found {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to find resource <%v> in expected resources.Limits.", k)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if ev.Value() != v.Value() {
0000000000000000000000000000000000000000;;						return fmt.Errorf("different resource.Limits: got <%v>, expected <%v>.", v.Value(), ev.Value())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(got.Resources.Requests) != len(expected.Resources.Requests) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different number of resources.Requests: got <%v>, expected <%v>", len(got.Resources.Requests), (expected.Resources.Requests))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, v := range got.Resources.Requests {
0000000000000000000000000000000000000000;;				if ev, found := expected.Resources.Requests[v1.ResourceName(k)]; !found {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to find resource <%v> in expected resources.Requests.", k)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if ev.Value() != v.Value() {
0000000000000000000000000000000000000000;;						return fmt.Errorf("different resource.Requests: got <%v>, expected <%v>.", v.Value(), ev.Value())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertProb := func(got, expected *v1.Container) error {
0000000000000000000000000000000000000000;;			// Assert LivenessProbe
0000000000000000000000000000000000000000;;			if got.LivenessProbe.Handler.HTTPGet.Path != expected.LivenessProbe.Handler.HTTPGet.Path ||
0000000000000000000000000000000000000000;;				got.LivenessProbe.Handler.HTTPGet.Scheme != expected.LivenessProbe.Handler.HTTPGet.Scheme ||
0000000000000000000000000000000000000000;;				got.LivenessProbe.FailureThreshold != expected.LivenessProbe.FailureThreshold ||
0000000000000000000000000000000000000000;;				got.LivenessProbe.SuccessThreshold != expected.LivenessProbe.SuccessThreshold ||
0000000000000000000000000000000000000000;;				got.LivenessProbe.PeriodSeconds != expected.LivenessProbe.PeriodSeconds ||
0000000000000000000000000000000000000000;;				got.LivenessProbe.TimeoutSeconds != expected.LivenessProbe.TimeoutSeconds {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different LivenessProbe: got <%v>, expected <%v>", got.LivenessProbe, expected.LivenessProbe)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assert ReadinessProbe
0000000000000000000000000000000000000000;;			if got.ReadinessProbe.Handler.HTTPGet.Path != expected.ReadinessProbe.Handler.HTTPGet.Path ||
0000000000000000000000000000000000000000;;				got.ReadinessProbe.Handler.HTTPGet.Scheme != expected.ReadinessProbe.Handler.HTTPGet.Scheme ||
0000000000000000000000000000000000000000;;				got.ReadinessProbe.FailureThreshold != expected.ReadinessProbe.FailureThreshold ||
0000000000000000000000000000000000000000;;				got.ReadinessProbe.SuccessThreshold != expected.ReadinessProbe.SuccessThreshold ||
0000000000000000000000000000000000000000;;				got.ReadinessProbe.PeriodSeconds != expected.ReadinessProbe.PeriodSeconds ||
0000000000000000000000000000000000000000;;				got.ReadinessProbe.TimeoutSeconds != expected.ReadinessProbe.TimeoutSeconds {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different ReadinessProbe: got <%v>, expected <%v>", got.ReadinessProbe, expected.ReadinessProbe)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertLifeCycle := func(got, expected *v1.Container) error {
0000000000000000000000000000000000000000;;			if got.Lifecycle.PostStart.HTTPGet.Path != expected.Lifecycle.PostStart.HTTPGet.Path ||
0000000000000000000000000000000000000000;;				got.Lifecycle.PostStart.HTTPGet.Scheme != expected.Lifecycle.PostStart.HTTPGet.Scheme {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different LifeCycle: got <%v>, expected <%v>", got.Lifecycle, expected.Lifecycle)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpu, _ := resource.ParseQuantity("100Gi")
0000000000000000000000000000000000000000;;		mem, _ := resource.ParseQuantity("100Mi")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name       string
0000000000000000000000000000000000000000;;			rc         v1.ReplicationController
0000000000000000000000000000000000000000;;			expected   []v1.Container
0000000000000000000000000000000000000000;;			validators []InitContainerValidator
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "imagePullIPolicy",
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									"pod.beta.kubernetes.io/init-containers": `
0000000000000000000000000000000000000000;;	                                [
0000000000000000000000000000000000000000;;	                                    {
0000000000000000000000000000000000000000;;	                                        "name": "install",
0000000000000000000000000000000000000000;;	                                        "image": "busybox"
0000000000000000000000000000000000000000;;	                                    }
0000000000000000000000000000000000000000;;	                                ]`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ImagePullPolicy: v1.PullAlways,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				validators: []InitContainerValidator{assertImagePullPolicy},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "FieldRef",
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									"pod.beta.kubernetes.io/init-containers": `
0000000000000000000000000000000000000000;;	                                [
0000000000000000000000000000000000000000;;	                                    {
0000000000000000000000000000000000000000;;	                                    "name": "fun",
0000000000000000000000000000000000000000;;	                                    "image": "alpine",
0000000000000000000000000000000000000000;;	                                    "env": [
0000000000000000000000000000000000000000;;	                                      {
0000000000000000000000000000000000000000;;	                                        "name": "MY_POD_IP",
0000000000000000000000000000000000000000;;	                                        "valueFrom": {
0000000000000000000000000000000000000000;;	                                          "fieldRef": {
0000000000000000000000000000000000000000;;	                                            "apiVersion": "",
0000000000000000000000000000000000000000;;	                                            "fieldPath": "status.podIP"
0000000000000000000000000000000000000000;;	                                          }
0000000000000000000000000000000000000000;;	                                        }
0000000000000000000000000000000000000000;;	                                      }
0000000000000000000000000000000000000000;;	                                    ]
0000000000000000000000000000000000000000;;	                                  }
0000000000000000000000000000000000000000;;	                                ]`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name: "MY_POD_IP",
0000000000000000000000000000000000000000;;								ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;									FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;										APIVersion: "v1",
0000000000000000000000000000000000000000;;										FieldPath:  "status.podIP",
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				validators: []InitContainerValidator{assertEnvFieldRef},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "ContainerPort",
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									"pod.beta.kubernetes.io/init-containers": `
0000000000000000000000000000000000000000;;	                                [
0000000000000000000000000000000000000000;;	                                    {
0000000000000000000000000000000000000000;;	                                    "name": "fun",
0000000000000000000000000000000000000000;;	                                    "image": "alpine",
0000000000000000000000000000000000000000;;	                                    "ports": [
0000000000000000000000000000000000000000;;	                                      {
0000000000000000000000000000000000000000;;	                                        "name": "default"
0000000000000000000000000000000000000000;;	                                      }
0000000000000000000000000000000000000000;;	                                    ]
0000000000000000000000000000000000000000;;	                                  }
0000000000000000000000000000000000000000;;	                                ]`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:     "default",
0000000000000000000000000000000000000000;;								Protocol: v1.ProtocolTCP,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				validators: []InitContainerValidator{assertContainerPort},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Resources",
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									"pod.beta.kubernetes.io/init-containers": `
0000000000000000000000000000000000000000;;	                                [
0000000000000000000000000000000000000000;;	                                  {
0000000000000000000000000000000000000000;;	                                    "name": "fun",
0000000000000000000000000000000000000000;;	                                    "image": "alpine",
0000000000000000000000000000000000000000;;	                                    "resources": {
0000000000000000000000000000000000000000;;	                                        "limits": {
0000000000000000000000000000000000000000;;	                                            "cpu": "100Gi",
0000000000000000000000000000000000000000;;	                                            "memory": "100Mi"
0000000000000000000000000000000000000000;;	                                        },
0000000000000000000000000000000000000000;;	                                        "requests": {
0000000000000000000000000000000000000000;;	                                            "cpu": "100Gi",
0000000000000000000000000000000000000000;;	                                            "memory": "100Mi"
0000000000000000000000000000000000000000;;	                                        }
0000000000000000000000000000000000000000;;	                                    }
0000000000000000000000000000000000000000;;	                                  }
0000000000000000000000000000000000000000;;	                                ]`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;							Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;								v1.ResourceCPU:    cpu,
0000000000000000000000000000000000000000;;								v1.ResourceMemory: mem,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;								v1.ResourceCPU:    cpu,
0000000000000000000000000000000000000000;;								v1.ResourceMemory: mem,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				validators: []InitContainerValidator{assertResource},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "Prob",
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									"pod.beta.kubernetes.io/init-containers": `
0000000000000000000000000000000000000000;;	                                [
0000000000000000000000000000000000000000;;	                                    {
0000000000000000000000000000000000000000;;	                                    "name": "fun",
0000000000000000000000000000000000000000;;	                                    "image": "alpine",
0000000000000000000000000000000000000000;;	                                    "livenessProbe": {
0000000000000000000000000000000000000000;;	                                        "httpGet": {
0000000000000000000000000000000000000000;;	                                            "host": "localhost"
0000000000000000000000000000000000000000;;	                                        }
0000000000000000000000000000000000000000;;	                                    },
0000000000000000000000000000000000000000;;	                                    "readinessProbe": {
0000000000000000000000000000000000000000;;	                                        "httpGet": {
0000000000000000000000000000000000000000;;	                                            "host": "localhost"
0000000000000000000000000000000000000000;;	                                        }
0000000000000000000000000000000000000000;;	                                    }
0000000000000000000000000000000000000000;;	                                  }
0000000000000000000000000000000000000000;;	                                ]`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						LivenessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;							Handler: v1.Handler{
0000000000000000000000000000000000000000;;								HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;									Path:   "/",
0000000000000000000000000000000000000000;;									Scheme: v1.URISchemeHTTP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TimeoutSeconds:   1,
0000000000000000000000000000000000000000;;							PeriodSeconds:    10,
0000000000000000000000000000000000000000;;							SuccessThreshold: 1,
0000000000000000000000000000000000000000;;							FailureThreshold: 3,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						ReadinessProbe: &v1.Probe{
0000000000000000000000000000000000000000;;							Handler: v1.Handler{
0000000000000000000000000000000000000000;;								HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;									Path:   "/",
0000000000000000000000000000000000000000;;									Scheme: v1.URISchemeHTTP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							TimeoutSeconds:   1,
0000000000000000000000000000000000000000;;							PeriodSeconds:    10,
0000000000000000000000000000000000000000;;							SuccessThreshold: 1,
0000000000000000000000000000000000000000;;							FailureThreshold: 3,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				validators: []InitContainerValidator{assertProb},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "LifeCycle",
0000000000000000000000000000000000000000;;				rc: v1.ReplicationController{
0000000000000000000000000000000000000000;;					Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;						Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;							ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									"pod.beta.kubernetes.io/init-containers": `
0000000000000000000000000000000000000000;;	                                [
0000000000000000000000000000000000000000;;	                                    {
0000000000000000000000000000000000000000;;	                                    "name": "fun",
0000000000000000000000000000000000000000;;	                                    "image": "alpine",
0000000000000000000000000000000000000000;;	                                    "lifecycle": {
0000000000000000000000000000000000000000;;	                                        "postStart": {
0000000000000000000000000000000000000000;;	                                            "httpGet": {
0000000000000000000000000000000000000000;;	                                                "host": "localhost"
0000000000000000000000000000000000000000;;	                                            }
0000000000000000000000000000000000000000;;	                                        },
0000000000000000000000000000000000000000;;	                                        "preStop": {
0000000000000000000000000000000000000000;;	                                            "httpGet": {
0000000000000000000000000000000000000000;;	                                                "host": "localhost"
0000000000000000000000000000000000000000;;	                                            }
0000000000000000000000000000000000000000;;	                                        }
0000000000000000000000000000000000000000;;	                                    }
0000000000000000000000000000000000000000;;	                                  }
0000000000000000000000000000000000000000;;	                                ]`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Lifecycle: &v1.Lifecycle{
0000000000000000000000000000000000000000;;							PostStart: &v1.Handler{
0000000000000000000000000000000000000000;;								HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;									Path:   "/",
0000000000000000000000000000000000000000;;									Scheme: v1.URISchemeHTTP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;							PreStop: &v1.Handler{
0000000000000000000000000000000000000000;;								HTTPGet: &v1.HTTPGetAction{
0000000000000000000000000000000000000000;;									Path:   "/",
0000000000000000000000000000000000000000;;									Scheme: v1.URISchemeHTTP,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				validators: []InitContainerValidator{assertLifeCycle},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assertInitContainers := func(got, expected []v1.Container, validators []InitContainerValidator) error {
0000000000000000000000000000000000000000;;			if len(got) != len(expected) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("different number of init container: got <%d>, expected <%d>",
0000000000000000000000000000000000000000;;					len(got), len(expected))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := range got {
0000000000000000000000000000000000000000;;				g := &got[i]
0000000000000000000000000000000000000000;;				e := &expected[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, validator := range validators {
0000000000000000000000000000000000000000;;					if err := validator(g, e); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			rc := &test.rc
0000000000000000000000000000000000000000;;			obj2 := roundTrip(t, runtime.Object(rc))
0000000000000000000000000000000000000000;;			rc2, ok := obj2.(*v1.ReplicationController)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected object: %v", rc2)
0000000000000000000000000000000000000000;;				t.FailNow()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := assertInitContainers(rc2.Spec.Template.Spec.InitContainers, test.expected, test.validators); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("test %v failed: %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultService(t *testing.T) {
0000000000000000000000000000000000000000;;		svc := &v1.Service{}
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(svc))
0000000000000000000000000000000000000000;;		svc2 := obj2.(*v1.Service)
0000000000000000000000000000000000000000;;		if svc2.Spec.SessionAffinity != v1.ServiceAffinityNone {
0000000000000000000000000000000000000000;;			t.Errorf("Expected default session affinity type:%s, got: %s", v1.ServiceAffinityNone, svc2.Spec.SessionAffinity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if svc2.Spec.Type != v1.ServiceTypeClusterIP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected default type:%s, got: %s", v1.ServiceTypeClusterIP, svc2.Spec.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultSecretVolumeSource(t *testing.T) {
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Volumes = []v1.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					Secret: &v1.SecretVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 := output.(*v1.Pod)
0000000000000000000000000000000000000000;;		defaultMode := pod2.Spec.Volumes[0].VolumeSource.Secret.DefaultMode
0000000000000000000000000000000000000000;;		expectedMode := v1.SecretVolumeSourceDefaultMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode == nil || *defaultMode != expectedMode {
0000000000000000000000000000000000000000;;			t.Errorf("Expected secret DefaultMode %v, got %v", expectedMode, defaultMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultConfigMapVolumeSource(t *testing.T) {
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Volumes = []v1.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					ConfigMap: &v1.ConfigMapVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 := output.(*v1.Pod)
0000000000000000000000000000000000000000;;		defaultMode := pod2.Spec.Volumes[0].VolumeSource.ConfigMap.DefaultMode
0000000000000000000000000000000000000000;;		expectedMode := v1.ConfigMapVolumeSourceDefaultMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode == nil || *defaultMode != expectedMode {
0000000000000000000000000000000000000000;;			t.Errorf("Expected v1.ConfigMap DefaultMode %v, got %v", expectedMode, defaultMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultDownwardAPIVolumeSource(t *testing.T) {
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Volumes = []v1.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					DownwardAPI: &v1.DownwardAPIVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 := output.(*v1.Pod)
0000000000000000000000000000000000000000;;		defaultMode := pod2.Spec.Volumes[0].VolumeSource.DownwardAPI.DefaultMode
0000000000000000000000000000000000000000;;		expectedMode := v1.DownwardAPIVolumeSourceDefaultMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode == nil || *defaultMode != expectedMode {
0000000000000000000000000000000000000000;;			t.Errorf("Expected DownwardAPI DefaultMode %v, got %v", expectedMode, defaultMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultProjectedVolumeSource(t *testing.T) {
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Volumes = []v1.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					Projected: &v1.ProjectedVolumeSource{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 := output.(*v1.Pod)
0000000000000000000000000000000000000000;;		defaultMode := pod2.Spec.Volumes[0].VolumeSource.Projected.DefaultMode
0000000000000000000000000000000000000000;;		expectedMode := v1.ProjectedVolumeSourceDefaultMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if defaultMode == nil || *defaultMode != expectedMode {
0000000000000000000000000000000000000000;;			t.Errorf("Expected v1.ProjectedVolumeSource DefaultMode %v, got %v", expectedMode, defaultMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultSecret(t *testing.T) {
0000000000000000000000000000000000000000;;		s := &v1.Secret{}
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(s))
0000000000000000000000000000000000000000;;		s2 := obj2.(*v1.Secret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s2.Type != v1.SecretTypeOpaque {
0000000000000000000000000000000000000000;;			t.Errorf("Expected secret type %v, got %v", v1.SecretTypeOpaque, s2.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultPersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{}
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(pv))
0000000000000000000000000000000000000000;;		pv2 := obj2.(*v1.PersistentVolume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pv2.Status.Phase != v1.VolumePending {
0000000000000000000000000000000000000000;;			t.Errorf("Expected volume phase %v, got %v", v1.VolumePending, pv2.Status.Phase)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv2.Spec.PersistentVolumeReclaimPolicy != v1.PersistentVolumeReclaimRetain {
0000000000000000000000000000000000000000;;			t.Errorf("Expected pv reclaim policy %v, got %v", v1.PersistentVolumeReclaimRetain, pv2.Spec.PersistentVolumeReclaimPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultPersistentVolumeClaim(t *testing.T) {
0000000000000000000000000000000000000000;;		pvc := &v1.PersistentVolumeClaim{}
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(pvc))
0000000000000000000000000000000000000000;;		pvc2 := obj2.(*v1.PersistentVolumeClaim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pvc2.Status.Phase != v1.ClaimPending {
0000000000000000000000000000000000000000;;			t.Errorf("Expected claim phase %v, got %v", v1.ClaimPending, pvc2.Status.Phase)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaulEndpointsProtocol(t *testing.T) {
0000000000000000000000000000000000000000;;		in := &v1.Endpoints{Subsets: []v1.EndpointSubset{
0000000000000000000000000000000000000000;;			{Ports: []v1.EndpointPort{{}, {Protocol: "UDP"}, {}}},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		obj := roundTrip(t, runtime.Object(in))
0000000000000000000000000000000000000000;;		out := obj.(*v1.Endpoints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range out.Subsets {
0000000000000000000000000000000000000000;;			for j := range out.Subsets[i].Ports {
0000000000000000000000000000000000000000;;				if in.Subsets[i].Ports[j].Protocol == "" {
0000000000000000000000000000000000000000;;					if out.Subsets[i].Ports[j].Protocol != v1.ProtocolTCP {
0000000000000000000000000000000000000000;;						t.Errorf("Expected protocol %s, got %s", v1.ProtocolTCP, out.Subsets[i].Ports[j].Protocol)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if out.Subsets[i].Ports[j].Protocol != in.Subsets[i].Ports[j].Protocol {
0000000000000000000000000000000000000000;;						t.Errorf("Expected protocol %s, got %s", in.Subsets[i].Ports[j].Protocol, out.Subsets[i].Ports[j].Protocol)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaulServiceTargetPort(t *testing.T) {
0000000000000000000000000000000000000000;;		in := &v1.Service{Spec: v1.ServiceSpec{Ports: []v1.ServicePort{{Port: 1234}}}}
0000000000000000000000000000000000000000;;		obj := roundTrip(t, runtime.Object(in))
0000000000000000000000000000000000000000;;		out := obj.(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.Ports[0].TargetPort != intstr.FromInt(1234) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected TargetPort to be defaulted, got %v", out.Spec.Ports[0].TargetPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in = &v1.Service{Spec: v1.ServiceSpec{Ports: []v1.ServicePort{{Port: 1234, TargetPort: intstr.FromInt(5678)}}}}
0000000000000000000000000000000000000000;;		obj = roundTrip(t, runtime.Object(in))
0000000000000000000000000000000000000000;;		out = obj.(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.Ports[0].TargetPort != intstr.FromInt(5678) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected TargetPort to be unchanged, got %v", out.Spec.Ports[0].TargetPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultServicePort(t *testing.T) {
0000000000000000000000000000000000000000;;		// Unchanged if set.
0000000000000000000000000000000000000000;;		in := &v1.Service{Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;			Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;				{Protocol: "UDP", Port: 9376, TargetPort: intstr.FromString("p")},
0000000000000000000000000000000000000000;;				{Protocol: "UDP", Port: 8675, TargetPort: intstr.FromInt(309)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		out := roundTrip(t, runtime.Object(in)).(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.Ports[0].Protocol != v1.ProtocolUDP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected protocol %s, got %s", v1.ProtocolUDP, out.Spec.Ports[0].Protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.Spec.Ports[0].TargetPort != intstr.FromString("p") {
0000000000000000000000000000000000000000;;			t.Errorf("Expected port %v, got %v", in.Spec.Ports[0].Port, out.Spec.Ports[0].TargetPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.Spec.Ports[1].Protocol != v1.ProtocolUDP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected protocol %s, got %s", v1.ProtocolUDP, out.Spec.Ports[1].Protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.Spec.Ports[1].TargetPort != intstr.FromInt(309) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected port %v, got %v", in.Spec.Ports[1].Port, out.Spec.Ports[1].TargetPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Defaulted.
0000000000000000000000000000000000000000;;		in = &v1.Service{Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;			Ports: []v1.ServicePort{
0000000000000000000000000000000000000000;;				{Protocol: "", Port: 9376, TargetPort: intstr.FromString("")},
0000000000000000000000000000000000000000;;				{Protocol: "", Port: 8675, TargetPort: intstr.FromInt(0)},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		out = roundTrip(t, runtime.Object(in)).(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.Ports[0].Protocol != v1.ProtocolTCP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected protocol %s, got %s", v1.ProtocolTCP, out.Spec.Ports[0].Protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.Spec.Ports[0].TargetPort != intstr.FromInt(int(in.Spec.Ports[0].Port)) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected port %v, got %v", in.Spec.Ports[0].Port, out.Spec.Ports[0].TargetPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.Spec.Ports[1].Protocol != v1.ProtocolTCP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected protocol %s, got %s", v1.ProtocolTCP, out.Spec.Ports[1].Protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out.Spec.Ports[1].TargetPort != intstr.FromInt(int(in.Spec.Ports[1].Port)) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected port %v, got %v", in.Spec.Ports[1].Port, out.Spec.Ports[1].TargetPort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaulServiceExternalTraffic(t *testing.T) {
0000000000000000000000000000000000000000;;		in := &v1.Service{}
0000000000000000000000000000000000000000;;		obj := roundTrip(t, runtime.Object(in))
0000000000000000000000000000000000000000;;		out := obj.(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.ExternalTrafficPolicy != "" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected ExternalTrafficPolicy to be empty, got %v", out.Spec.ExternalTrafficPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in = &v1.Service{Spec: v1.ServiceSpec{Type: v1.ServiceTypeNodePort}}
0000000000000000000000000000000000000000;;		obj = roundTrip(t, runtime.Object(in))
0000000000000000000000000000000000000000;;		out = obj.(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.ExternalTrafficPolicy != v1.ServiceExternalTrafficPolicyTypeCluster {
0000000000000000000000000000000000000000;;			t.Errorf("Expected ExternalTrafficPolicy to be %v, got %v", v1.ServiceExternalTrafficPolicyTypeCluster, out.Spec.ExternalTrafficPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in = &v1.Service{Spec: v1.ServiceSpec{Type: v1.ServiceTypeLoadBalancer}}
0000000000000000000000000000000000000000;;		obj = roundTrip(t, runtime.Object(in))
0000000000000000000000000000000000000000;;		out = obj.(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.ExternalTrafficPolicy != v1.ServiceExternalTrafficPolicyTypeCluster {
0000000000000000000000000000000000000000;;			t.Errorf("Expected ExternalTrafficPolicy to be %v, got %v", v1.ServiceExternalTrafficPolicyTypeCluster, out.Spec.ExternalTrafficPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in = &v1.Service{
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{Type: v1.ServiceTypeLoadBalancer},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{v1.BetaAnnotationExternalTraffic: v1.AnnotationValueExternalTrafficLocal},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj = roundTrip(t, runtime.Object(in))
0000000000000000000000000000000000000000;;		out = obj.(*v1.Service)
0000000000000000000000000000000000000000;;		if out.Spec.ExternalTrafficPolicy != "" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected ExternalTrafficPolicy to be empty, got %v", out.Spec.ExternalTrafficPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		s := &v1.Namespace{}
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(s))
0000000000000000000000000000000000000000;;		s2 := obj2.(*v1.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s2.Status.Phase != v1.NamespaceActive {
0000000000000000000000000000000000000000;;			t.Errorf("Expected phase %v, got %v", v1.NamespaceActive, s2.Status.Phase)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultPodSpecHostNetwork(t *testing.T) {
0000000000000000000000000000000000000000;;		portNum := int32(8080)
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.HostNetwork = true
0000000000000000000000000000000000000000;;		s.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ContainerPort: portNum,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.InitContainers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Ports: []v1.ContainerPort{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						ContainerPort: portNum,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 := obj2.(*v1.Pod)
0000000000000000000000000000000000000000;;		s2 := pod2.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPortNum := s2.Containers[0].Ports[0].HostPort
0000000000000000000000000000000000000000;;		if hostPortNum != portNum {
0000000000000000000000000000000000000000;;			t.Errorf("Expected container port to be defaulted, was made %d instead of %d", hostPortNum, portNum)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPortNum = s2.InitContainers[0].Ports[0].HostPort
0000000000000000000000000000000000000000;;		if hostPortNum != portNum {
0000000000000000000000000000000000000000;;			t.Errorf("Expected container port to be defaulted, was made %d instead of %d", hostPortNum, portNum)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultNodeExternalID(t *testing.T) {
0000000000000000000000000000000000000000;;		name := "node0"
0000000000000000000000000000000000000000;;		n := &v1.Node{}
0000000000000000000000000000000000000000;;		n.Name = name
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(n))
0000000000000000000000000000000000000000;;		n2 := obj2.(*v1.Node)
0000000000000000000000000000000000000000;;		if n2.Spec.ExternalID != name {
0000000000000000000000000000000000000000;;			t.Errorf("Expected default External ID: %s, got: %s", name, n2.Spec.ExternalID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n2.Spec.ProviderID != "" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected empty default Cloud Provider ID, got: %s", n2.Spec.ProviderID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultNodeStatusAllocatable(t *testing.T) {
0000000000000000000000000000000000000000;;		capacity := v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceCPU:    resource.MustParse("1000m"),
0000000000000000000000000000000000000000;;			v1.ResourceMemory: resource.MustParse("10G"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allocatable := v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceCPU:    resource.MustParse("500m"),
0000000000000000000000000000000000000000;;			v1.ResourceMemory: resource.MustParse("5G"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			capacity            v1.ResourceList
0000000000000000000000000000000000000000;;			allocatable         v1.ResourceList
0000000000000000000000000000000000000000;;			expectedAllocatable v1.ResourceList
0000000000000000000000000000000000000000;;		}{{ // Everything set, no defaulting.
0000000000000000000000000000000000000000;;			capacity:            capacity,
0000000000000000000000000000000000000000;;			allocatable:         allocatable,
0000000000000000000000000000000000000000;;			expectedAllocatable: allocatable,
0000000000000000000000000000000000000000;;		}, { // Allocatable set, no defaulting.
0000000000000000000000000000000000000000;;			capacity:            nil,
0000000000000000000000000000000000000000;;			allocatable:         allocatable,
0000000000000000000000000000000000000000;;			expectedAllocatable: allocatable,
0000000000000000000000000000000000000000;;		}, { // Capacity set, allocatable defaults to capacity.
0000000000000000000000000000000000000000;;			capacity:            capacity,
0000000000000000000000000000000000000000;;			allocatable:         nil,
0000000000000000000000000000000000000000;;			expectedAllocatable: capacity,
0000000000000000000000000000000000000000;;		}, { // Nothing set, allocatable "defaults" to capacity.
0000000000000000000000000000000000000000;;			capacity:            nil,
0000000000000000000000000000000000000000;;			allocatable:         nil,
0000000000000000000000000000000000000000;;			expectedAllocatable: nil,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copyResourceList := func(rl v1.ResourceList) v1.ResourceList {
0000000000000000000000000000000000000000;;			if rl == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy := make(v1.ResourceList, len(rl))
0000000000000000000000000000000000000000;;			for k, v := range rl {
0000000000000000000000000000000000000000;;				copy[k] = *v.Copy()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return copy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceListsEqual := func(a v1.ResourceList, b v1.ResourceList) bool {
0000000000000000000000000000000000000000;;			if len(a) != len(b) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range a {
0000000000000000000000000000000000000000;;				vb, found := b[k]
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.Cmp(vb) != 0 {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testcase := range tests {
0000000000000000000000000000000000000000;;			node := v1.Node{
0000000000000000000000000000000000000000;;				Status: v1.NodeStatus{
0000000000000000000000000000000000000000;;					Capacity:    copyResourceList(testcase.capacity),
0000000000000000000000000000000000000000;;					Allocatable: copyResourceList(testcase.allocatable),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			node2 := roundTrip(t, runtime.Object(&node)).(*v1.Node)
0000000000000000000000000000000000000000;;			actual := node2.Status.Allocatable
0000000000000000000000000000000000000000;;			expected := testcase.expectedAllocatable
0000000000000000000000000000000000000000;;			if !resourceListsEqual(expected, actual) {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] Expected v1.NodeStatus.Allocatable: %+v; Got: %+v", i, expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultObjectFieldSelectorAPIVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		s := v1.PodSpec{
0000000000000000000000000000000000000000;;			Containers: []v1.Container{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Env: []v1.EnvVar{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							ValueFrom: &v1.EnvVarSource{
0000000000000000000000000000000000000000;;								FieldRef: &v1.ObjectFieldSelector{},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2 := roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 := obj2.(*v1.Pod)
0000000000000000000000000000000000000000;;		s2 := pod2.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiVersion := s2.Containers[0].Env[0].ValueFrom.FieldRef.APIVersion
0000000000000000000000000000000000000000;;		if apiVersion != "v1" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected default APIVersion v1, got: %v", apiVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetMinimumScalePod(t *testing.T) {
0000000000000000000000000000000000000000;;		// verify we default if limits are specified (and that request=0 is preserved)
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("1n"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU: resource.MustParse("2n"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.InitContainers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("1n"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU: resource.MustParse("2n"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		k8s_api_v1.SetObjectDefaults_Pod(pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expect := resource.MustParse("1m"); expect.Cmp(pod.Spec.Containers[0].Resources.Requests[v1.ResourceMemory]) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("did not round resources: %#v", pod.Spec.Containers[0].Resources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expect := resource.MustParse("1m"); expect.Cmp(pod.Spec.InitContainers[0].Resources.Requests[v1.ResourceMemory]) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("did not round resources: %#v", pod.Spec.InitContainers[0].Resources)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultRequestsPod(t *testing.T) {
0000000000000000000000000000000000000000;;		// verify we default if limits are specified (and that request=0 is preserved)
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU:    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.InitContainers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("0"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU:    resource.MustParse("100m"),
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("1Gi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 := output.(*v1.Pod)
0000000000000000000000000000000000000000;;		defaultRequest := pod2.Spec.Containers[0].Resources.Requests
0000000000000000000000000000000000000000;;		if requestValue := defaultRequest[v1.ResourceCPU]; requestValue.String() != "100m" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected request cpu: %s, got: %s", "100m", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requestValue := defaultRequest[v1.ResourceMemory]; requestValue.String() != "0" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected request memory: %s, got: %s", "0", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultRequest = pod2.Spec.InitContainers[0].Resources.Requests
0000000000000000000000000000000000000000;;		if requestValue := defaultRequest[v1.ResourceCPU]; requestValue.String() != "100m" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected request cpu: %s, got: %s", "100m", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requestValue := defaultRequest[v1.ResourceMemory]; requestValue.String() != "0" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected request memory: %s, got: %s", "0", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify we do nothing if no limits are specified
0000000000000000000000000000000000000000;;		s = v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Containers = []v1.Container{{}}
0000000000000000000000000000000000000000;;		s.InitContainers = []v1.Container{{}}
0000000000000000000000000000000000000000;;		pod = &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output = roundTrip(t, runtime.Object(pod))
0000000000000000000000000000000000000000;;		pod2 = output.(*v1.Pod)
0000000000000000000000000000000000000000;;		defaultRequest = pod2.Spec.Containers[0].Resources.Requests
0000000000000000000000000000000000000000;;		if requestValue := defaultRequest[v1.ResourceCPU]; requestValue.String() != "0" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 0 request value, got: %s", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultRequest = pod2.Spec.InitContainers[0].Resources.Requests
0000000000000000000000000000000000000000;;		if requestValue := defaultRequest[v1.ResourceCPU]; requestValue.String() != "0" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 0 request value, got: %s", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDefaultRequestIsNotSetForReplicationController(t *testing.T) {
0000000000000000000000000000000000000000;;		s := v1.PodSpec{}
0000000000000000000000000000000000000000;;		s.Containers = []v1.Container{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Limits: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU: resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rc := &v1.ReplicationController{
0000000000000000000000000000000000000000;;			Spec: v1.ReplicationControllerSpec{
0000000000000000000000000000000000000000;;				Replicas: newInt(3),
0000000000000000000000000000000000000000;;				Template: &v1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"foo": "bar",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: s,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(rc))
0000000000000000000000000000000000000000;;		rc2 := output.(*v1.ReplicationController)
0000000000000000000000000000000000000000;;		defaultRequest := rc2.Spec.Template.Spec.Containers[0].Resources.Requests
0000000000000000000000000000000000000000;;		requestValue := defaultRequest[v1.ResourceCPU]
0000000000000000000000000000000000000000;;		if requestValue.String() != "0" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 0 request value, got: %s", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultLimitRangeItem(t *testing.T) {
0000000000000000000000000000000000000000;;		limitRange := &v1.LimitRange{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "test-defaults",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.LimitRangeSpec{
0000000000000000000000000000000000000000;;				Limits: []v1.LimitRangeItem{{
0000000000000000000000000000000000000000;;					Type: v1.LimitTypeContainer,
0000000000000000000000000000000000000000;;					Max: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceCPU: resource.MustParse("100m"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Min: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceMemory: resource.MustParse("100Mi"),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Default:        v1.ResourceList{},
0000000000000000000000000000000000000000;;					DefaultRequest: v1.ResourceList{},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(limitRange))
0000000000000000000000000000000000000000;;		limitRange2 := output.(*v1.LimitRange)
0000000000000000000000000000000000000000;;		defaultLimit := limitRange2.Spec.Limits[0].Default
0000000000000000000000000000000000000000;;		defaultRequest := limitRange2.Spec.Limits[0].DefaultRequest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// verify that default cpu was set to the max
0000000000000000000000000000000000000000;;		defaultValue := defaultLimit[v1.ResourceCPU]
0000000000000000000000000000000000000000;;		if defaultValue.String() != "100m" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected default cpu: %s, got: %s", "100m", defaultValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// verify that default request was set to the limit
0000000000000000000000000000000000000000;;		requestValue := defaultRequest[v1.ResourceCPU]
0000000000000000000000000000000000000000;;		if requestValue.String() != "100m" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected request cpu: %s, got: %s", "100m", requestValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// verify that if a min is provided, it will be the default if no limit is specified
0000000000000000000000000000000000000000;;		requestMinValue := defaultRequest[v1.ResourceMemory]
0000000000000000000000000000000000000000;;		if requestMinValue.String() != "100Mi" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected request memory: %s, got: %s", "100Mi", requestMinValue.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultProbe(t *testing.T) {
0000000000000000000000000000000000000000;;		originalProbe := v1.Probe{}
0000000000000000000000000000000000000000;;		expectedProbe := v1.Probe{
0000000000000000000000000000000000000000;;			InitialDelaySeconds: 0,
0000000000000000000000000000000000000000;;			TimeoutSeconds:      1,
0000000000000000000000000000000000000000;;			PeriodSeconds:       10,
0000000000000000000000000000000000000000;;			SuccessThreshold:    1,
0000000000000000000000000000000000000000;;			FailureThreshold:    3,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{{LivenessProbe: &originalProbe}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(pod)).(*v1.Pod)
0000000000000000000000000000000000000000;;		actualProbe := *output.Spec.Containers[0].LivenessProbe
0000000000000000000000000000000000000000;;		if actualProbe != expectedProbe {
0000000000000000000000000000000000000000;;			t.Errorf("Expected probe: %+v\ngot: %+v\n", expectedProbe, actualProbe)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetDefaultSchedulerName(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := &v1.Pod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := roundTrip(t, runtime.Object(pod)).(*v1.Pod)
0000000000000000000000000000000000000000;;		if output.Spec.SchedulerName != v1.DefaultSchedulerName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected scheduler name: %+v\ngot: %+v\n", v1.DefaultSchedulerName, output.Spec.SchedulerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
