0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6d15848aa5e7ecb5f4de191ae17f65f126f138bd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const isNegativeErrorMsg string = `must be greater than or equal to 0`
0000000000000000000000000000000000000000;;	const isNotIntegerErrorMsg string = `must be an integer`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateResourceRequirements(requirements *v1.ResourceRequirements, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		limPath := fldPath.Child("limits")
0000000000000000000000000000000000000000;;		reqPath := fldPath.Child("requests")
0000000000000000000000000000000000000000;;		for resourceName, quantity := range requirements.Limits {
0000000000000000000000000000000000000000;;			fldPath := limPath.Key(string(resourceName))
0000000000000000000000000000000000000000;;			// Validate resource name.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainerResourceName(string(resourceName), fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Validate resource quantity.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(resourceName), quantity, fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that request <= limit.
0000000000000000000000000000000000000000;;			requestQuantity, exists := requirements.Requests[resourceName]
0000000000000000000000000000000000000000;;			if exists {
0000000000000000000000000000000000000000;;				// For GPUs, not only requests can't exceed limits, they also can't be lower, i.e. must be equal.
0000000000000000000000000000000000000000;;				if resourceName == v1.ResourceNvidiaGPU && quantity.Cmp(requestQuantity) != 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(reqPath, requestQuantity.String(), fmt.Sprintf("must be equal to %s limit", v1.ResourceNvidiaGPU)))
0000000000000000000000000000000000000000;;				} else if quantity.Cmp(requestQuantity) < 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(limPath, quantity.String(), fmt.Sprintf("must be greater than or equal to %s request", resourceName)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for resourceName, quantity := range requirements.Requests {
0000000000000000000000000000000000000000;;			fldPath := reqPath.Key(string(resourceName))
0000000000000000000000000000000000000000;;			// Validate resource name.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainerResourceName(string(resourceName), fldPath)...)
0000000000000000000000000000000000000000;;			// Validate resource quantity.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(resourceName), quantity, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateContainerResourceName(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := validateResourceName(value, fldPath)
0000000000000000000000000000000000000000;;		if len(strings.Split(value, "/")) == 1 {
0000000000000000000000000000000000000000;;			if !helper.IsStandardContainerResourceName(value) {
0000000000000000000000000000000000000000;;				return append(allErrs, field.Invalid(fldPath, value, "must be a standard resource for containers"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return field.ErrorList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateResourceQuantityValue enforces that specified quantity is valid for specified resource
0000000000000000000000000000000000000000;;	func ValidateResourceQuantityValue(resource string, value resource.Quantity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeQuantity(value, fldPath)...)
0000000000000000000000000000000000000000;;		if helper.IsIntegerResourceName(resource) {
0000000000000000000000000000000000000000;;			if value.MilliValue()%int64(1000) != int64(0) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, value, isNotIntegerErrorMsg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates that a Quantity is not negative
0000000000000000000000000000000000000000;;	func ValidateNonnegativeQuantity(value resource.Quantity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if value.Cmp(resource.Quantity{}) < 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value.String(), isNegativeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate compute resource typename.
0000000000000000000000000000000000000000;;	// Refer to docs/design/resources.md for more details.
0000000000000000000000000000000000000000;;	func validateResourceName(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsQualifiedName(value) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allErrs) != 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(strings.Split(value, "/")) == 1 {
0000000000000000000000000000000000000000;;			if !helper.IsStandardResourceName(value) {
0000000000000000000000000000000000000000;;				return append(allErrs, field.Invalid(fldPath, value, "must be a standard resource type or fully qualified"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return field.ErrorList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidatePodLogOptions(opts *v1.PodLogOptions) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if opts.TailLines != nil && *opts.TailLines < 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("tailLines"), *opts.TailLines, isNegativeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.LimitBytes != nil && *opts.LimitBytes < 1 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("limitBytes"), *opts.LimitBytes, "must be greater than 0"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case opts.SinceSeconds != nil && opts.SinceTime != nil:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath(""), "at most one of `sinceTime` or `sinceSeconds` may be specified"))
0000000000000000000000000000000000000000;;		case opts.SinceSeconds != nil:
0000000000000000000000000000000000000000;;			if *opts.SinceSeconds < 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("sinceSeconds"), *opts.SinceSeconds, "must be greater than 0"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AccumulateUniqueHostPorts(containers []v1.Container, accumulator *sets.String, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ci, ctr := range containers {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(ci)
0000000000000000000000000000000000000000;;			portsPath := idxPath.Child("ports")
0000000000000000000000000000000000000000;;			for pi := range ctr.Ports {
0000000000000000000000000000000000000000;;				idxPath := portsPath.Index(pi)
0000000000000000000000000000000000000000;;				port := ctr.Ports[pi].HostPort
0000000000000000000000000000000000000000;;				if port == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				str := fmt.Sprintf("%d/%s", port, ctr.Ports[pi].Protocol)
0000000000000000000000000000000000000000;;				if accumulator.Has(str) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Duplicate(idxPath.Child("hostPort"), str))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					accumulator.Insert(str)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
