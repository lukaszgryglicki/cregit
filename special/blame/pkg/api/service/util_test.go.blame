0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
b298033cbb73605d7072aded88987a521fc8c5d1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		netsets "k8s.io/kubernetes/pkg/util/net/sets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetLoadBalancerSourceRanges(t *testing.T) {
0000000000000000000000000000000000000000;;		checkError := func(v string) {
0000000000000000000000000000000000000000;;			annotations := make(map[string]string)
0000000000000000000000000000000000000000;;			annotations[api.AnnotationLoadBalancerSourceRangesKey] = v
0000000000000000000000000000000000000000;;			svc := api.Service{}
0000000000000000000000000000000000000000;;			svc.Annotations = annotations
0000000000000000000000000000000000000000;;			_, err := GetLoadBalancerSourceRanges(&svc)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error parsing: %q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			svc = api.Service{}
0000000000000000000000000000000000000000;;			svc.Spec.LoadBalancerSourceRanges = strings.Split(v, ",")
0000000000000000000000000000000000000000;;			_, err = GetLoadBalancerSourceRanges(&svc)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Expected error parsing: %q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		checkError("10.0.0.1/33")
0000000000000000000000000000000000000000;;		checkError("foo.bar")
0000000000000000000000000000000000000000;;		checkError("10.0.0.1/32,*")
0000000000000000000000000000000000000000;;		checkError("10.0.0.1/32,")
0000000000000000000000000000000000000000;;		checkError("10.0.0.1/32, ")
0000000000000000000000000000000000000000;;		checkError("10.0.0.1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkOK := func(v string) netsets.IPNet {
0000000000000000000000000000000000000000;;			annotations := make(map[string]string)
0000000000000000000000000000000000000000;;			annotations[api.AnnotationLoadBalancerSourceRangesKey] = v
0000000000000000000000000000000000000000;;			svc := api.Service{}
0000000000000000000000000000000000000000;;			svc.Annotations = annotations
0000000000000000000000000000000000000000;;			cidrs, err := GetLoadBalancerSourceRanges(&svc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error parsing: %q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			svc = api.Service{}
0000000000000000000000000000000000000000;;			svc.Spec.LoadBalancerSourceRanges = strings.Split(v, ",")
0000000000000000000000000000000000000000;;			cidrs, err = GetLoadBalancerSourceRanges(&svc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error parsing: %q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cidrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cidrs := checkOK("192.168.0.1/32")
0000000000000000000000000000000000000000;;		if len(cidrs) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one CIDR: %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cidrs = checkOK("192.168.0.1/32,192.168.0.1/32")
0000000000000000000000000000000000000000;;		if len(cidrs) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one CIDR (after de-dup): %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cidrs = checkOK("192.168.0.1/32,192.168.0.2/32")
0000000000000000000000000000000000000000;;		if len(cidrs) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected two CIDRs: %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cidrs = checkOK("  192.168.0.1/32 , 192.168.0.2/32   ")
0000000000000000000000000000000000000000;;		if len(cidrs) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected two CIDRs: %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check LoadBalancerSourceRanges not specified
0000000000000000000000000000000000000000;;		svc := api.Service{}
0000000000000000000000000000000000000000;;		cidrs, err := GetLoadBalancerSourceRanges(&svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cidrs) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one CIDR: %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAllowAll(cidrs) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected default to be allow-all: %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check SourceRanges annotation is empty
0000000000000000000000000000000000000000;;		annotations := make(map[string]string)
0000000000000000000000000000000000000000;;		annotations[api.AnnotationLoadBalancerSourceRangesKey] = ""
0000000000000000000000000000000000000000;;		svc = api.Service{}
0000000000000000000000000000000000000000;;		svc.Annotations = annotations
0000000000000000000000000000000000000000;;		cidrs, err = GetLoadBalancerSourceRanges(&svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cidrs) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one CIDR: %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAllowAll(cidrs) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected default to be allow-all: %v", cidrs.StringSlice())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllowAll(t *testing.T) {
0000000000000000000000000000000000000000;;		checkAllowAll := func(allowAll bool, cidrs ...string) {
0000000000000000000000000000000000000000;;			ipnets, err := netsets.ParseIPNets(cidrs...)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error parsing cidrs: %v", cidrs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if allowAll != IsAllowAll(ipnets) {
0000000000000000000000000000000000000000;;				t.Errorf("IsAllowAll did not return expected value for %v", cidrs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		checkAllowAll(false, "10.0.0.1/32")
0000000000000000000000000000000000000000;;		checkAllowAll(false, "10.0.0.1/32", "10.0.0.2/32")
0000000000000000000000000000000000000000;;		checkAllowAll(false, "10.0.0.1/32", "10.0.0.1/32")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkAllowAll(true, "0.0.0.0/0")
0000000000000000000000000000000000000000;;		checkAllowAll(true, "192.168.0.0/0")
0000000000000000000000000000000000000000;;		checkAllowAll(true, "192.168.0.1/32", "0.0.0.0/0")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequestsOnlyLocalTraffic(t *testing.T) {
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic := func(requestsOnlyLocalTraffic bool, service *api.Service) {
0000000000000000000000000000000000000000;;			res := RequestsOnlyLocalTraffic(service)
0000000000000000000000000000000000000000;;			if res != requestsOnlyLocalTraffic {
0000000000000000000000000000000000000000;;				t.Errorf("Expected requests OnlyLocal traffic = %v, got %v",
0000000000000000000000000000000000000000;;					requestsOnlyLocalTraffic, res)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic(false, &api.Service{})
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic(true, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkRequestsOnlyLocalTraffic(true, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNeedsHealthCheck(t *testing.T) {
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck := func(needsHealthCheck bool, service *api.Service) {
0000000000000000000000000000000000000000;;			res := NeedsHealthCheck(service)
0000000000000000000000000000000000000000;;			if res != needsHealthCheck {
0000000000000000000000000000000000000000;;				t.Errorf("Expected needs health check = %v, got %v",
0000000000000000000000000000000000000000;;					needsHealthCheck, res)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(true, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic: "invalid",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(false, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficGlobal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkNeedsHealthCheck(true, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetServiceHealthCheckNodePort(t *testing.T) {
0000000000000000000000000000000000000000;;		checkGetServiceHealthCheckNodePort := func(healthCheckNodePort int32, service *api.Service) {
0000000000000000000000000000000000000000;;			res := GetServiceHealthCheckNodePort(service)
0000000000000000000000000000000000000000;;			if res != healthCheckNodePort {
0000000000000000000000000000000000000000;;				t.Errorf("Expected health check node port = %v, got %v",
0000000000000000000000000000000000000000;;					healthCheckNodePort, res)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkGetServiceHealthCheckNodePort(0, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkGetServiceHealthCheckNodePort(0, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeNodePort,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkGetServiceHealthCheckNodePort(0, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkGetServiceHealthCheckNodePort(34567, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeLocal,
0000000000000000000000000000000000000000;;				HealthCheckNodePort:   int32(34567),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		checkGetServiceHealthCheckNodePort(34567, &api.Service{
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Type: api.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.BetaAnnotationExternalTraffic:     api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;					api.BetaAnnotationHealthCheckNodePort: "34567",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClearExternalTrafficPolicy(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			inputService *api.Service
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// First class fields cases.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Beta annotations cases.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficLocal,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			ClearExternalTrafficPolicy(tc.inputService)
0000000000000000000000000000000000000000;;			if _, ok := tc.inputService.Annotations[api.BetaAnnotationExternalTraffic]; ok ||
0000000000000000000000000000000000000000;;				tc.inputService.Spec.ExternalTrafficPolicy != "" {
0000000000000000000000000000000000000000;;				t.Errorf("%v: failed to clear ExternalTrafficPolicy", i)
0000000000000000000000000000000000000000;;				spew.Dump(tc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetServiceHealthCheckNodePort(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			inputService *api.Service
0000000000000000000000000000000000000000;;			hcNodePort   int32
0000000000000000000000000000000000000000;;			beta         bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// First class fields cases.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				30012,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;						ExternalTrafficPolicy: api.ServiceExternalTrafficPolicyTypeCluster,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				0,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Beta annotations cases.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficGlobal,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				30012,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&api.Service{
0000000000000000000000000000000000000000;;					Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;						Type: api.ServiceTypeClusterIP,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Annotations: map[string]string{
0000000000000000000000000000000000000000;;							api.BetaAnnotationExternalTraffic: api.AnnotationValueExternalTrafficGlobal,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				0,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			SetServiceHealthCheckNodePort(tc.inputService, tc.hcNodePort)
0000000000000000000000000000000000000000;;			if !tc.beta {
0000000000000000000000000000000000000000;;				if tc.inputService.Spec.HealthCheckNodePort != tc.hcNodePort {
0000000000000000000000000000000000000000;;					t.Errorf("%v: got HealthCheckNodePort %v, want %v", i, tc.inputService.Spec.HealthCheckNodePort, tc.hcNodePort)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				l, ok := tc.inputService.Annotations[api.BetaAnnotationHealthCheckNodePort]
0000000000000000000000000000000000000000;;				if tc.hcNodePort == 0 {
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						t.Errorf("%v: HealthCheckNodePort set, want it to be cleared", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t.Errorf("%v: HealthCheckNodePort unset, want %v", i, tc.hcNodePort)
0000000000000000000000000000000000000000;;					} else if l != fmt.Sprintf("%v", tc.hcNodePort) {
0000000000000000000000000000000000000000;;						t.Errorf("%v: got HealthCheckNodePort %v, want %v", i, l, tc.hcNodePort)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
