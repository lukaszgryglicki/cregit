0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
ea541beac6829f29342120a97620f818f23030e1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package api_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		kapitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeepCopyApiObjects(t *testing.T) {
0000000000000000000000000000000000000000;;		for i := 0; i < *apitesting.FuzzIters; i++ {
0000000000000000000000000000000000000000;;			for _, version := range []schema.GroupVersion{testapi.Default.InternalGroupVersion(), api.Registry.GroupOrDie(api.GroupName).GroupVersion} {
0000000000000000000000000000000000000000;;				f := apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(rand.Int63()))
0000000000000000000000000000000000000000;;				for kind := range api.Scheme.KnownTypes(version) {
0000000000000000000000000000000000000000;;					doDeepCopyTest(t, version.WithKind(kind), f)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doDeepCopyTest(t *testing.T, kind schema.GroupVersionKind, f *fuzz.Fuzzer) {
0000000000000000000000000000000000000000;;		item, err := api.Scheme.New(kind)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Could not create a %v: %s", kind, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Fuzz(item)
0000000000000000000000000000000000000000;;		itemCopy, err := api.Scheme.DeepCopy(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Could not deep copy a %v: %s", kind, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(item, itemCopy) {
0000000000000000000000000000000000000000;;			t.Errorf("\nexpected: %#v\n\ngot:      %#v\n\ndiff:      %v", item, itemCopy, diff.ObjectReflectDiff(item, itemCopy))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prefuzzData := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := api.Codecs.LegacyCodec(kind.GroupVersion()).Encode(item, prefuzzData); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Could not encode a %v: %s", kind, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Refuzz the copy, which should have no effect on the original
0000000000000000000000000000000000000000;;		f.Fuzz(itemCopy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		postfuzzData := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := api.Codecs.LegacyCodec(kind.GroupVersion()).Encode(item, postfuzzData); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Could not encode a %v: %s", kind, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bytes.Compare(prefuzzData.Bytes(), postfuzzData.Bytes()) != 0 {
0000000000000000000000000000000000000000;;			t.Log(diff.StringDiff(prefuzzData.String(), postfuzzData.String()))
0000000000000000000000000000000000000000;;			t.Errorf("Fuzzing copy modified original of %#v", kind)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeepCopySingleType(t *testing.T) {
0000000000000000000000000000000000000000;;		for i := 0; i < *apitesting.FuzzIters; i++ {
0000000000000000000000000000000000000000;;			for _, version := range []schema.GroupVersion{testapi.Default.InternalGroupVersion(), api.Registry.GroupOrDie(api.GroupName).GroupVersion} {
0000000000000000000000000000000000000000;;				f := apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(rand.Int63()))
0000000000000000000000000000000000000000;;				doDeepCopyTest(t, version.WithKind("Pod"), f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
