0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
88103cb39efc05b9850454e8584a00a79ca8bb4a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package persistentvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPVSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		// Stub containing all possible secret references in a PV.
0000000000000000000000000000000000000000;;		// The names of the referenced secrets match struct paths detected by reflection.
0000000000000000000000000000000000000000;;		pvs := []*api.PersistentVolume{
0000000000000000000000000000000000000000;;			{Spec: api.PersistentVolumeSpec{PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				AzureFile: &api.AzureFileVolumeSource{
0000000000000000000000000000000000000000;;					SecretName: "Spec.PersistentVolumeSource.AzureFile.SecretName"}}}},
0000000000000000000000000000000000000000;;			{Spec: api.PersistentVolumeSpec{PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				CephFS: &api.CephFSVolumeSource{
0000000000000000000000000000000000000000;;					SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;						Name: "Spec.PersistentVolumeSource.CephFS.SecretRef"}}}}},
0000000000000000000000000000000000000000;;			{Spec: api.PersistentVolumeSpec{PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				FlexVolume: &api.FlexVolumeSource{
0000000000000000000000000000000000000000;;					SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;						Name: "Spec.PersistentVolumeSource.FlexVolume.SecretRef"}}}}},
0000000000000000000000000000000000000000;;			{Spec: api.PersistentVolumeSpec{PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				RBD: &api.RBDVolumeSource{
0000000000000000000000000000000000000000;;					SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;						Name: "Spec.PersistentVolumeSource.RBD.SecretRef"}}}}},
0000000000000000000000000000000000000000;;			{Spec: api.PersistentVolumeSpec{PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				ScaleIO: &api.ScaleIOVolumeSource{
0000000000000000000000000000000000000000;;					SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;						Name: "Spec.PersistentVolumeSource.ScaleIO.SecretRef"}}}}},
0000000000000000000000000000000000000000;;			{Spec: api.PersistentVolumeSpec{PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				ISCSI: &api.ISCSIVolumeSource{
0000000000000000000000000000000000000000;;					SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;						Name: "Spec.PersistentVolumeSource.ISCSI.SecretRef"}}}}},
0000000000000000000000000000000000000000;;			{Spec: api.PersistentVolumeSpec{PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;				StorageOS: &api.StorageOSPersistentVolumeSource{
0000000000000000000000000000000000000000;;					SecretRef: &api.ObjectReference{
0000000000000000000000000000000000000000;;						Name:      "Spec.PersistentVolumeSource.StorageOS.SecretRef",
0000000000000000000000000000000000000000;;						Namespace: "Spec.PersistentVolumeSource.StorageOS.SecretRef"}}}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extractedNames := sets.NewString()
0000000000000000000000000000000000000000;;		extractedNamespaces := sets.NewString()
0000000000000000000000000000000000000000;;		for _, pv := range pvs {
0000000000000000000000000000000000000000;;			VisitPVSecretNames(pv, func(namespace, name string) bool {
0000000000000000000000000000000000000000;;				extractedNames.Insert(name)
0000000000000000000000000000000000000000;;				if namespace != "" {
0000000000000000000000000000000000000000;;					extractedNamespaces.Insert(namespace)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// excludedSecretPaths holds struct paths to fields with "secret" in the name that are not actually references to secret API objects
0000000000000000000000000000000000000000;;		excludedSecretPaths := sets.NewString(
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.CephFS.SecretFile",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// expectedSecretPaths holds struct paths to fields with "secret" in the name that are references to secret API objects.
0000000000000000000000000000000000000000;;		// every path here should be represented as an example in the PV stub above, with the secret name set to the path.
0000000000000000000000000000000000000000;;		expectedSecretPaths := sets.NewString(
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.AzureFile.SecretName",
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.CephFS.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.FlexVolume.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.RBD.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.ScaleIO.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.ISCSI.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.StorageOS.SecretRef",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		secretPaths := collectSecretPaths(t, nil, "", reflect.TypeOf(&api.PersistentVolume{}))
0000000000000000000000000000000000000000;;		secretPaths = secretPaths.Difference(excludedSecretPaths)
0000000000000000000000000000000000000000;;		if missingPaths := expectedSecretPaths.Difference(secretPaths); len(missingPaths) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Missing expected secret paths:\n%s", strings.Join(missingPaths.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Missing expected secret paths. Verify VisitPVSecretNames() is correctly finding the missing paths, then correct expectedSecretPaths")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraPaths := secretPaths.Difference(expectedSecretPaths); len(extraPaths) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Extra secret paths:\n%s", strings.Join(extraPaths.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Extra fields with 'secret' in the name found. Verify VisitPVSecretNames() is including these fields if appropriate, then correct expectedSecretPaths")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if missingNames := expectedSecretPaths.Difference(extractedNames); len(missingNames) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Missing expected secret names:\n%s", strings.Join(missingNames.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Missing expected secret names. Verify the PV stub above includes these references, then verify VisitPVSecretNames() is correctly finding the missing names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraNames := extractedNames.Difference(expectedSecretPaths); len(extraNames) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Extra secret names:\n%s", strings.Join(extraNames.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Extra secret names extracted. Verify VisitPVSecretNames() is correctly extracting secret names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedSecretNamespaces := sets.NewString(
0000000000000000000000000000000000000000;;			"Spec.PersistentVolumeSource.StorageOS.SecretRef",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(expectedSecretNamespaces.Difference(extractedNamespaces)) > 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Missing expected secret namespace")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// collectSecretPaths traverses the object, computing all the struct paths that lead to fields with "secret" in the name.
0000000000000000000000000000000000000000;;	func collectSecretPaths(t *testing.T, path *field.Path, name string, tp reflect.Type) sets.String {
0000000000000000000000000000000000000000;;		secretPaths := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tp.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path, name, tp.Elem()).List()...)
0000000000000000000000000000000000000000;;			return secretPaths
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.Contains(strings.ToLower(name), "secret") {
0000000000000000000000000000000000000000;;			secretPaths.Insert(path.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tp.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path, name, tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < tp.NumField(); i++ {
0000000000000000000000000000000000000000;;				field := tp.Field(i)
0000000000000000000000000000000000000000;;				secretPaths.Insert(collectSecretPaths(t, path.Child(field.Name), field.Name, field.Type).List()...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			t.Errorf("cannot find secret fields in interface{} field %s", path.String())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path.Key("*"), "", tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path.Key("*"), "", tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// all primitive types
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return secretPaths
0000000000000000000000000000000000000000;;	}
