0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
3daefffda05ff5b90591c80268e75134390def49;pkg/api/helpers_test.go[pkg/api/helpers_test.go][pkg/api/helper/helpers_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package helper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSemantic(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			a, b        interface{}
0000000000000000000000000000000000000000;;			shouldEqual bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{resource.MustParse("0"), resource.Quantity{}, true},
0000000000000000000000000000000000000000;;			{resource.Quantity{}, resource.MustParse("0"), true},
0000000000000000000000000000000000000000;;			{resource.Quantity{}, resource.MustParse("1m"), false},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				resource.NewQuantity(5, resource.BinarySI),
0000000000000000000000000000000000000000;;				resource.NewQuantity(5, resource.DecimalSI),
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{resource.MustParse("2m"), resource.MustParse("1m"), false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, item := range table {
0000000000000000000000000000000000000000;;			if e, a := item.shouldEqual, Semantic.DeepEqual(item.a, item.b); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d], expected %v, got %v.", index, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsStandardResource(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input  string
0000000000000000000000000000000000000000;;			output bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"cpu", true},
0000000000000000000000000000000000000000;;			{"memory", true},
0000000000000000000000000000000000000000;;			{"disk", false},
0000000000000000000000000000000000000000;;			{"blah", false},
0000000000000000000000000000000000000000;;			{"x.y.z", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			if IsStandardResourceName(tc.input) != tc.output {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d], expected: %t, got: %t", i, tc.output, !tc.output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddToNodeAddresses(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			existing []api.NodeAddress
0000000000000000000000000000000000000000;;			toAdd    []api.NodeAddress
0000000000000000000000000000000000000000;;			expected []api.NodeAddress
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []api.NodeAddress{},
0000000000000000000000000000000000000000;;				toAdd:    []api.NodeAddress{},
0000000000000000000000000000000000000000;;				expected: []api.NodeAddress{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []api.NodeAddress{},
0000000000000000000000000000000000000000;;				toAdd: []api.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: api.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []api.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: api.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []api.NodeAddress{},
0000000000000000000000000000000000000000;;				toAdd: []api.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []api.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				existing: []api.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: api.NodeInternalIP, Address: "10.1.1.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				toAdd: []api.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: api.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: []api.NodeAddress{
0000000000000000000000000000000000000000;;					{Type: api.NodeExternalIP, Address: "1.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: api.NodeInternalIP, Address: "10.1.1.1"},
0000000000000000000000000000000000000000;;					{Type: api.NodeHostName, Address: "localhost"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			AddToNodeAddresses(&tc.existing, tc.toAdd...)
0000000000000000000000000000000000000000;;			if !Semantic.DeepEqual(tc.expected, tc.existing) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d], expected: %v, got: %v", i, tc.expected, tc.existing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAccessModesFromString(t *testing.T) {
0000000000000000000000000000000000000000;;		modes := GetAccessModesFromString("ROX")
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, api.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", api.ReadOnlyMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modes = GetAccessModesFromString("ROX,RWX")
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, api.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", api.ReadOnlyMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, api.ReadWriteMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", api.ReadWriteMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modes = GetAccessModesFromString("RWO,ROX,RWX")
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, api.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", api.ReadOnlyMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containsAccessMode(modes, api.ReadWriteMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected mode %s, but got %+v", api.ReadWriteMany, modes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemoveDuplicateAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		modes := []api.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			api.ReadWriteOnce, api.ReadOnlyMany, api.ReadOnlyMany, api.ReadOnlyMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modes = removeDuplicateAccessModes(modes)
0000000000000000000000000000000000000000;;		if len(modes) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 2 distinct modes in set but found %v", len(modes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeSelectorRequirementsAsSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		matchExpressions := []api.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;			Key:      "foo",
0000000000000000000000000000000000000000;;			Operator: api.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;			Values:   []string{"bar", "baz"},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		mustParse := func(s string) labels.Selector {
0000000000000000000000000000000000000000;;			out, e := labels.Parse(s)
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				panic(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc := []struct {
0000000000000000000000000000000000000000;;			in        []api.NodeSelectorRequirement
0000000000000000000000000000000000000000;;			out       labels.Selector
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{in: nil, out: labels.Nothing()},
0000000000000000000000000000000000000000;;			{in: []api.NodeSelectorRequirement{}, out: labels.Nothing()},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  matchExpressions,
0000000000000000000000000000000000000000;;				out: mustParse("foo in (baz,bar)"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in: []api.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: api.NodeSelectorOpExists,
0000000000000000000000000000000000000000;;					Values:   []string{"bar", "baz"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in: []api.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;					Key:      "foo",
0000000000000000000000000000000000000000;;					Operator: api.NodeSelectorOpGt,
0000000000000000000000000000000000000000;;					Values:   []string{"1"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				out: mustParse("foo>1"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in: []api.NodeSelectorRequirement{{
0000000000000000000000000000000000000000;;					Key:      "bar",
0000000000000000000000000000000000000000;;					Operator: api.NodeSelectorOpLt,
0000000000000000000000000000000000000000;;					Values:   []string{"7"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				out: mustParse("bar<7"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range tc {
0000000000000000000000000000000000000000;;			out, err := NodeSelectorRequirementsAsSelector(tc.in)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none.", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(out, tc.out) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected:\n\t%+v\nbut got:\n\t%+v", i, tc.out, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSysctlsFromPodAnnotation(t *testing.T) {
0000000000000000000000000000000000000000;;		type Test struct {
0000000000000000000000000000000000000000;;			annotation  string
0000000000000000000000000000000000000000;;			expectValue []api.Sysctl
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range []Test{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "",
0000000000000000000000000000000000000000;;				expectValue: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation: "foo.bar",
0000000000000000000000000000000000000000;;				expectErr:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation: "=123",
0000000000000000000000000000000000000000;;				expectErr:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "foo.bar=",
0000000000000000000000000000000000000000;;				expectValue: []api.Sysctl{{Name: "foo.bar", Value: ""}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "foo.bar=42",
0000000000000000000000000000000000000000;;				expectValue: []api.Sysctl{{Name: "foo.bar", Value: "42"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation: "foo.bar=42,",
0000000000000000000000000000000000000000;;				expectErr:  true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotation:  "foo.bar=42,abc.def=1",
0000000000000000000000000000000000000000;;				expectValue: []api.Sysctl{{Name: "foo.bar", Value: "42"}, {Name: "abc.def", Value: "1"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			sysctls, err := SysctlsFromPodAnnotation(test.annotation)
0000000000000000000000000000000000000000;;			if test.expectErr && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none", i)
0000000000000000000000000000000000000000;;			} else if !test.expectErr && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			} else if !reflect.DeepEqual(sysctls, test.expectValue) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expect value %v but got %v", i, test.expectValue, sysctls)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove when alpha support for topology constraints is removed
0000000000000000000000000000000000000000;;	func TestGetNodeAffinityFromAnnotations(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			annotations map[string]string
0000000000000000000000000000000000000000;;			expectErr   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: nil,
0000000000000000000000000000000000000000;;				expectErr:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{},
0000000000000000000000000000000000000000;;				expectErr:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.AlphaStorageNodeAffinityAnnotation: `{ 
0000000000000000000000000000000000000000;;						"requiredDuringSchedulingIgnoredDuringExecution": { 
0000000000000000000000000000000000000000;;							"nodeSelectorTerms": [ 
0000000000000000000000000000000000000000;;								{ "matchExpressions": [
0000000000000000000000000000000000000000;;									{ "key": "test-key1",
0000000000000000000000000000000000000000;;									  "operator": "In",
0000000000000000000000000000000000000000;;									  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{ "key": "test-key2",
0000000000000000000000000000000000000000;;									  "operator": "In",
0000000000000000000000000000000000000000;;									  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;								]}
0000000000000000000000000000000000000000;;							]}
0000000000000000000000000000000000000000;;						}`,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.AlphaStorageNodeAffinityAnnotation: `[{ 
0000000000000000000000000000000000000000;;						"requiredDuringSchedulingIgnoredDuringExecution": { 
0000000000000000000000000000000000000000;;							"nodeSelectorTerms": [ 
0000000000000000000000000000000000000000;;								{ "matchExpressions": [
0000000000000000000000000000000000000000;;									{ "key": "test-key1",
0000000000000000000000000000000000000000;;									  "operator": "In",
0000000000000000000000000000000000000000;;									  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{ "key": "test-key2",
0000000000000000000000000000000000000000;;									  "operator": "In",
0000000000000000000000000000000000000000;;									  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;								]}
0000000000000000000000000000000000000000;;							]}
0000000000000000000000000000000000000000;;						}]`,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				annotations: map[string]string{
0000000000000000000000000000000000000000;;					api.AlphaStorageNodeAffinityAnnotation: `{ 
0000000000000000000000000000000000000000;;						"requiredDuringSchedulingIgnoredDuringExecution": { 
0000000000000000000000000000000000000000;;							"nodeSelectorTerms":  
0000000000000000000000000000000000000000;;								 "matchExpressions": [
0000000000000000000000000000000000000000;;									{ "key": "test-key1",
0000000000000000000000000000000000000000;;									  "operator": "In",
0000000000000000000000000000000000000000;;									  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{ "key": "test-key2",
0000000000000000000000000000000000000000;;									  "operator": "In",
0000000000000000000000000000000000000000;;									  "values": ["test-value1", "test-value2"]
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;								]}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}`,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			_, err := GetStorageNodeAffinityFromAnnotation(tc.annotations)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none.", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
