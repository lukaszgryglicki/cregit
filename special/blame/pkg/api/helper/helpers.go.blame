0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0dc79c11e0b177aec401ed1333b326c09632ff41;pkg/api/helpers.go[pkg/api/helpers.go][pkg/api/helper/helpers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package helper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/selection"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NonConvertibleFields iterates over the provided map and filters out all but
0000000000000000000000000000000000000000;;	// any keys with the "non-convertible.kubernetes.io" prefix.
0000000000000000000000000000000000000000;;	func NonConvertibleFields(annotations map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		nonConvertibleKeys := map[string]string{}
0000000000000000000000000000000000000000;;		for key, value := range annotations {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(key, api.NonConvertibleAnnotationPrefix) {
0000000000000000000000000000000000000000;;				nonConvertibleKeys[key] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nonConvertibleKeys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Semantic can do semantic deep equality checks for api objects.
0000000000000000000000000000000000000000;;	// Example: apiequality.Semantic.DeepEqual(aPod, aPodWithNonNilButEmptyMaps) == true
0000000000000000000000000000000000000000;;	var Semantic = conversion.EqualitiesOrDie(
0000000000000000000000000000000000000000;;		func(a, b resource.Quantity) bool {
0000000000000000000000000000000000000000;;			// Ignore formatting, only care that numeric value stayed the same.
0000000000000000000000000000000000000000;;			// TODO: if we decide it's important, it should be safe to start comparing the format.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Uninitialized quantities are equivalent to 0 quantities.
0000000000000000000000000000000000000000;;			return a.Cmp(b) == 0
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		func(a, b metav1.Time) bool {
0000000000000000000000000000000000000000;;			return a.UTC() == b.UTC()
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		func(a, b labels.Selector) bool {
0000000000000000000000000000000000000000;;			return a.String() == b.String()
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		func(a, b fields.Selector) bool {
0000000000000000000000000000000000000000;;			return a.String() == b.String()
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var standardResourceQuotaScopes = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.ResourceQuotaScopeTerminating),
0000000000000000000000000000000000000000;;		string(api.ResourceQuotaScopeNotTerminating),
0000000000000000000000000000000000000000;;		string(api.ResourceQuotaScopeBestEffort),
0000000000000000000000000000000000000000;;		string(api.ResourceQuotaScopeNotBestEffort),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStandardResourceQuotaScope returns true if the scope is a standard value
0000000000000000000000000000000000000000;;	func IsStandardResourceQuotaScope(str string) bool {
0000000000000000000000000000000000000000;;		return standardResourceQuotaScopes.Has(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var podObjectCountQuotaResources = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.ResourcePods),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var podComputeQuotaResources = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.ResourceCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceMemory),
0000000000000000000000000000000000000000;;		string(api.ResourceLimitsCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceLimitsMemory),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsMemory),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsResourceQuotaScopeValidForResource returns true if the resource applies to the specified scope
0000000000000000000000000000000000000000;;	func IsResourceQuotaScopeValidForResource(scope api.ResourceQuotaScope, resource string) bool {
0000000000000000000000000000000000000000;;		switch scope {
0000000000000000000000000000000000000000;;		case api.ResourceQuotaScopeTerminating, api.ResourceQuotaScopeNotTerminating, api.ResourceQuotaScopeNotBestEffort:
0000000000000000000000000000000000000000;;			return podObjectCountQuotaResources.Has(resource) || podComputeQuotaResources.Has(resource)
0000000000000000000000000000000000000000;;		case api.ResourceQuotaScopeBestEffort:
0000000000000000000000000000000000000000;;			return podObjectCountQuotaResources.Has(resource)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var standardContainerResources = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.ResourceCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceMemory),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStandardContainerResourceName returns true if the container can make a resource request
0000000000000000000000000000000000000000;;	// for the specified resource
0000000000000000000000000000000000000000;;	func IsStandardContainerResourceName(str string) bool {
0000000000000000000000000000000000000000;;		return standardContainerResources.Has(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsOpaqueIntResourceName returns true if the resource name has the opaque
0000000000000000000000000000000000000000;;	// integer resource prefix.
0000000000000000000000000000000000000000;;	func IsOpaqueIntResourceName(name api.ResourceName) bool {
0000000000000000000000000000000000000000;;		return strings.HasPrefix(string(name), api.ResourceOpaqueIntPrefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpaqueIntResourceName returns a ResourceName with the canonical opaque
0000000000000000000000000000000000000000;;	// integer prefix prepended. If the argument already has the prefix, it is
0000000000000000000000000000000000000000;;	// returned unmodified.
0000000000000000000000000000000000000000;;	func OpaqueIntResourceName(name string) api.ResourceName {
0000000000000000000000000000000000000000;;		if IsOpaqueIntResourceName(api.ResourceName(name)) {
0000000000000000000000000000000000000000;;			return api.ResourceName(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return api.ResourceName(fmt.Sprintf("%s%s", api.ResourceOpaqueIntPrefix, name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var standardLimitRangeTypes = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.LimitTypePod),
0000000000000000000000000000000000000000;;		string(api.LimitTypeContainer),
0000000000000000000000000000000000000000;;		string(api.LimitTypePersistentVolumeClaim),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStandardLimitRangeType returns true if the type is Pod or Container
0000000000000000000000000000000000000000;;	func IsStandardLimitRangeType(str string) bool {
0000000000000000000000000000000000000000;;		return standardLimitRangeTypes.Has(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var standardQuotaResources = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.ResourceCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceMemory),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsMemory),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsStorage),
0000000000000000000000000000000000000000;;		string(api.ResourceLimitsCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceLimitsMemory),
0000000000000000000000000000000000000000;;		string(api.ResourcePods),
0000000000000000000000000000000000000000;;		string(api.ResourceQuotas),
0000000000000000000000000000000000000000;;		string(api.ResourceServices),
0000000000000000000000000000000000000000;;		string(api.ResourceReplicationControllers),
0000000000000000000000000000000000000000;;		string(api.ResourceSecrets),
0000000000000000000000000000000000000000;;		string(api.ResourcePersistentVolumeClaims),
0000000000000000000000000000000000000000;;		string(api.ResourceConfigMaps),
0000000000000000000000000000000000000000;;		string(api.ResourceServicesNodePorts),
0000000000000000000000000000000000000000;;		string(api.ResourceServicesLoadBalancers),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStandardQuotaResourceName returns true if the resource is known to
0000000000000000000000000000000000000000;;	// the quota tracking system
0000000000000000000000000000000000000000;;	func IsStandardQuotaResourceName(str string) bool {
0000000000000000000000000000000000000000;;		return standardQuotaResources.Has(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var standardResources = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.ResourceCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceMemory),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsMemory),
0000000000000000000000000000000000000000;;		string(api.ResourceLimitsCPU),
0000000000000000000000000000000000000000;;		string(api.ResourceLimitsMemory),
0000000000000000000000000000000000000000;;		string(api.ResourcePods),
0000000000000000000000000000000000000000;;		string(api.ResourceQuotas),
0000000000000000000000000000000000000000;;		string(api.ResourceServices),
0000000000000000000000000000000000000000;;		string(api.ResourceReplicationControllers),
0000000000000000000000000000000000000000;;		string(api.ResourceSecrets),
0000000000000000000000000000000000000000;;		string(api.ResourceConfigMaps),
0000000000000000000000000000000000000000;;		string(api.ResourcePersistentVolumeClaims),
0000000000000000000000000000000000000000;;		string(api.ResourceStorage),
0000000000000000000000000000000000000000;;		string(api.ResourceRequestsStorage),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStandardResourceName returns true if the resource is known to the system
0000000000000000000000000000000000000000;;	func IsStandardResourceName(str string) bool {
0000000000000000000000000000000000000000;;		return standardResources.Has(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var integerResources = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.ResourcePods),
0000000000000000000000000000000000000000;;		string(api.ResourceQuotas),
0000000000000000000000000000000000000000;;		string(api.ResourceServices),
0000000000000000000000000000000000000000;;		string(api.ResourceReplicationControllers),
0000000000000000000000000000000000000000;;		string(api.ResourceSecrets),
0000000000000000000000000000000000000000;;		string(api.ResourceConfigMaps),
0000000000000000000000000000000000000000;;		string(api.ResourcePersistentVolumeClaims),
0000000000000000000000000000000000000000;;		string(api.ResourceServicesNodePorts),
0000000000000000000000000000000000000000;;		string(api.ResourceServicesLoadBalancers),
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsIntegerResourceName returns true if the resource is measured in integer values
0000000000000000000000000000000000000000;;	func IsIntegerResourceName(str string) bool {
0000000000000000000000000000000000000000;;		return integerResources.Has(str) || IsOpaqueIntResourceName(api.ResourceName(str))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this function aims to check if the service's ClusterIP is set or not
0000000000000000000000000000000000000000;;	// the objective is not to perform validation here
0000000000000000000000000000000000000000;;	func IsServiceIPSet(service *api.Service) bool {
0000000000000000000000000000000000000000;;		return service.Spec.ClusterIP != api.ClusterIPNone && service.Spec.ClusterIP != ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this function aims to check if the service's cluster IP is requested or not
0000000000000000000000000000000000000000;;	func IsServiceIPRequested(service *api.Service) bool {
0000000000000000000000000000000000000000;;		// ExternalName services are CNAME aliases to external ones. Ignore the IP.
0000000000000000000000000000000000000000;;		if service.Spec.Type == api.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return service.Spec.ClusterIP == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var standardFinalizers = sets.NewString(
0000000000000000000000000000000000000000;;		string(api.FinalizerKubernetes),
0000000000000000000000000000000000000000;;		metav1.FinalizerOrphanDependents,
0000000000000000000000000000000000000000;;		metav1.FinalizerDeleteDependents,
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAnnotation returns a bool if passed in annotation exists
0000000000000000000000000000000000000000;;	func HasAnnotation(obj api.ObjectMeta, ann string) bool {
0000000000000000000000000000000000000000;;		_, found := obj.Annotations[ann]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMetaDataAnnotation sets the annotation and value
0000000000000000000000000000000000000000;;	func SetMetaDataAnnotation(obj *api.ObjectMeta, ann string, value string) {
0000000000000000000000000000000000000000;;		if obj.Annotations == nil {
0000000000000000000000000000000000000000;;			obj.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj.Annotations[ann] = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsStandardFinalizerName(str string) bool {
0000000000000000000000000000000000000000;;		return standardFinalizers.Has(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddToNodeAddresses appends the NodeAddresses to the passed-by-pointer slice,
0000000000000000000000000000000000000000;;	// only if they do not already exist
0000000000000000000000000000000000000000;;	func AddToNodeAddresses(addresses *[]api.NodeAddress, addAddresses ...api.NodeAddress) {
0000000000000000000000000000000000000000;;		for _, add := range addAddresses {
0000000000000000000000000000000000000000;;			exists := false
0000000000000000000000000000000000000000;;			for _, existing := range *addresses {
0000000000000000000000000000000000000000;;				if existing.Address == add.Address && existing.Type == add.Type {
0000000000000000000000000000000000000000;;					exists = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				*addresses = append(*addresses, add)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: make method on LoadBalancerStatus?
0000000000000000000000000000000000000000;;	func LoadBalancerStatusEqual(l, r *api.LoadBalancerStatus) bool {
0000000000000000000000000000000000000000;;		return ingressSliceEqual(l.Ingress, r.Ingress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ingressSliceEqual(lhs, rhs []api.LoadBalancerIngress) bool {
0000000000000000000000000000000000000000;;		if len(lhs) != len(rhs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range lhs {
0000000000000000000000000000000000000000;;			if !ingressEqual(&lhs[i], &rhs[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ingressEqual(lhs, rhs *api.LoadBalancerIngress) bool {
0000000000000000000000000000000000000000;;		if lhs.IP != rhs.IP {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lhs.Hostname != rhs.Hostname {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: make method on LoadBalancerStatus?
0000000000000000000000000000000000000000;;	func LoadBalancerStatusDeepCopy(lb *api.LoadBalancerStatus) *api.LoadBalancerStatus {
0000000000000000000000000000000000000000;;		c := &api.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		c.Ingress = make([]api.LoadBalancerIngress, len(lb.Ingress))
0000000000000000000000000000000000000000;;		for i := range lb.Ingress {
0000000000000000000000000000000000000000;;			c.Ingress[i] = lb.Ingress[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAccessModesAsString returns a string representation of an array of access modes.
0000000000000000000000000000000000000000;;	// modes, when present, are always in the same order: RWO,ROX,RWX.
0000000000000000000000000000000000000000;;	func GetAccessModesAsString(modes []api.PersistentVolumeAccessMode) string {
0000000000000000000000000000000000000000;;		modes = removeDuplicateAccessModes(modes)
0000000000000000000000000000000000000000;;		modesStr := []string{}
0000000000000000000000000000000000000000;;		if containsAccessMode(modes, api.ReadWriteOnce) {
0000000000000000000000000000000000000000;;			modesStr = append(modesStr, "RWO")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containsAccessMode(modes, api.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			modesStr = append(modesStr, "ROX")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containsAccessMode(modes, api.ReadWriteMany) {
0000000000000000000000000000000000000000;;			modesStr = append(modesStr, "RWX")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(modesStr, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAccessModesAsString returns an array of AccessModes from a string created by GetAccessModesAsString
0000000000000000000000000000000000000000;;	func GetAccessModesFromString(modes string) []api.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		strmodes := strings.Split(modes, ",")
0000000000000000000000000000000000000000;;		accessModes := []api.PersistentVolumeAccessMode{}
0000000000000000000000000000000000000000;;		for _, s := range strmodes {
0000000000000000000000000000000000000000;;			s = strings.Trim(s, " ")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case s == "RWO":
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, api.ReadWriteOnce)
0000000000000000000000000000000000000000;;			case s == "ROX":
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, api.ReadOnlyMany)
0000000000000000000000000000000000000000;;			case s == "RWX":
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, api.ReadWriteMany)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return accessModes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeDuplicateAccessModes returns an array of access modes without any duplicates
0000000000000000000000000000000000000000;;	func removeDuplicateAccessModes(modes []api.PersistentVolumeAccessMode) []api.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		accessModes := []api.PersistentVolumeAccessMode{}
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if !containsAccessMode(accessModes, m) {
0000000000000000000000000000000000000000;;				accessModes = append(accessModes, m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return accessModes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containsAccessMode(modes []api.PersistentVolumeAccessMode, mode api.PersistentVolumeAccessMode) bool {
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if m == mode {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeSelectorRequirementsAsSelector converts the []NodeSelectorRequirement api type into a struct that implements
0000000000000000000000000000000000000000;;	// labels.Selector.
0000000000000000000000000000000000000000;;	func NodeSelectorRequirementsAsSelector(nsm []api.NodeSelectorRequirement) (labels.Selector, error) {
0000000000000000000000000000000000000000;;		if len(nsm) == 0 {
0000000000000000000000000000000000000000;;			return labels.Nothing(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector := labels.NewSelector()
0000000000000000000000000000000000000000;;		for _, expr := range nsm {
0000000000000000000000000000000000000000;;			var op selection.Operator
0000000000000000000000000000000000000000;;			switch expr.Operator {
0000000000000000000000000000000000000000;;			case api.NodeSelectorOpIn:
0000000000000000000000000000000000000000;;				op = selection.In
0000000000000000000000000000000000000000;;			case api.NodeSelectorOpNotIn:
0000000000000000000000000000000000000000;;				op = selection.NotIn
0000000000000000000000000000000000000000;;			case api.NodeSelectorOpExists:
0000000000000000000000000000000000000000;;				op = selection.Exists
0000000000000000000000000000000000000000;;			case api.NodeSelectorOpDoesNotExist:
0000000000000000000000000000000000000000;;				op = selection.DoesNotExist
0000000000000000000000000000000000000000;;			case api.NodeSelectorOpGt:
0000000000000000000000000000000000000000;;				op = selection.GreaterThan
0000000000000000000000000000000000000000;;			case api.NodeSelectorOpLt:
0000000000000000000000000000000000000000;;				op = selection.LessThan
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%q is not a valid node selector operator", expr.Operator)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, err := labels.NewRequirement(expr.Key, op, expr.Values)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selector = selector.Add(*r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selector, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTolerationsFromPodAnnotations gets the json serialized tolerations data from Pod.Annotations
0000000000000000000000000000000000000000;;	// and converts it to the []Toleration type in api.
0000000000000000000000000000000000000000;;	func GetTolerationsFromPodAnnotations(annotations map[string]string) ([]api.Toleration, error) {
0000000000000000000000000000000000000000;;		var tolerations []api.Toleration
0000000000000000000000000000000000000000;;		if len(annotations) > 0 && annotations[api.TolerationsAnnotationKey] != "" {
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(annotations[api.TolerationsAnnotationKey]), &tolerations)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return tolerations, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tolerations, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddOrUpdateTolerationInPod tries to add a toleration to the pod's toleration list.
0000000000000000000000000000000000000000;;	// Returns true if something was updated, false otherwise.
0000000000000000000000000000000000000000;;	func AddOrUpdateTolerationInPod(pod *api.Pod, toleration *api.Toleration) bool {
0000000000000000000000000000000000000000;;		podTolerations := pod.Spec.Tolerations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var newTolerations []api.Toleration
0000000000000000000000000000000000000000;;		updated := false
0000000000000000000000000000000000000000;;		for i := range podTolerations {
0000000000000000000000000000000000000000;;			if toleration.MatchToleration(&podTolerations[i]) {
0000000000000000000000000000000000000000;;				if Semantic.DeepEqual(toleration, podTolerations[i]) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newTolerations = append(newTolerations, *toleration)
0000000000000000000000000000000000000000;;				updated = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newTolerations = append(newTolerations, podTolerations[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			newTolerations = append(newTolerations, *toleration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod.Spec.Tolerations = newTolerations
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TolerationToleratesTaint checks if the toleration tolerates the taint.
0000000000000000000000000000000000000000;;	func TolerationToleratesTaint(toleration *api.Toleration, taint *api.Taint) bool {
0000000000000000000000000000000000000000;;		if len(toleration.Effect) != 0 && toleration.Effect != taint.Effect {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if toleration.Key != taint.Key {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Use proper defaulting when Toleration becomes a field of PodSpec
0000000000000000000000000000000000000000;;		if (len(toleration.Operator) == 0 || toleration.Operator == api.TolerationOpEqual) && toleration.Value == taint.Value {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if toleration.Operator == api.TolerationOpExists {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TaintToleratedByTolerations checks if taint is tolerated by any of the tolerations.
0000000000000000000000000000000000000000;;	func TaintToleratedByTolerations(taint *api.Taint, tolerations []api.Toleration) bool {
0000000000000000000000000000000000000000;;		tolerated := false
0000000000000000000000000000000000000000;;		for i := range tolerations {
0000000000000000000000000000000000000000;;			if TolerationToleratesTaint(&tolerations[i], taint) {
0000000000000000000000000000000000000000;;				tolerated = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tolerated
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTaintsFromNodeAnnotations gets the json serialized taints data from Pod.Annotations
0000000000000000000000000000000000000000;;	// and converts it to the []Taint type in api.
0000000000000000000000000000000000000000;;	func GetTaintsFromNodeAnnotations(annotations map[string]string) ([]api.Taint, error) {
0000000000000000000000000000000000000000;;		var taints []api.Taint
0000000000000000000000000000000000000000;;		if len(annotations) > 0 && annotations[api.TaintsAnnotationKey] != "" {
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(annotations[api.TaintsAnnotationKey]), &taints)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []api.Taint{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return taints, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SysctlsFromPodAnnotations parses the sysctl annotations into a slice of safe Sysctls
0000000000000000000000000000000000000000;;	// and a slice of unsafe Sysctls. This is only a convenience wrapper around
0000000000000000000000000000000000000000;;	// SysctlsFromPodAnnotation.
0000000000000000000000000000000000000000;;	func SysctlsFromPodAnnotations(a map[string]string) ([]api.Sysctl, []api.Sysctl, error) {
0000000000000000000000000000000000000000;;		safe, err := SysctlsFromPodAnnotation(a[api.SysctlsPodAnnotationKey])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unsafe, err := SysctlsFromPodAnnotation(a[api.UnsafeSysctlsPodAnnotationKey])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return safe, unsafe, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SysctlsFromPodAnnotation parses an annotation value into a slice of Sysctls.
0000000000000000000000000000000000000000;;	func SysctlsFromPodAnnotation(annotation string) ([]api.Sysctl, error) {
0000000000000000000000000000000000000000;;		if len(annotation) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kvs := strings.Split(annotation, ",")
0000000000000000000000000000000000000000;;		sysctls := make([]api.Sysctl, len(kvs))
0000000000000000000000000000000000000000;;		for i, kv := range kvs {
0000000000000000000000000000000000000000;;			cs := strings.Split(kv, "=")
0000000000000000000000000000000000000000;;			if len(cs) != 2 || len(cs[0]) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("sysctl %q not of the format sysctl_name=value", kv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sysctls[i].Name = cs[0]
0000000000000000000000000000000000000000;;			sysctls[i].Value = cs[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sysctls, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodAnnotationsFromSysctls creates an annotation value for a slice of Sysctls.
0000000000000000000000000000000000000000;;	func PodAnnotationsFromSysctls(sysctls []api.Sysctl) string {
0000000000000000000000000000000000000000;;		if len(sysctls) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kvs := make([]string, len(sysctls))
0000000000000000000000000000000000000000;;		for i := range sysctls {
0000000000000000000000000000000000000000;;			kvs[i] = fmt.Sprintf("%s=%s", sysctls[i].Name, sysctls[i].Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(kvs, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPersistentVolumeClass returns StorageClassName.
0000000000000000000000000000000000000000;;	func GetPersistentVolumeClass(volume *api.PersistentVolume) string {
0000000000000000000000000000000000000000;;		// Use beta annotation first
0000000000000000000000000000000000000000;;		if class, found := volume.Annotations[api.BetaStorageClassAnnotation]; found {
0000000000000000000000000000000000000000;;			return class
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume.Spec.StorageClassName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPersistentVolumeClaimClass returns StorageClassName. If no storage class was
0000000000000000000000000000000000000000;;	// requested, it returns "".
0000000000000000000000000000000000000000;;	func GetPersistentVolumeClaimClass(claim *api.PersistentVolumeClaim) string {
0000000000000000000000000000000000000000;;		// Use beta annotation first
0000000000000000000000000000000000000000;;		if class, found := claim.Annotations[api.BetaStorageClassAnnotation]; found {
0000000000000000000000000000000000000000;;			return class
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if claim.Spec.StorageClassName != nil {
0000000000000000000000000000000000000000;;			return *claim.Spec.StorageClassName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimHasClass returns true if given claim has set StorageClassName field.
0000000000000000000000000000000000000000;;	func PersistentVolumeClaimHasClass(claim *api.PersistentVolumeClaim) bool {
0000000000000000000000000000000000000000;;		// Use beta annotation first
0000000000000000000000000000000000000000;;		if _, found := claim.Annotations[api.BetaStorageClassAnnotation]; found {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if claim.Spec.StorageClassName != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStorageNodeAffinityFromAnnotation gets the json serialized data from PersistentVolume.Annotations
0000000000000000000000000000000000000000;;	// and converts it to the NodeAffinity type in api.
0000000000000000000000000000000000000000;;	// TODO: update when storage node affinity graduates to beta
0000000000000000000000000000000000000000;;	func GetStorageNodeAffinityFromAnnotation(annotations map[string]string) (*api.NodeAffinity, error) {
0000000000000000000000000000000000000000;;		if len(annotations) > 0 && annotations[api.AlphaStorageNodeAffinityAnnotation] != "" {
0000000000000000000000000000000000000000;;			var affinity api.NodeAffinity
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(annotations[api.AlphaStorageNodeAffinityAnnotation]), &affinity)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &affinity, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts NodeAffinity type to Alpha annotation for use in PersistentVolumes
0000000000000000000000000000000000000000;;	// TODO: update when storage node affinity graduates to beta
0000000000000000000000000000000000000000;;	func StorageNodeAffinityToAlphaAnnotation(annotations map[string]string, affinity *api.NodeAffinity) error {
0000000000000000000000000000000000000000;;		if affinity == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		json, err := json.Marshal(*affinity)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations[api.AlphaStorageNodeAffinityAnnotation] = string(json)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
