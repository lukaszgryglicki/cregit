0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
e576b19a0d801645735882637a52ca9f8f9a7465;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package api_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		kapitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doRoundTrip(t *testing.T, group testapi.TestGroup, kind string) {
0000000000000000000000000000000000000000;;		// We do fuzzing on the internal version of the object, and only then
0000000000000000000000000000000000000000;;		// convert to the external version. This is because custom fuzzing
0000000000000000000000000000000000000000;;		// function are only supported for internal objects.
0000000000000000000000000000000000000000;;		internalObj, err := api.Scheme.New(group.InternalGroupVersion().WithKind(kind))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create internal object %v: %v", kind, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seed := rand.Int63()
0000000000000000000000000000000000000000;;		apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(seed)).
0000000000000000000000000000000000000000;;			// We are explicitly overwriting custom fuzzing functions, to ensure
0000000000000000000000000000000000000000;;			// that InitContainers and their statuses are not generated. This is
0000000000000000000000000000000000000000;;			// because in thise test we are simply doing json operations, in which
0000000000000000000000000000000000000000;;			// those disappear.
0000000000000000000000000000000000000000;;			Funcs(
0000000000000000000000000000000000000000;;				func(s *api.PodSpec, c fuzz.Continue) {
0000000000000000000000000000000000000000;;					c.FuzzNoCustom(s)
0000000000000000000000000000000000000000;;					s.InitContainers = nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				func(s *api.PodStatus, c fuzz.Continue) {
0000000000000000000000000000000000000000;;					c.FuzzNoCustom(s)
0000000000000000000000000000000000000000;;					s.InitContainerStatuses = nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			).Fuzz(internalObj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item, err := api.Scheme.New(group.GroupVersion().WithKind(kind))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't create external object %v: %v", kind, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := api.Scheme.Convert(internalObj, item, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Conversion for %v failed: %v", kind, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := json.Marshal(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when marshaling object: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unstr := make(map[string]interface{})
0000000000000000000000000000000000000000;;		err = json.Unmarshal(data, &unstr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when unmarshaling to unstructured: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err = json.Marshal(unstr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when marshaling unstructured: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unmarshalledObj := reflect.New(reflect.TypeOf(item).Elem()).Interface()
0000000000000000000000000000000000000000;;		err = json.Unmarshal(data, &unmarshalledObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when unmarshaling to object: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(item, unmarshalledObj) {
0000000000000000000000000000000000000000;;			t.Errorf("Object changed during JSON operations, diff: %v", diff.ObjectReflectDiff(item, unmarshalledObj))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newUnstr, err := unstructured.DefaultConverter.ToUnstructured(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("ToUnstructured failed: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newObj := reflect.New(reflect.TypeOf(item).Elem()).Interface().(runtime.Object)
0000000000000000000000000000000000000000;;		err = unstructured.DefaultConverter.FromUnstructured(newUnstr, newObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("FromUnstructured failed: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(item, newObj) {
0000000000000000000000000000000000000000;;			t.Errorf("Object changed, diff: %v", diff.ObjectReflectDiff(item, newObj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		for groupKey, group := range testapi.Groups {
0000000000000000000000000000000000000000;;			for kind := range group.ExternalTypes() {
0000000000000000000000000000000000000000;;				if nonRoundTrippableTypes.Has(kind) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Logf("Testing: %v in %v", kind, groupKey)
0000000000000000000000000000000000000000;;				for i := 0; i < 50; i++ {
0000000000000000000000000000000000000000;;					doRoundTrip(t, group, kind)
0000000000000000000000000000000000000000;;					if t.Failed() {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkToFromUnstructured(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		size := len(items)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			unstr, err := unstructured.DefaultConverter.ToUnstructured(&items[i%size])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj := v1.Pod{}
0000000000000000000000000000000000000000;;			if err := unstructured.DefaultConverter.FromUnstructured(unstr, &obj); err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkToFromUnstructuredViaJSON(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		size := len(items)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			data, err := json.Marshal(&items[i%size])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unstr := map[string]interface{}{}
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &unstr); err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err = json.Marshal(unstr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj := v1.Pod{}
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &obj); err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
