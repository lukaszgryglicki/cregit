0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
332ebfd58d909c618b2515742de2cdcbcd2b7238;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package api_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/proto"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/protobuf"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		kapitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		_ "k8s.io/kubernetes/pkg/apis/extensions/v1beta1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUniversalDeserializer(t *testing.T) {
0000000000000000000000000000000000000000;;		expected := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "test"}}
0000000000000000000000000000000000000000;;		d := api.Codecs.UniversalDeserializer()
0000000000000000000000000000000000000000;;		for _, mediaType := range []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"} {
0000000000000000000000000000000000000000;;			info, ok := runtime.SerializerInfoForMediaType(api.Codecs.SupportedMediaTypes(), mediaType)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Fatal(mediaType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			if err := info.Serializer.Encode(expected, buf); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: %v", mediaType, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, _, err := d.Decode(buf.Bytes(), &schema.GroupVersionKind{Kind: "Pod", Version: "v1"}, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: %v", mediaType, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(expected, obj) {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: %#v", mediaType, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllFieldsHaveTags(t *testing.T) {
0000000000000000000000000000000000000000;;		for gvk, obj := range api.Scheme.AllKnownTypes() {
0000000000000000000000000000000000000000;;			if gvk.Version == runtime.APIVersionInternal {
0000000000000000000000000000000000000000;;				// internal versions are not serialized to protobuf
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gvk.Group == "componentconfig" {
0000000000000000000000000000000000000000;;				// component config is not serialized to protobuf
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := fieldsHaveProtobufTags(obj); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("type %s as gvk %v is missing tags: %v", obj, gvk, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fieldsHaveProtobufTags(obj reflect.Type) error {
0000000000000000000000000000000000000000;;		switch obj.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice, reflect.Map, reflect.Ptr, reflect.Array:
0000000000000000000000000000000000000000;;			return fieldsHaveProtobufTags(obj.Elem())
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < obj.NumField(); i++ {
0000000000000000000000000000000000000000;;				f := obj.Field(i)
0000000000000000000000000000000000000000;;				if f.Name == "TypeMeta" && f.Type.Name() == "TypeMeta" {
0000000000000000000000000000000000000000;;					// TypeMeta is not included in external protobuf because we use an envelope type with TypeMeta
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(f.Tag.Get("json")) > 0 && len(f.Tag.Get("protobuf")) == 0 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("field %s in %s has a 'json' tag but no protobuf tag", f.Name, obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProtobufRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		obj := &v1.Pod{}
0000000000000000000000000000000000000000;;		apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(benchmarkSeed)).Fuzz(obj)
0000000000000000000000000000000000000000;;		// InitContainers are turned into annotations by conversion.
0000000000000000000000000000000000000000;;		obj.Spec.InitContainers = nil
0000000000000000000000000000000000000000;;		obj.Status.InitContainerStatuses = nil
0000000000000000000000000000000000000000;;		data, err := obj.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := &v1.Pod{}
0000000000000000000000000000000000000000;;		if err := out.Unmarshal(data); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.Equalities.DeepEqual(out, obj) {
0000000000000000000000000000000000000000;;			t.Logf("marshal\n%s", hex.Dump(data))
0000000000000000000000000000000000000000;;			t.Fatalf("Unmarshal is unequal\n%s", diff.ObjectGoPrintDiff(out, obj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkEncodeCodec measures the cost of performing a codec encode, which includes
0000000000000000000000000000000000000000;;	// reflection (to clear APIVersion and Kind)
0000000000000000000000000000000000000000;;	func BenchmarkEncodeCodecProtobuf(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		s := protobuf.NewSerializer(nil, nil, "application/arbitrary.content.type")
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := runtime.Encode(s, &items[i%width]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkEncodeCodecFromInternalProtobuf measures the cost of performing a codec encode,
0000000000000000000000000000000000000000;;	// including conversions and any type setting. This is a "full" encode.
0000000000000000000000000000000000000000;;	func BenchmarkEncodeCodecFromInternalProtobuf(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encodable := make([]api.Pod, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			if err := api.Scheme.Convert(&items[i], &encodable[i], nil); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := protobuf.NewSerializer(nil, nil, "application/arbitrary.content.type")
0000000000000000000000000000000000000000;;		codec := api.Codecs.EncoderForVersion(s, v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := runtime.Encode(codec, &encodable[i%width]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkEncodeProtobufGeneratedMarshal(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := items[i%width].Marshal(); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkDecodeCodecToInternalProtobuf measures the cost of performing a codec decode,
0000000000000000000000000000000000000000;;	// including conversions and any type setting. This is a "full" decode.
0000000000000000000000000000000000000000;;	func BenchmarkDecodeCodecToInternalProtobuf(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		s := protobuf.NewSerializer(api.Scheme, api.Scheme, "application/arbitrary.content.type")
0000000000000000000000000000000000000000;;		encoder := api.Codecs.EncoderForVersion(s, v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		var encoded [][]byte
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(encoder, &items[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded = append(encoded, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := api.Codecs.DecoderToVersion(s, api.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := runtime.Decode(decoder, encoded[i%width]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkDecodeJSON provides a baseline for regular JSON decode performance
0000000000000000000000000000000000000000;;	func BenchmarkDecodeIntoProtobuf(b *testing.B) {
0000000000000000000000000000000000000000;;		items := benchmarkItems(b)
0000000000000000000000000000000000000000;;		width := len(items)
0000000000000000000000000000000000000000;;		encoded := make([][]byte, width)
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			data, err := (&items[i]).Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encoded[i] = data
0000000000000000000000000000000000000000;;			validate := &v1.Pod{}
0000000000000000000000000000000000000000;;			if err := proto.Unmarshal(data, validate); err != nil {
0000000000000000000000000000000000000000;;				b.Fatalf("Failed to unmarshal %d: %v\n%#v", i, err, items[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			obj := v1.Pod{}
0000000000000000000000000000000000000000;;			if err := proto.Unmarshal(encoded[i%width], &obj); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
