0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6c6c543f52c504a5989151edaa9198778b792f29;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPodSecrets(t *testing.T) {
0000000000000000000000000000000000000000;;		// Stub containing all possible secret references in a pod.
0000000000000000000000000000000000000000;;		// The names of the referenced secrets match struct paths detected by reflection.
0000000000000000000000000000000000000000;;		pod := &api.Pod{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []api.Container{{
0000000000000000000000000000000000000000;;					EnvFrom: []api.EnvFromSource{{
0000000000000000000000000000000000000000;;						SecretRef: &api.SecretEnvSource{
0000000000000000000000000000000000000000;;							LocalObjectReference: api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Containers[*].EnvFrom[*].SecretRef"}}}},
0000000000000000000000000000000000000000;;					Env: []api.EnvVar{{
0000000000000000000000000000000000000000;;						ValueFrom: &api.EnvVarSource{
0000000000000000000000000000000000000000;;							SecretKeyRef: &api.SecretKeySelector{
0000000000000000000000000000000000000000;;								LocalObjectReference: api.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: "Spec.Containers[*].Env[*].ValueFrom.SecretKeyRef"}}}}}}},
0000000000000000000000000000000000000000;;				ImagePullSecrets: []api.LocalObjectReference{{
0000000000000000000000000000000000000000;;					Name: "Spec.ImagePullSecrets"}},
0000000000000000000000000000000000000000;;				InitContainers: []api.Container{{
0000000000000000000000000000000000000000;;					EnvFrom: []api.EnvFromSource{{
0000000000000000000000000000000000000000;;						SecretRef: &api.SecretEnvSource{
0000000000000000000000000000000000000000;;							LocalObjectReference: api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.InitContainers[*].EnvFrom[*].SecretRef"}}}},
0000000000000000000000000000000000000000;;					Env: []api.EnvVar{{
0000000000000000000000000000000000000000;;						ValueFrom: &api.EnvVarSource{
0000000000000000000000000000000000000000;;							SecretKeyRef: &api.SecretKeySelector{
0000000000000000000000000000000000000000;;								LocalObjectReference: api.LocalObjectReference{
0000000000000000000000000000000000000000;;									Name: "Spec.InitContainers[*].Env[*].ValueFrom.SecretKeyRef"}}}}}}},
0000000000000000000000000000000000000000;;				Volumes: []api.Volume{{
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						AzureFile: &api.AzureFileVolumeSource{
0000000000000000000000000000000000000000;;							SecretName: "Spec.Volumes[*].VolumeSource.AzureFile.SecretName"}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						CephFS: &api.CephFSVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.CephFS.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						FlexVolume: &api.FlexVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.FlexVolume.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						Projected: &api.ProjectedVolumeSource{
0000000000000000000000000000000000000000;;							Sources: []api.VolumeProjection{{
0000000000000000000000000000000000000000;;								Secret: &api.SecretProjection{
0000000000000000000000000000000000000000;;									LocalObjectReference: api.LocalObjectReference{
0000000000000000000000000000000000000000;;										Name: "Spec.Volumes[*].VolumeSource.Projected.Sources[*].Secret"}}}}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						RBD: &api.RBDVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.RBD.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						Secret: &api.SecretVolumeSource{
0000000000000000000000000000000000000000;;							SecretName: "Spec.Volumes[*].VolumeSource.Secret.SecretName"}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						Secret: &api.SecretVolumeSource{
0000000000000000000000000000000000000000;;							SecretName: "Spec.Volumes[*].VolumeSource.Secret"}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						ScaleIO: &api.ScaleIOVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.ScaleIO.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						ISCSI: &api.ISCSIVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.ISCSI.SecretRef"}}}}, {
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						StorageOS: &api.StorageOSVolumeSource{
0000000000000000000000000000000000000000;;							SecretRef: &api.LocalObjectReference{
0000000000000000000000000000000000000000;;								Name: "Spec.Volumes[*].VolumeSource.StorageOS.SecretRef"}}}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extractedNames := sets.NewString()
0000000000000000000000000000000000000000;;		VisitPodSecretNames(pod, func(name string) bool {
0000000000000000000000000000000000000000;;			extractedNames.Insert(name)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// excludedSecretPaths holds struct paths to fields with "secret" in the name that are not actually references to secret API objects
0000000000000000000000000000000000000000;;		excludedSecretPaths := sets.NewString(
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.CephFS.SecretFile",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// expectedSecretPaths holds struct paths to fields with "secret" in the name that are references to secret API objects.
0000000000000000000000000000000000000000;;		// every path here should be represented as an example in the Pod stub above, with the secret name set to the path.
0000000000000000000000000000000000000000;;		expectedSecretPaths := sets.NewString(
0000000000000000000000000000000000000000;;			"Spec.Containers[*].EnvFrom[*].SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Containers[*].Env[*].ValueFrom.SecretKeyRef",
0000000000000000000000000000000000000000;;			"Spec.ImagePullSecrets",
0000000000000000000000000000000000000000;;			"Spec.InitContainers[*].EnvFrom[*].SecretRef",
0000000000000000000000000000000000000000;;			"Spec.InitContainers[*].Env[*].ValueFrom.SecretKeyRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.AzureFile.SecretName",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.CephFS.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.FlexVolume.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.Projected.Sources[*].Secret",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.RBD.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.Secret",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.Secret.SecretName",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.ScaleIO.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.ISCSI.SecretRef",
0000000000000000000000000000000000000000;;			"Spec.Volumes[*].VolumeSource.StorageOS.SecretRef",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		secretPaths := collectSecretPaths(t, nil, "", reflect.TypeOf(&api.Pod{}))
0000000000000000000000000000000000000000;;		secretPaths = secretPaths.Difference(excludedSecretPaths)
0000000000000000000000000000000000000000;;		if missingPaths := expectedSecretPaths.Difference(secretPaths); len(missingPaths) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Missing expected secret paths:\n%s", strings.Join(missingPaths.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Missing expected secret paths. Verify VisitPodSecretNames() is correctly finding the missing paths, then correct expectedSecretPaths")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraPaths := secretPaths.Difference(expectedSecretPaths); len(extraPaths) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Extra secret paths:\n%s", strings.Join(extraPaths.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Extra fields with 'secret' in the name found. Verify VisitPodSecretNames() is including these fields if appropriate, then correct expectedSecretPaths")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if missingNames := expectedSecretPaths.Difference(extractedNames); len(missingNames) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Missing expected secret names:\n%s", strings.Join(missingNames.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Missing expected secret names. Verify the pod stub above includes these references, then verify VisitPodSecretNames() is correctly finding the missing names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraNames := extractedNames.Difference(expectedSecretPaths); len(extraNames) > 0 {
0000000000000000000000000000000000000000;;			t.Logf("Extra secret names:\n%s", strings.Join(extraNames.List(), "\n"))
0000000000000000000000000000000000000000;;			t.Error("Extra secret names extracted. Verify VisitPodSecretNames() is correctly extracting secret names")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// collectSecretPaths traverses the object, computing all the struct paths that lead to fields with "secret" in the name.
0000000000000000000000000000000000000000;;	func collectSecretPaths(t *testing.T, path *field.Path, name string, tp reflect.Type) sets.String {
0000000000000000000000000000000000000000;;		secretPaths := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tp.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path, name, tp.Elem()).List()...)
0000000000000000000000000000000000000000;;			return secretPaths
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.Contains(strings.ToLower(name), "secret") {
0000000000000000000000000000000000000000;;			secretPaths.Insert(path.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tp.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path, name, tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < tp.NumField(); i++ {
0000000000000000000000000000000000000000;;				field := tp.Field(i)
0000000000000000000000000000000000000000;;				secretPaths.Insert(collectSecretPaths(t, path.Child(field.Name), field.Name, field.Type).List()...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			t.Errorf("cannot find secret fields in interface{} field %s", path.String())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path.Key("*"), "", tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			secretPaths.Insert(collectSecretPaths(t, path.Key("*"), "", tp.Elem()).List()...)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// all primitive types
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return secretPaths
0000000000000000000000000000000000000000;;	}
