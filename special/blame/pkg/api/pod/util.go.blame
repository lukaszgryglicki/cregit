0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
8dbfda939a3d19f7ec3ab9e84f462ad209df6c0a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visitor is called with each object name, and returns true if visiting should continue
0000000000000000000000000000000000000000;;	type Visitor func(name string) (shouldContinue bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitPodSecretNames invokes the visitor function with the name of every secret
0000000000000000000000000000000000000000;;	// referenced by the pod spec. If visitor returns false, visiting is short-circuited.
0000000000000000000000000000000000000000;;	// Transitive references (e.g. pod -> pvc -> pv -> secret) are not visited.
0000000000000000000000000000000000000000;;	// Returns true if visiting completed, false if visiting was short-circuited.
0000000000000000000000000000000000000000;;	func VisitPodSecretNames(pod *api.Pod, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for _, reference := range pod.Spec.ImagePullSecrets {
0000000000000000000000000000000000000000;;			if !visitor(reference.Name) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if !visitContainerSecretNames(&pod.Spec.InitContainers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if !visitContainerSecretNames(&pod.Spec.Containers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var source *api.VolumeSource
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			source = &pod.Spec.Volumes[i].VolumeSource
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case source.AzureFile != nil:
0000000000000000000000000000000000000000;;				if len(source.AzureFile.SecretName) > 0 && !visitor(source.AzureFile.SecretName) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.CephFS != nil:
0000000000000000000000000000000000000000;;				if source.CephFS.SecretRef != nil && !visitor(source.CephFS.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.FlexVolume != nil:
0000000000000000000000000000000000000000;;				if source.FlexVolume.SecretRef != nil && !visitor(source.FlexVolume.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.Projected != nil:
0000000000000000000000000000000000000000;;				for j := range source.Projected.Sources {
0000000000000000000000000000000000000000;;					if source.Projected.Sources[j].Secret != nil {
0000000000000000000000000000000000000000;;						if !visitor(source.Projected.Sources[j].Secret.Name) {
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.RBD != nil:
0000000000000000000000000000000000000000;;				if source.RBD.SecretRef != nil && !visitor(source.RBD.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.Secret != nil:
0000000000000000000000000000000000000000;;				if !visitor(source.Secret.SecretName) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.ScaleIO != nil:
0000000000000000000000000000000000000000;;				if source.ScaleIO.SecretRef != nil && !visitor(source.ScaleIO.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.ISCSI != nil:
0000000000000000000000000000000000000000;;				if source.ISCSI.SecretRef != nil && !visitor(source.ISCSI.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.StorageOS != nil:
0000000000000000000000000000000000000000;;				if source.StorageOS.SecretRef != nil && !visitor(source.StorageOS.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func visitContainerSecretNames(container *api.Container, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for _, env := range container.EnvFrom {
0000000000000000000000000000000000000000;;			if env.SecretRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(env.SecretRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, envVar := range container.Env {
0000000000000000000000000000000000000000;;			if envVar.ValueFrom != nil && envVar.ValueFrom.SecretKeyRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(envVar.ValueFrom.SecretKeyRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitPodConfigmapNames invokes the visitor function with the name of every configmap
0000000000000000000000000000000000000000;;	// referenced by the pod spec. If visitor returns false, visiting is short-circuited.
0000000000000000000000000000000000000000;;	// Transitive references (e.g. pod -> pvc -> pv -> secret) are not visited.
0000000000000000000000000000000000000000;;	// Returns true if visiting completed, false if visiting was short-circuited.
0000000000000000000000000000000000000000;;	func VisitPodConfigmapNames(pod *api.Pod, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for i := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			if !visitContainerConfigmapNames(&pod.Spec.InitContainers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			if !visitContainerConfigmapNames(&pod.Spec.Containers[i], visitor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var source *api.VolumeSource
0000000000000000000000000000000000000000;;		for i := range pod.Spec.Volumes {
0000000000000000000000000000000000000000;;			source = &pod.Spec.Volumes[i].VolumeSource
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case source.Projected != nil:
0000000000000000000000000000000000000000;;				for j := range source.Projected.Sources {
0000000000000000000000000000000000000000;;					if source.Projected.Sources[j].ConfigMap != nil {
0000000000000000000000000000000000000000;;						if !visitor(source.Projected.Sources[j].ConfigMap.Name) {
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case source.ConfigMap != nil:
0000000000000000000000000000000000000000;;				if !visitor(source.ConfigMap.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func visitContainerConfigmapNames(container *api.Container, visitor Visitor) bool {
0000000000000000000000000000000000000000;;		for _, env := range container.EnvFrom {
0000000000000000000000000000000000000000;;			if env.ConfigMapRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(env.ConfigMapRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, envVar := range container.Env {
0000000000000000000000000000000000000000;;			if envVar.ValueFrom != nil && envVar.ValueFrom.ConfigMapKeyRef != nil {
0000000000000000000000000000000000000000;;				if !visitor(envVar.ValueFrom.ConfigMapKeyRef.Name) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPodReady returns true if a pod is ready; false otherwise.
0000000000000000000000000000000000000000;;	func IsPodReady(pod *api.Pod) bool {
0000000000000000000000000000000000000000;;		return IsPodReadyConditionTrue(pod.Status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPodReadyConditionTrue retruns true if a pod is ready; false otherwise.
0000000000000000000000000000000000000000;;	func IsPodReadyConditionTrue(status api.PodStatus) bool {
0000000000000000000000000000000000000000;;		condition := GetPodReadyCondition(status)
0000000000000000000000000000000000000000;;		return condition != nil && condition.Status == api.ConditionTrue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodReadyCondition extracts the pod ready condition from the given status and returns that.
0000000000000000000000000000000000000000;;	// Returns nil if the condition is not present.
0000000000000000000000000000000000000000;;	func GetPodReadyCondition(status api.PodStatus) *api.PodCondition {
0000000000000000000000000000000000000000;;		_, condition := GetPodCondition(&status, api.PodReady)
0000000000000000000000000000000000000000;;		return condition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPodCondition extracts the provided condition from the given status and returns that.
0000000000000000000000000000000000000000;;	// Returns nil and -1 if the condition is not present, and the index of the located condition.
0000000000000000000000000000000000000000;;	func GetPodCondition(status *api.PodStatus, conditionType api.PodConditionType) (int, *api.PodCondition) {
0000000000000000000000000000000000000000;;		if status == nil {
0000000000000000000000000000000000000000;;			return -1, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range status.Conditions {
0000000000000000000000000000000000000000;;			if status.Conditions[i].Type == conditionType {
0000000000000000000000000000000000000000;;				return i, &status.Conditions[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdatePodCondition updates existing pod condition or creates a new one. Sets LastTransitionTime to now if the
0000000000000000000000000000000000000000;;	// status has changed.
0000000000000000000000000000000000000000;;	// Returns true if pod condition has changed or has been added.
0000000000000000000000000000000000000000;;	func UpdatePodCondition(status *api.PodStatus, condition *api.PodCondition) bool {
0000000000000000000000000000000000000000;;		condition.LastTransitionTime = metav1.Now()
0000000000000000000000000000000000000000;;		// Try to find this pod condition.
0000000000000000000000000000000000000000;;		conditionIndex, oldCondition := GetPodCondition(status, condition.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldCondition == nil {
0000000000000000000000000000000000000000;;			// We are adding new pod condition.
0000000000000000000000000000000000000000;;			status.Conditions = append(status.Conditions, *condition)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We are updating an existing condition, so we need to check if it has changed.
0000000000000000000000000000000000000000;;		if condition.Status == oldCondition.Status {
0000000000000000000000000000000000000000;;			condition.LastTransitionTime = oldCondition.LastTransitionTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isEqual := condition.Status == oldCondition.Status &&
0000000000000000000000000000000000000000;;			condition.Reason == oldCondition.Reason &&
0000000000000000000000000000000000000000;;			condition.Message == oldCondition.Message &&
0000000000000000000000000000000000000000;;			condition.LastProbeTime.Equal(oldCondition.LastProbeTime) &&
0000000000000000000000000000000000000000;;			condition.LastTransitionTime.Equal(oldCondition.LastTransitionTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status.Conditions[conditionIndex] = *condition
0000000000000000000000000000000000000000;;		// Return true if one of the fields have changed.
0000000000000000000000000000000000000000;;		return !isEqual
0000000000000000000000000000000000000000;;	}
