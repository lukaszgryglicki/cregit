0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
01391205aa48b912aed1bac581f7e55df1e0aade;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful-swagger12"
0000000000000000000000000000000000000000;;		ejson "github.com/exponent-io/jsonpath"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		apiutil "k8s.io/kubernetes/pkg/api/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InvalidTypeError struct {
0000000000000000000000000000000000000000;;		ExpectedKind reflect.Kind
0000000000000000000000000000000000000000;;		ObservedKind reflect.Kind
0000000000000000000000000000000000000000;;		FieldName    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *InvalidTypeError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("expected type %s, for field %s, got %s", i.ExpectedKind.String(), i.FieldName, i.ObservedKind.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewInvalidTypeError(expected reflect.Kind, observed reflect.Kind, fieldName string) error {
0000000000000000000000000000000000000000;;		return &InvalidTypeError{expected, observed, fieldName}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeNotFoundError is returned when specified type
0000000000000000000000000000000000000000;;	// can not found in schema
0000000000000000000000000000000000000000;;	type TypeNotFoundError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tnfe TypeNotFoundError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("couldn't find type: %s", string(tnfe))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Schema is an interface that knows how to validate an API object serialized to a byte array.
0000000000000000000000000000000000000000;;	type Schema interface {
0000000000000000000000000000000000000000;;		ValidateBytes(data []byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NullSchema struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (NullSchema) ValidateBytes(data []byte) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NoDoubleKeySchema struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (NoDoubleKeySchema) ValidateBytes(data []byte) error {
0000000000000000000000000000000000000000;;		var list []error = nil
0000000000000000000000000000000000000000;;		if err := validateNoDuplicateKeys(data, "metadata", "labels"); err != nil {
0000000000000000000000000000000000000000;;			list = append(list, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := validateNoDuplicateKeys(data, "metadata", "annotations"); err != nil {
0000000000000000000000000000000000000000;;			list = append(list, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(list)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateNoDuplicateKeys(data []byte, path ...string) error {
0000000000000000000000000000000000000000;;		r := ejson.NewDecoder(bytes.NewReader(data))
0000000000000000000000000000000000000000;;		// This is Go being unfriendly. The 'path ...string' comes in as a
0000000000000000000000000000000000000000;;		// []string, and SeekTo takes ...interface{}, so we can't just pass
0000000000000000000000000000000000000000;;		// the path straight in, we have to copy it.  *sigh*
0000000000000000000000000000000000000000;;		ifacePath := []interface{}{}
0000000000000000000000000000000000000000;;		for ix := range path {
0000000000000000000000000000000000000000;;			ifacePath = append(ifacePath, path[ix])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		found, err := r.SeekTo(ifacePath...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seen := map[string]bool{}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok, err := r.Token()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := tok.(type) {
0000000000000000000000000000000000000000;;			case json.Delim:
0000000000000000000000000000000000000000;;				if t.String() == "}" {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ejson.KeyString:
0000000000000000000000000000000000000000;;				if seen[string(t)] {
0000000000000000000000000000000000000000;;					return fmt.Errorf("duplicate key: %s", string(t))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					seen[string(t)] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConjunctiveSchema []Schema
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c ConjunctiveSchema) ValidateBytes(data []byte) error {
0000000000000000000000000000000000000000;;		var list []error = nil
0000000000000000000000000000000000000000;;		schemas := []Schema(c)
0000000000000000000000000000000000000000;;		for ix := range schemas {
0000000000000000000000000000000000000000;;			if err := schemas[ix].ValidateBytes(data); err != nil {
0000000000000000000000000000000000000000;;				list = append(list, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(list)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SwaggerSchema struct {
0000000000000000000000000000000000000000;;		api      swagger.ApiDeclaration
0000000000000000000000000000000000000000;;		delegate Schema // For delegating to other api groups
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSwaggerSchemaFromBytes(data []byte, factory Schema) (Schema, error) {
0000000000000000000000000000000000000000;;		schema := &SwaggerSchema{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(data, &schema.api)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schema.delegate = factory
0000000000000000000000000000000000000000;;		return schema, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateList unpacks a list and validate every item in the list.
0000000000000000000000000000000000000000;;	// It return nil if every item is ok.
0000000000000000000000000000000000000000;;	// Otherwise it return an error list contain errors of every item.
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) validateList(obj map[string]interface{}) []error {
0000000000000000000000000000000000000000;;		items, exists := obj["items"]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return []error{fmt.Errorf("no items field in %#v", obj)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.validateItems(items)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) validateItems(items interface{}) []error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		itemList, ok := items.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return append(allErrs, fmt.Errorf("items isn't a slice"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, item := range itemList {
0000000000000000000000000000000000000000;;			fields, ok := item.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("items[%d] isn't a map[string]interface{}", i))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groupVersion := fields["apiVersion"]
0000000000000000000000000000000000000000;;			if groupVersion == nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("items[%d].apiVersion not set", i))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			itemVersion, ok := groupVersion.(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("items[%d].apiVersion isn't string type", i))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(itemVersion) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("items[%d].apiVersion is empty", i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kind := fields["kind"]
0000000000000000000000000000000000000000;;			if kind == nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("items[%d].kind not set", i))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			itemKind, ok := kind.(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("items[%d].kind isn't string type", i))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(itemKind) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("items[%d].kind is empty", i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			version := apiutil.GetVersion(itemVersion)
0000000000000000000000000000000000000000;;			errs := s.ValidateObject(item, "", version+"."+itemKind)
0000000000000000000000000000000000000000;;			if len(errs) >= 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, errs...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) ValidateBytes(data []byte) error {
0000000000000000000000000000000000000000;;		var obj interface{}
0000000000000000000000000000000000000000;;		out, err := yaml.ToJSON(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data = out
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields, ok := obj.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error in unmarshaling data %s", string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupVersion := fields["apiVersion"]
0000000000000000000000000000000000000000;;		if groupVersion == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("apiVersion not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := groupVersion.(string); !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("apiVersion isn't string type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kind := fields["kind"]
0000000000000000000000000000000000000000;;		if kind == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("kind not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := kind.(string); !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("kind isn't string type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(kind.(string), "List") {
0000000000000000000000000000000000000000;;			return utilerrors.NewAggregate(s.validateList(fields))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version := apiutil.GetVersion(groupVersion.(string))
0000000000000000000000000000000000000000;;		allErrs := s.ValidateObject(obj, "", version+"."+kind.(string))
0000000000000000000000000000000000000000;;		if len(allErrs) == 1 {
0000000000000000000000000000000000000000;;			return allErrs[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) ValidateObject(obj interface{}, fieldName, typeName string) []error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		models := s.api.Models
0000000000000000000000000000000000000000;;		model, ok := models.At(typeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify the api version matches.  This is required for nested types with differing api versions because
0000000000000000000000000000000000000000;;		// s.api only has schema for 1 api version (the parent object type's version).
0000000000000000000000000000000000000000;;		// e.g. an extensions/v1beta1 Template embedding a /v1 Service requires the schema for the extensions/v1beta1
0000000000000000000000000000000000000000;;		// api to delegate to the schema for the /v1 api.
0000000000000000000000000000000000000000;;		// Only do this for !ok objects so that cross ApiVersion vendored types take precedence.
0000000000000000000000000000000000000000;;		if !ok && s.delegate != nil {
0000000000000000000000000000000000000000;;			fields, mapOk := obj.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !mapOk {
0000000000000000000000000000000000000000;;				return append(allErrs, fmt.Errorf("field %s for %s: expected object of type map[string]interface{}, but the actual type is %T", fieldName, typeName, obj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if delegated, err := s.delegateIfDifferentApiVersion(&unstructured.Unstructured{Object: fields}); delegated {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return allErrs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return append(allErrs, TypeNotFoundError(typeName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		properties := model.Properties
0000000000000000000000000000000000000000;;		if len(properties.List) == 0 {
0000000000000000000000000000000000000000;;			// The object does not have any sub-fields.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields, ok := obj.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return append(allErrs, fmt.Errorf("field %s for %s: expected object of type map[string]interface{}, but the actual type is %T", fieldName, typeName, obj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fieldName) > 0 {
0000000000000000000000000000000000000000;;			fieldName = fieldName + "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle required fields
0000000000000000000000000000000000000000;;		for _, requiredKey := range model.Required {
0000000000000000000000000000000000000000;;			if _, ok := fields[requiredKey]; !ok {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("field %s%s for %s is required", fieldName, requiredKey, typeName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, value := range fields {
0000000000000000000000000000000000000000;;			details, ok := properties.At(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Special case for runtime.RawExtension and runtime.Objects because they always fail to validate
0000000000000000000000000000000000000000;;			// This is because the actual values will be of some sub-type (e.g. Deployment) not the expected
0000000000000000000000000000000000000000;;			// super-type (RawExtension)
0000000000000000000000000000000000000000;;			if s.isGenericArray(details) {
0000000000000000000000000000000000000000;;				errs := s.validateItems(value)
0000000000000000000000000000000000000000;;				if len(errs) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, errs...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("found invalid field %s for %s", key, typeName))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if details.Type == nil && details.Ref == nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("could not find the type of %s%s from object %v", fieldName, key, details))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var fieldType string
0000000000000000000000000000000000000000;;			if details.Type != nil {
0000000000000000000000000000000000000000;;				fieldType = *details.Type
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fieldType = *details.Ref
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value == nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Skipping nil field: %s%s", fieldName, key)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errs := s.validateField(value, fieldName+key, fieldType, &details)
0000000000000000000000000000000000000000;;			if len(errs) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, errs...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delegateIfDifferentApiVersion delegates the validation of an object if its ApiGroup does not match the
0000000000000000000000000000000000000000;;	// current SwaggerSchema.
0000000000000000000000000000000000000000;;	// First return value is true if the validation was delegated (by a different ApiGroup SwaggerSchema)
0000000000000000000000000000000000000000;;	// Second return value is the result of the delegated validation if performed.
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) delegateIfDifferentApiVersion(obj *unstructured.Unstructured) (bool, error) {
0000000000000000000000000000000000000000;;		// Never delegate objects in the same ApiVersion or we will get infinite recursion
0000000000000000000000000000000000000000;;		if !s.isDifferentApiVersion(obj) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert the object back into bytes so that we can pass it to the ValidateBytes function
0000000000000000000000000000000000000000;;		m, err := json.Marshal(obj.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delegate validation of this object to the correct SwaggerSchema for its ApiGroup
0000000000000000000000000000000000000000;;		return true, s.delegate.ValidateBytes(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isDifferentApiVersion Returns true if obj lives in a different ApiVersion than the SwaggerSchema does.
0000000000000000000000000000000000000000;;	// The SwaggerSchema will not be able to process objects in different ApiVersions unless they are vendored.
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) isDifferentApiVersion(obj *unstructured.Unstructured) bool {
0000000000000000000000000000000000000000;;		groupVersion := obj.GetAPIVersion()
0000000000000000000000000000000000000000;;		return len(groupVersion) > 0 && s.api.ApiVersion != groupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isGenericArray Returns true if p is an array of generic Objects - either RawExtension or Object.
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) isGenericArray(p swagger.ModelProperty) bool {
0000000000000000000000000000000000000000;;		return p.DataTypeFields.Type != nil &&
0000000000000000000000000000000000000000;;			*p.DataTypeFields.Type == "array" &&
0000000000000000000000000000000000000000;;			p.Items != nil &&
0000000000000000000000000000000000000000;;			p.Items.Ref != nil &&
0000000000000000000000000000000000000000;;			(*p.Items.Ref == "runtime.RawExtension" || *p.Items.Ref == "runtime.Object")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This matches type name in the swagger spec, such as "v1.Binding".
0000000000000000000000000000000000000000;;	var versionRegexp = regexp.MustCompile(`^(v.+|unversioned|types)\..*`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SwaggerSchema) validateField(value interface{}, fieldName, fieldType string, fieldDetails *swagger.ModelProperty) []error {
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		if reflect.TypeOf(value) == nil {
0000000000000000000000000000000000000000;;			return append(allErrs, fmt.Errorf("unexpected nil value for field %v", fieldName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: caesarxuchao: because we have multiple group/versions and objects
0000000000000000000000000000000000000000;;		// may reference objects in other group, the commented out way of checking
0000000000000000000000000000000000000000;;		// if a filedType is a type defined by us is outdated. We use a hacky way
0000000000000000000000000000000000000000;;		// for now.
0000000000000000000000000000000000000000;;		// TODO: the type name in the swagger spec is something like "v1.Binding",
0000000000000000000000000000000000000000;;		// and the "v1" is generated from the package name, not the groupVersion of
0000000000000000000000000000000000000000;;		// the type. We need to fix go-restful to embed the group name in the type
0000000000000000000000000000000000000000;;		// name, otherwise we couldn't handle identically named types in different
0000000000000000000000000000000000000000;;		// groups correctly.
0000000000000000000000000000000000000000;;		if versionRegexp.MatchString(fieldType) {
0000000000000000000000000000000000000000;;			// if strings.HasPrefix(fieldType, apiVersion) {
0000000000000000000000000000000000000000;;			return s.ValidateObject(value, fieldName, fieldType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch fieldType {
0000000000000000000000000000000000000000;;		case "string":
0000000000000000000000000000000000000000;;			// Be loose about what we accept for 'string' since we use IntOrString in a couple of places
0000000000000000000000000000000000000000;;			_, isString := value.(string)
0000000000000000000000000000000000000000;;			_, isNumber := value.(float64)
0000000000000000000000000000000000000000;;			_, isInteger := value.(int)
0000000000000000000000000000000000000000;;			if !isString && !isNumber && !isInteger {
0000000000000000000000000000000000000000;;				return append(allErrs, NewInvalidTypeError(reflect.String, reflect.TypeOf(value).Kind(), fieldName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "array":
0000000000000000000000000000000000000000;;			arr, ok := value.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return append(allErrs, NewInvalidTypeError(reflect.Array, reflect.TypeOf(value).Kind(), fieldName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var arrType string
0000000000000000000000000000000000000000;;			if fieldDetails.Items.Ref == nil && fieldDetails.Items.Type == nil {
0000000000000000000000000000000000000000;;				return append(allErrs, NewInvalidTypeError(reflect.Array, reflect.TypeOf(value).Kind(), fieldName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fieldDetails.Items.Ref != nil {
0000000000000000000000000000000000000000;;				arrType = *fieldDetails.Items.Ref
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				arrType = *fieldDetails.Items.Type
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for ix := range arr {
0000000000000000000000000000000000000000;;				errs := s.validateField(arr[ix], fmt.Sprintf("%s[%d]", fieldName, ix), arrType, nil)
0000000000000000000000000000000000000000;;				if len(errs) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, errs...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "uint64":
0000000000000000000000000000000000000000;;		case "int64":
0000000000000000000000000000000000000000;;		case "integer":
0000000000000000000000000000000000000000;;			_, isNumber := value.(float64)
0000000000000000000000000000000000000000;;			_, isInteger := value.(int)
0000000000000000000000000000000000000000;;			if !isNumber && !isInteger {
0000000000000000000000000000000000000000;;				return append(allErrs, NewInvalidTypeError(reflect.Int, reflect.TypeOf(value).Kind(), fieldName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "float64":
0000000000000000000000000000000000000000;;			if _, ok := value.(float64); !ok {
0000000000000000000000000000000000000000;;				return append(allErrs, NewInvalidTypeError(reflect.Float64, reflect.TypeOf(value).Kind(), fieldName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "boolean":
0000000000000000000000000000000000000000;;			if _, ok := value.(bool); !ok {
0000000000000000000000000000000000000000;;				return append(allErrs, NewInvalidTypeError(reflect.Bool, reflect.TypeOf(value).Kind(), fieldName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		// API servers before release 1.3 produce swagger spec with `type: "any"` as the fallback type, while newer servers produce spec with `type: "object"`.
0000000000000000000000000000000000000000;;		// We have both here so that kubectl can work with both old and new api servers.
0000000000000000000000000000000000000000;;		case "object":
0000000000000000000000000000000000000000;;		case "any":
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return append(allErrs, fmt.Errorf("unexpected type: %v", fieldType))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
