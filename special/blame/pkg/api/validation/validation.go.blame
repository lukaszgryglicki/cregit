0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
65fe3265cf42423e7f01f543d23e8c7ffb5efc0c;pkg/api/validation.go[pkg/api/validation.go][pkg/api/validation/validation.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		apimachineryvalidation "k8s.io/apimachinery/pkg/api/validation"
0000000000000000000000000000000000000000;;		genericvalidation "k8s.io/apimachinery/pkg/api/validation"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		unversionedvalidation "k8s.io/apimachinery/pkg/apis/meta/v1/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		apiservice "k8s.io/kubernetes/pkg/api/service"
0000000000000000000000000000000000000000;;		k8s_api_v1 "k8s.io/kubernetes/pkg/api/v1"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/capabilities"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/security/apparmor"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: delete this global variable when we enable the validation of common
0000000000000000000000000000000000000000;;	// fields by default.
0000000000000000000000000000000000000000;;	var RepairMalformedUpdates bool = genericvalidation.RepairMalformedUpdates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const isNegativeErrorMsg string = apimachineryvalidation.IsNegativeErrorMsg
0000000000000000000000000000000000000000;;	const isInvalidQuotaResource string = `must be a standard resource for quota`
0000000000000000000000000000000000000000;;	const fieldImmutableErrorMsg string = genericvalidation.FieldImmutableErrorMsg
0000000000000000000000000000000000000000;;	const isNotIntegerErrorMsg string = `must be an integer`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var pdPartitionErrorMsg string = validation.InclusiveRangeError(1, 255)
0000000000000000000000000000000000000000;;	var volumeModeErrorMsg string = "must be a number between 0 and 0777 (octal), both inclusive"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BannedOwners is a black list of object that are not allowed to be owners.
0000000000000000000000000000000000000000;;	var BannedOwners = genericvalidation.BannedOwners
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateHasLabel requires that metav1.ObjectMeta has a Label with key and expectedValue
0000000000000000000000000000000000000000;;	func ValidateHasLabel(meta metav1.ObjectMeta, fldPath *field.Path, key, expectedValue string) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		actualValue, found := meta.Labels[key]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("labels").Key(key),
0000000000000000000000000000000000000000;;				fmt.Sprintf("must be '%s'", expectedValue)))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if actualValue != expectedValue {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("labels").Key(key), meta.Labels,
0000000000000000000000000000000000000000;;				fmt.Sprintf("must be '%s'", expectedValue)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateAnnotations validates that a set of annotations are correctly defined.
0000000000000000000000000000000000000000;;	func ValidateAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		return genericvalidation.ValidateAnnotations(annotations, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateDNS1123Label(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsDNS1123Label(value) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateDNS1123Subdomain validates that a name is a proper DNS subdomain.
0000000000000000000000000000000000000000;;	func ValidateDNS1123Subdomain(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsDNS1123Subdomain(value) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidatePodSpecificAnnotations(annotations map[string]string, spec *api.PodSpec, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if value, isMirror := annotations[api.MirrorPodAnnotationKey]; isMirror {
0000000000000000000000000000000000000000;;			if len(spec.NodeName) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Key(api.MirrorPodAnnotationKey), value, "must set spec.nodeName if mirror pod annotation is set"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if annotations[api.TolerationsAnnotationKey] != "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateTolerationsInPodAnnotations(annotations, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateSeccompPodAnnotations(annotations, fldPath)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateAppArmorPodAnnotations(annotations, spec, fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sysctls, err := helper.SysctlsFromPodAnnotation(annotations[api.SysctlsPodAnnotationKey])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Key(api.SysctlsPodAnnotationKey), annotations[api.SysctlsPodAnnotationKey], err.Error()))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateSysctls(sysctls, fldPath.Key(api.SysctlsPodAnnotationKey))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unsafeSysctls, err := helper.SysctlsFromPodAnnotation(annotations[api.UnsafeSysctlsPodAnnotationKey])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Key(api.UnsafeSysctlsPodAnnotationKey), annotations[api.UnsafeSysctlsPodAnnotationKey], err.Error()))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateSysctls(unsafeSysctls, fldPath.Key(api.UnsafeSysctlsPodAnnotationKey))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inBoth := sysctlIntersection(sysctls, unsafeSysctls)
0000000000000000000000000000000000000000;;		if len(inBoth) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Key(api.UnsafeSysctlsPodAnnotationKey), strings.Join(inBoth, ", "), "can not be safe and unsafe"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateTolerationsInPodAnnotations tests that the serialized tolerations in Pod.Annotations has valid data
0000000000000000000000000000000000000000;;	func ValidateTolerationsInPodAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tolerations, err := helper.GetTolerationsFromPodAnnotations(annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, api.TolerationsAnnotationKey, err.Error()))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(tolerations) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateTolerations(tolerations, fldPath.Child(api.TolerationsAnnotationKey))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidatePodSpecificAnnotationUpdates(newPod, oldPod *api.Pod, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		newAnnotations := newPod.Annotations
0000000000000000000000000000000000000000;;		oldAnnotations := oldPod.Annotations
0000000000000000000000000000000000000000;;		for k, oldVal := range oldAnnotations {
0000000000000000000000000000000000000000;;			if newVal, exists := newAnnotations[k]; exists && newVal == oldVal {
0000000000000000000000000000000000000000;;				continue // No change.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(k, apparmor.ContainerAnnotationKeyPrefix) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Key(k), "may not remove or update AppArmor annotations"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k == api.MirrorPodAnnotationKey {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Key(k), "may not remove or update mirror pod annotation"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check for additions
0000000000000000000000000000000000000000;;		for k := range newAnnotations {
0000000000000000000000000000000000000000;;			if _, ok := oldAnnotations[k]; ok {
0000000000000000000000000000000000000000;;				continue // No change.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(k, apparmor.ContainerAnnotationKeyPrefix) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Key(k), "may not add AppArmor annotations"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k == api.MirrorPodAnnotationKey {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Key(k), "may not add mirror pod annotation"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSpecificAnnotations(newAnnotations, &newPod.Spec, fldPath)...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateEndpointsSpecificAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateOwnerReferences(ownerReferences []metav1.OwnerReference, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		return genericvalidation.ValidateOwnerReferences(ownerReferences, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNameFunc validates that the provided name is valid for a given resource type.
0000000000000000000000000000000000000000;;	// Not all resources have the same validation rules for names. Prefix is true
0000000000000000000000000000000000000000;;	// if the name will have a value appended to it.  If the name is not valid,
0000000000000000000000000000000000000000;;	// this returns a list of descriptions of individual characteristics of the
0000000000000000000000000000000000000000;;	// value that were not valid.  Otherwise this returns an empty list or nil.
0000000000000000000000000000000000000000;;	type ValidateNameFunc apimachineryvalidation.ValidateNameFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maskTrailingDash replaces the final character of a string with a subdomain safe
0000000000000000000000000000000000000000;;	// value if is a dash.
0000000000000000000000000000000000000000;;	func maskTrailingDash(name string) string {
0000000000000000000000000000000000000000;;		if strings.HasSuffix(name, "-") {
0000000000000000000000000000000000000000;;			return name[:len(name)-2] + "a"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodName can be used to check whether the given pod name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidatePodName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReplicationControllerName can be used to check whether the given replication
0000000000000000000000000000000000000000;;	// controller name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateReplicationControllerName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceName can be used to check whether the given service name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateServiceName = NameIsDNS1035Label
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNodeName can be used to check whether the given node name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateNodeName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNamespaceName can be used to check whether the given namespace name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateNamespaceName = apimachineryvalidation.ValidateNamespaceName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateLimitRangeName can be used to check whether the given limit range name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateLimitRangeName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateResourceQuotaName can be used to check whether the given
0000000000000000000000000000000000000000;;	// resource quota name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateResourceQuotaName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateSecretName can be used to check whether the given secret name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateSecretName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceAccountName can be used to check whether the given service account name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateServiceAccountName = apimachineryvalidation.ValidateServiceAccountName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateEndpointsName can be used to check whether the given endpoints name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateEndpointsName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateClusterName can be used to check whether the given cluster name is valid.
0000000000000000000000000000000000000000;;	var ValidateClusterName = genericvalidation.ValidateClusterName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateClassName can be used to check whether the given class name is valid.
0000000000000000000000000000000000000000;;	// It is defined here to avoid import cycle between pkg/apis/storage/validation
0000000000000000000000000000000000000000;;	// (where it should be) and this file.
0000000000000000000000000000000000000000;;	var ValidateClassName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePiorityClassName can be used to check whether the given priority
0000000000000000000000000000000000000000;;	// class name is valid.
0000000000000000000000000000000000000000;;	var ValidatePriorityClassName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO update all references to these functions to point to the genericvalidation ones
0000000000000000000000000000000000000000;;	// NameIsDNSSubdomain is a ValidateNameFunc for names that must be a DNS subdomain.
0000000000000000000000000000000000000000;;	func NameIsDNSSubdomain(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		return apimachineryvalidation.NameIsDNSSubdomain(name, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameIsDNSLabel is a ValidateNameFunc for names that must be a DNS 1123 label.
0000000000000000000000000000000000000000;;	func NameIsDNSLabel(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		return apimachineryvalidation.NameIsDNSLabel(name, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameIsDNS1035Label is a ValidateNameFunc for names that must be a DNS 952 label.
0000000000000000000000000000000000000000;;	func NameIsDNS1035Label(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		return apimachineryvalidation.NameIsDNS1035Label(name, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates that given value is not negative.
0000000000000000000000000000000000000000;;	func ValidateNonnegativeField(value int64, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		return apimachineryvalidation.ValidateNonnegativeField(value, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates that a Quantity is not negative
0000000000000000000000000000000000000000;;	func ValidateNonnegativeQuantity(value resource.Quantity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if value.Cmp(resource.Quantity{}) < 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value.String(), isNegativeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateImmutableField(newVal, oldVal interface{}, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		return genericvalidation.ValidateImmutableField(newVal, oldVal, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateImmutableAnnotation(newVal string, oldVal string, annotation string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldVal != newVal {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("annotations", annotation), newVal, fieldImmutableErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateObjectMeta validates an object's metadata on creation. It expects that name generation has already
0000000000000000000000000000000000000000;;	// been performed.
0000000000000000000000000000000000000000;;	// It doesn't return an error for rootscoped resources with namespace, because namespace should already be cleared before.
0000000000000000000000000000000000000000;;	// TODO: Remove calls to this method scattered in validations of specific resources, e.g., ValidatePodUpdate.
0000000000000000000000000000000000000000;;	func ValidateObjectMeta(meta *metav1.ObjectMeta, requiresNamespace bool, nameFn ValidateNameFunc, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := genericvalidation.ValidateObjectMeta(meta, requiresNamespace, apimachineryvalidation.ValidateNameFunc(nameFn), fldPath)
0000000000000000000000000000000000000000;;		// run additional checks for the finalizer name
0000000000000000000000000000000000000000;;		for i := range meta.Finalizers {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateKubeFinalizerName(string(meta.Finalizers[i]), fldPath.Child("finalizers").Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateObjectMetaUpdate validates an object's metadata when updated
0000000000000000000000000000000000000000;;	func ValidateObjectMetaUpdate(newMeta, oldMeta *metav1.ObjectMeta, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := genericvalidation.ValidateObjectMetaUpdate(newMeta, oldMeta, fldPath)
0000000000000000000000000000000000000000;;		// run additional checks for the finalizer name
0000000000000000000000000000000000000000;;		for i := range newMeta.Finalizers {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateKubeFinalizerName(string(newMeta.Finalizers[i]), fldPath.Child("finalizers").Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateNoNewFinalizers(newFinalizers []string, oldFinalizers []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		return genericvalidation.ValidateNoNewFinalizers(newFinalizers, oldFinalizers, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateVolumes(volumes []api.Volume, fldPath *field.Path) (sets.String, field.ErrorList) {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allNames := sets.String{}
0000000000000000000000000000000000000000;;		for i, vol := range volumes {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			namePath := idxPath.Child("name")
0000000000000000000000000000000000000000;;			el := validateVolumeSource(&vol.VolumeSource, idxPath)
0000000000000000000000000000000000000000;;			if len(vol.Name) == 0 {
0000000000000000000000000000000000000000;;				el = append(el, field.Required(namePath, ""))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				el = append(el, ValidateDNS1123Label(vol.Name, namePath)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if allNames.Has(vol.Name) {
0000000000000000000000000000000000000000;;				el = append(el, field.Duplicate(namePath, vol.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(el) == 0 {
0000000000000000000000000000000000000000;;				allNames.Insert(vol.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, el...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allNames, allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateVolumeSource(source *api.VolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		numVolumes := 0
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if source.EmptyDir != nil {
0000000000000000000000000000000000000000;;			numVolumes++
0000000000000000000000000000000000000000;;			if !utilfeature.DefaultFeatureGate.Enabled(features.LocalStorageCapacityIsolation) {
0000000000000000000000000000000000000000;;				unsetSizeLimit := resource.Quantity{}
0000000000000000000000000000000000000000;;				if unsetSizeLimit.Cmp(source.EmptyDir.SizeLimit) != 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Forbidden(fldPath.Child("emptyDir").Child("sizeLimit"), "SizeLimit field disabled by feature-gate for EmptyDir volumes"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.HostPath != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("hostPath"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateHostPathVolumeSource(source.HostPath, fldPath.Child("hostPath"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.GitRepo != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("gitRepo"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateGitRepoVolumeSource(source.GitRepo, fldPath.Child("gitRepo"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.GCEPersistentDisk != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("gcePersistentDisk"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateGCEPersistentDiskVolumeSource(source.GCEPersistentDisk, fldPath.Child("persistentDisk"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.AWSElasticBlockStore != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("awsElasticBlockStore"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateAWSElasticBlockStoreVolumeSource(source.AWSElasticBlockStore, fldPath.Child("awsElasticBlockStore"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.Secret != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("secret"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateSecretVolumeSource(source.Secret, fldPath.Child("secret"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.NFS != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("nfs"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateNFSVolumeSource(source.NFS, fldPath.Child("nfs"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.ISCSI != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("iscsi"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateISCSIVolumeSource(source.ISCSI, fldPath.Child("iscsi"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.Glusterfs != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("glusterfs"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateGlusterfs(source.Glusterfs, fldPath.Child("glusterfs"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.Flocker != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("flocker"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateFlockerVolumeSource(source.Flocker, fldPath.Child("flocker"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.PersistentVolumeClaim != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("persistentVolumeClaim"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePersistentClaimVolumeSource(source.PersistentVolumeClaim, fldPath.Child("persistentVolumeClaim"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.RBD != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("rbd"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateRBDVolumeSource(source.RBD, fldPath.Child("rbd"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.Cinder != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("cinder"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateCinderVolumeSource(source.Cinder, fldPath.Child("cinder"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.CephFS != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("cephFS"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateCephFSVolumeSource(source.CephFS, fldPath.Child("cephfs"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.Quobyte != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("quobyte"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateQuobyteVolumeSource(source.Quobyte, fldPath.Child("quobyte"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.DownwardAPI != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("downwarAPI"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateDownwardAPIVolumeSource(source.DownwardAPI, fldPath.Child("downwardAPI"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.FC != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("fc"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateFCVolumeSource(source.FC, fldPath.Child("fc"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.FlexVolume != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("flexVolume"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateFlexVolumeSource(source.FlexVolume, fldPath.Child("flexVolume"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.ConfigMap != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("configMap"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateConfigMapVolumeSource(source.ConfigMap, fldPath.Child("configMap"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if source.AzureFile != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("azureFile"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateAzureFile(source.AzureFile, fldPath.Child("azureFile"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if source.VsphereVolume != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("vsphereVolume"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateVsphereVolumeSource(source.VsphereVolume, fldPath.Child("vsphereVolume"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.PhotonPersistentDisk != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("photonPersistentDisk"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePhotonPersistentDiskVolumeSource(source.PhotonPersistentDisk, fldPath.Child("photonPersistentDisk"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.PortworxVolume != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("portworxVolume"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePortworxVolumeSource(source.PortworxVolume, fldPath.Child("portworxVolume"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.AzureDisk != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("azureDisk"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateAzureDisk(source.AzureDisk, fldPath.Child("azureDisk"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.StorageOS != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("storageos"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateStorageOSVolumeSource(source.StorageOS, fldPath.Child("storageos"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.Projected != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("projected"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateProjectedVolumeSource(source.Projected, fldPath.Child("projected"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if source.ScaleIO != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("scaleIO"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateScaleIOVolumeSource(source.ScaleIO, fldPath.Child("scaleIO"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numVolumes == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, "must specify a volume type"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateHostPathVolumeSource(hostPath *api.HostPathVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(hostPath.Path) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("path"), ""))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validatePathNoBacksteps(hostPath.Path, fldPath.Child("path"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateGitRepoVolumeSource(gitRepo *api.GitRepoVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(gitRepo.Repository) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("repository"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pathErrs := validateLocalDescendingPath(gitRepo.Directory, fldPath.Child("directory"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, pathErrs...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateISCSIVolumeSource(iscsi *api.ISCSIVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(iscsi.TargetPortal) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("targetPortal"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(iscsi.IQN) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("iqn"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if iscsi.Lun < 0 || iscsi.Lun > 255 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("lun"), iscsi.Lun, validation.InclusiveRangeError(0, 255)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (iscsi.DiscoveryCHAPAuth || iscsi.SessionCHAPAuth) && iscsi.SecretRef == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("secretRef"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateFCVolumeSource(fc *api.FCVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(fc.TargetWWNs) < 1 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("targetWWNs"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fc.Lun == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("lun"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if *fc.Lun < 0 || *fc.Lun > 255 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("lun"), fc.Lun, validation.InclusiveRangeError(0, 255)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateGCEPersistentDiskVolumeSource(pd *api.GCEPersistentDiskVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(pd.PDName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("pdName"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pd.Partition < 0 || pd.Partition > 255 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("partition"), pd.Partition, pdPartitionErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateAWSElasticBlockStoreVolumeSource(PD *api.AWSElasticBlockStoreVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(PD.VolumeID) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volumeID"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if PD.Partition < 0 || PD.Partition > 255 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("partition"), PD.Partition, pdPartitionErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateSecretVolumeSource(secretSource *api.SecretVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(secretSource.SecretName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("secretName"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretMode := secretSource.DefaultMode
0000000000000000000000000000000000000000;;		if secretMode != nil && (*secretMode > 0777 || *secretMode < 0) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("defaultMode"), *secretMode, volumeModeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemsPath := fldPath.Child("items")
0000000000000000000000000000000000000000;;		for i, kp := range secretSource.Items {
0000000000000000000000000000000000000000;;			itemPath := itemsPath.Index(i)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateKeyToPath(&kp, itemPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateConfigMapVolumeSource(configMapSource *api.ConfigMapVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(configMapSource.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configMapMode := configMapSource.DefaultMode
0000000000000000000000000000000000000000;;		if configMapMode != nil && (*configMapMode > 0777 || *configMapMode < 0) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("defaultMode"), *configMapMode, volumeModeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemsPath := fldPath.Child("items")
0000000000000000000000000000000000000000;;		for i, kp := range configMapSource.Items {
0000000000000000000000000000000000000000;;			itemPath := itemsPath.Index(i)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateKeyToPath(&kp, itemPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateKeyToPath(kp *api.KeyToPath, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(kp.Key) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("key"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kp.Path) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("path"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateLocalNonReservedPath(kp.Path, fldPath.Child("path"))...)
0000000000000000000000000000000000000000;;		if kp.Mode != nil && (*kp.Mode > 0777 || *kp.Mode < 0) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("mode"), *kp.Mode, volumeModeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePersistentClaimVolumeSource(claim *api.PersistentVolumeClaimVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(claim.ClaimName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("claimName"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateNFSVolumeSource(nfs *api.NFSVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(nfs.Server) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("server"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(nfs.Path) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("path"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !path.IsAbs(nfs.Path) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("path"), nfs.Path, "must be an absolute path"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateQuobyteVolumeSource(quobyte *api.QuobyteVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(quobyte.Registry) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("registry"), "must be a host:port pair or multiple pairs separated by commas"))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, hostPortPair := range strings.Split(quobyte.Registry, ",") {
0000000000000000000000000000000000000000;;				if _, _, err := net.SplitHostPort(hostPortPair); err != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("registry"), quobyte.Registry, "must be a host:port pair or multiple pairs separated by commas"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(quobyte.Volume) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volume"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateGlusterfs(glusterfs *api.GlusterfsVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(glusterfs.EndpointsName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("endpoints"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(glusterfs.Path) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("path"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateFlockerVolumeSource(flocker *api.FlockerVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(flocker.DatasetName) == 0 && len(flocker.DatasetUUID) == 0 {
0000000000000000000000000000000000000000;;			//TODO: consider adding a RequiredOneOf() error for this and similar cases
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, "one of datasetName and datasetUUID is required"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(flocker.DatasetName) != 0 && len(flocker.DatasetUUID) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, "resource", "datasetName and datasetUUID can not be specified simultaneously"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(flocker.DatasetName, "/") {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("datasetName"), flocker.DatasetName, "must not contain '/'"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var validDownwardAPIFieldPathExpressions = sets.NewString(
0000000000000000000000000000000000000000;;		"metadata.name",
0000000000000000000000000000000000000000;;		"metadata.namespace",
0000000000000000000000000000000000000000;;		"metadata.labels",
0000000000000000000000000000000000000000;;		"metadata.annotations",
0000000000000000000000000000000000000000;;		"metadata.uid")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateDownwardAPIVolumeFile(file *api.DownwardAPIVolumeFile, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(file.Path) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("path"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateLocalNonReservedPath(file.Path, fldPath.Child("path"))...)
0000000000000000000000000000000000000000;;		if file.FieldRef != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateObjectFieldSelector(file.FieldRef, &validDownwardAPIFieldPathExpressions, fldPath.Child("fieldRef"))...)
0000000000000000000000000000000000000000;;			if file.ResourceFieldRef != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, "resource", "fieldRef and resourceFieldRef can not be specified simultaneously"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if file.ResourceFieldRef != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainerResourceFieldSelector(file.ResourceFieldRef, &validContainerResourceFieldPathExpressions, fldPath.Child("resourceFieldRef"), true)...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, "one of fieldRef and resourceFieldRef is required"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if file.Mode != nil && (*file.Mode > 0777 || *file.Mode < 0) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("mode"), *file.Mode, volumeModeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateDownwardAPIVolumeSource(downwardAPIVolume *api.DownwardAPIVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		downwardAPIMode := downwardAPIVolume.DefaultMode
0000000000000000000000000000000000000000;;		if downwardAPIMode != nil && (*downwardAPIMode > 0777 || *downwardAPIMode < 0) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("defaultMode"), *downwardAPIMode, volumeModeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, file := range downwardAPIVolume.Items {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateDownwardAPIVolumeFile(&file, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateProjectionSources(projection *api.ProjectedVolumeSource, projectionMode *int32, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allPaths := sets.String{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, source := range projection.Sources {
0000000000000000000000000000000000000000;;			numSources := 0
0000000000000000000000000000000000000000;;			if source.Secret != nil {
0000000000000000000000000000000000000000;;				if numSources > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Forbidden(fldPath.Child("secret"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					numSources++
0000000000000000000000000000000000000000;;					if len(source.Secret.Name) == 0 {
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					itemsPath := fldPath.Child("items")
0000000000000000000000000000000000000000;;					for i, kp := range source.Secret.Items {
0000000000000000000000000000000000000000;;						itemPath := itemsPath.Index(i)
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, validateKeyToPath(&kp, itemPath)...)
0000000000000000000000000000000000000000;;						if len(kp.Path) > 0 {
0000000000000000000000000000000000000000;;							curPath := kp.Path
0000000000000000000000000000000000000000;;							if !allPaths.Has(curPath) {
0000000000000000000000000000000000000000;;								allPaths.Insert(curPath)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								allErrs = append(allErrs, field.Invalid(fldPath, source.Secret.Name, "conflicting duplicate paths"))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if source.ConfigMap != nil {
0000000000000000000000000000000000000000;;				if numSources > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Forbidden(fldPath.Child("configMap"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					numSources++
0000000000000000000000000000000000000000;;					if len(source.ConfigMap.Name) == 0 {
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					itemsPath := fldPath.Child("items")
0000000000000000000000000000000000000000;;					for i, kp := range source.ConfigMap.Items {
0000000000000000000000000000000000000000;;						itemPath := itemsPath.Index(i)
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, validateKeyToPath(&kp, itemPath)...)
0000000000000000000000000000000000000000;;						if len(kp.Path) > 0 {
0000000000000000000000000000000000000000;;							curPath := kp.Path
0000000000000000000000000000000000000000;;							if !allPaths.Has(curPath) {
0000000000000000000000000000000000000000;;								allPaths.Insert(curPath)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								allErrs = append(allErrs, field.Invalid(fldPath, source.ConfigMap.Name, "conflicting duplicate paths"))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if source.DownwardAPI != nil {
0000000000000000000000000000000000000000;;				if numSources > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Forbidden(fldPath.Child("downwardAPI"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					numSources++
0000000000000000000000000000000000000000;;					for _, file := range source.DownwardAPI.Items {
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, validateDownwardAPIVolumeFile(&file, fldPath.Child("downwardAPI"))...)
0000000000000000000000000000000000000000;;						if len(file.Path) > 0 {
0000000000000000000000000000000000000000;;							curPath := file.Path
0000000000000000000000000000000000000000;;							if !allPaths.Has(curPath) {
0000000000000000000000000000000000000000;;								allPaths.Insert(curPath)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								allErrs = append(allErrs, field.Invalid(fldPath, curPath, "conflicting duplicate paths"))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateProjectedVolumeSource(projection *api.ProjectedVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		projectionMode := projection.DefaultMode
0000000000000000000000000000000000000000;;		if projectionMode != nil && (*projectionMode > 0777 || *projectionMode < 0) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("defaultMode"), *projectionMode, volumeModeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateProjectionSources(projection, projectionMode, fldPath)...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This validate will make sure targetPath:
0000000000000000000000000000000000000000;;	// 1. is not abs path
0000000000000000000000000000000000000000;;	// 2. does not have any element which is ".."
0000000000000000000000000000000000000000;;	func validateLocalDescendingPath(targetPath string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if path.IsAbs(targetPath) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, targetPath, "must be a relative path"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validatePathNoBacksteps(targetPath, fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePathNoBacksteps makes sure the targetPath does not have any `..` path elements when split
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This assumes the OS of the apiserver and the nodes are the same. The same check should be done
0000000000000000000000000000000000000000;;	// on the node to ensure there are no backsteps.
0000000000000000000000000000000000000000;;	func validatePathNoBacksteps(targetPath string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		parts := strings.Split(filepath.ToSlash(targetPath), "/")
0000000000000000000000000000000000000000;;		for _, item := range parts {
0000000000000000000000000000000000000000;;			if item == ".." {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, targetPath, "must not contain '..'"))
0000000000000000000000000000000000000000;;				break // even for `../../..`, one error is sufficient to make the point
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This validate will make sure targetPath:
0000000000000000000000000000000000000000;;	// 1. is not abs path
0000000000000000000000000000000000000000;;	// 2. does not contain any '..' elements
0000000000000000000000000000000000000000;;	// 3. does not start with '..'
0000000000000000000000000000000000000000;;	func validateLocalNonReservedPath(targetPath string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateLocalDescendingPath(targetPath, fldPath)...)
0000000000000000000000000000000000000000;;		// Don't report this error if the check for .. elements already caught it.
0000000000000000000000000000000000000000;;		if strings.HasPrefix(targetPath, "..") && !strings.HasPrefix(targetPath, "../") {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, targetPath, "must not start with '..'"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateRBDVolumeSource(rbd *api.RBDVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(rbd.CephMonitors) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("monitors"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rbd.RBDImage) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("image"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateCinderVolumeSource(cd *api.CinderVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(cd.VolumeID) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volumeID"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateCephFSVolumeSource(cephfs *api.CephFSVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(cephfs.Monitors) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("monitors"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateFlexVolumeSource(fv *api.FlexVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(fv.Driver) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("driver"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure user-specified options don't use kubernetes namespaces
0000000000000000000000000000000000000000;;		for k := range fv.Options {
0000000000000000000000000000000000000000;;			namespace := k
0000000000000000000000000000000000000000;;			if parts := strings.SplitN(k, "/", 2); len(parts) == 2 {
0000000000000000000000000000000000000000;;				namespace = parts[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			normalized := "." + strings.ToLower(namespace)
0000000000000000000000000000000000000000;;			if strings.HasSuffix(normalized, ".kubernetes.io") || strings.HasSuffix(normalized, ".k8s.io") {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("options").Key(k), k, "kubernetes.io and k8s.io namespaces are reserved"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateAzureFile(azure *api.AzureFileVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if azure.SecretName == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("secretName"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azure.ShareName == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("shareName"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateAzureDisk(azure *api.AzureDiskVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var supportedCachingModes = sets.NewString(string(api.AzureDataDiskCachingNone), string(api.AzureDataDiskCachingReadOnly), string(api.AzureDataDiskCachingReadWrite))
0000000000000000000000000000000000000000;;		var supportedDiskKinds = sets.NewString(string(api.AzureSharedBlobDisk), string(api.AzureDedicatedBlobDisk), string(api.AzureManagedDisk))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskUriSupportedManaged := []string{"/subscriptions/{sub-id}/resourcegroups/{group-name}/providers/microsoft.compute/disks/{disk-id}"}
0000000000000000000000000000000000000000;;		diskUriSupportedblob := []string{"https://{account-name}.blob.core.windows.net/{container-name}/{disk-name}.vhd"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if azure.DiskName == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("diskName"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if azure.DataDiskURI == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("diskURI"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if azure.CachingMode != nil && !supportedCachingModes.Has(string(*azure.CachingMode)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("cachingMode"), *azure.CachingMode, supportedCachingModes.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if azure.Kind != nil && !supportedDiskKinds.Has(string(*azure.Kind)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("kind"), *azure.Kind, supportedDiskKinds.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate that DiskUri is the correct format
0000000000000000000000000000000000000000;;		if azure.Kind != nil && *azure.Kind == api.AzureManagedDisk && strings.Index(azure.DataDiskURI, "/subscriptions/") != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("diskURI"), azure.DataDiskURI, diskUriSupportedManaged))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if azure.Kind != nil && *azure.Kind != api.AzureManagedDisk && strings.Index(azure.DataDiskURI, "https://") != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("diskURI"), azure.DataDiskURI, diskUriSupportedblob))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateVsphereVolumeSource(cd *api.VsphereVirtualDiskVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(cd.VolumePath) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volumePath"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePhotonPersistentDiskVolumeSource(cd *api.PhotonPersistentDiskVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(cd.PdID) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("pdID"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePortworxVolumeSource(pwx *api.PortworxVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(pwx.VolumeID) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volumeID"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateScaleIOVolumeSource(sio *api.ScaleIOVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if sio.Gateway == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("gateway"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sio.System == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("system"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sio.VolumeName == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volumeName"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateLocalVolumeSource(ls *api.LocalVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if ls.Path == "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("path"), ""))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validatePathNoBacksteps(ls.Path, fldPath.Child("path"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateStorageOSVolumeSource(storageos *api.StorageOSVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(storageos.VolumeName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volumeName"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(storageos.VolumeName, fldPath.Child("volumeName"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(storageos.VolumeNamespace) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(storageos.VolumeNamespace, fldPath.Child("volumeNamespace"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if storageos.SecretRef != nil {
0000000000000000000000000000000000000000;;			if len(storageos.SecretRef.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("secretRef", "name"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateStorageOSPersistentVolumeSource(storageos *api.StorageOSPersistentVolumeSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(storageos.VolumeName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("volumeName"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(storageos.VolumeName, fldPath.Child("volumeName"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(storageos.VolumeNamespace) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(storageos.VolumeNamespace, fldPath.Child("volumeNamespace"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if storageos.SecretRef != nil {
0000000000000000000000000000000000000000;;			if len(storageos.SecretRef.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("secretRef", "name"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(storageos.SecretRef.Namespace) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("secretRef", "namespace"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePersistentVolumeName checks that a name is appropriate for a
0000000000000000000000000000000000000000;;	// PersistentVolumeName object.
0000000000000000000000000000000000000000;;	var ValidatePersistentVolumeName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedAccessModes = sets.NewString(string(api.ReadWriteOnce), string(api.ReadOnlyMany), string(api.ReadWriteMany))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedReclaimPolicy = sets.NewString(string(api.PersistentVolumeReclaimDelete), string(api.PersistentVolumeReclaimRecycle), string(api.PersistentVolumeReclaimRetain))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidatePersistentVolume(pv *api.PersistentVolume) field.ErrorList {
0000000000000000000000000000000000000000;;		metaPath := field.NewPath("metadata")
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&pv.ObjectMeta, false, ValidatePersistentVolumeName, metaPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		specPath := field.NewPath("spec")
0000000000000000000000000000000000000000;;		if len(pv.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(specPath.Child("accessModes"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, mode := range pv.Spec.AccessModes {
0000000000000000000000000000000000000000;;			if !supportedAccessModes.Has(string(mode)) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(specPath.Child("accessModes"), mode, supportedAccessModes.List()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pv.Spec.Capacity) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(specPath.Child("capacity"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := pv.Spec.Capacity[api.ResourceStorage]; !ok || len(pv.Spec.Capacity) > 1 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(specPath.Child("capacity"), pv.Spec.Capacity, []string{string(api.ResourceStorage)}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		capPath := specPath.Child("capacity")
0000000000000000000000000000000000000000;;		for r, qty := range pv.Spec.Capacity {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateBasicResource(qty, capPath.Key(string(r)))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(string(pv.Spec.PersistentVolumeReclaimPolicy)) > 0 {
0000000000000000000000000000000000000000;;			if !supportedReclaimPolicy.Has(string(pv.Spec.PersistentVolumeReclaimPolicy)) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(specPath.Child("persistentVolumeReclaimPolicy"), pv.Spec.PersistentVolumeReclaimPolicy, supportedReclaimPolicy.List()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeAffinitySpecified, errs := validateStorageNodeAffinityAnnotation(pv.ObjectMeta.Annotations, metaPath.Child("annotations"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, errs...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numVolumes := 0
0000000000000000000000000000000000000000;;		if pv.Spec.HostPath != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("hostPath"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateHostPathVolumeSource(pv.Spec.HostPath, specPath.Child("hostPath"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.GCEPersistentDisk != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("gcePersistentDisk"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateGCEPersistentDiskVolumeSource(pv.Spec.GCEPersistentDisk, specPath.Child("persistentDisk"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.AWSElasticBlockStore != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("awsElasticBlockStore"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateAWSElasticBlockStoreVolumeSource(pv.Spec.AWSElasticBlockStore, specPath.Child("awsElasticBlockStore"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.Glusterfs != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("glusterfs"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateGlusterfs(pv.Spec.Glusterfs, specPath.Child("glusterfs"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.Flocker != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("flocker"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateFlockerVolumeSource(pv.Spec.Flocker, specPath.Child("flocker"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.NFS != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("nfs"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateNFSVolumeSource(pv.Spec.NFS, specPath.Child("nfs"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.RBD != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("rbd"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateRBDVolumeSource(pv.Spec.RBD, specPath.Child("rbd"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.Quobyte != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("quobyte"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateQuobyteVolumeSource(pv.Spec.Quobyte, specPath.Child("quobyte"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.CephFS != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("cephFS"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateCephFSVolumeSource(pv.Spec.CephFS, specPath.Child("cephfs"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ISCSI != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("iscsi"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateISCSIVolumeSource(pv.Spec.ISCSI, specPath.Child("iscsi"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.Cinder != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("cinder"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateCinderVolumeSource(pv.Spec.Cinder, specPath.Child("cinder"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.FC != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("fc"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateFCVolumeSource(pv.Spec.FC, specPath.Child("fc"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.FlexVolume != nil {
0000000000000000000000000000000000000000;;			numVolumes++
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateFlexVolumeSource(pv.Spec.FlexVolume, specPath.Child("flexVolume"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.AzureFile != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("azureFile"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateAzureFile(pv.Spec.AzureFile, specPath.Child("azureFile"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pv.Spec.VsphereVolume != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("vsphereVolume"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateVsphereVolumeSource(pv.Spec.VsphereVolume, specPath.Child("vsphereVolume"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.PhotonPersistentDisk != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("photonPersistentDisk"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePhotonPersistentDiskVolumeSource(pv.Spec.PhotonPersistentDisk, specPath.Child("photonPersistentDisk"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.PortworxVolume != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("portworxVolume"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePortworxVolumeSource(pv.Spec.PortworxVolume, specPath.Child("portworxVolume"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.AzureDisk != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("azureDisk"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateAzureDisk(pv.Spec.AzureDisk, specPath.Child("azureDisk"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.ScaleIO != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("scaleIO"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateScaleIOVolumeSource(pv.Spec.ScaleIO, specPath.Child("scaleIO"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.Local != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("local"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				if !utilfeature.DefaultFeatureGate.Enabled(features.PersistentLocalVolumes) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Forbidden(specPath.Child("local"), "Local volumes are disabled by feature-gate"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateLocalVolumeSource(pv.Spec.Local, specPath.Child("local"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// NodeAffinity is required
0000000000000000000000000000000000000000;;				if !nodeAffinitySpecified {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Required(metaPath.Child("annotations"), "Local volume requires node affinity"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.StorageOS != nil {
0000000000000000000000000000000000000000;;			if numVolumes > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(specPath.Child("storageos"), "may not specify more than 1 volume type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numVolumes++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateStorageOSPersistentVolumeSource(pv.Spec.StorageOS, specPath.Child("storageos"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numVolumes == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(specPath, "must specify a volume type"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do not allow hostPath mounts of '/' to have a 'recycle' reclaim policy
0000000000000000000000000000000000000000;;		if pv.Spec.HostPath != nil && path.Clean(pv.Spec.HostPath.Path) == "/" && pv.Spec.PersistentVolumeReclaimPolicy == api.PersistentVolumeReclaimRecycle {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(specPath.Child("persistentVolumeReclaimPolicy"), "may not be 'recycle' for a hostPath mount of '/'"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pv.Spec.StorageClassName) > 0 {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateClassName(pv.Spec.StorageClassName, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(specPath.Child("storageClassName"), pv.Spec.StorageClassName, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePersistentVolumeUpdate tests to see if the update is legal for an end user to make.
0000000000000000000000000000000000000000;;	// newPv is updated with fields that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidatePersistentVolumeUpdate(newPv, oldPv *api.PersistentVolume) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = ValidatePersistentVolume(newPv)
0000000000000000000000000000000000000000;;		newPv.Status = oldPv.Status
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePersistentVolumeStatusUpdate tests to see if the status update is legal for an end user to make.
0000000000000000000000000000000000000000;;	// newPv is updated with fields that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidatePersistentVolumeStatusUpdate(newPv, oldPv *api.PersistentVolume) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newPv.ObjectMeta, &oldPv.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		if len(newPv.ResourceVersion) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("resourceVersion"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPv.Spec = oldPv.Spec
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePersistentVolumeClaim validates a PersistentVolumeClaim
0000000000000000000000000000000000000000;;	func ValidatePersistentVolumeClaim(pvc *api.PersistentVolumeClaim) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&pvc.ObjectMeta, true, ValidatePersistentVolumeName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePersistentVolumeClaimSpec(&pvc.Spec, field.NewPath("spec"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePersistentVolumeClaimSpec validates a PersistentVolumeClaimSpec
0000000000000000000000000000000000000000;;	func ValidatePersistentVolumeClaimSpec(spec *api.PersistentVolumeClaimSpec, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("accessModes"), "at least 1 access mode is required"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if spec.Selector != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, unversionedvalidation.ValidateLabelSelector(spec.Selector, fldPath.Child("selector"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, mode := range spec.AccessModes {
0000000000000000000000000000000000000000;;			if mode != api.ReadWriteOnce && mode != api.ReadOnlyMany && mode != api.ReadWriteMany {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(fldPath.Child("accessModes"), mode, supportedAccessModes.List()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storageValue, ok := spec.Resources.Requests[api.ResourceStorage]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("resources").Key(string(api.ResourceStorage)), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(api.ResourceStorage), storageValue, fldPath.Child("resources").Key(string(api.ResourceStorage)))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.StorageClassName != nil && len(*spec.StorageClassName) > 0 {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateClassName(*spec.StorageClassName, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("storageClassName"), *spec.StorageClassName, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePersistentVolumeClaimUpdate validates an update to a PersistentVolumeClaim
0000000000000000000000000000000000000000;;	func ValidatePersistentVolumeClaimUpdate(newPvc, oldPvc *api.PersistentVolumeClaim) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newPvc.ObjectMeta, &oldPvc.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePersistentVolumeClaim(newPvc)...)
0000000000000000000000000000000000000000;;		// PVController needs to update PVC.Spec w/ VolumeName.
0000000000000000000000000000000000000000;;		// Claims are immutable in order to enforce quota, range limits, etc. without gaming the system.
0000000000000000000000000000000000000000;;		if len(oldPvc.Spec.VolumeName) == 0 {
0000000000000000000000000000000000000000;;			// volumeName changes are allowed once.
0000000000000000000000000000000000000000;;			// Reset back to empty string after equality check
0000000000000000000000000000000000000000;;			oldPvc.Spec.VolumeName = newPvc.Spec.VolumeName
0000000000000000000000000000000000000000;;			defer func() { oldPvc.Spec.VolumeName = "" }()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// changes to Spec are not allowed, but updates to label/and some annotations are OK.
0000000000000000000000000000000000000000;;		// no-op updates pass validation.
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(newPvc.Spec, oldPvc.Spec) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath("spec"), "field is immutable after creation"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// storageclass annotation should be immutable after creation
0000000000000000000000000000000000000000;;		// TODO: remove Beta when no longer needed
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateImmutableAnnotation(newPvc.ObjectMeta.Annotations[v1.BetaStorageClassAnnotation], oldPvc.ObjectMeta.Annotations[v1.BetaStorageClassAnnotation], v1.BetaStorageClassAnnotation, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newPvc.Status = oldPvc.Status
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePersistentVolumeClaimStatusUpdate validates an update to status of a PersistentVolumeClaim
0000000000000000000000000000000000000000;;	func ValidatePersistentVolumeClaimStatusUpdate(newPvc, oldPvc *api.PersistentVolumeClaim) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newPvc.ObjectMeta, &oldPvc.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		if len(newPvc.ResourceVersion) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("resourceVersion"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(newPvc.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("Spec", "accessModes"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		capPath := field.NewPath("status", "capacity")
0000000000000000000000000000000000000000;;		for r, qty := range newPvc.Status.Capacity {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateBasicResource(qty, capPath.Key(string(r)))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPvc.Spec = oldPvc.Spec
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedPortProtocols = sets.NewString(string(api.ProtocolTCP), string(api.ProtocolUDP))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateContainerPorts(ports []api.ContainerPort, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allNames := sets.String{}
0000000000000000000000000000000000000000;;		for i, port := range ports {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			if len(port.Name) > 0 {
0000000000000000000000000000000000000000;;				if msgs := validation.IsValidPortName(port.Name); len(msgs) != 0 {
0000000000000000000000000000000000000000;;					for i = range msgs {
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, field.Invalid(idxPath.Child("name"), port.Name, msgs[i]))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if allNames.Has(port.Name) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Duplicate(idxPath.Child("name"), port.Name))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					allNames.Insert(port.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if port.ContainerPort == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath.Child("containerPort"), ""))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsValidPortNum(int(port.ContainerPort)) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("containerPort"), port.ContainerPort, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if port.HostPort != 0 {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsValidPortNum(int(port.HostPort)) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("hostPort"), port.HostPort, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(port.Protocol) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath.Child("protocol"), ""))
0000000000000000000000000000000000000000;;			} else if !supportedPortProtocols.Has(string(port.Protocol)) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(idxPath.Child("protocol"), port.Protocol, supportedPortProtocols.List()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateEnv validates env vars
0000000000000000000000000000000000000000;;	func ValidateEnv(vars []api.EnvVar, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, ev := range vars {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			if len(ev.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath.Child("name"), ""))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsCIdentifier(ev.Name) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("name"), ev.Name, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateEnvVarValueFrom(ev, idxPath.Child("valueFrom"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var validFieldPathExpressionsEnv = sets.NewString("metadata.name", "metadata.namespace", "metadata.uid", "spec.nodeName", "spec.serviceAccountName", "status.hostIP", "status.podIP")
0000000000000000000000000000000000000000;;	var validContainerResourceFieldPathExpressions = sets.NewString("limits.cpu", "limits.memory", "requests.cpu", "requests.memory")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEnvVarValueFrom(ev api.EnvVar, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ev.ValueFrom == nil {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numSources := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ev.ValueFrom.FieldRef != nil {
0000000000000000000000000000000000000000;;			numSources++
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateObjectFieldSelector(ev.ValueFrom.FieldRef, &validFieldPathExpressionsEnv, fldPath.Child("fieldRef"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ev.ValueFrom.ResourceFieldRef != nil {
0000000000000000000000000000000000000000;;			numSources++
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainerResourceFieldSelector(ev.ValueFrom.ResourceFieldRef, &validContainerResourceFieldPathExpressions, fldPath.Child("resourceFieldRef"), false)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ev.ValueFrom.ConfigMapKeyRef != nil {
0000000000000000000000000000000000000000;;			numSources++
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateConfigMapKeySelector(ev.ValueFrom.ConfigMapKeyRef, fldPath.Child("configMapKeyRef"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ev.ValueFrom.SecretKeyRef != nil {
0000000000000000000000000000000000000000;;			numSources++
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateSecretKeySelector(ev.ValueFrom.SecretKeyRef, fldPath.Child("secretKeyRef"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numSources == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, "", "must specify one of: `fieldRef`, `resourceFieldRef`, `configMapKeyRef` or `secretKeyRef`"))
0000000000000000000000000000000000000000;;		} else if len(ev.Value) != 0 {
0000000000000000000000000000000000000000;;			if numSources != 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, "", "may not be specified when `value` is not empty"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if numSources > 1 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, "", "may not have more than one field specified at a time"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateObjectFieldSelector(fs *api.ObjectFieldSelector, expressions *sets.String, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fs.APIVersion) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("apiVersion"), ""))
0000000000000000000000000000000000000000;;		} else if len(fs.FieldPath) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("fieldPath"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			internalFieldPath, _, err := api.Scheme.ConvertFieldLabel(fs.APIVersion, "Pod", fs.FieldPath, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("fieldPath"), fs.FieldPath, fmt.Sprintf("error converting fieldPath: %v", err)))
0000000000000000000000000000000000000000;;			} else if !expressions.Has(internalFieldPath) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(fldPath.Child("fieldPath"), internalFieldPath, expressions.List()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateContainerResourceFieldSelector(fs *api.ResourceFieldSelector, expressions *sets.String, fldPath *field.Path, volume bool) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volume && len(fs.ContainerName) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("containerName"), ""))
0000000000000000000000000000000000000000;;		} else if len(fs.Resource) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("resource"), ""))
0000000000000000000000000000000000000000;;		} else if !expressions.Has(fs.Resource) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("resource"), fs.Resource, expressions.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateContainerResourceDivisor(fs.Resource, fs.Divisor, fldPath)...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateEnvFrom(vars []api.EnvFromSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i, ev := range vars {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			if len(ev.Prefix) > 0 {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsCIdentifier(ev.Prefix) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("prefix"), ev.Prefix, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			numSources := 0
0000000000000000000000000000000000000000;;			if ev.ConfigMapRef != nil {
0000000000000000000000000000000000000000;;				numSources++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateConfigMapEnvSource(ev.ConfigMapRef, idxPath.Child("configMapRef"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ev.SecretRef != nil {
0000000000000000000000000000000000000000;;				numSources++
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateSecretEnvSource(ev.SecretRef, idxPath.Child("secretRef"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if numSources == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, "", "must specify one of: `configMapRef` or `secretRef`"))
0000000000000000000000000000000000000000;;			} else if numSources > 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, "", "may not have more than one field specified at a time"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateConfigMapEnvSource(configMapSource *api.ConfigMapEnvSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(configMapSource.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateConfigMapName(configMapSource.Name, true) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), configMapSource.Name, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateSecretEnvSource(secretSource *api.SecretEnvSource, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(secretSource.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateSecretName(secretSource.Name, true) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), secretSource.Name, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var validContainerResourceDivisorForCPU = sets.NewString("1m", "1")
0000000000000000000000000000000000000000;;	var validContainerResourceDivisorForMemory = sets.NewString("1", "1k", "1M", "1G", "1T", "1P", "1E", "1Ki", "1Mi", "1Gi", "1Ti", "1Pi", "1Ei")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateContainerResourceDivisor(rName string, divisor resource.Quantity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		unsetDivisor := resource.Quantity{}
0000000000000000000000000000000000000000;;		if unsetDivisor.Cmp(divisor) == 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch rName {
0000000000000000000000000000000000000000;;		case "limits.cpu", "requests.cpu":
0000000000000000000000000000000000000000;;			if !validContainerResourceDivisorForCPU.Has(divisor.String()) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("divisor"), rName, "only divisor's values 1m and 1 are supported with the cpu resource"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "limits.memory", "requests.memory":
0000000000000000000000000000000000000000;;			if !validContainerResourceDivisorForMemory.Has(divisor.String()) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("divisor"), rName, "only divisor's values 1, 1k, 1M, 1G, 1T, 1P, 1E, 1Ki, 1Mi, 1Gi, 1Ti, 1Pi, 1Ei are supported with the memory resource"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateConfigMapKeySelector(s *api.ConfigMapKeySelector, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameFn := ValidateNameFunc(ValidateSecretName)
0000000000000000000000000000000000000000;;		for _, msg := range nameFn(s.Name, false) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), s.Name, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.Key) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("key"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsConfigMapKey(s.Key) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("key"), s.Key, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateSecretKeySelector(s *api.SecretKeySelector, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameFn := ValidateNameFunc(ValidateSecretName)
0000000000000000000000000000000000000000;;		for _, msg := range nameFn(s.Name, false) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), s.Name, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.Key) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("key"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsConfigMapKey(s.Key) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("key"), s.Key, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateVolumeMounts(mounts []api.VolumeMount, volumes sets.String, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		mountpoints := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, mnt := range mounts {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			if len(mnt.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath.Child("name"), ""))
0000000000000000000000000000000000000000;;			} else if !volumes.Has(mnt.Name) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotFound(idxPath.Child("name"), mnt.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(mnt.MountPath) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath.Child("mountPath"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mountpoints.Has(mnt.MountPath) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("mountPath"), mnt.MountPath, "must be unique"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !path.IsAbs(mnt.MountPath) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("mountPath"), mnt.MountPath, "must be an absolute path"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mountpoints.Insert(mnt.MountPath)
0000000000000000000000000000000000000000;;			if len(mnt.SubPath) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateLocalDescendingPath(mnt.SubPath, fldPath.Child("subPath"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateProbe(probe *api.Probe, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if probe == nil {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateHandler(&probe.Handler, fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(probe.InitialDelaySeconds), fldPath.Child("initialDelaySeconds"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(probe.TimeoutSeconds), fldPath.Child("timeoutSeconds"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(probe.PeriodSeconds), fldPath.Child("periodSeconds"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(probe.SuccessThreshold), fldPath.Child("successThreshold"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(probe.FailureThreshold), fldPath.Child("failureThreshold"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AccumulateUniqueHostPorts extracts each HostPort of each Container,
0000000000000000000000000000000000000000;;	// accumulating the results and returning an error if any ports conflict.
0000000000000000000000000000000000000000;;	func AccumulateUniqueHostPorts(containers []api.Container, accumulator *sets.String, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ci, ctr := range containers {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(ci)
0000000000000000000000000000000000000000;;			portsPath := idxPath.Child("ports")
0000000000000000000000000000000000000000;;			for pi := range ctr.Ports {
0000000000000000000000000000000000000000;;				idxPath := portsPath.Index(pi)
0000000000000000000000000000000000000000;;				port := ctr.Ports[pi].HostPort
0000000000000000000000000000000000000000;;				if port == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				str := fmt.Sprintf("%s/%s/%d", ctr.Ports[pi].Protocol, ctr.Ports[pi].HostIP, port)
0000000000000000000000000000000000000000;;				if accumulator.Has(str) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Duplicate(idxPath.Child("hostPort"), str))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					accumulator.Insert(str)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkHostPortConflicts checks for colliding Port.HostPort values across
0000000000000000000000000000000000000000;;	// a slice of containers.
0000000000000000000000000000000000000000;;	func checkHostPortConflicts(containers []api.Container, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allPorts := sets.String{}
0000000000000000000000000000000000000000;;		return AccumulateUniqueHostPorts(containers, &allPorts, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateExecAction(exec *api.ExecAction, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(exec.Command) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("command"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedHTTPSchemes = sets.NewString(string(api.URISchemeHTTP), string(api.URISchemeHTTPS))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateHTTPGetAction(http *api.HTTPGetAction, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(http.Path) == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("path"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrors = append(allErrors, ValidatePortNumOrName(http.Port, fldPath.Child("port"))...)
0000000000000000000000000000000000000000;;		if !supportedHTTPSchemes.Has(string(http.Scheme)) {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.NotSupported(fldPath.Child("scheme"), http.Scheme, supportedHTTPSchemes.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, header := range http.HTTPHeaders {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsHTTPHeaderName(header.Name) {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(fldPath.Child("httpHeaders"), header.Name, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidatePortNumOrName(port intstr.IntOrString, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if port.Type == intstr.Int {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsValidPortNum(port.IntValue()) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, port.IntValue(), msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if port.Type == intstr.String {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsValidPortName(port.StrVal) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, port.StrVal, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.InternalError(fldPath, fmt.Errorf("unknown type: %v", port.Type)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateTCPSocketAction(tcp *api.TCPSocketAction, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		return ValidatePortNumOrName(tcp.Port, fldPath.Child("port"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateHandler(handler *api.Handler, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		numHandlers := 0
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		if handler.Exec != nil {
0000000000000000000000000000000000000000;;			if numHandlers > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Forbidden(fldPath.Child("exec"), "may not specify more than 1 handler type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numHandlers++
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, validateExecAction(handler.Exec, fldPath.Child("exec"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if handler.HTTPGet != nil {
0000000000000000000000000000000000000000;;			if numHandlers > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Forbidden(fldPath.Child("httpGet"), "may not specify more than 1 handler type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numHandlers++
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, validateHTTPGetAction(handler.HTTPGet, fldPath.Child("httpGet"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if handler.TCPSocket != nil {
0000000000000000000000000000000000000000;;			if numHandlers > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Forbidden(fldPath.Child("tcpSocket"), "may not specify more than 1 handler type"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numHandlers++
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, validateTCPSocketAction(handler.TCPSocket, fldPath.Child("tcpSocket"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if numHandlers == 0 {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath, "must specify a handler type"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateLifecycle(lifecycle *api.Lifecycle, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if lifecycle.PostStart != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateHandler(lifecycle.PostStart, fldPath.Child("postStart"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lifecycle.PreStop != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateHandler(lifecycle.PreStop, fldPath.Child("preStop"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedPullPolicies = sets.NewString(string(api.PullAlways), string(api.PullIfNotPresent), string(api.PullNever))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePullPolicy(policy api.PullPolicy, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch policy {
0000000000000000000000000000000000000000;;		case api.PullAlways, api.PullIfNotPresent, api.PullNever:
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.NotSupported(fldPath, policy, supportedPullPolicies.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateInitContainers(containers, otherContainers []api.Container, volumes sets.String, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		if len(containers) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainers(containers, volumes, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allNames := sets.String{}
0000000000000000000000000000000000000000;;		for _, ctr := range otherContainers {
0000000000000000000000000000000000000000;;			allNames.Insert(ctr.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, ctr := range containers {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			if allNames.Has(ctr.Name) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Duplicate(idxPath.Child("name"), ctr.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ctr.Name) > 0 {
0000000000000000000000000000000000000000;;				allNames.Insert(ctr.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctr.Lifecycle != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("lifecycle"), ctr.Lifecycle, "must not be set for init containers"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctr.LivenessProbe != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("livenessProbe"), ctr.LivenessProbe, "must not be set for init containers"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctr.ReadinessProbe != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("readinessProbe"), ctr.ReadinessProbe, "must not be set for init containers"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateContainers(containers []api.Container, volumes sets.String, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(containers) == 0 {
0000000000000000000000000000000000000000;;			return append(allErrs, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allNames := sets.String{}
0000000000000000000000000000000000000000;;		for i, ctr := range containers {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			namePath := idxPath.Child("name")
0000000000000000000000000000000000000000;;			if len(ctr.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(namePath, ""))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, ValidateDNS1123Label(ctr.Name, namePath)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if allNames.Has(ctr.Name) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Duplicate(namePath, ctr.Name))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				allNames.Insert(ctr.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: do not validate leading and trailing whitespace to preserve backward compatibility.
0000000000000000000000000000000000000000;;			// for example: https://github.com/openshift/origin/issues/14659 image = " " is special token in pod template
0000000000000000000000000000000000000000;;			// others may have done similar
0000000000000000000000000000000000000000;;			if len(ctr.Image) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath.Child("image"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctr.Lifecycle != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateLifecycle(ctr.Lifecycle, idxPath.Child("lifecycle"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateProbe(ctr.LivenessProbe, idxPath.Child("livenessProbe"))...)
0000000000000000000000000000000000000000;;			// Liveness-specific validation
0000000000000000000000000000000000000000;;			if ctr.LivenessProbe != nil && ctr.LivenessProbe.SuccessThreshold != 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("livenessProbe", "successThreshold"), ctr.LivenessProbe.SuccessThreshold, "must be 1"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch ctr.TerminationMessagePolicy {
0000000000000000000000000000000000000000;;			case api.TerminationMessageReadFile, api.TerminationMessageFallbackToLogsOnError:
0000000000000000000000000000000000000000;;			case "":
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath.Child("terminationMessagePolicy"), "must be 'File' or 'FallbackToLogsOnError'"))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("terminationMessagePolicy"), ctr.TerminationMessagePolicy, "must be 'File' or 'FallbackToLogsOnError'"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateProbe(ctr.ReadinessProbe, idxPath.Child("readinessProbe"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainerPorts(ctr.Ports, idxPath.Child("ports"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateEnv(ctr.Env, idxPath.Child("env"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateEnvFrom(ctr.EnvFrom, idxPath.Child("envFrom"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateVolumeMounts(ctr.VolumeMounts, volumes, idxPath.Child("volumeMounts"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validatePullPolicy(ctr.ImagePullPolicy, idxPath.Child("imagePullPolicy"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceRequirements(&ctr.Resources, idxPath.Child("resources"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateSecurityContext(ctr.SecurityContext, idxPath.Child("securityContext"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check for colliding ports across all containers.
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, checkHostPortConflicts(containers, fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateRestartPolicy(restartPolicy *api.RestartPolicy, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		switch *restartPolicy {
0000000000000000000000000000000000000000;;		case api.RestartPolicyAlways, api.RestartPolicyOnFailure, api.RestartPolicyNever:
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			validValues := []string{string(api.RestartPolicyAlways), string(api.RestartPolicyOnFailure), string(api.RestartPolicyNever)}
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.NotSupported(fldPath, *restartPolicy, validValues))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateDNSPolicy(dnsPolicy *api.DNSPolicy, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		switch *dnsPolicy {
0000000000000000000000000000000000000000;;		case api.DNSClusterFirstWithHostNet, api.DNSClusterFirst, api.DNSDefault:
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			validValues := []string{string(api.DNSClusterFirstWithHostNet), string(api.DNSClusterFirst), string(api.DNSDefault)}
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.NotSupported(fldPath, dnsPolicy, validValues))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateHostNetwork(hostNetwork bool, containers []api.Container, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		if hostNetwork {
0000000000000000000000000000000000000000;;			for i, container := range containers {
0000000000000000000000000000000000000000;;				portsPath := fldPath.Index(i).Child("ports")
0000000000000000000000000000000000000000;;				for i, port := range container.Ports {
0000000000000000000000000000000000000000;;					idxPath := portsPath.Index(i)
0000000000000000000000000000000000000000;;					if port.HostPort != port.ContainerPort {
0000000000000000000000000000000000000000;;						allErrors = append(allErrors, field.Invalid(idxPath.Child("containerPort"), port.ContainerPort, "must match `hostPort` when `hostNetwork` is true"))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateHostNetworkNoHostAliases(hostNetwork bool, hostAliases []api.HostAlias, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		if hostNetwork {
0000000000000000000000000000000000000000;;			if len(hostAliases) > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Forbidden(fldPath, "may not be set when `hostNetwork` is true"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateImagePullSecrets checks to make sure the pull secrets are well
0000000000000000000000000000000000000000;;	// formed.  Right now, we only expect name to be set (it's the only field).  If
0000000000000000000000000000000000000000;;	// this ever changes and someone decides to set those fields, we'd like to
0000000000000000000000000000000000000000;;	// know.
0000000000000000000000000000000000000000;;	func validateImagePullSecrets(imagePullSecrets []api.LocalObjectReference, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i, currPullSecret := range imagePullSecrets {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			strippedRef := api.LocalObjectReference{Name: currPullSecret.Name}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(strippedRef, currPullSecret) {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(idxPath, currPullSecret, "only name may be set"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateAffinity checks if given affinities are valid
0000000000000000000000000000000000000000;;	func validateAffinity(affinity *api.Affinity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if affinity != nil {
0000000000000000000000000000000000000000;;			if na := affinity.NodeAffinity; na != nil {
0000000000000000000000000000000000000000;;				// TODO: Uncomment the next three lines once RequiredDuringSchedulingRequiredDuringExecution is implemented.
0000000000000000000000000000000000000000;;				// if na.RequiredDuringSchedulingRequiredDuringExecution != nil {
0000000000000000000000000000000000000000;;				//	allErrs = append(allErrs, ValidateNodeSelector(na.RequiredDuringSchedulingRequiredDuringExecution, fldPath.Child("requiredDuringSchedulingRequiredDuringExecution"))...)
0000000000000000000000000000000000000000;;				// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if na.RequiredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, ValidateNodeSelector(na.RequiredDuringSchedulingIgnoredDuringExecution, fldPath.Child("requiredDuringSchedulingIgnoredDuringExecution"))...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(na.PreferredDuringSchedulingIgnoredDuringExecution) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, ValidatePreferredSchedulingTerms(na.PreferredDuringSchedulingIgnoredDuringExecution, fldPath.Child("preferredDuringSchedulingIgnoredDuringExecution"))...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if affinity.PodAffinity != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePodAffinity(affinity.PodAffinity, fldPath.Child("podAffinity"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if affinity.PodAntiAffinity != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePodAntiAffinity(affinity.PodAntiAffinity, fldPath.Child("podAntiAffinity"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateTaintEffect(effect *api.TaintEffect, allowEmpty bool, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		if !allowEmpty && len(*effect) == 0 {
0000000000000000000000000000000000000000;;			return field.ErrorList{field.Required(fldPath, "")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		switch *effect {
0000000000000000000000000000000000000000;;		// TODO: Replace next line with subsequent commented-out line when implement TaintEffectNoScheduleNoAdmit.
0000000000000000000000000000000000000000;;		case api.TaintEffectNoSchedule, api.TaintEffectPreferNoSchedule, api.TaintEffectNoExecute:
0000000000000000000000000000000000000000;;			// case api.TaintEffectNoSchedule, api.TaintEffectPreferNoSchedule, api.TaintEffectNoScheduleNoAdmit, api.TaintEffectNoExecute:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			validValues := []string{
0000000000000000000000000000000000000000;;				string(api.TaintEffectNoSchedule),
0000000000000000000000000000000000000000;;				string(api.TaintEffectPreferNoSchedule),
0000000000000000000000000000000000000000;;				string(api.TaintEffectNoExecute),
0000000000000000000000000000000000000000;;				// TODO: Uncomment this block when implement TaintEffectNoScheduleNoAdmit.
0000000000000000000000000000000000000000;;				// string(api.TaintEffectNoScheduleNoAdmit),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.NotSupported(fldPath, effect, validValues))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateOnlyAddedTolerations validates updated pod tolerations.
0000000000000000000000000000000000000000;;	func validateOnlyAddedTolerations(newTolerations []api.Toleration, oldTolerations []api.Toleration, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, old := range oldTolerations {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			old.TolerationSeconds = nil
0000000000000000000000000000000000000000;;			for _, new := range newTolerations {
0000000000000000000000000000000000000000;;				new.TolerationSeconds = nil
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(old, new) {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath, "existing toleration can not be modified except its tolerationSeconds"))
0000000000000000000000000000000000000000;;				return allErrs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateTolerations(newTolerations, fldPath)...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateHostAliases(hostAliases []api.HostAlias, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, hostAlias := range hostAliases {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(hostAlias.IP); ip == nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("ip"), hostAlias.IP, "must be valid IP address"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, hostname := range hostAlias.Hostnames {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, ValidateDNS1123Subdomain(hostname, fldPath.Child("hostnames"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateTolerations tests if given tolerations have valid data.
0000000000000000000000000000000000000000;;	func ValidateTolerations(tolerations []api.Toleration, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i, toleration := range tolerations {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			// validate the toleration key
0000000000000000000000000000000000000000;;			if len(toleration.Key) > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, unversionedvalidation.ValidateLabelName(toleration.Key, idxPath.Child("key"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// empty toleration key with Exists operator and empty value means match all taints
0000000000000000000000000000000000000000;;			if len(toleration.Key) == 0 && toleration.Operator != api.TolerationOpExists {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(idxPath.Child("operator"), toleration.Operator,
0000000000000000000000000000000000000000;;					"operator must be Exists when `key` is empty, which means \"match all values and all keys\""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if toleration.TolerationSeconds != nil && toleration.Effect != api.TaintEffectNoExecute {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(idxPath.Child("effect"), toleration.Effect,
0000000000000000000000000000000000000000;;					"effect must be 'NoExecute' when `tolerationSeconds` is set"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate toleration operator and value
0000000000000000000000000000000000000000;;			switch toleration.Operator {
0000000000000000000000000000000000000000;;			// empty operator means Equal
0000000000000000000000000000000000000000;;			case api.TolerationOpEqual, "":
0000000000000000000000000000000000000000;;				if errs := validation.IsValidLabelValue(toleration.Value); len(errs) != 0 {
0000000000000000000000000000000000000000;;					allErrors = append(allErrors, field.Invalid(idxPath.Child("operator"), toleration.Value, strings.Join(errs, ";")))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case api.TolerationOpExists:
0000000000000000000000000000000000000000;;				if len(toleration.Value) > 0 {
0000000000000000000000000000000000000000;;					allErrors = append(allErrors, field.Invalid(idxPath.Child("operator"), toleration, "value must be empty when `operator` is 'Exists'"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				validValues := []string{string(api.TolerationOpEqual), string(api.TolerationOpExists)}
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.NotSupported(idxPath.Child("operator"), toleration.Operator, validValues))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate toleration effect, empty toleration effect means match all taint effects
0000000000000000000000000000000000000000;;			if len(toleration.Effect) > 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, validateTaintEffect(&toleration.Effect, true, idxPath.Child("effect"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateContainersOnlyForPod does additional validation for containers on a pod versus a pod template
0000000000000000000000000000000000000000;;	// it only does additive validation of fields not covered in validateContainers
0000000000000000000000000000000000000000;;	func validateContainersOnlyForPod(containers []api.Container, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i, ctr := range containers {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			if len(ctr.Image) != len(strings.TrimSpace(ctr.Image)) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(idxPath.Child("image"), ctr.Image, "must not have leading or trailing whitespace"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePod tests if required fields in the pod are set.
0000000000000000000000000000000000000000;;	func ValidatePod(pod *api.Pod) field.ErrorList {
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("metadata")
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&pod.ObjectMeta, true, ValidatePodName, fldPath)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSpecificAnnotations(pod.ObjectMeta.Annotations, &pod.Spec, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSpec(&pod.Spec, field.NewPath("spec"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we do additional validation only pertinent for pods and not pod templates
0000000000000000000000000000000000000000;;		// this was done to preserve backwards compatibility
0000000000000000000000000000000000000000;;		specPath := field.NewPath("spec")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateContainersOnlyForPod(pod.Spec.Containers, specPath.Child("containers"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateContainersOnlyForPod(pod.Spec.InitContainers, specPath.Child("initContainers"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodSpec tests that the specified PodSpec has valid data.
0000000000000000000000000000000000000000;;	// This includes checking formatting and uniqueness.  It also canonicalizes the
0000000000000000000000000000000000000000;;	// structure by setting default values and implementing any backwards-compatibility
0000000000000000000000000000000000000000;;	// tricks.
0000000000000000000000000000000000000000;;	func ValidatePodSpec(spec *api.PodSpec, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allVolumes, vErrs := ValidateVolumes(spec.Volumes, fldPath.Child("volumes"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, vErrs...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateContainers(spec.Containers, allVolumes, fldPath.Child("containers"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateInitContainers(spec.InitContainers, spec.Containers, allVolumes, fldPath.Child("initContainers"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateRestartPolicy(&spec.RestartPolicy, fldPath.Child("restartPolicy"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateDNSPolicy(&spec.DNSPolicy, fldPath.Child("dnsPolicy"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, unversionedvalidation.ValidateLabels(spec.NodeSelector, fldPath.Child("nodeSelector"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSecurityContext(spec.SecurityContext, spec, fldPath, fldPath.Child("securityContext"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateImagePullSecrets(spec.ImagePullSecrets, fldPath.Child("imagePullSecrets"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateAffinity(spec.Affinity, fldPath.Child("affinity"))...)
0000000000000000000000000000000000000000;;		if len(spec.ServiceAccountName) > 0 {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateServiceAccountName(spec.ServiceAccountName, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("serviceAccountName"), spec.ServiceAccountName, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(spec.NodeName) > 0 {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateNodeName(spec.NodeName, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("nodeName"), spec.NodeName, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;			value := *spec.ActiveDeadlineSeconds
0000000000000000000000000000000000000000;;			if value < 1 || value > math.MaxInt32 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("activeDeadlineSeconds"), value, validation.InclusiveRangeError(1, math.MaxInt32)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(spec.Hostname) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(spec.Hostname, fldPath.Child("hostname"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(spec.Subdomain) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(spec.Subdomain, fldPath.Child("subdomain"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(spec.Tolerations) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateTolerations(spec.Tolerations, fldPath.Child("tolerations"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(spec.HostAliases) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateHostAliases(spec.HostAliases, fldPath.Child("hostAliases"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(spec.PriorityClassName) > 0 {
0000000000000000000000000000000000000000;;			if !utilfeature.DefaultFeatureGate.Enabled(features.PodPriority) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("priorityClassName"), "Pod priority is disabled by feature-gate"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, msg := range ValidatePriorityClassName(spec.PriorityClassName, false) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("priorityClassName"), spec.PriorityClassName, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Priority != nil && !utilfeature.DefaultFeatureGate.Enabled(features.PodPriority) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fldPath.Child("priority"), "Pod priority is disabled by feature-gate"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNodeSelectorRequirement tests that the specified NodeSelectorRequirement fields has valid data
0000000000000000000000000000000000000000;;	func ValidateNodeSelectorRequirement(rq api.NodeSelectorRequirement, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		switch rq.Operator {
0000000000000000000000000000000000000000;;		case api.NodeSelectorOpIn, api.NodeSelectorOpNotIn:
0000000000000000000000000000000000000000;;			if len(rq.Values) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("values"), "must be specified when `operator` is 'In' or 'NotIn'"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case api.NodeSelectorOpExists, api.NodeSelectorOpDoesNotExist:
0000000000000000000000000000000000000000;;			if len(rq.Values) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("values"), "may not be specified when `operator` is 'Exists' or 'DoesNotExist'"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case api.NodeSelectorOpGt, api.NodeSelectorOpLt:
0000000000000000000000000000000000000000;;			if len(rq.Values) != 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("values"), "must be specified single value when `operator` is 'Lt' or 'Gt'"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("operator"), rq.Operator, "not a valid selector operator"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, unversionedvalidation.ValidateLabelName(rq.Key, fldPath.Child("key"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNodeSelectorTerm tests that the specified node selector term has valid data
0000000000000000000000000000000000000000;;	func ValidateNodeSelectorTerm(term api.NodeSelectorTerm, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(term.MatchExpressions) == 0 {
0000000000000000000000000000000000000000;;			return append(allErrs, field.Required(fldPath.Child("matchExpressions"), "must have at least one node selector requirement"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for j, req := range term.MatchExpressions {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateNodeSelectorRequirement(req, fldPath.Child("matchExpressions").Index(j))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNodeSelector tests that the specified nodeSelector fields has valid data
0000000000000000000000000000000000000000;;	func ValidateNodeSelector(nodeSelector *api.NodeSelector, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		termFldPath := fldPath.Child("nodeSelectorTerms")
0000000000000000000000000000000000000000;;		if len(nodeSelector.NodeSelectorTerms) == 0 {
0000000000000000000000000000000000000000;;			return append(allErrs, field.Required(termFldPath, "must have at least one node selector term"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, term := range nodeSelector.NodeSelectorTerms {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateNodeSelectorTerm(term, termFldPath.Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateAvoidPodsInNodeAnnotations tests that the serialized AvoidPods in Node.Annotations has valid data
0000000000000000000000000000000000000000;;	func ValidateAvoidPodsInNodeAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v1Avoids, err := v1helper.GetAvoidPodsFromNodeAnnotations(annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("AvoidPods"), api.PreferAvoidPodsAnnotationKey, err.Error()))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var avoids api.AvoidPods
0000000000000000000000000000000000000000;;		if err := k8s_api_v1.Convert_v1_AvoidPods_To_api_AvoidPods(&v1Avoids, &avoids, nil); err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("AvoidPods"), api.PreferAvoidPodsAnnotationKey, err.Error()))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(avoids.PreferAvoidPods) != 0 {
0000000000000000000000000000000000000000;;			for i, pa := range avoids.PreferAvoidPods {
0000000000000000000000000000000000000000;;				idxPath := fldPath.Child(api.PreferAvoidPodsAnnotationKey).Index(i)
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validatePreferAvoidPodsEntry(pa, idxPath)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePreferAvoidPodsEntry tests if given PreferAvoidPodsEntry has valid data.
0000000000000000000000000000000000000000;;	func validatePreferAvoidPodsEntry(avoidPodEntry api.PreferAvoidPodsEntry, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;		if avoidPodEntry.PodSignature.PodController == nil {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, field.Required(fldPath.Child("PodSignature"), ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if *(avoidPodEntry.PodSignature.PodController.Controller) != true {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors,
0000000000000000000000000000000000000000;;					field.Invalid(fldPath.Child("PodSignature").Child("PodController").Child("Controller"),
0000000000000000000000000000000000000000;;						*(avoidPodEntry.PodSignature.PodController.Controller), "must point to a controller"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePreferredSchedulingTerms tests that the specified SoftNodeAffinity fields has valid data
0000000000000000000000000000000000000000;;	func ValidatePreferredSchedulingTerms(terms []api.PreferredSchedulingTerm, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, term := range terms {
0000000000000000000000000000000000000000;;			if term.Weight <= 0 || term.Weight > 100 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Index(i).Child("weight"), term.Weight, "must be in the range 1-100"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateNodeSelectorTerm(term.Preference, fldPath.Index(i).Child("preference"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePodAffinityTerm tests that the specified podAffinityTerm fields have valid data
0000000000000000000000000000000000000000;;	func validatePodAffinityTerm(podAffinityTerm api.PodAffinityTerm, allowEmptyTopologyKey bool, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, unversionedvalidation.ValidateLabelSelector(podAffinityTerm.LabelSelector, fldPath.Child("matchExpressions"))...)
0000000000000000000000000000000000000000;;		for _, name := range podAffinityTerm.Namespaces {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateNamespaceName(name, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("namespace"), name, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !allowEmptyTopologyKey && len(podAffinityTerm.TopologyKey) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("topologyKey"), "can only be empty for PreferredDuringScheduling pod anti affinity"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(podAffinityTerm.TopologyKey) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, unversionedvalidation.ValidateLabelName(podAffinityTerm.TopologyKey, fldPath.Child("topologyKey"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePodAffinityTerms tests that the specified podAffinityTerms fields have valid data
0000000000000000000000000000000000000000;;	func validatePodAffinityTerms(podAffinityTerms []api.PodAffinityTerm, allowEmptyTopologyKey bool, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i, podAffinityTerm := range podAffinityTerms {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validatePodAffinityTerm(podAffinityTerm, allowEmptyTopologyKey, fldPath.Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateWeightedPodAffinityTerms tests that the specified weightedPodAffinityTerms fields have valid data
0000000000000000000000000000000000000000;;	func validateWeightedPodAffinityTerms(weightedPodAffinityTerms []api.WeightedPodAffinityTerm, allowEmptyTopologyKey bool, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for j, weightedTerm := range weightedPodAffinityTerms {
0000000000000000000000000000000000000000;;			if weightedTerm.Weight <= 0 || weightedTerm.Weight > 100 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Index(j).Child("weight"), weightedTerm.Weight, "must be in the range 1-100"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validatePodAffinityTerm(weightedTerm.PodAffinityTerm, allowEmptyTopologyKey, fldPath.Index(j).Child("podAffinityTerm"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePodAntiAffinity tests that the specified podAntiAffinity fields have valid data
0000000000000000000000000000000000000000;;	func validatePodAntiAffinity(podAntiAffinity *api.PodAntiAffinity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		// TODO:Uncomment below code once RequiredDuringSchedulingRequiredDuringExecution is implemented.
0000000000000000000000000000000000000000;;		// if podAntiAffinity.RequiredDuringSchedulingRequiredDuringExecution != nil {
0000000000000000000000000000000000000000;;		//	allErrs = append(allErrs, validatePodAffinityTerms(podAntiAffinity.RequiredDuringSchedulingRequiredDuringExecution, false,
0000000000000000000000000000000000000000;;		//		fldPath.Child("requiredDuringSchedulingRequiredDuringExecution"))...)
0000000000000000000000000000000000000000;;		//}
0000000000000000000000000000000000000000;;		if podAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;			// empty topologyKey is not allowed for hard pod anti-affinity
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validatePodAffinityTerms(podAntiAffinity.RequiredDuringSchedulingIgnoredDuringExecution, false,
0000000000000000000000000000000000000000;;				fldPath.Child("requiredDuringSchedulingIgnoredDuringExecution"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if podAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;			// empty topologyKey is allowed for soft pod anti-affinity
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateWeightedPodAffinityTerms(podAntiAffinity.PreferredDuringSchedulingIgnoredDuringExecution, true,
0000000000000000000000000000000000000000;;				fldPath.Child("preferredDuringSchedulingIgnoredDuringExecution"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePodAffinity tests that the specified podAffinity fields have valid data
0000000000000000000000000000000000000000;;	func validatePodAffinity(podAffinity *api.PodAffinity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		// TODO:Uncomment below code once RequiredDuringSchedulingRequiredDuringExecution is implemented.
0000000000000000000000000000000000000000;;		// if podAffinity.RequiredDuringSchedulingRequiredDuringExecution != nil {
0000000000000000000000000000000000000000;;		//	allErrs = append(allErrs, validatePodAffinityTerms(podAffinity.RequiredDuringSchedulingRequiredDuringExecution, false,
0000000000000000000000000000000000000000;;		//		fldPath.Child("requiredDuringSchedulingRequiredDuringExecution"))...)
0000000000000000000000000000000000000000;;		//}
0000000000000000000000000000000000000000;;		if podAffinity.RequiredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;			// empty topologyKey is not allowed for hard pod affinity
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validatePodAffinityTerms(podAffinity.RequiredDuringSchedulingIgnoredDuringExecution, false,
0000000000000000000000000000000000000000;;				fldPath.Child("requiredDuringSchedulingIgnoredDuringExecution"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if podAffinity.PreferredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;			// empty topologyKey is not allowed for soft pod affinity
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateWeightedPodAffinityTerms(podAffinity.PreferredDuringSchedulingIgnoredDuringExecution, false,
0000000000000000000000000000000000000000;;				fldPath.Child("preferredDuringSchedulingIgnoredDuringExecution"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateSeccompProfile(p string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		if p == "docker/default" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p == "unconfined" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(p, "localhost/") {
0000000000000000000000000000000000000000;;			return validateLocalDescendingPath(strings.TrimPrefix(p, "localhost/"), fldPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return field.ErrorList{field.Invalid(fldPath, p, "must be a valid seccomp profile")}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateSeccompPodAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if p, exists := annotations[api.SeccompPodAnnotationKey]; exists {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateSeccompProfile(p, fldPath.Child(api.SeccompPodAnnotationKey))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, p := range annotations {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(k, api.SeccompContainerAnnotationKeyPrefix) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, ValidateSeccompProfile(p, fldPath.Child(k))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateAppArmorPodAnnotations(annotations map[string]string, spec *api.PodSpec, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for k, p := range annotations {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(k, apparmor.ContainerAnnotationKeyPrefix) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: this belongs to admission, not general pod validation:
0000000000000000000000000000000000000000;;			if !utilfeature.DefaultFeatureGate.Enabled(features.AppArmor) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Key(k), "AppArmor is disabled by feature-gate"))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containerName := strings.TrimPrefix(k, apparmor.ContainerAnnotationKeyPrefix)
0000000000000000000000000000000000000000;;			if !podSpecHasContainer(spec, containerName) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Key(k), containerName, "container not found"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := apparmor.ValidateProfileFormat(p); err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Key(k), p, err.Error()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podSpecHasContainer(spec *api.PodSpec, containerName string) bool {
0000000000000000000000000000000000000000;;		for _, c := range spec.InitContainers {
0000000000000000000000000000000000000000;;			if c.Name == containerName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range spec.Containers {
0000000000000000000000000000000000000000;;			if c.Name == containerName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// a sysctl segment regex, concatenated with dots to form a sysctl name
0000000000000000000000000000000000000000;;		SysctlSegmentFmt string = "[a-z0-9]([-_a-z0-9]*[a-z0-9])?"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a sysctl name regex
0000000000000000000000000000000000000000;;		SysctlFmt string = "(" + SysctlSegmentFmt + "\\.)*" + SysctlSegmentFmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the maximal length of a sysctl name
0000000000000000000000000000000000000000;;		SysctlMaxLength int = 253
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sysctlRegexp = regexp.MustCompile("^" + SysctlFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidSysctlName checks that the given string is a valid sysctl name,
0000000000000000000000000000000000000000;;	// i.e. matches SysctlFmt.
0000000000000000000000000000000000000000;;	func IsValidSysctlName(name string) bool {
0000000000000000000000000000000000000000;;		if len(name) > SysctlMaxLength {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sysctlRegexp.MatchString(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateSysctls(sysctls []api.Sysctl, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i, s := range sysctls {
0000000000000000000000000000000000000000;;			if len(s.Name) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Index(i).Child("name"), ""))
0000000000000000000000000000000000000000;;			} else if !IsValidSysctlName(s.Name) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Index(i).Child("name"), s.Name, fmt.Sprintf("must have at most %d characters and match regex %s", SysctlMaxLength, SysctlFmt)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodSecurityContext test that the specified PodSecurityContext has valid data.
0000000000000000000000000000000000000000;;	func ValidatePodSecurityContext(securityContext *api.PodSecurityContext, spec *api.PodSpec, specPath, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if securityContext != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateHostNetwork(securityContext.HostNetwork, spec.Containers, specPath.Child("containers"))...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateHostNetworkNoHostAliases(securityContext.HostNetwork, spec.HostAliases, specPath)...)
0000000000000000000000000000000000000000;;			if securityContext.FSGroup != nil {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsValidGroupID(*securityContext.FSGroup) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("fsGroup"), *(securityContext.FSGroup), msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if securityContext.RunAsUser != nil {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsValidUserID(*securityContext.RunAsUser) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("runAsUser"), *(securityContext.RunAsUser), msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for g, gid := range securityContext.SupplementalGroups {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsValidGroupID(gid) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("supplementalGroups").Index(g), gid, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateContainerUpdates(newContainers, oldContainers []api.Container, fldPath *field.Path) (allErrs field.ErrorList, stop bool) {
0000000000000000000000000000000000000000;;		allErrs = field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(newContainers) != len(oldContainers) {
0000000000000000000000000000000000000000;;			//TODO: Pinpoint the specific container that causes the invalid error after we have strategic merge diff
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fldPath, "pod updates may not add or remove containers"))
0000000000000000000000000000000000000000;;			return allErrs, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate updated container images
0000000000000000000000000000000000000000;;		for i, ctr := range newContainers {
0000000000000000000000000000000000000000;;			if len(ctr.Image) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Index(i).Child("image"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// this is only called from ValidatePodUpdate so its safe to check leading/trailing whitespace.
0000000000000000000000000000000000000000;;			if len(strings.TrimSpace(ctr.Image)) != len(ctr.Image) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Index(i).Child("image"), ctr.Image, "must not have leading or trailing whitespace"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodUpdate tests to see if the update is legal for an end user to make. newPod is updated with fields
0000000000000000000000000000000000000000;;	// that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidatePodUpdate(newPod, oldPod *api.Pod) field.ErrorList {
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("metadata")
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newPod.ObjectMeta, &oldPod.ObjectMeta, fldPath)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSpecificAnnotationUpdates(newPod, oldPod, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		specPath := field.NewPath("spec")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate updateable fields:
0000000000000000000000000000000000000000;;		// 1.  spec.containers[*].image
0000000000000000000000000000000000000000;;		// 2.  spec.initContainers[*].image
0000000000000000000000000000000000000000;;		// 3.  spec.activeDeadlineSeconds
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerErrs, stop := ValidateContainerUpdates(newPod.Spec.Containers, oldPod.Spec.Containers, specPath.Child("containers"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, containerErrs...)
0000000000000000000000000000000000000000;;		if stop {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerErrs, stop = ValidateContainerUpdates(newPod.Spec.InitContainers, oldPod.Spec.InitContainers, specPath.Child("initContainers"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, containerErrs...)
0000000000000000000000000000000000000000;;		if stop {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate updated spec.activeDeadlineSeconds.  two types of updates are allowed:
0000000000000000000000000000000000000000;;		// 1.  from nil to a positive value
0000000000000000000000000000000000000000;;		// 2.  from a positive value to a lesser, non-negative value
0000000000000000000000000000000000000000;;		if newPod.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;			newActiveDeadlineSeconds := *newPod.Spec.ActiveDeadlineSeconds
0000000000000000000000000000000000000000;;			if newActiveDeadlineSeconds < 0 || newActiveDeadlineSeconds > math.MaxInt32 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(specPath.Child("activeDeadlineSeconds"), newActiveDeadlineSeconds, validation.InclusiveRangeError(0, math.MaxInt32)))
0000000000000000000000000000000000000000;;				return allErrs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if oldPod.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;				oldActiveDeadlineSeconds := *oldPod.Spec.ActiveDeadlineSeconds
0000000000000000000000000000000000000000;;				if oldActiveDeadlineSeconds < newActiveDeadlineSeconds {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(specPath.Child("activeDeadlineSeconds"), newActiveDeadlineSeconds, "must be less than or equal to previous value"))
0000000000000000000000000000000000000000;;					return allErrs
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if oldPod.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(specPath.Child("activeDeadlineSeconds"), newPod.Spec.ActiveDeadlineSeconds, "must not update from a positive integer to nil value"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle updateable fields by munging those fields prior to deep equal comparison.
0000000000000000000000000000000000000000;;		mungedPod := *newPod
0000000000000000000000000000000000000000;;		// munge spec.containers[*].image
0000000000000000000000000000000000000000;;		var newContainers []api.Container
0000000000000000000000000000000000000000;;		for ix, container := range mungedPod.Spec.Containers {
0000000000000000000000000000000000000000;;			container.Image = oldPod.Spec.Containers[ix].Image
0000000000000000000000000000000000000000;;			newContainers = append(newContainers, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mungedPod.Spec.Containers = newContainers
0000000000000000000000000000000000000000;;		// munge spec.initContainers[*].image
0000000000000000000000000000000000000000;;		var newInitContainers []api.Container
0000000000000000000000000000000000000000;;		for ix, container := range mungedPod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			container.Image = oldPod.Spec.InitContainers[ix].Image
0000000000000000000000000000000000000000;;			newInitContainers = append(newInitContainers, container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mungedPod.Spec.InitContainers = newInitContainers
0000000000000000000000000000000000000000;;		// munge spec.activeDeadlineSeconds
0000000000000000000000000000000000000000;;		mungedPod.Spec.ActiveDeadlineSeconds = nil
0000000000000000000000000000000000000000;;		if oldPod.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;			activeDeadlineSeconds := *oldPod.Spec.ActiveDeadlineSeconds
0000000000000000000000000000000000000000;;			mungedPod.Spec.ActiveDeadlineSeconds = &activeDeadlineSeconds
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow only additions to tolerations updates.
0000000000000000000000000000000000000000;;		mungedPod.Spec.Tolerations = oldPod.Spec.Tolerations
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateOnlyAddedTolerations(newPod.Spec.Tolerations, oldPod.Spec.Tolerations, specPath.Child("tolerations"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(mungedPod.Spec, oldPod.Spec) {
0000000000000000000000000000000000000000;;			//TODO: Pinpoint the specific field that causes the invalid error after we have strategic merge diff
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(specPath, "pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds` or `spec.tolerations` (only additions to existing tolerations)"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodStatusUpdate tests to see if the update is legal for an end user to make. newPod is updated with fields
0000000000000000000000000000000000000000;;	// that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidatePodStatusUpdate(newPod, oldPod *api.Pod) field.ErrorList {
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("metadata")
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newPod.ObjectMeta, &oldPod.ObjectMeta, fldPath)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSpecificAnnotationUpdates(newPod, oldPod, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if newPod.Spec.NodeName != oldPod.Spec.NodeName {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath("status", "nodeName"), "may not be changed directly"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For status update we ignore changes to pod spec.
0000000000000000000000000000000000000000;;		newPod.Spec = oldPod.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodBinding tests if required fields in the pod binding are legal.
0000000000000000000000000000000000000000;;	func ValidatePodBinding(binding *api.Binding) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(binding.Target.Kind) != 0 && binding.Target.Kind != "Node" {
0000000000000000000000000000000000000000;;			// TODO: When validation becomes versioned, this gets more complicated.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(field.NewPath("target", "kind"), binding.Target.Kind, []string{"Node", "<empty>"}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(binding.Target.Name) == 0 {
0000000000000000000000000000000000000000;;			// TODO: When validation becomes versioned, this gets more complicated.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("target", "name"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodTemplate tests if required fields in the pod template are set.
0000000000000000000000000000000000000000;;	func ValidatePodTemplate(pod *api.PodTemplate) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&pod.ObjectMeta, true, ValidatePodName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodTemplateSpec(&pod.Template, field.NewPath("template"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodTemplateUpdate tests to see if the update is legal for an end user to make. newPod is updated with fields
0000000000000000000000000000000000000000;;	// that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidatePodTemplateUpdate(newPod, oldPod *api.PodTemplate) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&oldPod.ObjectMeta, &newPod.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodTemplateSpec(&newPod.Template, field.NewPath("template"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedSessionAffinityType = sets.NewString(string(api.ServiceAffinityClientIP), string(api.ServiceAffinityNone))
0000000000000000000000000000000000000000;;	var supportedServiceType = sets.NewString(string(api.ServiceTypeClusterIP), string(api.ServiceTypeNodePort),
0000000000000000000000000000000000000000;;		string(api.ServiceTypeLoadBalancer), string(api.ServiceTypeExternalName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateService tests if required fields/annotations of a Service are valid.
0000000000000000000000000000000000000000;;	func ValidateService(service *api.Service) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&service.ObjectMeta, true, ValidateServiceName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		specPath := field.NewPath("spec")
0000000000000000000000000000000000000000;;		isHeadlessService := service.Spec.ClusterIP == api.ClusterIPNone
0000000000000000000000000000000000000000;;		if len(service.Spec.Ports) == 0 && !isHeadlessService && service.Spec.Type != api.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(specPath.Child("ports"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch service.Spec.Type {
0000000000000000000000000000000000000000;;		case api.ServiceTypeLoadBalancer:
0000000000000000000000000000000000000000;;			for ix := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				port := &service.Spec.Ports[ix]
0000000000000000000000000000000000000000;;				// This is a workaround for broken cloud environments that
0000000000000000000000000000000000000000;;				// over-open firewalls.  Hopefully it can go away when more clouds
0000000000000000000000000000000000000000;;				// understand containers better.
0000000000000000000000000000000000000000;;				if port.Port == 10250 {
0000000000000000000000000000000000000000;;					portPath := specPath.Child("ports").Index(ix)
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(portPath, port.Port, "may not expose port 10250 externally since it is used by kubelet"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if service.Spec.ClusterIP == "None" {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(specPath.Child("clusterIP"), service.Spec.ClusterIP, "may not be set to 'None' for LoadBalancer services"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case api.ServiceTypeNodePort:
0000000000000000000000000000000000000000;;			if service.Spec.ClusterIP == "None" {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(specPath.Child("clusterIP"), service.Spec.ClusterIP, "may not be set to 'None' for NodePort services"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case api.ServiceTypeExternalName:
0000000000000000000000000000000000000000;;			if service.Spec.ClusterIP != "" {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(specPath.Child("clusterIP"), service.Spec.ClusterIP, "must be empty for ExternalName services"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(service.Spec.ExternalName) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, ValidateDNS1123Subdomain(service.Spec.ExternalName, specPath.Child("externalName"))...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(specPath.Child("externalName"), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allPortNames := sets.String{}
0000000000000000000000000000000000000000;;		portsPath := specPath.Child("ports")
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			portPath := portsPath.Index(i)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateServicePort(&service.Spec.Ports[i], len(service.Spec.Ports) > 1, isHeadlessService, &allPortNames, portPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if service.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, unversionedvalidation.ValidateLabels(service.Spec.Selector, specPath.Child("selector"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(service.Spec.SessionAffinity) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(specPath.Child("sessionAffinity"), ""))
0000000000000000000000000000000000000000;;		} else if !supportedSessionAffinityType.Has(string(service.Spec.SessionAffinity)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(specPath.Child("sessionAffinity"), service.Spec.SessionAffinity, supportedSessionAffinityType.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if helper.IsServiceIPSet(service) {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(service.Spec.ClusterIP); ip == nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(specPath.Child("clusterIP"), service.Spec.ClusterIP, "must be empty, 'None', or a valid IP address"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipPath := specPath.Child("externalIPs")
0000000000000000000000000000000000000000;;		for i, ip := range service.Spec.ExternalIPs {
0000000000000000000000000000000000000000;;			idxPath := ipPath.Index(i)
0000000000000000000000000000000000000000;;			if msgs := validation.IsValidIP(ip); len(msgs) != 0 {
0000000000000000000000000000000000000000;;				for i := range msgs {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath, ip, msgs[i]))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateNonSpecialIP(ip, idxPath)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(service.Spec.Type) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(specPath.Child("type"), ""))
0000000000000000000000000000000000000000;;		} else if !supportedServiceType.Has(string(service.Spec.Type)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(specPath.Child("type"), service.Spec.Type, supportedServiceType.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if service.Spec.Type == api.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;			portsPath := specPath.Child("ports")
0000000000000000000000000000000000000000;;			includeProtocols := sets.NewString()
0000000000000000000000000000000000000000;;			for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				portPath := portsPath.Index(i)
0000000000000000000000000000000000000000;;				if !supportedPortProtocols.Has(string(service.Spec.Ports[i].Protocol)) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(portPath.Child("protocol"), service.Spec.Ports[i].Protocol, "cannot create an external load balancer with non-TCP/UDP ports"))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					includeProtocols.Insert(string(service.Spec.Ports[i].Protocol))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if includeProtocols.Len() > 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(portsPath, service.Spec.Ports, "cannot create an external load balancer with mix protocols"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if service.Spec.Type == api.ServiceTypeClusterIP {
0000000000000000000000000000000000000000;;			portsPath := specPath.Child("ports")
0000000000000000000000000000000000000000;;			for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				portPath := portsPath.Index(i)
0000000000000000000000000000000000000000;;				if service.Spec.Ports[i].NodePort != 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(portPath.Child("nodePort"), service.Spec.Ports[i].NodePort, "may not be used when `type` is 'ClusterIP'"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for duplicate NodePorts, considering (protocol,port) pairs
0000000000000000000000000000000000000000;;		portsPath = specPath.Child("ports")
0000000000000000000000000000000000000000;;		nodePorts := make(map[api.ServicePort]bool)
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			port := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			if port.NodePort == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portPath := portsPath.Index(i)
0000000000000000000000000000000000000000;;			var key api.ServicePort
0000000000000000000000000000000000000000;;			key.Protocol = port.Protocol
0000000000000000000000000000000000000000;;			key.NodePort = port.NodePort
0000000000000000000000000000000000000000;;			_, found := nodePorts[key]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Duplicate(portPath.Child("nodePort"), port.NodePort))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodePorts[key] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for duplicate TargetPort
0000000000000000000000000000000000000000;;		portsPath = specPath.Child("ports")
0000000000000000000000000000000000000000;;		targetPorts := make(map[api.ServicePort]bool)
0000000000000000000000000000000000000000;;		for i, port := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			if (port.TargetPort.Type == intstr.Int && port.TargetPort.IntVal == 0) || (port.TargetPort.Type == intstr.String && port.TargetPort.StrVal == "") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portPath := portsPath.Index(i)
0000000000000000000000000000000000000000;;			key := api.ServicePort{Protocol: port.Protocol, TargetPort: port.TargetPort}
0000000000000000000000000000000000000000;;			_, found := targetPorts[key]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Duplicate(portPath.Child("targetPort"), port.TargetPort))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			targetPorts[key] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate SourceRange field and annotation
0000000000000000000000000000000000000000;;		_, ok := service.Annotations[api.AnnotationLoadBalancerSourceRangesKey]
0000000000000000000000000000000000000000;;		if len(service.Spec.LoadBalancerSourceRanges) > 0 || ok {
0000000000000000000000000000000000000000;;			var fieldPath *field.Path
0000000000000000000000000000000000000000;;			var val string
0000000000000000000000000000000000000000;;			if len(service.Spec.LoadBalancerSourceRanges) > 0 {
0000000000000000000000000000000000000000;;				fieldPath = specPath.Child("LoadBalancerSourceRanges")
0000000000000000000000000000000000000000;;				val = fmt.Sprintf("%v", service.Spec.LoadBalancerSourceRanges)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fieldPath = field.NewPath("metadata", "annotations").Key(api.AnnotationLoadBalancerSourceRangesKey)
0000000000000000000000000000000000000000;;				val = service.Annotations[api.AnnotationLoadBalancerSourceRangesKey]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if service.Spec.Type != api.ServiceTypeLoadBalancer {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fieldPath, "", "may only be used when `type` is 'LoadBalancer'"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := apiservice.GetLoadBalancerSourceRanges(service)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fieldPath, val, "must be a list of IP ranges. For example, 10.240.0.0/24,10.250.0.0/24 "))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateServiceExternalTrafficFieldsValue(service)...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateServiceExternalTrafficAPIVersion(service)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateServicePort(sp *api.ServicePort, requireName, isHeadlessService bool, allNames *sets.String, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if requireName && len(sp.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		} else if len(sp.Name) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(sp.Name, fldPath.Child("name"))...)
0000000000000000000000000000000000000000;;			if allNames.Has(sp.Name) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Duplicate(fldPath.Child("name"), sp.Name))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				allNames.Insert(sp.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsValidPortNum(int(sp.Port)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("port"), sp.Port, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(sp.Protocol) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("protocol"), ""))
0000000000000000000000000000000000000000;;		} else if !supportedPortProtocols.Has(string(sp.Protocol)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("protocol"), sp.Protocol, supportedPortProtocols.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePortNumOrName(sp.TargetPort, fldPath.Child("targetPort"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// in the v1 API, targetPorts on headless services were tolerated.
0000000000000000000000000000000000000000;;		// once we have version-specific validation, we can reject this on newer API versions, but until then, we have to tolerate it for compatibility.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// if isHeadlessService {
0000000000000000000000000000000000000000;;		// 	if sp.TargetPort.Type == intstr.String || (sp.TargetPort.Type == intstr.Int && sp.Port != sp.TargetPort.IntValue()) {
0000000000000000000000000000000000000000;;		// 		allErrs = append(allErrs, field.Invalid(fldPath.Child("targetPort"), sp.TargetPort, "must be equal to the value of 'port' when clusterIP = None"))
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateServiceExternalTrafficFieldsValue validates ExternalTraffic related annotations
0000000000000000000000000000000000000000;;	// have legal value.
0000000000000000000000000000000000000000;;	func validateServiceExternalTrafficFieldsValue(service *api.Service) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check beta annotations.
0000000000000000000000000000000000000000;;		if l, ok := service.Annotations[api.BetaAnnotationExternalTraffic]; ok {
0000000000000000000000000000000000000000;;			if l != api.AnnotationValueExternalTrafficLocal &&
0000000000000000000000000000000000000000;;				l != api.AnnotationValueExternalTrafficGlobal {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("metadata", "annotations").Key(api.BetaAnnotationExternalTraffic), l,
0000000000000000000000000000000000000000;;					fmt.Sprintf("ExternalTraffic must be %v or %v", api.AnnotationValueExternalTrafficLocal, api.AnnotationValueExternalTrafficGlobal)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l, ok := service.Annotations[api.BetaAnnotationHealthCheckNodePort]; ok {
0000000000000000000000000000000000000000;;			p, err := strconv.Atoi(l)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("metadata", "annotations").Key(api.BetaAnnotationHealthCheckNodePort), l,
0000000000000000000000000000000000000000;;					"HealthCheckNodePort must be a valid port number"))
0000000000000000000000000000000000000000;;			} else if p <= 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("metadata", "annotations").Key(api.BetaAnnotationHealthCheckNodePort), l,
0000000000000000000000000000000000000000;;					"HealthCheckNodePort must be greater than 0"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check first class fields.
0000000000000000000000000000000000000000;;		if service.Spec.ExternalTrafficPolicy != "" &&
0000000000000000000000000000000000000000;;			service.Spec.ExternalTrafficPolicy != api.ServiceExternalTrafficPolicyTypeCluster &&
0000000000000000000000000000000000000000;;			service.Spec.ExternalTrafficPolicy != api.ServiceExternalTrafficPolicyTypeLocal {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("spec").Child("externalTrafficPolicy"), service.Spec.ExternalTrafficPolicy,
0000000000000000000000000000000000000000;;				fmt.Sprintf("ExternalTrafficPolicy must be empty, %v or %v", api.ServiceExternalTrafficPolicyTypeCluster, api.ServiceExternalTrafficPolicyTypeLocal)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if service.Spec.HealthCheckNodePort < 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("spec").Child("healthCheckNodePort"), service.Spec.HealthCheckNodePort,
0000000000000000000000000000000000000000;;				"HealthCheckNodePort must be not less than 0"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serviceExternalTrafficStatus stores flags indicating whether ExternalTraffic
0000000000000000000000000000000000000000;;	// related beta annotations and GA fields are set on service.
0000000000000000000000000000000000000000;;	type serviceExternalTrafficStatus struct {
0000000000000000000000000000000000000000;;		betaExternalTrafficIsSet bool
0000000000000000000000000000000000000000;;		betaHealthCheckIsSet     bool
0000000000000000000000000000000000000000;;		gaExternalTrafficIsSet   bool
0000000000000000000000000000000000000000;;		gaHealthCheckIsSet       bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *serviceExternalTrafficStatus) useBetaExternalTrafficWithGA() bool {
0000000000000000000000000000000000000000;;		return s.betaExternalTrafficIsSet && (s.gaExternalTrafficIsSet || s.gaHealthCheckIsSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *serviceExternalTrafficStatus) useBetaHealthCheckWithGA() bool {
0000000000000000000000000000000000000000;;		return s.betaHealthCheckIsSet && (s.gaExternalTrafficIsSet || s.gaHealthCheckIsSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getServiceExternalTrafficStatus(service *api.Service) *serviceExternalTrafficStatus {
0000000000000000000000000000000000000000;;		s := serviceExternalTrafficStatus{}
0000000000000000000000000000000000000000;;		_, s.betaExternalTrafficIsSet = service.Annotations[api.BetaAnnotationExternalTraffic]
0000000000000000000000000000000000000000;;		_, s.betaHealthCheckIsSet = service.Annotations[api.BetaAnnotationHealthCheckNodePort]
0000000000000000000000000000000000000000;;		s.gaExternalTrafficIsSet = service.Spec.ExternalTrafficPolicy != ""
0000000000000000000000000000000000000000;;		s.gaHealthCheckIsSet = service.Spec.HealthCheckNodePort != 0
0000000000000000000000000000000000000000;;		return &s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateServiceExternalTrafficAPIVersion checks if user mixes ExternalTraffic
0000000000000000000000000000000000000000;;	// API versions.
0000000000000000000000000000000000000000;;	func validateServiceExternalTrafficAPIVersion(service *api.Service) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := getServiceExternalTrafficStatus(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if status.useBetaExternalTrafficWithGA() {
0000000000000000000000000000000000000000;;			fieldPath := field.NewPath("metadata", "annotations").Key(api.BetaAnnotationExternalTraffic)
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("please replace the beta annotation with 'ExternalTrafficPolicy' field")
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fieldPath, api.BetaAnnotationExternalTraffic, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if status.useBetaHealthCheckWithGA() {
0000000000000000000000000000000000000000;;			fieldPath := field.NewPath("metadata", "annotations").Key(api.BetaAnnotationHealthCheckNodePort)
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("please replace the beta annotation with 'HealthCheckNodePort' field")
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fieldPath, api.BetaAnnotationHealthCheckNodePort, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceExternalTrafficFieldsCombination validates if ExternalTrafficPolicy,
0000000000000000000000000000000000000000;;	// HealthCheckNodePort and Type combination are legal. For update, it should be called
0000000000000000000000000000000000000000;;	// after clearing externalTraffic related fields for the ease of transitioning between
0000000000000000000000000000000000000000;;	// different service types.
0000000000000000000000000000000000000000;;	func ValidateServiceExternalTrafficFieldsCombination(service *api.Service) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if service.Spec.Type != api.ServiceTypeLoadBalancer &&
0000000000000000000000000000000000000000;;			service.Spec.Type != api.ServiceTypeNodePort &&
0000000000000000000000000000000000000000;;			service.Spec.ExternalTrafficPolicy != "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "externalTrafficPolicy"), service.Spec.ExternalTrafficPolicy,
0000000000000000000000000000000000000000;;				"ExternalTrafficPolicy can only be set on NodePort and LoadBalancer service"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !apiservice.NeedsHealthCheck(service) &&
0000000000000000000000000000000000000000;;			service.Spec.HealthCheckNodePort != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("spec", "healthCheckNodePort"), service.Spec.HealthCheckNodePort,
0000000000000000000000000000000000000000;;				"HealthCheckNodePort can only be set on LoadBalancer service with ExternalTrafficPolicy=Local"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceUpdate tests if required fields in the service are set during an update
0000000000000000000000000000000000000000;;	func ValidateServiceUpdate(service, oldService *api.Service) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&service.ObjectMeta, &oldService.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClusterIP should be immutable for services using it (every type other than ExternalName)
0000000000000000000000000000000000000000;;		// which do not have ClusterIP assigned yet (empty string value)
0000000000000000000000000000000000000000;;		if service.Spec.Type != api.ServiceTypeExternalName {
0000000000000000000000000000000000000000;;			if oldService.Spec.Type != api.ServiceTypeExternalName && oldService.Spec.ClusterIP != "" {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, ValidateImmutableField(service.Spec.ClusterIP, oldService.Spec.ClusterIP, field.NewPath("spec", "clusterIP"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateService(service)...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceStatusUpdate tests if required fields in the Service are set when updating status.
0000000000000000000000000000000000000000;;	func ValidateServiceStatusUpdate(service, oldService *api.Service) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&service.ObjectMeta, &oldService.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateLoadBalancerStatus(&service.Status.LoadBalancer, field.NewPath("status", "loadBalancer"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReplicationController tests if required fields in the replication controller are set.
0000000000000000000000000000000000000000;;	func ValidateReplicationController(controller *api.ReplicationController) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&controller.ObjectMeta, true, ValidateReplicationControllerName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateReplicationControllerSpec(&controller.Spec, field.NewPath("spec"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReplicationControllerUpdate tests if required fields in the replication controller are set.
0000000000000000000000000000000000000000;;	func ValidateReplicationControllerUpdate(controller, oldController *api.ReplicationController) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&controller.ObjectMeta, &oldController.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateReplicationControllerSpec(&controller.Spec, field.NewPath("spec"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReplicationControllerStatusUpdate tests if required fields in the replication controller are set.
0000000000000000000000000000000000000000;;	func ValidateReplicationControllerStatusUpdate(controller, oldController *api.ReplicationController) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&controller.ObjectMeta, &oldController.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateReplicationControllerStatus(controller.Status, field.NewPath("status"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateReplicationControllerStatus(status api.ReplicationControllerStatus, statusPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(status.Replicas), statusPath.Child("replicas"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(status.FullyLabeledReplicas), statusPath.Child("fullyLabeledReplicas"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(status.ReadyReplicas), statusPath.Child("readyReplicas"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(status.AvailableReplicas), statusPath.Child("availableReplicas"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(status.ObservedGeneration), statusPath.Child("observedGeneration"))...)
0000000000000000000000000000000000000000;;		msg := "cannot be greater than status.replicas"
0000000000000000000000000000000000000000;;		if status.FullyLabeledReplicas > status.Replicas {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(statusPath.Child("fullyLabeledReplicas"), status.FullyLabeledReplicas, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status.ReadyReplicas > status.Replicas {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(statusPath.Child("readyReplicas"), status.ReadyReplicas, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status.AvailableReplicas > status.Replicas {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(statusPath.Child("availableReplicas"), status.AvailableReplicas, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status.AvailableReplicas > status.ReadyReplicas {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(statusPath.Child("availableReplicas"), status.AvailableReplicas, "cannot be greater than readyReplicas"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates that the given selector is non-empty.
0000000000000000000000000000000000000000;;	func ValidateNonEmptySelector(selectorMap map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		selector := labels.Set(selectorMap).AsSelector()
0000000000000000000000000000000000000000;;		if selector.Empty() {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates the given template and ensures that it is in accordance with the desired selector and replicas.
0000000000000000000000000000000000000000;;	func ValidatePodTemplateSpecForRC(template *api.PodTemplateSpec, selectorMap map[string]string, replicas int32, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if template == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath, ""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			selector := labels.Set(selectorMap).AsSelector()
0000000000000000000000000000000000000000;;			if !selector.Empty() {
0000000000000000000000000000000000000000;;				// Verify that the RC selector matches the labels in template.
0000000000000000000000000000000000000000;;				labels := labels.Set(template.Labels)
0000000000000000000000000000000000000000;;				if !selector.Matches(labels) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("metadata", "labels"), template.Labels, "`selector` does not match template `labels`"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidatePodTemplateSpec(template, fldPath)...)
0000000000000000000000000000000000000000;;			if replicas > 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, ValidateReadOnlyPersistentDisks(template.Spec.Volumes, fldPath.Child("spec", "volumes"))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// RestartPolicy has already been first-order validated as per ValidatePodTemplateSpec().
0000000000000000000000000000000000000000;;			if template.Spec.RestartPolicy != api.RestartPolicyAlways {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.NotSupported(fldPath.Child("spec", "restartPolicy"), template.Spec.RestartPolicy, []string{string(api.RestartPolicyAlways)}))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if template.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("spec", "activeDeadlineSeconds"), template.Spec.ActiveDeadlineSeconds, "must not be specified"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReplicationControllerSpec tests if required fields in the replication controller spec are set.
0000000000000000000000000000000000000000;;	func ValidateReplicationControllerSpec(spec *api.ReplicationControllerSpec, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(spec.MinReadySeconds), fldPath.Child("minReadySeconds"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonEmptySelector(spec.Selector, fldPath.Child("selector"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(int64(spec.Replicas), fldPath.Child("replicas"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodTemplateSpecForRC(spec.Template, spec.Selector, spec.Replicas, fldPath.Child("template"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePodTemplateSpec validates the spec of a pod template
0000000000000000000000000000000000000000;;	func ValidatePodTemplateSpec(spec *api.PodTemplateSpec, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, unversionedvalidation.ValidateLabels(spec.Labels, fldPath.Child("labels"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateAnnotations(spec.Annotations, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSpecificAnnotations(spec.Annotations, &spec.Spec, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidatePodSpec(&spec.Spec, fldPath.Child("spec"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateReadOnlyPersistentDisks(volumes []api.Volume, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i := range volumes {
0000000000000000000000000000000000000000;;			vol := &volumes[i]
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			if vol.GCEPersistentDisk != nil {
0000000000000000000000000000000000000000;;				if vol.GCEPersistentDisk.ReadOnly == false {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("gcePersistentDisk", "readOnly"), false, "must be true for replicated pods > 1; GCE PD can only be mounted on multiple machines if it is read-only"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: What to do for AWS?  It doesn't support replicas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateTaintsInNodeAnnotations tests that the serialized taints in Node.Annotations has valid data
0000000000000000000000000000000000000000;;	func ValidateTaintsInNodeAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		taints, err := helper.GetTaintsFromNodeAnnotations(annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, api.TaintsAnnotationKey, err.Error()))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(taints) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateNodeTaints(taints, fldPath.Child(api.TaintsAnnotationKey))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateNodeTaints tests if given taints have valid data.
0000000000000000000000000000000000000000;;	func validateNodeTaints(taints []api.Taint, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrors := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uniqueTaints := map[api.TaintEffect]sets.String{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, currTaint := range taints {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			// validate the taint key
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, unversionedvalidation.ValidateLabelName(currTaint.Key, idxPath.Child("key"))...)
0000000000000000000000000000000000000000;;			// validate the taint value
0000000000000000000000000000000000000000;;			if errs := validation.IsValidLabelValue(currTaint.Value); len(errs) != 0 {
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, field.Invalid(idxPath.Child("value"), currTaint.Value, strings.Join(errs, ";")))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// validate the taint effect
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, validateTaintEffect(&currTaint.Effect, false, idxPath.Child("effect"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate if taint is unique by <key, effect>
0000000000000000000000000000000000000000;;			if len(uniqueTaints[currTaint.Effect]) > 0 && uniqueTaints[currTaint.Effect].Has(currTaint.Key) {
0000000000000000000000000000000000000000;;				duplicatedError := field.Duplicate(idxPath, currTaint)
0000000000000000000000000000000000000000;;				duplicatedError.Detail = "taints must be unique by key and effect pair"
0000000000000000000000000000000000000000;;				allErrors = append(allErrors, duplicatedError)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// add taint to existingTaints for uniqueness check
0000000000000000000000000000000000000000;;			if len(uniqueTaints[currTaint.Effect]) == 0 {
0000000000000000000000000000000000000000;;				uniqueTaints[currTaint.Effect] = sets.String{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			uniqueTaints[currTaint.Effect].Insert(currTaint.Key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateNodeSpecificAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if annotations[api.TaintsAnnotationKey] != "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateTaintsInNodeAnnotations(annotations, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if annotations[api.PreferAvoidPodsAnnotationKey] != "" {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateAvoidPodsInNodeAnnotations(annotations, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNode tests if required fields in the node are set.
0000000000000000000000000000000000000000;;	func ValidateNode(node *api.Node) field.ErrorList {
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("metadata")
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&node.ObjectMeta, false, ValidateNodeName, fldPath)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNodeSpecificAnnotations(node.ObjectMeta.Annotations, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		if len(node.Spec.Taints) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateNodeTaints(node.Spec.Taints, fldPath.Child("taints"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only validate spec. All status fields are optional and can be updated later.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// external ID is required.
0000000000000000000000000000000000000000;;		if len(node.Spec.ExternalID) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("spec", "externalID"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(rjnagal): Ignore PodCIDR till its completely implemented.
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNodeUpdate tests to make sure a node update can be applied.  Modifies oldNode.
0000000000000000000000000000000000000000;;	func ValidateNodeUpdate(node, oldNode *api.Node) field.ErrorList {
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("metadata")
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&node.ObjectMeta, &oldNode.ObjectMeta, fldPath)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNodeSpecificAnnotations(node.ObjectMeta.Annotations, fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Enable the code once we have better api object.status update model. Currently,
0000000000000000000000000000000000000000;;		// anyone can update node status.
0000000000000000000000000000000000000000;;		// if !apiequality.Semantic.DeepEqual(node.Status, api.NodeStatus{}) {
0000000000000000000000000000000000000000;;		// 	allErrs = append(allErrs, field.Invalid("status", node.Status, "must be empty"))
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate resource quantities in capacity.
0000000000000000000000000000000000000000;;		for k, v := range node.Status.Capacity {
0000000000000000000000000000000000000000;;			resPath := field.NewPath("status", "capacity", string(k))
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(k), v, resPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Validate resource quantities in allocatable.
0000000000000000000000000000000000000000;;		for k, v := range node.Status.Allocatable {
0000000000000000000000000000000000000000;;			resPath := field.NewPath("status", "allocatable", string(k))
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(k), v, resPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validte no duplicate addresses in node status.
0000000000000000000000000000000000000000;;		addresses := make(map[api.NodeAddress]bool)
0000000000000000000000000000000000000000;;		for i, address := range node.Status.Addresses {
0000000000000000000000000000000000000000;;			if _, ok := addresses[address]; ok {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Duplicate(field.NewPath("status", "addresses").Index(i), address))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addresses[address] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(oldNode.Spec.PodCIDR) == 0 {
0000000000000000000000000000000000000000;;			// Allow the controller manager to assign a CIDR to a node if it doesn't have one.
0000000000000000000000000000000000000000;;			oldNode.Spec.PodCIDR = node.Spec.PodCIDR
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if oldNode.Spec.PodCIDR != node.Spec.PodCIDR {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(field.NewPath("spec", "podCIDR"), "node updates may not change podCIDR except from \"\" to valid"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: move reset function to its own location
0000000000000000000000000000000000000000;;		// Ignore metadata changes now that they have been tested
0000000000000000000000000000000000000000;;		oldNode.ObjectMeta = node.ObjectMeta
0000000000000000000000000000000000000000;;		// Allow users to update capacity
0000000000000000000000000000000000000000;;		oldNode.Status.Capacity = node.Status.Capacity
0000000000000000000000000000000000000000;;		// Allow users to unschedule node
0000000000000000000000000000000000000000;;		oldNode.Spec.Unschedulable = node.Spec.Unschedulable
0000000000000000000000000000000000000000;;		// Clear status
0000000000000000000000000000000000000000;;		oldNode.Status = node.Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update taints
0000000000000000000000000000000000000000;;		if len(node.Spec.Taints) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateNodeTaints(node.Spec.Taints, fldPath.Child("taints"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldNode.Spec.Taints = node.Spec.Taints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Add a 'real' error type for this error and provide print actual diffs.
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(oldNode, node) {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Update failed validation %#v vs %#v", oldNode, node)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath(""), "node updates may only change labels, taints or capacity"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate compute resource typename.
0000000000000000000000000000000000000000;;	// Refer to docs/design/resources.md for more details.
0000000000000000000000000000000000000000;;	func validateResourceName(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsQualifiedName(value) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allErrs) != 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(strings.Split(value, "/")) == 1 {
0000000000000000000000000000000000000000;;			if !helper.IsStandardResourceName(value) {
0000000000000000000000000000000000000000;;				return append(allErrs, field.Invalid(fldPath, value, "must be a standard resource type or fully qualified"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return field.ErrorList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate container resource name
0000000000000000000000000000000000000000;;	// Refer to docs/design/resources.md for more details.
0000000000000000000000000000000000000000;;	func validateContainerResourceName(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := validateResourceName(value, fldPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(strings.Split(value, "/")) == 1 {
0000000000000000000000000000000000000000;;			if !helper.IsStandardContainerResourceName(value) {
0000000000000000000000000000000000000000;;				return append(allErrs, field.Invalid(fldPath, value, "must be a standard resource for containers"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return field.ErrorList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate resource names that can go in a resource quota
0000000000000000000000000000000000000000;;	// Refer to docs/design/resources.md for more details.
0000000000000000000000000000000000000000;;	func ValidateResourceQuotaResourceName(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := validateResourceName(value, fldPath)
0000000000000000000000000000000000000000;;		if len(strings.Split(value, "/")) == 1 {
0000000000000000000000000000000000000000;;			if !helper.IsStandardQuotaResourceName(value) {
0000000000000000000000000000000000000000;;				return append(allErrs, field.Invalid(fldPath, value, isInvalidQuotaResource))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return field.ErrorList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate limit range types
0000000000000000000000000000000000000000;;	func validateLimitRangeTypeName(value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsQualifiedName(value) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allErrs) != 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(strings.Split(value, "/")) == 1 {
0000000000000000000000000000000000000000;;			if !helper.IsStandardLimitRangeType(value) {
0000000000000000000000000000000000000000;;				return append(allErrs, field.Invalid(fldPath, value, "must be a standard limit type or fully qualified"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate limit range resource name
0000000000000000000000000000000000000000;;	// limit types (other than Pod/Container) could contain storage not just cpu or memory
0000000000000000000000000000000000000000;;	func validateLimitRangeResourceName(limitType api.LimitType, value string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		switch limitType {
0000000000000000000000000000000000000000;;		case api.LimitTypePod, api.LimitTypeContainer:
0000000000000000000000000000000000000000;;			return validateContainerResourceName(value, fldPath)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return validateResourceName(value, fldPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateLimitRange tests if required fields in the LimitRange are set.
0000000000000000000000000000000000000000;;	func ValidateLimitRange(limitRange *api.LimitRange) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&limitRange.ObjectMeta, true, ValidateLimitRangeName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure resource names are properly qualified per docs/design/resources.md
0000000000000000000000000000000000000000;;		limitTypeSet := map[api.LimitType]bool{}
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("spec", "limits")
0000000000000000000000000000000000000000;;		for i := range limitRange.Spec.Limits {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			limit := &limitRange.Spec.Limits[i]
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateLimitRangeTypeName(string(limit.Type), idxPath.Child("type"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, found := limitTypeSet[limit.Type]
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Duplicate(idxPath.Child("type"), limit.Type))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			limitTypeSet[limit.Type] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keys := sets.String{}
0000000000000000000000000000000000000000;;			min := map[string]resource.Quantity{}
0000000000000000000000000000000000000000;;			max := map[string]resource.Quantity{}
0000000000000000000000000000000000000000;;			defaults := map[string]resource.Quantity{}
0000000000000000000000000000000000000000;;			defaultRequests := map[string]resource.Quantity{}
0000000000000000000000000000000000000000;;			maxLimitRequestRatios := map[string]resource.Quantity{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, q := range limit.Max {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateLimitRangeResourceName(limit.Type, string(k), idxPath.Child("max").Key(string(k)))...)
0000000000000000000000000000000000000000;;				keys.Insert(string(k))
0000000000000000000000000000000000000000;;				max[string(k)] = q
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, q := range limit.Min {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateLimitRangeResourceName(limit.Type, string(k), idxPath.Child("min").Key(string(k)))...)
0000000000000000000000000000000000000000;;				keys.Insert(string(k))
0000000000000000000000000000000000000000;;				min[string(k)] = q
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if limit.Type == api.LimitTypePod {
0000000000000000000000000000000000000000;;				if len(limit.Default) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Forbidden(idxPath.Child("default"), "may not be specified when `type` is 'Pod'"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(limit.DefaultRequest) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Forbidden(idxPath.Child("defaultRequest"), "may not be specified when `type` is 'Pod'"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for k, q := range limit.Default {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, validateLimitRangeResourceName(limit.Type, string(k), idxPath.Child("default").Key(string(k)))...)
0000000000000000000000000000000000000000;;					keys.Insert(string(k))
0000000000000000000000000000000000000000;;					defaults[string(k)] = q
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, q := range limit.DefaultRequest {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, validateLimitRangeResourceName(limit.Type, string(k), idxPath.Child("defaultRequest").Key(string(k)))...)
0000000000000000000000000000000000000000;;					keys.Insert(string(k))
0000000000000000000000000000000000000000;;					defaultRequests[string(k)] = q
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if limit.Type == api.LimitTypePersistentVolumeClaim {
0000000000000000000000000000000000000000;;				_, minQuantityFound := limit.Min[api.ResourceStorage]
0000000000000000000000000000000000000000;;				_, maxQuantityFound := limit.Max[api.ResourceStorage]
0000000000000000000000000000000000000000;;				if !minQuantityFound && !maxQuantityFound {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Required(idxPath.Child("limits"), "either minimum or maximum storage value is required, but neither was provided"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, q := range limit.MaxLimitRequestRatio {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateLimitRangeResourceName(limit.Type, string(k), idxPath.Child("maxLimitRequestRatio").Key(string(k)))...)
0000000000000000000000000000000000000000;;				keys.Insert(string(k))
0000000000000000000000000000000000000000;;				maxLimitRequestRatios[string(k)] = q
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k := range keys {
0000000000000000000000000000000000000000;;				minQuantity, minQuantityFound := min[k]
0000000000000000000000000000000000000000;;				maxQuantity, maxQuantityFound := max[k]
0000000000000000000000000000000000000000;;				defaultQuantity, defaultQuantityFound := defaults[k]
0000000000000000000000000000000000000000;;				defaultRequestQuantity, defaultRequestQuantityFound := defaultRequests[k]
0000000000000000000000000000000000000000;;				maxRatio, maxRatioFound := maxLimitRequestRatios[k]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if minQuantityFound && maxQuantityFound && minQuantity.Cmp(maxQuantity) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("min").Key(string(k)), minQuantity, fmt.Sprintf("min value %s is greater than max value %s", minQuantity.String(), maxQuantity.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if defaultRequestQuantityFound && minQuantityFound && minQuantity.Cmp(defaultRequestQuantity) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("defaultRequest").Key(string(k)), defaultRequestQuantity, fmt.Sprintf("min value %s is greater than default request value %s", minQuantity.String(), defaultRequestQuantity.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if defaultRequestQuantityFound && maxQuantityFound && defaultRequestQuantity.Cmp(maxQuantity) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("defaultRequest").Key(string(k)), defaultRequestQuantity, fmt.Sprintf("default request value %s is greater than max value %s", defaultRequestQuantity.String(), maxQuantity.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if defaultRequestQuantityFound && defaultQuantityFound && defaultRequestQuantity.Cmp(defaultQuantity) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("defaultRequest").Key(string(k)), defaultRequestQuantity, fmt.Sprintf("default request value %s is greater than default limit value %s", defaultRequestQuantity.String(), defaultQuantity.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if defaultQuantityFound && minQuantityFound && minQuantity.Cmp(defaultQuantity) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("default").Key(string(k)), minQuantity, fmt.Sprintf("min value %s is greater than default value %s", minQuantity.String(), defaultQuantity.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if defaultQuantityFound && maxQuantityFound && defaultQuantity.Cmp(maxQuantity) > 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("default").Key(string(k)), maxQuantity, fmt.Sprintf("default value %s is greater than max value %s", defaultQuantity.String(), maxQuantity.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if maxRatioFound && maxRatio.Cmp(*resource.NewQuantity(1, resource.DecimalSI)) < 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("maxLimitRequestRatio").Key(string(k)), maxRatio, fmt.Sprintf("ratio %s is less than 1", maxRatio.String())))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if maxRatioFound && minQuantityFound && maxQuantityFound {
0000000000000000000000000000000000000000;;					maxRatioValue := float64(maxRatio.Value())
0000000000000000000000000000000000000000;;					minQuantityValue := minQuantity.Value()
0000000000000000000000000000000000000000;;					maxQuantityValue := maxQuantity.Value()
0000000000000000000000000000000000000000;;					if maxRatio.Value() < resource.MaxMilliValue && minQuantityValue < resource.MaxMilliValue && maxQuantityValue < resource.MaxMilliValue {
0000000000000000000000000000000000000000;;						maxRatioValue = float64(maxRatio.MilliValue()) / 1000
0000000000000000000000000000000000000000;;						minQuantityValue = minQuantity.MilliValue()
0000000000000000000000000000000000000000;;						maxQuantityValue = maxQuantity.MilliValue()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					maxRatioLimit := float64(maxQuantityValue) / float64(minQuantityValue)
0000000000000000000000000000000000000000;;					if maxRatioValue > maxRatioLimit {
0000000000000000000000000000000000000000;;						allErrs = append(allErrs, field.Invalid(idxPath.Child("maxLimitRequestRatio").Key(string(k)), maxRatio, fmt.Sprintf("ratio %s is greater than max/min = %f", maxRatio.String(), maxRatioLimit)))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceAccount tests if required fields in the ServiceAccount are set.
0000000000000000000000000000000000000000;;	func ValidateServiceAccount(serviceAccount *api.ServiceAccount) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&serviceAccount.ObjectMeta, true, ValidateServiceAccountName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceAccountUpdate tests if required fields in the ServiceAccount are set.
0000000000000000000000000000000000000000;;	func ValidateServiceAccountUpdate(newServiceAccount, oldServiceAccount *api.ServiceAccount) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newServiceAccount.ObjectMeta, &oldServiceAccount.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateServiceAccount(newServiceAccount)...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateSecret tests if required fields in the Secret are set.
0000000000000000000000000000000000000000;;	func ValidateSecret(secret *api.Secret) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&secret.ObjectMeta, true, ValidateSecretName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataPath := field.NewPath("data")
0000000000000000000000000000000000000000;;		totalSize := 0
0000000000000000000000000000000000000000;;		for key, value := range secret.Data {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsConfigMapKey(key) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(dataPath.Key(key), key, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			totalSize += len(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if totalSize > api.MaxSecretSize {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.TooLong(dataPath, "", api.MaxSecretSize))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch secret.Type {
0000000000000000000000000000000000000000;;		case api.SecretTypeServiceAccountToken:
0000000000000000000000000000000000000000;;			// Only require Annotations[kubernetes.io/service-account.name]
0000000000000000000000000000000000000000;;			// Additional fields (like Annotations[kubernetes.io/service-account.uid] and Data[token]) might be contributed later by a controller loop
0000000000000000000000000000000000000000;;			if value := secret.Annotations[api.ServiceAccountNameKey]; len(value) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(field.NewPath("metadata", "annotations").Key(api.ServiceAccountNameKey), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case api.SecretTypeOpaque, "":
0000000000000000000000000000000000000000;;		// no-op
0000000000000000000000000000000000000000;;		case api.SecretTypeDockercfg:
0000000000000000000000000000000000000000;;			dockercfgBytes, exists := secret.Data[api.DockerConfigKey]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(dataPath.Key(api.DockerConfigKey), ""))
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure that the content is well-formed json.
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(dockercfgBytes, &map[string]interface{}{}); err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(dataPath.Key(api.DockerConfigKey), "<secret contents redacted>", err.Error()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case api.SecretTypeDockerConfigJson:
0000000000000000000000000000000000000000;;			dockerConfigJsonBytes, exists := secret.Data[api.DockerConfigJsonKey]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(dataPath.Key(api.DockerConfigJsonKey), ""))
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure that the content is well-formed json.
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(dockerConfigJsonBytes, &map[string]interface{}{}); err != nil {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(dataPath.Key(api.DockerConfigJsonKey), "<secret contents redacted>", err.Error()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case api.SecretTypeBasicAuth:
0000000000000000000000000000000000000000;;			_, usernameFieldExists := secret.Data[api.BasicAuthUsernameKey]
0000000000000000000000000000000000000000;;			_, passwordFieldExists := secret.Data[api.BasicAuthPasswordKey]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// username or password might be empty, but the field must be present
0000000000000000000000000000000000000000;;			if !usernameFieldExists && !passwordFieldExists {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(field.NewPath("data[%s]").Key(api.BasicAuthUsernameKey), ""))
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(field.NewPath("data[%s]").Key(api.BasicAuthPasswordKey), ""))
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case api.SecretTypeSSHAuth:
0000000000000000000000000000000000000000;;			if len(secret.Data[api.SSHAuthPrivateKey]) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(field.NewPath("data[%s]").Key(api.SSHAuthPrivateKey), ""))
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case api.SecretTypeTLS:
0000000000000000000000000000000000000000;;			if _, exists := secret.Data[api.TLSCertKey]; !exists {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(dataPath.Key(api.TLSCertKey), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, exists := secret.Data[api.TLSPrivateKeyKey]; !exists {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(dataPath.Key(api.TLSPrivateKeyKey), ""))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		// TODO: Verify that the key matches the cert.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// no-op
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateSecretUpdate tests if required fields in the Secret are set.
0000000000000000000000000000000000000000;;	func ValidateSecretUpdate(newSecret, oldSecret *api.Secret) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newSecret.ObjectMeta, &oldSecret.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(newSecret.Type) == 0 {
0000000000000000000000000000000000000000;;			newSecret.Type = oldSecret.Type
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateImmutableField(newSecret.Type, oldSecret.Type, field.NewPath("type"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateSecret(newSecret)...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateConfigMapName can be used to check whether the given ConfigMap name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateConfigMapName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateConfigMap tests whether required fields in the ConfigMap are set.
0000000000000000000000000000000000000000;;	func ValidateConfigMap(cfg *api.ConfigMap) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateObjectMeta(&cfg.ObjectMeta, true, ValidateConfigMapName, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		totalSize := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range cfg.Data {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsConfigMapKey(key) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("data").Key(key), key, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			totalSize += len(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if totalSize > api.MaxSecretSize {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.TooLong(field.NewPath("data"), "", api.MaxSecretSize))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateConfigMapUpdate tests if required fields in the ConfigMap are set.
0000000000000000000000000000000000000000;;	func ValidateConfigMapUpdate(newCfg, oldCfg *api.ConfigMap) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateObjectMetaUpdate(&newCfg.ObjectMeta, &oldCfg.ObjectMeta, field.NewPath("metadata"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateConfigMap(newCfg)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateBasicResource(quantity resource.Quantity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		if quantity.Value() < 0 {
0000000000000000000000000000000000000000;;			return field.ErrorList{field.Invalid(fldPath, quantity.Value(), "must be a valid resource quantity")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return field.ErrorList{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates resource requirement spec.
0000000000000000000000000000000000000000;;	func ValidateResourceRequirements(requirements *api.ResourceRequirements, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		limPath := fldPath.Child("limits")
0000000000000000000000000000000000000000;;		reqPath := fldPath.Child("requests")
0000000000000000000000000000000000000000;;		for resourceName, quantity := range requirements.Limits {
0000000000000000000000000000000000000000;;			fldPath := limPath.Key(string(resourceName))
0000000000000000000000000000000000000000;;			// Validate resource name.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainerResourceName(string(resourceName), fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Validate resource quantity.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(resourceName), quantity, fldPath)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that request <= limit.
0000000000000000000000000000000000000000;;			requestQuantity, exists := requirements.Requests[resourceName]
0000000000000000000000000000000000000000;;			if exists {
0000000000000000000000000000000000000000;;				// For GPUs, not only requests can't exceed limits, they also can't be lower, i.e. must be equal.
0000000000000000000000000000000000000000;;				if resourceName == api.ResourceNvidiaGPU && quantity.Cmp(requestQuantity) != 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(reqPath, requestQuantity.String(), fmt.Sprintf("must be equal to %s limit", api.ResourceNvidiaGPU)))
0000000000000000000000000000000000000000;;				} else if quantity.Cmp(requestQuantity) < 0 {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(limPath, quantity.String(), fmt.Sprintf("must be greater than or equal to %s request", resourceName)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resourceName == api.ResourceStorageOverlay && !utilfeature.DefaultFeatureGate.Enabled(features.LocalStorageCapacityIsolation) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(limPath, "ResourceStorageOverlay field disabled by feature-gate for ResourceRequirements"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for resourceName, quantity := range requirements.Requests {
0000000000000000000000000000000000000000;;			fldPath := reqPath.Key(string(resourceName))
0000000000000000000000000000000000000000;;			// Validate resource name.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateContainerResourceName(string(resourceName), fldPath)...)
0000000000000000000000000000000000000000;;			// Validate resource quantity.
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(resourceName), quantity, fldPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateResourceQuotaScopes ensures that each enumerated hard resource constraint is valid for set of scopes
0000000000000000000000000000000000000000;;	func validateResourceQuotaScopes(resourceQuotaSpec *api.ResourceQuotaSpec, fld *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(resourceQuotaSpec.Scopes) == 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hardLimits := sets.NewString()
0000000000000000000000000000000000000000;;		for k := range resourceQuotaSpec.Hard {
0000000000000000000000000000000000000000;;			hardLimits.Insert(string(k))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fldPath := fld.Child("scopes")
0000000000000000000000000000000000000000;;		scopeSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, scope := range resourceQuotaSpec.Scopes {
0000000000000000000000000000000000000000;;			if !helper.IsStandardResourceQuotaScope(string(scope)) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, resourceQuotaSpec.Scopes, "unsupported scope"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, k := range hardLimits.List() {
0000000000000000000000000000000000000000;;				if helper.IsStandardQuotaResourceName(k) && !helper.IsResourceQuotaScopeValidForResource(scope, k) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath, resourceQuotaSpec.Scopes, "unsupported scope applied to resource"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			scopeSet.Insert(string(scope))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		invalidScopePairs := []sets.String{
0000000000000000000000000000000000000000;;			sets.NewString(string(api.ResourceQuotaScopeBestEffort), string(api.ResourceQuotaScopeNotBestEffort)),
0000000000000000000000000000000000000000;;			sets.NewString(string(api.ResourceQuotaScopeTerminating), string(api.ResourceQuotaScopeNotTerminating)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, invalidScopePair := range invalidScopePairs {
0000000000000000000000000000000000000000;;			if scopeSet.HasAll(invalidScopePair.List()...) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, resourceQuotaSpec.Scopes, "conflicting scopes"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateResourceQuota tests if required fields in the ResourceQuota are set.
0000000000000000000000000000000000000000;;	func ValidateResourceQuota(resourceQuota *api.ResourceQuota) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&resourceQuota.ObjectMeta, true, ValidateResourceQuotaName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateResourceQuotaSpec(&resourceQuota.Spec, field.NewPath("spec"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateResourceQuotaStatus(&resourceQuota.Status, field.NewPath("status"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateResourceQuotaStatus(status *api.ResourceQuotaStatus, fld *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fldPath := fld.Child("hard")
0000000000000000000000000000000000000000;;		for k, v := range status.Hard {
0000000000000000000000000000000000000000;;			resPath := fldPath.Key(string(k))
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuotaResourceName(string(k), resPath)...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(k), v, resPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fldPath = fld.Child("used")
0000000000000000000000000000000000000000;;		for k, v := range status.Used {
0000000000000000000000000000000000000000;;			resPath := fldPath.Key(string(k))
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuotaResourceName(string(k), resPath)...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(k), v, resPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateResourceQuotaSpec(resourceQuotaSpec *api.ResourceQuotaSpec, fld *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fldPath := fld.Child("hard")
0000000000000000000000000000000000000000;;		for k, v := range resourceQuotaSpec.Hard {
0000000000000000000000000000000000000000;;			resPath := fldPath.Key(string(k))
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuotaResourceName(string(k), resPath)...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(k), v, resPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateResourceQuotaScopes(resourceQuotaSpec, fld)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateResourceQuantityValue enforces that specified quantity is valid for specified resource
0000000000000000000000000000000000000000;;	func ValidateResourceQuantityValue(resource string, value resource.Quantity, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeQuantity(value, fldPath)...)
0000000000000000000000000000000000000000;;		if helper.IsIntegerResourceName(resource) {
0000000000000000000000000000000000000000;;			if value.MilliValue()%int64(1000) != int64(0) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, value, isNotIntegerErrorMsg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateResourceQuotaUpdate tests to see if the update is legal for an end user to make.
0000000000000000000000000000000000000000;;	// newResourceQuota is updated with fields that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidateResourceQuotaUpdate(newResourceQuota, oldResourceQuota *api.ResourceQuota) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newResourceQuota.ObjectMeta, &oldResourceQuota.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateResourceQuotaSpec(&newResourceQuota.Spec, field.NewPath("spec"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure scopes cannot change, and that resources are still valid for scope
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("spec", "scopes")
0000000000000000000000000000000000000000;;		oldScopes := sets.NewString()
0000000000000000000000000000000000000000;;		newScopes := sets.NewString()
0000000000000000000000000000000000000000;;		for _, scope := range newResourceQuota.Spec.Scopes {
0000000000000000000000000000000000000000;;			newScopes.Insert(string(scope))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, scope := range oldResourceQuota.Spec.Scopes {
0000000000000000000000000000000000000000;;			oldScopes.Insert(string(scope))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !oldScopes.Equal(newScopes) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, newResourceQuota.Spec.Scopes, fieldImmutableErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newResourceQuota.Status = oldResourceQuota.Status
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateResourceQuotaStatusUpdate tests to see if the status update is legal for an end user to make.
0000000000000000000000000000000000000000;;	// newResourceQuota is updated with fields that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidateResourceQuotaStatusUpdate(newResourceQuota, oldResourceQuota *api.ResourceQuota) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newResourceQuota.ObjectMeta, &oldResourceQuota.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		if len(newResourceQuota.ResourceVersion) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(field.NewPath("resourceVersion"), ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("status", "hard")
0000000000000000000000000000000000000000;;		for k, v := range newResourceQuota.Status.Hard {
0000000000000000000000000000000000000000;;			resPath := fldPath.Key(string(k))
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuotaResourceName(string(k), resPath)...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(k), v, resPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fldPath = field.NewPath("status", "used")
0000000000000000000000000000000000000000;;		for k, v := range newResourceQuota.Status.Used {
0000000000000000000000000000000000000000;;			resPath := fldPath.Key(string(k))
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuotaResourceName(string(k), resPath)...)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateResourceQuantityValue(string(k), v, resPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newResourceQuota.Spec = oldResourceQuota.Spec
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNamespace tests if required fields are set.
0000000000000000000000000000000000000000;;	func ValidateNamespace(namespace *api.Namespace) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&namespace.ObjectMeta, false, ValidateNamespaceName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		for i := range namespace.Spec.Finalizers {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateFinalizerName(string(namespace.Spec.Finalizers[i]), field.NewPath("spec", "finalizers"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate finalizer names
0000000000000000000000000000000000000000;;	func validateFinalizerName(stringValue string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := genericvalidation.ValidateFinalizerName(stringValue, fldPath)
0000000000000000000000000000000000000000;;		for _, err := range validateKubeFinalizerName(stringValue, fldPath) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateKubeFinalizerName checks for "standard" names of legacy finalizer
0000000000000000000000000000000000000000;;	func validateKubeFinalizerName(stringValue string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if len(strings.Split(stringValue, "/")) == 1 {
0000000000000000000000000000000000000000;;			if !helper.IsStandardFinalizerName(stringValue) {
0000000000000000000000000000000000000000;;				return append(allErrs, field.Invalid(fldPath, stringValue, "name is neither a standard finalizer name nor is it fully qualified"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNamespaceUpdate tests to make sure a namespace update can be applied.
0000000000000000000000000000000000000000;;	// newNamespace is updated with fields that cannot be changed
0000000000000000000000000000000000000000;;	func ValidateNamespaceUpdate(newNamespace *api.Namespace, oldNamespace *api.Namespace) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newNamespace.ObjectMeta, &oldNamespace.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		newNamespace.Spec.Finalizers = oldNamespace.Spec.Finalizers
0000000000000000000000000000000000000000;;		newNamespace.Status = oldNamespace.Status
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNamespaceStatusUpdate tests to see if the update is legal for an end user to make. newNamespace is updated with fields
0000000000000000000000000000000000000000;;	// that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidateNamespaceStatusUpdate(newNamespace, oldNamespace *api.Namespace) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newNamespace.ObjectMeta, &oldNamespace.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		newNamespace.Spec = oldNamespace.Spec
0000000000000000000000000000000000000000;;		if newNamespace.DeletionTimestamp.IsZero() {
0000000000000000000000000000000000000000;;			if newNamespace.Status.Phase != api.NamespaceActive {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("status", "Phase"), newNamespace.Status.Phase, "may only be 'Active' if `deletionTimestamp` is empty"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if newNamespace.Status.Phase != api.NamespaceTerminating {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("status", "Phase"), newNamespace.Status.Phase, "may only be 'Terminating' if `deletionTimestamp` is not empty"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNamespaceFinalizeUpdate tests to see if the update is legal for an end user to make.
0000000000000000000000000000000000000000;;	// newNamespace is updated with fields that cannot be changed.
0000000000000000000000000000000000000000;;	func ValidateNamespaceFinalizeUpdate(newNamespace, oldNamespace *api.Namespace) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newNamespace.ObjectMeta, &oldNamespace.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fldPath := field.NewPath("spec", "finalizers")
0000000000000000000000000000000000000000;;		for i := range newNamespace.Spec.Finalizers {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateFinalizerName(string(newNamespace.Spec.Finalizers[i]), idxPath)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNamespace.Status = oldNamespace.Status
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Construct lookup map of old subset IPs to NodeNames.
0000000000000000000000000000000000000000;;	func updateEpAddrToNodeNameMap(ipToNodeName map[string]string, addresses []api.EndpointAddress) {
0000000000000000000000000000000000000000;;		for n := range addresses {
0000000000000000000000000000000000000000;;			if addresses[n].NodeName == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ipToNodeName[addresses[n].IP] = *addresses[n].NodeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a map across all subsets of IP -> NodeName
0000000000000000000000000000000000000000;;	func buildEndpointAddressNodeNameMap(subsets []api.EndpointSubset) map[string]string {
0000000000000000000000000000000000000000;;		ipToNodeName := make(map[string]string)
0000000000000000000000000000000000000000;;		for i := range subsets {
0000000000000000000000000000000000000000;;			updateEpAddrToNodeNameMap(ipToNodeName, subsets[i].Addresses)
0000000000000000000000000000000000000000;;			updateEpAddrToNodeNameMap(ipToNodeName, subsets[i].NotReadyAddresses)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ipToNodeName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEpAddrNodeNameTransition(addr *api.EndpointAddress, ipToNodeName map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		errList := field.ErrorList{}
0000000000000000000000000000000000000000;;		existingNodeName, found := ipToNodeName[addr.IP]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return errList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addr.NodeName == nil || *addr.NodeName == existingNodeName {
0000000000000000000000000000000000000000;;			return errList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// NodeName entry found for this endpoint IP, but user is attempting to change NodeName
0000000000000000000000000000000000000000;;		return append(errList, field.Forbidden(fldPath, fmt.Sprintf("Cannot change NodeName for %s to %s", addr.IP, *addr.NodeName)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateEndpoints tests if required fields are set.
0000000000000000000000000000000000000000;;	func ValidateEndpoints(endpoints *api.Endpoints) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMeta(&endpoints.ObjectMeta, true, ValidateEndpointsName, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateEndpointsSpecificAnnotations(endpoints.Annotations, field.NewPath("annotations"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateEndpointSubsets(endpoints.Subsets, []api.EndpointSubset{}, field.NewPath("subsets"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEndpointSubsets(subsets []api.EndpointSubset, oldSubsets []api.EndpointSubset, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		ipToNodeName := buildEndpointAddressNodeNameMap(oldSubsets)
0000000000000000000000000000000000000000;;		for i := range subsets {
0000000000000000000000000000000000000000;;			ss := &subsets[i]
0000000000000000000000000000000000000000;;			idxPath := fldPath.Index(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// EndpointSubsets must include endpoint address. For headless service, we allow its endpoints not to have ports.
0000000000000000000000000000000000000000;;			if len(ss.Addresses) == 0 && len(ss.NotReadyAddresses) == 0 {
0000000000000000000000000000000000000000;;				//TODO: consider adding a RequiredOneOf() error for this and similar cases
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(idxPath, "must specify `addresses` or `notReadyAddresses`"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for addr := range ss.Addresses {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateEndpointAddress(&ss.Addresses[addr], idxPath.Child("addresses").Index(addr), ipToNodeName)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for addr := range ss.NotReadyAddresses {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateEndpointAddress(&ss.NotReadyAddresses[addr], idxPath.Child("notReadyAddresses").Index(addr), ipToNodeName)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for port := range ss.Ports {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateEndpointPort(&ss.Ports[port], len(ss.Ports) > 1, idxPath.Child("ports").Index(port))...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEndpointAddress(address *api.EndpointAddress, fldPath *field.Path, ipToNodeName map[string]string) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsValidIP(address.IP) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("ip"), address.IP, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(address.Hostname) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(address.Hostname, fldPath.Child("hostname"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// During endpoint update, verify that NodeName is a DNS subdomain and transition rules allow the update
0000000000000000000000000000000000000000;;		if address.NodeName != nil {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateNodeName(*address.NodeName, false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("nodeName"), *address.NodeName, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateEpAddrNodeNameTransition(address, ipToNodeName, fldPath.Child("nodeName"))...)
0000000000000000000000000000000000000000;;		if len(allErrs) > 0 {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateNonSpecialIP(address.IP, fldPath.Child("ip"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateNonSpecialIP(ipAddress string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		// We disallow some IPs as endpoints or external-ips.  Specifically,
0000000000000000000000000000000000000000;;		// unspecified and loopback addresses are nonsensical and link-local
0000000000000000000000000000000000000000;;		// addresses tend to be used for node-centric purposes (e.g. metadata
0000000000000000000000000000000000000000;;		// service).
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		ip := net.ParseIP(ipAddress)
0000000000000000000000000000000000000000;;		if ip == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, ipAddress, "must be a valid IP address"))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip.IsUnspecified() {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, ipAddress, "may not be unspecified (0.0.0.0)"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip.IsLoopback() {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, ipAddress, "may not be in the loopback range (127.0.0.0/8)"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip.IsLinkLocalUnicast() {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, ipAddress, "may not be in the link-local range (169.254.0.0/16)"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip.IsLinkLocalMulticast() {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, ipAddress, "may not be in the link-local multicast range (224.0.0.0/24)"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEndpointPort(port *api.EndpointPort, requireName bool, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if requireName && len(port.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("name"), ""))
0000000000000000000000000000000000000000;;		} else if len(port.Name) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateDNS1123Label(port.Name, fldPath.Child("name"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsValidPortNum(int(port.Port)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("port"), port.Port, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(port.Protocol) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("protocol"), ""))
0000000000000000000000000000000000000000;;		} else if !supportedPortProtocols.Has(string(port.Protocol)) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.NotSupported(fldPath.Child("protocol"), port.Protocol, supportedPortProtocols.List()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateEndpointsUpdate tests to make sure an endpoints update can be applied.
0000000000000000000000000000000000000000;;	func ValidateEndpointsUpdate(newEndpoints, oldEndpoints *api.Endpoints) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := ValidateObjectMetaUpdate(&newEndpoints.ObjectMeta, &oldEndpoints.ObjectMeta, field.NewPath("metadata"))
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateEndpointSubsets(newEndpoints.Subsets, oldEndpoints.Subsets, field.NewPath("subsets"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateEndpointsSpecificAnnotations(newEndpoints.Annotations, field.NewPath("annotations"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateSecurityContext ensure the security context contains valid settings
0000000000000000000000000000000000000000;;	func ValidateSecurityContext(sc *api.SecurityContext, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		//this should only be true for testing since SecurityContext is defaulted by the api
0000000000000000000000000000000000000000;;		if sc == nil {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.Privileged != nil {
0000000000000000000000000000000000000000;;			if *sc.Privileged && !capabilities.Get().AllowPrivileged {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("privileged"), "disallowed by cluster policy"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.RunAsUser != nil {
0000000000000000000000000000000000000000;;			if *sc.RunAsUser < 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("runAsUser"), *sc.RunAsUser, isNegativeErrorMsg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidatePodLogOptions(opts *api.PodLogOptions) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if opts.TailLines != nil && *opts.TailLines < 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("tailLines"), *opts.TailLines, isNegativeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.LimitBytes != nil && *opts.LimitBytes < 1 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath("limitBytes"), *opts.LimitBytes, "must be greater than 0"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case opts.SinceSeconds != nil && opts.SinceTime != nil:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(field.NewPath(""), "at most one of `sinceTime` or `sinceSeconds` may be specified"))
0000000000000000000000000000000000000000;;		case opts.SinceSeconds != nil:
0000000000000000000000000000000000000000;;			if *opts.SinceSeconds < 1 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(field.NewPath("sinceSeconds"), *opts.SinceSeconds, "must be greater than 0"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateLoadBalancerStatus validates required fields on a LoadBalancerStatus
0000000000000000000000000000000000000000;;	func ValidateLoadBalancerStatus(status *api.LoadBalancerStatus, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for i, ingress := range status.Ingress {
0000000000000000000000000000000000000000;;			idxPath := fldPath.Child("ingress").Index(i)
0000000000000000000000000000000000000000;;			if len(ingress.IP) > 0 {
0000000000000000000000000000000000000000;;				if isIP := (net.ParseIP(ingress.IP) != nil); !isIP {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("ip"), ingress.IP, "must be a valid IP address"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ingress.Hostname) > 0 {
0000000000000000000000000000000000000000;;				for _, msg := range validation.IsDNS1123Subdomain(ingress.Hostname) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("hostname"), ingress.Hostname, msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isIP := (net.ParseIP(ingress.Hostname) != nil); isIP {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(idxPath.Child("hostname"), ingress.Hostname, "must be a DNS name, not an IP address"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sysctlIntersection(a []api.Sysctl, b []api.Sysctl) []string {
0000000000000000000000000000000000000000;;		lookup := make(map[string]struct{}, len(a))
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for i := range a {
0000000000000000000000000000000000000000;;			lookup[a[i].Name] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range b {
0000000000000000000000000000000000000000;;			if _, found := lookup[b[i].Name]; found {
0000000000000000000000000000000000000000;;				result = append(result, b[i].Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateStorageNodeAffinityAnnotation tests that the serialized TopologyConstraints in PersistentVolume.Annotations has valid data
0000000000000000000000000000000000000000;;	func validateStorageNodeAffinityAnnotation(annotations map[string]string, fldPath *field.Path) (bool, field.ErrorList) {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		na, err := helper.GetStorageNodeAffinityFromAnnotation(annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, api.AlphaStorageNodeAffinityAnnotation, err.Error()))
0000000000000000000000000000000000000000;;			return false, allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if na == nil {
0000000000000000000000000000000000000000;;			return false, allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !utilfeature.DefaultFeatureGate.Enabled(features.PersistentLocalVolumes) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fldPath, "Storage node affinity is disabled by feature-gate"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policySpecified := false
0000000000000000000000000000000000000000;;		if na.RequiredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateNodeSelector(na.RequiredDuringSchedulingIgnoredDuringExecution, fldPath.Child("requiredDuringSchedulingIgnoredDuringExecution"))...)
0000000000000000000000000000000000000000;;			policySpecified = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(na.PreferredDuringSchedulingIgnoredDuringExecution) > 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fldPath.Child("preferredDuringSchedulingIgnoredDuringExection"), "Storage node affinity does not support preferredDuringSchedulingIgnoredDuringExecution"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return policySpecified, allErrs
0000000000000000000000000000000000000000;;	}
