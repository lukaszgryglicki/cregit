0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
01391205aa48b912aed1bac581f7e55df1e0aade;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/apimachinery/pkg/api/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		k8syaml "k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		kapitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readPod(filename string) ([]byte, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile("testdata/" + api.Registry.GroupOrDie(api.GroupName).GroupVersion.Version + "/" + filename)
0000000000000000000000000000000000000000;;		return data, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readSwaggerFile() ([]byte, error) {
0000000000000000000000000000000000000000;;		return readSwaggerApiFile(testapi.Default)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readSwaggerApiFile(group testapi.TestGroup) ([]byte, error) {
0000000000000000000000000000000000000000;;		// TODO: Figure out a better way of finding these files
0000000000000000000000000000000000000000;;		var pathToSwaggerSpec string
0000000000000000000000000000000000000000;;		if group.GroupVersion().Group == "" {
0000000000000000000000000000000000000000;;			pathToSwaggerSpec = "../../../api/swagger-spec/" + group.GroupVersion().Version + ".json"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pathToSwaggerSpec = "../../../api/swagger-spec/" + group.GroupVersion().Group + "_" + group.GroupVersion().Version + ".json"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ioutil.ReadFile(pathToSwaggerSpec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mock delegating Schema.  Not a full fake impl.
0000000000000000000000000000000000000000;;	type Factory struct {
0000000000000000000000000000000000000000;;		defaultSchema    Schema
0000000000000000000000000000000000000000;;		extensionsSchema Schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Schema = &Factory{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Consider using a mocking library instead or fully fleshing this out into a fake impl and putting it in some
0000000000000000000000000000000000000000;;	// generally available location
0000000000000000000000000000000000000000;;	func (f *Factory) ValidateBytes(data []byte) error {
0000000000000000000000000000000000000000;;		var obj interface{}
0000000000000000000000000000000000000000;;		out, err := k8syaml.ToJSON(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data = out
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields, ok := obj.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error in unmarshaling data %s", string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Note: This only supports the 2 api versions we expect from the test it is currently supporting.
0000000000000000000000000000000000000000;;		groupVersion := fields["apiVersion"]
0000000000000000000000000000000000000000;;		switch groupVersion {
0000000000000000000000000000000000000000;;		case "v1":
0000000000000000000000000000000000000000;;			return f.defaultSchema.ValidateBytes(data)
0000000000000000000000000000000000000000;;		case "extensions/v1beta1":
0000000000000000000000000000000000000000;;			return f.extensionsSchema.ValidateBytes(data)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unsupported API version %s", groupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadSchemaForTest() (Schema, error) {
0000000000000000000000000000000000000000;;		data, err := readSwaggerFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewSwaggerSchemaFromBytes(data, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadSchemaForTestWithFactory(group testapi.TestGroup, factory Schema) (Schema, error) {
0000000000000000000000000000000000000000;;		data, err := readSwaggerApiFile(group)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewSwaggerSchemaFromBytes(data, factory)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFactory() (*Factory, error) {
0000000000000000000000000000000000000000;;		f := &Factory{}
0000000000000000000000000000000000000000;;		defaultSchema, err := loadSchemaForTestWithFactory(testapi.Default, f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.defaultSchema = defaultSchema
0000000000000000000000000000000000000000;;		extensionSchema, err := loadSchemaForTestWithFactory(testapi.Extensions, f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.extensionsSchema = extensionSchema
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoad(t *testing.T) {
0000000000000000000000000000000000000000;;		_, err := loadSchemaForTest()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to load: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateOk(t *testing.T) {
0000000000000000000000000000000000000000;;		schema, err := loadSchemaForTest()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to load: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			obj      runtime.Object
0000000000000000000000000000000000000000;;			typeName string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{obj: &api.Pod{}},
0000000000000000000000000000000000000000;;			{obj: &api.Service{}},
0000000000000000000000000000000000000000;;			{obj: &api.ReplicationController{}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seed := rand.Int63()
0000000000000000000000000000000000000000;;		apiObjectFuzzer := apitesting.FuzzerFor(kapitesting.FuzzerFuncs(t, api.Codecs), rand.NewSource(seed))
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			for _, test := range tests {
0000000000000000000000000000000000000000;;				testObj := test.obj
0000000000000000000000000000000000000000;;				apiObjectFuzzer.Fuzz(testObj)
0000000000000000000000000000000000000000;;				data, err := runtime.Encode(testapi.Default.Codec(), testObj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = schema.ValidateBytes(data)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateDifferentApiVersions(t *testing.T) {
0000000000000000000000000000000000000000;;		schema, err := loadSchemaForTest()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to load: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := &v1.Pod{}
0000000000000000000000000000000000000000;;		pod.APIVersion = "v1"
0000000000000000000000000000000000000000;;		pod.Kind = "Pod"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment := &v1beta1.Deployment{}
0000000000000000000000000000000000000000;;		deployment.APIVersion = "extensions/v1beta1"
0000000000000000000000000000000000000000;;		deployment.Kind = "Deployment"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list := &v1.List{}
0000000000000000000000000000000000000000;;		list.APIVersion = "v1"
0000000000000000000000000000000000000000;;		list.Kind = "List"
0000000000000000000000000000000000000000;;		list.Items = []runtime.RawExtension{{Object: pod}, {Object: deployment}}
0000000000000000000000000000000000000000;;		bytes, err := json.Marshal(list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = schema.ValidateBytes(bytes)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error(fmt.Errorf("Expected error when validating different api version and no delegate exists."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := NewFactory()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(fmt.Errorf("Failed to create Schema factory %v.", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = f.ValidateBytes(bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(fmt.Errorf("Failed to validate object with multiple ApiGroups: %v.", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInvalid(t *testing.T) {
0000000000000000000000000000000000000000;;		schema, err := loadSchemaForTest()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to load: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []string{
0000000000000000000000000000000000000000;;			"invalidPod1.json", // command is a string, instead of []string.
0000000000000000000000000000000000000000;;			"invalidPod2.json", // hostPort if of type string, instead of int.
0000000000000000000000000000000000000000;;			"invalidPod3.json", // volumes is not an array of objects.
0000000000000000000000000000000000000000;;			"invalidPod4.yaml", // string list with empty string.
0000000000000000000000000000000000000000;;			"invalidPod.yaml",  // command is a string, instead of []string.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			pod, err := readPod(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("could not read file: %s, err: %v", test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = schema.ValidateBytes(pod)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected non-error, err: %s for pod: %s", err, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValid(t *testing.T) {
0000000000000000000000000000000000000000;;		schema, err := loadSchemaForTest()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to load: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []string{
0000000000000000000000000000000000000000;;			"validPod.yaml",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			pod, err := readPod(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("could not read file: %s, err: %v", test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = schema.ValidateBytes(pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %s, for pod %s", err, pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVersionRegex(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			typeName string
0000000000000000000000000000000000000000;;			match    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				typeName: "v1.Binding",
0000000000000000000000000000000000000000;;				match:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				typeName: "v1beta1.Binding",
0000000000000000000000000000000000000000;;				match:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				typeName: "Binding",
0000000000000000000000000000000000000000;;				match:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			if versionRegexp.MatchString(test.typeName) && !test.match {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: expect %s not to match the regular expression", test.typeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !versionRegexp.MatchString(test.typeName) && test.match {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: expect %s to match the regular expression", test.typeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests that validation works fine when spec contains "type": "any" instead of "type": "object"
0000000000000000000000000000000000000000;;	// Ref: https://github.com/kubernetes/kubernetes/issues/24309
0000000000000000000000000000000000000000;;	func TestTypeAny(t *testing.T) {
0000000000000000000000000000000000000000;;		data, err := readSwaggerFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to read swagger file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Replace type: "any" in the spec by type: "object" and verify that the validation still passes.
0000000000000000000000000000000000000000;;		newData := strings.Replace(string(data), `"type": "object"`, `"type": "any"`, -1)
0000000000000000000000000000000000000000;;		schema, err := NewSwaggerSchemaFromBytes([]byte(newData), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to load: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []string{
0000000000000000000000000000000000000000;;			"validPod.yaml",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			podBytes, err := readPod(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("could not read file: %s, err: %v", test, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Verify that pod has at least one label (labels are type "any")
0000000000000000000000000000000000000000;;			var pod v1.Pod
0000000000000000000000000000000000000000;;			err = yaml.Unmarshal(podBytes, &pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("error in unmarshalling pod: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pod.Labels) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("invalid test input: the pod should have at least one label")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = schema.ValidateBytes(podBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %s, for pod %s", err, string(podBytes))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateDuplicateLabelsFailCases(t *testing.T) {
0000000000000000000000000000000000000000;;		strs := []string{
0000000000000000000000000000000000000000;;			`{
0000000000000000000000000000000000000000;;		"metadata": {
0000000000000000000000000000000000000000;;			"labels": {
0000000000000000000000000000000000000000;;				"foo": "bar",
0000000000000000000000000000000000000000;;				"foo": "baz"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}`,
0000000000000000000000000000000000000000;;			`{
0000000000000000000000000000000000000000;;		"metadata": {
0000000000000000000000000000000000000000;;			"annotations": {
0000000000000000000000000000000000000000;;				"foo": "bar",
0000000000000000000000000000000000000000;;				"foo": "baz"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}`,
0000000000000000000000000000000000000000;;			`{
0000000000000000000000000000000000000000;;		"metadata": {
0000000000000000000000000000000000000000;;			"labels": {
0000000000000000000000000000000000000000;;				"foo": "blah"
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"annotations": {
0000000000000000000000000000000000000000;;				"foo": "bar",
0000000000000000000000000000000000000000;;				"foo": "baz"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}`,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schema := NoDoubleKeySchema{}
0000000000000000000000000000000000000000;;		for _, str := range strs {
0000000000000000000000000000000000000000;;			err := schema.ValidateBytes([]byte(str))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected non-error %s", str)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateDuplicateLabelsPassCases(t *testing.T) {
0000000000000000000000000000000000000000;;		strs := []string{
0000000000000000000000000000000000000000;;			`{
0000000000000000000000000000000000000000;;		"metadata": {
0000000000000000000000000000000000000000;;			"labels": {
0000000000000000000000000000000000000000;;				"foo": "bar"
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"annotations": {
0000000000000000000000000000000000000000;;				"foo": "baz"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}`,
0000000000000000000000000000000000000000;;			`{
0000000000000000000000000000000000000000;;		"metadata": {}
0000000000000000000000000000000000000000;;	}`,
0000000000000000000000000000000000000000;;			`{
0000000000000000000000000000000000000000;;		"metadata": {
0000000000000000000000000000000000000000;;			"labels": {}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}`,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schema := NoDoubleKeySchema{}
0000000000000000000000000000000000000000;;		for _, str := range strs {
0000000000000000000000000000000000000000;;			err := schema.ValidateBytes([]byte(str))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v %s", err, str)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AlwaysInvalidSchema struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (AlwaysInvalidSchema) ValidateBytes([]byte) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("Always invalid!")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConjunctiveSchema(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			schemas    []Schema
0000000000000000000000000000000000000000;;			shouldPass bool
0000000000000000000000000000000000000000;;			name       string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				schemas:    []Schema{NullSchema{}, NullSchema{}},
0000000000000000000000000000000000000000;;				shouldPass: true,
0000000000000000000000000000000000000000;;				name:       "all pass",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				schemas:    []Schema{NullSchema{}, AlwaysInvalidSchema{}},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;				name:       "one fail",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				schemas:    []Schema{AlwaysInvalidSchema{}, AlwaysInvalidSchema{}},
0000000000000000000000000000000000000000;;				shouldPass: false,
0000000000000000000000000000000000000000;;				name:       "all fail",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				schemas:    []Schema{},
0000000000000000000000000000000000000000;;				shouldPass: true,
0000000000000000000000000000000000000000;;				name:       "empty",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			schema := ConjunctiveSchema(test.schemas)
0000000000000000000000000000000000000000;;			err := schema.ValidateBytes([]byte{})
0000000000000000000000000000000000000000;;			if err != nil && test.shouldPass {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error: %v in %s", err, test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && !test.shouldPass {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected non-error: %s", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
