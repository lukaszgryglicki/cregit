0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f2b94eec88350fc8ee57d021412e4198f7348794;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package install
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		internal "k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResourceVersioner(t *testing.T) {
0000000000000000000000000000000000000000;;		g, err := internal.Registry.Group(v1.GroupName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		intf, err := g.DefaultInterfacesFor(v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor := intf.MetadataAccessor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := internal.Pod{ObjectMeta: metav1.ObjectMeta{ResourceVersion: "10"}}
0000000000000000000000000000000000000000;;		version, err := accessor.ResourceVersion(&pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version != "10" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version %v", version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		podList := internal.PodList{ListMeta: metav1.ListMeta{ResourceVersion: "10"}}
0000000000000000000000000000000000000000;;		version, err = accessor.ResourceVersion(&podList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version != "10" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version %v", version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCodec(t *testing.T) {
0000000000000000000000000000000000000000;;		pod := internal.Pod{}
0000000000000000000000000000000000000000;;		// We do want to use package registered rather than testapi here, because we
0000000000000000000000000000000000000000;;		// want to test if the package install and package registered work as expected.
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(internal.Codecs.LegacyCodec(internal.Registry.GroupOrDie(internal.GroupName).GroupVersion), &pod)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		other := internal.Pod{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &other); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if other.APIVersion != internal.Registry.GroupOrDie(internal.GroupName).GroupVersion.Version || other.Kind != "Pod" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected unmarshalled object %#v", other)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInterfacesFor(t *testing.T) {
0000000000000000000000000000000000000000;;		if _, err := internal.Registry.GroupOrDie(internal.GroupName).InterfacesFor(internal.SchemeGroupVersion); err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected non-error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, version := range internal.Registry.GroupOrDie(internal.GroupName).GroupVersions {
0000000000000000000000000000000000000000;;			if vi, err := internal.Registry.GroupOrDie(internal.GroupName).InterfacesFor(version); err != nil || vi == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unexpected result: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapper(t *testing.T) {
0000000000000000000000000000000000000000;;		gv := schema.GroupVersion{Group: "", Version: "v1"}
0000000000000000000000000000000000000000;;		rcGVK := gv.WithKind("ReplicationController")
0000000000000000000000000000000000000000;;		podTemplateGVK := gv.WithKind("PodTemplate")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gvk, err := internal.Registry.RESTMapper().KindFor(internal.SchemeGroupVersion.WithResource("replicationcontrollers")); err != nil || gvk != rcGVK {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version mapping: %v %v", gvk, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m, err := internal.Registry.GroupOrDie(internal.GroupName).RESTMapper.RESTMapping(podTemplateGVK.GroupKind(), ""); err != nil || m.GroupVersionKind != podTemplateGVK || m.Resource != "podtemplates" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected version mapping: %#v %v", m, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, version := range internal.Registry.GroupOrDie(internal.GroupName).GroupVersions {
0000000000000000000000000000000000000000;;			mapping, err := internal.Registry.GroupOrDie(internal.GroupName).RESTMapper.RESTMapping(rcGVK.GroupKind(), version.Version)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if mapping.Resource != "replicationControllers" && mapping.Resource != "replicationcontrollers" {
0000000000000000000000000000000000000000;;				t.Errorf("incorrect resource name: %#v", mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mapping.GroupVersionKind.GroupVersion() != version {
0000000000000000000000000000000000000000;;				t.Errorf("incorrect version: %v", mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			interfaces, _ := internal.Registry.GroupOrDie(internal.GroupName).InterfacesFor(version)
0000000000000000000000000000000000000000;;			if mapping.ObjectConvertor != interfaces.ObjectConvertor {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected: %#v, expected: %#v", mapping, interfaces)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rc := &internal.ReplicationController{ObjectMeta: metav1.ObjectMeta{Name: "foo"}}
0000000000000000000000000000000000000000;;			name, err := mapping.MetadataAccessor.Name(rc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if name != "foo" {
0000000000000000000000000000000000000000;;				t.Errorf("unable to retrieve object meta with: %v", mapping.MetadataAccessor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnversioned(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, obj := range []runtime.Object{
0000000000000000000000000000000000000000;;			&metav1.Status{},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			if unversioned, ok := internal.Scheme.IsUnversioned(obj); !unversioned || !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%v is expected to be unversioned", reflect.TypeOf(obj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
