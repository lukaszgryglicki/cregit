0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
4bfbd98ce6474205ebd59ab3028dce1cd914e325;pkg/api/resource/resource_helpers.go[pkg/api/resource/resource_helpers.go][pkg/api/resource/helpers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodRequestsAndLimits returns a dictionary of all defined resources summed up for all
0000000000000000000000000000000000000000;;	// containers of the pod.
0000000000000000000000000000000000000000;;	func PodRequestsAndLimits(pod *api.Pod) (reqs map[api.ResourceName]resource.Quantity, limits map[api.ResourceName]resource.Quantity, err error) {
0000000000000000000000000000000000000000;;		reqs, limits = map[api.ResourceName]resource.Quantity{}, map[api.ResourceName]resource.Quantity{}
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Requests {
0000000000000000000000000000000000000000;;				if value, ok := reqs[name]; !ok {
0000000000000000000000000000000000000000;;					reqs[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value.Add(quantity)
0000000000000000000000000000000000000000;;					reqs[name] = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Limits {
0000000000000000000000000000000000000000;;				if value, ok := limits[name]; !ok {
0000000000000000000000000000000000000000;;					limits[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value.Add(quantity)
0000000000000000000000000000000000000000;;					limits[name] = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// init containers define the minimum of any resource
0000000000000000000000000000000000000000;;		for _, container := range pod.Spec.InitContainers {
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Requests {
0000000000000000000000000000000000000000;;				value, ok := reqs[name]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					reqs[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quantity.Cmp(value) > 0 {
0000000000000000000000000000000000000000;;					reqs[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for name, quantity := range container.Resources.Limits {
0000000000000000000000000000000000000000;;				value, ok := limits[name]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					limits[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quantity.Cmp(value) > 0 {
0000000000000000000000000000000000000000;;					limits[name] = *quantity.Copy()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractContainerResourceValue extracts the value of a resource
0000000000000000000000000000000000000000;;	// in an already known container
0000000000000000000000000000000000000000;;	func ExtractContainerResourceValue(fs *api.ResourceFieldSelector, container *api.Container) (string, error) {
0000000000000000000000000000000000000000;;		divisor := resource.Quantity{}
0000000000000000000000000000000000000000;;		if divisor.Cmp(fs.Divisor) == 0 {
0000000000000000000000000000000000000000;;			divisor = resource.MustParse("1")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			divisor = fs.Divisor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch fs.Resource {
0000000000000000000000000000000000000000;;		case "limits.cpu":
0000000000000000000000000000000000000000;;			return convertResourceCPUToString(container.Resources.Limits.Cpu(), divisor)
0000000000000000000000000000000000000000;;		case "limits.memory":
0000000000000000000000000000000000000000;;			return convertResourceMemoryToString(container.Resources.Limits.Memory(), divisor)
0000000000000000000000000000000000000000;;		case "requests.cpu":
0000000000000000000000000000000000000000;;			return convertResourceCPUToString(container.Resources.Requests.Cpu(), divisor)
0000000000000000000000000000000000000000;;		case "requests.memory":
0000000000000000000000000000000000000000;;			return convertResourceMemoryToString(container.Resources.Requests.Memory(), divisor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("unsupported container resource : %v", fs.Resource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertResourceCPUToString converts cpu value to the format of divisor and returns
0000000000000000000000000000000000000000;;	// ceiling of the value.
0000000000000000000000000000000000000000;;	func convertResourceCPUToString(cpu *resource.Quantity, divisor resource.Quantity) (string, error) {
0000000000000000000000000000000000000000;;		c := int64(math.Ceil(float64(cpu.MilliValue()) / float64(divisor.MilliValue())))
0000000000000000000000000000000000000000;;		return strconv.FormatInt(c, 10), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertResourceMemoryToString converts memory value to the format of divisor and returns
0000000000000000000000000000000000000000;;	// ceiling of the value.
0000000000000000000000000000000000000000;;	func convertResourceMemoryToString(memory *resource.Quantity, divisor resource.Quantity) (string, error) {
0000000000000000000000000000000000000000;;		m := int64(math.Ceil(float64(memory.Value()) / float64(divisor.Value())))
0000000000000000000000000000000000000000;;		return strconv.FormatInt(m, 10), nil
0000000000000000000000000000000000000000;;	}
