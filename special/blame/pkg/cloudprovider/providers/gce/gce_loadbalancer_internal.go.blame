0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
a9c2f7b28ff7908be3bd6c902d9b2fdf3786462d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		v1_service "k8s.io/kubernetes/pkg/api/v1/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		allInstances = "ALL"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lbBalancingMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalLoadBalancer(clusterName, clusterID string, svc *v1.Service, existingFwdRule *compute.ForwardingRule, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		nm := types.NamespacedName{Name: svc.Name, Namespace: svc.Namespace}
0000000000000000000000000000000000000000;;		ports, protocol := getPortsAndProtocol(svc.Spec.Ports)
0000000000000000000000000000000000000000;;		scheme := schemeInternal
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(svc)
0000000000000000000000000000000000000000;;		sharedBackend := shareBackendService(svc)
0000000000000000000000000000000000000000;;		backendServiceName := makeBackendServiceName(loadBalancerName, clusterID, sharedBackend, scheme, protocol, svc.Spec.SessionAffinity)
0000000000000000000000000000000000000000;;		backendServiceLink := gce.getBackendServiceLink(backendServiceName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure instance groups exist and nodes are assigned to groups
0000000000000000000000000000000000000000;;		igName := makeInstanceGroupName(clusterID)
0000000000000000000000000000000000000000;;		igLinks, err := gce.ensureInternalInstanceGroups(igName, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get existing backend service (if exists)
0000000000000000000000000000000000000000;;		var existingBackendService *compute.BackendService
0000000000000000000000000000000000000000;;		if existingFwdRule != nil && existingFwdRule.BackendService != "" {
0000000000000000000000000000000000000000;;			existingBSName := getNameFromLink(existingFwdRule.BackendService)
0000000000000000000000000000000000000000;;			if existingBackendService, err = gce.GetRegionBackendService(existingBSName, gce.region); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lock the sharedResourceLock to prevent any deletions of shared resources while assembling shared resources here
0000000000000000000000000000000000000000;;		gce.sharedResourceLock.Lock()
0000000000000000000000000000000000000000;;		defer gce.sharedResourceLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure health check exists before creating the backend service. The health check is shared
0000000000000000000000000000000000000000;;		// if externalTrafficPolicy=Cluster.
0000000000000000000000000000000000000000;;		sharedHealthCheck := !v1_service.RequestsOnlyLocalTraffic(svc)
0000000000000000000000000000000000000000;;		hcName := makeHealthCheckName(loadBalancerName, clusterID, sharedHealthCheck)
0000000000000000000000000000000000000000;;		hcPath, hcPort := GetNodesHealthCheckPath(), GetNodesHealthCheckPort()
0000000000000000000000000000000000000000;;		if !sharedHealthCheck {
0000000000000000000000000000000000000000;;			// Service requires a special health check, retrieve the OnlyLocal port & path
0000000000000000000000000000000000000000;;			hcPath, hcPort = v1_service.GetServiceHealthCheckPathPort(svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hc, err := gce.ensureInternalHealthCheck(hcName, nm, sharedHealthCheck, hcPath, hcPort)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure firewall rules if necessary
0000000000000000000000000000000000000000;;		if gce.OnXPN() {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalLoadBalancer: cluster is on a cross-project network (XPN) network project %v, compute project %v - skipping firewall creation", gce.networkProjectID, gce.projectID)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err = gce.ensureInternalFirewalls(loadBalancerName, clusterID, nm, svc, strconv.Itoa(int(hcPort)), sharedHealthCheck, nodes); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedFwdRule := &compute.ForwardingRule{
0000000000000000000000000000000000000000;;			Name:                loadBalancerName,
0000000000000000000000000000000000000000;;			Description:         fmt.Sprintf(`{"kubernetes.io/service-name":"%s"}`, nm.String()),
0000000000000000000000000000000000000000;;			IPAddress:           svc.Spec.LoadBalancerIP,
0000000000000000000000000000000000000000;;			BackendService:      backendServiceLink,
0000000000000000000000000000000000000000;;			Ports:               ports,
0000000000000000000000000000000000000000;;			IPProtocol:          string(protocol),
0000000000000000000000000000000000000000;;			LoadBalancingScheme: string(scheme),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specify subnetwork if network type is manual
0000000000000000000000000000000000000000;;		if len(gce.subnetworkURL) > 0 {
0000000000000000000000000000000000000000;;			expectedFwdRule.Subnetwork = gce.subnetworkURL
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			expectedFwdRule.Network = gce.networkURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fwdRuleDeleted := false
0000000000000000000000000000000000000000;;		if existingFwdRule != nil && !fwdRuleEqual(existingFwdRule, expectedFwdRule) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalLoadBalancer(%v): deleting existing forwarding rule with IP address %v", loadBalancerName, existingFwdRule.IPAddress)
0000000000000000000000000000000000000000;;			if err = gce.DeleteRegionForwardingRule(loadBalancerName, gce.region); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fwdRuleDeleted = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bsDescription := makeBackendServiceDescription(nm, sharedBackend)
0000000000000000000000000000000000000000;;		err = gce.ensureInternalBackendService(backendServiceName, bsDescription, svc.Spec.SessionAffinity, scheme, protocol, igLinks, hc.SelfLink)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we previously deleted the forwarding rule or it never existed, finally create it.
0000000000000000000000000000000000000000;;		if fwdRuleDeleted || existingFwdRule == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalLoadBalancer(%v): creating forwarding rule", loadBalancerName)
0000000000000000000000000000000000000000;;			if err = gce.CreateRegionForwardingRule(expectedFwdRule, gce.region); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the previous internal load balancer resources if necessary
0000000000000000000000000000000000000000;;		if existingBackendService != nil {
0000000000000000000000000000000000000000;;			gce.clearPreviousInternalResources(loadBalancerName, existingBackendService, backendServiceName, hcName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the most recent forwarding rule for the new address.
0000000000000000000000000000000000000000;;		existingFwdRule, err = gce.GetRegionForwardingRule(loadBalancerName, gce.region)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		status.Ingress = []v1.LoadBalancerIngress{{IP: existingFwdRule.IPAddress}}
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) clearPreviousInternalResources(loadBalancerName string, existingBackendService *compute.BackendService, expectedBSName, expectedHCName string) {
0000000000000000000000000000000000000000;;		// If a new backend service was created, delete the old one.
0000000000000000000000000000000000000000;;		if existingBackendService.Name != expectedBSName {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("clearPreviousInternalResources(%v): expected backend service %q does not match previous %q - deleting backend service", loadBalancerName, expectedBSName, existingBackendService.Name)
0000000000000000000000000000000000000000;;			if err := gce.teardownInternalBackendService(existingBackendService.Name); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				glog.Warningf("clearPreviousInternalResources: could not delete old backend service: %v, err: %v", existingBackendService.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If a new health check was created, delete the old one.
0000000000000000000000000000000000000000;;		if len(existingBackendService.HealthChecks) == 1 {
0000000000000000000000000000000000000000;;			existingHCName := getNameFromLink(existingBackendService.HealthChecks[0])
0000000000000000000000000000000000000000;;			if existingHCName != expectedHCName {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("clearPreviousInternalResources(%v): expected health check %q does not match previous %q - deleting health check", loadBalancerName, expectedHCName, existingHCName)
0000000000000000000000000000000000000000;;				if err := gce.teardownInternalHealthCheckAndFirewall(existingHCName); err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("clearPreviousInternalResources: could not delete existing healthcheck: %v, err: %v", existingHCName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if len(existingBackendService.HealthChecks) > 1 {
0000000000000000000000000000000000000000;;			glog.Warningf("clearPreviousInternalResources(%v): more than one health check on the backend service %v, %v", loadBalancerName, existingBackendService.Name, existingBackendService.HealthChecks)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateInternalLoadBalancer is called when the list of nodes has changed. Therefore, only the instance groups
0000000000000000000000000000000000000000;;	// and possibly the backend service need to be updated.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) updateInternalLoadBalancer(clusterName, clusterID string, svc *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		gce.sharedResourceLock.Lock()
0000000000000000000000000000000000000000;;		defer gce.sharedResourceLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		igName := makeInstanceGroupName(clusterID)
0000000000000000000000000000000000000000;;		igLinks, err := gce.ensureInternalInstanceGroups(igName, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the backend service name
0000000000000000000000000000000000000000;;		_, protocol := getPortsAndProtocol(svc.Spec.Ports)
0000000000000000000000000000000000000000;;		scheme := schemeInternal
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(svc)
0000000000000000000000000000000000000000;;		backendServiceName := makeBackendServiceName(loadBalancerName, clusterID, shareBackendService(svc), scheme, protocol, svc.Spec.SessionAffinity)
0000000000000000000000000000000000000000;;		// Ensure the backend service has the proper backend/instance-group links
0000000000000000000000000000000000000000;;		return gce.ensureInternalBackendServiceGroups(backendServiceName, igLinks)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalLoadBalancerDeleted(clusterName, clusterID string, svc *v1.Service) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(svc)
0000000000000000000000000000000000000000;;		_, protocol := getPortsAndProtocol(svc.Spec.Ports)
0000000000000000000000000000000000000000;;		scheme := schemeInternal
0000000000000000000000000000000000000000;;		sharedBackend := shareBackendService(svc)
0000000000000000000000000000000000000000;;		sharedHealthCheck := !v1_service.RequestsOnlyLocalTraffic(svc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce.sharedResourceLock.Lock()
0000000000000000000000000000000000000000;;		defer gce.sharedResourceLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalLoadBalancerDeleted(%v): deleting region internal forwarding rule", loadBalancerName)
0000000000000000000000000000000000000000;;		if err := gce.DeleteRegionForwardingRule(loadBalancerName, gce.region); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backendServiceName := makeBackendServiceName(loadBalancerName, clusterID, sharedBackend, scheme, protocol, svc.Spec.SessionAffinity)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalLoadBalancerDeleted(%v): deleting region backend service %v", loadBalancerName, backendServiceName)
0000000000000000000000000000000000000000;;		if err := gce.teardownInternalBackendService(backendServiceName); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalLoadBalancerDeleted(%v): deleting firewall for traffic", loadBalancerName)
0000000000000000000000000000000000000000;;		if err := gce.DeleteFirewall(loadBalancerName); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hcName := makeHealthCheckName(loadBalancerName, clusterID, sharedHealthCheck)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalLoadBalancerDeleted(%v): deleting health check %v and its firewall", loadBalancerName, hcName)
0000000000000000000000000000000000000000;;		if err := gce.teardownInternalHealthCheckAndFirewall(hcName); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try deleting instance groups - expect ResourceInuse error if needed by other LBs
0000000000000000000000000000000000000000;;		igName := makeInstanceGroupName(clusterID)
0000000000000000000000000000000000000000;;		if err := gce.ensureInternalInstanceGroupsDeleted(igName); err != nil && !isInUsedByError(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) teardownInternalBackendService(bsName string) error {
0000000000000000000000000000000000000000;;		if err := gce.DeleteRegionBackendService(bsName, gce.region); err != nil {
0000000000000000000000000000000000000000;;			if isNotFound(err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("teardownInternalBackendService(%v): backend service already deleted. err: %v", bsName, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if isInUsedByError(err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("teardownInternalBackendService(%v): backend service in use.", bsName)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to delete backend service: %v, err: %v", bsName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("teardownInternalBackendService(%v): backend service deleted", bsName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) teardownInternalHealthCheckAndFirewall(hcName string) error {
0000000000000000000000000000000000000000;;		if err := gce.DeleteHealthCheck(hcName); err != nil {
0000000000000000000000000000000000000000;;			if isNotFound(err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("teardownInternalHealthCheckAndFirewall(%v): health check does not exist.", hcName)
0000000000000000000000000000000000000000;;				// Purposely do not early return - double check the firewall does not exist
0000000000000000000000000000000000000000;;			} else if isInUsedByError(err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("teardownInternalHealthCheckAndFirewall(%v): health check in use.", hcName)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to delete health check: %v, err: %v", hcName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("teardownInternalHealthCheckAndFirewall(%v): health check deleted", hcName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hcFirewallName := makeHealthCheckFirewallNameFromHC(hcName)
0000000000000000000000000000000000000000;;		if err := gce.DeleteFirewall(hcFirewallName); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to delete health check firewall: %v, err: %v", hcFirewallName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("teardownInternalHealthCheckAndFirewall(%v): health check firewall deleted", hcFirewallName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalFirewall(fwName, fwDesc string, sourceRanges []string, ports []string, protocol v1.Protocol, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalFirewall(%v): checking existing firewall", fwName)
0000000000000000000000000000000000000000;;		targetTags, err := gce.GetNodeTags(nodeNames(nodes))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingFirewall, err := gce.GetFirewall(fwName)
0000000000000000000000000000000000000000;;		if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedFirewall := &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         fwName,
0000000000000000000000000000000000000000;;			Description:  fwDesc,
0000000000000000000000000000000000000000;;			Network:      gce.networkURL,
0000000000000000000000000000000000000000;;			SourceRanges: sourceRanges,
0000000000000000000000000000000000000000;;			TargetTags:   targetTags,
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					IPProtocol: strings.ToLower(string(protocol)),
0000000000000000000000000000000000000000;;					Ports:      ports,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existingFirewall == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalFirewall(%v): creating firewall", fwName)
0000000000000000000000000000000000000000;;			return gce.CreateFirewall(expectedFirewall)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if firewallRuleEqual(expectedFirewall, existingFirewall) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalFirewall(%v): updating firewall", fwName)
0000000000000000000000000000000000000000;;		return gce.UpdateFirewall(expectedFirewall)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalFirewalls(loadBalancerName, clusterID string, nm types.NamespacedName, svc *v1.Service, healthCheckPort string, sharedHealthCheck bool, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		// First firewall is for ingress traffic
0000000000000000000000000000000000000000;;		fwDesc := makeFirewallDescription(nm.String(), svc.Spec.LoadBalancerIP)
0000000000000000000000000000000000000000;;		ports, protocol := getPortsAndProtocol(svc.Spec.Ports)
0000000000000000000000000000000000000000;;		sourceRanges, err := v1_service.GetLoadBalancerSourceRanges(svc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = gce.ensureInternalFirewall(loadBalancerName, fwDesc, sourceRanges.StringSlice(), ports, protocol, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Second firewall is for health checking nodes / services
0000000000000000000000000000000000000000;;		fwHCName := makeHealthCheckFirewallName(loadBalancerName, clusterID, sharedHealthCheck)
0000000000000000000000000000000000000000;;		hcSrcRanges := LoadBalancerSrcRanges()
0000000000000000000000000000000000000000;;		return gce.ensureInternalFirewall(fwHCName, "", hcSrcRanges, []string{healthCheckPort}, v1.ProtocolTCP, nodes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalHealthCheck(name string, svcName types.NamespacedName, shared bool, path string, port int32) (*compute.HealthCheck, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalHealthCheck(%v, %v, %v): checking existing health check", name, path, port)
0000000000000000000000000000000000000000;;		expectedHC := newInternalLBHealthCheck(name, svcName, shared, path, port)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hc, err := gce.GetHealthCheck(name)
0000000000000000000000000000000000000000;;		if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hc == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalHealthCheck: did not find health check %v, creating one with port %v path %v", name, port, path)
0000000000000000000000000000000000000000;;			if err = gce.CreateHealthCheck(expectedHC); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hc, err = gce.GetHealthCheck(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to get http health check %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalHealthCheck: created health check %v", name)
0000000000000000000000000000000000000000;;			return hc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if healthChecksEqual(expectedHC, hc) {
0000000000000000000000000000000000000000;;			return hc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalHealthCheck: health check %v exists but parameters have drifted - updating...", name)
0000000000000000000000000000000000000000;;		if err := gce.UpdateHealthCheck(expectedHC); err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to reconcile http health check %v parameters", name)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalHealthCheck: corrected health check %v parameters successful", name)
0000000000000000000000000000000000000000;;		return hc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalInstanceGroup(name, zone string, nodes []*v1.Node) (string, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalInstanceGroup(%v, %v): checking group that it contains %v nodes", name, zone, len(nodes))
0000000000000000000000000000000000000000;;		ig, err := gce.GetInstanceGroup(name, zone)
0000000000000000000000000000000000000000;;		if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeNodes := sets.NewString()
0000000000000000000000000000000000000000;;		for _, n := range nodes {
0000000000000000000000000000000000000000;;			kubeNodes.Insert(n.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gceNodes := sets.NewString()
0000000000000000000000000000000000000000;;		if ig == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalInstanceGroup(%v, %v): creating instance group", name, zone)
0000000000000000000000000000000000000000;;			ig, err = gce.CreateInstanceGroup(name, zone)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			instances, err := gce.ListInstancesInInstanceGroup(name, zone, allInstances)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, ins := range instances.Items {
0000000000000000000000000000000000000000;;				parts := strings.Split(ins.Instance, "/")
0000000000000000000000000000000000000000;;				gceNodes.Insert(parts[len(parts)-1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		removeNodes := gceNodes.Difference(kubeNodes).List()
0000000000000000000000000000000000000000;;		addNodes := kubeNodes.Difference(gceNodes).List()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(removeNodes) != 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalInstanceGroup(%v, %v): removing nodes: %v", name, zone, removeNodes)
0000000000000000000000000000000000000000;;			instanceRefs := gce.ToInstanceReferences(zone, removeNodes)
0000000000000000000000000000000000000000;;			// Possible we'll receive 404's here if the instance was deleted before getting to this point.
0000000000000000000000000000000000000000;;			if err = gce.RemoveInstancesFromInstanceGroup(name, zone, instanceRefs); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(addNodes) != 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalInstanceGroup(%v, %v): adding nodes: %v", name, zone, addNodes)
0000000000000000000000000000000000000000;;			instanceRefs := gce.ToInstanceReferences(zone, addNodes)
0000000000000000000000000000000000000000;;			if err = gce.AddInstancesToInstanceGroup(name, zone, instanceRefs); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ig.SelfLink, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureInternalInstanceGroups generates an unmanaged instance group for every zone
0000000000000000000000000000000000000000;;	// where a K8s node exists. It also ensures that each node belongs to an instance group
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalInstanceGroups(name string, nodes []*v1.Node) ([]string, error) {
0000000000000000000000000000000000000000;;		zonedNodes := splitNodesByZone(nodes)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalInstanceGroups(%v): %d nodes over %d zones in region %v", name, len(nodes), len(zonedNodes), gce.region)
0000000000000000000000000000000000000000;;		var igLinks []string
0000000000000000000000000000000000000000;;		for zone, nodes := range zonedNodes {
0000000000000000000000000000000000000000;;			igLink, err := gce.ensureInternalInstanceGroup(name, zone, nodes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []string{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			igLinks = append(igLinks, igLink)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return igLinks, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalInstanceGroupsDeleted(name string) error {
0000000000000000000000000000000000000000;;		// List of nodes isn't available here - fetch all zones in region and try deleting this cluster's ig
0000000000000000000000000000000000000000;;		zones, err := gce.ListZonesInRegion(gce.region)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalInstanceGroupsDeleted(%v): attempting delete instance group in all %d zones", name, len(zones))
0000000000000000000000000000000000000000;;		for _, z := range zones {
0000000000000000000000000000000000000000;;			if err := gce.DeleteInstanceGroup(name, z.Name); err != nil && !isNotFoundOrInUse(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalBackendService(name, description string, affinityType v1.ServiceAffinity, scheme lbScheme, protocol v1.Protocol, igLinks []string, hcLink string) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalBackendService(%v, %v, %v): checking existing backend service with %d groups", name, scheme, protocol, len(igLinks))
0000000000000000000000000000000000000000;;		bs, err := gce.GetRegionBackendService(name, gce.region)
0000000000000000000000000000000000000000;;		if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backends := backendsFromGroupLinks(igLinks)
0000000000000000000000000000000000000000;;		expectedBS := &compute.BackendService{
0000000000000000000000000000000000000000;;			Name:                name,
0000000000000000000000000000000000000000;;			Protocol:            string(protocol),
0000000000000000000000000000000000000000;;			Description:         description,
0000000000000000000000000000000000000000;;			HealthChecks:        []string{hcLink},
0000000000000000000000000000000000000000;;			Backends:            backends,
0000000000000000000000000000000000000000;;			SessionAffinity:     translateAffinityType(affinityType),
0000000000000000000000000000000000000000;;			LoadBalancingScheme: string(scheme),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create backend service if none was found
0000000000000000000000000000000000000000;;		if bs == nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalBackendService: creating backend service %v", name)
0000000000000000000000000000000000000000;;			err := gce.CreateRegionBackendService(expectedBS, gce.region)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensureInternalBackendService: created backend service %v successfully", name)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check existing backend service
0000000000000000000000000000000000000000;;		existingIGLinks := sets.NewString()
0000000000000000000000000000000000000000;;		for _, be := range bs.Backends {
0000000000000000000000000000000000000000;;			existingIGLinks.Insert(be.Group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if backendSvcEqual(expectedBS, bs) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalBackendService: updating backend service %v", name)
0000000000000000000000000000000000000000;;		// Set fingerprint for optimistic locking
0000000000000000000000000000000000000000;;		expectedBS.Fingerprint = bs.Fingerprint
0000000000000000000000000000000000000000;;		if err := gce.UpdateRegionBackendService(expectedBS, gce.region); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalBackendService: updated backend service %v successfully", name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureInternalBackendServiceGroups updates backend services if their list of backend instance groups is incorrect.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureInternalBackendServiceGroups(name string, igLinks []string) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalBackendServiceGroups(%v): checking existing backend service's groups", name)
0000000000000000000000000000000000000000;;		bs, err := gce.GetRegionBackendService(name, gce.region)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backends := backendsFromGroupLinks(igLinks)
0000000000000000000000000000000000000000;;		if backendsListEqual(bs.Backends, backends) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalBackendServiceGroups: updating backend service %v", name)
0000000000000000000000000000000000000000;;		if err := gce.UpdateRegionBackendService(bs, gce.region); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensureInternalBackendServiceGroups: updated backend service %v successfully", name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shareBackendService(svc *v1.Service) bool {
0000000000000000000000000000000000000000;;		return GetLoadBalancerAnnotationBackendShare(svc) && !v1_service.RequestsOnlyLocalTraffic(svc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func backendsFromGroupLinks(igLinks []string) []*compute.Backend {
0000000000000000000000000000000000000000;;		var backends []*compute.Backend
0000000000000000000000000000000000000000;;		for _, igLink := range igLinks {
0000000000000000000000000000000000000000;;			backends = append(backends, &compute.Backend{
0000000000000000000000000000000000000000;;				Group: igLink,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return backends
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInternalLBHealthCheck(name string, svcName types.NamespacedName, shared bool, path string, port int32) *compute.HealthCheck {
0000000000000000000000000000000000000000;;		httpSettings := compute.HTTPHealthCheck{
0000000000000000000000000000000000000000;;			Port:        int64(port),
0000000000000000000000000000000000000000;;			RequestPath: path,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desc := ""
0000000000000000000000000000000000000000;;		if !shared {
0000000000000000000000000000000000000000;;			desc = makeHealthCheckDescription(svcName.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &compute.HealthCheck{
0000000000000000000000000000000000000000;;			Name:               name,
0000000000000000000000000000000000000000;;			CheckIntervalSec:   gceHcCheckIntervalSeconds,
0000000000000000000000000000000000000000;;			TimeoutSec:         gceHcTimeoutSeconds,
0000000000000000000000000000000000000000;;			HealthyThreshold:   gceHcHealthyThreshold,
0000000000000000000000000000000000000000;;			UnhealthyThreshold: gceHcUnhealthyThreshold,
0000000000000000000000000000000000000000;;			HttpHealthCheck:    &httpSettings,
0000000000000000000000000000000000000000;;			Type:               "HTTP",
0000000000000000000000000000000000000000;;			Description:        desc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func firewallRuleEqual(a, b *compute.Firewall) bool {
0000000000000000000000000000000000000000;;		return a.Description == b.Description &&
0000000000000000000000000000000000000000;;			len(a.Allowed) == 1 && len(a.Allowed) == len(b.Allowed) &&
0000000000000000000000000000000000000000;;			a.Allowed[0].IPProtocol == b.Allowed[0].IPProtocol &&
0000000000000000000000000000000000000000;;			equalStringSets(a.Allowed[0].Ports, b.Allowed[0].Ports) &&
0000000000000000000000000000000000000000;;			equalStringSets(a.SourceRanges, b.SourceRanges) &&
0000000000000000000000000000000000000000;;			equalStringSets(a.TargetTags, b.TargetTags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func healthChecksEqual(a, b *compute.HealthCheck) bool {
0000000000000000000000000000000000000000;;		return a.HttpHealthCheck != nil && b.HttpHealthCheck != nil &&
0000000000000000000000000000000000000000;;			a.HttpHealthCheck.Port == b.HttpHealthCheck.Port &&
0000000000000000000000000000000000000000;;			a.HttpHealthCheck.RequestPath == b.HttpHealthCheck.RequestPath &&
0000000000000000000000000000000000000000;;			a.Description == b.Description &&
0000000000000000000000000000000000000000;;			a.CheckIntervalSec == b.CheckIntervalSec &&
0000000000000000000000000000000000000000;;			a.TimeoutSec == b.TimeoutSec &&
0000000000000000000000000000000000000000;;			a.UnhealthyThreshold == b.UnhealthyThreshold &&
0000000000000000000000000000000000000000;;			a.HealthyThreshold == b.HealthyThreshold
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// backendsListEqual asserts that backend lists are equal by instance group link only
0000000000000000000000000000000000000000;;	func backendsListEqual(a, b []*compute.Backend) bool {
0000000000000000000000000000000000000000;;		if len(a) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(a) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, v := range a {
0000000000000000000000000000000000000000;;			aSet.Insert(v.Group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bSet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, v := range b {
0000000000000000000000000000000000000000;;			bSet.Insert(v.Group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return aSet.Equal(bSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func backendSvcEqual(a, b *compute.BackendService) bool {
0000000000000000000000000000000000000000;;		return a.Protocol == b.Protocol &&
0000000000000000000000000000000000000000;;			a.Description == b.Description &&
0000000000000000000000000000000000000000;;			a.SessionAffinity == b.SessionAffinity &&
0000000000000000000000000000000000000000;;			a.LoadBalancingScheme == b.LoadBalancingScheme &&
0000000000000000000000000000000000000000;;			equalStringSets(a.HealthChecks, b.HealthChecks) &&
0000000000000000000000000000000000000000;;			backendsListEqual(a.Backends, b.Backends)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fwdRuleEqual(a, b *compute.ForwardingRule) bool {
0000000000000000000000000000000000000000;;		return (a.IPAddress == "" || b.IPAddress == "" || a.IPAddress == b.IPAddress) &&
0000000000000000000000000000000000000000;;			a.IPProtocol == b.IPProtocol &&
0000000000000000000000000000000000000000;;			a.LoadBalancingScheme == b.LoadBalancingScheme &&
0000000000000000000000000000000000000000;;			equalStringSets(a.Ports, b.Ports) &&
0000000000000000000000000000000000000000;;			a.BackendService == b.BackendService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPortsAndProtocol(svcPorts []v1.ServicePort) (ports []string, protocol v1.Protocol) {
0000000000000000000000000000000000000000;;		if len(svcPorts) == 0 {
0000000000000000000000000000000000000000;;			return []string{}, v1.ProtocolUDP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GCP doesn't support multiple protocols for a single load balancer
0000000000000000000000000000000000000000;;		protocol = svcPorts[0].Protocol
0000000000000000000000000000000000000000;;		for _, p := range svcPorts {
0000000000000000000000000000000000000000;;			ports = append(ports, strconv.Itoa(int(p.Port)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ports, protocol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) getBackendServiceLink(name string) string {
0000000000000000000000000000000000000000;;		return gce.service.BasePath + strings.Join([]string{gce.projectID, "regions", gce.region, "backendServices", name}, "/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNameFromLink(link string) string {
0000000000000000000000000000000000000000;;		if link == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fields := strings.Split(link, "/")
0000000000000000000000000000000000000000;;		return fields[len(fields)-1]
0000000000000000000000000000000000000000;;	}
