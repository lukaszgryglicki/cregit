0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9a3e3fac5acb000ea4977a0e92d5b6e96ddd1f63;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DiskType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DiskTypeSSD      = "pd-ssd"
0000000000000000000000000000000000000000;;		DiskTypeStandard = "pd-standard"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskTypeDefault     = DiskTypeStandard
0000000000000000000000000000000000000000;;		diskTypeUriTemplate = "%s/zones/%s/diskTypes/%s"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Disks is interface for manipulation with GCE PDs.
0000000000000000000000000000000000000000;;	type Disks interface {
0000000000000000000000000000000000000000;;		// AttachDisk attaches given disk to the node with the specified NodeName.
0000000000000000000000000000000000000000;;		// Current instance is used when instanceID is empty string.
0000000000000000000000000000000000000000;;		AttachDisk(diskName string, nodeName types.NodeName, readOnly bool) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DetachDisk detaches given disk to the node with the specified NodeName.
0000000000000000000000000000000000000000;;		// Current instance is used when nodeName is empty string.
0000000000000000000000000000000000000000;;		DetachDisk(devicePath string, nodeName types.NodeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DiskIsAttached checks if a disk is attached to the node with the specified NodeName.
0000000000000000000000000000000000000000;;		DiskIsAttached(diskName string, nodeName types.NodeName) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DisksAreAttached is a batch function to check if a list of disks are attached
0000000000000000000000000000000000000000;;		// to the node with the specified NodeName.
0000000000000000000000000000000000000000;;		DisksAreAttached(diskNames []string, nodeName types.NodeName) (map[string]bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreateDisk creates a new PD with given properties. Tags are serialized
0000000000000000000000000000000000000000;;		// as JSON into Description field.
0000000000000000000000000000000000000000;;		CreateDisk(name string, diskType string, zone string, sizeGb int64, tags map[string]string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteDisk deletes PD.
0000000000000000000000000000000000000000;;		DeleteDisk(diskToDelete string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetAutoLabelsForPD returns labels to apply to PersistentVolume
0000000000000000000000000000000000000000;;		// representing this PD, namely failure domain and zone.
0000000000000000000000000000000000000000;;		// zone can be provided to specify the zone for the PD,
0000000000000000000000000000000000000000;;		// if empty all managed zones will be searched.
0000000000000000000000000000000000000000;;		GetAutoLabelsForPD(name string, zone string) (map[string]string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GCECloud implements Disks.
0000000000000000000000000000000000000000;;	var _ Disks = (*GCECloud)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GCEDisk struct {
0000000000000000000000000000000000000000;;		Zone string
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Kind string
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDiskMetricContext(request, zone string) *metricContext {
0000000000000000000000000000000000000000;;		return &metricContext{
0000000000000000000000000000000000000000;;			start:      time.Now(),
0000000000000000000000000000000000000000;;			attributes: []string{"disk_" + request, unusedMetricLabel, zone},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) AttachDisk(diskName string, nodeName types.NodeName, readOnly bool) error {
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(nodeName)
0000000000000000000000000000000000000000;;		instance, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error getting instance %q", instanceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disk, err := gce.getDiskByName(diskName, instance.Zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readWrite := "READ_WRITE"
0000000000000000000000000000000000000000;;		if readOnly {
0000000000000000000000000000000000000000;;			readWrite = "READ_ONLY"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachedDisk := gce.convertDiskToAttachedDisk(disk, readWrite)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mc := newDiskMetricContext("attach", instance.Zone)
0000000000000000000000000000000000000000;;		attachOp, err := gce.service.Instances.AttachDisk(
0000000000000000000000000000000000000000;;			gce.projectID, disk.Zone, instance.Name, attachedDisk).Do()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return mc.Observe(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gce.waitForZoneOp(attachOp, disk.Zone, mc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) DetachDisk(devicePath string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(nodeName)
0000000000000000000000000000000000000000;;		inst, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == cloudprovider.InstanceNotFound {
0000000000000000000000000000000000000000;;				// If instance no longer exists, safe to assume volume is not attached.
0000000000000000000000000000000000000000;;				glog.Warningf(
0000000000000000000000000000000000000000;;					"Instance %q does not exist. DetachDisk will assume PD %q is not attached to it.",
0000000000000000000000000000000000000000;;					instanceName,
0000000000000000000000000000000000000000;;					devicePath)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Errorf("error getting instance %q", instanceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mc := newDiskMetricContext("detach", inst.Zone)
0000000000000000000000000000000000000000;;		detachOp, err := gce.service.Instances.DetachDisk(gce.projectID, inst.Zone, inst.Name, devicePath).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return mc.Observe(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gce.waitForZoneOp(detachOp, inst.Zone, mc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) DiskIsAttached(diskName string, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(nodeName)
0000000000000000000000000000000000000000;;		instance, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == cloudprovider.InstanceNotFound {
0000000000000000000000000000000000000000;;				// If instance no longer exists, safe to assume volume is not attached.
0000000000000000000000000000000000000000;;				glog.Warningf(
0000000000000000000000000000000000000000;;					"Instance %q does not exist. DiskIsAttached will assume PD %q is not attached to it.",
0000000000000000000000000000000000000000;;					instanceName,
0000000000000000000000000000000000000000;;					diskName)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, disk := range instance.Disks {
0000000000000000000000000000000000000000;;			if disk.DeviceName == diskName {
0000000000000000000000000000000000000000;;				// Disk is still attached to node
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) DisksAreAttached(diskNames []string, nodeName types.NodeName) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		attached := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, diskName := range diskNames {
0000000000000000000000000000000000000000;;			attached[diskName] = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(nodeName)
0000000000000000000000000000000000000000;;		instance, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == cloudprovider.InstanceNotFound {
0000000000000000000000000000000000000000;;				// If instance no longer exists, safe to assume volume is not attached.
0000000000000000000000000000000000000000;;				glog.Warningf(
0000000000000000000000000000000000000000;;					"Instance %q does not exist. DisksAreAttached will assume PD %v are not attached to it.",
0000000000000000000000000000000000000000;;					instanceName,
0000000000000000000000000000000000000000;;					diskNames)
0000000000000000000000000000000000000000;;				return attached, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return attached, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, instanceDisk := range instance.Disks {
0000000000000000000000000000000000000000;;			for _, diskName := range diskNames {
0000000000000000000000000000000000000000;;				if instanceDisk.DeviceName == diskName {
0000000000000000000000000000000000000000;;					// Disk is still attached to node
0000000000000000000000000000000000000000;;					attached[diskName] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attached, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateDisk creates a new Persistent Disk, with the specified name &
0000000000000000000000000000000000000000;;	// size, in the specified zone. It stores specified tags encoded in
0000000000000000000000000000000000000000;;	// JSON in Description field.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) CreateDisk(
0000000000000000000000000000000000000000;;		name string, diskType string, zone string, sizeGb int64, tags map[string]string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not allow creation of PDs in zones that are not managed. Such PDs
0000000000000000000000000000000000000000;;		// then cannot be deleted by DeleteDisk.
0000000000000000000000000000000000000000;;		isManaged := false
0000000000000000000000000000000000000000;;		for _, managedZone := range gce.managedZones {
0000000000000000000000000000000000000000;;			if zone == managedZone {
0000000000000000000000000000000000000000;;				isManaged = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isManaged {
0000000000000000000000000000000000000000;;			return fmt.Errorf("kubernetes does not manage zone %q", zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tagsStr, err := gce.encodeDiskTags(tags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch diskType {
0000000000000000000000000000000000000000;;		case DiskTypeSSD, DiskTypeStandard:
0000000000000000000000000000000000000000;;			// noop
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			diskType = diskTypeDefault
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid GCE disk type %q", diskType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		projectsApiEndpoint := gceComputeAPIEndpoint + "projects/"
0000000000000000000000000000000000000000;;		if gce.service != nil {
0000000000000000000000000000000000000000;;			projectsApiEndpoint = gce.service.BasePath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diskTypeUri := projectsApiEndpoint + fmt.Sprintf(diskTypeUriTemplate, gce.projectID, zone, diskType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskToCreate := &compute.Disk{
0000000000000000000000000000000000000000;;			Name:        name,
0000000000000000000000000000000000000000;;			SizeGb:      sizeGb,
0000000000000000000000000000000000000000;;			Description: tagsStr,
0000000000000000000000000000000000000000;;			Type:        diskTypeUri,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mc := newDiskMetricContext("create", zone)
0000000000000000000000000000000000000000;;		createOp, err := gce.manager.CreateDisk(gce.projectID, zone, diskToCreate)
0000000000000000000000000000000000000000;;		if isGCEError(err, "alreadyExists") {
0000000000000000000000000000000000000000;;			glog.Warningf("GCE PD %q already exists, reusing", name)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return mc.Observe(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = gce.manager.WaitForZoneOp(createOp, zone, mc)
0000000000000000000000000000000000000000;;		if isGCEError(err, "alreadyExists") {
0000000000000000000000000000000000000000;;			glog.Warningf("GCE PD %q already exists, reusing", name)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) DeleteDisk(diskToDelete string) error {
0000000000000000000000000000000000000000;;		err := gce.doDeleteDisk(diskToDelete)
0000000000000000000000000000000000000000;;		if isGCEError(err, "resourceInUseByAnotherResource") {
0000000000000000000000000000000000000000;;			return volume.NewDeletedVolumeInUseError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == cloudprovider.DiskNotFound {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Builds the labels that should be automatically added to a PersistentVolume backed by a GCE PD
0000000000000000000000000000000000000000;;	// Specifically, this builds FailureDomain (zone) and Region labels.
0000000000000000000000000000000000000000;;	// The PersistentVolumeLabel admission controller calls this and adds the labels when a PV is created.
0000000000000000000000000000000000000000;;	// If zone is specified, the volume will only be found in the specified zone,
0000000000000000000000000000000000000000;;	// otherwise all managed zones will be searched.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) GetAutoLabelsForPD(name string, zone string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		var disk *GCEDisk
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if zone == "" {
0000000000000000000000000000000000000000;;			// We would like as far as possible to avoid this case,
0000000000000000000000000000000000000000;;			// because GCE doesn't guarantee that volumes are uniquely named per region,
0000000000000000000000000000000000000000;;			// just per zone.  However, creation of GCE PDs was originally done only
0000000000000000000000000000000000000000;;			// by name, so we have to continue to support that.
0000000000000000000000000000000000000000;;			// However, wherever possible the zone should be passed (and it is passed
0000000000000000000000000000000000000000;;			// for most cases that we can control, e.g. dynamic volume provisioning)
0000000000000000000000000000000000000000;;			disk, err = gce.GetDiskByNameUnknownZone(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zone = disk.Zone
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We could assume the disks exists; we have all the information we need
0000000000000000000000000000000000000000;;			// However it is more consistent to ensure the disk exists,
0000000000000000000000000000000000000000;;			// and in future we may gather addition information (e.g. disk type, IOPS etc)
0000000000000000000000000000000000000000;;			disk, err = gce.getDiskByName(name, zone)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		region, err := GetGCERegion(zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if zone == "" || region == "" {
0000000000000000000000000000000000000000;;			// Unexpected, but sanity-check
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("PD did not have zone/region information: %q", disk.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		labels[kubeletapis.LabelZoneFailureDomain] = zone
0000000000000000000000000000000000000000;;		labels[kubeletapis.LabelZoneRegion] = region
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a GCEDisk for the disk, if it is found in the specified zone.
0000000000000000000000000000000000000000;;	// If not found, returns (nil, nil)
0000000000000000000000000000000000000000;;	func (gce *GCECloud) findDiskByName(diskName string, zone string) (*GCEDisk, error) {
0000000000000000000000000000000000000000;;		mc := newDiskMetricContext("get", zone)
0000000000000000000000000000000000000000;;		disk, err := gce.manager.GetDisk(gce.projectID, zone, diskName)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			d := &GCEDisk{
0000000000000000000000000000000000000000;;				Zone: lastComponent(disk.Zone),
0000000000000000000000000000000000000000;;				Name: disk.Name,
0000000000000000000000000000000000000000;;				Kind: disk.Kind,
0000000000000000000000000000000000000000;;				Type: disk.Type,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return d, mc.Observe(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;			return nil, mc.Observe(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, mc.Observe(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Like findDiskByName, but returns an error if the disk is not found
0000000000000000000000000000000000000000;;	func (gce *GCECloud) getDiskByName(diskName string, zone string) (*GCEDisk, error) {
0000000000000000000000000000000000000000;;		disk, err := gce.findDiskByName(diskName, zone)
0000000000000000000000000000000000000000;;		if disk == nil && err == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("GCE persistent disk not found: diskName=%q zone=%q", diskName, zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return disk, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scans all managed zones to return the GCE PD
0000000000000000000000000000000000000000;;	// Prefer getDiskByName, if the zone can be established
0000000000000000000000000000000000000000;;	// Return cloudprovider.DiskNotFound if the given disk cannot be found in any zone
0000000000000000000000000000000000000000;;	func (gce *GCECloud) GetDiskByNameUnknownZone(diskName string) (*GCEDisk, error) {
0000000000000000000000000000000000000000;;		// Note: this is the gotcha right now with GCE PD support:
0000000000000000000000000000000000000000;;		// disk names are not unique per-region.
0000000000000000000000000000000000000000;;		// (I can create two volumes with name "myvol" in e.g. us-central1-b & us-central1-f)
0000000000000000000000000000000000000000;;		// For now, this is simply undefined behvaiour.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// In future, we will have to require users to qualify their disk
0000000000000000000000000000000000000000;;		// "us-central1-a/mydisk".  We could do this for them as part of
0000000000000000000000000000000000000000;;		// admission control, but that might be a little weird (values changing
0000000000000000000000000000000000000000;;		// on create)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var found *GCEDisk
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			disk, err := gce.findDiskByName(diskName, zone)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// findDiskByName returns (nil,nil) if the disk doesn't exist, so we can't
0000000000000000000000000000000000000000;;			// assume that a disk was found unless disk is non-nil.
0000000000000000000000000000000000000000;;			if disk == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("GCE persistent disk name was found in multiple zones: %q", diskName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			found = disk
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if found != nil {
0000000000000000000000000000000000000000;;			return found, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Warningf("GCE persistent disk %q not found in managed zones (%s)",
0000000000000000000000000000000000000000;;			diskName, strings.Join(gce.managedZones, ","))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, cloudprovider.DiskNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeDiskTags encodes requested volume tags into JSON string, as GCE does
0000000000000000000000000000000000000000;;	// not support tags on GCE PDs and we use Description field as fallback.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) encodeDiskTags(tags map[string]string) (string, error) {
0000000000000000000000000000000000000000;;		if len(tags) == 0 {
0000000000000000000000000000000000000000;;			// No tags -> empty JSON
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enc, err := json.Marshal(tags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(enc), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) doDeleteDisk(diskToDelete string) error {
0000000000000000000000000000000000000000;;		disk, err := gce.GetDiskByNameUnknownZone(diskToDelete)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mc := newDiskMetricContext("delete", disk.Zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleteOp, err := gce.manager.DeleteDisk(gce.projectID, disk.Zone, disk.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return mc.Observe(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gce.manager.WaitForZoneOp(deleteOp, disk.Zone, mc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts a Disk resource to an AttachedDisk resource.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) convertDiskToAttachedDisk(disk *GCEDisk, readWrite string) *compute.AttachedDisk {
0000000000000000000000000000000000000000;;		return &compute.AttachedDisk{
0000000000000000000000000000000000000000;;			DeviceName: disk.Name,
0000000000000000000000000000000000000000;;			Kind:       disk.Kind,
0000000000000000000000000000000000000000;;			Mode:       readWrite,
0000000000000000000000000000000000000000;;			Source: gce.service.BasePath + strings.Join([]string{
0000000000000000000000000000000000000000;;				gce.projectID, "zones", disk.Zone, "disks", disk.Name}, "/"),
0000000000000000000000000000000000000000;;			Type: "PERSISTENT",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isGCEError returns true if given error is a googleapi.Error with given
0000000000000000000000000000000000000000;;	// reason (e.g. "resourceInUseByAnotherResource")
0000000000000000000000000000000000000000;;	func isGCEError(err error, reason string) bool {
0000000000000000000000000000000000000000;;		apiErr, ok := err.(*googleapi.Error)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, e := range apiErr.Errors {
0000000000000000000000000000000000000000;;			if e.Reason == reason {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
