0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
741a28ea282dea53937dd41c7e68b061848c9160;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateDisk_Basic(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		projectId := "test-project"
0000000000000000000000000000000000000000;;		gce := GCECloud{
0000000000000000000000000000000000000000;;			manager:      fakeManager,
0000000000000000000000000000000000000000;;			managedZones: []string{"zone1"},
0000000000000000000000000000000000000000;;			projectID:    projectId,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		zone := "zone1"
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;		tags := make(map[string]string)
0000000000000000000000000000000000000000;;		tags["test-tag"] = "test-value"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskTypeUri := gceComputeAPIEndpoint + "projects/" + fmt.Sprintf(diskTypeUriTemplate, projectId, zone, diskType)
0000000000000000000000000000000000000000;;		expectedDescription := "{\"test-tag\":\"test-value\"}"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.CreateDisk(diskName, diskType, zone, sizeGb, tags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.createDiskCalled {
0000000000000000000000000000000000000000;;			t.Error("Never called GCE disk create.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.doesOpMatch {
0000000000000000000000000000000000000000;;			t.Error("Ops used in WaitForZoneOp does not match what's returned by CreateDisk.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Partial check of equality between disk description sent to GCE and parameters of method.
0000000000000000000000000000000000000000;;		diskToCreate := fakeManager.diskToCreate
0000000000000000000000000000000000000000;;		if diskToCreate.Name != diskName {
0000000000000000000000000000000000000000;;			t.Errorf("Expected disk name: %s; Actual: %s", diskName, diskToCreate.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if diskToCreate.Type != diskTypeUri {
0000000000000000000000000000000000000000;;			t.Errorf("Expected disk type: %s; Actual: %s", diskTypeUri, diskToCreate.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if diskToCreate.SizeGb != sizeGb {
0000000000000000000000000000000000000000;;			t.Errorf("Expected disk size: %d; Actual: %d", sizeGb, diskToCreate.SizeGb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if diskToCreate.Description != expectedDescription {
0000000000000000000000000000000000000000;;			t.Errorf("Expected tag string: %s; Actual: %s", expectedDescription, diskToCreate.Description)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateDisk_DiskAlreadyExists(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inject disk AlreadyExists error.
0000000000000000000000000000000000000000;;		alreadyExistsError := googleapi.ErrorItem{Reason: "alreadyExists"}
0000000000000000000000000000000000000000;;		fakeManager.waitForZoneOpError = &googleapi.Error{
0000000000000000000000000000000000000000;;			Errors: []googleapi.ErrorItem{alreadyExistsError},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.CreateDisk("disk", DiskTypeSSD, "zone1", 128, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(
0000000000000000000000000000000000000000;;				"Expected success when a disk with the given name already exists, but an error is returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateDisk_WrongZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.CreateDisk(diskName, diskType, "zone2", sizeGb, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when zone is not managed, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateDisk_NoManagedZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.CreateDisk(diskName, diskType, "zone1", sizeGb, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when managedZones is empty, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateDisk_BadDiskType(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := "arbitrary-disk"
0000000000000000000000000000000000000000;;		zone := "zone1"
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when disk type is not supported, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateDisk_MultiZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1", "zone2", "zone3"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeStandard
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act & Assert */
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			diskName = zone + "disk"
0000000000000000000000000000000000000000;;			err := gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error creating disk in zone '%v'; error: \"%v\"", zone, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteDisk_Basic(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1"}}
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		zone := "zone1"
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.DeleteDisk(diskName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.deleteDiskCalled {
0000000000000000000000000000000000000000;;			t.Error("Never called GCE disk delete.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.doesOpMatch {
0000000000000000000000000000000000000000;;			t.Error("Ops used in WaitForZoneOp does not match what's returned by DeleteDisk.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteDisk_NotFound(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1"}}
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.DeleteDisk(diskName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error("Expected successful operation when disk is not found, but an error is returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteDisk_ResourceBeingUsed(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1"}}
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		zone := "zone1"
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;		fakeManager.resourceInUse = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		err := gce.DeleteDisk(diskName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when disk is in use, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteDisk_SameDiskMultiZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1", "zone2", "zone3"}}
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		// DeleteDisk will call FakeServiceManager.GetDisk() with all zones,
0000000000000000000000000000000000000000;;		// and FakeServiceManager.GetDisk() always returns a disk,
0000000000000000000000000000000000000000;;		// so DeleteDisk thinks a disk with diskName exists in all zones.
0000000000000000000000000000000000000000;;		err := gce.DeleteDisk(diskName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when disk is found in multiple zones, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleteDisk_DiffDiskMultiZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"zone1"}}
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			diskName = zone + "disk"
0000000000000000000000000000000000000000;;			gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act & Assert */
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			diskName = zone + "disk"
0000000000000000000000000000000000000000;;			err = gce.DeleteDisk(diskName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Error deleting disk in zone '%v'; error: \"%v\"", zone, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAutoLabelsForPD_Basic(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeSSD
0000000000000000000000000000000000000000;;		zone := "us-central1-c"
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{zone}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		labels, err := gce.GetAutoLabelsForPD(diskName, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels[kubeletapis.LabelZoneFailureDomain] != zone {
0000000000000000000000000000000000000000;;			t.Errorf("Failure domain is '%v', but zone is '%v'",
0000000000000000000000000000000000000000;;				labels[kubeletapis.LabelZoneFailureDomain], zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels[kubeletapis.LabelZoneRegion] != "us-central1" {
0000000000000000000000000000000000000000;;			t.Errorf("Region is '%v', but zone is 'us-central1'", labels[kubeletapis.LabelZoneRegion])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAutoLabelsForPD_NoZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeStandard
0000000000000000000000000000000000000000;;		zone := "europe-west1-d"
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{zone}}
0000000000000000000000000000000000000000;;		gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		labels, err := gce.GetAutoLabelsForPD(diskName, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels[kubeletapis.LabelZoneFailureDomain] != zone {
0000000000000000000000000000000000000000;;			t.Errorf("Failure domain is '%v', but zone is '%v'",
0000000000000000000000000000000000000000;;				labels[kubeletapis.LabelZoneFailureDomain], zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels[kubeletapis.LabelZoneRegion] != "europe-west1" {
0000000000000000000000000000000000000000;;			t.Errorf("Region is '%v', but zone is 'europe-west1'", labels[kubeletapis.LabelZoneRegion])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAutoLabelsForPD_DiskNotFound(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		zone := "asia-northeast1-a"
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{zone}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		_, err := gce.GetAutoLabelsForPD(diskName, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when the specified disk does not exist, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAutoLabelsForPD_DiskNotFoundAndNoZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		_, err := gce.GetAutoLabelsForPD(diskName, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when the specified disk does not exist, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAutoLabelsForPD_DupDisk(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeStandard
0000000000000000000000000000000000000000;;		zone := "us-west1-b"
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"us-west1-b", "asia-southeast1-a"}}
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		labels, err := gce.GetAutoLabelsForPD(diskName, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error("Disk name and zone uniquely identifies a disk, yet an error is returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels[kubeletapis.LabelZoneFailureDomain] != zone {
0000000000000000000000000000000000000000;;			t.Errorf("Failure domain is '%v', but zone is '%v'",
0000000000000000000000000000000000000000;;				labels[kubeletapis.LabelZoneFailureDomain], zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if labels[kubeletapis.LabelZoneRegion] != "us-west1" {
0000000000000000000000000000000000000000;;			t.Errorf("Region is '%v', but zone is 'us-west1'", labels[kubeletapis.LabelZoneRegion])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAutoLabelsForPD_DupDiskNoZone(t *testing.T) {
0000000000000000000000000000000000000000;;		/* Arrange */
0000000000000000000000000000000000000000;;		fakeManager := newFakeManager()
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		diskType := DiskTypeStandard
0000000000000000000000000000000000000000;;		const sizeGb int64 = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce := GCECloud{manager: fakeManager, managedZones: []string{"us-west1-b", "asia-southeast1-a"}}
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			gce.CreateDisk(diskName, diskType, zone, sizeGb, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Act */
0000000000000000000000000000000000000000;;		_, err := gce.GetAutoLabelsForPD(diskName, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Assert */
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expected error when the disk is duplicated and zone is not specified, but none returned.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeServiceManager struct {
0000000000000000000000000000000000000000;;		// Common fields shared among tests
0000000000000000000000000000000000000000;;		op                 *compute.Operation // Mocks an operation returned by GCE API calls
0000000000000000000000000000000000000000;;		doesOpMatch        bool
0000000000000000000000000000000000000000;;		disks              map[string]string // zone: diskName
0000000000000000000000000000000000000000;;		waitForZoneOpError error             // Error to be returned by WaitForZoneOp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fields for TestCreateDisk
0000000000000000000000000000000000000000;;		createDiskCalled bool
0000000000000000000000000000000000000000;;		diskToCreate     *compute.Disk
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fields for TestDeleteDisk
0000000000000000000000000000000000000000;;		deleteDiskCalled bool
0000000000000000000000000000000000000000;;		resourceInUse    bool // Marks the disk as in-use
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeManager() *FakeServiceManager {
0000000000000000000000000000000000000000;;		return &FakeServiceManager{disks: make(map[string]string)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/**
0000000000000000000000000000000000000000;;	 * Upon disk creation, disk info is stored in FakeServiceManager
0000000000000000000000000000000000000000;;	 * to be used by other tested methods.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func (manager *FakeServiceManager) CreateDisk(
0000000000000000000000000000000000000000;;		project string,
0000000000000000000000000000000000000000;;		zone string,
0000000000000000000000000000000000000000;;		disk *compute.Disk) (*compute.Operation, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manager.createDiskCalled = true
0000000000000000000000000000000000000000;;		op := &compute.Operation{}
0000000000000000000000000000000000000000;;		manager.op = op
0000000000000000000000000000000000000000;;		manager.diskToCreate = disk
0000000000000000000000000000000000000000;;		manager.disks[zone] = disk.Name
0000000000000000000000000000000000000000;;		return op, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/**
0000000000000000000000000000000000000000;;	 * Gets disk info stored in the FakeServiceManager.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func (manager *FakeServiceManager) GetDisk(
0000000000000000000000000000000000000000;;		project string,
0000000000000000000000000000000000000000;;		zone string,
0000000000000000000000000000000000000000;;		diskName string) (*compute.Disk, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if manager.disks[zone] == "" {
0000000000000000000000000000000000000000;;			return nil, cloudprovider.DiskNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if manager.resourceInUse {
0000000000000000000000000000000000000000;;			errorItem := googleapi.ErrorItem{Reason: "resourceInUseByAnotherResource"}
0000000000000000000000000000000000000000;;			err := &googleapi.Error{Errors: []googleapi.ErrorItem{errorItem}}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		disk := &compute.Disk{Name: diskName, Zone: zone, Kind: "compute#disk"}
0000000000000000000000000000000000000000;;		return disk, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/**
0000000000000000000000000000000000000000;;	 * Disk info is removed from the FakeServiceManager.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func (manager *FakeServiceManager) DeleteDisk(
0000000000000000000000000000000000000000;;		project string,
0000000000000000000000000000000000000000;;		zone string,
0000000000000000000000000000000000000000;;		disk string) (*compute.Operation, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manager.deleteDiskCalled = true
0000000000000000000000000000000000000000;;		op := &compute.Operation{}
0000000000000000000000000000000000000000;;		manager.op = op
0000000000000000000000000000000000000000;;		manager.disks[zone] = ""
0000000000000000000000000000000000000000;;		return op, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *FakeServiceManager) WaitForZoneOp(
0000000000000000000000000000000000000000;;		op *compute.Operation,
0000000000000000000000000000000000000000;;		zone string,
0000000000000000000000000000000000000000;;		mc *metricContext) error {
0000000000000000000000000000000000000000;;		if op == manager.op {
0000000000000000000000000000000000000000;;			manager.doesOpMatch = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return manager.waitForZoneOpError
0000000000000000000000000000000000000000;;	}
