0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0d84449fe2b09eaa0897d569b1856a57a376e69d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Key used to persist UIDs to configmaps.
0000000000000000000000000000000000000000;;		UIDConfigMapName = "ingress-uid"
0000000000000000000000000000000000000000;;		// Namespace which contains the above config map
0000000000000000000000000000000000000000;;		UIDNamespace = metav1.NamespaceSystem
0000000000000000000000000000000000000000;;		// Data keys for the specific ids
0000000000000000000000000000000000000000;;		UIDCluster     = "uid"
0000000000000000000000000000000000000000;;		UIDProvider    = "provider-uid"
0000000000000000000000000000000000000000;;		UIDLengthBytes = 8
0000000000000000000000000000000000000000;;		// Frequency of the updateFunc event handler being called
0000000000000000000000000000000000000000;;		// This does not actually query the apiserver for current state - the local cache value is used.
0000000000000000000000000000000000000000;;		updateFuncFrequency = 10 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterID struct {
0000000000000000000000000000000000000000;;		idLock     sync.RWMutex
0000000000000000000000000000000000000000;;		client     clientset.Interface
0000000000000000000000000000000000000000;;		cfgMapKey  string
0000000000000000000000000000000000000000;;		store      cache.Store
0000000000000000000000000000000000000000;;		providerID *string
0000000000000000000000000000000000000000;;		clusterID  *string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Continually watches for changes to the cluster id config map
0000000000000000000000000000000000000000;;	func (gce *GCECloud) watchClusterID() {
0000000000000000000000000000000000000000;;		gce.ClusterID = ClusterID{
0000000000000000000000000000000000000000;;			cfgMapKey: fmt.Sprintf("%v/%v", UIDNamespace, UIDConfigMapName),
0000000000000000000000000000000000000000;;			client:    gce.clientBuilder.ClientOrDie("cloud-provider"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapEventHandler := cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				m, ok := obj.(*v1.ConfigMap)
0000000000000000000000000000000000000000;;				if !ok || m == nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Expected v1.ConfigMap, item=%+v, typeIsOk=%v", obj, ok)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if m.Namespace != UIDNamespace ||
0000000000000000000000000000000000000000;;					m.Name != UIDConfigMapName {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Observed new configmap for clusteriD: %v, %v; setting local values", m.Name, m.Data)
0000000000000000000000000000000000000000;;				gce.ClusterID.update(m)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UpdateFunc: func(old, cur interface{}) {
0000000000000000000000000000000000000000;;				m, ok := cur.(*v1.ConfigMap)
0000000000000000000000000000000000000000;;				if !ok || m == nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Expected v1.ConfigMap, item=%+v, typeIsOk=%v", cur, ok)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if m.Namespace != UIDNamespace ||
0000000000000000000000000000000000000000;;					m.Name != UIDConfigMapName {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(old, cur) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Observed updated configmap for clusteriD %v, %v; setting local values", m.Name, m.Data)
0000000000000000000000000000000000000000;;				gce.ClusterID.update(m)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listerWatcher := cache.NewListWatchFromClient(gce.ClusterID.client.Core().RESTClient(), "configmaps", UIDNamespace, fields.Everything())
0000000000000000000000000000000000000000;;		var controller cache.Controller
0000000000000000000000000000000000000000;;		gce.ClusterID.store, controller = cache.NewInformer(newSingleObjectListerWatcher(listerWatcher, UIDConfigMapName), &v1.ConfigMap{}, updateFuncFrequency, mapEventHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller.Run(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetID returns the id which is unique to this cluster
0000000000000000000000000000000000000000;;	// if federated, return the provider id (unique to the cluster)
0000000000000000000000000000000000000000;;	// if not federated, return the cluster id
0000000000000000000000000000000000000000;;	func (ci *ClusterID) GetID() (string, error) {
0000000000000000000000000000000000000000;;		if err := ci.getOrInitialize(); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ci.idLock.RLock()
0000000000000000000000000000000000000000;;		defer ci.idLock.RUnlock()
0000000000000000000000000000000000000000;;		if ci.clusterID == nil {
0000000000000000000000000000000000000000;;			return "", errors.New("Could not retrieve cluster id")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If provider ID is set, (Federation is enabled) use this field
0000000000000000000000000000000000000000;;		if ci.providerID != nil {
0000000000000000000000000000000000000000;;			return *ci.providerID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// providerID is not set, use the cluster id
0000000000000000000000000000000000000000;;		return *ci.clusterID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFederationId returns the id which could represent the entire Federation
0000000000000000000000000000000000000000;;	// or just the cluster if not federated.
0000000000000000000000000000000000000000;;	func (ci *ClusterID) GetFederationId() (string, bool, error) {
0000000000000000000000000000000000000000;;		if err := ci.getOrInitialize(); err != nil {
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ci.idLock.RLock()
0000000000000000000000000000000000000000;;		defer ci.idLock.RUnlock()
0000000000000000000000000000000000000000;;		if ci.clusterID == nil {
0000000000000000000000000000000000000000;;			return "", false, errors.New("Could not retrieve cluster id")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If provider ID is not set, return false
0000000000000000000000000000000000000000;;		if ci.providerID == nil || *ci.clusterID == *ci.providerID {
0000000000000000000000000000000000000000;;			return "", false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return *ci.clusterID, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getOrInitialize either grabs the configmaps current value or defines the value
0000000000000000000000000000000000000000;;	// and sets the configmap. This is for the case of the user calling GetClusterID()
0000000000000000000000000000000000000000;;	// before the watch has begun.
0000000000000000000000000000000000000000;;	func (ci *ClusterID) getOrInitialize() error {
0000000000000000000000000000000000000000;;		if ci.store == nil {
0000000000000000000000000000000000000000;;			return errors.New("GCECloud.ClusterID is not ready. Call Initialize() before using.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ci.clusterID != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists, err := ci.getConfigMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if exists {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The configmap does not exist - let's try creating one.
0000000000000000000000000000000000000000;;		newId, err := makeUID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Creating clusteriD: %v", newId)
0000000000000000000000000000000000000000;;		cfg := &v1.ConfigMap{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      UIDConfigMapName,
0000000000000000000000000000000000000000;;				Namespace: UIDNamespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg.Data = map[string]string{
0000000000000000000000000000000000000000;;			UIDCluster:  newId,
0000000000000000000000000000000000000000;;			UIDProvider: newId,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := ci.client.Core().ConfigMaps(UIDNamespace).Create(cfg); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("GCE cloud provider failed to create %v config map to store cluster id: %v", ci.cfgMapKey, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Created a config map containing clusteriD: %v", newId)
0000000000000000000000000000000000000000;;		ci.update(cfg)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ci *ClusterID) getConfigMap() (bool, error) {
0000000000000000000000000000000000000000;;		item, exists, err := ci.store.GetByKey(ci.cfgMapKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, ok := item.(*v1.ConfigMap)
0000000000000000000000000000000000000000;;		if !ok || m == nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Expected v1.ConfigMap, item=%+v, typeIsOk=%v", item, ok)
0000000000000000000000000000000000000000;;			glog.Error(err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ci.update(m)
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ci *ClusterID) update(m *v1.ConfigMap) {
0000000000000000000000000000000000000000;;		ci.idLock.Lock()
0000000000000000000000000000000000000000;;		defer ci.idLock.Unlock()
0000000000000000000000000000000000000000;;		if clusterID, exists := m.Data[UIDCluster]; exists {
0000000000000000000000000000000000000000;;			ci.clusterID = &clusterID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if provId, exists := m.Data[UIDProvider]; exists {
0000000000000000000000000000000000000000;;			ci.providerID = &provId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeUID() (string, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, UIDLengthBytes)
0000000000000000000000000000000000000000;;		_, err := rand.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hex.EncodeToString(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSingleObjectListerWatcher(lw cache.ListerWatcher, objectName string) *singleObjListerWatcher {
0000000000000000000000000000000000000000;;		return &singleObjListerWatcher{lw: lw, objectName: objectName}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type singleObjListerWatcher struct {
0000000000000000000000000000000000000000;;		lw         cache.ListerWatcher
0000000000000000000000000000000000000000;;		objectName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sow *singleObjListerWatcher) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		options.FieldSelector = "metadata.name=" + sow.objectName
0000000000000000000000000000000000000000;;		return sow.lw.List(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sow *singleObjListerWatcher) Watch(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		options.FieldSelector = "metadata.name=" + sow.objectName
0000000000000000000000000000000000000000;;		return sow.lw.Watch(options)
0000000000000000000000000000000000000000;;	}
