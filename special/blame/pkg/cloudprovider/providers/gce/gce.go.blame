0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d31dcf734feb05aa86260bc1f1d21098af4f0b6e;pkg/cloudprovider/gce.go[pkg/cloudprovider/gce.go][pkg/cloudprovider/providers/gce/gce.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gcfg "gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"cloud.google.com/go/compute/metadata"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/google"
0000000000000000000000000000000000000000;;		cloudkms "google.golang.org/api/cloudkms/v1"
0000000000000000000000000000000000000000;;		computealpha "google.golang.org/api/compute/v0.alpha"
0000000000000000000000000000000000000000;;		computebeta "google.golang.org/api/compute/v0.beta"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;		container "google.golang.org/api/container/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProviderName = "gce"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k8sNodeRouteTag = "k8s-node-route"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AffinityTypeNone - no session affinity.
0000000000000000000000000000000000000000;;		gceAffinityTypeNone = "NONE"
0000000000000000000000000000000000000000;;		// AffinityTypeClientIP - affinity based on Client IP.
0000000000000000000000000000000000000000;;		gceAffinityTypeClientIP = "CLIENT_IP"
0000000000000000000000000000000000000000;;		// AffinityTypeClientIPProto - affinity based on Client IP and port.
0000000000000000000000000000000000000000;;		gceAffinityTypeClientIPProto = "CLIENT_IP_PROTO"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operationPollInterval = 3 * time.Second
0000000000000000000000000000000000000000;;		// Creating Route in very large clusters, may take more than half an hour.
0000000000000000000000000000000000000000;;		operationPollTimeoutDuration = time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Each page can have 500 results, but we cap how many pages
0000000000000000000000000000000000000000;;		// are iterated through to prevent infinite loops if the API
0000000000000000000000000000000000000000;;		// were to continuously return a nextPageToken.
0000000000000000000000000000000000000000;;		maxPages = 25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxTargetPoolCreateInstances = 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HTTP Load Balancer parameters
0000000000000000000000000000000000000000;;		// Configure 2 second period for external health checks.
0000000000000000000000000000000000000000;;		gceHcCheckIntervalSeconds = int64(2)
0000000000000000000000000000000000000000;;		gceHcTimeoutSeconds       = int64(1)
0000000000000000000000000000000000000000;;		// Start sending requests as soon as a pod is found on the node.
0000000000000000000000000000000000000000;;		gceHcHealthyThreshold = int64(1)
0000000000000000000000000000000000000000;;		// Defaults to 5 * 2 = 10 seconds before the LB will steer traffic away
0000000000000000000000000000000000000000;;		gceHcUnhealthyThreshold = int64(5)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gceComputeAPIEndpoint = "https://www.googleapis.com/compute/v1/"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GCECloud is an implementation of Interface, LoadBalancer and Instances for Google Compute Engine.
0000000000000000000000000000000000000000;;	type GCECloud struct {
0000000000000000000000000000000000000000;;		// ClusterID contains functionality for getting (and initializing) the ingress-uid. Call GCECloud.Initialize()
0000000000000000000000000000000000000000;;		// for the cloudprovider to start watching the configmap.
0000000000000000000000000000000000000000;;		ClusterID ClusterID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service                  *compute.Service
0000000000000000000000000000000000000000;;		serviceBeta              *computebeta.Service
0000000000000000000000000000000000000000;;		serviceAlpha             *computealpha.Service
0000000000000000000000000000000000000000;;		containerService         *container.Service
0000000000000000000000000000000000000000;;		cloudkmsService          *cloudkms.Service
0000000000000000000000000000000000000000;;		clientBuilder            controller.ControllerClientBuilder
0000000000000000000000000000000000000000;;		projectID                string
0000000000000000000000000000000000000000;;		region                   string
0000000000000000000000000000000000000000;;		localZone                string   // The zone in which we are running
0000000000000000000000000000000000000000;;		managedZones             []string // List of zones we are spanning (for multi-AZ clusters, primarily when running on master)
0000000000000000000000000000000000000000;;		networkURL               string
0000000000000000000000000000000000000000;;		subnetworkURL            string
0000000000000000000000000000000000000000;;		networkProjectID         string
0000000000000000000000000000000000000000;;		onXPN                    bool
0000000000000000000000000000000000000000;;		nodeTags                 []string    // List of tags to use on firewall rules for load balancers
0000000000000000000000000000000000000000;;		lastComputedNodeTags     []string    // List of node tags calculated in GetHostTags()
0000000000000000000000000000000000000000;;		lastKnownNodeNames       sets.String // List of hostnames used to calculate lastComputedHostTags in GetHostTags(names)
0000000000000000000000000000000000000000;;		computeNodeTagLock       sync.Mutex  // Lock for computing and setting node tags
0000000000000000000000000000000000000000;;		nodeInstancePrefix       string      // If non-"", an advisory prefix for all nodes in the cluster
0000000000000000000000000000000000000000;;		useMetadataServer        bool
0000000000000000000000000000000000000000;;		operationPollRateLimiter flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;		manager                  ServiceManager
0000000000000000000000000000000000000000;;		// sharedResourceLock is used to serialize GCE operations that may mutate shared state to
0000000000000000000000000000000000000000;;		// prevent inconsistencies. For example, load balancers manipulation methods will take the
0000000000000000000000000000000000000000;;		// lock to prevent shared resources from being prematurely deleted while the operation is
0000000000000000000000000000000000000000;;		// in progress.
0000000000000000000000000000000000000000;;		sharedResourceLock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ServiceManager interface {
0000000000000000000000000000000000000000;;		// Creates a new persistent disk on GCE with the given disk spec.
0000000000000000000000000000000000000000;;		CreateDisk(project string, zone string, disk *compute.Disk) (*compute.Operation, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gets the persistent disk from GCE with the given diskName.
0000000000000000000000000000000000000000;;		GetDisk(project string, zone string, diskName string) (*compute.Disk, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deletes the persistent disk from GCE with the given diskName.
0000000000000000000000000000000000000000;;		DeleteDisk(project string, zone string, disk string) (*compute.Operation, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Waits until GCE reports the given operation in the given zone as done.
0000000000000000000000000000000000000000;;		WaitForZoneOp(op *compute.Operation, zone string, mc *metricContext) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GCEServiceManager struct {
0000000000000000000000000000000000000000;;		gce *GCECloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		Global struct {
0000000000000000000000000000000000000000;;			TokenURL           string   `gcfg:"token-url"`
0000000000000000000000000000000000000000;;			TokenBody          string   `gcfg:"token-body"`
0000000000000000000000000000000000000000;;			ProjectID          string   `gcfg:"project-id"`
0000000000000000000000000000000000000000;;			NetworkName        string   `gcfg:"network-name"`
0000000000000000000000000000000000000000;;			SubnetworkName     string   `gcfg:"subnetwork-name"`
0000000000000000000000000000000000000000;;			NodeTags           []string `gcfg:"node-tags"`
0000000000000000000000000000000000000000;;			NodeInstancePrefix string   `gcfg:"node-instance-prefix"`
0000000000000000000000000000000000000000;;			Multizone          bool     `gcfg:"multizone"`
0000000000000000000000000000000000000000;;			// Specifying ApiEndpoint will override the default GCE compute API endpoint.
0000000000000000000000000000000000000000;;			ApiEndpoint string `gcfg:"api-endpoint"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		cloudprovider.RegisterCloudProvider(
0000000000000000000000000000000000000000;;			ProviderName,
0000000000000000000000000000000000000000;;			func(config io.Reader) (cloudprovider.Interface, error) {
0000000000000000000000000000000000000000;;				return newGCECloud(config)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw access to the underlying GCE service, probably should only be used for e2e tests
0000000000000000000000000000000000000000;;	func (g *GCECloud) GetComputeService() *compute.Service {
0000000000000000000000000000000000000000;;		return g.service
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw access to the cloudkmsService of GCE cloud. Required for encryption of etcd using Google KMS.
0000000000000000000000000000000000000000;;	func (g *GCECloud) GetKMSService() *cloudkms.Service {
0000000000000000000000000000000000000000;;		return g.cloudkmsService
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the ProjectID corresponding to the project this cloud is in.
0000000000000000000000000000000000000000;;	func (g *GCECloud) GetProjectID() string {
0000000000000000000000000000000000000000;;		return g.projectID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newGCECloud creates a new instance of GCECloud.
0000000000000000000000000000000000000000;;	func newGCECloud(config io.Reader) (*GCECloud, error) {
0000000000000000000000000000000000000000;;		apiEndpoint := ""
0000000000000000000000000000000000000000;;		projectID, zone, err := getProjectAndZone()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		region, err := GetGCERegion(zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		networkName, err := getNetworkNameViaMetadata()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		networkURL := gceNetworkURL("", projectID, networkName)
0000000000000000000000000000000000000000;;		subnetworkURL := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// By default, Kubernetes clusters only run against one zone
0000000000000000000000000000000000000000;;		managedZones := []string{zone}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenSource := google.ComputeTokenSource("")
0000000000000000000000000000000000000000;;		var nodeTags []string
0000000000000000000000000000000000000000;;		var nodeInstancePrefix string
0000000000000000000000000000000000000000;;		if config != nil {
0000000000000000000000000000000000000000;;			var cfg Config
0000000000000000000000000000000000000000;;			if err := gcfg.ReadInto(&cfg, config); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't read config: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Using GCE provider config %+v", cfg)
0000000000000000000000000000000000000000;;			if cfg.Global.ApiEndpoint != "" {
0000000000000000000000000000000000000000;;				apiEndpoint = cfg.Global.ApiEndpoint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cfg.Global.ProjectID != "" {
0000000000000000000000000000000000000000;;				projectID = cfg.Global.ProjectID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cfg.Global.NetworkName != "" && strings.Contains(cfg.Global.NetworkName, "/") {
0000000000000000000000000000000000000000;;				networkURL = cfg.Global.NetworkName
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				networkURL = gceNetworkURL(apiEndpoint, projectID, networkName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cfg.Global.SubnetworkName != "" && strings.Contains(cfg.Global.SubnetworkName, "/") {
0000000000000000000000000000000000000000;;				subnetworkURL = cfg.Global.SubnetworkName
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				subnetworkURL = gceSubnetworkURL(apiEndpoint, cfg.Global.ProjectID, region, cfg.Global.SubnetworkName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cfg.Global.TokenURL != "" {
0000000000000000000000000000000000000000;;				tokenSource = NewAltTokenSource(cfg.Global.TokenURL, cfg.Global.TokenBody)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeTags = cfg.Global.NodeTags
0000000000000000000000000000000000000000;;			nodeInstancePrefix = cfg.Global.NodeInstancePrefix
0000000000000000000000000000000000000000;;			if cfg.Global.Multizone {
0000000000000000000000000000000000000000;;				managedZones = nil // Use all zones in region
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return CreateGCECloud(apiEndpoint, projectID, region, zone, managedZones, networkURL, subnetworkURL,
0000000000000000000000000000000000000000;;			nodeTags, nodeInstancePrefix, tokenSource, true /* useMetadataServer */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a GCECloud object using the specified parameters.
0000000000000000000000000000000000000000;;	// If no networkUrl is specified, loads networkName via rest call.
0000000000000000000000000000000000000000;;	// If no tokenSource is specified, uses oauth2.DefaultTokenSource.
0000000000000000000000000000000000000000;;	// If managedZones is nil / empty all zones in the region will be managed.
0000000000000000000000000000000000000000;;	func CreateGCECloud(apiEndpoint, projectID, region, zone string, managedZones []string, networkURL, subnetworkURL string, nodeTags []string,
0000000000000000000000000000000000000000;;		nodeInstancePrefix string, tokenSource oauth2.TokenSource, useMetadataServer bool) (*GCECloud, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err := newOauthClient(tokenSource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service, err := compute.New(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err = newOauthClient(tokenSource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serviceBeta, err := computebeta.New(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client, err = newOauthClient(tokenSource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serviceAlpha, err := computealpha.New(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect override api endpoint to always be v1 api and follows the same pattern as prod.
0000000000000000000000000000000000000000;;		// Generate alpha and beta api endpoints based on override v1 api endpoint.
0000000000000000000000000000000000000000;;		// For example,
0000000000000000000000000000000000000000;;		// staging API endpoint: https://www.googleapis.com/compute/staging_v1/
0000000000000000000000000000000000000000;;		if apiEndpoint != "" {
0000000000000000000000000000000000000000;;			service.BasePath = fmt.Sprintf("%sprojects/", apiEndpoint)
0000000000000000000000000000000000000000;;			serviceBeta.BasePath = fmt.Sprintf("%sprojects/", strings.Replace(apiEndpoint, "v1", "beta", 0))
0000000000000000000000000000000000000000;;			serviceAlpha.BasePath = fmt.Sprintf("%sprojects/", strings.Replace(apiEndpoint, "v1", "alpha", 0))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerService, err := container.New(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudkmsService, err := cloudkms.New(client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if networkURL == "" {
0000000000000000000000000000000000000000;;			networkName, err := getNetworkNameViaAPICall(service, projectID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			networkURL = gceNetworkURL(apiEndpoint, projectID, networkName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		networkProjectID, err := getProjectIDInURL(networkURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		onXPN := networkProjectID != projectID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(managedZones) == 0 {
0000000000000000000000000000000000000000;;			managedZones, err = getZonesForRegion(service, projectID, region)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(managedZones) != 1 {
0000000000000000000000000000000000000000;;			glog.Infof("managing multiple zones: %v", managedZones)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operationPollRateLimiter := flowcontrol.NewTokenBucketRateLimiter(10, 100) // 10 qps, 100 bucket size.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce := &GCECloud{
0000000000000000000000000000000000000000;;			service:                  service,
0000000000000000000000000000000000000000;;			serviceBeta:              serviceBeta,
0000000000000000000000000000000000000000;;			containerService:         containerService,
0000000000000000000000000000000000000000;;			cloudkmsService:          cloudkmsService,
0000000000000000000000000000000000000000;;			projectID:                projectID,
0000000000000000000000000000000000000000;;			networkProjectID:         networkProjectID,
0000000000000000000000000000000000000000;;			onXPN:                    onXPN,
0000000000000000000000000000000000000000;;			region:                   region,
0000000000000000000000000000000000000000;;			localZone:                zone,
0000000000000000000000000000000000000000;;			managedZones:             managedZones,
0000000000000000000000000000000000000000;;			networkURL:               networkURL,
0000000000000000000000000000000000000000;;			subnetworkURL:            subnetworkURL,
0000000000000000000000000000000000000000;;			nodeTags:                 nodeTags,
0000000000000000000000000000000000000000;;			nodeInstancePrefix:       nodeInstancePrefix,
0000000000000000000000000000000000000000;;			useMetadataServer:        useMetadataServer,
0000000000000000000000000000000000000000;;			operationPollRateLimiter: operationPollRateLimiter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce.manager = &GCEServiceManager{gce}
0000000000000000000000000000000000000000;;		return gce, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize takes in a clientBuilder and spawns a goroutine for watching the clusterid configmap.
0000000000000000000000000000000000000000;;	// This must be called before utilizing the funcs of gce.ClusterID
0000000000000000000000000000000000000000;;	func (gce *GCECloud) Initialize(clientBuilder controller.ControllerClientBuilder) {
0000000000000000000000000000000000000000;;		gce.clientBuilder = clientBuilder
0000000000000000000000000000000000000000;;		go gce.watchClusterID()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer returns an implementation of LoadBalancer for Google Compute Engine.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
0000000000000000000000000000000000000000;;		return gce, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances returns an implementation of Instances for Google Compute Engine.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		return gce, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zones returns an implementation of Zones for Google Compute Engine.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) Zones() (cloudprovider.Zones, bool) {
0000000000000000000000000000000000000000;;		return gce, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) Clusters() (cloudprovider.Clusters, bool) {
0000000000000000000000000000000000000000;;		return gce, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Routes returns an implementation of Routes for Google Compute Engine.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) Routes() (cloudprovider.Routes, bool) {
0000000000000000000000000000000000000000;;		return gce, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ProviderName() string {
0000000000000000000000000000000000000000;;		return ProviderName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Region returns the region
0000000000000000000000000000000000000000;;	func (gce *GCECloud) Region() string {
0000000000000000000000000000000000000000;;		return gce.region
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnXPN returns true if the cluster is running on a cross project network (XPN)
0000000000000000000000000000000000000000;;	func (gce *GCECloud) OnXPN() bool {
0000000000000000000000000000000000000000;;		return gce.onXPN
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkURL returns the network url
0000000000000000000000000000000000000000;;	func (gce *GCECloud) NetworkURL() string {
0000000000000000000000000000000000000000;;		return gce.networkURL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubnetworkURL returns the subnetwork url
0000000000000000000000000000000000000000;;	func (gce *GCECloud) SubnetworkURL() string {
0000000000000000000000000000000000000000;;		return gce.subnetworkURL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Known-useless DNS search path.
0000000000000000000000000000000000000000;;	var uselessDNSSearchRE = regexp.MustCompile(`^[0-9]+.google.internal.$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScrubDNS filters DNS settings for pods.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string) {
0000000000000000000000000000000000000000;;		// GCE has too many search paths by default. Filter the ones we know are useless.
0000000000000000000000000000000000000000;;		for _, s := range searches {
0000000000000000000000000000000000000000;;			if !uselessDNSSearchRE.MatchString(s) {
0000000000000000000000000000000000000000;;				srchOut = append(srchOut, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nameservers, srchOut
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GCECloud implements cloudprovider.Interface.
0000000000000000000000000000000000000000;;	var _ cloudprovider.Interface = (*GCECloud)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gceNetworkURL(apiEndpoint, project, network string) string {
0000000000000000000000000000000000000000;;		if apiEndpoint == "" {
0000000000000000000000000000000000000000;;			apiEndpoint = gceComputeAPIEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return apiEndpoint + strings.Join([]string{"projects", project, "global", "networks", network}, "/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gceSubnetworkURL(apiEndpoint, project, region, subnetwork string) string {
0000000000000000000000000000000000000000;;		if apiEndpoint == "" {
0000000000000000000000000000000000000000;;			apiEndpoint = gceComputeAPIEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return apiEndpoint + strings.Join([]string{"projects", project, "regions", region, "subnetworks", subnetwork}, "/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getProjectIDInURL parses typical full resource URLS and shorter URLS
0000000000000000000000000000000000000000;;	// https://www.googleapis.com/compute/v1/projects/myproject/global/networks/mycustom
0000000000000000000000000000000000000000;;	// projects/myproject/global/networks/mycustom
0000000000000000000000000000000000000000;;	// All return "myproject"
0000000000000000000000000000000000000000;;	func getProjectIDInURL(urlStr string) (string, error) {
0000000000000000000000000000000000000000;;		fields := strings.Split(urlStr, "/")
0000000000000000000000000000000000000000;;		for i, v := range fields {
0000000000000000000000000000000000000000;;			if v == "projects" && i < len(fields)-1 {
0000000000000000000000000000000000000000;;				return fields[i+1], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("could not find project field in url: %v", urlStr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNetworkNameViaMetadata() (string, error) {
0000000000000000000000000000000000000000;;		result, err := metadata.Get("instance/network-interfaces/0/network")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.Split(result, "/")
0000000000000000000000000000000000000000;;		if len(parts) != 4 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected response: %s", result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parts[3], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNetworkNameViaAPICall(svc *compute.Service, projectID string) (string, error) {
0000000000000000000000000000000000000000;;		// TODO: use PageToken to list all not just the first 500
0000000000000000000000000000000000000000;;		networkList, err := svc.Networks.List(projectID).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if networkList == nil || len(networkList.Items) <= 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("GCE Network List call returned no networks for project %q", projectID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return networkList.Items[0].Name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getZonesForRegion(svc *compute.Service, projectID, region string) ([]string, error) {
0000000000000000000000000000000000000000;;		// TODO: use PageToken to list all not just the first 500
0000000000000000000000000000000000000000;;		listCall := svc.Zones.List(projectID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Filtering by region doesn't seem to work
0000000000000000000000000000000000000000;;		// (tested in https://cloud.google.com/compute/docs/reference/latest/zones/list)
0000000000000000000000000000000000000000;;		// listCall = listCall.Filter("region eq " + region)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := listCall.Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected response listing zones: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zones := []string{}
0000000000000000000000000000000000000000;;		for _, zone := range res.Items {
0000000000000000000000000000000000000000;;			regionName := lastComponent(zone.Region)
0000000000000000000000000000000000000000;;			if regionName == region {
0000000000000000000000000000000000000000;;				zones = append(zones, zone.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return zones, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newOauthClient(tokenSource oauth2.TokenSource) (*http.Client, error) {
0000000000000000000000000000000000000000;;		if tokenSource == nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			tokenSource, err = google.DefaultTokenSource(
0000000000000000000000000000000000000000;;				oauth2.NoContext,
0000000000000000000000000000000000000000;;				compute.CloudPlatformScope,
0000000000000000000000000000000000000000;;				compute.ComputeScope)
0000000000000000000000000000000000000000;;			glog.Infof("Using DefaultTokenSource %#v", tokenSource)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Infof("Using existing Token Source %#v", tokenSource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := wait.PollImmediate(5*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			if _, err := tokenSource.Token(); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error fetching initial token: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return oauth2.NewClient(oauth2.NoContext, tokenSource), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *GCEServiceManager) CreateDisk(
0000000000000000000000000000000000000000;;		project string,
0000000000000000000000000000000000000000;;		zone string,
0000000000000000000000000000000000000000;;		disk *compute.Disk) (*compute.Operation, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return manager.gce.service.Disks.Insert(project, zone, disk).Do()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *GCEServiceManager) GetDisk(
0000000000000000000000000000000000000000;;		project string,
0000000000000000000000000000000000000000;;		zone string,
0000000000000000000000000000000000000000;;		diskName string) (*compute.Disk, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return manager.gce.service.Disks.Get(project, zone, diskName).Do()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *GCEServiceManager) DeleteDisk(
0000000000000000000000000000000000000000;;		project string,
0000000000000000000000000000000000000000;;		zone string,
0000000000000000000000000000000000000000;;		diskName string) (*compute.Operation, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return manager.gce.service.Disks.Delete(project, zone, diskName).Do()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (manager *GCEServiceManager) WaitForZoneOp(op *compute.Operation, zone string, mc *metricContext) error {
0000000000000000000000000000000000000000;;		return manager.gce.waitForZoneOp(op, zone, mc)
0000000000000000000000000000000000000000;;	}
