0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9a3e3fac5acb000ea4977a0e92d5b6e96ddd1f63;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"cloud.google.com/go/compute/metadata"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		computebeta "google.golang.org/api/compute/v0.beta"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultZone = ""
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInstancesMetricContext(request, zone string) *metricContext {
0000000000000000000000000000000000000000;;		return &metricContext{
0000000000000000000000000000000000000000;;			start:      time.Now(),
0000000000000000000000000000000000000000;;			attributes: []string{"instances_" + request, unusedMetricLabel, zone},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func splitNodesByZone(nodes []*v1.Node) map[string][]*v1.Node {
0000000000000000000000000000000000000000;;		zones := make(map[string][]*v1.Node)
0000000000000000000000000000000000000000;;		for _, n := range nodes {
0000000000000000000000000000000000000000;;			z := getZone(n)
0000000000000000000000000000000000000000;;			if z != defaultZone {
0000000000000000000000000000000000000000;;				zones[z] = append(zones[z], n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return zones
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getZone(n *v1.Node) string {
0000000000000000000000000000000000000000;;		zone, ok := n.Labels[kubeletapis.LabelZoneFailureDomain]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return defaultZone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return zone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToInstanceReferences returns instance references by links
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ToInstanceReferences(zone string, instanceNames []string) (refs []*compute.InstanceReference) {
0000000000000000000000000000000000000000;;		for _, ins := range instanceNames {
0000000000000000000000000000000000000000;;			instanceLink := makeHostURL(gce.service.BasePath, gce.projectID, zone, ins)
0000000000000000000000000000000000000000;;			refs = append(refs, &compute.InstanceReference{Instance: instanceLink})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return refs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddresses is an implementation of Instances.NodeAddresses.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) NodeAddresses(_ types.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		internalIP, err := metadata.Get("instance/network-interfaces/0/ip")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't get internal IP: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		externalIP, err := metadata.Get("instance/network-interfaces/0/access-configs/0/external-ip")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't get external IP: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{Type: v1.NodeInternalIP, Address: internalIP},
0000000000000000000000000000000000000000;;			{Type: v1.NodeExternalIP, Address: externalIP},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID.
0000000000000000000000000000000000000000;;	// i.e. metadata service and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (gce *GCECloud) NodeAddressesByProviderID(providerID string) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		project, zone, name, err := splitProviderID(providerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []v1.NodeAddress{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instance, err := gce.service.Instances.Get(project, zone, canonicalizeInstanceName(name)).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []v1.NodeAddress{}, fmt.Errorf("error while querying for providerID %q: %v", providerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(instance.NetworkInterfaces) < 1 {
0000000000000000000000000000000000000000;;			return []v1.NodeAddress{}, fmt.Errorf("could not find network interfaces for providerID %q", providerID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		networkInterface := instance.NetworkInterfaces[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeAddresses := []v1.NodeAddress{{Type: v1.NodeInternalIP, Address: networkInterface.NetworkIP}}
0000000000000000000000000000000000000000;;		for _, config := range networkInterface.AccessConfigs {
0000000000000000000000000000000000000000;;			nodeAddresses = append(nodeAddresses, v1.NodeAddress{Type: v1.NodeExternalIP, Address: config.NatIP})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodeAddresses, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceTypeByProviderID returns the cloudprovider instance type of the node
0000000000000000000000000000000000000000;;	// with the specified unique providerID This method will not be called from the
0000000000000000000000000000000000000000;;	// node that is requesting this ID. i.e. metadata service and other local
0000000000000000000000000000000000000000;;	// methods cannot be used here
0000000000000000000000000000000000000000;;	func (gce *GCECloud) InstanceTypeByProviderID(providerID string) (string, error) {
0000000000000000000000000000000000000000;;		project, zone, name, err := splitProviderID(providerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instance, err := gce.getInstanceFromProjectInZoneByName(project, zone, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return instance.Type, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalID returns the cloud provider ID of the node with the specified NodeName (deprecated).
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ExternalID(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(nodeName)
0000000000000000000000000000000000000000;;		if gce.useMetadataServer {
0000000000000000000000000000000000000000;;			// Use metadata, if possible, to fetch ID. See issue #12000
0000000000000000000000000000000000000000;;			if gce.isCurrentInstance(instanceName) {
0000000000000000000000000000000000000000;;				externalInstanceID, err := getCurrentExternalIDViaMetadata()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return externalInstanceID, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fallback to GCE API call if metadata server fails to retrieve ID
0000000000000000000000000000000000000000;;		inst, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.FormatUint(inst.ID, 10), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the cloud provider ID of the node with the specified NodeName.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) InstanceID(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(nodeName)
0000000000000000000000000000000000000000;;		if gce.useMetadataServer {
0000000000000000000000000000000000000000;;			// Use metadata, if possible, to fetch ID. See issue #12000
0000000000000000000000000000000000000000;;			if gce.isCurrentInstance(instanceName) {
0000000000000000000000000000000000000000;;				projectID, zone, err := getProjectAndZone()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return projectID + "/" + zone + "/" + canonicalizeInstanceName(instanceName), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instance, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gce.projectID + "/" + instance.Zone + "/" + instance.Name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceType returns the type of the specified node with the specified NodeName.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) InstanceType(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(nodeName)
0000000000000000000000000000000000000000;;		if gce.useMetadataServer {
0000000000000000000000000000000000000000;;			// Use metadata, if possible, to fetch ID. See issue #12000
0000000000000000000000000000000000000000;;			if gce.isCurrentInstance(instanceName) {
0000000000000000000000000000000000000000;;				mType, err := getCurrentMachineTypeViaMetadata()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return mType, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instance, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return instance.Type, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) AddSSHKeyToAllInstances(user string, keyData []byte) error {
0000000000000000000000000000000000000000;;		return wait.Poll(2*time.Second, 30*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			project, err := gce.service.Projects.Get(gce.projectID).Do()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not get project: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyString := fmt.Sprintf("%s:%s %s@%s", user, strings.TrimSpace(string(keyData)), user, user)
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, item := range project.CommonInstanceMetadata.Items {
0000000000000000000000000000000000000000;;				if item.Key == "sshKeys" {
0000000000000000000000000000000000000000;;					if strings.Contains(*item.Value, keyString) {
0000000000000000000000000000000000000000;;						// We've already added the key
0000000000000000000000000000000000000000;;						glog.Info("SSHKey already in project metadata")
0000000000000000000000000000000000000000;;						return true, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					value := *item.Value + "\n" + keyString
0000000000000000000000000000000000000000;;					item.Value = &value
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				// This is super unlikely, so log.
0000000000000000000000000000000000000000;;				glog.Infof("Failed to find sshKeys metadata, creating a new item")
0000000000000000000000000000000000000000;;				project.CommonInstanceMetadata.Items = append(project.CommonInstanceMetadata.Items,
0000000000000000000000000000000000000000;;					&compute.MetadataItems{
0000000000000000000000000000000000000000;;						Key:   "sshKeys",
0000000000000000000000000000000000000000;;						Value: &keyString,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mc := newInstancesMetricContext("add_ssh_key", "")
0000000000000000000000000000000000000000;;			op, err := gce.service.Projects.SetCommonInstanceMetadata(
0000000000000000000000000000000000000000;;				gce.projectID, project.CommonInstanceMetadata).Do()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not Set Metadata: %v", err)
0000000000000000000000000000000000000000;;				mc.Observe(err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := gce.waitForGlobalOp(op, mc); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Could not Set Metadata: %v", err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof("Successfully added sshKey to project metadata")
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAllZones returns all the zones in which nodes are running
0000000000000000000000000000000000000000;;	func (gce *GCECloud) GetAllZones() (sets.String, error) {
0000000000000000000000000000000000000000;;		// Fast-path for non-multizone
0000000000000000000000000000000000000000;;		if len(gce.managedZones) == 1 {
0000000000000000000000000000000000000000;;			return sets.NewString(gce.managedZones...), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Caching, but this is currently only called when we are creating a volume,
0000000000000000000000000000000000000000;;		// which is a relatively infrequent operation, and this is only # zones API calls
0000000000000000000000000000000000000000;;		zones := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Parallelize, although O(zones) so not too bad (N <= 3 typically)
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			mc := newInstancesMetricContext("list", zone)
0000000000000000000000000000000000000000;;			// We only retrieve one page in each zone - we only care about existence
0000000000000000000000000000000000000000;;			listCall := gce.service.Instances.List(gce.projectID, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// No filter: We assume that a zone is either used or unused
0000000000000000000000000000000000000000;;			// We could only consider running nodes (like we do in List above),
0000000000000000000000000000000000000000;;			// but probably if instances are starting we still want to consider them.
0000000000000000000000000000000000000000;;			// I think we should wait until we have a reason to make the
0000000000000000000000000000000000000000;;			// call one way or the other; we generally can't guarantee correct
0000000000000000000000000000000000000000;;			// volume spreading if the set of zones is changing
0000000000000000000000000000000000000000;;			// (and volume spreading is currently only a heuristic).
0000000000000000000000000000000000000000;;			// Long term we want to replace GetAllZones (which primarily supports volume
0000000000000000000000000000000000000000;;			// spreading) with a scheduler policy that is able to see the global state of
0000000000000000000000000000000000000000;;			// volumes and the health of zones.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Just a minimal set of fields - we only care about existence
0000000000000000000000000000000000000000;;			listCall = listCall.Fields("items(name)")
0000000000000000000000000000000000000000;;			res, err := listCall.Do()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, mc.Observe(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mc.Observe(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(res.Items) != 0 {
0000000000000000000000000000000000000000;;				zones.Insert(zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return zones, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of Instances.CurrentNodeName
0000000000000000000000000000000000000000;;	func (gce *GCECloud) CurrentNodeName(hostname string) (types.NodeName, error) {
0000000000000000000000000000000000000000;;		return types.NodeName(hostname), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AliasRanges returns a list of CIDR ranges that are assigned to the
0000000000000000000000000000000000000000;;	// `node` for allocation to pods. Returns a list of the form
0000000000000000000000000000000000000000;;	// "<ip>/<netmask>".
0000000000000000000000000000000000000000;;	func (gce *GCECloud) AliasRanges(nodeName types.NodeName) (cidrs []string, err error) {
0000000000000000000000000000000000000000;;		var instance *gceInstance
0000000000000000000000000000000000000000;;		instance, err = gce.getInstanceByName(mapNodeNameToInstanceName(nodeName))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res *computebeta.Instance
0000000000000000000000000000000000000000;;		res, err = gce.serviceBeta.Instances.Get(
0000000000000000000000000000000000000000;;			gce.projectID, instance.Zone, instance.Name).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, networkInterface := range res.NetworkInterfaces {
0000000000000000000000000000000000000000;;			for _, aliasIpRange := range networkInterface.AliasIpRanges {
0000000000000000000000000000000000000000;;				cidrs = append(cidrs, aliasIpRange.IpCidrRange)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the named instances, returning cloudprovider.InstanceNotFound if any instance is not found
0000000000000000000000000000000000000000;;	func (gce *GCECloud) getInstancesByNames(names []string) ([]*gceInstance, error) {
0000000000000000000000000000000000000000;;		instances := make(map[string]*gceInstance)
0000000000000000000000000000000000000000;;		remaining := len(names)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeInstancePrefix := gce.nodeInstancePrefix
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			name = canonicalizeInstanceName(name)
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(name, gce.nodeInstancePrefix) {
0000000000000000000000000000000000000000;;				glog.Warningf("instance '%s' does not conform to prefix '%s', removing filter", name, gce.nodeInstancePrefix)
0000000000000000000000000000000000000000;;				nodeInstancePrefix = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			instances[name] = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			if remaining == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pageToken := ""
0000000000000000000000000000000000000000;;			page := 0
0000000000000000000000000000000000000000;;			for ; page == 0 || (pageToken != "" && page < maxPages); page++ {
0000000000000000000000000000000000000000;;				listCall := gce.service.Instances.List(gce.projectID, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if nodeInstancePrefix != "" {
0000000000000000000000000000000000000000;;					// Add the filter for hosts
0000000000000000000000000000000000000000;;					listCall = listCall.Filter("name eq " + nodeInstancePrefix + ".*")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO(zmerlynn): Internal bug 29524655
0000000000000000000000000000000000000000;;				// listCall = listCall.Fields("items(name,id,disks,machineType)")
0000000000000000000000000000000000000000;;				if pageToken != "" {
0000000000000000000000000000000000000000;;					listCall.PageToken(pageToken)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				res, err := listCall.Do()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pageToken = res.NextPageToken
0000000000000000000000000000000000000000;;				for _, i := range res.Items {
0000000000000000000000000000000000000000;;					name := i.Name
0000000000000000000000000000000000000000;;					if _, ok := instances[name]; !ok {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					instance := &gceInstance{
0000000000000000000000000000000000000000;;						Zone:  zone,
0000000000000000000000000000000000000000;;						Name:  name,
0000000000000000000000000000000000000000;;						ID:    i.Id,
0000000000000000000000000000000000000000;;						Disks: i.Disks,
0000000000000000000000000000000000000000;;						Type:  lastComponent(i.MachineType),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					instances[name] = instance
0000000000000000000000000000000000000000;;					remaining--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if page >= maxPages {
0000000000000000000000000000000000000000;;				glog.Errorf("getInstancesByNames exceeded maxPages=%d for Instances.List: truncating.", maxPages)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instanceArray := make([]*gceInstance, len(names))
0000000000000000000000000000000000000000;;		for i, name := range names {
0000000000000000000000000000000000000000;;			name = canonicalizeInstanceName(name)
0000000000000000000000000000000000000000;;			instance := instances[name]
0000000000000000000000000000000000000000;;			if instance == nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to retrieve instance: %q", name)
0000000000000000000000000000000000000000;;				return nil, cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			instanceArray[i] = instances[name]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return instanceArray, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the named instance, returning cloudprovider.InstanceNotFound if the instance is not found
0000000000000000000000000000000000000000;;	func (gce *GCECloud) getInstanceByName(name string) (*gceInstance, error) {
0000000000000000000000000000000000000000;;		// Avoid changing behaviour when not managing multiple zones
0000000000000000000000000000000000000000;;		for _, zone := range gce.managedZones {
0000000000000000000000000000000000000000;;			instance, err := gce.getInstanceFromProjectInZoneByName(gce.projectID, zone, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return instance, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) getInstanceFromProjectInZoneByName(project, zone, name string) (*gceInstance, error) {
0000000000000000000000000000000000000000;;		name = canonicalizeInstanceName(name)
0000000000000000000000000000000000000000;;		mc := newInstancesMetricContext("get", zone)
0000000000000000000000000000000000000000;;		res, err := gce.service.Instances.Get(project, zone, name).Do()
0000000000000000000000000000000000000000;;		mc.Observe(err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("getInstanceFromProjectInZoneByName: failed to get instance %s; err: %v", name, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &gceInstance{
0000000000000000000000000000000000000000;;			Zone:  lastComponent(res.Zone),
0000000000000000000000000000000000000000;;			Name:  res.Name,
0000000000000000000000000000000000000000;;			ID:    res.Id,
0000000000000000000000000000000000000000;;			Disks: res.Disks,
0000000000000000000000000000000000000000;;			Type:  lastComponent(res.MachineType),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInstanceIDViaMetadata() (string, error) {
0000000000000000000000000000000000000000;;		result, err := metadata.Get("instance/hostname")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.Split(result, ".")
0000000000000000000000000000000000000000;;		if len(parts) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected response: %s", result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parts[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCurrentExternalIDViaMetadata() (string, error) {
0000000000000000000000000000000000000000;;		externalID, err := metadata.Get("instance/id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("couldn't get external ID: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return externalID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCurrentMachineTypeViaMetadata() (string, error) {
0000000000000000000000000000000000000000;;		mType, err := metadata.Get("instance/machine-type")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("couldn't get machine type: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.Split(mType, "/")
0000000000000000000000000000000000000000;;		if len(parts) != 4 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected response for machine type: %s", mType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parts[3], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isCurrentInstance uses metadata server to check if specified
0000000000000000000000000000000000000000;;	// instanceID matches current machine's instanceID
0000000000000000000000000000000000000000;;	func (gce *GCECloud) isCurrentInstance(instanceID string) bool {
0000000000000000000000000000000000000000;;		currentInstanceID, err := getInstanceIDViaMetadata()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log and swallow error
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to fetch instanceID via Metadata: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return currentInstanceID == canonicalizeInstanceName(instanceID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComputeHostTags grabs all tags from all instances being added to the pool.
0000000000000000000000000000000000000000;;	// * The longest tag that is a prefix of the instance name is used
0000000000000000000000000000000000000000;;	// * If any instance has no matching prefix tag, return error
0000000000000000000000000000000000000000;;	// Invoking this method to get host tags is risky since it depends on the format
0000000000000000000000000000000000000000;;	// of the host names in the cluster. Only use it as a fallback if gce.nodeTags
0000000000000000000000000000000000000000;;	// is unspecified
0000000000000000000000000000000000000000;;	func (gce *GCECloud) computeHostTags(hosts []*gceInstance) ([]string, error) {
0000000000000000000000000000000000000000;;		// TODO: We could store the tags in gceInstance, so we could have already fetched it
0000000000000000000000000000000000000000;;		hostNamesByZone := make(map[string]map[string]bool) // map of zones -> map of names -> bool (for easy lookup)
0000000000000000000000000000000000000000;;		nodeInstancePrefix := gce.nodeInstancePrefix
0000000000000000000000000000000000000000;;		for _, host := range hosts {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(host.Name, gce.nodeInstancePrefix) {
0000000000000000000000000000000000000000;;				glog.Warningf("instance '%s' does not conform to prefix '%s', ignoring filter", host, gce.nodeInstancePrefix)
0000000000000000000000000000000000000000;;				nodeInstancePrefix = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			z, ok := hostNamesByZone[host.Zone]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				z = make(map[string]bool)
0000000000000000000000000000000000000000;;				hostNamesByZone[host.Zone] = z
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			z[host.Name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tags := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for zone, hostNames := range hostNamesByZone {
0000000000000000000000000000000000000000;;			pageToken := ""
0000000000000000000000000000000000000000;;			page := 0
0000000000000000000000000000000000000000;;			for ; page == 0 || (pageToken != "" && page < maxPages); page++ {
0000000000000000000000000000000000000000;;				listCall := gce.service.Instances.List(gce.projectID, zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if nodeInstancePrefix != "" {
0000000000000000000000000000000000000000;;					// Add the filter for hosts
0000000000000000000000000000000000000000;;					listCall = listCall.Filter("name eq " + nodeInstancePrefix + ".*")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Add the fields we want
0000000000000000000000000000000000000000;;				// TODO(zmerlynn): Internal bug 29524655
0000000000000000000000000000000000000000;;				// listCall = listCall.Fields("items(name,tags)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if pageToken != "" {
0000000000000000000000000000000000000000;;					listCall = listCall.PageToken(pageToken)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				res, err := listCall.Do()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pageToken = res.NextPageToken
0000000000000000000000000000000000000000;;				for _, instance := range res.Items {
0000000000000000000000000000000000000000;;					if !hostNames[instance.Name] {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					longest_tag := ""
0000000000000000000000000000000000000000;;					for _, tag := range instance.Tags.Items {
0000000000000000000000000000000000000000;;						if strings.HasPrefix(instance.Name, tag) && len(tag) > len(longest_tag) {
0000000000000000000000000000000000000000;;							longest_tag = tag
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(longest_tag) > 0 {
0000000000000000000000000000000000000000;;						tags.Insert(longest_tag)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("Could not find any tag that is a prefix of instance name for instance %s", instance.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if page >= maxPages {
0000000000000000000000000000000000000000;;				glog.Errorf("computeHostTags exceeded maxPages=%d for Instances.List: truncating.", maxPages)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tags) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No instances found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tags.List(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNodeTags will first try returning the list of tags specified in GCE cloud Configuration.
0000000000000000000000000000000000000000;;	// If they weren't provided, it'll compute the host tags with the given hostnames. If the list
0000000000000000000000000000000000000000;;	// of hostnames has not changed, a cached set of nodetags are returned.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) GetNodeTags(nodeNames []string) ([]string, error) {
0000000000000000000000000000000000000000;;		// If nodeTags were specified through configuration, use them
0000000000000000000000000000000000000000;;		if len(gce.nodeTags) > 0 {
0000000000000000000000000000000000000000;;			return gce.nodeTags, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gce.computeNodeTagLock.Lock()
0000000000000000000000000000000000000000;;		defer gce.computeNodeTagLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Early return if hosts have not changed
0000000000000000000000000000000000000000;;		hosts := sets.NewString(nodeNames...)
0000000000000000000000000000000000000000;;		if hosts.Equal(gce.lastKnownNodeNames) {
0000000000000000000000000000000000000000;;			return gce.lastComputedNodeTags, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get GCE instance data by hostname
0000000000000000000000000000000000000000;;		instances, err := gce.getInstancesByNames(nodeNames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine list of host tags
0000000000000000000000000000000000000000;;		tags, err := gce.computeHostTags(instances)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the list of tags
0000000000000000000000000000000000000000;;		gce.lastKnownNodeNames = hosts
0000000000000000000000000000000000000000;;		gce.lastComputedNodeTags = tags
0000000000000000000000000000000000000000;;		return tags, nil
0000000000000000000000000000000000000000;;	}
