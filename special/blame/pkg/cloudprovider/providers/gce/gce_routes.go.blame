0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9a3e3fac5acb000ea4977a0e92d5b6e96ddd1f63;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRoutesMetricContext(request string) *metricContext {
0000000000000000000000000000000000000000;;		return &metricContext{
0000000000000000000000000000000000000000;;			start:      time.Now(),
0000000000000000000000000000000000000000;;			attributes: []string{"routes_" + request, unusedMetricLabel, unusedMetricLabel},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ListRoutes(clusterName string) ([]*cloudprovider.Route, error) {
0000000000000000000000000000000000000000;;		var routes []*cloudprovider.Route
0000000000000000000000000000000000000000;;		pageToken := ""
0000000000000000000000000000000000000000;;		page := 0
0000000000000000000000000000000000000000;;		for ; page == 0 || (pageToken != "" && page < maxPages); page++ {
0000000000000000000000000000000000000000;;			mc := newRoutesMetricContext("list_page")
0000000000000000000000000000000000000000;;			listCall := gce.service.Routes.List(gce.projectID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			prefix := truncateClusterName(clusterName)
0000000000000000000000000000000000000000;;			listCall = listCall.Filter("name eq " + prefix + "-.*")
0000000000000000000000000000000000000000;;			if pageToken != "" {
0000000000000000000000000000000000000000;;				listCall = listCall.PageToken(pageToken)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res, err := listCall.Do()
0000000000000000000000000000000000000000;;			mc.Observe(err)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error getting routes from GCE: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pageToken = res.NextPageToken
0000000000000000000000000000000000000000;;			for _, r := range res.Items {
0000000000000000000000000000000000000000;;				if r.Network != gce.networkURL {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Not managed if route description != "k8s-node-route"
0000000000000000000000000000000000000000;;				if r.Description != k8sNodeRouteTag {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Not managed if route name doesn't start with <clusterName>
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(r.Name, prefix) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				target := path.Base(r.NextHopInstance)
0000000000000000000000000000000000000000;;				// TODO: Should we lastComponent(target) this?
0000000000000000000000000000000000000000;;				targetNodeName := types.NodeName(target) // NodeName == Instance Name on GCE
0000000000000000000000000000000000000000;;				routes = append(routes, &cloudprovider.Route{Name: r.Name, TargetNode: targetNodeName, DestinationCIDR: r.DestRange})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if page >= maxPages {
0000000000000000000000000000000000000000;;			glog.Errorf("ListRoutes exceeded maxPages=%d for Routes.List; truncating.", maxPages)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return routes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) CreateRoute(clusterName string, nameHint string, route *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		routeName := truncateClusterName(clusterName) + "-" + nameHint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instanceName := mapNodeNameToInstanceName(route.TargetNode)
0000000000000000000000000000000000000000;;		targetInstance, err := gce.getInstanceByName(instanceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mc := newRoutesMetricContext("create")
0000000000000000000000000000000000000000;;		insertOp, err := gce.service.Routes.Insert(gce.projectID, &compute.Route{
0000000000000000000000000000000000000000;;			Name:            routeName,
0000000000000000000000000000000000000000;;			DestRange:       route.DestinationCIDR,
0000000000000000000000000000000000000000;;			NextHopInstance: fmt.Sprintf("zones/%s/instances/%s", targetInstance.Zone, targetInstance.Name),
0000000000000000000000000000000000000000;;			Network:         gce.networkURL,
0000000000000000000000000000000000000000;;			Priority:        1000,
0000000000000000000000000000000000000000;;			Description:     k8sNodeRouteTag,
0000000000000000000000000000000000000000;;		}).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isHTTPErrorCode(err, http.StatusConflict) {
0000000000000000000000000000000000000000;;				glog.Infof("Route %v already exists.", routeName)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return mc.Observe(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gce.waitForGlobalOp(insertOp, mc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) DeleteRoute(clusterName string, route *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		mc := newRoutesMetricContext("delete")
0000000000000000000000000000000000000000;;		deleteOp, err := gce.service.Routes.Delete(gce.projectID, route.Name).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return mc.Observe(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gce.waitForGlobalOp(deleteOp, mc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func truncateClusterName(clusterName string) string {
0000000000000000000000000000000000000000;;		if len(clusterName) > 26 {
0000000000000000000000000000000000000000;;			return clusterName[:26]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clusterName
0000000000000000000000000000000000000000;;	}
