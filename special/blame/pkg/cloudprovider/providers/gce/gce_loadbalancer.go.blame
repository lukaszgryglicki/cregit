0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
aed27bebfe8ff8030751cd2cdcaf9eccd43373d4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		netsets "k8s.io/kubernetes/pkg/util/net/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cidrs struct {
0000000000000000000000000000000000000000;;		ipn   netsets.IPNet
0000000000000000000000000000000000000000;;		isSet bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		lbSrcRngsFlag cidrs
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLoadBalancerMetricContext(request, region string) *metricContext {
0000000000000000000000000000000000000000;;		return &metricContext{
0000000000000000000000000000000000000000;;			start:      time.Now(),
0000000000000000000000000000000000000000;;			attributes: []string{"loadbalancer_" + request, region, unusedMetricLabel},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lbScheme string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		schemeExternal lbScheme = "EXTERNAL"
0000000000000000000000000000000000000000;;		schemeInternal lbScheme = "INTERNAL"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// LB L7 proxies and all L3/4/7 health checkers have client addresses within these known CIDRs.
0000000000000000000000000000000000000000;;		lbSrcRngsFlag.ipn, err = netsets.ParseIPNets([]string{"130.211.0.0/22", "35.191.0.0/16", "209.85.152.0/22", "209.85.204.0/22"}...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("Incorrect default GCE L7 source ranges")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag.Var(&lbSrcRngsFlag, "cloud-provider-gce-lb-src-cidrs", "CIDRS opened in GCE firewall for LB traffic proxy & health checks")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String is the method to format the flag's value, part of the flag.Value interface.
0000000000000000000000000000000000000000;;	func (c *cidrs) String() string {
0000000000000000000000000000000000000000;;		return strings.Join(c.ipn.StringSlice(), ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set supports a value of CSV or the flag repeated multiple times
0000000000000000000000000000000000000000;;	func (c *cidrs) Set(value string) error {
0000000000000000000000000000000000000000;;		// On first Set(), clear the original defaults
0000000000000000000000000000000000000000;;		if !c.isSet {
0000000000000000000000000000000000000000;;			c.isSet = true
0000000000000000000000000000000000000000;;			c.ipn = make(netsets.IPNet)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Errorf("GCE LB CIDRS have already been set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cidr := range strings.Split(value, ",") {
0000000000000000000000000000000000000000;;			_, ipnet, err := net.ParseCIDR(cidr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.ipn.Insert(ipnet)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancerSrcRanges contains the ranges of ips used by the GCE load balancers (l4 & L7)
0000000000000000000000000000000000000000;;	// for proxying client requests and performing health checks.
0000000000000000000000000000000000000000;;	func LoadBalancerSrcRanges() []string {
0000000000000000000000000000000000000000;;		return lbSrcRngsFlag.ipn.StringSlice()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLoadBalancer is an implementation of LoadBalancer.GetLoadBalancer
0000000000000000000000000000000000000000;;	func (gce *GCECloud) GetLoadBalancer(clusterName string, svc *v1.Service) (*v1.LoadBalancerStatus, bool, error) {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(svc)
0000000000000000000000000000000000000000;;		fwd, err := gce.GetRegionForwardingRule(loadBalancerName, gce.region)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;			status.Ingress = []v1.LoadBalancerIngress{{IP: fwd.IPAddress}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return status, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, ignoreNotFound(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancer is an implementation of LoadBalancer.EnsureLoadBalancer.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) EnsureLoadBalancer(clusterName string, svc *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(svc)
0000000000000000000000000000000000000000;;		desiredScheme := getSvcScheme(svc)
0000000000000000000000000000000000000000;;		clusterID, err := gce.ClusterID.GetID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v): ensure %v loadbalancer", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region, desiredScheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingFwdRule, err := gce.GetRegionForwardingRule(loadBalancerName, gce.region)
0000000000000000000000000000000000000000;;		if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existingFwdRule != nil {
0000000000000000000000000000000000000000;;			existingScheme := lbScheme(strings.ToUpper(existingFwdRule.LoadBalancingScheme))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the loadbalancer type changes between INTERNAL and EXTERNAL, the old load balancer should be deleted.
0000000000000000000000000000000000000000;;			if existingScheme != desiredScheme {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v): deleting existing %v loadbalancer", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region, existingScheme)
0000000000000000000000000000000000000000;;				switch existingScheme {
0000000000000000000000000000000000000000;;				case schemeInternal:
0000000000000000000000000000000000000000;;					err = gce.ensureInternalLoadBalancerDeleted(clusterName, clusterID, svc)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					err = gce.ensureExternalLoadBalancerDeleted(clusterName, clusterID, svc)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v): done deleting existing %v loadbalancer. err: %v", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region, existingScheme, err)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var status *v1.LoadBalancerStatus
0000000000000000000000000000000000000000;;		switch desiredScheme {
0000000000000000000000000000000000000000;;		case schemeInternal:
0000000000000000000000000000000000000000;;			status, err = gce.ensureInternalLoadBalancer(clusterName, clusterID, svc, existingFwdRule, nodes)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			status, err = gce.ensureExternalLoadBalancer(clusterName, clusterID, svc, existingFwdRule, nodes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v): done ensuring loadbalancer. err: %v", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region, err)
0000000000000000000000000000000000000000;;		return status, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateLoadBalancer is an implementation of LoadBalancer.UpdateLoadBalancer.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) UpdateLoadBalancer(clusterName string, svc *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(svc)
0000000000000000000000000000000000000000;;		scheme := getSvcScheme(svc)
0000000000000000000000000000000000000000;;		clusterID, err := gce.ClusterID.GetID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("UpdateLoadBalancer(%v, %v, %v, %v, %v): updating with %d nodes", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region, len(nodes))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch scheme {
0000000000000000000000000000000000000000;;		case schemeInternal:
0000000000000000000000000000000000000000;;			err = gce.updateInternalLoadBalancer(clusterName, clusterID, svc, nodes)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = gce.updateExternalLoadBalancer(clusterName, svc, nodes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("UpdateLoadBalancer(%v, %v, %v, %v, %v): done updating. err: %v", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region, err)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancerDeleted is an implementation of LoadBalancer.EnsureLoadBalancerDeleted.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) EnsureLoadBalancerDeleted(clusterName string, svc *v1.Service) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(svc)
0000000000000000000000000000000000000000;;		scheme := getSvcScheme(svc)
0000000000000000000000000000000000000000;;		clusterID, err := gce.ClusterID.GetID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancerDeleted(%v, %v, %v, %v, %v): deleting loadbalancer", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch scheme {
0000000000000000000000000000000000000000;;		case schemeInternal:
0000000000000000000000000000000000000000;;			err = gce.ensureInternalLoadBalancerDeleted(clusterName, clusterID, svc)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = gce.ensureExternalLoadBalancerDeleted(clusterName, clusterID, svc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancerDeleted(%v, %v, %v, %v, %v): done deleting loadbalancer. err: %v", clusterName, svc.Namespace, svc.Name, loadBalancerName, gce.region, err)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSvcScheme(svc *v1.Service) lbScheme {
0000000000000000000000000000000000000000;;		if typ, ok := GetLoadBalancerAnnotationType(svc); ok && typ == LBTypeInternal {
0000000000000000000000000000000000000000;;			return schemeInternal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return schemeExternal
0000000000000000000000000000000000000000;;	}
