0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9a3e3fac5acb000ea4977a0e92d5b6e96ddd1f63;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) waitForOp(op *compute.Operation, getOperation func(operationName string) (*compute.Operation, error), mc *metricContext) error {
0000000000000000000000000000000000000000;;		if op == nil {
0000000000000000000000000000000000000000;;			return mc.Observe(fmt.Errorf("operation must not be nil"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opIsDone(op) {
0000000000000000000000000000000000000000;;			return getErrorFromOp(op)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opStart := time.Now()
0000000000000000000000000000000000000000;;		opName := op.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return wait.Poll(operationPollInterval, operationPollTimeoutDuration, func() (bool, error) {
0000000000000000000000000000000000000000;;			start := time.Now()
0000000000000000000000000000000000000000;;			gce.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			duration := time.Now().Sub(start)
0000000000000000000000000000000000000000;;			if duration > 5*time.Second {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("pollOperation: throttled %v for %v", duration, opName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pollOp, err := getOperation(opName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("GCE poll operation %s failed: pollOp: [%v] err: [%v] getErrorFromOp: [%v]",
0000000000000000000000000000000000000000;;					opName, pollOp, err, getErrorFromOp(pollOp))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			done := opIsDone(pollOp)
0000000000000000000000000000000000000000;;			if done {
0000000000000000000000000000000000000000;;				duration := time.Now().Sub(opStart)
0000000000000000000000000000000000000000;;				if duration > 1*time.Minute {
0000000000000000000000000000000000000000;;					// Log the JSON. It's cleaner than the %v structure.
0000000000000000000000000000000000000000;;					enc, err := pollOp.MarshalJSON()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Warningf("waitForOperation: long operation (%v): %v (failed to encode to JSON: %v)",
0000000000000000000000000000000000000000;;							duration, pollOp, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("waitForOperation: long operation (%v): %v",
0000000000000000000000000000000000000000;;							duration, string(enc))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return done, mc.Observe(getErrorFromOp(pollOp))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func opIsDone(op *compute.Operation) bool {
0000000000000000000000000000000000000000;;		return op != nil && op.Status == "DONE"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getErrorFromOp(op *compute.Operation) error {
0000000000000000000000000000000000000000;;		if op != nil && op.Error != nil && len(op.Error.Errors) > 0 {
0000000000000000000000000000000000000000;;			err := &googleapi.Error{
0000000000000000000000000000000000000000;;				Code:    int(op.HttpErrorStatusCode),
0000000000000000000000000000000000000000;;				Message: op.Error.Errors[0].Message,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("GCE operation failed: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) waitForGlobalOp(op *compute.Operation, mc *metricContext) error {
0000000000000000000000000000000000000000;;		return gce.waitForOp(op, func(operationName string) (*compute.Operation, error) {
0000000000000000000000000000000000000000;;			return gce.service.GlobalOperations.Get(gce.projectID, operationName).Do()
0000000000000000000000000000000000000000;;		}, mc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) waitForRegionOp(op *compute.Operation, region string, mc *metricContext) error {
0000000000000000000000000000000000000000;;		return gce.waitForOp(op, func(operationName string) (*compute.Operation, error) {
0000000000000000000000000000000000000000;;			return gce.service.RegionOperations.Get(gce.projectID, region, operationName).Do()
0000000000000000000000000000000000000000;;		}, mc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) waitForZoneOp(op *compute.Operation, zone string, mc *metricContext) error {
0000000000000000000000000000000000000000;;		return gce.waitForOp(op, func(operationName string) (*compute.Operation, error) {
0000000000000000000000000000000000000000;;			return gce.service.ZoneOperations.Get(gce.projectID, zone, operationName).Do()
0000000000000000000000000000000000000000;;		}, mc)
0000000000000000000000000000000000000000;;	}
