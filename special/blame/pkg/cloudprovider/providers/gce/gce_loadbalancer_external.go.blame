0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
9a3e3fac5acb000ea4977a0e92d5b6e96ddd1f63;pkg/cloudprovider/providers/gce/gce_loadbalancer.go[pkg/cloudprovider/providers/gce/gce_loadbalancer.go][pkg/cloudprovider/providers/gce/gce_loadbalancer_external.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		apiservice "k8s.io/kubernetes/pkg/api/v1/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		netsets "k8s.io/kubernetes/pkg/util/net/sets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		compute "google.golang.org/api/compute/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureExternalLoadBalancer is the external implementation of LoadBalancer.EnsureLoadBalancer.
0000000000000000000000000000000000000000;;	// Our load balancers in GCE consist of four separate GCE resources - a static
0000000000000000000000000000000000000000;;	// IP address, a firewall rule, a target pool, and a forwarding rule. This
0000000000000000000000000000000000000000;;	// function has to manage all of them.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Due to an interesting series of design decisions, this handles both creating
0000000000000000000000000000000000000000;;	// new load balancers and updating existing load balancers, recognizing when
0000000000000000000000000000000000000000;;	// each is needed.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureExternalLoadBalancer(clusterName, clusterID string, apiService *v1.Service, existingFwdRule *compute.ForwardingRule, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		if len(nodes) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Cannot EnsureLoadBalancer() with no hosts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostNames := nodeNames(nodes)
0000000000000000000000000000000000000000;;		supportsNodesHealthCheck := supportsNodesHealthCheck(nodes)
0000000000000000000000000000000000000000;;		hosts, err := gce.getInstancesByNames(hostNames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(apiService)
0000000000000000000000000000000000000000;;		loadBalancerIP := apiService.Spec.LoadBalancerIP
0000000000000000000000000000000000000000;;		ports := apiService.Spec.Ports
0000000000000000000000000000000000000000;;		portStr := []string{}
0000000000000000000000000000000000000000;;		for _, p := range apiService.Spec.Ports {
0000000000000000000000000000000000000000;;			portStr = append(portStr, fmt.Sprintf("%s/%d", p.Protocol, p.Port))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		affinityType := apiService.Spec.SessionAffinity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceName := types.NamespacedName{Namespace: apiService.Namespace, Name: apiService.Name}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v, %v, %v)",
0000000000000000000000000000000000000000;;			loadBalancerName, gce.region, loadBalancerIP, portStr, hostNames, serviceName, apiService.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the forwarding rule exists, and if so, what its IP is.
0000000000000000000000000000000000000000;;		fwdRuleExists, fwdRuleNeedsUpdate, fwdRuleIP, err := gce.forwardingRuleNeedsUpdate(loadBalancerName, gce.region, loadBalancerIP, ports)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fwdRuleExists {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Forwarding rule %v for Service %v/%v doesn't exist",
0000000000000000000000000000000000000000;;				loadBalancerName, apiService.Namespace, apiService.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we know which IP address will be used and have properly reserved
0000000000000000000000000000000000000000;;		// it as static before moving forward with the rest of our operations.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We use static IP addresses when updating a load balancer to ensure that we
0000000000000000000000000000000000000000;;		// can replace the load balancer's other components without changing the
0000000000000000000000000000000000000000;;		// address its service is reachable on. We do it this way rather than always
0000000000000000000000000000000000000000;;		// keeping the static IP around even though this is more complicated because
0000000000000000000000000000000000000000;;		// it makes it less likely that we'll run into quota issues. Only 7 static
0000000000000000000000000000000000000000;;		// IP addresses are allowed per region by default.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We could let an IP be allocated for us when the forwarding rule is created,
0000000000000000000000000000000000000000;;		// but we need the IP to set up the firewall rule, and we want to keep the
0000000000000000000000000000000000000000;;		// forwarding rule creation as the last thing that needs to be done in this
0000000000000000000000000000000000000000;;		// function in order to maintain the invariant that "if the forwarding rule
0000000000000000000000000000000000000000;;		// exists, the LB has been fully created".
0000000000000000000000000000000000000000;;		ipAddress := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Through this process we try to keep track of whether it is safe to
0000000000000000000000000000000000000000;;		// release the IP that was allocated.  If the user specifically asked for
0000000000000000000000000000000000000000;;		// an IP, we assume they are managing it themselves.  Otherwise, we will
0000000000000000000000000000000000000000;;		// release the IP in case of early-terminating failure or upon successful
0000000000000000000000000000000000000000;;		// creating of the LB.
0000000000000000000000000000000000000000;;		// TODO(#36535): boil this logic down into a set of component functions
0000000000000000000000000000000000000000;;		// and key the flag values off of errors returned.
0000000000000000000000000000000000000000;;		isUserOwnedIP := false // if this is set, we never release the IP
0000000000000000000000000000000000000000;;		isSafeToReleaseIP := false
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if isUserOwnedIP {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isSafeToReleaseIP {
0000000000000000000000000000000000000000;;				if err := gce.DeleteRegionAddress(loadBalancerName, gce.region); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to release static IP %s for load balancer (%v(%v), %v): %v", ipAddress, loadBalancerName, serviceName, gce.region, err)
0000000000000000000000000000000000000000;;				} else if isNotFound(err) {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("EnsureLoadBalancer(%v(%v)): address %s is not reserved.", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("EnsureLoadBalancer(%v(%v)): released static IP %s", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Warningf("orphaning static IP %s during update of load balancer (%v(%v), %v): %v", ipAddress, loadBalancerName, serviceName, gce.region, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if loadBalancerIP != "" {
0000000000000000000000000000000000000000;;			// If a specific IP address has been requested, we have to respect the
0000000000000000000000000000000000000000;;			// user's request and use that IP. If the forwarding rule was already using
0000000000000000000000000000000000000000;;			// a different IP, it will be harmlessly abandoned because it was only an
0000000000000000000000000000000000000000;;			// ephemeral IP (or it was a different static IP owned by the user, in which
0000000000000000000000000000000000000000;;			// case we shouldn't delete it anyway).
0000000000000000000000000000000000000000;;			if isStatic, err := gce.projectOwnsStaticIP(loadBalancerName, gce.region, loadBalancerIP); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to test if this GCE project owns the static IP %s: %v", loadBalancerIP, err)
0000000000000000000000000000000000000000;;			} else if isStatic {
0000000000000000000000000000000000000000;;				// The requested IP is a static IP, owned and managed by the user.
0000000000000000000000000000000000000000;;				isUserOwnedIP = true
0000000000000000000000000000000000000000;;				isSafeToReleaseIP = false
0000000000000000000000000000000000000000;;				ipAddress = loadBalancerIP
0000000000000000000000000000000000000000;;				glog.V(4).Infof("EnsureLoadBalancer(%v(%v)): using user-provided static IP %s", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;			} else if loadBalancerIP == fwdRuleIP {
0000000000000000000000000000000000000000;;				// The requested IP is not a static IP, but is currently assigned
0000000000000000000000000000000000000000;;				// to this forwarding rule, so we can keep it.
0000000000000000000000000000000000000000;;				isUserOwnedIP = false
0000000000000000000000000000000000000000;;				isSafeToReleaseIP = true
0000000000000000000000000000000000000000;;				ipAddress, _, err = gce.ensureStaticIP(loadBalancerName, serviceName.String(), gce.region, fwdRuleIP)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("failed to ensure static IP %s: %v", fwdRuleIP, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("EnsureLoadBalancer(%v(%v)): using user-provided non-static IP %s", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// The requested IP is not static and it is not assigned to the
0000000000000000000000000000000000000000;;				// current forwarding rule.  It might be attached to a different
0000000000000000000000000000000000000000;;				// rule or it might not be part of this project at all.  Either
0000000000000000000000000000000000000000;;				// way, we can't use it.
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("requested ip %s is neither static nor assigned to LB %s(%v): %v", loadBalancerIP, loadBalancerName, serviceName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The user did not request a specific IP.
0000000000000000000000000000000000000000;;			isUserOwnedIP = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This will either allocate a new static IP if the forwarding rule didn't
0000000000000000000000000000000000000000;;			// already have an IP, or it will promote the forwarding rule's current
0000000000000000000000000000000000000000;;			// IP from ephemeral to static, or it will just get the IP if it is
0000000000000000000000000000000000000000;;			// already static.
0000000000000000000000000000000000000000;;			existed := false
0000000000000000000000000000000000000000;;			ipAddress, existed, err = gce.ensureStaticIP(loadBalancerName, serviceName.String(), gce.region, fwdRuleIP)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to ensure static IP %s: %v", fwdRuleIP, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if existed {
0000000000000000000000000000000000000000;;				// If the IP was not specifically requested by the user, but it
0000000000000000000000000000000000000000;;				// already existed, it seems to be a failed update cycle.  We can
0000000000000000000000000000000000000000;;				// use this IP and try to run through the process again, but we
0000000000000000000000000000000000000000;;				// should not release the IP unless it is explicitly flagged as OK.
0000000000000000000000000000000000000000;;				isSafeToReleaseIP = false
0000000000000000000000000000000000000000;;				glog.V(4).Infof("EnsureLoadBalancer(%v(%v)): adopting static IP %s", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// For total clarity.  The IP did not pre-exist and the user did
0000000000000000000000000000000000000000;;				// not ask for a particular one, so we can release the IP in case
0000000000000000000000000000000000000000;;				// of failure or success.
0000000000000000000000000000000000000000;;				isSafeToReleaseIP = true
0000000000000000000000000000000000000000;;				glog.V(4).Infof("EnsureLoadBalancer(%v(%v)): allocated static IP %s", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deal with the firewall next. The reason we do this here rather than last
0000000000000000000000000000000000000000;;		// is because the forwarding rule is used as the indicator that the load
0000000000000000000000000000000000000000;;		// balancer is fully created - it's what getLoadBalancer checks for.
0000000000000000000000000000000000000000;;		// Check if user specified the allow source range
0000000000000000000000000000000000000000;;		sourceRanges, err := apiservice.GetLoadBalancerSourceRanges(apiService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firewallExists, firewallNeedsUpdate, err := gce.firewallNeedsUpdate(loadBalancerName, serviceName.String(), gce.region, ipAddress, ports, sourceRanges)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if firewallNeedsUpdate {
0000000000000000000000000000000000000000;;			desc := makeFirewallDescription(serviceName.String(), ipAddress)
0000000000000000000000000000000000000000;;			// Unlike forwarding rules and target pools, firewalls can be updated
0000000000000000000000000000000000000000;;			// without needing to be deleted and recreated.
0000000000000000000000000000000000000000;;			if firewallExists {
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): updating firewall", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;				if err := gce.updateFirewall(makeFirewallName(loadBalancerName), gce.region, desc, sourceRanges, ports, hosts); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): updated firewall", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): creating firewall", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;				if err := gce.createFirewall(makeFirewallName(loadBalancerName), gce.region, desc, sourceRanges, ports, hosts); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): created firewall", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tpExists, tpNeedsUpdate, err := gce.targetPoolNeedsUpdate(loadBalancerName, gce.region, affinityType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !tpExists {
0000000000000000000000000000000000000000;;			glog.Infof("Target pool %v for Service %v/%v doesn't exist", loadBalancerName, apiService.Namespace, apiService.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check which health check needs to create and which health check needs to delete.
0000000000000000000000000000000000000000;;		// Health check management is coupled with target pool operation to prevent leaking.
0000000000000000000000000000000000000000;;		var hcToCreate, hcToDelete *compute.HttpHealthCheck
0000000000000000000000000000000000000000;;		hcLocalTrafficExisting, err := gce.GetHttpHealthCheck(loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil && !isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error checking HTTP health check %s: %v", loadBalancerName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if path, healthCheckNodePort := apiservice.GetServiceHealthCheckPathPort(apiService); path != "" {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("service %v (%v) needs local traffic health checks on: %d%s)", apiService.Name, loadBalancerName, healthCheckNodePort, path)
0000000000000000000000000000000000000000;;			if hcLocalTrafficExisting == nil {
0000000000000000000000000000000000000000;;				// This logic exists to detect a transition for non-OnlyLocal to OnlyLocal service
0000000000000000000000000000000000000000;;				// turn on the tpNeedsUpdate flag to delete/recreate fwdrule/tpool updating the
0000000000000000000000000000000000000000;;				// target pool to use local traffic health check.
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Updating from nodes health checks to local traffic health checks for service %v LB %v", apiService.Name, loadBalancerName)
0000000000000000000000000000000000000000;;				if supportsNodesHealthCheck {
0000000000000000000000000000000000000000;;					hcToDelete = makeHttpHealthCheck(makeNodesHealthCheckName(clusterID), GetNodesHealthCheckPath(), GetNodesHealthCheckPort())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tpNeedsUpdate = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hcToCreate = makeHttpHealthCheck(loadBalancerName, path, healthCheckNodePort)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Service %v needs nodes health checks.", apiService.Name)
0000000000000000000000000000000000000000;;			if hcLocalTrafficExisting != nil {
0000000000000000000000000000000000000000;;				// This logic exists to detect a transition from OnlyLocal to non-OnlyLocal service
0000000000000000000000000000000000000000;;				// and turn on the tpNeedsUpdate flag to delete/recreate fwdrule/tpool updating the
0000000000000000000000000000000000000000;;				// target pool to use nodes health check.
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Updating from local traffic health checks to nodes health checks for service %v LB %v", apiService.Name, loadBalancerName)
0000000000000000000000000000000000000000;;				hcToDelete = hcLocalTrafficExisting
0000000000000000000000000000000000000000;;				tpNeedsUpdate = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if supportsNodesHealthCheck {
0000000000000000000000000000000000000000;;				hcToCreate = makeHttpHealthCheck(makeNodesHealthCheckName(clusterID), GetNodesHealthCheckPath(), GetNodesHealthCheckPort())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Now we get to some slightly more interesting logic.
0000000000000000000000000000000000000000;;		// First, neither target pools nor forwarding rules can be updated in place -
0000000000000000000000000000000000000000;;		// they have to be deleted and recreated.
0000000000000000000000000000000000000000;;		// Second, forwarding rules are layered on top of target pools in that you
0000000000000000000000000000000000000000;;		// can't delete a target pool that's currently in use by a forwarding rule.
0000000000000000000000000000000000000000;;		// Thus, we have to tear down the forwarding rule if either it or the target
0000000000000000000000000000000000000000;;		// pool needs to be updated.
0000000000000000000000000000000000000000;;		if fwdRuleExists && (fwdRuleNeedsUpdate || tpNeedsUpdate) {
0000000000000000000000000000000000000000;;			// Begin critical section. If we have to delete the forwarding rule,
0000000000000000000000000000000000000000;;			// and something should fail before we recreate it, don't release the
0000000000000000000000000000000000000000;;			// IP.  That way we can come back to it later.
0000000000000000000000000000000000000000;;			isSafeToReleaseIP = false
0000000000000000000000000000000000000000;;			if err := gce.DeleteRegionForwardingRule(loadBalancerName, gce.region); err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to delete existing forwarding rule %s for load balancer update: %v", loadBalancerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("EnsureLoadBalancer(%v(%v)): deleted forwarding rule", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tpExists && tpNeedsUpdate {
0000000000000000000000000000000000000000;;			// Pass healthchecks to DeleteExternalTargetPoolAndChecks to cleanup health checks after cleaning up the target pool itself.
0000000000000000000000000000000000000000;;			var hcNames []string
0000000000000000000000000000000000000000;;			if hcToDelete != nil {
0000000000000000000000000000000000000000;;				hcNames = append(hcNames, hcToDelete.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := gce.DeleteExternalTargetPoolAndChecks(loadBalancerName, gce.region, clusterID, hcNames...); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to delete existing target pool %s for load balancer update: %v", loadBalancerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("EnsureLoadBalancer(%v(%v)): deleted target pool", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Once we've deleted the resources (if necessary), build them back up (or for
0000000000000000000000000000000000000000;;		// the first time if they're new).
0000000000000000000000000000000000000000;;		if tpNeedsUpdate {
0000000000000000000000000000000000000000;;			createInstances := hosts
0000000000000000000000000000000000000000;;			if len(hosts) > maxTargetPoolCreateInstances {
0000000000000000000000000000000000000000;;				createInstances = createInstances[:maxTargetPoolCreateInstances]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Pass healthchecks to createTargetPool which needs them as health check links in the target pool
0000000000000000000000000000000000000000;;			if err := gce.createTargetPool(loadBalancerName, serviceName.String(), ipAddress, gce.region, clusterID, createInstances, affinityType, hcToCreate); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to create target pool %s: %v", loadBalancerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hcToCreate != nil {
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): created health checks %v for target pool", loadBalancerName, serviceName, hcToCreate.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(hosts) <= maxTargetPoolCreateInstances {
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): created target pool", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): created initial target pool (now updating with %d hosts)", loadBalancerName, serviceName, len(hosts)-maxTargetPoolCreateInstances)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				created := sets.NewString()
0000000000000000000000000000000000000000;;				for _, host := range createInstances {
0000000000000000000000000000000000000000;;					created.Insert(host.makeComparableHostPath())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := gce.updateTargetPool(loadBalancerName, created, hosts); err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("failed to update target pool %s: %v", loadBalancerName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("EnsureLoadBalancer(%v(%v)): updated target pool (with %d hosts)", loadBalancerName, serviceName, len(hosts)-maxTargetPoolCreateInstances)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tpNeedsUpdate || fwdRuleNeedsUpdate {
0000000000000000000000000000000000000000;;			glog.Infof("EnsureLoadBalancer(%v(%v)): creating forwarding rule, IP %s", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;			if err := gce.createForwardingRule(loadBalancerName, serviceName.String(), gce.region, ipAddress, ports); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to create forwarding rule %s: %v", loadBalancerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// End critical section.  It is safe to release the static IP (which
0000000000000000000000000000000000000000;;			// just demotes it to ephemeral) now that it is attached.  In the case
0000000000000000000000000000000000000000;;			// of a user-requested IP, the "is user-owned" flag will be set,
0000000000000000000000000000000000000000;;			// preventing it from actually being released.
0000000000000000000000000000000000000000;;			isSafeToReleaseIP = true
0000000000000000000000000000000000000000;;			glog.Infof("EnsureLoadBalancer(%v(%v)): created forwarding rule, IP %s", loadBalancerName, serviceName, ipAddress)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		status.Ingress = []v1.LoadBalancerIngress{{IP: ipAddress}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateExternalLoadBalancer is the external implementation of LoadBalancer.UpdateLoadBalancer.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) updateExternalLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		hosts, err := gce.getInstancesByNames(nodeNames(nodes))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		pool, err := gce.service.TargetPools.Get(gce.projectID, gce.region, loadBalancerName).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existing := sets.NewString()
0000000000000000000000000000000000000000;;		for _, instance := range pool.Instances {
0000000000000000000000000000000000000000;;			existing.Insert(hostURLToComparablePath(instance))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gce.updateTargetPool(loadBalancerName, existing, hosts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureExternalLoadBalancerDeleted is the external implementation of LoadBalancer.EnsureLoadBalancerDeleted
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureExternalLoadBalancerDeleted(clusterName, clusterID string, service *v1.Service) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hcNames []string
0000000000000000000000000000000000000000;;		if path, _ := apiservice.GetServiceHealthCheckPathPort(service); path != "" {
0000000000000000000000000000000000000000;;			hcToDelete, err := gce.GetHttpHealthCheck(loadBalancerName)
0000000000000000000000000000000000000000;;			if err != nil && !isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				glog.Infof("Failed to retrieve health check %v:%v", loadBalancerName, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hcNames = append(hcNames, hcToDelete.Name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// EnsureLoadBalancerDeleted() could be triggered by changing service from
0000000000000000000000000000000000000000;;			// LoadBalancer type to others. In this case we have no idea whether it was
0000000000000000000000000000000000000000;;			// using local traffic health check or nodes health check. Attempt to delete
0000000000000000000000000000000000000000;;			// both to prevent leaking.
0000000000000000000000000000000000000000;;			hcNames = append(hcNames, loadBalancerName)
0000000000000000000000000000000000000000;;			hcNames = append(hcNames, makeNodesHealthCheckName(clusterID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs := utilerrors.AggregateGoroutines(
0000000000000000000000000000000000000000;;			func() error { return ignoreNotFound(gce.DeleteFirewall(makeFirewallName(loadBalancerName))) },
0000000000000000000000000000000000000000;;			// Even though we don't hold on to static IPs for load balancers, it's
0000000000000000000000000000000000000000;;			// possible that EnsureLoadBalancer left one around in a failed
0000000000000000000000000000000000000000;;			// creation/update attempt, so make sure we clean it up here just in case.
0000000000000000000000000000000000000000;;			func() error { return ignoreNotFound(gce.DeleteRegionAddress(loadBalancerName, gce.region)) },
0000000000000000000000000000000000000000;;			func() error {
0000000000000000000000000000000000000000;;				// The forwarding rule must be deleted before either the target pool can,
0000000000000000000000000000000000000000;;				// unfortunately, so we have to do these two serially.
0000000000000000000000000000000000000000;;				if err := ignoreNotFound(gce.DeleteRegionForwardingRule(loadBalancerName, gce.region)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := gce.DeleteExternalTargetPoolAndChecks(loadBalancerName, gce.region, clusterID, hcNames...); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if errs != nil {
0000000000000000000000000000000000000000;;			return utilerrors.Flatten(errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) DeleteExternalTargetPoolAndChecks(name, region, clusterID string, hcNames ...string) error {
0000000000000000000000000000000000000000;;		if err := gce.DeleteTargetPool(name, region); err != nil && isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;			glog.Infof("Target pool %s already deleted. Continuing to delete other resources.", name)
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to delete target pool %s, got error %s.", name, err.Error())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deletion of health checks is allowed only after the TargetPool reference is deleted
0000000000000000000000000000000000000000;;		for _, hcName := range hcNames {
0000000000000000000000000000000000000000;;			if err := func() error {
0000000000000000000000000000000000000000;;				// Check whether it is nodes health check, which has different name from the load-balancer.
0000000000000000000000000000000000000000;;				isNodesHealthCheck := hcName != name
0000000000000000000000000000000000000000;;				if isNodesHealthCheck {
0000000000000000000000000000000000000000;;					// Lock to prevent deleting necessary nodes health check before it gets attached
0000000000000000000000000000000000000000;;					// to target pool.
0000000000000000000000000000000000000000;;					gce.sharedResourceLock.Lock()
0000000000000000000000000000000000000000;;					defer gce.sharedResourceLock.Unlock()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.Infof("Deleting health check %v", hcName)
0000000000000000000000000000000000000000;;				if err := gce.DeleteHttpHealthCheck(hcName); err != nil {
0000000000000000000000000000000000000000;;					// Delete nodes health checks will fail if any other target pool is using it.
0000000000000000000000000000000000000000;;					if isInUsedByError(err) {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Health check %v is in used: %v.", hcName, err)
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					} else if !isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;						glog.Warningf("Failed to delete health check %v: %v", hcName, err)
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// StatusNotFound could happen when:
0000000000000000000000000000000000000000;;					// - This is the first attempt but we pass in a healthcheck that is already deleted
0000000000000000000000000000000000000000;;					//   to prevent leaking.
0000000000000000000000000000000000000000;;					// - This is the first attempt but user manually deleted the heathcheck.
0000000000000000000000000000000000000000;;					// - This is a retry and in previous round we failed to delete the healthcheck firewall
0000000000000000000000000000000000000000;;					//   after deleted the healthcheck.
0000000000000000000000000000000000000000;;					// We continue to delete the healthcheck firewall to prevent leaking.
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Health check %v is already deleted.", hcName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If health check is deleted without error, it means no load-balancer is using it.
0000000000000000000000000000000000000000;;				// So we should delete the health check firewall as well.
0000000000000000000000000000000000000000;;				fwName := MakeHealthCheckFirewallName(clusterID, hcName, isNodesHealthCheck)
0000000000000000000000000000000000000000;;				glog.Infof("Deleting firewall %v.", fwName)
0000000000000000000000000000000000000000;;				if err := gce.DeleteFirewall(fwName); err != nil {
0000000000000000000000000000000000000000;;					if isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Firewall %v is already deleted.", fwName)
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) createTargetPool(name, serviceName, ipAddress, region, clusterID string, hosts []*gceInstance, affinityType v1.ServiceAffinity, hc *compute.HttpHealthCheck) error {
0000000000000000000000000000000000000000;;		// health check management is coupled with targetPools to prevent leaks. A
0000000000000000000000000000000000000000;;		// target pool is the only thing that requires a health check, so we delete
0000000000000000000000000000000000000000;;		// associated checks on teardown, and ensure checks on setup.
0000000000000000000000000000000000000000;;		hcLinks := []string{}
0000000000000000000000000000000000000000;;		if hc != nil {
0000000000000000000000000000000000000000;;			// Check whether it is nodes health check, which has different name from the load-balancer.
0000000000000000000000000000000000000000;;			isNodesHealthCheck := hc.Name != name
0000000000000000000000000000000000000000;;			if isNodesHealthCheck {
0000000000000000000000000000000000000000;;				// Lock to prevent necessary nodes health check / firewall gets deleted.
0000000000000000000000000000000000000000;;				gce.sharedResourceLock.Lock()
0000000000000000000000000000000000000000;;				defer gce.sharedResourceLock.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !gce.OnXPN() {
0000000000000000000000000000000000000000;;				if err := gce.ensureHttpHealthCheckFirewall(serviceName, ipAddress, region, clusterID, hosts, hc.Name, int32(hc.Port), isNodesHealthCheck); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if hc, err = gce.ensureHttpHealthCheck(hc.Name, hc.RequestPath, int32(hc.Port)); err != nil || hc == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to ensure health check for %v port %d path %v: %v", name, hc.Port, hc.RequestPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hcLinks = append(hcLinks, hc.SelfLink)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var instances []string
0000000000000000000000000000000000000000;;		for _, host := range hosts {
0000000000000000000000000000000000000000;;			instances = append(instances, makeHostURL(gce.service.BasePath, gce.projectID, host.Zone, host.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Creating targetpool %v with %d healthchecks", name, len(hcLinks))
0000000000000000000000000000000000000000;;		pool := &compute.TargetPool{
0000000000000000000000000000000000000000;;			Name:            name,
0000000000000000000000000000000000000000;;			Description:     fmt.Sprintf(`{"kubernetes.io/service-name":"%s"}`, serviceName),
0000000000000000000000000000000000000000;;			Instances:       instances,
0000000000000000000000000000000000000000;;			SessionAffinity: translateAffinityType(affinityType),
0000000000000000000000000000000000000000;;			HealthChecks:    hcLinks,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := gce.CreateTargetPool(pool, region); err != nil && !isHTTPErrorCode(err, http.StatusConflict) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) updateTargetPool(loadBalancerName string, existing sets.String, hosts []*gceInstance) error {
0000000000000000000000000000000000000000;;		var toAdd []*compute.InstanceReference
0000000000000000000000000000000000000000;;		var toRemove []*compute.InstanceReference
0000000000000000000000000000000000000000;;		for _, host := range hosts {
0000000000000000000000000000000000000000;;			link := host.makeComparableHostPath()
0000000000000000000000000000000000000000;;			if !existing.Has(link) {
0000000000000000000000000000000000000000;;				toAdd = append(toAdd, &compute.InstanceReference{Instance: link})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			existing.Delete(link)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for link := range existing {
0000000000000000000000000000000000000000;;			toRemove = append(toRemove, &compute.InstanceReference{Instance: link})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(toAdd) > 0 {
0000000000000000000000000000000000000000;;			if err := gce.AddInstancesToTargetPool(loadBalancerName, gce.region, toAdd); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(toRemove) > 0 {
0000000000000000000000000000000000000000;;			if err := gce.RemoveInstancesFromTargetPool(loadBalancerName, gce.region, toRemove); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to verify that the correct number of nodes are now in the target pool.
0000000000000000000000000000000000000000;;		// We've been bitten by a bug here before (#11327) where all nodes were
0000000000000000000000000000000000000000;;		// accidentally removed and want to make similar problems easier to notice.
0000000000000000000000000000000000000000;;		updatedPool, err := gce.GetTargetPool(loadBalancerName, gce.region)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(updatedPool.Instances) != len(hosts) {
0000000000000000000000000000000000000000;;			glog.Errorf("Unexpected number of instances (%d) in target pool %s after updating (expected %d). Instances in updated pool: %s",
0000000000000000000000000000000000000000;;				len(updatedPool.Instances), loadBalancerName, len(hosts), strings.Join(updatedPool.Instances, ","))
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unexpected number of instances (%d) in target pool %s after update (expected %d)", len(updatedPool.Instances), loadBalancerName, len(hosts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) targetPoolURL(name, region string) string {
0000000000000000000000000000000000000000;;		return gce.service.BasePath + strings.Join([]string{gce.projectID, "regions", region, "targetPools", name}, "/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeHttpHealthCheck(name, path string, port int32) *compute.HttpHealthCheck {
0000000000000000000000000000000000000000;;		return &compute.HttpHealthCheck{
0000000000000000000000000000000000000000;;			Name:               name,
0000000000000000000000000000000000000000;;			Port:               int64(port),
0000000000000000000000000000000000000000;;			RequestPath:        path,
0000000000000000000000000000000000000000;;			Host:               "",
0000000000000000000000000000000000000000;;			Description:        makeHealthCheckDescription(name),
0000000000000000000000000000000000000000;;			CheckIntervalSec:   gceHcCheckIntervalSeconds,
0000000000000000000000000000000000000000;;			TimeoutSec:         gceHcTimeoutSeconds,
0000000000000000000000000000000000000000;;			HealthyThreshold:   gceHcHealthyThreshold,
0000000000000000000000000000000000000000;;			UnhealthyThreshold: gceHcUnhealthyThreshold,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureHttpHealthCheck(name, path string, port int32) (hc *compute.HttpHealthCheck, err error) {
0000000000000000000000000000000000000000;;		newHC := makeHttpHealthCheck(name, path, port)
0000000000000000000000000000000000000000;;		hc, err = gce.GetHttpHealthCheck(name)
0000000000000000000000000000000000000000;;		if hc == nil || err != nil && isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;			glog.Infof("Did not find health check %v, creating port %v path %v", name, port, path)
0000000000000000000000000000000000000000;;			if err = gce.CreateHttpHealthCheck(newHC); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hc, err = gce.GetHttpHealthCheck(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to get http health check %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Created HTTP health check %v healthCheckNodePort: %d", name, port)
0000000000000000000000000000000000000000;;			return hc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Validate health check fields
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Checking http health check params %s", name)
0000000000000000000000000000000000000000;;		drift := hc.Port != int64(port) || hc.RequestPath != path || hc.Description != makeHealthCheckDescription(name)
0000000000000000000000000000000000000000;;		drift = drift || hc.CheckIntervalSec != gceHcCheckIntervalSeconds || hc.TimeoutSec != gceHcTimeoutSeconds
0000000000000000000000000000000000000000;;		drift = drift || hc.UnhealthyThreshold != gceHcUnhealthyThreshold || hc.HealthyThreshold != gceHcHealthyThreshold
0000000000000000000000000000000000000000;;		if drift {
0000000000000000000000000000000000000000;;			glog.Warningf("Health check %v exists but parameters have drifted - updating...", name)
0000000000000000000000000000000000000000;;			if err := gce.UpdateHttpHealthCheck(newHC); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to reconcile http health check %v parameters", name)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Corrected health check %v parameters successful", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Passing nil for requested IP is perfectly fine - it just means that no specific
0000000000000000000000000000000000000000;;	// IP is being requested.
0000000000000000000000000000000000000000;;	// Returns whether the forwarding rule exists, whether it needs to be updated,
0000000000000000000000000000000000000000;;	// what its IP address is (if it exists), and any error we encountered.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) forwardingRuleNeedsUpdate(name, region string, loadBalancerIP string, ports []v1.ServicePort) (exists bool, needsUpdate bool, ipAddress string, err error) {
0000000000000000000000000000000000000000;;		fwd, err := gce.service.ForwardingRules.Get(gce.projectID, region, name).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return false, true, "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Err on the side of caution in case of errors. Caller should notice the error and retry.
0000000000000000000000000000000000000000;;			// We never want to end up recreating resources because gce api flaked.
0000000000000000000000000000000000000000;;			return true, false, "", fmt.Errorf("error getting load balancer's forwarding rule: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the user asks for a specific static ip through the Service spec,
0000000000000000000000000000000000000000;;		// check that we're actually using it.
0000000000000000000000000000000000000000;;		// TODO: we report loadbalancer IP through status, so we want to verify if
0000000000000000000000000000000000000000;;		// that matches the forwarding rule as well.
0000000000000000000000000000000000000000;;		if loadBalancerIP != "" && loadBalancerIP != fwd.IPAddress {
0000000000000000000000000000000000000000;;			glog.Infof("LoadBalancer ip for forwarding rule %v was expected to be %v, but was actually %v", fwd.Name, fwd.IPAddress, loadBalancerIP)
0000000000000000000000000000000000000000;;			return true, true, fwd.IPAddress, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portRange, err := loadBalancerPortRange(ports)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Err on the side of caution in case of errors. Caller should notice the error and retry.
0000000000000000000000000000000000000000;;			// We never want to end up recreating resources because gce api flaked.
0000000000000000000000000000000000000000;;			return true, false, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if portRange != fwd.PortRange {
0000000000000000000000000000000000000000;;			glog.Infof("LoadBalancer port range for forwarding rule %v was expected to be %v, but was actually %v", fwd.Name, fwd.PortRange, portRange)
0000000000000000000000000000000000000000;;			return true, true, fwd.IPAddress, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The service controller verified all the protocols match on the ports, just check the first one
0000000000000000000000000000000000000000;;		if string(ports[0].Protocol) != fwd.IPProtocol {
0000000000000000000000000000000000000000;;			glog.Infof("LoadBalancer protocol for forwarding rule %v was expected to be %v, but was actually %v", fwd.Name, fwd.IPProtocol, string(ports[0].Protocol))
0000000000000000000000000000000000000000;;			return true, true, fwd.IPAddress, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, false, fwd.IPAddress, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Doesn't check whether the hosts have changed, since host updating is handled
0000000000000000000000000000000000000000;;	// separately.
0000000000000000000000000000000000000000;;	func (gce *GCECloud) targetPoolNeedsUpdate(name, region string, affinityType v1.ServiceAffinity) (exists bool, needsUpdate bool, err error) {
0000000000000000000000000000000000000000;;		tp, err := gce.service.TargetPools.Get(gce.projectID, region, name).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return false, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Err on the side of caution in case of errors. Caller should notice the error and retry.
0000000000000000000000000000000000000000;;			// We never want to end up recreating resources because gce api flaked.
0000000000000000000000000000000000000000;;			return true, false, fmt.Errorf("error getting load balancer's target pool: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: If the user modifies their Service's session affinity, it *should*
0000000000000000000000000000000000000000;;		// reflect in the associated target pool. However, currently not setting the
0000000000000000000000000000000000000000;;		// session affinity on a target pool defaults it to the empty string while
0000000000000000000000000000000000000000;;		// not setting in on a Service defaults it to None. There is a lack of
0000000000000000000000000000000000000000;;		// documentation around the default setting for the target pool, so if we
0000000000000000000000000000000000000000;;		// find it's the undocumented empty string, don't blindly recreate the
0000000000000000000000000000000000000000;;		// target pool (which results in downtime). Fix this when we have formally
0000000000000000000000000000000000000000;;		// defined the defaults on either side.
0000000000000000000000000000000000000000;;		if tp.SessionAffinity != "" && translateAffinityType(affinityType) != tp.SessionAffinity {
0000000000000000000000000000000000000000;;			glog.Infof("LoadBalancer target pool %v changed affinity from %v to %v", name, tp.SessionAffinity, affinityType)
0000000000000000000000000000000000000000;;			return true, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *gceInstance) makeComparableHostPath() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/zones/%s/instances/%s", h.Zone, h.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeNames(nodes []*v1.Node) []string {
0000000000000000000000000000000000000000;;		ret := make([]string, len(nodes))
0000000000000000000000000000000000000000;;		for i, node := range nodes {
0000000000000000000000000000000000000000;;			ret[i] = node.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeHostURL(projectsApiEndpoint, projectID, zone, host string) string {
0000000000000000000000000000000000000000;;		host = canonicalizeInstanceName(host)
0000000000000000000000000000000000000000;;		return projectsApiEndpoint + strings.Join([]string{projectID, "zones", zone, "instances", host}, "/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hostURLToComparablePath(hostURL string) string {
0000000000000000000000000000000000000000;;		idx := strings.Index(hostURL, "/zones/")
0000000000000000000000000000000000000000;;		if idx < 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hostURL[idx:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadBalancerPortRange(ports []v1.ServicePort) (string, error) {
0000000000000000000000000000000000000000;;		if len(ports) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no ports specified for GCE load balancer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The service controller verified all the protocols match on the ports, just check and use the first one
0000000000000000000000000000000000000000;;		if ports[0].Protocol != v1.ProtocolTCP && ports[0].Protocol != v1.ProtocolUDP {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Invalid protocol %s, only TCP and UDP are supported", string(ports[0].Protocol))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minPort := int32(65536)
0000000000000000000000000000000000000000;;		maxPort := int32(0)
0000000000000000000000000000000000000000;;		for i := range ports {
0000000000000000000000000000000000000000;;			if ports[i].Port < minPort {
0000000000000000000000000000000000000000;;				minPort = ports[i].Port
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ports[i].Port > maxPort {
0000000000000000000000000000000000000000;;				maxPort = ports[i].Port
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d-%d", minPort, maxPort), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// translate from what K8s supports to what the cloud provider supports for session affinity.
0000000000000000000000000000000000000000;;	func translateAffinityType(affinityType v1.ServiceAffinity) string {
0000000000000000000000000000000000000000;;		switch affinityType {
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityClientIP:
0000000000000000000000000000000000000000;;			return gceAffinityTypeClientIP
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityNone:
0000000000000000000000000000000000000000;;			return gceAffinityTypeNone
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			glog.Errorf("Unexpected affinity type: %v", affinityType)
0000000000000000000000000000000000000000;;			return gceAffinityTypeNone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) firewallNeedsUpdate(name, serviceName, region, ipAddress string, ports []v1.ServicePort, sourceRanges netsets.IPNet) (exists bool, needsUpdate bool, err error) {
0000000000000000000000000000000000000000;;		if gce.OnXPN() {
0000000000000000000000000000000000000000;;			glog.V(2).Infoln("firewallNeedsUpdate: Cluster is on XPN network - skipping firewall creation")
0000000000000000000000000000000000000000;;			return false, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw, err := gce.service.Firewalls.Get(gce.projectID, makeFirewallName(name)).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return false, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, false, fmt.Errorf("error getting load balancer's firewall: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fw.Description != makeFirewallDescription(serviceName, ipAddress) {
0000000000000000000000000000000000000000;;			return true, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fw.Allowed) != 1 || (fw.Allowed[0].IPProtocol != "tcp" && fw.Allowed[0].IPProtocol != "udp") {
0000000000000000000000000000000000000000;;			return true, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make sure the allowed ports match.
0000000000000000000000000000000000000000;;		allowedPorts := make([]string, len(ports))
0000000000000000000000000000000000000000;;		for ix := range ports {
0000000000000000000000000000000000000000;;			allowedPorts[ix] = strconv.Itoa(int(ports[ix].Port))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !equalStringSets(allowedPorts, fw.Allowed[0].Ports) {
0000000000000000000000000000000000000000;;			return true, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The service controller already verified that the protocol matches on all ports, no need to check.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualSourceRanges, err := netsets.ParseIPNets(fw.SourceRanges...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This really shouldn't happen... GCE has returned something unexpected
0000000000000000000000000000000000000000;;			glog.Warningf("Error parsing firewall SourceRanges: %v", fw.SourceRanges)
0000000000000000000000000000000000000000;;			// We don't return the error, because we can hopefully recover from this by reconfiguring the firewall
0000000000000000000000000000000000000000;;			return true, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !sourceRanges.Equal(actualSourceRanges) {
0000000000000000000000000000000000000000;;			return true, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureHttpHealthCheckFirewall(serviceName, ipAddress, region, clusterID string, hosts []*gceInstance, hcName string, hcPort int32, isNodesHealthCheck bool) error {
0000000000000000000000000000000000000000;;		// Prepare the firewall params for creating / checking.
0000000000000000000000000000000000000000;;		desc := fmt.Sprintf(`{"kubernetes.io/cluster-id":"%s"}`, clusterID)
0000000000000000000000000000000000000000;;		if !isNodesHealthCheck {
0000000000000000000000000000000000000000;;			desc = makeFirewallDescription(serviceName, ipAddress)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sourceRanges := lbSrcRngsFlag.ipn
0000000000000000000000000000000000000000;;		ports := []v1.ServicePort{{Protocol: "tcp", Port: hcPort}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fwName := MakeHealthCheckFirewallName(clusterID, hcName, isNodesHealthCheck)
0000000000000000000000000000000000000000;;		fw, err := gce.service.Firewalls.Get(gce.projectID, fwName).Do()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !isHTTPErrorCode(err, http.StatusNotFound) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error getting firewall for health checks: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Creating firewall %v for health checks.", fwName)
0000000000000000000000000000000000000000;;			if err := gce.createFirewall(fwName, region, desc, sourceRanges, ports, hosts); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Infof("Created firewall %v for health checks.", fwName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Validate firewall fields.
0000000000000000000000000000000000000000;;		if fw.Description != desc ||
0000000000000000000000000000000000000000;;			len(fw.Allowed) != 1 ||
0000000000000000000000000000000000000000;;			fw.Allowed[0].IPProtocol != string(ports[0].Protocol) ||
0000000000000000000000000000000000000000;;			!equalStringSets(fw.Allowed[0].Ports, []string{string(ports[0].Port)}) ||
0000000000000000000000000000000000000000;;			!equalStringSets(fw.SourceRanges, sourceRanges.StringSlice()) {
0000000000000000000000000000000000000000;;			glog.Warningf("Firewall %v exists but parameters have drifted - updating...", fwName)
0000000000000000000000000000000000000000;;			if err := gce.updateFirewall(fwName, region, desc, sourceRanges, ports, hosts); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to reconcile firewall %v parameters.", fwName)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Corrected firewall %v parameters successful", fwName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) createForwardingRule(name, serviceName, region, ipAddress string, ports []v1.ServicePort) error {
0000000000000000000000000000000000000000;;		portRange, err := loadBalancerPortRange(ports)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := &compute.ForwardingRule{
0000000000000000000000000000000000000000;;			Name:        name,
0000000000000000000000000000000000000000;;			Description: fmt.Sprintf(`{"kubernetes.io/service-name":"%s"}`, serviceName),
0000000000000000000000000000000000000000;;			IPAddress:   ipAddress,
0000000000000000000000000000000000000000;;			IPProtocol:  string(ports[0].Protocol),
0000000000000000000000000000000000000000;;			PortRange:   portRange,
0000000000000000000000000000000000000000;;			Target:      gce.targetPoolURL(name, region),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = gce.CreateRegionForwardingRule(req, region); err != nil && !isHTTPErrorCode(err, http.StatusConflict) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) createFirewall(name, region, desc string, sourceRanges netsets.IPNet, ports []v1.ServicePort, hosts []*gceInstance) error {
0000000000000000000000000000000000000000;;		firewall, err := gce.firewallObject(name, region, desc, sourceRanges, ports, hosts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = gce.CreateFirewall(firewall); err != nil && !isHTTPErrorCode(err, http.StatusConflict) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) updateFirewall(name, region, desc string, sourceRanges netsets.IPNet, ports []v1.ServicePort, hosts []*gceInstance) error {
0000000000000000000000000000000000000000;;		firewall, err := gce.firewallObject(name, region, desc, sourceRanges, ports, hosts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = gce.UpdateFirewall(firewall); err != nil && !isHTTPErrorCode(err, http.StatusConflict) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) firewallObject(name, region, desc string, sourceRanges netsets.IPNet, ports []v1.ServicePort, hosts []*gceInstance) (*compute.Firewall, error) {
0000000000000000000000000000000000000000;;		allowedPorts := make([]string, len(ports))
0000000000000000000000000000000000000000;;		for ix := range ports {
0000000000000000000000000000000000000000;;			allowedPorts[ix] = strconv.Itoa(int(ports[ix].Port))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the node tags to be used for this cluster have been predefined in the
0000000000000000000000000000000000000000;;		// provider config, just use them. Otherwise, invoke computeHostTags method to get the tags.
0000000000000000000000000000000000000000;;		hostTags := gce.nodeTags
0000000000000000000000000000000000000000;;		if len(hostTags) == 0 {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if hostTags, err = gce.computeHostTags(hosts); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("No node tags supplied and also failed to parse the given lists of hosts for tags. Abort creating firewall rule.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firewall := &compute.Firewall{
0000000000000000000000000000000000000000;;			Name:         name,
0000000000000000000000000000000000000000;;			Description:  desc,
0000000000000000000000000000000000000000;;			Network:      gce.networkURL,
0000000000000000000000000000000000000000;;			SourceRanges: sourceRanges.StringSlice(),
0000000000000000000000000000000000000000;;			TargetTags:   hostTags,
0000000000000000000000000000000000000000;;			Allowed: []*compute.FirewallAllowed{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					// TODO: Make this more generic. Currently this method is only
0000000000000000000000000000000000000000;;					// used to create firewall rules for loadbalancers, which have
0000000000000000000000000000000000000000;;					// exactly one protocol, so we can never end up with a list of
0000000000000000000000000000000000000000;;					// mixed TCP and UDP ports. It should be possible to use a
0000000000000000000000000000000000000000;;					// single firewall rule for both a TCP and UDP lb.
0000000000000000000000000000000000000000;;					IPProtocol: strings.ToLower(string(ports[0].Protocol)),
0000000000000000000000000000000000000000;;					Ports:      allowedPorts,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return firewall, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) projectOwnsStaticIP(name, region string, ipAddress string) (bool, error) {
0000000000000000000000000000000000000000;;		pageToken := ""
0000000000000000000000000000000000000000;;		page := 0
0000000000000000000000000000000000000000;;		for ; page == 0 || (pageToken != "" && page < maxPages); page++ {
0000000000000000000000000000000000000000;;			listCall := gce.service.Addresses.List(gce.projectID, region)
0000000000000000000000000000000000000000;;			if pageToken != "" {
0000000000000000000000000000000000000000;;				listCall = listCall.PageToken(pageToken)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addresses, err := listCall.Do()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("failed to list gce IP addresses: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pageToken = addresses.NextPageToken
0000000000000000000000000000000000000000;;			for _, addr := range addresses.Items {
0000000000000000000000000000000000000000;;				if addr.Address == ipAddress {
0000000000000000000000000000000000000000;;					// This project does own the address, so return success.
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if page >= maxPages {
0000000000000000000000000000000000000000;;			glog.Errorf("projectOwnsStaticIP exceeded maxPages=%d for Addresses.List; truncating.", maxPages)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gce *GCECloud) ensureStaticIP(name, serviceName, region, existingIP string) (ipAddress string, created bool, err error) {
0000000000000000000000000000000000000000;;		// If the address doesn't exist, this will create it.
0000000000000000000000000000000000000000;;		// If the existingIP exists but is ephemeral, this will promote it to static.
0000000000000000000000000000000000000000;;		// If the address already exists, this will harmlessly return a StatusConflict
0000000000000000000000000000000000000000;;		// and we'll grab the IP before returning.
0000000000000000000000000000000000000000;;		existed := false
0000000000000000000000000000000000000000;;		addressObj := &compute.Address{
0000000000000000000000000000000000000000;;			Name:        name,
0000000000000000000000000000000000000000;;			Description: fmt.Sprintf(`{"kubernetes.io/service-name":"%s"}`, serviceName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existingIP != "" {
0000000000000000000000000000000000000000;;			addressObj.Address = existingIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = gce.ReserveRegionAddress(addressObj, region); err != nil {
0000000000000000000000000000000000000000;;			if !isHTTPErrorCode(err, http.StatusConflict) {
0000000000000000000000000000000000000000;;				return "", false, fmt.Errorf("error creating gce static IP address: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// StatusConflict == the IP exists already.
0000000000000000000000000000000000000000;;			existed = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr, err := gce.GetRegionAddress(name, region)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", false, fmt.Errorf("error getting static IP address: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return addr.Address, existed, nil
0000000000000000000000000000000000000000;;	}
