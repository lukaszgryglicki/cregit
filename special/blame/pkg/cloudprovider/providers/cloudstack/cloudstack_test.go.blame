0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
36519cd78daa9cd9f5210eb78323309888b430dd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cloudstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const testClusterName = "testCluster"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		_, err := readConfig(nil)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Should fail when no config is provided: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg, err := readConfig(strings.NewReader(`
0000000000000000000000000000000000000000;;	 [Global]
0000000000000000000000000000000000000000;;	 api-url				= https://cloudstack.url
0000000000000000000000000000000000000000;;	 api-key				= a-valid-api-key
0000000000000000000000000000000000000000;;	 secret-key			= a-valid-secret-key
0000000000000000000000000000000000000000;;	 ssl-no-verify	= true
0000000000000000000000000000000000000000;;	 project-id			= a-valid-project-id
0000000000000000000000000000000000000000;;	 zone						= a-valid-zone
0000000000000000000000000000000000000000;;	 `))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Should succeed when a valid config is provided: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Global.APIURL != "https://cloudstack.url" {
0000000000000000000000000000000000000000;;			t.Errorf("incorrect api-url: %s", cfg.Global.APIURL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.APIKey != "a-valid-api-key" {
0000000000000000000000000000000000000000;;			t.Errorf("incorrect api-key: %s", cfg.Global.APIKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.SecretKey != "a-valid-secret-key" {
0000000000000000000000000000000000000000;;			t.Errorf("incorrect secret-key: %s", cfg.Global.SecretKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cfg.Global.SSLNoVerify {
0000000000000000000000000000000000000000;;			t.Errorf("incorrect ssl-no-verify: %t", cfg.Global.SSLNoVerify)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.Zone != "a-valid-zone" {
0000000000000000000000000000000000000000;;			t.Errorf("incorrect zone: %s", cfg.Global.Zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This allows acceptance testing against an existing CloudStack environment.
0000000000000000000000000000000000000000;;	func configFromEnv() (*CSConfig, bool) {
0000000000000000000000000000000000000000;;		cfg := &CSConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg.Global.APIURL = os.Getenv("CS_API_URL")
0000000000000000000000000000000000000000;;		cfg.Global.APIKey = os.Getenv("CS_API_KEY")
0000000000000000000000000000000000000000;;		cfg.Global.SecretKey = os.Getenv("CS_SECRET_KEY")
0000000000000000000000000000000000000000;;		cfg.Global.ProjectID = os.Getenv("CS_PROJECT_ID")
0000000000000000000000000000000000000000;;		cfg.Global.Zone = os.Getenv("CS_ZONE")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It is save to ignore the error here. If the input cannot be parsed SSLNoVerify
0000000000000000000000000000000000000000;;		// will still be a bool with its zero value (false) which is the expected default.
0000000000000000000000000000000000000000;;		cfg.Global.SSLNoVerify, _ = strconv.ParseBool(os.Getenv("CS_SSL_NO_VERIFY"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if we have the minimum required info to be able to connect to CloudStack.
0000000000000000000000000000000000000000;;		ok := cfg.Global.APIURL != "" && cfg.Global.APIKey != "" && cfg.Global.SecretKey != ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cfg, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewCSCloud(t *testing.T) {
0000000000000000000000000000000000000000;;		cfg, ok := configFromEnv()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Skipf("No config found in environment")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := newCSCloud(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to construct/authenticate CloudStack: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadBalancer(t *testing.T) {
0000000000000000000000000000000000000000;;		cfg, ok := configFromEnv()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Skipf("No config found in environment")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cs, err := newCSCloud(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to construct/authenticate CloudStack: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, ok := cs.LoadBalancer()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("LoadBalancer() returned false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, exists, err := lb.GetLoadBalancer(testClusterName, &v1.Service{ObjectMeta: metav1.ObjectMeta{Name: "noexist"}})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("GetLoadBalancer(\"noexist\") returned error: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Fatalf("GetLoadBalancer(\"noexist\") returned exists")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestZones(t *testing.T) {
0000000000000000000000000000000000000000;;		cs := &CSCloud{
0000000000000000000000000000000000000000;;			zone: "myRegion",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		z, ok := cs.Zones()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Zones() returned false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zone, err := z.GetZone()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("GetZone() returned error: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if zone.Region != "myRegion" {
0000000000000000000000000000000000000000;;			t.Fatalf("GetZone() returned wrong region (%s)", zone.Region)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
