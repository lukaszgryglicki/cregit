0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
36519cd78daa9cd9f5210eb78323309888b430dd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cloudstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/xanzy/go-cloudstack/cloudstack"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type loadBalancer struct {
0000000000000000000000000000000000000000;;		*cloudstack.CloudStackClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		algorithm string
0000000000000000000000000000000000000000;;		hostIDs   []string
0000000000000000000000000000000000000000;;		ipAddr    string
0000000000000000000000000000000000000000;;		ipAddrID  string
0000000000000000000000000000000000000000;;		networkID string
0000000000000000000000000000000000000000;;		projectID string
0000000000000000000000000000000000000000;;		rules     map[string]*cloudstack.LoadBalancerRule
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLoadBalancer returns whether the specified load balancer exists, and if so, what its status is.
0000000000000000000000000000000000000000;;	func (cs *CSCloud) GetLoadBalancer(clusterName string, service *v1.Service) (*v1.LoadBalancerStatus, bool, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("GetLoadBalancer(%v, %v, %v)", clusterName, service.Namespace, service.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the load balancer details and existing rules.
0000000000000000000000000000000000000000;;		lb, err := cs.getLoadBalancer(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we don't have any rules, the load balancer does not exist.
0000000000000000000000000000000000000000;;		if len(lb.rules) == 0 {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Found a load balancer associated with IP %v", lb.ipAddr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		status.Ingress = append(status.Ingress, v1.LoadBalancerIngress{IP: lb.ipAddr})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancer creates a new load balancer, or updates the existing one. Returns the status of the balancer.
0000000000000000000000000000000000000000;;	func (cs *CSCloud) EnsureLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) (status *v1.LoadBalancerStatus, err error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v, %v)", clusterName, service.Namespace, service.Name, service.Spec.LoadBalancerIP, service.Spec.Ports, nodes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(service.Spec.Ports) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("requested load balancer with no ports")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the load balancer details and existing rules.
0000000000000000000000000000000000000000;;		lb, err := cs.getLoadBalancer(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the load balancer algorithm.
0000000000000000000000000000000000000000;;		switch service.Spec.SessionAffinity {
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityNone:
0000000000000000000000000000000000000000;;			lb.algorithm = "roundrobin"
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityClientIP:
0000000000000000000000000000000000000000;;			lb.algorithm = "source"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported load balancer affinity: %v", service.Spec.SessionAffinity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that all the hosts belong to the same network, and retrieve their ID's.
0000000000000000000000000000000000000000;;		lb.hostIDs, lb.networkID, err = cs.verifyHosts(nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !lb.hasLoadBalancerIP() {
0000000000000000000000000000000000000000;;			// Create or retrieve the load balancer IP.
0000000000000000000000000000000000000000;;			if err := lb.getLoadBalancerIP(service.Spec.LoadBalancerIP); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if lb.ipAddr != "" && lb.ipAddr != service.Spec.LoadBalancerIP {
0000000000000000000000000000000000000000;;				defer func(lb *loadBalancer) {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if err := lb.releaseLoadBalancerIP(); err != nil {
0000000000000000000000000000000000000000;;							glog.Errorf(err.Error())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}(lb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Load balancer %v is associated with IP %v", lb.name, lb.ipAddr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, port := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			// All ports have their own load balancer rule, so add the port to lbName to keep the names unique.
0000000000000000000000000000000000000000;;			lbRuleName := fmt.Sprintf("%s-%d", lb.name, port.Port)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the load balancer rule exists and is up-to-date, we move on to the next rule.
0000000000000000000000000000000000000000;;			exists, needsUpdate, err := lb.checkLoadBalancerRule(lbRuleName, port)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exists && !needsUpdate {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Load balancer rule %v is up-to-date", lbRuleName)
0000000000000000000000000000000000000000;;				// Delete the rule from the map, to prevent it being deleted.
0000000000000000000000000000000000000000;;				delete(lb.rules, lbRuleName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if needsUpdate {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Updating load balancer rule: %v", lbRuleName)
0000000000000000000000000000000000000000;;				if err := lb.updateLoadBalancerRule(lbRuleName); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Delete the rule from the map, to prevent it being deleted.
0000000000000000000000000000000000000000;;				delete(lb.rules, lbRuleName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Creating load balancer rule: %v", lbRuleName)
0000000000000000000000000000000000000000;;			lbRule, err := lb.createLoadBalancerRule(lbRuleName, port)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Assigning hosts (%v) to load balancer rule: %v", lb.hostIDs, lbRuleName)
0000000000000000000000000000000000000000;;			if err = lb.assignHostsToRule(lbRule, lb.hostIDs); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cleanup any rules that are now still in the rules map, as they are no longer needed.
0000000000000000000000000000000000000000;;		for _, lbRule := range lb.rules {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Deleting obsolete load balancer rule: %v", lbRule.Name)
0000000000000000000000000000000000000000;;			if err := lb.deleteLoadBalancerRule(lbRule); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status = &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		status.Ingress = []v1.LoadBalancerIngress{{IP: lb.ipAddr}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateLoadBalancer updates hosts under the specified load balancer.
0000000000000000000000000000000000000000;;	func (cs *CSCloud) UpdateLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("UpdateLoadBalancer(%v, %v, %v, %v)", clusterName, service.Namespace, service.Name, nodes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the load balancer details and existing rules.
0000000000000000000000000000000000000000;;		lb, err := cs.getLoadBalancer(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that all the hosts belong to the same network, and retrieve their ID's.
0000000000000000000000000000000000000000;;		lb.hostIDs, _, err = cs.verifyHosts(nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, lbRule := range lb.rules {
0000000000000000000000000000000000000000;;			p := lb.LoadBalancer.NewListLoadBalancerRuleInstancesParams(lbRule.Id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Retrieve all VMs currently associated to this load balancer rule.
0000000000000000000000000000000000000000;;			l, err := lb.LoadBalancer.ListLoadBalancerRuleInstances(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error retrieving associated instances: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			assign, remove := symmetricDifference(lb.hostIDs, l.LoadBalancerRuleInstances)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(assign) > 0 {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Assigning new hosts (%v) to load balancer rule: %v", assign, lbRule.Name)
0000000000000000000000000000000000000000;;				if err := lb.assignHostsToRule(lbRule, assign); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(remove) > 0 {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Removing old hosts (%v) from load balancer rule: %v", assign, lbRule.Name)
0000000000000000000000000000000000000000;;				if err := lb.removeHostsFromRule(lbRule, remove); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancerDeleted deletes the specified load balancer if it exists, returning
0000000000000000000000000000000000000000;;	// nil if the load balancer specified either didn't exist or was successfully deleted.
0000000000000000000000000000000000000000;;	func (cs *CSCloud) EnsureLoadBalancerDeleted(clusterName string, service *v1.Service) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancerDeleted(%v, %v, %v)", clusterName, service.Namespace, service.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the load balancer details and existing rules.
0000000000000000000000000000000000000000;;		lb, err := cs.getLoadBalancer(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, lbRule := range lb.rules {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Deleting load balancer rule: %v", lbRule.Name)
0000000000000000000000000000000000000000;;			if err := lb.deleteLoadBalancerRule(lbRule); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb.ipAddr != "" && lb.ipAddr != service.Spec.LoadBalancerIP {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Releasing load balancer IP: %v", lb.ipAddr)
0000000000000000000000000000000000000000;;			if err := lb.releaseLoadBalancerIP(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLoadBalancer retrieves the IP address and ID and all the existing rules it can find.
0000000000000000000000000000000000000000;;	func (cs *CSCloud) getLoadBalancer(service *v1.Service) (*loadBalancer, error) {
0000000000000000000000000000000000000000;;		lb := &loadBalancer{
0000000000000000000000000000000000000000;;			CloudStackClient: cs.client,
0000000000000000000000000000000000000000;;			name:             cloudprovider.GetLoadBalancerName(service),
0000000000000000000000000000000000000000;;			projectID:        cs.projectID,
0000000000000000000000000000000000000000;;			rules:            make(map[string]*cloudstack.LoadBalancerRule),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := cs.client.LoadBalancer.NewListLoadBalancerRulesParams()
0000000000000000000000000000000000000000;;		p.SetKeyword(lb.name)
0000000000000000000000000000000000000000;;		p.SetListall(true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cs.projectID != "" {
0000000000000000000000000000000000000000;;			p.SetProjectid(cs.projectID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, err := cs.client.LoadBalancer.ListLoadBalancerRules(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error retrieving load balancer rules: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, lbRule := range l.LoadBalancerRules {
0000000000000000000000000000000000000000;;			lb.rules[lbRule.Name] = lbRule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if lb.ipAddr != "" && lb.ipAddr != lbRule.Publicip {
0000000000000000000000000000000000000000;;				glog.Warningf("Load balancer for service %v/%v has rules associated with different IP's: %v, %v", service.Namespace, service.Name, lb.ipAddr, lbRule.Publicip)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lb.ipAddr = lbRule.Publicip
0000000000000000000000000000000000000000;;			lb.ipAddrID = lbRule.Publicipid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Load balancer %v contains %d rule(s)", lb.name, len(lb.rules))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lb, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyHosts verifies if all hosts belong to the same network, and returns the host ID's and network ID.
0000000000000000000000000000000000000000;;	func (cs *CSCloud) verifyHosts(nodes []*v1.Node) ([]string, string, error) {
0000000000000000000000000000000000000000;;		hostNames := map[string]bool{}
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			hostNames[node.Name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := cs.client.VirtualMachine.NewListVirtualMachinesParams()
0000000000000000000000000000000000000000;;		p.SetListall(true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cs.projectID != "" {
0000000000000000000000000000000000000000;;			p.SetProjectid(cs.projectID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, err := cs.client.VirtualMachine.ListVirtualMachines(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf("error retrieving list of hosts: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hostIDs []string
0000000000000000000000000000000000000000;;		var networkID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the virtual machine is in the hosts slice, then add the corresponding ID.
0000000000000000000000000000000000000000;;		for _, vm := range l.VirtualMachines {
0000000000000000000000000000000000000000;;			if hostNames[vm.Name] {
0000000000000000000000000000000000000000;;				if networkID != "" && networkID != vm.Nic[0].Networkid {
0000000000000000000000000000000000000000;;					return nil, "", fmt.Errorf("found hosts that belong to different networks")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				networkID = vm.Nic[0].Networkid
0000000000000000000000000000000000000000;;				hostIDs = append(hostIDs, vm.Id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hostIDs, networkID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasLoadBalancerIP returns true if we have a load balancer address and ID.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) hasLoadBalancerIP() bool {
0000000000000000000000000000000000000000;;		return lb.ipAddr != "" && lb.ipAddrID != ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLoadBalancerIP retieves an existing IP or associates a new IP.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) getLoadBalancerIP(loadBalancerIP string) error {
0000000000000000000000000000000000000000;;		if loadBalancerIP != "" {
0000000000000000000000000000000000000000;;			return lb.getPublicIPAddress(loadBalancerIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lb.associatePublicIPAddress()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPublicIPAddressID retrieves the ID of the given IP, and sets the address and it's ID.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) getPublicIPAddress(loadBalancerIP string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Retrieve load balancer IP details: %v", loadBalancerIP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := lb.Address.NewListPublicIpAddressesParams()
0000000000000000000000000000000000000000;;		p.SetIpaddress(loadBalancerIP)
0000000000000000000000000000000000000000;;		p.SetListall(true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb.projectID != "" {
0000000000000000000000000000000000000000;;			p.SetProjectid(lb.projectID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, err := lb.Address.ListPublicIpAddresses(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error retrieving IP address: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.Count != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("could not find IP address %v", loadBalancerIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb.ipAddr = l.PublicIpAddresses[0].Ipaddress
0000000000000000000000000000000000000000;;		lb.ipAddrID = l.PublicIpAddresses[0].Id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// associatePublicIPAddress associates a new IP and sets the address and it's ID.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) associatePublicIPAddress() error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Allocate new IP for load balancer: %v", lb.name)
0000000000000000000000000000000000000000;;		// If a network belongs to a VPC, the IP address needs to be associated with
0000000000000000000000000000000000000000;;		// the VPC instead of with the network.
0000000000000000000000000000000000000000;;		network, count, err := lb.Network.GetNetworkByID(lb.networkID, cloudstack.WithProject(lb.projectID))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if count == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("could not find network %v", lb.networkID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("error retrieving network: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := lb.Address.NewAssociateIpAddressParams()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if network.Vpcid != "" {
0000000000000000000000000000000000000000;;			p.SetVpcid(network.Vpcid)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.SetNetworkid(lb.networkID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb.projectID != "" {
0000000000000000000000000000000000000000;;			p.SetProjectid(lb.projectID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Associate a new IP address
0000000000000000000000000000000000000000;;		r, err := lb.Address.AssociateIpAddress(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error associating new IP address: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb.ipAddr = r.Ipaddress
0000000000000000000000000000000000000000;;		lb.ipAddrID = r.Id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// releasePublicIPAddress releases an associated IP.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) releaseLoadBalancerIP() error {
0000000000000000000000000000000000000000;;		p := lb.Address.NewDisassociateIpAddressParams(lb.ipAddrID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := lb.Address.DisassociateIpAddress(p); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error releasing load balancer IP %v: %v", lb.ipAddr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkLoadBalancerRule checks if the rule already exists and if it does, if it can be updated. If
0000000000000000000000000000000000000000;;	// it does exist but cannot be updated, it will delete the existing rule so it can be created again.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) checkLoadBalancerRule(lbRuleName string, port v1.ServicePort) (bool, bool, error) {
0000000000000000000000000000000000000000;;		lbRule, ok := lb.rules[lbRuleName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if any of the values we cannot update (those that require a new load balancer rule) are changed.
0000000000000000000000000000000000000000;;		if lbRule.Publicip == lb.ipAddr && lbRule.Privateport == strconv.Itoa(int(port.NodePort)) && lbRule.Publicport == strconv.Itoa(int(port.Port)) {
0000000000000000000000000000000000000000;;			return true, lbRule.Algorithm != lb.algorithm, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the load balancer rule so we can create a new one using the new values.
0000000000000000000000000000000000000000;;		if err := lb.deleteLoadBalancerRule(lbRule); err != nil {
0000000000000000000000000000000000000000;;			return false, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateLoadBalancerRule updates a load balancer rule.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) updateLoadBalancerRule(lbRuleName string) error {
0000000000000000000000000000000000000000;;		lbRule := lb.rules[lbRuleName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := lb.LoadBalancer.NewUpdateLoadBalancerRuleParams(lbRule.Id)
0000000000000000000000000000000000000000;;		p.SetAlgorithm(lb.algorithm)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := lb.LoadBalancer.UpdateLoadBalancerRule(p)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createLoadBalancerRule creates a new load balancer rule and returns it's ID.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) createLoadBalancerRule(lbRuleName string, port v1.ServicePort) (*cloudstack.LoadBalancerRule, error) {
0000000000000000000000000000000000000000;;		p := lb.LoadBalancer.NewCreateLoadBalancerRuleParams(
0000000000000000000000000000000000000000;;			lb.algorithm,
0000000000000000000000000000000000000000;;			lbRuleName,
0000000000000000000000000000000000000000;;			int(port.NodePort),
0000000000000000000000000000000000000000;;			int(port.Port),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.SetNetworkid(lb.networkID)
0000000000000000000000000000000000000000;;		p.SetPublicipid(lb.ipAddrID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch port.Protocol {
0000000000000000000000000000000000000000;;		case v1.ProtocolTCP:
0000000000000000000000000000000000000000;;			p.SetProtocol("TCP")
0000000000000000000000000000000000000000;;		case v1.ProtocolUDP:
0000000000000000000000000000000000000000;;			p.SetProtocol("UDP")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported load balancer protocol: %v", port.Protocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not create corresponding firewall rule.
0000000000000000000000000000000000000000;;		p.SetOpenfirewall(false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new load balancer rule.
0000000000000000000000000000000000000000;;		r, err := lb.LoadBalancer.CreateLoadBalancerRule(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating load balancer rule %v: %v", lbRuleName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbRule := &cloudstack.LoadBalancerRule{
0000000000000000000000000000000000000000;;			Id:          r.Id,
0000000000000000000000000000000000000000;;			Algorithm:   r.Algorithm,
0000000000000000000000000000000000000000;;			Cidrlist:    r.Cidrlist,
0000000000000000000000000000000000000000;;			Name:        r.Name,
0000000000000000000000000000000000000000;;			Networkid:   r.Networkid,
0000000000000000000000000000000000000000;;			Privateport: r.Privateport,
0000000000000000000000000000000000000000;;			Publicport:  r.Publicport,
0000000000000000000000000000000000000000;;			Publicip:    r.Publicip,
0000000000000000000000000000000000000000;;			Publicipid:  r.Publicipid,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lbRule, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteLoadBalancerRule deletes a load balancer rule.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) deleteLoadBalancerRule(lbRule *cloudstack.LoadBalancerRule) error {
0000000000000000000000000000000000000000;;		p := lb.LoadBalancer.NewDeleteLoadBalancerRuleParams(lbRule.Id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := lb.LoadBalancer.DeleteLoadBalancerRule(p); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error deleting load balancer rule %v: %v", lbRule.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the rule from the map as it no longer exists
0000000000000000000000000000000000000000;;		delete(lb.rules, lbRule.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignHostsToRule assigns hosts to a load balancer rule.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) assignHostsToRule(lbRule *cloudstack.LoadBalancerRule, hostIDs []string) error {
0000000000000000000000000000000000000000;;		p := lb.LoadBalancer.NewAssignToLoadBalancerRuleParams(lbRule.Id)
0000000000000000000000000000000000000000;;		p.SetVirtualmachineids(hostIDs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := lb.LoadBalancer.AssignToLoadBalancerRule(p); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error assigning hosts to load balancer rule %v: %v", lbRule.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeHostsFromRule removes hosts from a load balancer rule.
0000000000000000000000000000000000000000;;	func (lb *loadBalancer) removeHostsFromRule(lbRule *cloudstack.LoadBalancerRule, hostIDs []string) error {
0000000000000000000000000000000000000000;;		p := lb.LoadBalancer.NewRemoveFromLoadBalancerRuleParams(lbRule.Id)
0000000000000000000000000000000000000000;;		p.SetVirtualmachineids(hostIDs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := lb.LoadBalancer.RemoveFromLoadBalancerRule(p); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error removing hosts from load balancer rule %v: %v", lbRule.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// symmetricDifference returns the symmetric difference between the old (existing) and new (wanted) host ID's.
0000000000000000000000000000000000000000;;	func symmetricDifference(hostIDs []string, lbInstances []*cloudstack.VirtualMachine) ([]string, []string) {
0000000000000000000000000000000000000000;;		new := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, hostID := range hostIDs {
0000000000000000000000000000000000000000;;			new[hostID] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var remove []string
0000000000000000000000000000000000000000;;		for _, instance := range lbInstances {
0000000000000000000000000000000000000000;;			if new[instance.Id] {
0000000000000000000000000000000000000000;;				delete(new, instance.Id)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			remove = append(remove, instance.Id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var assign []string
0000000000000000000000000000000000000000;;		for hostID := range new {
0000000000000000000000000000000000000000;;			assign = append(assign, hostID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return assign, remove
0000000000000000000000000000000000000000;;	}
