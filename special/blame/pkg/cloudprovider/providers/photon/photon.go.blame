0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d6825686a3614f2a83a58338ae1cabf7e3bbea85;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This version of Photon cloud provider supports the disk interface
0000000000000000000000000000000000000000;;	// for Photon persistent disk volume plugin. LoadBalancer, Routes, and
0000000000000000000000000000000000000000;;	// Zones are currently not supported.
0000000000000000000000000000000000000000;;	// The use of Photon cloud provider requires to start kubelet, kube-apiserver,
0000000000000000000000000000000000000000;;	// and kube-controller-manager with config flag: '--cloud-provider=photon
0000000000000000000000000000000000000000;;	// --cloud-config=[path_to_config_file]'. When running multi-node kubernetes
0000000000000000000000000000000000000000;;	// using docker, the config file should be located inside /etc/kubernetes.
0000000000000000000000000000000000000000;;	package photon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/vmware/photon-controller-go-sdk/photon"
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		k8stypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProviderName = "photon"
0000000000000000000000000000000000000000;;		DiskSpecKind = "persistent-disk"
0000000000000000000000000000000000000000;;		MAC_OUI_VC   = "00:50:56"
0000000000000000000000000000000000000000;;		MAC_OUI_ESX  = "00:0c:29"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// overrideIP indicates if the hostname is overriden by IP address, such as when
0000000000000000000000000000000000000000;;	// running multi-node kubernetes using docker. In this case the user should set
0000000000000000000000000000000000000000;;	// overrideIP = true in cloud config file. Default value is false.
0000000000000000000000000000000000000000;;	var overrideIP bool = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Photon is an implementation of the cloud provider interface for Photon Controller.
0000000000000000000000000000000000000000;;	type PCCloud struct {
0000000000000000000000000000000000000000;;		cfg *PCConfig
0000000000000000000000000000000000000000;;		// InstanceID of the server where this PCCloud object is instantiated.
0000000000000000000000000000000000000000;;		localInstanceID string
0000000000000000000000000000000000000000;;		// local $HOSTNAME
0000000000000000000000000000000000000000;;		localHostname string
0000000000000000000000000000000000000000;;		// hostname from K8S, could be overridden
0000000000000000000000000000000000000000;;		localK8sHostname string
0000000000000000000000000000000000000000;;		// Photon project ID. We assume that there is only one Photon Controller project
0000000000000000000000000000000000000000;;		// in the environment per current Photon Controller deployment methodology.
0000000000000000000000000000000000000000;;		projID string
0000000000000000000000000000000000000000;;		cloudprovider.Zone
0000000000000000000000000000000000000000;;		photonClient *photon.Client
0000000000000000000000000000000000000000;;		logger       *log.Logger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PCConfig struct {
0000000000000000000000000000000000000000;;		Global struct {
0000000000000000000000000000000000000000;;			// the Photon Controller endpoint IP address
0000000000000000000000000000000000000000;;			CloudTarget string `gcfg:"target"`
0000000000000000000000000000000000000000;;			// Photon Controller project name
0000000000000000000000000000000000000000;;			Project string `gcfg:"project"`
0000000000000000000000000000000000000000;;			// when kubelet is started with '--hostname-override=${IP_ADDRESS}', set to true;
0000000000000000000000000000000000000000;;			// otherwise, set to false.
0000000000000000000000000000000000000000;;			OverrideIP bool `gcfg:"overrideIP"`
0000000000000000000000000000000000000000;;			// VM ID for this node
0000000000000000000000000000000000000000;;			VMID string `gcfg:"vmID"`
0000000000000000000000000000000000000000;;			// Authentication enabled or not
0000000000000000000000000000000000000000;;			AuthEnabled bool `gcfg:"authentication"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Disks is interface for manipulation with PhotonController Persistent Disks.
0000000000000000000000000000000000000000;;	type Disks interface {
0000000000000000000000000000000000000000;;		// AttachDisk attaches given disk to given node. Current node
0000000000000000000000000000000000000000;;		// is used when nodeName is empty string.
0000000000000000000000000000000000000000;;		AttachDisk(pdID string, nodeName k8stypes.NodeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DetachDisk detaches given disk to given node. Current node
0000000000000000000000000000000000000000;;		// is used when nodeName is empty string.
0000000000000000000000000000000000000000;;		DetachDisk(pdID string, nodeName k8stypes.NodeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DiskIsAttached checks if a disk is attached to the given node.
0000000000000000000000000000000000000000;;		DiskIsAttached(pdID string, nodeName k8stypes.NodeName) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DisksAreAttached is a batch function to check if a list of disks are attached
0000000000000000000000000000000000000000;;		// to the node with the specified NodeName.
0000000000000000000000000000000000000000;;		DisksAreAttached(pdIDs []string, nodeName k8stypes.NodeName) (map[string]bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreateDisk creates a new PD with given properties.
0000000000000000000000000000000000000000;;		CreateDisk(volumeOptions *VolumeOptions) (pdID string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteDisk deletes PD.
0000000000000000000000000000000000000000;;		DeleteDisk(pdID string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeOptions specifies capacity, tags, name and flavorID for a volume.
0000000000000000000000000000000000000000;;	type VolumeOptions struct {
0000000000000000000000000000000000000000;;		CapacityGB int
0000000000000000000000000000000000000000;;		Tags       map[string]string
0000000000000000000000000000000000000000;;		Name       string
0000000000000000000000000000000000000000;;		Flavor     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readConfig(config io.Reader) (PCConfig, error) {
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("cloud provider config file is missing. Please restart kubelet with --cloud-provider=photon --cloud-config=[path_to_config_file]")
0000000000000000000000000000000000000000;;			return PCConfig{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cfg PCConfig
0000000000000000000000000000000000000000;;		err := gcfg.ReadInto(&cfg, config)
0000000000000000000000000000000000000000;;		return cfg, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		cloudprovider.RegisterCloudProvider(ProviderName, func(config io.Reader) (cloudprovider.Interface, error) {
0000000000000000000000000000000000000000;;			cfg, err := readConfig(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: failed to read in cloud provider config file. Error[%v]", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newPCCloud(cfg)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieve the Photon VM ID from the Photon Controller endpoint based on the node name
0000000000000000000000000000000000000000;;	func getVMIDbyNodename(pc *PCCloud, nodeName string) (string, error) {
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for getVMIDbyNodename, error: [%v]", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmList, err := photonClient.Projects.GetVMs(pc.projID, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to GetVMs from project %s with nodeName %s, error: [%v]", pc.projID, nodeName, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, vm := range vmList.Items {
0000000000000000000000000000000000000000;;			if vm.Name == nodeName {
0000000000000000000000000000000000000000;;				return vm.ID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("No matching started VM is found with name %s", nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieve the Photon VM ID from the Photon Controller endpoint based on the IP address
0000000000000000000000000000000000000000;;	func getVMIDbyIP(pc *PCCloud, IPAddress string) (string, error) {
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for getVMIDbyNodename, error: [%v]", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmList, err := photonClient.Projects.GetVMs(pc.projID, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to GetVMs for project %s. error: [%v]", pc.projID, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, vm := range vmList.Items {
0000000000000000000000000000000000000000;;			task, err := photonClient.VMs.GetNetworks(vm.ID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Photon Cloud Provider: GetNetworks failed for vm.ID %s, error [%v]", vm.ID, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				task, err = photonClient.Tasks.Wait(task.ID)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Photon Cloud Provider: Wait task for GetNetworks failed for vm.ID %s, error [%v]", vm.ID, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					networkConnections := task.ResourceProperties.(map[string]interface{})
0000000000000000000000000000000000000000;;					networks := networkConnections["networkConnections"].([]interface{})
0000000000000000000000000000000000000000;;					for _, nt := range networks {
0000000000000000000000000000000000000000;;						network := nt.(map[string]interface{})
0000000000000000000000000000000000000000;;						if val, ok := network["ipAddress"]; ok && val != nil {
0000000000000000000000000000000000000000;;							ipAddr := val.(string)
0000000000000000000000000000000000000000;;							if ipAddr == IPAddress {
0000000000000000000000000000000000000000;;								return vm.ID, nil
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("No matching VM is found with IP %s", IPAddress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPhotonClient(pc *PCCloud) (*photon.Client, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if len(pc.cfg.Global.CloudTarget) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Photon Controller endpoint was not specified.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := &photon.ClientOptions{
0000000000000000000000000000000000000000;;			IgnoreCertificate: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc.photonClient = photon.NewClient(pc.cfg.Global.CloudTarget, options, pc.logger)
0000000000000000000000000000000000000000;;		if pc.cfg.Global.AuthEnabled == true {
0000000000000000000000000000000000000000;;			// work around before metadata is available
0000000000000000000000000000000000000000;;			file, err := os.Open("/etc/kubernetes/pc_login_info")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: Authentication is enabled but found no username/password at /etc/kubernetes/pc_login_info. Error[%v]", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer file.Close()
0000000000000000000000000000000000000000;;			scanner := bufio.NewScanner(file)
0000000000000000000000000000000000000000;;			if !scanner.Scan() {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: Empty username inside /etc/kubernetes/pc_login_info.")
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to create authentication enabled client with invalid username")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			username := scanner.Text()
0000000000000000000000000000000000000000;;			if !scanner.Scan() {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: Empty password set inside /etc/kubernetes/pc_login_info.")
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to create authentication enabled client with invalid password")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			password := scanner.Text()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			token_options, err := pc.photonClient.Auth.GetTokensByPassword(username, password)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: failed to get tokens by password")
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			options = &photon.ClientOptions{
0000000000000000000000000000000000000000;;				IgnoreCertificate: true,
0000000000000000000000000000000000000000;;				TokenOptions: &photon.TokenOptions{
0000000000000000000000000000000000000000;;					AccessToken: token_options.AccessToken,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pc.photonClient = photon.NewClient(pc.cfg.Global.CloudTarget, options, pc.logger)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status, err := pc.photonClient.Status.Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: new client creation failed. Error[%v]", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Photon Cloud Provider: Status of the new photon controller client: %v", status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pc.photonClient, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPCCloud(cfg PCConfig) (*PCCloud, error) {
0000000000000000000000000000000000000000;;		projID := cfg.Global.Project
0000000000000000000000000000000000000000;;		vmID := cfg.Global.VMID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get local hostname
0000000000000000000000000000000000000000;;		cmd := exec.Command("bash", "-c", `echo $HOSTNAME`)
0000000000000000000000000000000000000000;;		out, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: get local hostname bash command failed. Error[%v]", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(out) == 0 {
0000000000000000000000000000000000000000;;			glog.Errorf("unable to retrieve hostname for Instance ID")
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to retrieve hostname for Instance ID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hostname := strings.TrimRight(string(out), "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc := PCCloud{
0000000000000000000000000000000000000000;;			cfg:              &cfg,
0000000000000000000000000000000000000000;;			localInstanceID:  vmID,
0000000000000000000000000000000000000000;;			localHostname:    hostname,
0000000000000000000000000000000000000000;;			localK8sHostname: "",
0000000000000000000000000000000000000000;;			projID:           projID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		overrideIP = cfg.Global.OverrideIP
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize passes a Kubernetes clientBuilder interface to the cloud provider
0000000000000000000000000000000000000000;;	func (pc *PCCloud) Initialize(clientBuilder controller.ControllerClientBuilder) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances returns an implementation of Instances for Photon Controller.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		return pc, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List is an implementation of Instances.List.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) List(filter string) ([]k8stypes.NodeName, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddresses is an implementation of Instances.NodeAddresses.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) NodeAddresses(nodeName k8stypes.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		nodeAddrs := []v1.NodeAddress{}
0000000000000000000000000000000000000000;;		name := string(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name == pc.localK8sHostname {
0000000000000000000000000000000000000000;;			ifaces, err := net.Interfaces()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: net.Interfaces() failed for NodeAddresses. Error[%v]", err)
0000000000000000000000000000000000000000;;				return nodeAddrs, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, i := range ifaces {
0000000000000000000000000000000000000000;;				addrs, err := i.Addrs()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Photon Cloud Provider: Failed to extract addresses for NodeAddresses. Error[%v]", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					for _, addr := range addrs {
0000000000000000000000000000000000000000;;						if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
0000000000000000000000000000000000000000;;							if ipnet.IP.To4() != nil {
0000000000000000000000000000000000000000;;								// Filter external IP by MAC address OUIs from vCenter and from ESX
0000000000000000000000000000000000000000;;								if strings.HasPrefix(i.HardwareAddr.String(), MAC_OUI_VC) ||
0000000000000000000000000000000000000000;;									strings.HasPrefix(i.HardwareAddr.String(), MAC_OUI_ESX) {
0000000000000000000000000000000000000000;;									v1helper.AddToNodeAddresses(&nodeAddrs,
0000000000000000000000000000000000000000;;										v1.NodeAddress{
0000000000000000000000000000000000000000;;											Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;											Address: ipnet.IP.String(),
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									)
0000000000000000000000000000000000000000;;								} else {
0000000000000000000000000000000000000000;;									v1helper.AddToNodeAddresses(&nodeAddrs,
0000000000000000000000000000000000000000;;										v1.NodeAddress{
0000000000000000000000000000000000000000;;											Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;											Address: ipnet.IP.String(),
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nodeAddrs, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inquiring IP addresses from photon controller endpoint only for a node other than this node.
0000000000000000000000000000000000000000;;		// This is assumed to be done by master only.
0000000000000000000000000000000000000000;;		vmID, err := getInstanceID(pc, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: getInstanceID failed for NodeAddresses. Error[%v]", err)
0000000000000000000000000000000000000000;;			return nodeAddrs, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for NodeAddresses, error: [%v]", err)
0000000000000000000000000000000000000000;;			return nodeAddrs, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve the Photon VM's IP addresses from the Photon Controller endpoint based on the VM ID
0000000000000000000000000000000000000000;;		vmList, err := photonClient.Projects.GetVMs(pc.projID, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to GetVMs for project %s. Error[%v]", pc.projID, err)
0000000000000000000000000000000000000000;;			return nodeAddrs, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, vm := range vmList.Items {
0000000000000000000000000000000000000000;;			if vm.ID == vmID {
0000000000000000000000000000000000000000;;				task, err := photonClient.VMs.GetNetworks(vm.ID)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Photon Cloud Provider: GetNetworks failed for node %s with vm.ID %s. Error[%v]", name, vm.ID, err)
0000000000000000000000000000000000000000;;					return nodeAddrs, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					task, err = photonClient.Tasks.Wait(task.ID)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("Photon Cloud Provider: Wait task for GetNetworks failed for node %s with vm.ID %s. Error[%v]", name, vm.ID, err)
0000000000000000000000000000000000000000;;						return nodeAddrs, err
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						networkConnections := task.ResourceProperties.(map[string]interface{})
0000000000000000000000000000000000000000;;						networks := networkConnections["networkConnections"].([]interface{})
0000000000000000000000000000000000000000;;						for _, nt := range networks {
0000000000000000000000000000000000000000;;							ipAddr := "-"
0000000000000000000000000000000000000000;;							macAddr := "-"
0000000000000000000000000000000000000000;;							network := nt.(map[string]interface{})
0000000000000000000000000000000000000000;;							if val, ok := network["ipAddress"]; ok && val != nil {
0000000000000000000000000000000000000000;;								ipAddr = val.(string)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if val, ok := network["macAddress"]; ok && val != nil {
0000000000000000000000000000000000000000;;								macAddr = val.(string)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if ipAddr != "-" {
0000000000000000000000000000000000000000;;								if strings.HasPrefix(macAddr, MAC_OUI_VC) ||
0000000000000000000000000000000000000000;;									strings.HasPrefix(macAddr, MAC_OUI_ESX) {
0000000000000000000000000000000000000000;;									v1helper.AddToNodeAddresses(&nodeAddrs,
0000000000000000000000000000000000000000;;										v1.NodeAddress{
0000000000000000000000000000000000000000;;											Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;											Address: ipAddr,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									)
0000000000000000000000000000000000000000;;								} else {
0000000000000000000000000000000000000000;;									v1helper.AddToNodeAddresses(&nodeAddrs,
0000000000000000000000000000000000000000;;										v1.NodeAddress{
0000000000000000000000000000000000000000;;											Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;											Address: ipAddr,
0000000000000000000000000000000000000000;;										},
0000000000000000000000000000000000000000;;									)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return nodeAddrs, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Errorf("Failed to find the node %s from Photon Controller endpoint", name)
0000000000000000000000000000000000000000;;		return nodeAddrs, fmt.Errorf("Failed to find the node %s from Photon Controller endpoint", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddressesByProviderID returns the node addresses of an instances with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (pc *PCCloud) NodeAddressesByProviderID(providerID string) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		return []v1.NodeAddress{}, errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *PCCloud) AddSSHKeyToAllInstances(user string, keyData []byte) error {
0000000000000000000000000000000000000000;;		return errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *PCCloud) CurrentNodeName(hostname string) (k8stypes.NodeName, error) {
0000000000000000000000000000000000000000;;		pc.localK8sHostname = hostname
0000000000000000000000000000000000000000;;		return k8stypes.NodeName(hostname), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInstanceID(pc *PCCloud, name string) (string, error) {
0000000000000000000000000000000000000000;;		var vmID string
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if overrideIP == true {
0000000000000000000000000000000000000000;;			vmID, err = getVMIDbyIP(pc, name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			vmID, err = getVMIDbyNodename(pc, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vmID == "" {
0000000000000000000000000000000000000000;;			err = cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vmID, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalID returns the cloud provider ID of the specified instance (deprecated).
0000000000000000000000000000000000000000;;	func (pc *PCCloud) ExternalID(nodeName k8stypes.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		name := string(nodeName)
0000000000000000000000000000000000000000;;		if name == pc.localK8sHostname {
0000000000000000000000000000000000000000;;			return pc.localInstanceID, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We assume only master need to get InstanceID of a node other than itself
0000000000000000000000000000000000000000;;			ID, err := getInstanceID(pc, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: getInstanceID failed for ExternalID. Error[%v]", err)
0000000000000000000000000000000000000000;;				return ID, err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return ID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the cloud provider ID of the specified instance.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) InstanceID(nodeName k8stypes.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		name := string(nodeName)
0000000000000000000000000000000000000000;;		if name == pc.localK8sHostname {
0000000000000000000000000000000000000000;;			return pc.localInstanceID, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We assume only master need to get InstanceID of a node other than itself
0000000000000000000000000000000000000000;;			ID, err := getInstanceID(pc, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Photon Cloud Provider: getInstanceID failed for InstanceID. Error[%v]", err)
0000000000000000000000000000000000000000;;				return ID, err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return ID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceTypeByProviderID returns the cloudprovider instance type of the node with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (pc *PCCloud) InstanceTypeByProviderID(providerID string) (string, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *PCCloud) InstanceType(nodeName k8stypes.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *PCCloud) Clusters() (cloudprovider.Clusters, bool) {
0000000000000000000000000000000000000000;;		return nil, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) ProviderName() string {
0000000000000000000000000000000000000000;;		return ProviderName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer returns an implementation of LoadBalancer for Photon Controller.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zones returns an implementation of Zones for Photon Controller.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) Zones() (cloudprovider.Zones, bool) {
0000000000000000000000000000000000000000;;		return pc, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *PCCloud) GetZone() (cloudprovider.Zone, error) {
0000000000000000000000000000000000000000;;		return pc.Zone, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Routes returns a false since the interface is not supported for photon controller.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) Routes() (cloudprovider.Routes, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScrubDNS filters DNS settings for pods.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string) {
0000000000000000000000000000000000000000;;		return nameservers, searches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attaches given virtual disk volume to the compute running kubelet.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) AttachDisk(pdID string, nodeName k8stypes.NodeName) error {
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for AttachDisk, error: [%v]", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operation := &photon.VmDiskOperation{
0000000000000000000000000000000000000000;;			DiskID: pdID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmID, err := pc.InstanceID(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: pc.InstanceID failed for AttachDisk. Error[%v]", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := photonClient.VMs.AttachDisk(vmID, operation)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to attach disk with pdID %s. Error[%v]", pdID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = photonClient.Tasks.Wait(task.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to wait for task to attach disk with pdID %s. Error[%v]", pdID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detaches given virtual disk volume from the compute running kubelet.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) DetachDisk(pdID string, nodeName k8stypes.NodeName) error {
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for DetachDisk, error: [%v]", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operation := &photon.VmDiskOperation{
0000000000000000000000000000000000000000;;			DiskID: pdID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmID, err := pc.InstanceID(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: pc.InstanceID failed for DetachDisk. Error[%v]", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := photonClient.VMs.DetachDisk(vmID, operation)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to detach disk with pdID %s. Error[%v]", pdID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = photonClient.Tasks.Wait(task.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to wait for task to detach disk with pdID %s. Error[%v]", pdID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiskIsAttached returns if disk is attached to the VM using controllers supported by the plugin.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) DiskIsAttached(pdID string, nodeName k8stypes.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for DiskIsAttached, error: [%v]", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		disk, err := photonClient.Disks.Get(pdID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to Get disk with pdID %s. Error[%v]", pdID, err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmID, err := pc.InstanceID(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: pc.InstanceID failed for DiskIsAttached. Error[%v]", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, vm := range disk.VMs {
0000000000000000000000000000000000000000;;			if vm == vmID {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisksAreAttached returns if disks are attached to the VM using controllers supported by the plugin.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) DisksAreAttached(pdIDs []string, nodeName k8stypes.NodeName) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		attached := make(map[string]bool)
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for DisksAreAttached, error: [%v]", err)
0000000000000000000000000000000000000000;;			return attached, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pdID := range pdIDs {
0000000000000000000000000000000000000000;;			attached[pdID] = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmID, err := pc.InstanceID(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: pc.InstanceID failed for DiskIsAttached. Error[%v]", err)
0000000000000000000000000000000000000000;;			return attached, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pdID := range pdIDs {
0000000000000000000000000000000000000000;;			disk, err := photonClient.Disks.Get(pdID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Photon Cloud Provider: failed to get VMs for persistent disk %s, err [%v]", pdID, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, vm := range disk.VMs {
0000000000000000000000000000000000000000;;					if vm == vmID {
0000000000000000000000000000000000000000;;						attached[pdID] = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attached, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a volume of given size (in GB).
0000000000000000000000000000000000000000;;	func (pc *PCCloud) CreateDisk(volumeOptions *VolumeOptions) (pdID string, err error) {
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for CreateDisk, error: [%v]", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskSpec := photon.DiskCreateSpec{}
0000000000000000000000000000000000000000;;		diskSpec.Name = volumeOptions.Name
0000000000000000000000000000000000000000;;		diskSpec.Flavor = volumeOptions.Flavor
0000000000000000000000000000000000000000;;		diskSpec.CapacityGB = volumeOptions.CapacityGB
0000000000000000000000000000000000000000;;		diskSpec.Kind = DiskSpecKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := photonClient.Projects.CreateDisk(pc.projID, &diskSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to CreateDisk. Error[%v]", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitTask, err := photonClient.Tasks.Wait(task.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to wait for task to CreateDisk. Error[%v]", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return waitTask.Entity.ID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes a volume given volume name.
0000000000000000000000000000000000000000;;	func (pc *PCCloud) DeleteDisk(pdID string) error {
0000000000000000000000000000000000000000;;		photonClient, err := getPhotonClient(pc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to get photon client for DeleteDisk, error: [%v]", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := photonClient.Disks.Delete(pdID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to DeleteDisk. Error[%v]", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = photonClient.Tasks.Wait(task.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Cloud Provider: Failed to wait for task to DeleteDisk. Error[%v]", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
