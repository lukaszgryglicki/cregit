0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f050e96cf08b79e447c6733a930c9ec7df26eb44;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/network"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/to"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListRoutes lists all managed routes that belong to the specified clusterName
0000000000000000000000000000000000000000;;	func (az *Cloud) ListRoutes(clusterName string) (routes []*cloudprovider.Route, err error) {
0000000000000000000000000000000000000000;;		glog.V(10).Infof("list: START clusterName=%q", clusterName)
0000000000000000000000000000000000000000;;		routeTable, existsRouteTable, err := az.getRouteTable()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existsRouteTable {
0000000000000000000000000000000000000000;;			return []*cloudprovider.Route{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kubeRoutes []*cloudprovider.Route
0000000000000000000000000000000000000000;;		if routeTable.Routes != nil {
0000000000000000000000000000000000000000;;			kubeRoutes = make([]*cloudprovider.Route, len(*routeTable.Routes))
0000000000000000000000000000000000000000;;			for i, route := range *routeTable.Routes {
0000000000000000000000000000000000000000;;				instance := mapRouteNameToNodeName(*route.Name)
0000000000000000000000000000000000000000;;				cidr := *route.AddressPrefix
0000000000000000000000000000000000000000;;				glog.V(10).Infof("list: * instance=%q, cidr=%q", instance, cidr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				kubeRoutes[i] = &cloudprovider.Route{
0000000000000000000000000000000000000000;;					Name:            *route.Name,
0000000000000000000000000000000000000000;;					TargetNode:      instance,
0000000000000000000000000000000000000000;;					DestinationCIDR: cidr,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(10).Info("list: FINISH")
0000000000000000000000000000000000000000;;		return kubeRoutes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateRoute creates the described managed route
0000000000000000000000000000000000000000;;	// route.Name will be ignored, although the cloud-provider may use nameHint
0000000000000000000000000000000000000000;;	// to create a more user-meaningful name.
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateRoute(clusterName string, nameHint string, kubeRoute *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("create: creating route. clusterName=%q instance=%q cidr=%q", clusterName, kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routeTable, existsRouteTable, err := az.getRouteTable()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("create error: couldn't get routetable. clusterName=%q instance=%q cidr=%q", clusterName, kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existsRouteTable {
0000000000000000000000000000000000000000;;			routeTable = network.RouteTable{
0000000000000000000000000000000000000000;;				Name:                       to.StringPtr(az.RouteTableName),
0000000000000000000000000000000000000000;;				Location:                   to.StringPtr(az.Location),
0000000000000000000000000000000000000000;;				RouteTablePropertiesFormat: &network.RouteTablePropertiesFormat{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(3).Infof("create: creating routetable. routeTableName=%q", az.RouteTableName)
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.RouteTablesClient.CreateOrUpdate(az.ResourceGroup, az.RouteTableName, routeTable, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("create backing off: creating routetable. routeTableName=%q", az.RouteTableName)
0000000000000000000000000000000000000000;;				retryErr := az.CreateOrUpdateRouteTableWithRetry(routeTable)
0000000000000000000000000000000000000000;;				if retryErr != nil {
0000000000000000000000000000000000000000;;					err = retryErr
0000000000000000000000000000000000000000;;					glog.V(2).Infof("create abort backoff: creating routetable. routeTableName=%q", az.RouteTableName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			routeTable, err = az.RouteTablesClient.Get(az.ResourceGroup, az.RouteTableName, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targetIP, err := az.getIPForMachine(kubeRoute.TargetNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routeName := mapNodeNameToRouteName(kubeRoute.TargetNode)
0000000000000000000000000000000000000000;;		route := network.Route{
0000000000000000000000000000000000000000;;			Name: to.StringPtr(routeName),
0000000000000000000000000000000000000000;;			RoutePropertiesFormat: &network.RoutePropertiesFormat{
0000000000000000000000000000000000000000;;				AddressPrefix:    to.StringPtr(kubeRoute.DestinationCIDR),
0000000000000000000000000000000000000000;;				NextHopType:      network.RouteNextHopTypeVirtualAppliance,
0000000000000000000000000000000000000000;;				NextHopIPAddress: to.StringPtr(targetIP),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("create: creating route: instance=%q cidr=%q", kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		respChan, errChan := az.RoutesClient.CreateOrUpdate(az.ResourceGroup, az.RouteTableName, *route.Name, route, nil)
0000000000000000000000000000000000000000;;		resp := <-respChan
0000000000000000000000000000000000000000;;		err = <-errChan
0000000000000000000000000000000000000000;;		if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("create backing off: creating route: instance=%q cidr=%q", kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;			retryErr := az.CreateOrUpdateRouteWithRetry(route)
0000000000000000000000000000000000000000;;			if retryErr != nil {
0000000000000000000000000000000000000000;;				err = retryErr
0000000000000000000000000000000000000000;;				glog.V(2).Infof("create abort backoff: creating route: instance=%q cidr=%q", kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("create: route created. clusterName=%q instance=%q cidr=%q", clusterName, kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteRoute deletes the specified managed route
0000000000000000000000000000000000000000;;	// Route should be as returned by ListRoutes
0000000000000000000000000000000000000000;;	func (az *Cloud) DeleteRoute(clusterName string, kubeRoute *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("delete: deleting route. clusterName=%q instance=%q cidr=%q", clusterName, kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routeName := mapNodeNameToRouteName(kubeRoute.TargetNode)
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		respChan, errChan := az.RoutesClient.Delete(az.ResourceGroup, az.RouteTableName, routeName, nil)
0000000000000000000000000000000000000000;;		resp := <-respChan
0000000000000000000000000000000000000000;;		err := <-errChan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if az.CloudProviderBackoff && shouldRetryAPIRequest(resp, err) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("delete backing off: deleting route. clusterName=%q instance=%q cidr=%q", clusterName, kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;			retryErr := az.DeleteRouteWithRetry(routeName)
0000000000000000000000000000000000000000;;			if retryErr != nil {
0000000000000000000000000000000000000000;;				err = retryErr
0000000000000000000000000000000000000000;;				glog.V(2).Infof("delete abort backoff: deleting route. clusterName=%q instance=%q cidr=%q", clusterName, kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("delete: route deleted. clusterName=%q instance=%q cidr=%q", clusterName, kubeRoute.TargetNode, kubeRoute.DestinationCIDR)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This must be kept in sync with mapRouteNameToNodeName.
0000000000000000000000000000000000000000;;	// These two functions enable stashing the instance name in the route
0000000000000000000000000000000000000000;;	// and then retrieving it later when listing. This is needed because
0000000000000000000000000000000000000000;;	// Azure does not let you put tags/descriptions on the Route itself.
0000000000000000000000000000000000000000;;	func mapNodeNameToRouteName(nodeName types.NodeName) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s", nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used with mapNodeNameToRouteName. See comment on mapNodeNameToRouteName.
0000000000000000000000000000000000000000;;	func mapRouteNameToNodeName(routeName string) types.NodeName {
0000000000000000000000000000000000000000;;		return types.NodeName(fmt.Sprintf("%s", routeName))
0000000000000000000000000000000000000000;;	}
