0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
422f47e7a2326d645262ae561ebdc4ec20bf9704;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/compute"
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/network"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetVirtualMachineWithRetry invokes az.getVirtualMachine with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) GetVirtualMachineWithRetry(name types.NodeName) (compute.VirtualMachine, bool, error) {
0000000000000000000000000000000000000000;;		var machine compute.VirtualMachine
0000000000000000000000000000000000000000;;		var exists bool
0000000000000000000000000000000000000000;;		err := wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			var retryErr error
0000000000000000000000000000000000000000;;			machine, exists, retryErr = az.getVirtualMachine(name)
0000000000000000000000000000000000000000;;			if retryErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("backoff: failure, will retry,err=%v", retryErr)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("backoff: success")
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return machine, exists, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdateSGWithRetry invokes az.SecurityGroupsClient.CreateOrUpdate with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateOrUpdateSGWithRetry(sg network.SecurityGroup) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.SecurityGroupsClient.CreateOrUpdate(az.ResourceGroup, *sg.Name, sg, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp.Response, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdateLBWithRetry invokes az.LoadBalancerClient.CreateOrUpdate with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateOrUpdateLBWithRetry(lb network.LoadBalancer) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.LoadBalancerClient.CreateOrUpdate(az.ResourceGroup, *lb.Name, lb, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp.Response, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdatePIPWithRetry invokes az.PublicIPAddressesClient.CreateOrUpdate with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateOrUpdatePIPWithRetry(pip network.PublicIPAddress) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.PublicIPAddressesClient.CreateOrUpdate(az.ResourceGroup, *pip.Name, pip, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp.Response, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdateInterfaceWithRetry invokes az.PublicIPAddressesClient.CreateOrUpdate with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateOrUpdateInterfaceWithRetry(nic network.Interface) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.InterfacesClient.CreateOrUpdate(az.ResourceGroup, *nic.Name, nic, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp.Response, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletePublicIPWithRetry invokes az.PublicIPAddressesClient.Delete with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) DeletePublicIPWithRetry(pipName string) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.PublicIPAddressesClient.Delete(az.ResourceGroup, pipName, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteLBWithRetry invokes az.LoadBalancerClient.Delete with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) DeleteLBWithRetry(lbName string) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.LoadBalancerClient.Delete(az.ResourceGroup, lbName, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdateRouteTableWithRetry invokes az.RouteTablesClient.CreateOrUpdate with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateOrUpdateRouteTableWithRetry(routeTable network.RouteTable) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.RouteTablesClient.CreateOrUpdate(az.ResourceGroup, az.RouteTableName, routeTable, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp.Response, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdateRouteWithRetry invokes az.RoutesClient.CreateOrUpdate with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateOrUpdateRouteWithRetry(route network.Route) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.RoutesClient.CreateOrUpdate(az.ResourceGroup, az.RouteTableName, *route.Name, route, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp.Response, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteRouteWithRetry invokes az.RoutesClient.Delete with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) DeleteRouteWithRetry(routeName string) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.RoutesClient.Delete(az.ResourceGroup, az.RouteTableName, routeName, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdateVMWithRetry invokes az.VirtualMachinesClient.CreateOrUpdate with exponential backoff retry
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateOrUpdateVMWithRetry(vmName string, newVM compute.VirtualMachine) error {
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(az.resourceRequestBackoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.VirtualMachinesClient.CreateOrUpdate(az.ResourceGroup, vmName, newVM, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			return processRetryResponse(resp.Response, err)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A wait.ConditionFunc function to deal with common HTTP backoff response conditions
0000000000000000000000000000000000000000;;	func processRetryResponse(resp autorest.Response, err error) (bool, error) {
0000000000000000000000000000000000000000;;		if isSuccessHTTPResponse(resp) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("backoff: success, HTTP response=%d", resp.StatusCode)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if shouldRetryAPIRequest(resp, err) {
0000000000000000000000000000000000000000;;			glog.Errorf("backoff: failure, will retry, HTTP response=%d, err=%v", resp.StatusCode, err)
0000000000000000000000000000000000000000;;			// suppress the error object so that backoff process continues
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Fall-through: stop periodic backoff, return error object from most recent request
0000000000000000000000000000000000000000;;		return true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldRetryAPIRequest determines if the response from an HTTP request suggests periodic retry behavior
0000000000000000000000000000000000000000;;	func shouldRetryAPIRequest(resp autorest.Response, err error) bool {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// HTTP 4xx or 5xx suggests we should retry
0000000000000000000000000000000000000000;;		if 399 < resp.StatusCode && resp.StatusCode < 600 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSuccessHTTPResponse determines if the response from an HTTP request suggests success
0000000000000000000000000000000000000000;;	func isSuccessHTTPResponse(resp autorest.Response) bool {
0000000000000000000000000000000000000000;;		// HTTP 2xx suggests a successful response
0000000000000000000000000000000000000000;;		if 199 < resp.StatusCode && resp.StatusCode < 300 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
