0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f050e96cf08b79e447c6733a930c9ec7df26eb44;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/compute"
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/network"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		loadBalancerMinimumPriority = 500
0000000000000000000000000000000000000000;;		loadBalancerMaximumPriority = 4096
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		machineIDTemplate           = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/virtualMachines/%s"
0000000000000000000000000000000000000000;;		availabilitySetIDTemplate   = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Compute/availabilitySets/%s"
0000000000000000000000000000000000000000;;		frontendIPConfigIDTemplate  = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/frontendIPConfigurations/%s"
0000000000000000000000000000000000000000;;		backendPoolIDTemplate       = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/backendAddressPools/%s"
0000000000000000000000000000000000000000;;		loadBalancerRuleIDTemplate  = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/loadBalancingRules/%s"
0000000000000000000000000000000000000000;;		loadBalancerProbeIDTemplate = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/loadBalancers/%s/probes/%s"
0000000000000000000000000000000000000000;;		securityRuleIDTemplate      = "/subscriptions/%s/resourceGroups/%s/providers/Microsoft.Network/networkSecurityGroups/%s/securityRules/%s"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var providerIDRE = regexp.MustCompile(`^` + CloudProviderName + `://(.+)$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the full identifier of a machine
0000000000000000000000000000000000000000;;	func (az *Cloud) getMachineID(machineName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			machineIDTemplate,
0000000000000000000000000000000000000000;;			az.SubscriptionID,
0000000000000000000000000000000000000000;;			az.ResourceGroup,
0000000000000000000000000000000000000000;;			machineName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the full identifier of an availabilitySet
0000000000000000000000000000000000000000;;	func (az *Cloud) getAvailabilitySetID(availabilitySetName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			availabilitySetIDTemplate,
0000000000000000000000000000000000000000;;			az.SubscriptionID,
0000000000000000000000000000000000000000;;			az.ResourceGroup,
0000000000000000000000000000000000000000;;			availabilitySetName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the full identifier of a loadbalancer frontendipconfiguration.
0000000000000000000000000000000000000000;;	func (az *Cloud) getFrontendIPConfigID(lbName, backendPoolName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			frontendIPConfigIDTemplate,
0000000000000000000000000000000000000000;;			az.SubscriptionID,
0000000000000000000000000000000000000000;;			az.ResourceGroup,
0000000000000000000000000000000000000000;;			lbName,
0000000000000000000000000000000000000000;;			backendPoolName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the full identifier of a loadbalancer backendpool.
0000000000000000000000000000000000000000;;	func (az *Cloud) getBackendPoolID(lbName, backendPoolName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			backendPoolIDTemplate,
0000000000000000000000000000000000000000;;			az.SubscriptionID,
0000000000000000000000000000000000000000;;			az.ResourceGroup,
0000000000000000000000000000000000000000;;			lbName,
0000000000000000000000000000000000000000;;			backendPoolName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the full identifier of a loadbalancer rule.
0000000000000000000000000000000000000000;;	func (az *Cloud) getLoadBalancerRuleID(lbName, lbRuleName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			loadBalancerRuleIDTemplate,
0000000000000000000000000000000000000000;;			az.SubscriptionID,
0000000000000000000000000000000000000000;;			az.ResourceGroup,
0000000000000000000000000000000000000000;;			lbName,
0000000000000000000000000000000000000000;;			lbRuleName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the full identifier of a loadbalancer probe.
0000000000000000000000000000000000000000;;	func (az *Cloud) getLoadBalancerProbeID(lbName, lbRuleName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			loadBalancerProbeIDTemplate,
0000000000000000000000000000000000000000;;			az.SubscriptionID,
0000000000000000000000000000000000000000;;			az.ResourceGroup,
0000000000000000000000000000000000000000;;			lbName,
0000000000000000000000000000000000000000;;			lbRuleName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the full identifier of a network security group security rule.
0000000000000000000000000000000000000000;;	func (az *Cloud) getSecurityRuleID(securityRuleName string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			securityRuleIDTemplate,
0000000000000000000000000000000000000000;;			az.SubscriptionID,
0000000000000000000000000000000000000000;;			az.ResourceGroup,
0000000000000000000000000000000000000000;;			az.SecurityGroupName,
0000000000000000000000000000000000000000;;			securityRuleName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the deepest child's identifier from a full identifier string.
0000000000000000000000000000000000000000;;	func getLastSegment(ID string) (string, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(ID, "/")
0000000000000000000000000000000000000000;;		name := parts[len(parts)-1]
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("resource name was missing from identifier")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the equivalent LoadBalancerRule, SecurityRule and LoadBalancerProbe
0000000000000000000000000000000000000000;;	// protocol types for the given Kubernetes protocol type.
0000000000000000000000000000000000000000;;	func getProtocolsFromKubernetesProtocol(protocol v1.Protocol) (*network.TransportProtocol, *network.SecurityRuleProtocol, *network.ProbeProtocol, error) {
0000000000000000000000000000000000000000;;		var transportProto network.TransportProtocol
0000000000000000000000000000000000000000;;		var securityProto network.SecurityRuleProtocol
0000000000000000000000000000000000000000;;		var probeProto network.ProbeProtocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case v1.ProtocolTCP:
0000000000000000000000000000000000000000;;			transportProto = network.TransportProtocolTCP
0000000000000000000000000000000000000000;;			securityProto = network.SecurityRuleProtocolTCP
0000000000000000000000000000000000000000;;			probeProto = network.ProbeProtocolTCP
0000000000000000000000000000000000000000;;			return &transportProto, &securityProto, &probeProto, nil
0000000000000000000000000000000000000000;;		case v1.ProtocolUDP:
0000000000000000000000000000000000000000;;			transportProto = network.TransportProtocolUDP
0000000000000000000000000000000000000000;;			securityProto = network.SecurityRuleProtocolUDP
0000000000000000000000000000000000000000;;			return &transportProto, &securityProto, nil, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return &transportProto, &securityProto, &probeProto, fmt.Errorf("Only TCP and UDP are supported for Azure LoadBalancers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This returns the full identifier of the primary NIC for the given VM.
0000000000000000000000000000000000000000;;	func getPrimaryInterfaceID(machine compute.VirtualMachine) (string, error) {
0000000000000000000000000000000000000000;;		if len(*machine.NetworkProfile.NetworkInterfaces) == 1 {
0000000000000000000000000000000000000000;;			return *(*machine.NetworkProfile.NetworkInterfaces)[0].ID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ref := range *machine.NetworkProfile.NetworkInterfaces {
0000000000000000000000000000000000000000;;			if *ref.Primary {
0000000000000000000000000000000000000000;;				return *ref.ID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("failed to find a primary nic for the vm. vmname=%q", *machine.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPrimaryIPConfig(nic network.Interface) (*network.InterfaceIPConfiguration, error) {
0000000000000000000000000000000000000000;;		if len(*nic.IPConfigurations) == 1 {
0000000000000000000000000000000000000000;;			return &((*nic.IPConfigurations)[0]), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ref := range *nic.IPConfigurations {
0000000000000000000000000000000000000000;;			if *ref.Primary {
0000000000000000000000000000000000000000;;				return &ref, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("failed to determine the determine primary ipconfig. nicname=%q", *nic.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For a load balancer, all frontend ip should reference either a subnet or publicIpAddress.
0000000000000000000000000000000000000000;;	// Thus Azure do not allow mixed type (public and internal) load balancer.
0000000000000000000000000000000000000000;;	// So we'd have a separate name for internal load balancer.
0000000000000000000000000000000000000000;;	// This would be the name for Azure LoadBalancer resource.
0000000000000000000000000000000000000000;;	func getLoadBalancerName(clusterName string, isInternal bool) string {
0000000000000000000000000000000000000000;;		if isInternal {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s-internal", clusterName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clusterName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getBackendPoolName(clusterName string) string {
0000000000000000000000000000000000000000;;		return clusterName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getLoadBalancerRuleName(service *v1.Service, port v1.ServicePort) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%s-%d", getRulePrefix(service), port.Protocol, port.Port)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSecurityRuleName(service *v1.Service, port v1.ServicePort, sourceAddrPrefix string) string {
0000000000000000000000000000000000000000;;		safePrefix := strings.Replace(sourceAddrPrefix, "/", "_", -1)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%s-%d-%s", getRulePrefix(service), port.Protocol, port.Port, safePrefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This returns a human-readable version of the Service used to tag some resources.
0000000000000000000000000000000000000000;;	// This is only used for human-readable convenience, and not to filter.
0000000000000000000000000000000000000000;;	func getServiceName(service *v1.Service) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s", service.Namespace, service.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This returns a prefix for loadbalancer/security rules.
0000000000000000000000000000000000000000;;	func getRulePrefix(service *v1.Service) string {
0000000000000000000000000000000000000000;;		return cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPublicIPName(clusterName string, service *v1.Service) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%s", clusterName, cloudprovider.GetLoadBalancerName(service))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceOwnsRule(service *v1.Service, rule string) bool {
0000000000000000000000000000000000000000;;		prefix := getRulePrefix(service)
0000000000000000000000000000000000000000;;		return strings.HasPrefix(strings.ToUpper(rule), strings.ToUpper(prefix))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getFrontendIPConfigName(service *v1.Service) string {
0000000000000000000000000000000000000000;;		return cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This returns the next available rule priority level for a given set of security rules.
0000000000000000000000000000000000000000;;	func getNextAvailablePriority(rules []network.SecurityRule) (int32, error) {
0000000000000000000000000000000000000000;;		var smallest int32 = loadBalancerMinimumPriority
0000000000000000000000000000000000000000;;		var spread int32 = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	outer:
0000000000000000000000000000000000000000;;		for smallest < loadBalancerMaximumPriority {
0000000000000000000000000000000000000000;;			for _, rule := range rules {
0000000000000000000000000000000000000000;;				if *rule.Priority == smallest {
0000000000000000000000000000000000000000;;					smallest += spread
0000000000000000000000000000000000000000;;					continue outer
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// no one else had it
0000000000000000000000000000000000000000;;			return smallest, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return -1, fmt.Errorf("SecurityGroup priorities are exhausted")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (az *Cloud) getIPForMachine(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		machine, exists, err := az.getVirtualMachine(nodeName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return "", cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("error: az.getIPForMachine(%s), az.getVirtualMachine(%s), err=%v", nodeName, nodeName, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nicID, err := getPrimaryInterfaceID(machine)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("error: az.getIPForMachine(%s), getPrimaryInterfaceID(%v), err=%v", nodeName, machine, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nicName, err := getLastSegment(nicID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("error: az.getIPForMachine(%s), getLastSegment(%s), err=%v", nodeName, nicID, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		nic, err := az.InterfacesClient.Get(az.ResourceGroup, nicName, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("error: az.getIPForMachine(%s), az.InterfacesClient.Get(%s, %s, %s), err=%v", nodeName, az.ResourceGroup, nicName, "", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipConfig, err := getPrimaryIPConfig(nic)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("error: az.getIPForMachine(%s), getPrimaryIPConfig(%v), err=%v", nodeName, nic, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targetIP := *ipConfig.PrivateIPAddress
0000000000000000000000000000000000000000;;		return targetIP, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitProviderID converts a providerID to a NodeName.
0000000000000000000000000000000000000000;;	func splitProviderID(providerID string) (types.NodeName, error) {
0000000000000000000000000000000000000000;;		matches := providerIDRE.FindStringSubmatch(providerID)
0000000000000000000000000000000000000000;;		if len(matches) != 2 {
0000000000000000000000000000000000000000;;			return "", errors.New("error splitting providerID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types.NodeName(matches[1]), nil
0000000000000000000000000000000000000000;;	}
