0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f050e96cf08b79e447c6733a930c9ec7df26eb44;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		serviceapi "k8s.io/kubernetes/pkg/api/v1/service"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/network"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/to"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testClusterName = "testCluster"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test additional of a new service/port.
0000000000000000000000000000000000000000;;	func TestReconcileLoadBalancerAddPort(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc := getTestService("servicea", v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;		configProperties := getTestPublicFipConfigurationProperties()
0000000000000000000000000000000000000000;;		lb := getTestLoadBalancer()
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc.Spec.Ports = append(svc.Spec.Ports, v1.ServicePort{
0000000000000000000000000000000000000000;;			Name:     fmt.Sprintf("port-udp-%d", 1234),
0000000000000000000000000000000000000000;;			Protocol: v1.ProtocolUDP,
0000000000000000000000000000000000000000;;			Port:     1234,
0000000000000000000000000000000000000000;;			NodePort: getBackendPort(1234),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, updated, err := az.reconcileLoadBalancer(lb, &configProperties, testClusterName, &svc, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to need an update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we got a frontend ip configuration
0000000000000000000000000000000000000000;;		if len(*lb.FrontendIPConfigurations) != 1 {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to have a frontend ip configuration")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, lb, svc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcileLoadBalancerNodeHealth(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc := getTestService("servicea", v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;		svc.Spec.ExternalTrafficPolicy = v1.ServiceExternalTrafficPolicyTypeLocal
0000000000000000000000000000000000000000;;		svc.Spec.HealthCheckNodePort = int32(32456)
0000000000000000000000000000000000000000;;		configProperties := getTestPublicFipConfigurationProperties()
0000000000000000000000000000000000000000;;		lb := getTestLoadBalancer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, updated, err := az.reconcileLoadBalancer(lb, &configProperties, testClusterName, &svc, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to need an update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we got a frontend ip configuration
0000000000000000000000000000000000000000;;		if len(*lb.FrontendIPConfigurations) != 1 {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to have a frontend ip configuration")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, lb, svc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test removing all services results in removing the frontend ip configuration
0000000000000000000000000000000000000000;;	func TestReconcileLoadBalancerRemoveService(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc := getTestService("servicea", v1.ProtocolTCP, 80, 443)
0000000000000000000000000000000000000000;;		lb := getTestLoadBalancer()
0000000000000000000000000000000000000000;;		configProperties := getTestPublicFipConfigurationProperties()
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, updated, err := az.reconcileLoadBalancer(lb, &configProperties, testClusterName, &svc, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, lb, svc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, updated, err = az.reconcileLoadBalancer(lb, nil, testClusterName, &svc, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to need an update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we abandoned the frontend ip configuration
0000000000000000000000000000000000000000;;		if len(*lb.FrontendIPConfigurations) != 0 {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to have no frontend ip configuration")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, lb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test removing all service ports results in removing the frontend ip configuration
0000000000000000000000000000000000000000;;	func TestReconcileLoadBalancerRemoveAllPortsRemovesFrontendConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc := getTestService("servicea", v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;		lb := getTestLoadBalancer()
0000000000000000000000000000000000000000;;		configProperties := getTestPublicFipConfigurationProperties()
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, updated, err := az.reconcileLoadBalancer(lb, &configProperties, testClusterName, &svc, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, lb, svc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcUpdated := getTestService("servicea", v1.ProtocolTCP)
0000000000000000000000000000000000000000;;		lb, updated, err = az.reconcileLoadBalancer(lb, nil, testClusterName, &svcUpdated, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !updated {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to need an update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we abandoned the frontend ip configuration
0000000000000000000000000000000000000000;;		if len(*lb.FrontendIPConfigurations) != 0 {
0000000000000000000000000000000000000000;;			t.Error("Expected the loadbalancer to have no frontend ip configuration")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, lb, svcUpdated)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test removal of a port from an existing service.
0000000000000000000000000000000000000000;;	func TestReconcileLoadBalancerRemovesPort(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc := getTestService("servicea", v1.ProtocolTCP, 80, 443)
0000000000000000000000000000000000000000;;		configProperties := getTestPublicFipConfigurationProperties()
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingLoadBalancer := getTestLoadBalancer(svc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcUpdated := getTestService("servicea", v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;		updatedLoadBalancer, _, err := az.reconcileLoadBalancer(existingLoadBalancer, &configProperties, testClusterName, &svcUpdated, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, updatedLoadBalancer, svcUpdated)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test reconciliation of multiple services on same port
0000000000000000000000000000000000000000;;	func TestReconcileLoadBalancerMultipleServices(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc1 := getTestService("servicea", v1.ProtocolTCP, 80, 443)
0000000000000000000000000000000000000000;;		svc2 := getTestService("serviceb", v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;		configProperties := getTestPublicFipConfigurationProperties()
0000000000000000000000000000000000000000;;		nodes := []*v1.Node{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingLoadBalancer := getTestLoadBalancer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedLoadBalancer, _, err := az.reconcileLoadBalancer(existingLoadBalancer, &configProperties, testClusterName, &svc1, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedLoadBalancer, _, err = az.reconcileLoadBalancer(updatedLoadBalancer, &configProperties, testClusterName, &svc2, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateLoadBalancer(t, updatedLoadBalancer, svc1, svc2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcileSecurityGroupNewServiceAddsPort(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc1 := getTestService("serviceea", v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg := getTestSecurityGroup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg, _, err := az.reconcileSecurityGroup(sg, testClusterName, &svc1, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateSecurityGroup(t, sg, svc1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcileSecurityGroupNewInternalServiceAddsPort(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc1 := getInternalTestService("serviceea", 80)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg := getTestSecurityGroup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg, _, err := az.reconcileSecurityGroup(sg, testClusterName, &svc1, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateSecurityGroup(t, sg, svc1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcileSecurityGroupRemoveService(t *testing.T) {
0000000000000000000000000000000000000000;;		service1 := getTestService("servicea", v1.ProtocolTCP, 81)
0000000000000000000000000000000000000000;;		service2 := getTestService("serviceb", v1.ProtocolTCP, 82)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg := getTestSecurityGroup(service1, service2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateSecurityGroup(t, sg, service1, service2)
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		sg, _, err := az.reconcileSecurityGroup(sg, testClusterName, &service1, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateSecurityGroup(t, sg, service2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcileSecurityGroupRemoveServiceRemovesPort(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc := getTestService("servicea", v1.ProtocolTCP, 80, 443)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg := getTestSecurityGroup(svc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svcUpdated := getTestService("servicea", v1.ProtocolTCP, 80)
0000000000000000000000000000000000000000;;		sg, _, err := az.reconcileSecurityGroup(sg, testClusterName, &svcUpdated, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateSecurityGroup(t, sg, svcUpdated)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReconcileSecurityWithSourceRanges(t *testing.T) {
0000000000000000000000000000000000000000;;		az := getTestCloud()
0000000000000000000000000000000000000000;;		svc := getTestService("servicea", v1.ProtocolTCP, 80, 443)
0000000000000000000000000000000000000000;;		svc.Spec.LoadBalancerSourceRanges = []string{
0000000000000000000000000000000000000000;;			"192.168.0.0/24",
0000000000000000000000000000000000000000;;			"10.0.0.0/32",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg := getTestSecurityGroup(svc)
0000000000000000000000000000000000000000;;		sg, _, err := az.reconcileSecurityGroup(sg, testClusterName, &svc, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateSecurityGroup(t, sg, svc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestCloud() *Cloud {
0000000000000000000000000000000000000000;;		return &Cloud{
0000000000000000000000000000000000000000;;			Config: Config{
0000000000000000000000000000000000000000;;				TenantID:          "tenant",
0000000000000000000000000000000000000000;;				SubscriptionID:    "subscription",
0000000000000000000000000000000000000000;;				ResourceGroup:     "rg",
0000000000000000000000000000000000000000;;				Location:          "westus",
0000000000000000000000000000000000000000;;				VnetName:          "vnet",
0000000000000000000000000000000000000000;;				SubnetName:        "subnet",
0000000000000000000000000000000000000000;;				SecurityGroupName: "nsg",
0000000000000000000000000000000000000000;;				RouteTableName:    "rt",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getBackendPort(port int32) int32 {
0000000000000000000000000000000000000000;;		return port + 10000
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestPublicFipConfigurationProperties() network.FrontendIPConfigurationPropertiesFormat {
0000000000000000000000000000000000000000;;		return network.FrontendIPConfigurationPropertiesFormat{
0000000000000000000000000000000000000000;;			PublicIPAddress: &network.PublicIPAddress{ID: to.StringPtr("/this/is/a/public/ip/address/id")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestService(identifier string, proto v1.Protocol, requestedPorts ...int32) v1.Service {
0000000000000000000000000000000000000000;;		ports := []v1.ServicePort{}
0000000000000000000000000000000000000000;;		for _, port := range requestedPorts {
0000000000000000000000000000000000000000;;			ports = append(ports, v1.ServicePort{
0000000000000000000000000000000000000000;;				Name:     fmt.Sprintf("port-tcp-%d", port),
0000000000000000000000000000000000000000;;				Protocol: proto,
0000000000000000000000000000000000000000;;				Port:     port,
0000000000000000000000000000000000000000;;				NodePort: getBackendPort(port),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc := v1.Service{
0000000000000000000000000000000000000000;;			Spec: v1.ServiceSpec{
0000000000000000000000000000000000000000;;				Type:  v1.ServiceTypeLoadBalancer,
0000000000000000000000000000000000000000;;				Ports: ports,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svc.Name = identifier
0000000000000000000000000000000000000000;;		svc.Namespace = "default"
0000000000000000000000000000000000000000;;		svc.UID = types.UID(identifier)
0000000000000000000000000000000000000000;;		svc.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInternalTestService(identifier string, requestedPorts ...int32) v1.Service {
0000000000000000000000000000000000000000;;		svc := getTestService(identifier, v1.ProtocolTCP, requestedPorts...)
0000000000000000000000000000000000000000;;		svc.Annotations[ServiceAnnotationLoadBalancerInternal] = "true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestLoadBalancer(services ...v1.Service) network.LoadBalancer {
0000000000000000000000000000000000000000;;		rules := []network.LoadBalancingRule{}
0000000000000000000000000000000000000000;;		probes := []network.Probe{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, service := range services {
0000000000000000000000000000000000000000;;			for _, port := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				ruleName := getLoadBalancerRuleName(&service, port)
0000000000000000000000000000000000000000;;				rules = append(rules, network.LoadBalancingRule{
0000000000000000000000000000000000000000;;					Name: to.StringPtr(ruleName),
0000000000000000000000000000000000000000;;					LoadBalancingRulePropertiesFormat: &network.LoadBalancingRulePropertiesFormat{
0000000000000000000000000000000000000000;;						FrontendPort: to.Int32Ptr(port.Port),
0000000000000000000000000000000000000000;;						BackendPort:  to.Int32Ptr(port.Port),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				probes = append(probes, network.Probe{
0000000000000000000000000000000000000000;;					Name: to.StringPtr(ruleName),
0000000000000000000000000000000000000000;;					ProbePropertiesFormat: &network.ProbePropertiesFormat{
0000000000000000000000000000000000000000;;						Port: to.Int32Ptr(port.NodePort),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb := network.LoadBalancer{
0000000000000000000000000000000000000000;;			LoadBalancerPropertiesFormat: &network.LoadBalancerPropertiesFormat{
0000000000000000000000000000000000000000;;				LoadBalancingRules: &rules,
0000000000000000000000000000000000000000;;				Probes:             &probes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lb
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getServiceSourceRanges(service *v1.Service) []string {
0000000000000000000000000000000000000000;;		if len(service.Spec.LoadBalancerSourceRanges) == 0 {
0000000000000000000000000000000000000000;;			if !requiresInternalLoadBalancer(service) {
0000000000000000000000000000000000000000;;				return []string{"Internet"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return service.Spec.LoadBalancerSourceRanges
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestSecurityGroup(services ...v1.Service) network.SecurityGroup {
0000000000000000000000000000000000000000;;		rules := []network.SecurityRule{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, service := range services {
0000000000000000000000000000000000000000;;			for _, port := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				sources := getServiceSourceRanges(&service)
0000000000000000000000000000000000000000;;				for _, src := range sources {
0000000000000000000000000000000000000000;;					ruleName := getSecurityRuleName(&service, port, src)
0000000000000000000000000000000000000000;;					rules = append(rules, network.SecurityRule{
0000000000000000000000000000000000000000;;						Name: to.StringPtr(ruleName),
0000000000000000000000000000000000000000;;						SecurityRulePropertiesFormat: &network.SecurityRulePropertiesFormat{
0000000000000000000000000000000000000000;;							SourceAddressPrefix:  to.StringPtr(src),
0000000000000000000000000000000000000000;;							DestinationPortRange: to.StringPtr(fmt.Sprintf("%d", port.Port)),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg := network.SecurityGroup{
0000000000000000000000000000000000000000;;			SecurityGroupPropertiesFormat: &network.SecurityGroupPropertiesFormat{
0000000000000000000000000000000000000000;;				SecurityRules: &rules,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateLoadBalancer(t *testing.T, loadBalancer network.LoadBalancer, services ...v1.Service) {
0000000000000000000000000000000000000000;;		expectedRuleCount := 0
0000000000000000000000000000000000000000;;		expectedFrontendIPCount := 0
0000000000000000000000000000000000000000;;		expectedProbeCount := 0
0000000000000000000000000000000000000000;;		for _, svc := range services {
0000000000000000000000000000000000000000;;			if len(svc.Spec.Ports) > 0 {
0000000000000000000000000000000000000000;;				expectedFrontendIPCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, wantedRule := range svc.Spec.Ports {
0000000000000000000000000000000000000000;;				expectedRuleCount++
0000000000000000000000000000000000000000;;				wantedRuleName := getLoadBalancerRuleName(&svc, wantedRule)
0000000000000000000000000000000000000000;;				foundRule := false
0000000000000000000000000000000000000000;;				for _, actualRule := range *loadBalancer.LoadBalancingRules {
0000000000000000000000000000000000000000;;					if strings.EqualFold(*actualRule.Name, wantedRuleName) &&
0000000000000000000000000000000000000000;;						*actualRule.FrontendPort == wantedRule.Port &&
0000000000000000000000000000000000000000;;						*actualRule.BackendPort == wantedRule.Port {
0000000000000000000000000000000000000000;;						foundRule = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !foundRule {
0000000000000000000000000000000000000000;;					t.Errorf("Expected load balancer rule but didn't find it: %q", wantedRuleName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if UDP rule, there is no probe
0000000000000000000000000000000000000000;;				if wantedRule.Protocol == v1.ProtocolUDP {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedProbeCount++
0000000000000000000000000000000000000000;;				foundProbe := false
0000000000000000000000000000000000000000;;				if serviceapi.NeedsHealthCheck(&svc) {
0000000000000000000000000000000000000000;;					path, port := serviceapi.GetServiceHealthCheckPathPort(&svc)
0000000000000000000000000000000000000000;;					for _, actualProbe := range *loadBalancer.Probes {
0000000000000000000000000000000000000000;;						if strings.EqualFold(*actualProbe.Name, wantedRuleName) &&
0000000000000000000000000000000000000000;;							*actualProbe.Port == port &&
0000000000000000000000000000000000000000;;							*actualProbe.RequestPath == path &&
0000000000000000000000000000000000000000;;							actualProbe.Protocol == network.ProbeProtocolHTTP {
0000000000000000000000000000000000000000;;							foundProbe = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					for _, actualProbe := range *loadBalancer.Probes {
0000000000000000000000000000000000000000;;						if strings.EqualFold(*actualProbe.Name, wantedRuleName) &&
0000000000000000000000000000000000000000;;							*actualProbe.Port == wantedRule.NodePort {
0000000000000000000000000000000000000000;;							foundProbe = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !foundProbe {
0000000000000000000000000000000000000000;;					for _, actualProbe := range *loadBalancer.Probes {
0000000000000000000000000000000000000000;;						t.Logf("Probe: %s %d", *actualProbe.Name, *actualProbe.Port)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t.Errorf("Expected loadbalancer probe but didn't find it: %q", wantedRuleName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frontendIPCount := len(*loadBalancer.FrontendIPConfigurations)
0000000000000000000000000000000000000000;;		if frontendIPCount != expectedFrontendIPCount {
0000000000000000000000000000000000000000;;			t.Errorf("Expected the loadbalancer to have %d frontend IPs. Found %d.\n%v", expectedFrontendIPCount, frontendIPCount, loadBalancer.FrontendIPConfigurations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lenRules := len(*loadBalancer.LoadBalancingRules)
0000000000000000000000000000000000000000;;		if lenRules != expectedRuleCount {
0000000000000000000000000000000000000000;;			t.Errorf("Expected the loadbalancer to have %d rules. Found %d.\n%v", expectedRuleCount, lenRules, loadBalancer.LoadBalancingRules)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lenProbes := len(*loadBalancer.Probes)
0000000000000000000000000000000000000000;;		if lenProbes != expectedProbeCount {
0000000000000000000000000000000000000000;;			t.Errorf("Expected the loadbalancer to have %d probes. Found %d.", expectedRuleCount, lenProbes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateSecurityGroup(t *testing.T, securityGroup network.SecurityGroup, services ...v1.Service) {
0000000000000000000000000000000000000000;;		expectedRuleCount := 0
0000000000000000000000000000000000000000;;		for _, svc := range services {
0000000000000000000000000000000000000000;;			for _, wantedRule := range svc.Spec.Ports {
0000000000000000000000000000000000000000;;				sources := getServiceSourceRanges(&svc)
0000000000000000000000000000000000000000;;				for _, source := range sources {
0000000000000000000000000000000000000000;;					wantedRuleName := getSecurityRuleName(&svc, wantedRule, source)
0000000000000000000000000000000000000000;;					expectedRuleCount++
0000000000000000000000000000000000000000;;					foundRule := false
0000000000000000000000000000000000000000;;					for _, actualRule := range *securityGroup.SecurityRules {
0000000000000000000000000000000000000000;;						if strings.EqualFold(*actualRule.Name, wantedRuleName) &&
0000000000000000000000000000000000000000;;							*actualRule.SourceAddressPrefix == source &&
0000000000000000000000000000000000000000;;							*actualRule.DestinationPortRange == fmt.Sprintf("%d", wantedRule.Port) {
0000000000000000000000000000000000000000;;							foundRule = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !foundRule {
0000000000000000000000000000000000000000;;						t.Errorf("Expected security group rule but didn't find it: %q", wantedRuleName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lenRules := len(*securityGroup.SecurityRules)
0000000000000000000000000000000000000000;;		if lenRules != expectedRuleCount {
0000000000000000000000000000000000000000;;			t.Errorf("Expected the loadbalancer to have %d rules. Found %d.\n", expectedRuleCount, lenRules)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecurityRulePriorityPicksNextAvailablePriority(t *testing.T) {
0000000000000000000000000000000000000000;;		rules := []network.SecurityRule{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var expectedPriority int32 = loadBalancerMinimumPriority + 50
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var i int32
0000000000000000000000000000000000000000;;		for i = loadBalancerMinimumPriority; i < expectedPriority; i++ {
0000000000000000000000000000000000000000;;			rules = append(rules, network.SecurityRule{
0000000000000000000000000000000000000000;;				SecurityRulePropertiesFormat: &network.SecurityRulePropertiesFormat{
0000000000000000000000000000000000000000;;					Priority: to.Int32Ptr(i),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priority, err := getNextAvailablePriority(rules)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpectected error: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if priority != expectedPriority {
0000000000000000000000000000000000000000;;			t.Errorf("Expected priority %d. Got priority %d.", expectedPriority, priority)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSecurityRulePriorityFailsIfExhausted(t *testing.T) {
0000000000000000000000000000000000000000;;		rules := []network.SecurityRule{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var i int32
0000000000000000000000000000000000000000;;		for i = loadBalancerMinimumPriority; i < loadBalancerMaximumPriority; i++ {
0000000000000000000000000000000000000000;;			rules = append(rules, network.SecurityRule{
0000000000000000000000000000000000000000;;				SecurityRulePropertiesFormat: &network.SecurityRulePropertiesFormat{
0000000000000000000000000000000000000000;;					Priority: to.Int32Ptr(i),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := getNextAvailablePriority(rules)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Error("Expectected an error. There are no priority levels left.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProtocolTranslationTCP(t *testing.T) {
0000000000000000000000000000000000000000;;		proto := v1.ProtocolTCP
0000000000000000000000000000000000000000;;		transportProto, securityGroupProto, probeProto, err := getProtocolsFromKubernetesProtocol(proto)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *transportProto != network.TransportProtocolTCP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected TCP LoadBalancer Rule Protocol. Got %v", transportProto)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *securityGroupProto != network.SecurityRuleProtocolTCP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected TCP SecurityGroup Protocol. Got %v", transportProto)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *probeProto != network.ProbeProtocolTCP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected TCP LoadBalancer Probe Protocol. Got %v", transportProto)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProtocolTranslationUDP(t *testing.T) {
0000000000000000000000000000000000000000;;		proto := v1.ProtocolUDP
0000000000000000000000000000000000000000;;		transportProto, securityGroupProto, probeProto, _ := getProtocolsFromKubernetesProtocol(proto)
0000000000000000000000000000000000000000;;		if *transportProto != network.TransportProtocolUDP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected UDP LoadBalancer Rule Protocol. Got %v", transportProto)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *securityGroupProto != network.SecurityRuleProtocolUDP {
0000000000000000000000000000000000000000;;			t.Errorf("Expected UDP SecurityGroup Protocol. Got %v", transportProto)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if probeProto != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected UDP LoadBalancer Probe Protocol. Got %v", transportProto)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test Configuration deserialization (json)
0000000000000000000000000000000000000000;;	func TestNewCloudFromJSON(t *testing.T) {
0000000000000000000000000000000000000000;;		config := `{
0000000000000000000000000000000000000000;;			"tenantId": "--tenant-id--",
0000000000000000000000000000000000000000;;			"subscriptionId": "--subscription-id--",
0000000000000000000000000000000000000000;;			"aadClientId": "--aad-client-id--",
0000000000000000000000000000000000000000;;			"aadClientSecret": "--aad-client-secret--",
0000000000000000000000000000000000000000;;			"aadClientCertPath": "--aad-client-cert-path--",
0000000000000000000000000000000000000000;;			"aadClientCertPassword": "--aad-client-cert-password--",
0000000000000000000000000000000000000000;;			"resourceGroup": "--resource-group--",
0000000000000000000000000000000000000000;;			"location": "--location--",
0000000000000000000000000000000000000000;;			"subnetName": "--subnet-name--",
0000000000000000000000000000000000000000;;			"securityGroupName": "--security-group-name--",
0000000000000000000000000000000000000000;;			"vnetName": "--vnet-name--",
0000000000000000000000000000000000000000;;			"routeTableName": "--route-table-name--",
0000000000000000000000000000000000000000;;			"primaryAvailabilitySetName": "--primary-availability-set-name--",
0000000000000000000000000000000000000000;;			"cloudProviderBackoff": true,
0000000000000000000000000000000000000000;;			"cloudProviderBackoffRetries": 6,
0000000000000000000000000000000000000000;;			"cloudProviderBackoffExponent": 1.5,
0000000000000000000000000000000000000000;;			"cloudProviderBackoffDuration": 5,
0000000000000000000000000000000000000000;;			"cloudProviderBackoffJitter": 1.0,
0000000000000000000000000000000000000000;;			"cloudProviderRatelimit": true,
0000000000000000000000000000000000000000;;			"cloudProviderRateLimitQPS": 0.5,
0000000000000000000000000000000000000000;;			"cloudProviderRateLimitBucket": 5
0000000000000000000000000000000000000000;;		}`
0000000000000000000000000000000000000000;;		validateConfig(t, config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test Backoff and Rate Limit defaults (json)
0000000000000000000000000000000000000000;;	func TestCloudDefaultConfigFromJSON(t *testing.T) {
0000000000000000000000000000000000000000;;		config := `{
0000000000000000000000000000000000000000;;	                "aadClientId": "--aad-client-id--",
0000000000000000000000000000000000000000;;	                "aadClientSecret": "--aad-client-secret--"
0000000000000000000000000000000000000000;;	        }`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateEmptyConfig(t, config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test Backoff and Rate Limit defaults (yaml)
0000000000000000000000000000000000000000;;	func TestCloudDefaultConfigFromYAML(t *testing.T) {
0000000000000000000000000000000000000000;;		config := `
0000000000000000000000000000000000000000;;	aadClientId: --aad-client-id--
0000000000000000000000000000000000000000;;	aadClientSecret: --aad-client-secret--
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		validateEmptyConfig(t, config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test Configuration deserialization (yaml)
0000000000000000000000000000000000000000;;	func TestNewCloudFromYAML(t *testing.T) {
0000000000000000000000000000000000000000;;		config := `
0000000000000000000000000000000000000000;;	tenantId: --tenant-id--
0000000000000000000000000000000000000000;;	subscriptionId: --subscription-id--
0000000000000000000000000000000000000000;;	aadClientId: --aad-client-id--
0000000000000000000000000000000000000000;;	aadClientSecret: --aad-client-secret--
0000000000000000000000000000000000000000;;	aadClientCertPath: --aad-client-cert-path--
0000000000000000000000000000000000000000;;	aadClientCertPassword: --aad-client-cert-password--
0000000000000000000000000000000000000000;;	resourceGroup: --resource-group--
0000000000000000000000000000000000000000;;	location: --location--
0000000000000000000000000000000000000000;;	subnetName: --subnet-name--
0000000000000000000000000000000000000000;;	securityGroupName: --security-group-name--
0000000000000000000000000000000000000000;;	vnetName: --vnet-name--
0000000000000000000000000000000000000000;;	routeTableName: --route-table-name--
0000000000000000000000000000000000000000;;	primaryAvailabilitySetName: --primary-availability-set-name--
0000000000000000000000000000000000000000;;	cloudProviderBackoff: true
0000000000000000000000000000000000000000;;	cloudProviderBackoffRetries: 6
0000000000000000000000000000000000000000;;	cloudProviderBackoffExponent: 1.5
0000000000000000000000000000000000000000;;	cloudProviderBackoffDuration: 5
0000000000000000000000000000000000000000;;	cloudProviderBackoffJitter: 1.0
0000000000000000000000000000000000000000;;	cloudProviderRatelimit: true
0000000000000000000000000000000000000000;;	cloudProviderRateLimitQPS: 0.5
0000000000000000000000000000000000000000;;	cloudProviderRateLimitBucket: 5
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;		validateConfig(t, config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateConfig(t *testing.T, config string) {
0000000000000000000000000000000000000000;;		azureCloud := getCloudFromConfig(t, config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if azureCloud.TenantID != "--tenant-id--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for TenantID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.SubscriptionID != "--subscription-id--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for SubscriptionID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.AADClientID != "--aad-client-id--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for AADClientID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.AADClientSecret != "--aad-client-secret--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for AADClientSecret")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.AADClientCertPath != "--aad-client-cert-path--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for AADClientCertPath")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.AADClientCertPassword != "--aad-client-cert-password--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for AADClientCertPassword")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.ResourceGroup != "--resource-group--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for ResourceGroup")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.Location != "--location--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for Location")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.SubnetName != "--subnet-name--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for SubnetName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.SecurityGroupName != "--security-group-name--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for SecurityGroupName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.VnetName != "--vnet-name--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for VnetName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.RouteTableName != "--route-table-name--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for RouteTableName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.PrimaryAvailabilitySetName != "--primary-availability-set-name--" {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for PrimaryAvailabilitySetName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderBackoff != true {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderBackoff")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderBackoffRetries != 6 {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderBackoffRetries")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderBackoffExponent != 1.5 {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderBackoffExponent")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderBackoffDuration != 5 {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderBackoffDuration")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderBackoffJitter != 1.0 {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderBackoffJitter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderRateLimit != true {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderRateLimit")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderRateLimitQPS != 0.5 {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderRateLimitQPS")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderRateLimitBucket != 5 {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderRateLimitBucket")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCloudFromConfig(t *testing.T, config string) *Cloud {
0000000000000000000000000000000000000000;;		configReader := strings.NewReader(config)
0000000000000000000000000000000000000000;;		cloud, err := NewCloud(configReader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		azureCloud, ok := cloud.(*Cloud)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Error("NewCloud returned incorrect type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return azureCloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO include checks for other appropriate default config parameters
0000000000000000000000000000000000000000;;	func validateEmptyConfig(t *testing.T, config string) {
0000000000000000000000000000000000000000;;		azureCloud := getCloudFromConfig(t, config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// backoff should be disabled by default if not explicitly enabled in config
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderBackoff != false {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderBackoff")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rate limits should be disabled by default if not explicitly enabled in config
0000000000000000000000000000000000000000;;		if azureCloud.CloudProviderRateLimit != false {
0000000000000000000000000000000000000000;;			t.Errorf("got incorrect value for CloudProviderRateLimit")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeInstanceInfo(t *testing.T) {
0000000000000000000000000000000000000000;;		response := `{"ID":"_azdev","UD":"0","FD":"99"}`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		faultDomain, err := readFaultDomain(strings.NewReader(response))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error("Unexpected error in ReadFaultDomain")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if faultDomain == nil {
0000000000000000000000000000000000000000;;			t.Error("Fault domain was unexpectedly nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *faultDomain != "99" {
0000000000000000000000000000000000000000;;			t.Error("got incorrect fault domain")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSplitProviderID(t *testing.T) {
0000000000000000000000000000000000000000;;		providers := []struct {
0000000000000000000000000000000000000000;;			providerID string
0000000000000000000000000000000000000000;;			name       types.NodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fail bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				providerID: CloudProviderName + ":///subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
0000000000000000000000000000000000000000;;				name:       "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
0000000000000000000000000000000000000000;;				fail:       false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				providerID: CloudProviderName + ":/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
0000000000000000000000000000000000000000;;				name:       "",
0000000000000000000000000000000000000000;;				fail:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				providerID: CloudProviderName + "://",
0000000000000000000000000000000000000000;;				name:       "",
0000000000000000000000000000000000000000;;				fail:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				providerID: ":///subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
0000000000000000000000000000000000000000;;				name:       "",
0000000000000000000000000000000000000000;;				fail:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				providerID: "aws:///subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroupName/providers/Microsoft.Compute/virtualMachines/k8s-agent-AAAAAAAA-0",
0000000000000000000000000000000000000000;;				name:       "",
0000000000000000000000000000000000000000;;				fail:       true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range providers {
0000000000000000000000000000000000000000;;			name, err := splitProviderID(test.providerID)
0000000000000000000000000000000000000000;;			if (err != nil) != test.fail {
0000000000000000000000000000000000000000;;				t.Errorf("Expected to failt=%t, with pattern %v", test.fail, test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.fail {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if name != test.name {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, but got %v", test.name, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMetadataParsing(t *testing.T) {
0000000000000000000000000000000000000000;;		data := `
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    "interface": [
0000000000000000000000000000000000000000;;	      {
0000000000000000000000000000000000000000;;	        "ipv4": {
0000000000000000000000000000000000000000;;	          "ipAddress": [
0000000000000000000000000000000000000000;;	            {
0000000000000000000000000000000000000000;;	              "privateIpAddress": "10.0.1.4",
0000000000000000000000000000000000000000;;	              "publicIpAddress": "X.X.X.X"
0000000000000000000000000000000000000000;;	            }
0000000000000000000000000000000000000000;;	          ],
0000000000000000000000000000000000000000;;	          "subnet": [
0000000000000000000000000000000000000000;;	            {
0000000000000000000000000000000000000000;;	              "address": "10.0.1.0",
0000000000000000000000000000000000000000;;	              "prefix": "24"
0000000000000000000000000000000000000000;;	            }
0000000000000000000000000000000000000000;;	          ]
0000000000000000000000000000000000000000;;	        },
0000000000000000000000000000000000000000;;	        "ipv6": {
0000000000000000000000000000000000000000;;	          "ipAddress": [
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	          ]
0000000000000000000000000000000000000000;;	        },
0000000000000000000000000000000000000000;;	        "macAddress": "002248020E1E"
0000000000000000000000000000000000000000;;	      }
0000000000000000000000000000000000000000;;	    ]
0000000000000000000000000000000000000000;;	}	
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		network := NetworkMetadata{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal([]byte(data), &network); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ip := network.Interface[0].IPV4.IPAddress[0].PrivateIP
0000000000000000000000000000000000000000;;		if ip != "10.0.1.4" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected value: %s, expected 10.0.1.4", ip)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			fmt.Fprintln(w, data)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SetMetadataURLForTesting(server.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		networkJSON := NetworkMetadata{}
0000000000000000000000000000000000000000;;		if err := QueryMetadataJSON("/some/path", &networkJSON); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(network, networkJSON) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected inequality:\n%#v\nvs\n%#v", network, networkJSON)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
