0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f050e96cf08b79e447c6733a930c9ec7df26eb44;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/compute"
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/network"
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/storage"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/adal"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/azure"
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/pkcs12"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// CloudProviderName is the value used for the --cloud-provider flag
0000000000000000000000000000000000000000;;		CloudProviderName      = "azure"
0000000000000000000000000000000000000000;;		rateLimitQPSDefault    = 1.0
0000000000000000000000000000000000000000;;		rateLimitBucketDefault = 5
0000000000000000000000000000000000000000;;		backoffRetriesDefault  = 6
0000000000000000000000000000000000000000;;		backoffExponentDefault = 1.5
0000000000000000000000000000000000000000;;		backoffDurationDefault = 5 // in seconds
0000000000000000000000000000000000000000;;		backoffJitterDefault   = 1.0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config holds the configuration parsed from the --cloud-config flag
0000000000000000000000000000000000000000;;	// All fields are required unless otherwise specified
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// The cloud environment identifier. Takes values from https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
0000000000000000000000000000000000000000;;		Cloud string `json:"cloud" yaml:"cloud"`
0000000000000000000000000000000000000000;;		// The AAD Tenant ID for the Subscription that the cluster is deployed in
0000000000000000000000000000000000000000;;		TenantID string `json:"tenantId" yaml:"tenantId"`
0000000000000000000000000000000000000000;;		// The ID of the Azure Subscription that the cluster is deployed in
0000000000000000000000000000000000000000;;		SubscriptionID string `json:"subscriptionId" yaml:"subscriptionId"`
0000000000000000000000000000000000000000;;		// The name of the resource group that the cluster is deployed in
0000000000000000000000000000000000000000;;		ResourceGroup string `json:"resourceGroup" yaml:"resourceGroup"`
0000000000000000000000000000000000000000;;		// The location of the resource group that the cluster is deployed in
0000000000000000000000000000000000000000;;		Location string `json:"location" yaml:"location"`
0000000000000000000000000000000000000000;;		// The name of the VNet that the cluster is deployed in
0000000000000000000000000000000000000000;;		VnetName string `json:"vnetName" yaml:"vnetName"`
0000000000000000000000000000000000000000;;		// The name of the subnet that the cluster is deployed in
0000000000000000000000000000000000000000;;		SubnetName string `json:"subnetName" yaml:"subnetName"`
0000000000000000000000000000000000000000;;		// The name of the security group attached to the cluster's subnet
0000000000000000000000000000000000000000;;		SecurityGroupName string `json:"securityGroupName" yaml:"securityGroupName"`
0000000000000000000000000000000000000000;;		// (Optional in 1.6) The name of the route table attached to the subnet that the cluster is deployed in
0000000000000000000000000000000000000000;;		RouteTableName string `json:"routeTableName" yaml:"routeTableName"`
0000000000000000000000000000000000000000;;		// (Optional) The name of the availability set that should be used as the load balancer backend
0000000000000000000000000000000000000000;;		// If this is set, the Azure cloudprovider will only add nodes from that availability set to the load
0000000000000000000000000000000000000000;;		// balancer backend pool. If this is not set, and multiple agent pools (availability sets) are used, then
0000000000000000000000000000000000000000;;		// the cloudprovider will try to add all nodes to a single backend pool which is forbidden.
0000000000000000000000000000000000000000;;		// In other words, if you use multiple agent pools (availability sets), you MUST set this field.
0000000000000000000000000000000000000000;;		PrimaryAvailabilitySetName string `json:"primaryAvailabilitySetName" yaml:"primaryAvailabilitySetName"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The ClientID for an AAD application with RBAC access to talk to Azure RM APIs
0000000000000000000000000000000000000000;;		AADClientID string `json:"aadClientId" yaml:"aadClientId"`
0000000000000000000000000000000000000000;;		// The ClientSecret for an AAD application with RBAC access to talk to Azure RM APIs
0000000000000000000000000000000000000000;;		AADClientSecret string `json:"aadClientSecret" yaml:"aadClientSecret"`
0000000000000000000000000000000000000000;;		// The path of a client certificate for an AAD application with RBAC access to talk to Azure RM APIs
0000000000000000000000000000000000000000;;		AADClientCertPath string `json:"aadClientCertPath" yaml:"aadClientCertPath"`
0000000000000000000000000000000000000000;;		// The password of the client certificate for an AAD application with RBAC access to talk to Azure RM APIs
0000000000000000000000000000000000000000;;		AADClientCertPassword string `json:"aadClientCertPassword" yaml:"aadClientCertPassword"`
0000000000000000000000000000000000000000;;		// Enable exponential backoff to manage resource request retries
0000000000000000000000000000000000000000;;		CloudProviderBackoff bool `json:"cloudProviderBackoff" yaml:"cloudProviderBackoff"`
0000000000000000000000000000000000000000;;		// Backoff retry limit
0000000000000000000000000000000000000000;;		CloudProviderBackoffRetries int `json:"cloudProviderBackoffRetries" yaml:"cloudProviderBackoffRetries"`
0000000000000000000000000000000000000000;;		// Backoff exponent
0000000000000000000000000000000000000000;;		CloudProviderBackoffExponent float64 `json:"cloudProviderBackoffExponent" yaml:"cloudProviderBackoffExponent"`
0000000000000000000000000000000000000000;;		// Backoff duration
0000000000000000000000000000000000000000;;		CloudProviderBackoffDuration int `json:"cloudProviderBackoffDuration" yaml:"cloudProviderBackoffDuration"`
0000000000000000000000000000000000000000;;		// Backoff jitter
0000000000000000000000000000000000000000;;		CloudProviderBackoffJitter float64 `json:"cloudProviderBackoffJitter" yaml:"cloudProviderBackoffJitter"`
0000000000000000000000000000000000000000;;		// Enable rate limiting
0000000000000000000000000000000000000000;;		CloudProviderRateLimit bool `json:"cloudProviderRateLimit" yaml:"cloudProviderRateLimit"`
0000000000000000000000000000000000000000;;		// Rate limit QPS
0000000000000000000000000000000000000000;;		CloudProviderRateLimitQPS float32 `json:"cloudProviderRateLimitQPS" yaml:"cloudProviderRateLimitQPS"`
0000000000000000000000000000000000000000;;		// Rate limit Bucket Size
0000000000000000000000000000000000000000;;		CloudProviderRateLimitBucket int `json:"cloudProviderRateLimitBucket" yaml:"cloudProviderRateLimitBucket"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use instance metadata service where possible
0000000000000000000000000000000000000000;;		UseInstanceMetadata bool `json:"useInstanceMetadata" yaml:"useInstanceMetadata"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cloud holds the config and clients
0000000000000000000000000000000000000000;;	type Cloud struct {
0000000000000000000000000000000000000000;;		Config
0000000000000000000000000000000000000000;;		Environment              azure.Environment
0000000000000000000000000000000000000000;;		RoutesClient             network.RoutesClient
0000000000000000000000000000000000000000;;		SubnetsClient            network.SubnetsClient
0000000000000000000000000000000000000000;;		InterfacesClient         network.InterfacesClient
0000000000000000000000000000000000000000;;		RouteTablesClient        network.RouteTablesClient
0000000000000000000000000000000000000000;;		LoadBalancerClient       network.LoadBalancersClient
0000000000000000000000000000000000000000;;		PublicIPAddressesClient  network.PublicIPAddressesClient
0000000000000000000000000000000000000000;;		SecurityGroupsClient     network.SecurityGroupsClient
0000000000000000000000000000000000000000;;		VirtualMachinesClient    compute.VirtualMachinesClient
0000000000000000000000000000000000000000;;		StorageAccountClient     storage.AccountsClient
0000000000000000000000000000000000000000;;		operationPollRateLimiter flowcontrol.RateLimiter
0000000000000000000000000000000000000000;;		resourceRequestBackoff   wait.Backoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		cloudprovider.RegisterCloudProvider(CloudProviderName, NewCloud)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodePkcs12 decodes a PKCS#12 client certificate by extracting the public certificate and
0000000000000000000000000000000000000000;;	// the private RSA key
0000000000000000000000000000000000000000;;	func decodePkcs12(pkcs []byte, password string) (*x509.Certificate, *rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		privateKey, certificate, err := pkcs12.Decode(pkcs, password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("decoding the PKCS#12 client certificate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rsaPrivateKey, isRsaKey := privateKey.(*rsa.PrivateKey)
0000000000000000000000000000000000000000;;		if !isRsaKey {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("PKCS#12 certificate must contain a RSA private key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return certificate, rsaPrivateKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newServicePrincipalToken creates a new service principal token based on the configuration
0000000000000000000000000000000000000000;;	func newServicePrincipalToken(az *Cloud) (*adal.ServicePrincipalToken, error) {
0000000000000000000000000000000000000000;;		oauthConfig, err := adal.NewOAuthConfig(az.Environment.ActiveDirectoryEndpoint, az.TenantID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("creating the OAuth config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(az.AADClientSecret) > 0 {
0000000000000000000000000000000000000000;;			return adal.NewServicePrincipalToken(
0000000000000000000000000000000000000000;;				*oauthConfig,
0000000000000000000000000000000000000000;;				az.AADClientID,
0000000000000000000000000000000000000000;;				az.AADClientSecret,
0000000000000000000000000000000000000000;;				az.Environment.ServiceManagementEndpoint)
0000000000000000000000000000000000000000;;		} else if len(az.AADClientCertPath) > 0 && len(az.AADClientCertPassword) > 0 {
0000000000000000000000000000000000000000;;			certData, err := ioutil.ReadFile(az.AADClientCertPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("reading the client certificate from file %s: %v", az.AADClientCertPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			certificate, privateKey, err := decodePkcs12(certData, az.AADClientCertPassword)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("decoding the client certificate: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return adal.NewServicePrincipalTokenFromCertificate(
0000000000000000000000000000000000000000;;				*oauthConfig,
0000000000000000000000000000000000000000;;				az.AADClientID,
0000000000000000000000000000000000000000;;				certificate,
0000000000000000000000000000000000000000;;				privateKey,
0000000000000000000000000000000000000000;;				az.Environment.ServiceManagementEndpoint)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No credentials provided for AAD application %s", az.AADClientID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCloud returns a Cloud with initialized clients
0000000000000000000000000000000000000000;;	func NewCloud(configReader io.Reader) (cloudprovider.Interface, error) {
0000000000000000000000000000000000000000;;		var az Cloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configContents, err := ioutil.ReadAll(configReader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = yaml.Unmarshal(configContents, &az)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if az.Cloud == "" {
0000000000000000000000000000000000000000;;			az.Environment = azure.PublicCloud
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			az.Environment, err = azure.EnvironmentFromName(az.Cloud)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePrincipalToken, err := newServicePrincipalToken(&az)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.SubnetsClient = network.NewSubnetsClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.SubnetsClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.SubnetsClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.SubnetsClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.SubnetsClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.RouteTablesClient = network.NewRouteTablesClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.RouteTablesClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.RouteTablesClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.RouteTablesClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.RouteTablesClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.RoutesClient = network.NewRoutesClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.RoutesClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.RoutesClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.RoutesClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.RoutesClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.InterfacesClient = network.NewInterfacesClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.InterfacesClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.InterfacesClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.InterfacesClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.InterfacesClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.LoadBalancerClient = network.NewLoadBalancersClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.LoadBalancerClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.LoadBalancerClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.LoadBalancerClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.LoadBalancerClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.VirtualMachinesClient = compute.NewVirtualMachinesClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.VirtualMachinesClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.VirtualMachinesClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.VirtualMachinesClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.VirtualMachinesClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.PublicIPAddressesClient = network.NewPublicIPAddressesClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.PublicIPAddressesClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.PublicIPAddressesClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.PublicIPAddressesClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.PublicIPAddressesClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.SecurityGroupsClient = network.NewSecurityGroupsClient(az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.SecurityGroupsClient.BaseURI = az.Environment.ResourceManagerEndpoint
0000000000000000000000000000000000000000;;		az.SecurityGroupsClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;		az.SecurityGroupsClient.PollingDelay = 5 * time.Second
0000000000000000000000000000000000000000;;		configureUserAgent(&az.SecurityGroupsClient.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.StorageAccountClient = storage.NewAccountsClientWithBaseURI(az.Environment.ResourceManagerEndpoint, az.SubscriptionID)
0000000000000000000000000000000000000000;;		az.StorageAccountClient.Authorizer = autorest.NewBearerAuthorizer(servicePrincipalToken)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Conditionally configure rate limits
0000000000000000000000000000000000000000;;		if az.CloudProviderRateLimit {
0000000000000000000000000000000000000000;;			// Assign rate limit defaults if no configuration was passed in
0000000000000000000000000000000000000000;;			if az.CloudProviderRateLimitQPS == 0 {
0000000000000000000000000000000000000000;;				az.CloudProviderRateLimitQPS = rateLimitQPSDefault
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if az.CloudProviderRateLimitBucket == 0 {
0000000000000000000000000000000000000000;;				az.CloudProviderRateLimitBucket = rateLimitBucketDefault
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter = flowcontrol.NewTokenBucketRateLimiter(
0000000000000000000000000000000000000000;;				az.CloudProviderRateLimitQPS,
0000000000000000000000000000000000000000;;				az.CloudProviderRateLimitBucket)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Azure cloudprovider using rate limit config: QPS=%d, bucket=%d",
0000000000000000000000000000000000000000;;				az.CloudProviderRateLimitQPS,
0000000000000000000000000000000000000000;;				az.CloudProviderRateLimitBucket)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// if rate limits are configured off, az.operationPollRateLimiter.Accept() is a no-op
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter = flowcontrol.NewFakeAlwaysRateLimiter()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Conditionally configure resource request backoff
0000000000000000000000000000000000000000;;		if az.CloudProviderBackoff {
0000000000000000000000000000000000000000;;			// Assign backoff defaults if no configuration was passed in
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoffRetries == 0 {
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffRetries = backoffRetriesDefault
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoffExponent == 0 {
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffExponent = backoffExponentDefault
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoffDuration == 0 {
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffDuration = backoffDurationDefault
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoffJitter == 0 {
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffJitter = backoffJitterDefault
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			az.resourceRequestBackoff = wait.Backoff{
0000000000000000000000000000000000000000;;				Steps:    az.CloudProviderBackoffRetries,
0000000000000000000000000000000000000000;;				Factor:   az.CloudProviderBackoffExponent,
0000000000000000000000000000000000000000;;				Duration: time.Duration(az.CloudProviderBackoffDuration) * time.Second,
0000000000000000000000000000000000000000;;				Jitter:   az.CloudProviderBackoffJitter,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Azure cloudprovider using retry backoff: retries=%d, exponent=%f, duration=%d, jitter=%f",
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffRetries,
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffExponent,
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffDuration,
0000000000000000000000000000000000000000;;				az.CloudProviderBackoffJitter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &az, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize passes a Kubernetes clientBuilder interface to the cloud provider
0000000000000000000000000000000000000000;;	func (az *Cloud) Initialize(clientBuilder controller.ControllerClientBuilder) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer returns a balancer interface. Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;	func (az *Cloud) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
0000000000000000000000000000000000000000;;		return az, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances returns an instances interface. Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;	func (az *Cloud) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		return az, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zones returns a zones interface. Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;	func (az *Cloud) Zones() (cloudprovider.Zones, bool) {
0000000000000000000000000000000000000000;;		return az, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clusters returns a clusters interface.  Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;	func (az *Cloud) Clusters() (cloudprovider.Clusters, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Routes returns a routes interface along with whether the interface is supported.
0000000000000000000000000000000000000000;;	func (az *Cloud) Routes() (cloudprovider.Routes, bool) {
0000000000000000000000000000000000000000;;		return az, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScrubDNS provides an opportunity for cloud-provider-specific code to process DNS settings for pods.
0000000000000000000000000000000000000000;;	func (az *Cloud) ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string) {
0000000000000000000000000000000000000000;;		return nameservers, searches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;	func (az *Cloud) ProviderName() string {
0000000000000000000000000000000000000000;;		return CloudProviderName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configureUserAgent configures the autorest client with a user agent that
0000000000000000000000000000000000000000;;	// includes "kubernetes" and the full kubernetes git version string
0000000000000000000000000000000000000000;;	// example:
0000000000000000000000000000000000000000;;	// Azure-SDK-for-Go/7.0.1-beta arm-network/2016-09-01; kubernetes-cloudprovider/v1.7.0-alpha.2.711+a2fadef8170bb0-dirty;
0000000000000000000000000000000000000000;;	func configureUserAgent(client *autorest.Client) {
0000000000000000000000000000000000000000;;		k8sVersion := version.Get().GitVersion
0000000000000000000000000000000000000000;;		client.UserAgent = fmt.Sprintf("%s; kubernetes-cloudprovider/%s", client.UserAgent, k8sVersion)
0000000000000000000000000000000000000000;;	}
