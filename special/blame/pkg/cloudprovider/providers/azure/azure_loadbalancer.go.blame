0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f050e96cf08b79e447c6733a930c9ec7df26eb44;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		serviceapi "k8s.io/kubernetes/pkg/api/v1/service"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/network"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/to"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerInternal is the annotation used on the service
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerInternal = "service.beta.kubernetes.io/azure-load-balancer-internal"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLoadBalancer returns whether the specified load balancer exists, and
0000000000000000000000000000000000000000;;	// if so, what its status is.
0000000000000000000000000000000000000000;;	func (az *Cloud) GetLoadBalancer(clusterName string, service *v1.Service) (status *v1.LoadBalancerStatus, exists bool, err error) {
0000000000000000000000000000000000000000;;		isInternal := requiresInternalLoadBalancer(service)
0000000000000000000000000000000000000000;;		lbName := getLoadBalancerName(clusterName, isInternal)
0000000000000000000000000000000000000000;;		serviceName := getServiceName(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, existsLb, err := az.getAzureLoadBalancer(lbName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existsLb {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("get(%s): lb(%s) - doesn't exist", serviceName, lbName)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var lbIP *string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isInternal {
0000000000000000000000000000000000000000;;			lbFrontendIPConfigName := getFrontendIPConfigName(service)
0000000000000000000000000000000000000000;;			for _, ipConfiguration := range *lb.FrontendIPConfigurations {
0000000000000000000000000000000000000000;;				if lbFrontendIPConfigName == *ipConfiguration.Name {
0000000000000000000000000000000000000000;;					lbIP = ipConfiguration.PrivateIPAddress
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: Consider also read address from lb's FrontendIPConfigurations
0000000000000000000000000000000000000000;;			pipName, err := az.determinePublicIPName(clusterName, service)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pip, existsPip, err := az.getPublicIPAddress(pipName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if existsPip {
0000000000000000000000000000000000000000;;				lbIP = pip.IPAddress
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lbIP == nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("get(%s): lb(%s) - IP doesn't exist", serviceName, lbName)
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.LoadBalancerStatus{
0000000000000000000000000000000000000000;;			Ingress: []v1.LoadBalancerIngress{{IP: *lbIP}},
0000000000000000000000000000000000000000;;		}, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (az *Cloud) determinePublicIPName(clusterName string, service *v1.Service) (string, error) {
0000000000000000000000000000000000000000;;		loadBalancerIP := service.Spec.LoadBalancerIP
0000000000000000000000000000000000000000;;		if len(loadBalancerIP) == 0 {
0000000000000000000000000000000000000000;;			return getPublicIPName(clusterName, service), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		list, err := az.PublicIPAddressesClient.List(az.ResourceGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if list.Value != nil {
0000000000000000000000000000000000000000;;			for ix := range *list.Value {
0000000000000000000000000000000000000000;;				ip := &(*list.Value)[ix]
0000000000000000000000000000000000000000;;				if ip.PublicIPAddressPropertiesFormat.IPAddress != nil &&
0000000000000000000000000000000000000000;;					*ip.PublicIPAddressPropertiesFormat.IPAddress == loadBalancerIP {
0000000000000000000000000000000000000000;;					return *ip.Name, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: follow next link here? Will there really ever be that many public IPs?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("user supplied IP Address %s was not found", loadBalancerIP)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancer creates a new load balancer 'name', or updates the existing one. Returns the status of the balancer
0000000000000000000000000000000000000000;;	func (az *Cloud) EnsureLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		isInternal := requiresInternalLoadBalancer(service)
0000000000000000000000000000000000000000;;		lbName := getLoadBalancerName(clusterName, isInternal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a client updates the internal load balancer annotation,
0000000000000000000000000000000000000000;;		// the service may be switched from an internal LB to a public one, or vise versa.
0000000000000000000000000000000000000000;;		// Here we'll firstly ensure service do not lie in the opposite LB.
0000000000000000000000000000000000000000;;		err := az.cleanupLoadBalancer(clusterName, service, !isInternal)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceName := getServiceName(service)
0000000000000000000000000000000000000000;;		glog.V(5).Infof("ensure(%s): START clusterName=%q lbName=%q", serviceName, clusterName, lbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		sg, err := az.SecurityGroupsClient.Get(az.ResourceGroup, az.SecurityGroupName, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sg, sgNeedsUpdate, err := az.reconcileSecurityGroup(sg, clusterName, service, true /* wantLb */)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sgNeedsUpdate {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("ensure(%s): sg(%s) - updating", serviceName, *sg.Name)
0000000000000000000000000000000000000000;;			// azure-sdk-for-go introduced contraint validation which breaks the updating here if we don't set these
0000000000000000000000000000000000000000;;			// to nil. This is a workaround until https://github.com/Azure/go-autorest/issues/112 is fixed
0000000000000000000000000000000000000000;;			sg.SecurityGroupPropertiesFormat.NetworkInterfaces = nil
0000000000000000000000000000000000000000;;			sg.SecurityGroupPropertiesFormat.Subnets = nil
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.SecurityGroupsClient.CreateOrUpdate(az.ResourceGroup, *sg.Name, sg, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("ensure(%s) backing off: sg(%s) - updating", serviceName, *sg.Name)
0000000000000000000000000000000000000000;;				retryErr := az.CreateOrUpdateSGWithRetry(sg)
0000000000000000000000000000000000000000;;				if retryErr != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("ensure(%s) abort backoff: sg(%s) - updating", serviceName, *sg.Name)
0000000000000000000000000000000000000000;;					return nil, retryErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, existsLb, err := az.getAzureLoadBalancer(lbName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existsLb {
0000000000000000000000000000000000000000;;			lb = network.LoadBalancer{
0000000000000000000000000000000000000000;;				Name:                         &lbName,
0000000000000000000000000000000000000000;;				Location:                     &az.Location,
0000000000000000000000000000000000000000;;				LoadBalancerPropertiesFormat: &network.LoadBalancerPropertiesFormat{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var lbIP *string
0000000000000000000000000000000000000000;;		var fipConfigurationProperties *network.FrontendIPConfigurationPropertiesFormat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isInternal {
0000000000000000000000000000000000000000;;			subnet, existsSubnet, err := az.getSubnet(az.VnetName, az.SubnetName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !existsSubnet {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("ensure(%s): lb(%s) - failed to get subnet: %s/%s", serviceName, lbName, az.VnetName, az.SubnetName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			configProperties := network.FrontendIPConfigurationPropertiesFormat{
0000000000000000000000000000000000000000;;				Subnet: &network.Subnet{
0000000000000000000000000000000000000000;;					ID: subnet.ID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			loadBalancerIP := service.Spec.LoadBalancerIP
0000000000000000000000000000000000000000;;			if loadBalancerIP != "" {
0000000000000000000000000000000000000000;;				configProperties.PrivateIPAllocationMethod = network.Static
0000000000000000000000000000000000000000;;				configProperties.PrivateIPAddress = &loadBalancerIP
0000000000000000000000000000000000000000;;				lbIP = &loadBalancerIP
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// We'll need to call GetLoadBalancer later to retrieve allocated IP.
0000000000000000000000000000000000000000;;				configProperties.PrivateIPAllocationMethod = network.Dynamic
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fipConfigurationProperties = &configProperties
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pipName, err := az.determinePublicIPName(clusterName, service)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pip, err := az.ensurePublicIPExists(serviceName, pipName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lbIP = pip.IPAddress
0000000000000000000000000000000000000000;;			fipConfigurationProperties = &network.FrontendIPConfigurationPropertiesFormat{
0000000000000000000000000000000000000000;;				PublicIPAddress: &network.PublicIPAddress{ID: pip.ID},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, lbNeedsUpdate, err := az.reconcileLoadBalancer(lb, fipConfigurationProperties, clusterName, service, nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !existsLb || lbNeedsUpdate {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("ensure(%s): lb(%s) - updating", serviceName, lbName)
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.LoadBalancerClient.CreateOrUpdate(az.ResourceGroup, *lb.Name, lb, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("ensure(%s) backing off: lb(%s) - updating", serviceName, lbName)
0000000000000000000000000000000000000000;;				retryErr := az.CreateOrUpdateLBWithRetry(lb)
0000000000000000000000000000000000000000;;				if retryErr != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("ensure(%s) abort backoff: lb(%s) - updating", serviceName, lbName)
0000000000000000000000000000000000000000;;					return nil, retryErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the machines to the backend pool if they're not already
0000000000000000000000000000000000000000;;		lbBackendName := getBackendPoolName(clusterName)
0000000000000000000000000000000000000000;;		lbBackendPoolID := az.getBackendPoolID(lbName, lbBackendName)
0000000000000000000000000000000000000000;;		hostUpdates := make([]func() error, len(nodes))
0000000000000000000000000000000000000000;;		for i, node := range nodes {
0000000000000000000000000000000000000000;;			localNodeName := node.Name
0000000000000000000000000000000000000000;;			f := func() error {
0000000000000000000000000000000000000000;;				err := az.ensureHostInPool(serviceName, types.NodeName(localNodeName), lbBackendPoolID)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("ensure(%s): lb(%s) - failed to ensure host in pool: %q", serviceName, lbName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hostUpdates[i] = f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs := utilerrors.AggregateGoroutines(hostUpdates...)
0000000000000000000000000000000000000000;;		if errs != nil {
0000000000000000000000000000000000000000;;			return nil, utilerrors.Flatten(errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensure(%s): lb(%s) finished", serviceName, lbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lbIP == nil {
0000000000000000000000000000000000000000;;			lbStatus, exists, err := az.GetLoadBalancer(clusterName, service)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("ensure(%s): lb(%s) - failed to get back load balancer", serviceName, lbName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return lbStatus, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.LoadBalancerStatus{
0000000000000000000000000000000000000000;;			Ingress: []v1.LoadBalancerIngress{{IP: *lbIP}},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateLoadBalancer updates hosts under the specified load balancer.
0000000000000000000000000000000000000000;;	func (az *Cloud) UpdateLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		_, err := az.EnsureLoadBalancer(clusterName, service, nodes)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancerDeleted deletes the specified load balancer if it
0000000000000000000000000000000000000000;;	// exists, returning nil if the load balancer specified either didn't exist or
0000000000000000000000000000000000000000;;	// was successfully deleted.
0000000000000000000000000000000000000000;;	// This construction is useful because many cloud providers' load balancers
0000000000000000000000000000000000000000;;	// have multiple underlying components, meaning a Get could say that the LB
0000000000000000000000000000000000000000;;	// doesn't exist even if some part of it is still laying around.
0000000000000000000000000000000000000000;;	func (az *Cloud) EnsureLoadBalancerDeleted(clusterName string, service *v1.Service) error {
0000000000000000000000000000000000000000;;		isInternal := requiresInternalLoadBalancer(service)
0000000000000000000000000000000000000000;;		lbName := getLoadBalancerName(clusterName, isInternal)
0000000000000000000000000000000000000000;;		serviceName := getServiceName(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("delete(%s): START clusterName=%q lbName=%q", serviceName, clusterName, lbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := az.cleanupLoadBalancer(clusterName, service, isInternal)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg, existsSg, err := az.getSecurityGroup()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if existsSg {
0000000000000000000000000000000000000000;;			reconciledSg, sgNeedsUpdate, reconcileErr := az.reconcileSecurityGroup(sg, clusterName, service, false /* wantLb */)
0000000000000000000000000000000000000000;;			if reconcileErr != nil {
0000000000000000000000000000000000000000;;				return reconcileErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sgNeedsUpdate {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("delete(%s): sg(%s) - updating", serviceName, az.SecurityGroupName)
0000000000000000000000000000000000000000;;				// azure-sdk-for-go introduced contraint validation which breaks the updating here if we don't set these
0000000000000000000000000000000000000000;;				// to nil. This is a workaround until https://github.com/Azure/go-autorest/issues/112 is fixed
0000000000000000000000000000000000000000;;				sg.SecurityGroupPropertiesFormat.NetworkInterfaces = nil
0000000000000000000000000000000000000000;;				sg.SecurityGroupPropertiesFormat.Subnets = nil
0000000000000000000000000000000000000000;;				az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;				respChan, errChan := az.SecurityGroupsClient.CreateOrUpdate(az.ResourceGroup, *reconciledSg.Name, reconciledSg, nil)
0000000000000000000000000000000000000000;;				resp := <-respChan
0000000000000000000000000000000000000000;;				err := <-errChan
0000000000000000000000000000000000000000;;				if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("delete(%s) backing off: sg(%s) - updating", serviceName, az.SecurityGroupName)
0000000000000000000000000000000000000000;;					retryErr := az.CreateOrUpdateSGWithRetry(reconciledSg)
0000000000000000000000000000000000000000;;					if retryErr != nil {
0000000000000000000000000000000000000000;;						err = retryErr
0000000000000000000000000000000000000000;;						glog.V(2).Infof("delete(%s) abort backoff: sg(%s) - updating", serviceName, az.SecurityGroupName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("delete(%s): FINISH", serviceName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (az *Cloud) cleanupLoadBalancer(clusterName string, service *v1.Service, isInternalLb bool) error {
0000000000000000000000000000000000000000;;		lbName := getLoadBalancerName(clusterName, isInternalLb)
0000000000000000000000000000000000000000;;		serviceName := getServiceName(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(10).Infof("ensure lb deleted: clusterName=%q, serviceName=%s, lbName=%q", clusterName, serviceName, lbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lb, existsLb, err := az.getAzureLoadBalancer(lbName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if existsLb {
0000000000000000000000000000000000000000;;			var publicIPToCleanup *string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !isInternalLb {
0000000000000000000000000000000000000000;;				// Find public ip resource to clean up from IP configuration
0000000000000000000000000000000000000000;;				lbFrontendIPConfigName := getFrontendIPConfigName(service)
0000000000000000000000000000000000000000;;				for _, config := range *lb.FrontendIPConfigurations {
0000000000000000000000000000000000000000;;					if strings.EqualFold(*config.Name, lbFrontendIPConfigName) {
0000000000000000000000000000000000000000;;						if config.PublicIPAddress != nil {
0000000000000000000000000000000000000000;;							// Only ID property is available
0000000000000000000000000000000000000000;;							publicIPToCleanup = config.PublicIPAddress.ID
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lb, lbNeedsUpdate, reconcileErr := az.reconcileLoadBalancer(lb, nil, clusterName, service, []*v1.Node{})
0000000000000000000000000000000000000000;;			if reconcileErr != nil {
0000000000000000000000000000000000000000;;				return reconcileErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lbNeedsUpdate {
0000000000000000000000000000000000000000;;				if len(*lb.FrontendIPConfigurations) > 0 {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("delete(%s): lb(%s) - updating", serviceName, lbName)
0000000000000000000000000000000000000000;;					az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;					respChan, errChan := az.LoadBalancerClient.CreateOrUpdate(az.ResourceGroup, *lb.Name, lb, nil)
0000000000000000000000000000000000000000;;					resp := <-respChan
0000000000000000000000000000000000000000;;					err := <-errChan
0000000000000000000000000000000000000000;;					if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("delete(%s) backing off: sg(%s) - updating", serviceName, az.SecurityGroupName)
0000000000000000000000000000000000000000;;						retryErr := az.CreateOrUpdateLBWithRetry(lb)
0000000000000000000000000000000000000000;;						if retryErr != nil {
0000000000000000000000000000000000000000;;							err = retryErr
0000000000000000000000000000000000000000;;							glog.V(2).Infof("delete(%s) abort backoff: sg(%s) - updating", serviceName, az.SecurityGroupName)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("delete(%s): lb(%s) - deleting; no remaining frontendipconfigs", serviceName, lbName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;					respChan, errChan := az.LoadBalancerClient.Delete(az.ResourceGroup, lbName, nil)
0000000000000000000000000000000000000000;;					resp := <-respChan
0000000000000000000000000000000000000000;;					err := <-errChan
0000000000000000000000000000000000000000;;					if az.CloudProviderBackoff && shouldRetryAPIRequest(resp, err) {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("delete(%s) backing off: lb(%s) - deleting; no remaining frontendipconfigs", serviceName, lbName)
0000000000000000000000000000000000000000;;						retryErr := az.DeleteLBWithRetry(lbName)
0000000000000000000000000000000000000000;;						if retryErr != nil {
0000000000000000000000000000000000000000;;							err = retryErr
0000000000000000000000000000000000000000;;							glog.V(2).Infof("delete(%s) abort backoff: lb(%s) - deleting; no remaining frontendipconfigs", serviceName, lbName)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Public IP can be deleted after frontend ip configuration rule deleted.
0000000000000000000000000000000000000000;;			if publicIPToCleanup != nil {
0000000000000000000000000000000000000000;;				// Only delete an IP address if we created it, deducing by name.
0000000000000000000000000000000000000000;;				if index := strings.LastIndex(*publicIPToCleanup, "/"); index != -1 {
0000000000000000000000000000000000000000;;					managedPipName := getPublicIPName(clusterName, service)
0000000000000000000000000000000000000000;;					pipName := (*publicIPToCleanup)[index+1:]
0000000000000000000000000000000000000000;;					if strings.EqualFold(managedPipName, pipName) {
0000000000000000000000000000000000000000;;						glog.V(5).Infof("Deleting public IP resource %q.", pipName)
0000000000000000000000000000000000000000;;						err = az.ensurePublicIPDeleted(serviceName, pipName)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.V(5).Infof("Public IP resource %q found, but it does not match managed name %q, skip deleting.", pipName, managedPipName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (az *Cloud) ensurePublicIPExists(serviceName, pipName string) (*network.PublicIPAddress, error) {
0000000000000000000000000000000000000000;;		pip, existsPip, err := az.getPublicIPAddress(pipName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if existsPip {
0000000000000000000000000000000000000000;;			return &pip, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pip.Name = to.StringPtr(pipName)
0000000000000000000000000000000000000000;;		pip.Location = to.StringPtr(az.Location)
0000000000000000000000000000000000000000;;		pip.PublicIPAddressPropertiesFormat = &network.PublicIPAddressPropertiesFormat{
0000000000000000000000000000000000000000;;			PublicIPAllocationMethod: network.Static,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pip.Tags = &map[string]*string{"service": &serviceName}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("ensure(%s): pip(%s) - creating", serviceName, *pip.Name)
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		respChan, errChan := az.PublicIPAddressesClient.CreateOrUpdate(az.ResourceGroup, *pip.Name, pip, nil)
0000000000000000000000000000000000000000;;		resp := <-respChan
0000000000000000000000000000000000000000;;		err = <-errChan
0000000000000000000000000000000000000000;;		if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensure(%s) backing off: pip(%s) - creating", serviceName, *pip.Name)
0000000000000000000000000000000000000000;;			retryErr := az.CreateOrUpdatePIPWithRetry(pip)
0000000000000000000000000000000000000000;;			if retryErr != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("ensure(%s) abort backoff: pip(%s) - creating", serviceName, *pip.Name)
0000000000000000000000000000000000000000;;				err = retryErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		pip, err = az.PublicIPAddressesClient.Get(az.ResourceGroup, *pip.Name, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pip, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (az *Cloud) ensurePublicIPDeleted(serviceName, pipName string) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("ensure(%s): pip(%s) - deleting", serviceName, pipName)
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		resp, deleteErrChan := az.PublicIPAddressesClient.Delete(az.ResourceGroup, pipName, nil)
0000000000000000000000000000000000000000;;		deleteErr := <-deleteErrChan
0000000000000000000000000000000000000000;;		if az.CloudProviderBackoff && shouldRetryAPIRequest(<-resp, deleteErr) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("ensure(%s) backing off: pip(%s) - deleting", serviceName, pipName)
0000000000000000000000000000000000000000;;			retryErr := az.DeletePublicIPWithRetry(pipName)
0000000000000000000000000000000000000000;;			if retryErr != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("ensure(%s) abort backoff: pip(%s) - deleting", serviceName, pipName)
0000000000000000000000000000000000000000;;				return retryErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, realErr := checkResourceExistsFromError(deleteErr)
0000000000000000000000000000000000000000;;		if realErr != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This ensures load balancer exists and the frontend ip config is setup.
0000000000000000000000000000000000000000;;	// This also reconciles the Service's Ports  with the LoadBalancer config.
0000000000000000000000000000000000000000;;	// This entails adding rules/probes for expected Ports and removing stale rules/ports.
0000000000000000000000000000000000000000;;	func (az *Cloud) reconcileLoadBalancer(lb network.LoadBalancer, fipConfigurationProperties *network.FrontendIPConfigurationPropertiesFormat, clusterName string, service *v1.Service, nodes []*v1.Node) (network.LoadBalancer, bool, error) {
0000000000000000000000000000000000000000;;		isInternal := requiresInternalLoadBalancer(service)
0000000000000000000000000000000000000000;;		lbName := getLoadBalancerName(clusterName, isInternal)
0000000000000000000000000000000000000000;;		serviceName := getServiceName(service)
0000000000000000000000000000000000000000;;		lbFrontendIPConfigName := getFrontendIPConfigName(service)
0000000000000000000000000000000000000000;;		lbFrontendIPConfigID := az.getFrontendIPConfigID(lbName, lbFrontendIPConfigName)
0000000000000000000000000000000000000000;;		lbBackendPoolName := getBackendPoolName(clusterName)
0000000000000000000000000000000000000000;;		lbBackendPoolID := az.getBackendPoolID(lbName, lbBackendPoolName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wantLb := fipConfigurationProperties != nil
0000000000000000000000000000000000000000;;		dirtyLb := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure LoadBalancer's Backend Pool Configuration
0000000000000000000000000000000000000000;;		if wantLb {
0000000000000000000000000000000000000000;;			newBackendPools := []network.BackendAddressPool{}
0000000000000000000000000000000000000000;;			if lb.BackendAddressPools != nil {
0000000000000000000000000000000000000000;;				newBackendPools = *lb.BackendAddressPools
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			foundBackendPool := false
0000000000000000000000000000000000000000;;			for _, bp := range newBackendPools {
0000000000000000000000000000000000000000;;				if strings.EqualFold(*bp.Name, lbBackendPoolName) {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("reconcile(%s)(%t): lb backendpool - found wanted backendpool. not adding anything", serviceName, wantLb)
0000000000000000000000000000000000000000;;					foundBackendPool = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("reconcile(%s)(%t): lb backendpool - found other backendpool %s", serviceName, wantLb, *bp.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !foundBackendPool {
0000000000000000000000000000000000000000;;				newBackendPools = append(newBackendPools, network.BackendAddressPool{
0000000000000000000000000000000000000000;;					Name: to.StringPtr(lbBackendPoolName),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb backendpool - adding backendpool", serviceName, wantLb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dirtyLb = true
0000000000000000000000000000000000000000;;				lb.BackendAddressPools = &newBackendPools
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure LoadBalancer's Frontend IP Configurations
0000000000000000000000000000000000000000;;		dirtyConfigs := false
0000000000000000000000000000000000000000;;		newConfigs := []network.FrontendIPConfiguration{}
0000000000000000000000000000000000000000;;		if lb.FrontendIPConfigurations != nil {
0000000000000000000000000000000000000000;;			newConfigs = *lb.FrontendIPConfigurations
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wantLb {
0000000000000000000000000000000000000000;;			for i := len(newConfigs) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				config := newConfigs[i]
0000000000000000000000000000000000000000;;				if strings.EqualFold(*config.Name, lbFrontendIPConfigName) {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("reconcile(%s)(%t): lb frontendconfig(%s) - dropping", serviceName, wantLb, lbFrontendIPConfigName)
0000000000000000000000000000000000000000;;					newConfigs = append(newConfigs[:i], newConfigs[i+1:]...)
0000000000000000000000000000000000000000;;					dirtyConfigs = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			foundConfig := false
0000000000000000000000000000000000000000;;			for _, config := range newConfigs {
0000000000000000000000000000000000000000;;				if strings.EqualFold(*config.Name, lbFrontendIPConfigName) {
0000000000000000000000000000000000000000;;					foundConfig = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !foundConfig {
0000000000000000000000000000000000000000;;				newConfigs = append(newConfigs,
0000000000000000000000000000000000000000;;					network.FrontendIPConfiguration{
0000000000000000000000000000000000000000;;						Name: to.StringPtr(lbFrontendIPConfigName),
0000000000000000000000000000000000000000;;						FrontendIPConfigurationPropertiesFormat: fipConfigurationProperties,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb frontendconfig(%s) - adding", serviceName, wantLb, lbFrontendIPConfigName)
0000000000000000000000000000000000000000;;				dirtyConfigs = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dirtyConfigs {
0000000000000000000000000000000000000000;;			dirtyLb = true
0000000000000000000000000000000000000000;;			lb.FrontendIPConfigurations = &newConfigs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update probes/rules
0000000000000000000000000000000000000000;;		var ports []v1.ServicePort
0000000000000000000000000000000000000000;;		if wantLb {
0000000000000000000000000000000000000000;;			ports = service.Spec.Ports
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ports = []v1.ServicePort{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var expectedProbes []network.Probe
0000000000000000000000000000000000000000;;		var expectedRules []network.LoadBalancingRule
0000000000000000000000000000000000000000;;		for _, port := range ports {
0000000000000000000000000000000000000000;;			lbRuleName := getLoadBalancerRuleName(service, port)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transportProto, _, probeProto, err := getProtocolsFromKubernetesProtocol(port.Protocol)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return lb, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if serviceapi.NeedsHealthCheck(service) {
0000000000000000000000000000000000000000;;				if port.Protocol == v1.ProtocolUDP {
0000000000000000000000000000000000000000;;					// ERROR: this isn't supported
0000000000000000000000000000000000000000;;					// health check (aka source ip preservation) is not
0000000000000000000000000000000000000000;;					// compatible with UDP (it uses an HTTP check)
0000000000000000000000000000000000000000;;					return lb, false, fmt.Errorf("services requiring health checks are incompatible with UDP ports")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				podPresencePath, podPresencePort := serviceapi.GetServiceHealthCheckPathPort(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedProbes = append(expectedProbes, network.Probe{
0000000000000000000000000000000000000000;;					Name: &lbRuleName,
0000000000000000000000000000000000000000;;					ProbePropertiesFormat: &network.ProbePropertiesFormat{
0000000000000000000000000000000000000000;;						RequestPath:       to.StringPtr(podPresencePath),
0000000000000000000000000000000000000000;;						Protocol:          network.ProbeProtocolHTTP,
0000000000000000000000000000000000000000;;						Port:              to.Int32Ptr(podPresencePort),
0000000000000000000000000000000000000000;;						IntervalInSeconds: to.Int32Ptr(5),
0000000000000000000000000000000000000000;;						NumberOfProbes:    to.Int32Ptr(2),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			} else if port.Protocol != v1.ProtocolUDP {
0000000000000000000000000000000000000000;;				// we only add the expected probe if we're doing TCP
0000000000000000000000000000000000000000;;				expectedProbes = append(expectedProbes, network.Probe{
0000000000000000000000000000000000000000;;					Name: &lbRuleName,
0000000000000000000000000000000000000000;;					ProbePropertiesFormat: &network.ProbePropertiesFormat{
0000000000000000000000000000000000000000;;						Protocol:          *probeProto,
0000000000000000000000000000000000000000;;						Port:              to.Int32Ptr(port.NodePort),
0000000000000000000000000000000000000000;;						IntervalInSeconds: to.Int32Ptr(5),
0000000000000000000000000000000000000000;;						NumberOfProbes:    to.Int32Ptr(2),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			loadDistribution := network.Default
0000000000000000000000000000000000000000;;			if service.Spec.SessionAffinity == v1.ServiceAffinityClientIP {
0000000000000000000000000000000000000000;;				loadDistribution = network.SourceIP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expectedRule := network.LoadBalancingRule{
0000000000000000000000000000000000000000;;				Name: &lbRuleName,
0000000000000000000000000000000000000000;;				LoadBalancingRulePropertiesFormat: &network.LoadBalancingRulePropertiesFormat{
0000000000000000000000000000000000000000;;					Protocol: *transportProto,
0000000000000000000000000000000000000000;;					FrontendIPConfiguration: &network.SubResource{
0000000000000000000000000000000000000000;;						ID: to.StringPtr(lbFrontendIPConfigID),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					BackendAddressPool: &network.SubResource{
0000000000000000000000000000000000000000;;						ID: to.StringPtr(lbBackendPoolID),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					LoadDistribution: loadDistribution,
0000000000000000000000000000000000000000;;					FrontendPort:     to.Int32Ptr(port.Port),
0000000000000000000000000000000000000000;;					BackendPort:      to.Int32Ptr(port.Port),
0000000000000000000000000000000000000000;;					EnableFloatingIP: to.BoolPtr(true),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we didn't construct the probe objects for UDP because they're not used/needed/allowed
0000000000000000000000000000000000000000;;			if port.Protocol != v1.ProtocolUDP {
0000000000000000000000000000000000000000;;				expectedRule.Probe = &network.SubResource{
0000000000000000000000000000000000000000;;					ID: to.StringPtr(az.getLoadBalancerProbeID(lbName, lbRuleName)),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedRules = append(expectedRules, expectedRule)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove unwanted probes
0000000000000000000000000000000000000000;;		dirtyProbes := false
0000000000000000000000000000000000000000;;		var updatedProbes []network.Probe
0000000000000000000000000000000000000000;;		if lb.Probes != nil {
0000000000000000000000000000000000000000;;			updatedProbes = *lb.Probes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := len(updatedProbes) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			existingProbe := updatedProbes[i]
0000000000000000000000000000000000000000;;			if serviceOwnsRule(service, *existingProbe.Name) {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb probe(%s) - considering evicting", serviceName, wantLb, *existingProbe.Name)
0000000000000000000000000000000000000000;;				keepProbe := false
0000000000000000000000000000000000000000;;				if findProbe(expectedProbes, existingProbe) {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("reconcile(%s)(%t): lb probe(%s) - keeping", serviceName, wantLb, *existingProbe.Name)
0000000000000000000000000000000000000000;;					keepProbe = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !keepProbe {
0000000000000000000000000000000000000000;;					updatedProbes = append(updatedProbes[:i], updatedProbes[i+1:]...)
0000000000000000000000000000000000000000;;					glog.V(10).Infof("reconcile(%s)(%t): lb probe(%s) - dropping", serviceName, wantLb, *existingProbe.Name)
0000000000000000000000000000000000000000;;					dirtyProbes = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// add missing, wanted probes
0000000000000000000000000000000000000000;;		for _, expectedProbe := range expectedProbes {
0000000000000000000000000000000000000000;;			foundProbe := false
0000000000000000000000000000000000000000;;			if findProbe(updatedProbes, expectedProbe) {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb probe(%s) - already exists", serviceName, wantLb, *expectedProbe.Name)
0000000000000000000000000000000000000000;;				foundProbe = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !foundProbe {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb probe(%s) - adding", serviceName, wantLb, *expectedProbe.Name)
0000000000000000000000000000000000000000;;				updatedProbes = append(updatedProbes, expectedProbe)
0000000000000000000000000000000000000000;;				dirtyProbes = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dirtyProbes {
0000000000000000000000000000000000000000;;			dirtyLb = true
0000000000000000000000000000000000000000;;			lb.Probes = &updatedProbes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update rules
0000000000000000000000000000000000000000;;		dirtyRules := false
0000000000000000000000000000000000000000;;		var updatedRules []network.LoadBalancingRule
0000000000000000000000000000000000000000;;		if lb.LoadBalancingRules != nil {
0000000000000000000000000000000000000000;;			updatedRules = *lb.LoadBalancingRules
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update rules: remove unwanted
0000000000000000000000000000000000000000;;		for i := len(updatedRules) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			existingRule := updatedRules[i]
0000000000000000000000000000000000000000;;			if serviceOwnsRule(service, *existingRule.Name) {
0000000000000000000000000000000000000000;;				keepRule := false
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb rule(%s) - considering evicting", serviceName, wantLb, *existingRule.Name)
0000000000000000000000000000000000000000;;				if findRule(expectedRules, existingRule) {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("reconcile(%s)(%t): lb rule(%s) - keeping", serviceName, wantLb, *existingRule.Name)
0000000000000000000000000000000000000000;;					keepRule = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !keepRule {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("reconcile(%s)(%t): lb rule(%s) - dropping", serviceName, wantLb, *existingRule.Name)
0000000000000000000000000000000000000000;;					updatedRules = append(updatedRules[:i], updatedRules[i+1:]...)
0000000000000000000000000000000000000000;;					dirtyRules = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update rules: add needed
0000000000000000000000000000000000000000;;		for _, expectedRule := range expectedRules {
0000000000000000000000000000000000000000;;			foundRule := false
0000000000000000000000000000000000000000;;			if findRule(updatedRules, expectedRule) {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb rule(%s) - already exists", serviceName, wantLb, *expectedRule.Name)
0000000000000000000000000000000000000000;;				foundRule = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !foundRule {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): lb rule(%s) adding", serviceName, wantLb, *expectedRule.Name)
0000000000000000000000000000000000000000;;				updatedRules = append(updatedRules, expectedRule)
0000000000000000000000000000000000000000;;				dirtyRules = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dirtyRules {
0000000000000000000000000000000000000000;;			dirtyLb = true
0000000000000000000000000000000000000000;;			lb.LoadBalancingRules = &updatedRules
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lb, dirtyLb, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This reconciles the Network Security Group similar to how the LB is reconciled.
0000000000000000000000000000000000000000;;	// This entails adding required, missing SecurityRules and removing stale rules.
0000000000000000000000000000000000000000;;	func (az *Cloud) reconcileSecurityGroup(sg network.SecurityGroup, clusterName string, service *v1.Service, wantLb bool) (network.SecurityGroup, bool, error) {
0000000000000000000000000000000000000000;;		serviceName := getServiceName(service)
0000000000000000000000000000000000000000;;		var ports []v1.ServicePort
0000000000000000000000000000000000000000;;		if wantLb {
0000000000000000000000000000000000000000;;			ports = service.Spec.Ports
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ports = []v1.ServicePort{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sourceRanges, err := serviceapi.GetLoadBalancerSourceRanges(service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return sg, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var sourceAddressPrefixes []string
0000000000000000000000000000000000000000;;		if sourceRanges == nil || serviceapi.IsAllowAll(sourceRanges) {
0000000000000000000000000000000000000000;;			if !requiresInternalLoadBalancer(service) {
0000000000000000000000000000000000000000;;				sourceAddressPrefixes = []string{"Internet"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, ip := range sourceRanges {
0000000000000000000000000000000000000000;;				sourceAddressPrefixes = append(sourceAddressPrefixes, ip.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedSecurityRules := make([]network.SecurityRule, len(ports)*len(sourceAddressPrefixes))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, port := range ports {
0000000000000000000000000000000000000000;;			_, securityProto, _, err := getProtocolsFromKubernetesProtocol(port.Protocol)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return sg, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j := range sourceAddressPrefixes {
0000000000000000000000000000000000000000;;				ix := i*len(sourceAddressPrefixes) + j
0000000000000000000000000000000000000000;;				securityRuleName := getSecurityRuleName(service, port, sourceAddressPrefixes[j])
0000000000000000000000000000000000000000;;				expectedSecurityRules[ix] = network.SecurityRule{
0000000000000000000000000000000000000000;;					Name: to.StringPtr(securityRuleName),
0000000000000000000000000000000000000000;;					SecurityRulePropertiesFormat: &network.SecurityRulePropertiesFormat{
0000000000000000000000000000000000000000;;						Protocol:                 *securityProto,
0000000000000000000000000000000000000000;;						SourcePortRange:          to.StringPtr("*"),
0000000000000000000000000000000000000000;;						DestinationPortRange:     to.StringPtr(strconv.Itoa(int(port.Port))),
0000000000000000000000000000000000000000;;						SourceAddressPrefix:      to.StringPtr(sourceAddressPrefixes[j]),
0000000000000000000000000000000000000000;;						DestinationAddressPrefix: to.StringPtr("*"),
0000000000000000000000000000000000000000;;						Access:    network.SecurityRuleAccessAllow,
0000000000000000000000000000000000000000;;						Direction: network.SecurityRuleDirectionInbound,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update security rules
0000000000000000000000000000000000000000;;		dirtySg := false
0000000000000000000000000000000000000000;;		var updatedRules []network.SecurityRule
0000000000000000000000000000000000000000;;		if sg.SecurityRules != nil {
0000000000000000000000000000000000000000;;			updatedRules = *sg.SecurityRules
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update security rules: remove unwanted
0000000000000000000000000000000000000000;;		for i := len(updatedRules) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			existingRule := updatedRules[i]
0000000000000000000000000000000000000000;;			if serviceOwnsRule(service, *existingRule.Name) {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): sg rule(%s) - considering evicting", serviceName, wantLb, *existingRule.Name)
0000000000000000000000000000000000000000;;				keepRule := false
0000000000000000000000000000000000000000;;				if findSecurityRule(expectedSecurityRules, existingRule) {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("reconcile(%s)(%t): sg rule(%s) - keeping", serviceName, wantLb, *existingRule.Name)
0000000000000000000000000000000000000000;;					keepRule = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !keepRule {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("reconcile(%s)(%t): sg rule(%s) - dropping", serviceName, wantLb, *existingRule.Name)
0000000000000000000000000000000000000000;;					updatedRules = append(updatedRules[:i], updatedRules[i+1:]...)
0000000000000000000000000000000000000000;;					dirtySg = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update security rules: add needed
0000000000000000000000000000000000000000;;		for _, expectedRule := range expectedSecurityRules {
0000000000000000000000000000000000000000;;			foundRule := false
0000000000000000000000000000000000000000;;			if findSecurityRule(updatedRules, expectedRule) {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): sg rule(%s) - already exists", serviceName, wantLb, *expectedRule.Name)
0000000000000000000000000000000000000000;;				foundRule = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !foundRule {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("reconcile(%s)(%t): sg rule(%s) - adding", serviceName, wantLb, *expectedRule.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nextAvailablePriority, err := getNextAvailablePriority(updatedRules)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return sg, false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedRule.Priority = to.Int32Ptr(nextAvailablePriority)
0000000000000000000000000000000000000000;;				updatedRules = append(updatedRules, expectedRule)
0000000000000000000000000000000000000000;;				dirtySg = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dirtySg {
0000000000000000000000000000000000000000;;			sg.SecurityRules = &updatedRules
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sg, dirtySg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findProbe(probes []network.Probe, probe network.Probe) bool {
0000000000000000000000000000000000000000;;		for _, existingProbe := range probes {
0000000000000000000000000000000000000000;;			if strings.EqualFold(*existingProbe.Name, *probe.Name) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findRule(rules []network.LoadBalancingRule, rule network.LoadBalancingRule) bool {
0000000000000000000000000000000000000000;;		for _, existingRule := range rules {
0000000000000000000000000000000000000000;;			if strings.EqualFold(*existingRule.Name, *rule.Name) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findSecurityRule(rules []network.SecurityRule, rule network.SecurityRule) bool {
0000000000000000000000000000000000000000;;		for _, existingRule := range rules {
0000000000000000000000000000000000000000;;			if strings.EqualFold(*existingRule.Name, *rule.Name) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This ensures the given VM's Primary NIC's Primary IP Configuration is
0000000000000000000000000000000000000000;;	// participating in the specified LoadBalancer Backend Pool.
0000000000000000000000000000000000000000;;	func (az *Cloud) ensureHostInPool(serviceName string, nodeName types.NodeName, backendPoolID string) error {
0000000000000000000000000000000000000000;;		vmName := mapNodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		machine, err := az.VirtualMachinesClient.Get(az.ResourceGroup, vmName, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		primaryNicID, err := getPrimaryInterfaceID(machine)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nicName, err := getLastSegment(primaryNicID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check availability set
0000000000000000000000000000000000000000;;		if az.PrimaryAvailabilitySetName != "" {
0000000000000000000000000000000000000000;;			expectedAvailabilitySetName := az.getAvailabilitySetID(az.PrimaryAvailabilitySetName)
0000000000000000000000000000000000000000;;			if !strings.EqualFold(*machine.AvailabilitySet.ID, expectedAvailabilitySetName) {
0000000000000000000000000000000000000000;;				glog.V(3).Infof(
0000000000000000000000000000000000000000;;					"nicupdate(%s): skipping nic (%s) since it is not in the primaryAvailabilitSet(%s)",
0000000000000000000000000000000000000000;;					serviceName, nicName, az.PrimaryAvailabilitySetName)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		nic, err := az.InterfacesClient.Get(az.ResourceGroup, nicName, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var primaryIPConfig *network.InterfaceIPConfiguration
0000000000000000000000000000000000000000;;		primaryIPConfig, err = getPrimaryIPConfig(nic)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foundPool := false
0000000000000000000000000000000000000000;;		newBackendPools := []network.BackendAddressPool{}
0000000000000000000000000000000000000000;;		if primaryIPConfig.LoadBalancerBackendAddressPools != nil {
0000000000000000000000000000000000000000;;			newBackendPools = *primaryIPConfig.LoadBalancerBackendAddressPools
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, existingPool := range newBackendPools {
0000000000000000000000000000000000000000;;			if strings.EqualFold(backendPoolID, *existingPool.ID) {
0000000000000000000000000000000000000000;;				foundPool = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !foundPool {
0000000000000000000000000000000000000000;;			newBackendPools = append(newBackendPools,
0000000000000000000000000000000000000000;;				network.BackendAddressPool{
0000000000000000000000000000000000000000;;					ID: to.StringPtr(backendPoolID),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			primaryIPConfig.LoadBalancerBackendAddressPools = &newBackendPools
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(3).Infof("nicupdate(%s): nic(%s) - updating", serviceName, nicName)
0000000000000000000000000000000000000000;;			az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;			respChan, errChan := az.InterfacesClient.CreateOrUpdate(az.ResourceGroup, *nic.Name, nic, nil)
0000000000000000000000000000000000000000;;			resp := <-respChan
0000000000000000000000000000000000000000;;			err := <-errChan
0000000000000000000000000000000000000000;;			if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("nicupdate(%s) backing off: nic(%s) - updating, err=%v", serviceName, nicName, err)
0000000000000000000000000000000000000000;;				retryErr := az.CreateOrUpdateInterfaceWithRetry(nic)
0000000000000000000000000000000000000000;;				if retryErr != nil {
0000000000000000000000000000000000000000;;					err = retryErr
0000000000000000000000000000000000000000;;					glog.V(2).Infof("nicupdate(%s) abort backoff: nic(%s) - updating", serviceName, nicName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if service requires an internal load balancer.
0000000000000000000000000000000000000000;;	func requiresInternalLoadBalancer(service *v1.Service) bool {
0000000000000000000000000000000000000000;;		if l, ok := service.Annotations[ServiceAnnotationLoadBalancerInternal]; ok {
0000000000000000000000000000000000000000;;			return l == "true"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
