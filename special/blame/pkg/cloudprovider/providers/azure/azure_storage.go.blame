0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d3342ef184d2fe00b2aea4310cae8fa7797b21d3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/compute"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxLUN               = 64 // max number of LUNs per VM
0000000000000000000000000000000000000000;;		errLeaseFailed       = "AcquireDiskLeaseFailed"
0000000000000000000000000000000000000000;;		errLeaseIDMissing    = "LeaseIdMissing"
0000000000000000000000000000000000000000;;		errContainerNotFound = "ContainerNotFound"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachDisk attaches a vhd to vm
0000000000000000000000000000000000000000;;	// the vhd must exist, can be identified by diskName, diskURI, and lun.
0000000000000000000000000000000000000000;;	func (az *Cloud) AttachDisk(diskName, diskURI string, nodeName types.NodeName, lun int32, cachingMode compute.CachingTypes) error {
0000000000000000000000000000000000000000;;		vm, exists, err := az.getVirtualMachine(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if !exists {
0000000000000000000000000000000000000000;;			return cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disks := *vm.StorageProfile.DataDisks
0000000000000000000000000000000000000000;;		disks = append(disks,
0000000000000000000000000000000000000000;;			compute.DataDisk{
0000000000000000000000000000000000000000;;				Name: &diskName,
0000000000000000000000000000000000000000;;				Vhd: &compute.VirtualHardDisk{
0000000000000000000000000000000000000000;;					URI: &diskURI,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Lun:          &lun,
0000000000000000000000000000000000000000;;				Caching:      cachingMode,
0000000000000000000000000000000000000000;;				CreateOption: "attach",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newVM := compute.VirtualMachine{
0000000000000000000000000000000000000000;;			Location: vm.Location,
0000000000000000000000000000000000000000;;			VirtualMachineProperties: &compute.VirtualMachineProperties{
0000000000000000000000000000000000000000;;				StorageProfile: &compute.StorageProfile{
0000000000000000000000000000000000000000;;					DataDisks: &disks,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vmName := mapNodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("create(%s): vm(%s)", az.ResourceGroup, vmName)
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		respChan, errChan := az.VirtualMachinesClient.CreateOrUpdate(az.ResourceGroup, vmName, newVM, nil)
0000000000000000000000000000000000000000;;		resp := <-respChan
0000000000000000000000000000000000000000;;		err = <-errChan
0000000000000000000000000000000000000000;;		if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("create(%s) backing off: vm(%s)", az.ResourceGroup, vmName)
0000000000000000000000000000000000000000;;			retryErr := az.CreateOrUpdateVMWithRetry(vmName, newVM)
0000000000000000000000000000000000000000;;			if retryErr != nil {
0000000000000000000000000000000000000000;;				err = retryErr
0000000000000000000000000000000000000000;;				glog.V(2).Infof("create(%s) abort backoff: vm(%s)", az.ResourceGroup, vmName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("azure attach failed, err: %v", err)
0000000000000000000000000000000000000000;;			detail := err.Error()
0000000000000000000000000000000000000000;;			if strings.Contains(detail, errLeaseFailed) {
0000000000000000000000000000000000000000;;				// if lease cannot be acquired, immediately detach the disk and return the original error
0000000000000000000000000000000000000000;;				glog.Infof("failed to acquire disk lease, try detach")
0000000000000000000000000000000000000000;;				az.DetachDiskByName(diskName, diskURI, nodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("azure attach succeeded")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisksAreAttached checks if a list of volumes are attached to the node with the specified NodeName
0000000000000000000000000000000000000000;;	func (az *Cloud) DisksAreAttached(diskNames []string, nodeName types.NodeName) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		attached := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, diskName := range diskNames {
0000000000000000000000000000000000000000;;			attached[diskName] = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vm, exists, err := az.getVirtualMachine(nodeName)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			// if host doesn't exist, no need to detach
0000000000000000000000000000000000000000;;			glog.Warningf("Cannot find node %q, DisksAreAttached will assume disks %v are not attached to it.",
0000000000000000000000000000000000000000;;				nodeName, diskNames)
0000000000000000000000000000000000000000;;			return attached, nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return attached, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		disks := *vm.StorageProfile.DataDisks
0000000000000000000000000000000000000000;;		for _, disk := range disks {
0000000000000000000000000000000000000000;;			for _, diskName := range diskNames {
0000000000000000000000000000000000000000;;				if disk.Name != nil && diskName != "" && *disk.Name == diskName {
0000000000000000000000000000000000000000;;					attached[diskName] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attached, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetachDiskByName detaches a vhd from host
0000000000000000000000000000000000000000;;	// the vhd can be identified by diskName or diskURI
0000000000000000000000000000000000000000;;	func (az *Cloud) DetachDiskByName(diskName, diskURI string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		vm, exists, err := az.getVirtualMachine(nodeName)
0000000000000000000000000000000000000000;;		if err != nil || !exists {
0000000000000000000000000000000000000000;;			// if host doesn't exist, no need to detach
0000000000000000000000000000000000000000;;			glog.Warningf("cannot find node %s, skip detaching disk %s", nodeName, diskName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		disks := *vm.StorageProfile.DataDisks
0000000000000000000000000000000000000000;;		for i, disk := range disks {
0000000000000000000000000000000000000000;;			if (disk.Name != nil && diskName != "" && *disk.Name == diskName) || (disk.Vhd.URI != nil && diskURI != "" && *disk.Vhd.URI == diskURI) {
0000000000000000000000000000000000000000;;				// found the disk
0000000000000000000000000000000000000000;;				glog.V(4).Infof("detach disk: name %q uri %q", diskName, diskURI)
0000000000000000000000000000000000000000;;				disks = append(disks[:i], disks[i+1:]...)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newVM := compute.VirtualMachine{
0000000000000000000000000000000000000000;;			Location: vm.Location,
0000000000000000000000000000000000000000;;			VirtualMachineProperties: &compute.VirtualMachineProperties{
0000000000000000000000000000000000000000;;				StorageProfile: &compute.StorageProfile{
0000000000000000000000000000000000000000;;					DataDisks: &disks,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vmName := mapNodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;		glog.V(2).Infof("create(%s): vm(%s)", az.ResourceGroup, vmName)
0000000000000000000000000000000000000000;;		az.operationPollRateLimiter.Accept()
0000000000000000000000000000000000000000;;		respChan, errChan := az.VirtualMachinesClient.CreateOrUpdate(az.ResourceGroup, vmName, newVM, nil)
0000000000000000000000000000000000000000;;		resp := <-respChan
0000000000000000000000000000000000000000;;		err = <-errChan
0000000000000000000000000000000000000000;;		if az.CloudProviderBackoff && shouldRetryAPIRequest(resp.Response, err) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("create(%s) backing off: vm(%s)", az.ResourceGroup, vmName)
0000000000000000000000000000000000000000;;			retryErr := az.CreateOrUpdateVMWithRetry(vmName, newVM)
0000000000000000000000000000000000000000;;			if retryErr != nil {
0000000000000000000000000000000000000000;;				err = retryErr
0000000000000000000000000000000000000000;;				glog.V(2).Infof("create(%s) abort backoff: vm(%s)", az.ResourceGroup, vmName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("azure disk detach failed, err: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("azure disk detach succeeded")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDiskLun finds the lun on the host that the vhd is attached to, given a vhd's diskName and diskURI
0000000000000000000000000000000000000000;;	func (az *Cloud) GetDiskLun(diskName, diskURI string, nodeName types.NodeName) (int32, error) {
0000000000000000000000000000000000000000;;		vm, exists, err := az.getVirtualMachine(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		} else if !exists {
0000000000000000000000000000000000000000;;			return -1, cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disks := *vm.StorageProfile.DataDisks
0000000000000000000000000000000000000000;;		for _, disk := range disks {
0000000000000000000000000000000000000000;;			if disk.Lun != nil && (disk.Name != nil && diskName != "" && *disk.Name == diskName) || (disk.Vhd.URI != nil && diskURI != "" && *disk.Vhd.URI == diskURI) {
0000000000000000000000000000000000000000;;				// found the disk
0000000000000000000000000000000000000000;;				glog.V(4).Infof("find disk: lun %d name %q uri %q", *disk.Lun, diskName, diskURI)
0000000000000000000000000000000000000000;;				return *disk.Lun, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, fmt.Errorf("Cannot find Lun for disk %s", diskName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNextDiskLun searches all vhd attachment on the host and find unused lun
0000000000000000000000000000000000000000;;	// return -1 if all luns are used
0000000000000000000000000000000000000000;;	func (az *Cloud) GetNextDiskLun(nodeName types.NodeName) (int32, error) {
0000000000000000000000000000000000000000;;		vm, exists, err := az.getVirtualMachine(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		} else if !exists {
0000000000000000000000000000000000000000;;			return -1, cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		used := make([]bool, maxLUN)
0000000000000000000000000000000000000000;;		disks := *vm.StorageProfile.DataDisks
0000000000000000000000000000000000000000;;		for _, disk := range disks {
0000000000000000000000000000000000000000;;			if disk.Lun != nil {
0000000000000000000000000000000000000000;;				used[*disk.Lun] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range used {
0000000000000000000000000000000000000000;;			if !v {
0000000000000000000000000000000000000000;;				return int32(k), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, fmt.Errorf("All Luns are used")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateVolume creates a VHD blob in a storage account that has storageType and location using the given storage account.
0000000000000000000000000000000000000000;;	// If no storage account is given, search all the storage accounts associated with the resource group and pick one that
0000000000000000000000000000000000000000;;	// fits storage type and location.
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateVolume(name, storageAccount, storageType, location string, requestGB int) (string, string, int, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		accounts := []accountWithLocation{}
0000000000000000000000000000000000000000;;		if len(storageAccount) > 0 {
0000000000000000000000000000000000000000;;			accounts = append(accounts, accountWithLocation{Name: storageAccount})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// find a storage account
0000000000000000000000000000000000000000;;			accounts, err = az.getStorageAccounts()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO: create a storage account and container
0000000000000000000000000000000000000000;;				return "", "", 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, account := range accounts {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("account %s type %s location %s", account.Name, account.StorageType, account.Location)
0000000000000000000000000000000000000000;;			if ((storageType == "" || account.StorageType == storageType) && (location == "" || account.Location == location)) || len(storageAccount) > 0 {
0000000000000000000000000000000000000000;;				// find the access key with this account
0000000000000000000000000000000000000000;;				key, err := az.getStorageAccesskey(account.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("no key found for storage account %s", account.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create a page blob in this account's vhd container
0000000000000000000000000000000000000000;;				name, uri, err := az.createVhdBlob(account.Name, key, name, int64(requestGB), nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("failed to create vhd in account %s: %v", account.Name, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("created vhd blob uri: %s", uri)
0000000000000000000000000000000000000000;;				return name, uri, requestGB, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", 0, fmt.Errorf("failed to find a matching storage account")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteVolume deletes a VHD blob
0000000000000000000000000000000000000000;;	func (az *Cloud) DeleteVolume(name, uri string) error {
0000000000000000000000000000000000000000;;		accountName, blob, err := az.getBlobNameAndAccountFromURI(uri)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to parse vhd URI %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key, err := az.getStorageAccesskey(accountName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no key for storage account %s, err %v", accountName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = az.deleteVhdBlob(accountName, key, blob)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("failed to delete blob %s err: %v", uri, err)
0000000000000000000000000000000000000000;;			detail := err.Error()
0000000000000000000000000000000000000000;;			if strings.Contains(detail, errLeaseIDMissing) {
0000000000000000000000000000000000000000;;				// disk is still being used
0000000000000000000000000000000000000000;;				// see https://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.blob.protocol.bloberrorcodestrings.leaseidmissing.aspx
0000000000000000000000000000000000000000;;				return volume.NewDeletedVolumeInUseError(fmt.Sprintf("disk %q is still in use while being deleted", name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to delete vhd %v, account %s, blob %s, err: %v", uri, accountName, blob, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("blob %s deleted", uri)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateFileShare creates a file share, using a matching storage account
0000000000000000000000000000000000000000;;	func (az *Cloud) CreateFileShare(name, storageAccount, storageType, location string, requestGB int) (string, string, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		accounts := []accountWithLocation{}
0000000000000000000000000000000000000000;;		if len(storageAccount) > 0 {
0000000000000000000000000000000000000000;;			accounts = append(accounts, accountWithLocation{Name: storageAccount})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// find a storage account
0000000000000000000000000000000000000000;;			accounts, err = az.getStorageAccounts()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO: create a storage account and container
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, account := range accounts {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("account %s type %s location %s", account.Name, account.StorageType, account.Location)
0000000000000000000000000000000000000000;;			if ((storageType == "" || account.StorageType == storageType) && (location == "" || account.Location == location)) || len(storageAccount) > 0 {
0000000000000000000000000000000000000000;;				// find the access key with this account
0000000000000000000000000000000000000000;;				key, err := az.getStorageAccesskey(account.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("no key found for storage account %s", account.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = az.createFileShare(account.Name, key, name, requestGB)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("failed to create share in account %s: %v", account.Name, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("created share %s in account %s", name, account.Name)
0000000000000000000000000000000000000000;;				return account.Name, key, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", fmt.Errorf("failed to find a matching storage account")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteFileShare deletes a file share using storage account name and key
0000000000000000000000000000000000000000;;	func (az *Cloud) DeleteFileShare(accountName, key, name string) error {
0000000000000000000000000000000000000000;;		err := az.deleteFileShare(accountName, key, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("share %s deleted", name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
