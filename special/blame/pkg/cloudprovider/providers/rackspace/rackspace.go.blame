0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6e2653a484377c9b7931f70d0197def098cf9ae1;pkg/cloudprovider/rackspace/rackspace.go[pkg/cloudprovider/rackspace/rackspace.go][pkg/cloudprovider/providers/rackspace/rackspace.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rackspace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud"
0000000000000000000000000000000000000000;;		osvolumeattach "github.com/rackspace/gophercloud/openstack/compute/v2/extensions/volumeattach"
0000000000000000000000000000000000000000;;		osservers "github.com/rackspace/gophercloud/openstack/compute/v2/servers"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/pagination"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/rackspace"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/rackspace/blockstorage/v1/volumes"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/rackspace/compute/v2/servers"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/rackspace/compute/v2/volumeattach"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProviderName          = "rackspace"
0000000000000000000000000000000000000000;;		MetaDataPath          = "/media/configdrive/openstack/latest/meta_data.json"
0000000000000000000000000000000000000000;;		VolumeAvailableStatus = "available"
0000000000000000000000000000000000000000;;		VolumeInUseStatus     = "in-use"
0000000000000000000000000000000000000000;;		VolumeErrorStatus     = "error"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrNotFound = errors.New("Failed to find object")
0000000000000000000000000000000000000000;;	var ErrMultipleResults = errors.New("Multiple results where only one expected")
0000000000000000000000000000000000000000;;	var ErrNoAddressFound = errors.New("No address found for host")
0000000000000000000000000000000000000000;;	var ErrAttrNotFound = errors.New("Expected attribute not found")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encoding.TextUnmarshaler interface for time.Duration
0000000000000000000000000000000000000000;;	type MyDuration struct {
0000000000000000000000000000000000000000;;		time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *MyDuration) UnmarshalText(text []byte) error {
0000000000000000000000000000000000000000;;		res, err := time.ParseDuration(string(text))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.Duration = res
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MetaData struct {
0000000000000000000000000000000000000000;;		UUID string `json:"uuid"`
0000000000000000000000000000000000000000;;		Name string `json:"name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LoadBalancerOpts struct {
0000000000000000000000000000000000000000;;		SubnetId          string     `gcfg:"subnet-id"` // required
0000000000000000000000000000000000000000;;		CreateMonitor     bool       `gcfg:"create-monitor"`
0000000000000000000000000000000000000000;;		MonitorDelay      MyDuration `gcfg:"monitor-delay"`
0000000000000000000000000000000000000000;;		MonitorTimeout    MyDuration `gcfg:"monitor-timeout"`
0000000000000000000000000000000000000000;;		MonitorMaxRetries uint       `gcfg:"monitor-max-retries"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rackspace is an implementation of cloud provider Interface for Rackspace.
0000000000000000000000000000000000000000;;	type Rackspace struct {
0000000000000000000000000000000000000000;;		provider *gophercloud.ProviderClient
0000000000000000000000000000000000000000;;		region   string
0000000000000000000000000000000000000000;;		lbOpts   LoadBalancerOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		Global struct {
0000000000000000000000000000000000000000;;			AuthUrl    string `gcfg:"auth-url"`
0000000000000000000000000000000000000000;;			Username   string
0000000000000000000000000000000000000000;;			UserId     string `gcfg:"user-id"`
0000000000000000000000000000000000000000;;			Password   string
0000000000000000000000000000000000000000;;			ApiKey     string `gcfg:"api-key"`
0000000000000000000000000000000000000000;;			TenantId   string `gcfg:"tenant-id"`
0000000000000000000000000000000000000000;;			TenantName string `gcfg:"tenant-name"`
0000000000000000000000000000000000000000;;			DomainId   string `gcfg:"domain-id"`
0000000000000000000000000000000000000000;;			DomainName string `gcfg:"domain-name"`
0000000000000000000000000000000000000000;;			Region     string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		LoadBalancer LoadBalancerOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func probeNodeAddress(compute *gophercloud.ServiceClient, name string) (string, error) {
0000000000000000000000000000000000000000;;		id, err := readInstanceID()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			srv, err := servers.Get(compute, id).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return getAddressByServer(srv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ip, err := getAddressByName(compute, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ip, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func probeInstanceID(client *gophercloud.ServiceClient, name string) (string, error) {
0000000000000000000000000000000000000000;;		// Attempt to read id from config drive.
0000000000000000000000000000000000000000;;		id, err := readInstanceID()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return id, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attempt to get the server by the name from the API
0000000000000000000000000000000000000000;;		server, err := getServerByName(client, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server.ID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseMetaData(file io.Reader) (string, error) {
0000000000000000000000000000000000000000;;		metaDataBytes, err := ioutil.ReadAll(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Cannot read %s: %v", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metaData := MetaData{}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(metaDataBytes, &metaData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Cannot parse %s: %v", MetaDataPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return metaData.UUID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readInstanceID() (string, error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(MetaDataPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Cannot open %s: %v", MetaDataPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseMetaData(file)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		cloudprovider.RegisterCloudProvider(ProviderName, func(config io.Reader) (cloudprovider.Interface, error) {
0000000000000000000000000000000000000000;;			cfg, err := readConfig(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newRackspace(cfg)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cfg Config) toAuthOptions() gophercloud.AuthOptions {
0000000000000000000000000000000000000000;;		return gophercloud.AuthOptions{
0000000000000000000000000000000000000000;;			IdentityEndpoint: cfg.Global.AuthUrl,
0000000000000000000000000000000000000000;;			Username:         cfg.Global.Username,
0000000000000000000000000000000000000000;;			UserID:           cfg.Global.UserId,
0000000000000000000000000000000000000000;;			Password:         cfg.Global.Password,
0000000000000000000000000000000000000000;;			APIKey:           cfg.Global.ApiKey,
0000000000000000000000000000000000000000;;			TenantID:         cfg.Global.TenantId,
0000000000000000000000000000000000000000;;			TenantName:       cfg.Global.TenantName,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Persistent service, so we need to be able to renew tokens
0000000000000000000000000000000000000000;;			AllowReauth: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readConfig(config io.Reader) (Config, error) {
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("no Rackspace cloud provider config file given")
0000000000000000000000000000000000000000;;			return Config{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cfg Config
0000000000000000000000000000000000000000;;		err := gcfg.ReadInto(&cfg, config)
0000000000000000000000000000000000000000;;		return cfg, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRackspace(cfg Config) (*Rackspace, error) {
0000000000000000000000000000000000000000;;		provider, err := rackspace.AuthenticatedClient(cfg.toAuthOptions())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os := Rackspace{
0000000000000000000000000000000000000000;;			provider: provider,
0000000000000000000000000000000000000000;;			region:   cfg.Global.Region,
0000000000000000000000000000000000000000;;			lbOpts:   cfg.LoadBalancer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &os, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize passes a Kubernetes clientBuilder interface to the cloud provider
0000000000000000000000000000000000000000;;	func (os *Rackspace) Initialize(clientBuilder controller.ControllerClientBuilder) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Instances struct {
0000000000000000000000000000000000000000;;		compute *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances returns an implementation of Instances for Rackspace.
0000000000000000000000000000000000000000;;	func (os *Rackspace) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		glog.V(2).Info("rackspace.Instances() called")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compute, err := os.getComputeClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to find compute endpoint: %v", err)
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(1).Info("Claiming to support Instances")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Instances{compute}, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serverHasAddress(srv osservers.Server, ip string) bool {
0000000000000000000000000000000000000000;;		if ip == firstAddr(srv.Addresses["private"]) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip == firstAddr(srv.Addresses["public"]) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip == srv.AccessIPv4 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip == srv.AccessIPv6 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getServerByAddress(client *gophercloud.ServiceClient, name string) (*osservers.Server, error) {
0000000000000000000000000000000000000000;;		pager := servers.List(client, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverList := make([]osservers.Server, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			s, err := servers.ExtractServers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range s {
0000000000000000000000000000000000000000;;				if serverHasAddress(v, name) {
0000000000000000000000000000000000000000;;					serverList = append(serverList, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(serverList) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(serverList) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		} else if len(serverList) > 1 {
0000000000000000000000000000000000000000;;			return nil, ErrMultipleResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &serverList[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getServerByName(client *gophercloud.ServiceClient, name string) (*osservers.Server, error) {
0000000000000000000000000000000000000000;;		if net.ParseIP(name) != nil {
0000000000000000000000000000000000000000;;			// we're an IP, so we'll have to walk the full list of servers to
0000000000000000000000000000000000000000;;			// figure out which one we are.
0000000000000000000000000000000000000000;;			return getServerByAddress(client, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts := osservers.ListOpts{
0000000000000000000000000000000000000000;;			Name:   fmt.Sprintf("^%s$", regexp.QuoteMeta(name)),
0000000000000000000000000000000000000000;;			Status: "ACTIVE",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := servers.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverList := make([]osservers.Server, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			s, err := servers.ExtractServers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serverList = append(serverList, s...)
0000000000000000000000000000000000000000;;			if len(serverList) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(serverList) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		} else if len(serverList) > 1 {
0000000000000000000000000000000000000000;;			return nil, ErrMultipleResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &serverList[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func firstAddr(netblob interface{}) string {
0000000000000000000000000000000000000000;;		// Run-time types for the win :(
0000000000000000000000000000000000000000;;		list, ok := netblob.([]interface{})
0000000000000000000000000000000000000000;;		if !ok || len(list) < 1 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		props, ok := list[0].(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmp, ok := props["addr"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addr, ok := tmp.(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAddressByServer(srv *osservers.Server) (string, error) {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = firstAddr(srv.Addresses["private"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = firstAddr(srv.Addresses["public"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = srv.AccessIPv4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = srv.AccessIPv6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return "", ErrNoAddressFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAddressByName(api *gophercloud.ServiceClient, name string) (string, error) {
0000000000000000000000000000000000000000;;		srv, err := getServerByName(api, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getAddressByServer(srv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *Instances) NodeAddresses(nodeName types.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("NodeAddresses(%v) called", nodeName)
0000000000000000000000000000000000000000;;		serverName := mapNodeNameToServerName(nodeName)
0000000000000000000000000000000000000000;;		ip, err := probeNodeAddress(i.compute, serverName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("NodeAddresses(%v) => %v", serverName, ip)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// net.ParseIP().String() is to maintain compatibility with the old code
0000000000000000000000000000000000000000;;		parsedIP := net.ParseIP(ip).String()
0000000000000000000000000000000000000000;;		return []v1.NodeAddress{
0000000000000000000000000000000000000000;;			{Type: v1.NodeInternalIP, Address: parsedIP},
0000000000000000000000000000000000000000;;			{Type: v1.NodeExternalIP, Address: parsedIP},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddressesByProviderID returns the node addresses of an instances with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (i *Instances) NodeAddressesByProviderID(providerID string) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		return []v1.NodeAddress{}, errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapNodeNameToServerName maps from a k8s NodeName to a rackspace Server Name
0000000000000000000000000000000000000000;;	// This is a simple string cast.
0000000000000000000000000000000000000000;;	func mapNodeNameToServerName(nodeName types.NodeName) string {
0000000000000000000000000000000000000000;;		return string(nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapServerToNodeName maps a rackspace Server to an k8s NodeName
0000000000000000000000000000000000000000;;	func mapServerToNodeName(s *osservers.Server) types.NodeName {
0000000000000000000000000000000000000000;;		return types.NodeName(s.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalID returns the cloud provider ID of the node with the specified Name (deprecated).
0000000000000000000000000000000000000000;;	func (i *Instances) ExternalID(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		serverName := mapNodeNameToServerName(nodeName)
0000000000000000000000000000000000000000;;		return probeInstanceID(i.compute, serverName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the cloud provider ID of the kubelet's instance.
0000000000000000000000000000000000000000;;	func (rs *Rackspace) InstanceID() (string, error) {
0000000000000000000000000000000000000000;;		return readInstanceID()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the cloud provider ID of the node with the specified Name.
0000000000000000000000000000000000000000;;	func (i *Instances) InstanceID(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		serverName := mapNodeNameToServerName(nodeName)
0000000000000000000000000000000000000000;;		return probeInstanceID(i.compute, serverName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceType returns the type of the specified instance.
0000000000000000000000000000000000000000;;	func (i *Instances) InstanceType(name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceTypeByProviderID returns the cloudprovider instance type of the node with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (i *Instances) InstanceTypeByProviderID(providerID string) (string, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *Instances) AddSSHKeyToAllInstances(user string, keyData []byte) error {
0000000000000000000000000000000000000000;;		return errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of Instances.CurrentNodeName
0000000000000000000000000000000000000000;;	func (i *Instances) CurrentNodeName(hostname string) (types.NodeName, error) {
0000000000000000000000000000000000000000;;		// Beware when changing this, nodename == hostname assumption is crucial to
0000000000000000000000000000000000000000;;		// apiserver => kubelet communication.
0000000000000000000000000000000000000000;;		return types.NodeName(hostname), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *Rackspace) Clusters() (cloudprovider.Clusters, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;	func (os *Rackspace) ProviderName() string {
0000000000000000000000000000000000000000;;		return ProviderName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScrubDNS filters DNS settings for pods.
0000000000000000000000000000000000000000;;	func (os *Rackspace) ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string) {
0000000000000000000000000000000000000000;;		return nameservers, searches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *Rackspace) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *Rackspace) Zones() (cloudprovider.Zones, bool) {
0000000000000000000000000000000000000000;;		glog.V(1).Info("Claiming to support Zones")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return os, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *Rackspace) Routes() (cloudprovider.Routes, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *Rackspace) GetZone() (cloudprovider.Zone, error) {
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Current zone is %v", os.region)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cloudprovider.Zone{Region: os.region}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a volume of given size (in GiB)
0000000000000000000000000000000000000000;;	func (rs *Rackspace) CreateVolume(name string, size int, vtype, availability string, tags *map[string]string) (string, string, error) {
0000000000000000000000000000000000000000;;		return "", "", errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *Rackspace) DeleteVolume(volumeID string) error {
0000000000000000000000000000000000000000;;		return errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *Rackspace) OperationPending(diskName string) (bool, string, error) {
0000000000000000000000000000000000000000;;		disk, err := rs.getVolume(diskName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeStatus := disk.Status
0000000000000000000000000000000000000000;;		if volumeStatus == VolumeErrorStatus {
0000000000000000000000000000000000000000;;			glog.Errorf("status of volume %s is %s", diskName, volumeStatus)
0000000000000000000000000000000000000000;;			return false, volumeStatus, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volumeStatus == VolumeAvailableStatus || volumeStatus == VolumeInUseStatus {
0000000000000000000000000000000000000000;;			return false, disk.Status, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, volumeStatus, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attaches given cinder volume to the compute running kubelet
0000000000000000000000000000000000000000;;	func (rs *Rackspace) AttachDisk(instanceID, volumeID string) (string, error) {
0000000000000000000000000000000000000000;;		volume, err := rs.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volume.Status != VolumeAvailableStatus {
0000000000000000000000000000000000000000;;			errmsg := fmt.Sprintf("volume %s status is %s, not %s, can not be attached to instance %s.", volume.Name, volume.Status, VolumeAvailableStatus, instanceID)
0000000000000000000000000000000000000000;;			glog.Errorf(errmsg)
0000000000000000000000000000000000000000;;			return "", errors.New(errmsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compute, err := rs.getComputeClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volume.Attachments) > 0 {
0000000000000000000000000000000000000000;;			if instanceID == volume.Attachments[0]["server_id"] {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Volume: %q is already attached to compute: %q", volumeID, instanceID)
0000000000000000000000000000000000000000;;				return volume.ID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("Volume %q is attached to a different compute: %q, should be detached before proceeding", volumeID, volume.Attachments[0]["server_id"])
0000000000000000000000000000000000000000;;			glog.Errorf(errMsg)
0000000000000000000000000000000000000000;;			return "", errors.New(errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = volumeattach.Create(compute, instanceID, &osvolumeattach.CreateOpts{
0000000000000000000000000000000000000000;;			VolumeID: volume.ID,
0000000000000000000000000000000000000000;;		}).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to attach %s volume to %s compute", volumeID, instanceID)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully attached %s volume to %s compute", volumeID, instanceID)
0000000000000000000000000000000000000000;;		return volume.ID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDevicePath returns the path of an attached block storage volume, specified by its id.
0000000000000000000000000000000000000000;;	func (rs *Rackspace) GetDevicePath(volumeID string) string {
0000000000000000000000000000000000000000;;		volume, err := rs.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachments := volume.Attachments
0000000000000000000000000000000000000000;;		if len(attachments) != 1 {
0000000000000000000000000000000000000000;;			glog.Warningf("Unexpected number of volume attachments on %s: %d", volumeID, len(attachments))
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return attachments[0]["device"].(string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Takes a partial/full disk id or volumeName
0000000000000000000000000000000000000000;;	func (rs *Rackspace) getVolume(volumeID string) (*volumes.Volume, error) {
0000000000000000000000000000000000000000;;		client, err := rackspace.NewBlockStorageV1(rs.provider, gophercloud.EndpointOpts{
0000000000000000000000000000000000000000;;			Region: rs.region,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume, err := volumes.Get(client, volumeID).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error occurred getting volume by ID: %s", volumeID)
0000000000000000000000000000000000000000;;			return &volumes.Volume{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rs *Rackspace) getComputeClient() (*gophercloud.ServiceClient, error) {
0000000000000000000000000000000000000000;;		client, err := rackspace.NewComputeV2(rs.provider, gophercloud.EndpointOpts{
0000000000000000000000000000000000000000;;			Region: rs.region,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil || client == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to initialize nova client for region: %s", rs.region)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detaches given cinder volume from the compute running kubelet
0000000000000000000000000000000000000000;;	func (rs *Rackspace) DetachDisk(instanceID, volumeID string) error {
0000000000000000000000000000000000000000;;		volume, err := rs.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volume.Status != VolumeInUseStatus {
0000000000000000000000000000000000000000;;			errmsg := fmt.Sprintf("can not detach volume %s, its status is %s.", volume.Name, volume.Status)
0000000000000000000000000000000000000000;;			glog.Errorf(errmsg)
0000000000000000000000000000000000000000;;			return errors.New(errmsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compute, err := rs.getComputeClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volume.Attachments) > 1 {
0000000000000000000000000000000000000000;;			// Rackspace does not support "multiattach", this is a sanity check.
0000000000000000000000000000000000000000;;			errmsg := fmt.Sprintf("Volume %s is attached to multiple instances, which is not supported by this provider.", volume.ID)
0000000000000000000000000000000000000000;;			return errors.New(errmsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volume.Attachments) > 0 && instanceID == volume.Attachments[0]["server_id"] {
0000000000000000000000000000000000000000;;			// This is a blocking call and effects kubelet's performance directly.
0000000000000000000000000000000000000000;;			// We should consider kicking it out into a separate routine, if it is bad.
0000000000000000000000000000000000000000;;			err = volumeattach.Delete(compute, instanceID, volume.ID).ExtractErr()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to delete volume %s from compute %s attached %v", volume.ID, instanceID, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Successfully detached volume: %s from compute: %s", volume.ID, instanceID)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("Disk: %s has no attachments or is not attached to compute: %s", volume.Name, instanceID)
0000000000000000000000000000000000000000;;			glog.Errorf(errMsg)
0000000000000000000000000000000000000000;;			return errors.New(errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get device path of attached volume to the compute running kubelet, as known by cinder
0000000000000000000000000000000000000000;;	func (rs *Rackspace) GetAttachmentDiskPath(instanceID, volumeID string) (string, error) {
0000000000000000000000000000000000000000;;		// See issue #33128 - Cinder does not always tell you the right device path, as such
0000000000000000000000000000000000000000;;		// we must only use this value as a last resort.
0000000000000000000000000000000000000000;;		volume, err := rs.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volume.Status != VolumeInUseStatus {
0000000000000000000000000000000000000000;;			errmsg := fmt.Sprintf("can not get device path of volume %s, its status is %s.", volume.Name, volume.Status)
0000000000000000000000000000000000000000;;			glog.Errorf(errmsg)
0000000000000000000000000000000000000000;;			return "", errors.New(errmsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volume.Attachments) > 0 && volume.Attachments[0]["server_id"] != nil {
0000000000000000000000000000000000000000;;			if instanceID == volume.Attachments[0]["server_id"] {
0000000000000000000000000000000000000000;;				// Attachment[0]["device"] points to the device path
0000000000000000000000000000000000000000;;				// see http://developer.openstack.org/api-ref-blockstorage-v1.html
0000000000000000000000000000000000000000;;				return volume.Attachments[0]["device"].(string), nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errMsg := fmt.Sprintf("Disk %q is attached to a different compute: %q, should be detached before proceeding", volumeID, volume.Attachments[0]["server_id"])
0000000000000000000000000000000000000000;;				glog.Errorf(errMsg)
0000000000000000000000000000000000000000;;				return "", errors.New(errMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("volume %s is not attached to %s", volumeID, instanceID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// query if a volume is attached to a compute instance
0000000000000000000000000000000000000000;;	func (rs *Rackspace) DiskIsAttached(instanceID, volumeID string) (bool, error) {
0000000000000000000000000000000000000000;;		volume, err := rs.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volume.Attachments) > 0 && volume.Attachments[0]["server_id"] != nil && instanceID == volume.Attachments[0]["server_id"] {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// query if a list volumes are attached to a compute instance
0000000000000000000000000000000000000000;;	func (rs *Rackspace) DisksAreAttached(instanceID string, volumeIDs []string) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		attached := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, volumeID := range volumeIDs {
0000000000000000000000000000000000000000;;			attached[volumeID] = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var returnedErr error
0000000000000000000000000000000000000000;;		for _, volumeID := range volumeIDs {
0000000000000000000000000000000000000000;;			result, err := rs.DiskIsAttached(instanceID, volumeID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				returnedErr = fmt.Errorf("Error in checking disk %q attached: %v \n %v", volumeID, err, returnedErr)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result {
0000000000000000000000000000000000000000;;				attached[volumeID] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return attached, returnedErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// query if we should trust the cinder provide deviceName, See issue #33128
0000000000000000000000000000000000000000;;	func (rs *Rackspace) ShouldTrustDevicePath() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
