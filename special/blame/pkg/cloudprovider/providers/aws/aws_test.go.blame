0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
5fa3cbce3551017455f31b035f00973f44ce8a0f;pkg/cloudprovider/aws/aws_test.go[pkg/cloudprovider/aws/aws_test.go][pkg/cloudprovider/providers/aws/aws_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/elb"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/autoscaling"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/mock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const TestClusterId = "clusterid.test"
0000000000000000000000000000000000000000;;	const TestClusterName = "testCluster"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadAWSCloudConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reader io.Reader
0000000000000000000000000000000000000000;;			aws    Services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;			zone        string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No config reader",
0000000000000000000000000000000000000000;;				nil, nil,
0000000000000000000000000000000000000000;;				true, "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Empty config, no metadata",
0000000000000000000000000000000000000000;;				strings.NewReader(""), nil,
0000000000000000000000000000000000000000;;				true, "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No zone in config, no metadata",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\n"), nil,
0000000000000000000000000000000000000000;;				true, "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Zone in config, no metadata",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\nzone = eu-west-1a"), nil,
0000000000000000000000000000000000000000;;				false, "eu-west-1a",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No zone in config, metadata does not have zone",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\n"), NewFakeAWSServices().withAz(""),
0000000000000000000000000000000000000000;;				true, "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No zone in config, metadata has zone",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\n"), NewFakeAWSServices(),
0000000000000000000000000000000000000000;;				false, "us-east-1a",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Zone in config should take precedence over metadata",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\nzone = eu-west-1a"), NewFakeAWSServices(),
0000000000000000000000000000000000000000;;				false, "eu-west-1a",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Logf("Running test case %s", test.name)
0000000000000000000000000000000000000000;;			var metadata EC2Metadata
0000000000000000000000000000000000000000;;			if test.aws != nil {
0000000000000000000000000000000000000000;;				metadata, _ = test.aws.Metadata()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cfg, err := readAWSCloudConfig(test.reader, metadata)
0000000000000000000000000000000000000000;;			if test.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("Should error for case %s (cfg=%v)", test.name, cfg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Should succeed for case: %s", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cfg.Global.Zone != test.zone {
0000000000000000000000000000000000000000;;					t.Errorf("Incorrect zone value (%s vs %s) for case: %s",
0000000000000000000000000000000000000000;;						cfg.Global.Zone, test.zone, test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeAWSServices struct {
0000000000000000000000000000000000000000;;		region                  string
0000000000000000000000000000000000000000;;		instances               []*ec2.Instance
0000000000000000000000000000000000000000;;		selfInstance            *ec2.Instance
0000000000000000000000000000000000000000;;		networkInterfacesMacs   []string
0000000000000000000000000000000000000000;;		networkInterfacesVpcIDs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ec2      *FakeEC2
0000000000000000000000000000000000000000;;		elb      *FakeELB
0000000000000000000000000000000000000000;;		asg      *FakeASG
0000000000000000000000000000000000000000;;		metadata *FakeMetadata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeAWSServices() *FakeAWSServices {
0000000000000000000000000000000000000000;;		s := &FakeAWSServices{}
0000000000000000000000000000000000000000;;		s.region = "us-east-1"
0000000000000000000000000000000000000000;;		s.ec2 = &FakeEC2{aws: s}
0000000000000000000000000000000000000000;;		s.elb = &FakeELB{aws: s}
0000000000000000000000000000000000000000;;		s.asg = &FakeASG{aws: s}
0000000000000000000000000000000000000000;;		s.metadata = &FakeMetadata{aws: s}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.networkInterfacesMacs = []string{"aa:bb:cc:dd:ee:00", "aa:bb:cc:dd:ee:01"}
0000000000000000000000000000000000000000;;		s.networkInterfacesVpcIDs = []string{"vpc-mac0", "vpc-mac1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfInstance := &ec2.Instance{}
0000000000000000000000000000000000000000;;		selfInstance.InstanceId = aws.String("i-self")
0000000000000000000000000000000000000000;;		selfInstance.Placement = &ec2.Placement{
0000000000000000000000000000000000000000;;			AvailabilityZone: aws.String("us-east-1a"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selfInstance.PrivateDnsName = aws.String("ip-172-20-0-100.ec2.internal")
0000000000000000000000000000000000000000;;		selfInstance.PrivateIpAddress = aws.String("192.168.0.1")
0000000000000000000000000000000000000000;;		selfInstance.PublicIpAddress = aws.String("1.2.3.4")
0000000000000000000000000000000000000000;;		s.selfInstance = selfInstance
0000000000000000000000000000000000000000;;		s.instances = []*ec2.Instance{selfInstance}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tag ec2.Tag
0000000000000000000000000000000000000000;;		tag.Key = aws.String(TagNameKubernetesClusterLegacy)
0000000000000000000000000000000000000000;;		tag.Value = aws.String(TestClusterId)
0000000000000000000000000000000000000000;;		selfInstance.Tags = []*ec2.Tag{&tag}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeAWSServices) withAz(az string) *FakeAWSServices {
0000000000000000000000000000000000000000;;		if s.selfInstance.Placement == nil {
0000000000000000000000000000000000000000;;			s.selfInstance.Placement = &ec2.Placement{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.selfInstance.Placement.AvailabilityZone = aws.String(az)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeAWSServices) Compute(region string) (EC2, error) {
0000000000000000000000000000000000000000;;		return s.ec2, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeAWSServices) LoadBalancing(region string) (ELB, error) {
0000000000000000000000000000000000000000;;		return s.elb, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeAWSServices) Autoscaling(region string) (ASG, error) {
0000000000000000000000000000000000000000;;		return s.asg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeAWSServices) Metadata() (EC2Metadata, error) {
0000000000000000000000000000000000000000;;		return s.metadata, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewAWSCloud(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reader      io.Reader
0000000000000000000000000000000000000000;;			awsServices Services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;			region      string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No config reader",
0000000000000000000000000000000000000000;;				nil, NewFakeAWSServices().withAz(""),
0000000000000000000000000000000000000000;;				true, "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Config specifies valid zone",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\nzone = eu-west-1a"), NewFakeAWSServices(),
0000000000000000000000000000000000000000;;				false, "eu-west-1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Gets zone from metadata when not in config",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\n"),
0000000000000000000000000000000000000000;;				NewFakeAWSServices(),
0000000000000000000000000000000000000000;;				false, "us-east-1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No zone in config or metadata",
0000000000000000000000000000000000000000;;				strings.NewReader("[global]\n"),
0000000000000000000000000000000000000000;;				NewFakeAWSServices().withAz(""),
0000000000000000000000000000000000000000;;				true, "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Logf("Running test case %s", test.name)
0000000000000000000000000000000000000000;;			c, err := newAWSCloud(test.reader, test.awsServices)
0000000000000000000000000000000000000000;;			if test.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("Should error for case %s", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Should succeed for case: %s, got %v", test.name, err)
0000000000000000000000000000000000000000;;				} else if c.region != test.region {
0000000000000000000000000000000000000000;;					t.Errorf("Incorrect region value (%s vs %s) for case: %s",
0000000000000000000000000000000000000000;;						c.region, test.region, test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeEC2 struct {
0000000000000000000000000000000000000000;;		aws                      *FakeAWSServices
0000000000000000000000000000000000000000;;		Subnets                  []*ec2.Subnet
0000000000000000000000000000000000000000;;		DescribeSubnetsInput     *ec2.DescribeSubnetsInput
0000000000000000000000000000000000000000;;		RouteTables              []*ec2.RouteTable
0000000000000000000000000000000000000000;;		DescribeRouteTablesInput *ec2.DescribeRouteTablesInput
0000000000000000000000000000000000000000;;		mock.Mock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(haystack []*string, needle string) bool {
0000000000000000000000000000000000000000;;		for _, s := range haystack {
0000000000000000000000000000000000000000;;			// (deliberately panic if s == nil)
0000000000000000000000000000000000000000;;			if needle == *s {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func instanceMatchesFilter(instance *ec2.Instance, filter *ec2.Filter) bool {
0000000000000000000000000000000000000000;;		name := *filter.Name
0000000000000000000000000000000000000000;;		if name == "private-dns-name" {
0000000000000000000000000000000000000000;;			if instance.PrivateDnsName == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return contains(filter.Values, *instance.PrivateDnsName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name == "instance-state-name" {
0000000000000000000000000000000000000000;;			return contains(filter.Values, *instance.State.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name == "tag-key" {
0000000000000000000000000000000000000000;;			for _, instanceTag := range instance.Tags {
0000000000000000000000000000000000000000;;				if contains(filter.Values, aws.StringValue(instanceTag.Key)) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasPrefix(name, "tag:") {
0000000000000000000000000000000000000000;;			tagName := name[4:]
0000000000000000000000000000000000000000;;			for _, instanceTag := range instance.Tags {
0000000000000000000000000000000000000000;;				if aws.StringValue(instanceTag.Key) == tagName && contains(filter.Values, aws.StringValue(instanceTag.Value)) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic("Unknown filter name: " + name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *FakeEC2) DescribeInstances(request *ec2.DescribeInstancesInput) ([]*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		matches := []*ec2.Instance{}
0000000000000000000000000000000000000000;;		for _, instance := range self.aws.instances {
0000000000000000000000000000000000000000;;			if request.InstanceIds != nil {
0000000000000000000000000000000000000000;;				if instance.InstanceId == nil {
0000000000000000000000000000000000000000;;					glog.Warning("Instance with no instance id: ", instance)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for _, instanceID := range request.InstanceIds {
0000000000000000000000000000000000000000;;					if *instanceID == *instance.InstanceId {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if request.Filters != nil {
0000000000000000000000000000000000000000;;				allMatch := true
0000000000000000000000000000000000000000;;				for _, filter := range request.Filters {
0000000000000000000000000000000000000000;;					if !instanceMatchesFilter(instance, filter) {
0000000000000000000000000000000000000000;;						allMatch = false
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !allMatch {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			matches = append(matches, instance)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matches, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeMetadata struct {
0000000000000000000000000000000000000000;;		aws *FakeAWSServices
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *FakeMetadata) GetMetadata(key string) (string, error) {
0000000000000000000000000000000000000000;;		networkInterfacesPrefix := "network/interfaces/macs/"
0000000000000000000000000000000000000000;;		i := self.aws.selfInstance
0000000000000000000000000000000000000000;;		if key == "placement/availability-zone" {
0000000000000000000000000000000000000000;;			az := ""
0000000000000000000000000000000000000000;;			if i.Placement != nil {
0000000000000000000000000000000000000000;;				az = aws.StringValue(i.Placement.AvailabilityZone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return az, nil
0000000000000000000000000000000000000000;;		} else if key == "instance-id" {
0000000000000000000000000000000000000000;;			return aws.StringValue(i.InstanceId), nil
0000000000000000000000000000000000000000;;		} else if key == "local-hostname" {
0000000000000000000000000000000000000000;;			return aws.StringValue(i.PrivateDnsName), nil
0000000000000000000000000000000000000000;;		} else if key == "public-hostname" {
0000000000000000000000000000000000000000;;			return aws.StringValue(i.PublicDnsName), nil
0000000000000000000000000000000000000000;;		} else if key == "local-ipv4" {
0000000000000000000000000000000000000000;;			return aws.StringValue(i.PrivateIpAddress), nil
0000000000000000000000000000000000000000;;		} else if key == "public-ipv4" {
0000000000000000000000000000000000000000;;			return aws.StringValue(i.PublicIpAddress), nil
0000000000000000000000000000000000000000;;		} else if strings.HasPrefix(key, networkInterfacesPrefix) {
0000000000000000000000000000000000000000;;			if key == networkInterfacesPrefix {
0000000000000000000000000000000000000000;;				return strings.Join(self.aws.networkInterfacesMacs, "/\n") + "/\n", nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				keySplit := strings.Split(key, "/")
0000000000000000000000000000000000000000;;				macParam := keySplit[3]
0000000000000000000000000000000000000000;;				if len(keySplit) == 5 && keySplit[4] == "vpc-id" {
0000000000000000000000000000000000000000;;					for i, macElem := range self.aws.networkInterfacesMacs {
0000000000000000000000000000000000000000;;						if macParam == macElem {
0000000000000000000000000000000000000000;;							return self.aws.networkInterfacesVpcIDs[i], nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) AttachVolume(request *ec2.AttachVolumeInput) (resp *ec2.VolumeAttachment, err error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) DetachVolume(request *ec2.DetachVolumeInput) (resp *ec2.VolumeAttachment, err error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *FakeEC2) DescribeVolumes(request *ec2.DescribeVolumesInput) ([]*ec2.Volume, error) {
0000000000000000000000000000000000000000;;		args := e.Called(request)
0000000000000000000000000000000000000000;;		return args.Get(0).([]*ec2.Volume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) CreateVolume(request *ec2.CreateVolumeInput) (resp *ec2.Volume, err error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) DeleteVolume(request *ec2.DeleteVolumeInput) (resp *ec2.DeleteVolumeOutput, err error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *FakeEC2) DescribeSecurityGroups(request *ec2.DescribeSecurityGroupsInput) ([]*ec2.SecurityGroup, error) {
0000000000000000000000000000000000000000;;		args := e.Called(request)
0000000000000000000000000000000000000000;;		return args.Get(0).([]*ec2.SecurityGroup), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) CreateSecurityGroup(*ec2.CreateSecurityGroupInput) (*ec2.CreateSecurityGroupOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) DeleteSecurityGroup(*ec2.DeleteSecurityGroupInput) (*ec2.DeleteSecurityGroupOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) AuthorizeSecurityGroupIngress(*ec2.AuthorizeSecurityGroupIngressInput) (*ec2.AuthorizeSecurityGroupIngressOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) RevokeSecurityGroupIngress(*ec2.RevokeSecurityGroupIngressInput) (*ec2.RevokeSecurityGroupIngressOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) DescribeSubnets(request *ec2.DescribeSubnetsInput) ([]*ec2.Subnet, error) {
0000000000000000000000000000000000000000;;		ec2.DescribeSubnetsInput = request
0000000000000000000000000000000000000000;;		return ec2.Subnets, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) CreateTags(*ec2.CreateTagsInput) (*ec2.CreateTagsOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeEC2) DescribeRouteTables(request *ec2.DescribeRouteTablesInput) ([]*ec2.RouteTable, error) {
0000000000000000000000000000000000000000;;		ec2.DescribeRouteTablesInput = request
0000000000000000000000000000000000000000;;		return ec2.RouteTables, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeEC2) CreateRoute(request *ec2.CreateRouteInput) (*ec2.CreateRouteOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeEC2) DeleteRoute(request *ec2.DeleteRouteInput) (*ec2.DeleteRouteOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FakeEC2) ModifyInstanceAttribute(request *ec2.ModifyInstanceAttributeInput) (*ec2.ModifyInstanceAttributeOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeELB struct {
0000000000000000000000000000000000000000;;		aws *FakeAWSServices
0000000000000000000000000000000000000000;;		mock.Mock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) CreateLoadBalancer(*elb.CreateLoadBalancerInput) (*elb.CreateLoadBalancerOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) DeleteLoadBalancer(input *elb.DeleteLoadBalancerInput) (*elb.DeleteLoadBalancerOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) DescribeLoadBalancers(input *elb.DescribeLoadBalancersInput) (*elb.DescribeLoadBalancersOutput, error) {
0000000000000000000000000000000000000000;;		args := ec2.Called(input)
0000000000000000000000000000000000000000;;		return args.Get(0).(*elb.DescribeLoadBalancersOutput), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) RegisterInstancesWithLoadBalancer(*elb.RegisterInstancesWithLoadBalancerInput) (*elb.RegisterInstancesWithLoadBalancerOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) DeregisterInstancesFromLoadBalancer(*elb.DeregisterInstancesFromLoadBalancerInput) (*elb.DeregisterInstancesFromLoadBalancerOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) DetachLoadBalancerFromSubnets(*elb.DetachLoadBalancerFromSubnetsInput) (*elb.DetachLoadBalancerFromSubnetsOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) AttachLoadBalancerToSubnets(*elb.AttachLoadBalancerToSubnetsInput) (*elb.AttachLoadBalancerToSubnetsOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) CreateLoadBalancerListeners(*elb.CreateLoadBalancerListenersInput) (*elb.CreateLoadBalancerListenersOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) DeleteLoadBalancerListeners(*elb.DeleteLoadBalancerListenersInput) (*elb.DeleteLoadBalancerListenersOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec2 *FakeELB) ApplySecurityGroupsToLoadBalancer(*elb.ApplySecurityGroupsToLoadBalancerInput) (*elb.ApplySecurityGroupsToLoadBalancerOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (elb *FakeELB) ConfigureHealthCheck(*elb.ConfigureHealthCheckInput) (*elb.ConfigureHealthCheckOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (elb *FakeELB) CreateLoadBalancerPolicy(*elb.CreateLoadBalancerPolicyInput) (*elb.CreateLoadBalancerPolicyOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (elb *FakeELB) SetLoadBalancerPoliciesForBackendServer(*elb.SetLoadBalancerPoliciesForBackendServerInput) (*elb.SetLoadBalancerPoliciesForBackendServerOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (elb *FakeELB) DescribeLoadBalancerAttributes(*elb.DescribeLoadBalancerAttributesInput) (*elb.DescribeLoadBalancerAttributesOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (elb *FakeELB) ModifyLoadBalancerAttributes(*elb.ModifyLoadBalancerAttributesInput) (*elb.ModifyLoadBalancerAttributesOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeASG struct {
0000000000000000000000000000000000000000;;		aws *FakeAWSServices
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *FakeASG) UpdateAutoScalingGroup(*autoscaling.UpdateAutoScalingGroupInput) (*autoscaling.UpdateAutoScalingGroupOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *FakeASG) DescribeAutoScalingGroups(*autoscaling.DescribeAutoScalingGroupsInput) (*autoscaling.DescribeAutoScalingGroupsOutput, error) {
0000000000000000000000000000000000000000;;		panic("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mockInstancesResp(selfInstance *ec2.Instance, instances []*ec2.Instance) (*Cloud, *FakeAWSServices) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		awsServices.instances = instances
0000000000000000000000000000000000000000;;		awsServices.selfInstance = selfInstance
0000000000000000000000000000000000000000;;		awsCloud, err := newAWSCloud(nil, awsServices)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return awsCloud, awsServices
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mockAvailabilityZone(availabilityZone string) *Cloud {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices().withAz(availabilityZone)
0000000000000000000000000000000000000000;;		awsCloud, err := newAWSCloud(nil, awsServices)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return awsCloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testHasNodeAddress(t *testing.T, addrs []v1.NodeAddress, addressType v1.NodeAddressType, address string) {
0000000000000000000000000000000000000000;;		for _, addr := range addrs {
0000000000000000000000000000000000000000;;			if addr.Type == addressType && addr.Address == address {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("Did not find expected address: %s:%s in %v", addressType, address, addrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNodeAddresses(t *testing.T) {
0000000000000000000000000000000000000000;;		// Note these instances have the same name
0000000000000000000000000000000000000000;;		// (we test that this produces an error)
0000000000000000000000000000000000000000;;		var instance0 ec2.Instance
0000000000000000000000000000000000000000;;		var instance1 ec2.Instance
0000000000000000000000000000000000000000;;		var instance2 ec2.Instance
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//0
0000000000000000000000000000000000000000;;		instance0.InstanceId = aws.String("i-0")
0000000000000000000000000000000000000000;;		instance0.PrivateDnsName = aws.String("instance-same.ec2.internal")
0000000000000000000000000000000000000000;;		instance0.PrivateIpAddress = aws.String("192.168.0.1")
0000000000000000000000000000000000000000;;		instance0.PublicDnsName = aws.String("instance-same.ec2.external")
0000000000000000000000000000000000000000;;		instance0.PublicIpAddress = aws.String("1.2.3.4")
0000000000000000000000000000000000000000;;		instance0.InstanceType = aws.String("c3.large")
0000000000000000000000000000000000000000;;		instance0.Placement = &ec2.Placement{AvailabilityZone: aws.String("us-east-1a")}
0000000000000000000000000000000000000000;;		state0 := ec2.InstanceState{
0000000000000000000000000000000000000000;;			Name: aws.String("running"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instance0.State = &state0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//1
0000000000000000000000000000000000000000;;		instance1.InstanceId = aws.String("i-1")
0000000000000000000000000000000000000000;;		instance1.PrivateDnsName = aws.String("instance-same.ec2.internal")
0000000000000000000000000000000000000000;;		instance1.PrivateIpAddress = aws.String("192.168.0.2")
0000000000000000000000000000000000000000;;		instance1.InstanceType = aws.String("c3.large")
0000000000000000000000000000000000000000;;		instance1.Placement = &ec2.Placement{AvailabilityZone: aws.String("us-east-1a")}
0000000000000000000000000000000000000000;;		state1 := ec2.InstanceState{
0000000000000000000000000000000000000000;;			Name: aws.String("running"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instance1.State = &state1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//2
0000000000000000000000000000000000000000;;		instance2.InstanceId = aws.String("i-2")
0000000000000000000000000000000000000000;;		instance2.PrivateDnsName = aws.String("instance-other.ec2.internal")
0000000000000000000000000000000000000000;;		instance2.PrivateIpAddress = aws.String("192.168.0.1")
0000000000000000000000000000000000000000;;		instance2.PublicIpAddress = aws.String("1.2.3.4")
0000000000000000000000000000000000000000;;		instance2.InstanceType = aws.String("c3.large")
0000000000000000000000000000000000000000;;		instance2.Placement = &ec2.Placement{AvailabilityZone: aws.String("us-east-1a")}
0000000000000000000000000000000000000000;;		state2 := ec2.InstanceState{
0000000000000000000000000000000000000000;;			Name: aws.String("running"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instance2.State = &state2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances := []*ec2.Instance{&instance0, &instance1, &instance2}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aws1, _ := mockInstancesResp(&instance0, []*ec2.Instance{&instance0})
0000000000000000000000000000000000000000;;		_, err1 := aws1.NodeAddresses("instance-mismatch.ec2.internal")
0000000000000000000000000000000000000000;;		if err1 == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Should error when no instance found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aws2, _ := mockInstancesResp(&instance2, instances)
0000000000000000000000000000000000000000;;		_, err2 := aws2.NodeAddresses("instance-same.ec2.internal")
0000000000000000000000000000000000000000;;		if err2 == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Should error when multiple instances found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aws3, _ := mockInstancesResp(&instance0, instances[0:1])
0000000000000000000000000000000000000000;;		addrs3, err3 := aws3.NodeAddresses("instance-same.ec2.internal")
0000000000000000000000000000000000000000;;		if err3 != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Should not error when instance found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(addrs3) != 4 {
0000000000000000000000000000000000000000;;			t.Errorf("Should return exactly 4 NodeAddresses")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testHasNodeAddress(t, addrs3, v1.NodeInternalIP, "192.168.0.1")
0000000000000000000000000000000000000000;;		testHasNodeAddress(t, addrs3, v1.NodeExternalIP, "1.2.3.4")
0000000000000000000000000000000000000000;;		testHasNodeAddress(t, addrs3, v1.NodeExternalDNS, "instance-same.ec2.external")
0000000000000000000000000000000000000000;;		testHasNodeAddress(t, addrs3, v1.NodeInternalDNS, "instance-same.ec2.internal")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fetch from metadata
0000000000000000000000000000000000000000;;		aws4, fakeServices := mockInstancesResp(&instance0, []*ec2.Instance{&instance0})
0000000000000000000000000000000000000000;;		fakeServices.selfInstance.PublicIpAddress = aws.String("2.3.4.5")
0000000000000000000000000000000000000000;;		fakeServices.selfInstance.PrivateIpAddress = aws.String("192.168.0.2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addrs4, err4 := aws4.NodeAddresses(mapInstanceToNodeName(&instance0))
0000000000000000000000000000000000000000;;		if err4 != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err4)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testHasNodeAddress(t, addrs4, v1.NodeInternalIP, "192.168.0.2")
0000000000000000000000000000000000000000;;		testHasNodeAddress(t, addrs4, v1.NodeExternalIP, "2.3.4.5")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetRegion(t *testing.T) {
0000000000000000000000000000000000000000;;		aws := mockAvailabilityZone("us-west-2e")
0000000000000000000000000000000000000000;;		zones, ok := aws.Zones()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected missing zones impl")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zone, err := zones.GetZone()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if zone.Region != "us-west-2" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected region: %s", zone.Region)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if zone.FailureDomain != "us-west-2e" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected FailureDomain: %s", zone.FailureDomain)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindVPCID(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, err := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error building aws cloud: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vpcID, err := c.findVPCID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vpcID != "vpc-mac0" {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected vpcID: %s", vpcID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func constructSubnets(subnetsIn map[int]map[string]string) (subnetsOut []*ec2.Subnet) {
0000000000000000000000000000000000000000;;		for i := range subnetsIn {
0000000000000000000000000000000000000000;;			subnetsOut = append(
0000000000000000000000000000000000000000;;				subnetsOut,
0000000000000000000000000000000000000000;;				constructSubnet(
0000000000000000000000000000000000000000;;					subnetsIn[i]["id"],
0000000000000000000000000000000000000000;;					subnetsIn[i]["az"],
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func constructSubnet(id string, az string) *ec2.Subnet {
0000000000000000000000000000000000000000;;		return &ec2.Subnet{
0000000000000000000000000000000000000000;;			SubnetId:         &id,
0000000000000000000000000000000000000000;;			AvailabilityZone: &az,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func constructRouteTables(routeTablesIn map[string]bool) (routeTablesOut []*ec2.RouteTable) {
0000000000000000000000000000000000000000;;		routeTablesOut = append(routeTablesOut,
0000000000000000000000000000000000000000;;			&ec2.RouteTable{
0000000000000000000000000000000000000000;;				Associations: []*ec2.RouteTableAssociation{{Main: aws.Bool(true)}},
0000000000000000000000000000000000000000;;				Routes: []*ec2.Route{{
0000000000000000000000000000000000000000;;					DestinationCidrBlock: aws.String("0.0.0.0/0"),
0000000000000000000000000000000000000000;;					GatewayId:            aws.String("igw-main"),
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for subnetID := range routeTablesIn {
0000000000000000000000000000000000000000;;			routeTablesOut = append(
0000000000000000000000000000000000000000;;				routeTablesOut,
0000000000000000000000000000000000000000;;				constructRouteTable(
0000000000000000000000000000000000000000;;					subnetID,
0000000000000000000000000000000000000000;;					routeTablesIn[subnetID],
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func constructRouteTable(subnetID string, public bool) *ec2.RouteTable {
0000000000000000000000000000000000000000;;		var gatewayID string
0000000000000000000000000000000000000000;;		if public {
0000000000000000000000000000000000000000;;			gatewayID = "igw-" + subnetID[len(subnetID)-8:8]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			gatewayID = "vgw-" + subnetID[len(subnetID)-8:8]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ec2.RouteTable{
0000000000000000000000000000000000000000;;			Associations: []*ec2.RouteTableAssociation{{SubnetId: aws.String(subnetID)}},
0000000000000000000000000000000000000000;;			Routes: []*ec2.Route{{
0000000000000000000000000000000000000000;;				DestinationCidrBlock: aws.String("0.0.0.0/0"),
0000000000000000000000000000000000000000;;				GatewayId:            aws.String(gatewayID),
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSubnetIDsinVPC(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, err := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error building aws cloud: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test with 3 subnets from 3 different AZs
0000000000000000000000000000000000000000;;		subnets := make(map[int]map[string]string)
0000000000000000000000000000000000000000;;		subnets[0] = make(map[string]string)
0000000000000000000000000000000000000000;;		subnets[0]["id"] = "subnet-a0000001"
0000000000000000000000000000000000000000;;		subnets[0]["az"] = "af-south-1a"
0000000000000000000000000000000000000000;;		subnets[1] = make(map[string]string)
0000000000000000000000000000000000000000;;		subnets[1]["id"] = "subnet-b0000001"
0000000000000000000000000000000000000000;;		subnets[1]["az"] = "af-south-1b"
0000000000000000000000000000000000000000;;		subnets[2] = make(map[string]string)
0000000000000000000000000000000000000000;;		subnets[2]["id"] = "subnet-c0000001"
0000000000000000000000000000000000000000;;		subnets[2]["az"] = "af-south-1c"
0000000000000000000000000000000000000000;;		awsServices.ec2.Subnets = constructSubnets(subnets)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routeTables := map[string]bool{
0000000000000000000000000000000000000000;;			"subnet-a0000001": true,
0000000000000000000000000000000000000000;;			"subnet-b0000001": true,
0000000000000000000000000000000000000000;;			"subnet-c0000001": true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsServices.ec2.RouteTables = constructRouteTables(routeTables)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err := c.findELBSubnets(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error listing subnets: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(result) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 3 subnets but got %d", len(result))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result_set := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, v := range result {
0000000000000000000000000000000000000000;;			result_set[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range subnets {
0000000000000000000000000000000000000000;;			if !result_set[subnets[i]["id"]] {
0000000000000000000000000000000000000000;;				t.Errorf("Expected subnet%d '%s' in result: %v", i, subnets[i]["id"], result)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test implicit routing table - when subnets are not explicitly linked to a table they should use main
0000000000000000000000000000000000000000;;		awsServices.ec2.RouteTables = constructRouteTables(map[string]bool{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err = c.findELBSubnets(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error listing subnets: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(result) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 3 subnets but got %d", len(result))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result_set = make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, v := range result {
0000000000000000000000000000000000000000;;			result_set[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range subnets {
0000000000000000000000000000000000000000;;			if !result_set[subnets[i]["id"]] {
0000000000000000000000000000000000000000;;				t.Errorf("Expected subnet%d '%s' in result: %v", i, subnets[i]["id"], result)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test with 4 subnets from 3 different AZs
0000000000000000000000000000000000000000;;		// add duplicate az subnet
0000000000000000000000000000000000000000;;		subnets[3] = make(map[string]string)
0000000000000000000000000000000000000000;;		subnets[3]["id"] = "subnet-c0000002"
0000000000000000000000000000000000000000;;		subnets[3]["az"] = "af-south-1c"
0000000000000000000000000000000000000000;;		awsServices.ec2.Subnets = constructSubnets(subnets)
0000000000000000000000000000000000000000;;		routeTables["subnet-c0000002"] = true
0000000000000000000000000000000000000000;;		awsServices.ec2.RouteTables = constructRouteTables(routeTables)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err = c.findELBSubnets(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error listing subnets: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(result) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 3 subnets but got %d", len(result))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test with 6 subnets from 3 different AZs
0000000000000000000000000000000000000000;;		// with 3 private subnets
0000000000000000000000000000000000000000;;		subnets[4] = make(map[string]string)
0000000000000000000000000000000000000000;;		subnets[4]["id"] = "subnet-d0000001"
0000000000000000000000000000000000000000;;		subnets[4]["az"] = "af-south-1a"
0000000000000000000000000000000000000000;;		subnets[5] = make(map[string]string)
0000000000000000000000000000000000000000;;		subnets[5]["id"] = "subnet-d0000002"
0000000000000000000000000000000000000000;;		subnets[5]["az"] = "af-south-1b"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsServices.ec2.Subnets = constructSubnets(subnets)
0000000000000000000000000000000000000000;;		routeTables["subnet-a0000001"] = false
0000000000000000000000000000000000000000;;		routeTables["subnet-b0000001"] = false
0000000000000000000000000000000000000000;;		routeTables["subnet-c0000001"] = false
0000000000000000000000000000000000000000;;		routeTables["subnet-c0000002"] = true
0000000000000000000000000000000000000000;;		routeTables["subnet-d0000001"] = true
0000000000000000000000000000000000000000;;		routeTables["subnet-d0000002"] = true
0000000000000000000000000000000000000000;;		awsServices.ec2.RouteTables = constructRouteTables(routeTables)
0000000000000000000000000000000000000000;;		result, err = c.findELBSubnets(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error listing subnets: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(result) != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 3 subnets but got %d", len(result))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := []*string{aws.String("subnet-c0000002"), aws.String("subnet-d0000001"), aws.String("subnet-d0000002")}
0000000000000000000000000000000000000000;;		for _, s := range result {
0000000000000000000000000000000000000000;;			if !contains(expected, s) {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected subnet '%s' found", s)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIpPermissionExistsHandlesMultipleGroupIds(t *testing.T) {
0000000000000000000000000000000000000000;;		oldIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			UserIdGroupPairs: []*ec2.UserIdGroupPair{
0000000000000000000000000000000000000000;;				{GroupId: aws.String("firstGroupId")},
0000000000000000000000000000000000000000;;				{GroupId: aws.String("secondGroupId")},
0000000000000000000000000000000000000000;;				{GroupId: aws.String("thirdGroupId")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			UserIdGroupPairs: []*ec2.UserIdGroupPair{
0000000000000000000000000000000000000000;;				{GroupId: aws.String("secondGroupId")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			UserIdGroupPairs: []*ec2.UserIdGroupPair{
0000000000000000000000000000000000000000;;				{GroupId: aws.String("fourthGroupId")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		equals := ipPermissionExists(&existingIpPermission, &oldIpPermission, false)
0000000000000000000000000000000000000000;;		if !equals {
0000000000000000000000000000000000000000;;			t.Errorf("Should have been considered equal since first is in the second array of groups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		equals = ipPermissionExists(&newIpPermission, &oldIpPermission, false)
0000000000000000000000000000000000000000;;		if equals {
0000000000000000000000000000000000000000;;			t.Errorf("Should have not been considered equal since first is not in the second array of groups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The first pair matches, but the second does not
0000000000000000000000000000000000000000;;		newIpPermission2 := ec2.IpPermission{
0000000000000000000000000000000000000000;;			UserIdGroupPairs: []*ec2.UserIdGroupPair{
0000000000000000000000000000000000000000;;				{GroupId: aws.String("firstGroupId")},
0000000000000000000000000000000000000000;;				{GroupId: aws.String("fourthGroupId")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		equals = ipPermissionExists(&newIpPermission2, &oldIpPermission, false)
0000000000000000000000000000000000000000;;		if equals {
0000000000000000000000000000000000000000;;			t.Errorf("Should have not been considered equal since first is not in the second array of groups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIpPermissionExistsHandlesRangeSubsets(t *testing.T) {
0000000000000000000000000000000000000000;;		// Two existing scenarios we'll test against
0000000000000000000000000000000000000000;;		emptyIpPermission := ec2.IpPermission{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			IpRanges: []*ec2.IpRange{
0000000000000000000000000000000000000000;;				{CidrIp: aws.String("10.0.0.0/8")},
0000000000000000000000000000000000000000;;				{CidrIp: aws.String("192.168.1.0/24")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two already existing ranges and a new one
0000000000000000000000000000000000000000;;		existingIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			IpRanges: []*ec2.IpRange{
0000000000000000000000000000000000000000;;				{CidrIp: aws.String("10.0.0.0/8")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existingIpPermission2 := ec2.IpPermission{
0000000000000000000000000000000000000000;;			IpRanges: []*ec2.IpRange{
0000000000000000000000000000000000000000;;				{CidrIp: aws.String("192.168.1.0/24")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			IpRanges: []*ec2.IpRange{
0000000000000000000000000000000000000000;;				{CidrIp: aws.String("172.16.0.0/16")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists := ipPermissionExists(&emptyIpPermission, &emptyIpPermission, false)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Errorf("Should have been considered existing since we're comparing a range array against itself")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exists = ipPermissionExists(&oldIpPermission, &oldIpPermission, false)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Errorf("Should have been considered existing since we're comparing a range array against itself")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists = ipPermissionExists(&existingIpPermission, &oldIpPermission, false)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Errorf("Should have been considered existing since 10.* is in oldIpPermission's array of ranges")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exists = ipPermissionExists(&existingIpPermission2, &oldIpPermission, false)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			t.Errorf("Should have been considered existing since 192.* is in oldIpPermission2's array of ranges")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists = ipPermissionExists(&newIpPermission, &emptyIpPermission, false)
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("Should have not been considered existing since we compared against a missing array of ranges")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exists = ipPermissionExists(&newIpPermission, &oldIpPermission, false)
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("Should have not been considered existing since 172.* is not in oldIpPermission's array of ranges")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIpPermissionExistsHandlesMultipleGroupIdsWithUserIds(t *testing.T) {
0000000000000000000000000000000000000000;;		oldIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			UserIdGroupPairs: []*ec2.UserIdGroupPair{
0000000000000000000000000000000000000000;;				{GroupId: aws.String("firstGroupId"), UserId: aws.String("firstUserId")},
0000000000000000000000000000000000000000;;				{GroupId: aws.String("secondGroupId"), UserId: aws.String("secondUserId")},
0000000000000000000000000000000000000000;;				{GroupId: aws.String("thirdGroupId"), UserId: aws.String("thirdUserId")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			UserIdGroupPairs: []*ec2.UserIdGroupPair{
0000000000000000000000000000000000000000;;				{GroupId: aws.String("secondGroupId"), UserId: aws.String("secondUserId")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newIpPermission := ec2.IpPermission{
0000000000000000000000000000000000000000;;			UserIdGroupPairs: []*ec2.UserIdGroupPair{
0000000000000000000000000000000000000000;;				{GroupId: aws.String("secondGroupId"), UserId: aws.String("anotherUserId")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		equals := ipPermissionExists(&existingIpPermission, &oldIpPermission, true)
0000000000000000000000000000000000000000;;		if !equals {
0000000000000000000000000000000000000000;;			t.Errorf("Should have been considered equal since first is in the second array of groups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		equals = ipPermissionExists(&newIpPermission, &oldIpPermission, true)
0000000000000000000000000000000000000000;;		if equals {
0000000000000000000000000000000000000000;;			t.Errorf("Should have not been considered equal since first is not in the second array of groups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindInstanceByNodeNameExcludesTerminatedInstances(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("my-dns.internal")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tag ec2.Tag
0000000000000000000000000000000000000000;;		tag.Key = aws.String(TagNameKubernetesClusterLegacy)
0000000000000000000000000000000000000000;;		tag.Value = aws.String(TestClusterId)
0000000000000000000000000000000000000000;;		tags := []*ec2.Tag{&tag}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var runningInstance ec2.Instance
0000000000000000000000000000000000000000;;		runningInstance.InstanceId = aws.String("i-running")
0000000000000000000000000000000000000000;;		runningInstance.PrivateDnsName = aws.String(string(nodeName))
0000000000000000000000000000000000000000;;		runningInstance.State = &ec2.InstanceState{Code: aws.Int64(16), Name: aws.String("running")}
0000000000000000000000000000000000000000;;		runningInstance.Tags = tags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var terminatedInstance ec2.Instance
0000000000000000000000000000000000000000;;		terminatedInstance.InstanceId = aws.String("i-terminated")
0000000000000000000000000000000000000000;;		terminatedInstance.PrivateDnsName = aws.String(string(nodeName))
0000000000000000000000000000000000000000;;		terminatedInstance.State = &ec2.InstanceState{Code: aws.Int64(48), Name: aws.String("terminated")}
0000000000000000000000000000000000000000;;		terminatedInstance.Tags = tags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances := []*ec2.Instance{&terminatedInstance, &runningInstance}
0000000000000000000000000000000000000000;;		awsServices.instances = append(awsServices.instances, instances...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error building aws cloud: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instance, err := c.findInstanceByNodeName(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to find instance: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *instance.InstanceId != "i-running" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected running instance but got %v", *instance.InstanceId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetInstanceByNodeNameBatching(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, err := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		assert.Nil(t, err, "Error building aws cloud: %v", err)
0000000000000000000000000000000000000000;;		var tag ec2.Tag
0000000000000000000000000000000000000000;;		tag.Key = aws.String(TagNameKubernetesClusterPrefix + TestClusterId)
0000000000000000000000000000000000000000;;		tag.Value = aws.String("")
0000000000000000000000000000000000000000;;		tags := []*ec2.Tag{&tag}
0000000000000000000000000000000000000000;;		nodeNames := []string{}
0000000000000000000000000000000000000000;;		for i := 0; i < 200; i++ {
0000000000000000000000000000000000000000;;			nodeName := fmt.Sprintf("ip-171-20-42-%d.ec2.internal", i)
0000000000000000000000000000000000000000;;			nodeNames = append(nodeNames, nodeName)
0000000000000000000000000000000000000000;;			ec2Instance := &ec2.Instance{}
0000000000000000000000000000000000000000;;			instanceId := fmt.Sprintf("i-abcedf%d", i)
0000000000000000000000000000000000000000;;			ec2Instance.InstanceId = aws.String(instanceId)
0000000000000000000000000000000000000000;;			ec2Instance.PrivateDnsName = aws.String(nodeName)
0000000000000000000000000000000000000000;;			ec2Instance.State = &ec2.InstanceState{Code: aws.Int64(48), Name: aws.String("running")}
0000000000000000000000000000000000000000;;			ec2Instance.Tags = tags
0000000000000000000000000000000000000000;;			awsServices.instances = append(awsServices.instances, ec2Instance)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, err := c.getInstancesByNodeNames(nodeNames)
0000000000000000000000000000000000000000;;		assert.NotEmpty(t, instances)
0000000000000000000000000000000000000000;;		assert.Equal(t, 200, len(instances), "Expected 200 but got less")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetVolumeLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, err := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		assert.Nil(t, err, "Error building aws cloud: %v", err)
0000000000000000000000000000000000000000;;		volumeId := awsVolumeID("vol-VolumeId")
0000000000000000000000000000000000000000;;		expectedVolumeRequest := &ec2.DescribeVolumesInput{VolumeIds: []*string{volumeId.awsString()}}
0000000000000000000000000000000000000000;;		awsServices.ec2.On("DescribeVolumes", expectedVolumeRequest).Return([]*ec2.Volume{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				VolumeId:         volumeId.awsString(),
0000000000000000000000000000000000000000;;				AvailabilityZone: aws.String("us-east-1a"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels, err := c.GetVolumeLabels(KubernetesVolumeID("aws:///" + string(volumeId)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Nil(t, err, "Error creating Volume %v", err)
0000000000000000000000000000000000000000;;		assert.Equal(t, map[string]string{
0000000000000000000000000000000000000000;;			kubeletapis.LabelZoneFailureDomain: "us-east-1a",
0000000000000000000000000000000000000000;;			kubeletapis.LabelZoneRegion:        "us-east-1"}, labels)
0000000000000000000000000000000000000000;;		awsServices.ec2.AssertExpectations(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *FakeELB) expectDescribeLoadBalancers(loadBalancerName string) {
0000000000000000000000000000000000000000;;		self.On("DescribeLoadBalancers", &elb.DescribeLoadBalancersInput{LoadBalancerNames: []*string{aws.String(loadBalancerName)}}).Return(&elb.DescribeLoadBalancersOutput{
0000000000000000000000000000000000000000;;			LoadBalancerDescriptions: []*elb.LoadBalancerDescription{{}},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *FakeEC2) expectDescribeSecurityGroups(groupName, clusterID string) {
0000000000000000000000000000000000000000;;		tags := []*ec2.Tag{
0000000000000000000000000000000000000000;;			{Key: aws.String(TagNameKubernetesClusterLegacy), Value: aws.String(TestClusterId)},
0000000000000000000000000000000000000000;;			{Key: aws.String(fmt.Sprintf("%s%s", TagNameKubernetesClusterPrefix, TestClusterId)), Value: aws.String(ResourceLifecycleOwned)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		self.On("DescribeSecurityGroups", &ec2.DescribeSecurityGroupsInput{Filters: []*ec2.Filter{
0000000000000000000000000000000000000000;;			newEc2Filter("group-name", groupName),
0000000000000000000000000000000000000000;;			newEc2Filter("vpc-id", ""),
0000000000000000000000000000000000000000;;		}}).Return([]*ec2.SecurityGroup{{Tags: tags}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDescribeLoadBalancerOnDelete(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, _ := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		awsServices.elb.expectDescribeLoadBalancers("aid")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.EnsureLoadBalancerDeleted(TestClusterName, &v1.Service{ObjectMeta: metav1.ObjectMeta{Name: "myservice", UID: "id"}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDescribeLoadBalancerOnUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, _ := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		awsServices.elb.expectDescribeLoadBalancers("aid")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.UpdateLoadBalancer(TestClusterName, &v1.Service{ObjectMeta: metav1.ObjectMeta{Name: "myservice", UID: "id"}}, []*v1.Node{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDescribeLoadBalancerOnGet(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, _ := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		awsServices.elb.expectDescribeLoadBalancers("aid")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.GetLoadBalancer(TestClusterName, &v1.Service{ObjectMeta: metav1.ObjectMeta{Name: "myservice", UID: "id"}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDescribeLoadBalancerOnEnsure(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, _ := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;		awsServices.elb.expectDescribeLoadBalancers("aid")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.EnsureLoadBalancer(TestClusterName, &v1.Service{ObjectMeta: metav1.ObjectMeta{Name: "myservice", UID: "id"}}, []*v1.Node{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBuildListener(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lbPort                    int64
0000000000000000000000000000000000000000;;			portName                  string
0000000000000000000000000000000000000000;;			instancePort              int64
0000000000000000000000000000000000000000;;			backendProtocolAnnotation string
0000000000000000000000000000000000000000;;			certAnnotation            string
0000000000000000000000000000000000000000;;			sslPortAnnotation         string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectError      bool
0000000000000000000000000000000000000000;;			lbProtocol       string
0000000000000000000000000000000000000000;;			instanceProtocol string
0000000000000000000000000000000000000000;;			certID           string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"No cert or BE protocol annotation, passthrough",
0000000000000000000000000000000000000000;;				80, "", 7999, "", "", "",
0000000000000000000000000000000000000000;;				false, "tcp", "tcp", "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Cert annotation without BE protocol specified, SSL->TCP",
0000000000000000000000000000000000000000;;				80, "", 8000, "", "cert", "",
0000000000000000000000000000000000000000;;				false, "ssl", "tcp", "cert",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"BE protocol without cert annotation, passthrough",
0000000000000000000000000000000000000000;;				443, "", 8001, "https", "", "",
0000000000000000000000000000000000000000;;				false, "tcp", "tcp", "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Invalid cert annotation, bogus backend protocol",
0000000000000000000000000000000000000000;;				443, "", 8002, "bacon", "foo", "",
0000000000000000000000000000000000000000;;				true, "tcp", "tcp", "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Invalid cert annotation, protocol followed by equal sign",
0000000000000000000000000000000000000000;;				443, "", 8003, "http=", "=", "",
0000000000000000000000000000000000000000;;				true, "tcp", "tcp", "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"HTTPS->HTTPS",
0000000000000000000000000000000000000000;;				443, "", 8004, "https", "cert", "",
0000000000000000000000000000000000000000;;				false, "https", "https", "cert",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"HTTPS->HTTP",
0000000000000000000000000000000000000000;;				443, "", 8005, "http", "cert", "",
0000000000000000000000000000000000000000;;				false, "https", "http", "cert",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"SSL->SSL",
0000000000000000000000000000000000000000;;				443, "", 8006, "ssl", "cert", "",
0000000000000000000000000000000000000000;;				false, "ssl", "ssl", "cert",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"SSL->TCP",
0000000000000000000000000000000000000000;;				443, "", 8007, "tcp", "cert", "",
0000000000000000000000000000000000000000;;				false, "ssl", "tcp", "cert",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Port in whitelist",
0000000000000000000000000000000000000000;;				1234, "", 8008, "tcp", "cert", "1234,5678",
0000000000000000000000000000000000000000;;				false, "ssl", "tcp", "cert",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Port not in whitelist, passthrough",
0000000000000000000000000000000000000000;;				443, "", 8009, "tcp", "cert", "1234,5678",
0000000000000000000000000000000000000000;;				false, "tcp", "tcp", "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Named port in whitelist",
0000000000000000000000000000000000000000;;				1234, "bar", 8010, "tcp", "cert", "foo,bar",
0000000000000000000000000000000000000000;;				false, "ssl", "tcp", "cert",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Named port not in whitelist, passthrough",
0000000000000000000000000000000000000000;;				443, "", 8011, "tcp", "cert", "foo,bar",
0000000000000000000000000000000000000000;;				false, "tcp", "tcp", "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"HTTP->HTTP",
0000000000000000000000000000000000000000;;				80, "", 8012, "http", "", "",
0000000000000000000000000000000000000000;;				false, "http", "http", "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Logf("Running test case %s", test.name)
0000000000000000000000000000000000000000;;			annotations := make(map[string]string)
0000000000000000000000000000000000000000;;			if test.backendProtocolAnnotation != "" {
0000000000000000000000000000000000000000;;				annotations[ServiceAnnotationLoadBalancerBEProtocol] = test.backendProtocolAnnotation
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.certAnnotation != "" {
0000000000000000000000000000000000000000;;				annotations[ServiceAnnotationLoadBalancerCertificate] = test.certAnnotation
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ports := getPortSets(test.sslPortAnnotation)
0000000000000000000000000000000000000000;;			l, err := buildListener(v1.ServicePort{
0000000000000000000000000000000000000000;;				NodePort: int32(test.instancePort),
0000000000000000000000000000000000000000;;				Port:     int32(test.lbPort),
0000000000000000000000000000000000000000;;				Name:     test.portName,
0000000000000000000000000000000000000000;;				Protocol: v1.Protocol("tcp"),
0000000000000000000000000000000000000000;;			}, annotations, ports)
0000000000000000000000000000000000000000;;			if test.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("Should error for case %s", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Should succeed for case: %s, got %v", test.name, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					var cert *string
0000000000000000000000000000000000000000;;					if test.certID != "" {
0000000000000000000000000000000000000000;;						cert = &test.certID
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					expected := &elb.Listener{
0000000000000000000000000000000000000000;;						InstancePort:     &test.instancePort,
0000000000000000000000000000000000000000;;						InstanceProtocol: &test.instanceProtocol,
0000000000000000000000000000000000000000;;						LoadBalancerPort: &test.lbPort,
0000000000000000000000000000000000000000;;						Protocol:         &test.lbProtocol,
0000000000000000000000000000000000000000;;						SSLCertificateId: cert,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(l, expected) {
0000000000000000000000000000000000000000;;						t.Errorf("Incorrect listener (%v vs expected %v) for case: %s",
0000000000000000000000000000000000000000;;							l, expected, test.name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyProtocolEnabled(t *testing.T) {
0000000000000000000000000000000000000000;;		policies := sets.NewString(ProxyProtocolPolicyName, "FooBarFoo")
0000000000000000000000000000000000000000;;		fakeBackend := &elb.BackendServerDescription{
0000000000000000000000000000000000000000;;			InstancePort: aws.Int64(80),
0000000000000000000000000000000000000000;;			PolicyNames:  stringSetToPointers(policies),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := proxyProtocolEnabled(fakeBackend)
0000000000000000000000000000000000000000;;		assert.True(t, result, "expected to find %s in %s", ProxyProtocolPolicyName, policies)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policies = sets.NewString("FooBarFoo")
0000000000000000000000000000000000000000;;		fakeBackend = &elb.BackendServerDescription{
0000000000000000000000000000000000000000;;			InstancePort: aws.Int64(80),
0000000000000000000000000000000000000000;;			PolicyNames: []*string{
0000000000000000000000000000000000000000;;				aws.String("FooBarFoo"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result = proxyProtocolEnabled(fakeBackend)
0000000000000000000000000000000000000000;;		assert.False(t, result, "did not expect to find %s in %s", ProxyProtocolPolicyName, policies)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		policies = sets.NewString()
0000000000000000000000000000000000000000;;		fakeBackend = &elb.BackendServerDescription{
0000000000000000000000000000000000000000;;			InstancePort: aws.Int64(80),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result = proxyProtocolEnabled(fakeBackend)
0000000000000000000000000000000000000000;;		assert.False(t, result, "did not expect to find %s in %s", ProxyProtocolPolicyName, policies)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetLoadBalancerAdditionalTags(t *testing.T) {
0000000000000000000000000000000000000000;;		tagTests := []struct {
0000000000000000000000000000000000000000;;			Annotations map[string]string
0000000000000000000000000000000000000000;;			Tags        map[string]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerAdditionalTags: "Key=Val",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Tags: map[string]string{
0000000000000000000000000000000000000000;;					"Key": "Val",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerAdditionalTags: "Key1=Val1, Key2=Val2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Tags: map[string]string{
0000000000000000000000000000000000000000;;					"Key1": "Val1",
0000000000000000000000000000000000000000;;					"Key2": "Val2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerAdditionalTags: "Key1=, Key2=Val2",
0000000000000000000000000000000000000000;;					"anotherKey":                                "anotherValue",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Tags: map[string]string{
0000000000000000000000000000000000000000;;					"Key1": "",
0000000000000000000000000000000000000000;;					"Key2": "Val2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					"Nothing": "Key1=, Key2=Val2, Key3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Tags: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerAdditionalTags: "K=V K1=V2,Key1========, =====, ======Val, =Val, , 234,",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Tags: map[string]string{
0000000000000000000000000000000000000000;;					"K":    "V K1",
0000000000000000000000000000000000000000;;					"Key1": "",
0000000000000000000000000000000000000000;;					"234":  "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tagTest := range tagTests {
0000000000000000000000000000000000000000;;			result := getLoadBalancerAdditionalTags(tagTest.Annotations)
0000000000000000000000000000000000000000;;			for k, v := range result {
0000000000000000000000000000000000000000;;				if len(result) != len(tagTest.Tags) {
0000000000000000000000000000000000000000;;					t.Errorf("incorrect expected length: %v != %v", result, tagTest.Tags)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tagTest.Tags[k] != v {
0000000000000000000000000000000000000000;;					t.Errorf("%s != %s", tagTest.Tags[k], v)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLBExtraSecurityGroupsAnnotation(t *testing.T) {
0000000000000000000000000000000000000000;;		awsServices := NewFakeAWSServices()
0000000000000000000000000000000000000000;;		c, _ := newAWSCloud(strings.NewReader("[global]"), awsServices)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sg1 := "sg-000001"
0000000000000000000000000000000000000000;;		sg2 := "sg-000002"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			extraSGsAnnotation string
0000000000000000000000000000000000000000;;			expectedSGs        []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"No extra SG annotation", "", []string{}},
0000000000000000000000000000000000000000;;			{"Empty extra SGs specified", ", ,,", []string{}},
0000000000000000000000000000000000000000;;			{"SG specified", sg1, []string{sg1}},
0000000000000000000000000000000000000000;;			{"Multiple SGs specified", fmt.Sprintf("%s, %s", sg1, sg2), []string{sg1, sg2}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsServices.ec2.expectDescribeSecurityGroups("k8s-elb-aid", "cluster.test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Run(test.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				serviceName := types.NamespacedName{Namespace: "default", Name: "myservice"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sgList, err := c.buildELBSecurityGroupList(serviceName, "aid", test.extraSGsAnnotation)
0000000000000000000000000000000000000000;;				assert.NoError(t, err, "buildELBSecurityGroupList failed")
0000000000000000000000000000000000000000;;				extraSGs := sgList[1:]
0000000000000000000000000000000000000000;;				assert.True(t, sets.NewString(test.expectedSGs...).Equal(sets.NewString(extraSGs...)),
0000000000000000000000000000000000000000;;					"Security Groups expected=%q , returned=%q", test.expectedSGs, extraSGs)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
