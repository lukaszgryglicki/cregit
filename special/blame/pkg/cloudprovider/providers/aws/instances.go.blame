0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
41ea0d9ac2068c0aa95581cc08ce032472766355;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awsInstanceID represents the ID of the instance in the AWS API, e.g. i-12345678
0000000000000000000000000000000000000000;;	// The "traditional" format is "i-12345678"
0000000000000000000000000000000000000000;;	// A new longer format is also being introduced: "i-12345678abcdef01"
0000000000000000000000000000000000000000;;	// We should not assume anything about the length or format, though it seems
0000000000000000000000000000000000000000;;	// reasonable to assume that instances will continue to start with "i-".
0000000000000000000000000000000000000000;;	type awsInstanceID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i awsInstanceID) awsString() *string {
0000000000000000000000000000000000000000;;		return aws.String(string(i))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kubernetesInstanceID represents the id for an instance in the kubernetes API;
0000000000000000000000000000000000000000;;	// the following form
0000000000000000000000000000000000000000;;	//  * aws:///<zone>/<awsInstanceId>
0000000000000000000000000000000000000000;;	//  * aws:////<awsInstanceId>
0000000000000000000000000000000000000000;;	//  * <awsInstanceId>
0000000000000000000000000000000000000000;;	type kubernetesInstanceID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapToAWSInstanceID extracts the awsInstanceID from the kubernetesInstanceID
0000000000000000000000000000000000000000;;	func (name kubernetesInstanceID) mapToAWSInstanceID() (awsInstanceID, error) {
0000000000000000000000000000000000000000;;		s := string(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(s, "aws://") {
0000000000000000000000000000000000000000;;			// Assume a bare aws volume id (vol-1234...)
0000000000000000000000000000000000000000;;			// Build a URL with an empty host (AZ)
0000000000000000000000000000000000000000;;			s = "aws://" + "/" + "/" + s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		url, err := url.Parse(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Invalid instance name (%s): %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if url.Scheme != "aws" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Invalid scheme for AWS instance (%s)", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsID := ""
0000000000000000000000000000000000000000;;		tokens := strings.Split(strings.Trim(url.Path, "/"), "/")
0000000000000000000000000000000000000000;;		if len(tokens) == 1 {
0000000000000000000000000000000000000000;;			// instanceId
0000000000000000000000000000000000000000;;			awsID = tokens[0]
0000000000000000000000000000000000000000;;		} else if len(tokens) == 2 {
0000000000000000000000000000000000000000;;			// az/instanceId
0000000000000000000000000000000000000000;;			awsID = tokens[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We sanity check the resulting volume; the two known formats are
0000000000000000000000000000000000000000;;		// i-12345678 and i-12345678abcdef01
0000000000000000000000000000000000000000;;		// TODO: Regex match?
0000000000000000000000000000000000000000;;		if awsID == "" || strings.Contains(awsID, "/") || !strings.HasPrefix(awsID, "i-") {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Invalid format for AWS instance (%s)", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return awsInstanceID(awsID), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapToAWSInstanceID extracts the awsInstanceIDs from the Nodes, returning an error if a Node cannot be mapped
0000000000000000000000000000000000000000;;	func mapToAWSInstanceIDs(nodes []*v1.Node) ([]awsInstanceID, error) {
0000000000000000000000000000000000000000;;		var instanceIDs []awsInstanceID
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if node.Spec.ProviderID == "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("node %q did not have ProviderID set", node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			instanceID, err := kubernetesInstanceID(node.Spec.ProviderID).mapToAWSInstanceID()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to parse ProviderID %q for node %q", node.Spec.ProviderID, node.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			instanceIDs = append(instanceIDs, instanceID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return instanceIDs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapToAWSInstanceIDsTolerant extracts the awsInstanceIDs from the Nodes, skipping Nodes that cannot be mapped
0000000000000000000000000000000000000000;;	func mapToAWSInstanceIDsTolerant(nodes []*v1.Node) []awsInstanceID {
0000000000000000000000000000000000000000;;		var instanceIDs []awsInstanceID
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			if node.Spec.ProviderID == "" {
0000000000000000000000000000000000000000;;				glog.Warningf("node %q did not have ProviderID set", node.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			instanceID, err := kubernetesInstanceID(node.Spec.ProviderID).mapToAWSInstanceID()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("unable to parse ProviderID %q for node %q", node.Spec.ProviderID, node.Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			instanceIDs = append(instanceIDs, instanceID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return instanceIDs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the full information about this instance from the EC2 API
0000000000000000000000000000000000000000;;	func describeInstance(ec2Client EC2, instanceID awsInstanceID) (*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		request := &ec2.DescribeInstancesInput{
0000000000000000000000000000000000000000;;			InstanceIds: []*string{instanceID.awsString()},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, err := ec2Client.DescribeInstances(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(instances) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no instances found for instance: %s", instanceID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(instances) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple instances found for instance: %s", instanceID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return instances[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// instanceCache manages the cache of DescribeInstances
0000000000000000000000000000000000000000;;	type instanceCache struct {
0000000000000000000000000000000000000000;;		// TODO: Get rid of this field, send all calls through the instanceCache
0000000000000000000000000000000000000000;;		cloud *Cloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mutex    sync.Mutex
0000000000000000000000000000000000000000;;		snapshot *allInstancesSnapshot
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the full information about these instance from the EC2 API
0000000000000000000000000000000000000000;;	func (c *instanceCache) describeAllInstancesUncached() (*allInstancesSnapshot, error) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EC2 DescribeInstances - fetching all instances")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filters := []*ec2.Filter{}
0000000000000000000000000000000000000000;;		instances, err := c.cloud.describeInstances(filters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(map[awsInstanceID]*ec2.Instance)
0000000000000000000000000000000000000000;;		for _, i := range instances {
0000000000000000000000000000000000000000;;			id := awsInstanceID(aws.StringValue(i.InstanceId))
0000000000000000000000000000000000000000;;			m[id] = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		snapshot := &allInstancesSnapshot{now, m}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.mutex.Lock()
0000000000000000000000000000000000000000;;		defer c.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.snapshot != nil && snapshot.olderThan(c.snapshot) {
0000000000000000000000000000000000000000;;			// If this happens a lot, we could run this function in a mutex and only return one result
0000000000000000000000000000000000000000;;			glog.Infof("Not caching concurrent AWS DescribeInstances results")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.snapshot = snapshot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return snapshot, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cacheCriteria holds criteria that must hold to use a cached snapshot
0000000000000000000000000000000000000000;;	type cacheCriteria struct {
0000000000000000000000000000000000000000;;		// MaxAge indicates the maximum age of a cached snapshot we can accept.
0000000000000000000000000000000000000000;;		// If set to 0 (i.e. unset), cached values will not time out because of age.
0000000000000000000000000000000000000000;;		MaxAge time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HasInstances is a list of awsInstanceIDs that must be in a cached snapshot for it to be considered valid.
0000000000000000000000000000000000000000;;		// If an instance is not found in the cached snapshot, the snapshot be ignored and we will re-fetch.
0000000000000000000000000000000000000000;;		HasInstances []awsInstanceID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// describeAllInstancesCached returns all instances, using cached results if applicable
0000000000000000000000000000000000000000;;	func (c *instanceCache) describeAllInstancesCached(criteria cacheCriteria) (*allInstancesSnapshot, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		snapshot := c.getSnapshot()
0000000000000000000000000000000000000000;;		if snapshot != nil && !snapshot.MeetsCriteria(criteria) {
0000000000000000000000000000000000000000;;			snapshot = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if snapshot == nil {
0000000000000000000000000000000000000000;;			snapshot, err = c.describeAllInstancesUncached()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(6).Infof("EC2 DescribeInstances - using cached results")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return snapshot, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSnapshot returns a snapshot if one exists
0000000000000000000000000000000000000000;;	func (c *instanceCache) getSnapshot() *allInstancesSnapshot {
0000000000000000000000000000000000000000;;		c.mutex.Lock()
0000000000000000000000000000000000000000;;		defer c.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.snapshot
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// olderThan is a simple helper to encapsulate timestamp comparison
0000000000000000000000000000000000000000;;	func (s *allInstancesSnapshot) olderThan(other *allInstancesSnapshot) bool {
0000000000000000000000000000000000000000;;		// After() is technically broken by time changes until we have monotonic time
0000000000000000000000000000000000000000;;		return other.timestamp.After(s.timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MeetsCriteria returns true if the snapshot meets the criteria in cacheCriteria
0000000000000000000000000000000000000000;;	func (s *allInstancesSnapshot) MeetsCriteria(criteria cacheCriteria) bool {
0000000000000000000000000000000000000000;;		if criteria.MaxAge > 0 {
0000000000000000000000000000000000000000;;			// Sub() is technically broken by time changes until we have monotonic time
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			if now.Sub(s.timestamp) > criteria.MaxAge {
0000000000000000000000000000000000000000;;				glog.V(6).Infof("instanceCache snapshot cannot be used as is older than MaxAge=%s", criteria.MaxAge)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(criteria.HasInstances) != 0 {
0000000000000000000000000000000000000000;;			for _, id := range criteria.HasInstances {
0000000000000000000000000000000000000000;;				if nil == s.instances[id] {
0000000000000000000000000000000000000000;;					glog.V(6).Infof("instanceCache snapshot cannot be used as does not contain instance %s", id)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allInstancesSnapshot holds the results from querying for all instances,
0000000000000000000000000000000000000000;;	// along with the timestamp for cache-invalidation purposes
0000000000000000000000000000000000000000;;	type allInstancesSnapshot struct {
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;		instances map[awsInstanceID]*ec2.Instance
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindInstances returns the instances corresponding to the specified ids.  If an id is not found, it is ignored.
0000000000000000000000000000000000000000;;	func (s *allInstancesSnapshot) FindInstances(ids []awsInstanceID) map[awsInstanceID]*ec2.Instance {
0000000000000000000000000000000000000000;;		m := make(map[awsInstanceID]*ec2.Instance)
0000000000000000000000000000000000000000;;		for _, id := range ids {
0000000000000000000000000000000000000000;;			instance := s.instances[id]
0000000000000000000000000000000000000000;;			if instance != nil {
0000000000000000000000000000000000000000;;				m[id] = instance
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
