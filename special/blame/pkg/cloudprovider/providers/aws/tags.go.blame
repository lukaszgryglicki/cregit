0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
e95298f55dc89584a5908a239c3df6137f080976;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagNameKubernetesClusterPrefix is the tag name we use to differentiate multiple
0000000000000000000000000000000000000000;;	// logically independent clusters running in the same AZ.
0000000000000000000000000000000000000000;;	// The tag key = TagNameKubernetesClusterPrefix + clusterID
0000000000000000000000000000000000000000;;	// The tag value is an ownership value
0000000000000000000000000000000000000000;;	const TagNameKubernetesClusterPrefix = "kubernetes.io/cluster/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagNameKubernetesClusterLegacy is the legacy tag name we use to differentiate multiple
0000000000000000000000000000000000000000;;	// logically independent clusters running in the same AZ.  The problem with it was that it
0000000000000000000000000000000000000000;;	// did not allow shared resources.
0000000000000000000000000000000000000000;;	const TagNameKubernetesClusterLegacy = "KubernetesCluster"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceLifecycle string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ResourceLifecycleOwned is the value we use when tagging resources to indicate
0000000000000000000000000000000000000000;;		// that the resource is considered owned and managed by the cluster,
0000000000000000000000000000000000000000;;		// and in particular that the lifecycle is tied to the lifecycle of the cluster.
0000000000000000000000000000000000000000;;		ResourceLifecycleOwned = "owned"
0000000000000000000000000000000000000000;;		// ResourceLifecycleShared is the value we use when tagging resources to indicate
0000000000000000000000000000000000000000;;		// that the resource is shared between multiple clusters, and should not be destroyed
0000000000000000000000000000000000000000;;		// if the cluster is destroyed.
0000000000000000000000000000000000000000;;		ResourceLifecycleShared = "shared"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsTagging struct {
0000000000000000000000000000000000000000;;		// ClusterID is our cluster identifier: we tag AWS resources with this value,
0000000000000000000000000000000000000000;;		// and thus we can run two independent clusters in the same VPC or subnets.
0000000000000000000000000000000000000000;;		// This gives us similar functionality to GCE projects.
0000000000000000000000000000000000000000;;		ClusterID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// usesLegacyTags is true if we are using the legacy TagNameKubernetesClusterLegacy tags
0000000000000000000000000000000000000000;;		usesLegacyTags bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *awsTagging) init(legacyClusterID string, clusterID string) error {
0000000000000000000000000000000000000000;;		if legacyClusterID != "" {
0000000000000000000000000000000000000000;;			if clusterID != "" && legacyClusterID != clusterID {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ClusterID tags did not match: %q vs %q", clusterID, legacyClusterID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.usesLegacyTags = true
0000000000000000000000000000000000000000;;			clusterID = legacyClusterID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.ClusterID = clusterID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if clusterID != "" {
0000000000000000000000000000000000000000;;			glog.Infof("AWS cloud filtering on ClusterID: %v", clusterID)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Infof("AWS cloud - no clusterID filtering")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extracts a clusterID from the given tags, if one is present
0000000000000000000000000000000000000000;;	// If no clusterID is found, returns "", nil
0000000000000000000000000000000000000000;;	// If multiple (different) clusterIDs are found, returns an error
0000000000000000000000000000000000000000;;	func (t *awsTagging) initFromTags(tags []*ec2.Tag) error {
0000000000000000000000000000000000000000;;		legacyClusterID, newClusterID, err := findClusterIDs(tags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if legacyClusterID == "" && newClusterID == "" {
0000000000000000000000000000000000000000;;			glog.Errorf("Tag %q nor %q not found; Kubernetes may behave unexpectedly.", TagNameKubernetesClusterLegacy, TagNameKubernetesClusterPrefix+"...")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t.init(legacyClusterID, newClusterID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extracts the legacy & new cluster ids from the given tags, if they are present
0000000000000000000000000000000000000000;;	// If duplicate tags are found, returns an error
0000000000000000000000000000000000000000;;	func findClusterIDs(tags []*ec2.Tag) (string, string, error) {
0000000000000000000000000000000000000000;;		legacyClusterID := ""
0000000000000000000000000000000000000000;;		newClusterID := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tag := range tags {
0000000000000000000000000000000000000000;;			tagKey := aws.StringValue(tag.Key)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(tagKey, TagNameKubernetesClusterPrefix) {
0000000000000000000000000000000000000000;;				id := strings.TrimPrefix(tagKey, TagNameKubernetesClusterPrefix)
0000000000000000000000000000000000000000;;				if newClusterID != "" {
0000000000000000000000000000000000000000;;					return "", "", fmt.Errorf("Found multiple cluster tags with prefix %s (%q and %q)", TagNameKubernetesClusterPrefix, newClusterID, id)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newClusterID = id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tagKey == TagNameKubernetesClusterLegacy {
0000000000000000000000000000000000000000;;				id := aws.StringValue(tag.Value)
0000000000000000000000000000000000000000;;				if legacyClusterID != "" {
0000000000000000000000000000000000000000;;					return "", "", fmt.Errorf("Found multiple %s tags (%q and %q)", TagNameKubernetesClusterLegacy, legacyClusterID, id)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				legacyClusterID = id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return legacyClusterID, newClusterID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *awsTagging) clusterTagKey() string {
0000000000000000000000000000000000000000;;		return TagNameKubernetesClusterPrefix + t.ClusterID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *awsTagging) hasClusterTag(tags []*ec2.Tag) bool {
0000000000000000000000000000000000000000;;		// if the clusterID is not configured -- we consider all instances.
0000000000000000000000000000000000000000;;		if len(t.ClusterID) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterTagKey := t.clusterTagKey()
0000000000000000000000000000000000000000;;		for _, tag := range tags {
0000000000000000000000000000000000000000;;			tagKey := aws.StringValue(tag.Key)
0000000000000000000000000000000000000000;;			// For 1.6, we continue to recognize the legacy tags, for the 1.5 -> 1.6 upgrade
0000000000000000000000000000000000000000;;			if tagKey == TagNameKubernetesClusterLegacy {
0000000000000000000000000000000000000000;;				return aws.StringValue(tag.Value) == t.ClusterID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tagKey == clusterTagKey {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure that a resource has the correct tags
0000000000000000000000000000000000000000;;	// If it has no tags, we assume that this was a problem caused by an error in between creation and tagging,
0000000000000000000000000000000000000000;;	// and we add the tags.  If it has a different cluster's tags, that is an error.
0000000000000000000000000000000000000000;;	func (c *awsTagging) readRepairClusterTags(client EC2, resourceID string, lifecycle ResourceLifecycle, additionalTags map[string]string, observedTags []*ec2.Tag) error {
0000000000000000000000000000000000000000;;		actualTagMap := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, tag := range observedTags {
0000000000000000000000000000000000000000;;			actualTagMap[aws.StringValue(tag.Key)] = aws.StringValue(tag.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedTags := c.buildTags(lifecycle, additionalTags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addTags := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, expected := range expectedTags {
0000000000000000000000000000000000000000;;			actual := actualTagMap[k]
0000000000000000000000000000000000000000;;			if actual == expected {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual == "" {
0000000000000000000000000000000000000000;;				glog.Warningf("Resource %q was missing expected cluster tag %q.  Will add (with value %q)", resourceID, k, expected)
0000000000000000000000000000000000000000;;				addTags[k] = expected
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("resource %q has tag belonging to another cluster: %q=%q (expected %q)", resourceID, k, actual, expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(addTags) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.createTags(client, resourceID, lifecycle, addTags); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error adding missing tags to resource %q: %q", resourceID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createTags calls EC2 CreateTags, but adds retry-on-failure logic
0000000000000000000000000000000000000000;;	// We retry mainly because if we create an object, we cannot tag it until it is "fully created" (eventual consistency)
0000000000000000000000000000000000000000;;	// The error code varies though (depending on what we are tagging), so we simply retry on all errors
0000000000000000000000000000000000000000;;	func (t *awsTagging) createTags(client EC2, resourceID string, lifecycle ResourceLifecycle, additionalTags map[string]string) error {
0000000000000000000000000000000000000000;;		tags := t.buildTags(lifecycle, additionalTags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tags == nil || len(tags) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var awsTags []*ec2.Tag
0000000000000000000000000000000000000000;;		for k, v := range tags {
0000000000000000000000000000000000000000;;			tag := &ec2.Tag{
0000000000000000000000000000000000000000;;				Key:   aws.String(k),
0000000000000000000000000000000000000000;;				Value: aws.String(v),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			awsTags = append(awsTags, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: createTagInitialDelay,
0000000000000000000000000000000000000000;;			Factor:   createTagFactor,
0000000000000000000000000000000000000000;;			Steps:    createTagSteps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request := &ec2.CreateTagsInput{}
0000000000000000000000000000000000000000;;		request.Resources = []*string{&resourceID}
0000000000000000000000000000000000000000;;		request.Tags = awsTags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var lastErr error
0000000000000000000000000000000000000000;;		err := wait.ExponentialBackoff(backoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := client.CreateTags(request)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We could check that the error is retryable, but the error code changes based on what we are tagging
0000000000000000000000000000000000000000;;			// SecurityGroup: InvalidGroup.NotFound
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed to create tags; will retry.  Error was %q", err)
0000000000000000000000000000000000000000;;			lastErr = err
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			// return real CreateTags error instead of timeout
0000000000000000000000000000000000000000;;			err = lastErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add additional filters, to match on our tags
0000000000000000000000000000000000000000;;	// This lets us run multiple k8s clusters in a single EC2 AZ
0000000000000000000000000000000000000000;;	func (t *awsTagging) addFilters(filters []*ec2.Filter) []*ec2.Filter {
0000000000000000000000000000000000000000;;		// if there are no clusterID configured - no filtering by special tag names
0000000000000000000000000000000000000000;;		// should be applied to revert to legacy behaviour.
0000000000000000000000000000000000000000;;		if len(t.ClusterID) == 0 {
0000000000000000000000000000000000000000;;			if len(filters) == 0 {
0000000000000000000000000000000000000000;;				// We can't pass a zero-length Filters to AWS (it's an error)
0000000000000000000000000000000000000000;;				// So if we end up with no filters; just return nil
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return filters
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// For 1.6, we always recognize the legacy tag, for the 1.5 -> 1.6 upgrade
0000000000000000000000000000000000000000;;		// There are no "or" filters by key, so we look for both the legacy and new key, and then we have to post-filter
0000000000000000000000000000000000000000;;		f := newEc2Filter("tag-key", TagNameKubernetesClusterLegacy, t.clusterTagKey())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We can't pass a zero-length Filters to AWS (it's an error)
0000000000000000000000000000000000000000;;		// So if we end up with no filters; we need to return nil
0000000000000000000000000000000000000000;;		filters = append(filters, f)
0000000000000000000000000000000000000000;;		return filters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *awsTagging) buildTags(lifecycle ResourceLifecycle, additionalTags map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		tags := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range additionalTags {
0000000000000000000000000000000000000000;;			tags[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no clusterID is a sign of misconfigured cluster, but we can't be tagging the resources with empty
0000000000000000000000000000000000000000;;		// strings
0000000000000000000000000000000000000000;;		if len(t.ClusterID) == 0 {
0000000000000000000000000000000000000000;;			return tags
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We only create legacy tags if we are using legacy tags, i.e. if we have seen a legacy tag on our instance
0000000000000000000000000000000000000000;;		if t.usesLegacyTags {
0000000000000000000000000000000000000000;;			tags[TagNameKubernetesClusterLegacy] = t.ClusterID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tags[t.clusterTagKey()] = string(lifecycle)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tags
0000000000000000000000000000000000000000;;	}
