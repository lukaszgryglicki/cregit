0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
40c711234d42330d162d85195c4328ad2d85a4ac;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		decayIntervalSeconds = 20
0000000000000000000000000000000000000000;;		decayFraction        = 0.8
0000000000000000000000000000000000000000;;		maxDelay             = 60 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CrossRequestRetryDelay inserts delays before AWS calls, when we are observing RequestLimitExceeded errors
0000000000000000000000000000000000000000;;	// Note that we share a CrossRequestRetryDelay across multiple AWS requests; this is a process-wide back-off,
0000000000000000000000000000000000000000;;	// whereas the aws-sdk-go implements a per-request exponential backoff/retry
0000000000000000000000000000000000000000;;	type CrossRequestRetryDelay struct {
0000000000000000000000000000000000000000;;		backoff Backoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new CrossRequestRetryDelay
0000000000000000000000000000000000000000;;	func NewCrossRequestRetryDelay() *CrossRequestRetryDelay {
0000000000000000000000000000000000000000;;		c := &CrossRequestRetryDelay{}
0000000000000000000000000000000000000000;;		c.backoff.init(decayIntervalSeconds, decayFraction, maxDelay)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Added to the Sign chain; called before each request
0000000000000000000000000000000000000000;;	func (c *CrossRequestRetryDelay) BeforeSign(r *request.Request) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		delay := c.backoff.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;		if delay > 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("Inserting delay before AWS request (%s) to avoid RequestLimitExceeded: %s",
0000000000000000000000000000000000000000;;				describeRequest(r), delay.String())
0000000000000000000000000000000000000000;;			r.Config.SleepDelay(delay)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Avoid clock skew problems
0000000000000000000000000000000000000000;;			r.Time = now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a user-friendly string describing the request, for use in log messages
0000000000000000000000000000000000000000;;	func describeRequest(r *request.Request) string {
0000000000000000000000000000000000000000;;		service := r.ClientInfo.ServiceName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := "?"
0000000000000000000000000000000000000000;;		if r.Operation != nil {
0000000000000000000000000000000000000000;;			name = r.Operation.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return service + "::" + name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Added to the AfterRetry chain; called after any error
0000000000000000000000000000000000000000;;	func (c *CrossRequestRetryDelay) AfterRetry(r *request.Request) {
0000000000000000000000000000000000000000;;		if r.Error == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsError, ok := r.Error.(awserr.Error)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if awsError.Code() == "RequestLimitExceeded" {
0000000000000000000000000000000000000000;;			c.backoff.ReportError()
0000000000000000000000000000000000000000;;			glog.Warningf("Got RequestLimitExceeded error on AWS request (%s)",
0000000000000000000000000000000000000000;;				describeRequest(r))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Backoff manages a backoff that varies based on the recently observed failures
0000000000000000000000000000000000000000;;	type Backoff struct {
0000000000000000000000000000000000000000;;		decayIntervalSeconds int64
0000000000000000000000000000000000000000;;		decayFraction        float64
0000000000000000000000000000000000000000;;		maxDelay             time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mutex sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We count all requests & the number of requests which hit a
0000000000000000000000000000000000000000;;		// RequestLimit.  We only really care about 'recent' requests, so we
0000000000000000000000000000000000000000;;		// decay the counts exponentially to bias towards recent values.
0000000000000000000000000000000000000000;;		countErrorsRequestLimit float32
0000000000000000000000000000000000000000;;		countRequests           float32
0000000000000000000000000000000000000000;;		lastDecay               int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Backoff) init(decayIntervalSeconds int, decayFraction float64, maxDelay time.Duration) {
0000000000000000000000000000000000000000;;		b.lastDecay = time.Now().Unix()
0000000000000000000000000000000000000000;;		// Bias so that if the first request hits the limit we don't immediately apply the full delay
0000000000000000000000000000000000000000;;		b.countRequests = 4
0000000000000000000000000000000000000000;;		b.decayIntervalSeconds = int64(decayIntervalSeconds)
0000000000000000000000000000000000000000;;		b.decayFraction = decayFraction
0000000000000000000000000000000000000000;;		b.maxDelay = maxDelay
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Computes the delay required for a request, also updating internal state to count this request
0000000000000000000000000000000000000000;;	func (b *Backoff) ComputeDelayForRequest(now time.Time) time.Duration {
0000000000000000000000000000000000000000;;		b.mutex.Lock()
0000000000000000000000000000000000000000;;		defer b.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply exponential decay to the counters
0000000000000000000000000000000000000000;;		timeDeltaSeconds := now.Unix() - b.lastDecay
0000000000000000000000000000000000000000;;		if timeDeltaSeconds > b.decayIntervalSeconds {
0000000000000000000000000000000000000000;;			intervals := float64(timeDeltaSeconds) / float64(b.decayIntervalSeconds)
0000000000000000000000000000000000000000;;			decay := float32(math.Pow(b.decayFraction, intervals))
0000000000000000000000000000000000000000;;			b.countErrorsRequestLimit *= decay
0000000000000000000000000000000000000000;;			b.countRequests *= decay
0000000000000000000000000000000000000000;;			b.lastDecay = now.Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count this request
0000000000000000000000000000000000000000;;		b.countRequests += 1.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compute the failure rate
0000000000000000000000000000000000000000;;		errorFraction := float32(0.0)
0000000000000000000000000000000000000000;;		if b.countRequests > 0.5 {
0000000000000000000000000000000000000000;;			// Avoid tiny residuals & rounding errors
0000000000000000000000000000000000000000;;			errorFraction = b.countErrorsRequestLimit / b.countRequests
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore a low fraction of errors
0000000000000000000000000000000000000000;;		// This also allows them to time-out
0000000000000000000000000000000000000000;;		if errorFraction < 0.1 {
0000000000000000000000000000000000000000;;			return time.Duration(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delay by the max delay multiplied by the recent error rate
0000000000000000000000000000000000000000;;		// (i.e. we apply a linear delay function)
0000000000000000000000000000000000000000;;		// TODO: This is pretty arbitrary
0000000000000000000000000000000000000000;;		delay := time.Nanosecond * time.Duration(float32(b.maxDelay.Nanoseconds())*errorFraction)
0000000000000000000000000000000000000000;;		// Round down to the nearest second for sanity
0000000000000000000000000000000000000000;;		return time.Second * time.Duration(int(delay.Seconds()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Called when we observe a throttling error
0000000000000000000000000000000000000000;;	func (b *Backoff) ReportError() {
0000000000000000000000000000000000000000;;		b.mutex.Lock()
0000000000000000000000000000000000000000;;		defer b.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.countErrorsRequestLimit += 1.0
0000000000000000000000000000000000000000;;	}
