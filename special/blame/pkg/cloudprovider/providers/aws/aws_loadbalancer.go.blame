0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
728bc505472938f0cc77cfd53f998d9deaf246d2;pkg/cloudprovider/aws/aws_loadbalancer.go[pkg/cloudprovider/aws/aws_loadbalancer.go][pkg/cloudprovider/providers/aws/aws_loadbalancer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/elb"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ProxyProtocolPolicyName = "k8s-proxyprotocol-enabled"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLoadBalancerAdditionalTags converts the comma separated list of key-value
0000000000000000000000000000000000000000;;	// pairs in the ServiceAnnotationLoadBalancerAdditionalTags annotation and returns
0000000000000000000000000000000000000000;;	// it as a map.
0000000000000000000000000000000000000000;;	func getLoadBalancerAdditionalTags(annotations map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		additionalTags := make(map[string]string)
0000000000000000000000000000000000000000;;		if additionalTagsList, ok := annotations[ServiceAnnotationLoadBalancerAdditionalTags]; ok {
0000000000000000000000000000000000000000;;			additionalTagsList = strings.TrimSpace(additionalTagsList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Break up list of "Key1=Val,Key2=Val2"
0000000000000000000000000000000000000000;;			tagList := strings.Split(additionalTagsList, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Break up "Key=Val"
0000000000000000000000000000000000000000;;			for _, tagSet := range tagList {
0000000000000000000000000000000000000000;;				tag := strings.Split(strings.TrimSpace(tagSet), "=")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Accept "Key=val" or "Key=" or just "Key"
0000000000000000000000000000000000000000;;				if len(tag) >= 2 && len(tag[0]) != 0 {
0000000000000000000000000000000000000000;;					// There is a key and a value, so save it
0000000000000000000000000000000000000000;;					additionalTags[tag[0]] = tag[1]
0000000000000000000000000000000000000000;;				} else if len(tag) == 1 && len(tag[0]) != 0 {
0000000000000000000000000000000000000000;;					// Just "Key"
0000000000000000000000000000000000000000;;					additionalTags[tag[0]] = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return additionalTags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) ensureLoadBalancer(namespacedName types.NamespacedName, loadBalancerName string, listeners []*elb.Listener, subnetIDs []string, securityGroupIDs []string, internalELB, proxyProtocol bool, loadBalancerAttributes *elb.LoadBalancerAttributes, annotations map[string]string) (*elb.LoadBalancerDescription, error) {
0000000000000000000000000000000000000000;;		loadBalancer, err := c.describeLoadBalancer(loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirty := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if loadBalancer == nil {
0000000000000000000000000000000000000000;;			createRequest := &elb.CreateLoadBalancerInput{}
0000000000000000000000000000000000000000;;			createRequest.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createRequest.Listeners = listeners
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if internalELB {
0000000000000000000000000000000000000000;;				createRequest.Scheme = aws.String("internal")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We are supposed to specify one subnet per AZ.
0000000000000000000000000000000000000000;;			// TODO: What happens if we have more than one subnet per AZ?
0000000000000000000000000000000000000000;;			createRequest.Subnets = stringPointerArray(subnetIDs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createRequest.SecurityGroups = stringPointerArray(securityGroupIDs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get additional tags set by the user
0000000000000000000000000000000000000000;;			tags := getLoadBalancerAdditionalTags(annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add default tags
0000000000000000000000000000000000000000;;			tags[TagNameKubernetesService] = namespacedName.String()
0000000000000000000000000000000000000000;;			tags = c.tagging.buildTags(ResourceLifecycleOwned, tags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, v := range tags {
0000000000000000000000000000000000000000;;				createRequest.Tags = append(createRequest.Tags, &elb.Tag{
0000000000000000000000000000000000000000;;					Key: aws.String(k), Value: aws.String(v),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof("Creating load balancer for %v with name: %s", namespacedName, loadBalancerName)
0000000000000000000000000000000000000000;;			_, err := c.elb.CreateLoadBalancer(createRequest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if proxyProtocol {
0000000000000000000000000000000000000000;;				err = c.createProxyProtocolPolicy(loadBalancerName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, listener := range listeners {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("Adjusting AWS loadbalancer proxy protocol on node port %d. Setting to true", *listener.InstancePort)
0000000000000000000000000000000000000000;;					err := c.setBackendPolicies(loadBalancerName, *listener.InstancePort, []*string{aws.String(ProxyProtocolPolicyName)})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dirty = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: Sync internal vs non-internal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Sync subnets
0000000000000000000000000000000000000000;;				expected := sets.NewString(subnetIDs...)
0000000000000000000000000000000000000000;;				actual := stringSetFromPointers(loadBalancer.Subnets)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				additions := expected.Difference(actual)
0000000000000000000000000000000000000000;;				removals := actual.Difference(expected)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if removals.Len() != 0 {
0000000000000000000000000000000000000000;;					request := &elb.DetachLoadBalancerFromSubnetsInput{}
0000000000000000000000000000000000000000;;					request.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;					request.Subnets = stringSetToPointers(removals)
0000000000000000000000000000000000000000;;					glog.V(2).Info("Detaching load balancer from removed subnets")
0000000000000000000000000000000000000000;;					_, err := c.elb.DetachLoadBalancerFromSubnets(request)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("error detaching AWS loadbalancer from subnets: %q", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dirty = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if additions.Len() != 0 {
0000000000000000000000000000000000000000;;					request := &elb.AttachLoadBalancerToSubnetsInput{}
0000000000000000000000000000000000000000;;					request.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;					request.Subnets = stringSetToPointers(additions)
0000000000000000000000000000000000000000;;					glog.V(2).Info("Attaching load balancer to added subnets")
0000000000000000000000000000000000000000;;					_, err := c.elb.AttachLoadBalancerToSubnets(request)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("error attaching AWS loadbalancer to subnets: %q", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dirty = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Sync security groups
0000000000000000000000000000000000000000;;				expected := sets.NewString(securityGroupIDs...)
0000000000000000000000000000000000000000;;				actual := stringSetFromPointers(loadBalancer.SecurityGroups)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !expected.Equal(actual) {
0000000000000000000000000000000000000000;;					// This call just replaces the security groups, unlike e.g. subnets (!)
0000000000000000000000000000000000000000;;					request := &elb.ApplySecurityGroupsToLoadBalancerInput{}
0000000000000000000000000000000000000000;;					request.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;					request.SecurityGroups = stringPointerArray(securityGroupIDs)
0000000000000000000000000000000000000000;;					glog.V(2).Info("Applying updated security groups to load balancer")
0000000000000000000000000000000000000000;;					_, err := c.elb.ApplySecurityGroupsToLoadBalancer(request)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("error applying AWS loadbalancer security groups: %q", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dirty = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Sync listeners
0000000000000000000000000000000000000000;;				listenerDescriptions := loadBalancer.ListenerDescriptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				foundSet := make(map[int]bool)
0000000000000000000000000000000000000000;;				removals := []*int64{}
0000000000000000000000000000000000000000;;				for _, listenerDescription := range listenerDescriptions {
0000000000000000000000000000000000000000;;					actual := listenerDescription.Listener
0000000000000000000000000000000000000000;;					if actual == nil {
0000000000000000000000000000000000000000;;						glog.Warning("Ignoring empty listener in AWS loadbalancer: ", loadBalancerName)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					found := -1
0000000000000000000000000000000000000000;;					for i, expected := range listeners {
0000000000000000000000000000000000000000;;						if elbProtocolsAreEqual(actual.Protocol, expected.Protocol) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if elbProtocolsAreEqual(actual.InstanceProtocol, expected.InstanceProtocol) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if orZero(actual.InstancePort) != orZero(expected.InstancePort) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if orZero(actual.LoadBalancerPort) != orZero(expected.LoadBalancerPort) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if awsArnEquals(actual.SSLCertificateId, expected.SSLCertificateId) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						found = i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if found != -1 {
0000000000000000000000000000000000000000;;						foundSet[found] = true
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						removals = append(removals, actual.LoadBalancerPort)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				additions := []*elb.Listener{}
0000000000000000000000000000000000000000;;				for i := range listeners {
0000000000000000000000000000000000000000;;					if foundSet[i] {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					additions = append(additions, listeners[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(removals) != 0 {
0000000000000000000000000000000000000000;;					request := &elb.DeleteLoadBalancerListenersInput{}
0000000000000000000000000000000000000000;;					request.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;					request.LoadBalancerPorts = removals
0000000000000000000000000000000000000000;;					glog.V(2).Info("Deleting removed load balancer listeners")
0000000000000000000000000000000000000000;;					_, err := c.elb.DeleteLoadBalancerListeners(request)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("error deleting AWS loadbalancer listeners: %q", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dirty = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(additions) != 0 {
0000000000000000000000000000000000000000;;					request := &elb.CreateLoadBalancerListenersInput{}
0000000000000000000000000000000000000000;;					request.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;					request.Listeners = additions
0000000000000000000000000000000000000000;;					glog.V(2).Info("Creating added load balancer listeners")
0000000000000000000000000000000000000000;;					_, err := c.elb.CreateLoadBalancerListeners(request)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("error creating AWS loadbalancer listeners: %q", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dirty = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Sync proxy protocol state for new and existing listeners
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				proxyPolicies := make([]*string, 0)
0000000000000000000000000000000000000000;;				if proxyProtocol {
0000000000000000000000000000000000000000;;					// Ensure the backend policy exists
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// NOTE The documentation for the AWS API indicates we could get an HTTP 400
0000000000000000000000000000000000000000;;					// back if a policy of the same name already exists. However, the aws-sdk does not
0000000000000000000000000000000000000000;;					// seem to return an error to us in these cases. Therefore, this will issue an API
0000000000000000000000000000000000000000;;					// request every time.
0000000000000000000000000000000000000000;;					err := c.createProxyProtocolPolicy(loadBalancerName)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					proxyPolicies = append(proxyPolicies, aws.String(ProxyProtocolPolicyName))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				foundBackends := make(map[int64]bool)
0000000000000000000000000000000000000000;;				proxyProtocolBackends := make(map[int64]bool)
0000000000000000000000000000000000000000;;				for _, backendListener := range loadBalancer.BackendServerDescriptions {
0000000000000000000000000000000000000000;;					foundBackends[*backendListener.InstancePort] = false
0000000000000000000000000000000000000000;;					proxyProtocolBackends[*backendListener.InstancePort] = proxyProtocolEnabled(backendListener)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, listener := range listeners {
0000000000000000000000000000000000000000;;					setPolicy := false
0000000000000000000000000000000000000000;;					instancePort := *listener.InstancePort
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if currentState, ok := proxyProtocolBackends[instancePort]; !ok {
0000000000000000000000000000000000000000;;						// This is a new ELB backend so we only need to worry about
0000000000000000000000000000000000000000;;						// potentially adding a policy and not removing an
0000000000000000000000000000000000000000;;						// existing one
0000000000000000000000000000000000000000;;						setPolicy = proxyProtocol
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						foundBackends[instancePort] = true
0000000000000000000000000000000000000000;;						// This is an existing ELB backend so we need to determine
0000000000000000000000000000000000000000;;						// if the state changed
0000000000000000000000000000000000000000;;						setPolicy = (currentState != proxyProtocol)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if setPolicy {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Adjusting AWS loadbalancer proxy protocol on node port %d. Setting to %t", instancePort, proxyProtocol)
0000000000000000000000000000000000000000;;						err := c.setBackendPolicies(loadBalancerName, instancePort, proxyPolicies)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						dirty = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// We now need to figure out if any backend policies need removed
0000000000000000000000000000000000000000;;				// because these old policies will stick around even if there is no
0000000000000000000000000000000000000000;;				// corresponding listener anymore
0000000000000000000000000000000000000000;;				for instancePort, found := range foundBackends {
0000000000000000000000000000000000000000;;					if !found {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Adjusting AWS loadbalancer proxy protocol on node port %d. Setting to false", instancePort)
0000000000000000000000000000000000000000;;						err := c.setBackendPolicies(loadBalancerName, instancePort, []*string{})
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						dirty = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether the ELB was new or existing, sync attributes regardless. This accounts for things
0000000000000000000000000000000000000000;;		// that cannot be specified at the time of creation and can only be modified after the fact,
0000000000000000000000000000000000000000;;		// e.g. idle connection timeout.
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			describeAttributesRequest := &elb.DescribeLoadBalancerAttributesInput{}
0000000000000000000000000000000000000000;;			describeAttributesRequest.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;			describeAttributesOutput, err := c.elb.DescribeLoadBalancerAttributes(describeAttributesRequest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warning("Unable to retrieve load balancer attributes during attribute sync")
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			foundAttributes := &describeAttributesOutput.LoadBalancerAttributes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update attributes if they're dirty
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(loadBalancerAttributes, foundAttributes) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Updating load-balancer attributes for %q", loadBalancerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				modifyAttributesRequest := &elb.ModifyLoadBalancerAttributesInput{}
0000000000000000000000000000000000000000;;				modifyAttributesRequest.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;				modifyAttributesRequest.LoadBalancerAttributes = loadBalancerAttributes
0000000000000000000000000000000000000000;;				_, err = c.elb.ModifyLoadBalancerAttributes(modifyAttributesRequest)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Unable to update load balancer attributes during attribute sync: %q", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dirty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dirty {
0000000000000000000000000000000000000000;;			loadBalancer, err = c.describeLoadBalancer(loadBalancerName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warning("Unable to retrieve load balancer after creation/update")
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return loadBalancer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// elbProtocolsAreEqual checks if two ELB protocol strings are considered the same
0000000000000000000000000000000000000000;;	// Comparison is case insensitive
0000000000000000000000000000000000000000;;	func elbProtocolsAreEqual(l, r *string) bool {
0000000000000000000000000000000000000000;;		if l == nil || r == nil {
0000000000000000000000000000000000000000;;			return l == r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.EqualFold(aws.StringValue(l), aws.StringValue(r))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awsArnEquals checks if two ARN strings are considered the same
0000000000000000000000000000000000000000;;	// Comparison is case insensitive
0000000000000000000000000000000000000000;;	func awsArnEquals(l, r *string) bool {
0000000000000000000000000000000000000000;;		if l == nil || r == nil {
0000000000000000000000000000000000000000;;			return l == r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.EqualFold(aws.StringValue(l), aws.StringValue(r))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes sure that the health check for an ELB matches the configured health check node port
0000000000000000000000000000000000000000;;	func (c *Cloud) ensureLoadBalancerHealthCheck(loadBalancer *elb.LoadBalancerDescription, protocol string, port int32, path string) error {
0000000000000000000000000000000000000000;;		name := aws.StringValue(loadBalancer.LoadBalancerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual := loadBalancer.HealthCheck
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default AWS settings
0000000000000000000000000000000000000000;;		expectedHealthyThreshold := int64(2)
0000000000000000000000000000000000000000;;		expectedUnhealthyThreshold := int64(6)
0000000000000000000000000000000000000000;;		expectedTimeout := int64(5)
0000000000000000000000000000000000000000;;		expectedInterval := int64(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedTarget := protocol + ":" + strconv.FormatInt(int64(port), 10) + path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectedTarget == orEmpty(actual.Target) &&
0000000000000000000000000000000000000000;;			expectedHealthyThreshold == orZero(actual.HealthyThreshold) &&
0000000000000000000000000000000000000000;;			expectedUnhealthyThreshold == orZero(actual.UnhealthyThreshold) &&
0000000000000000000000000000000000000000;;			expectedTimeout == orZero(actual.Timeout) &&
0000000000000000000000000000000000000000;;			expectedInterval == orZero(actual.Interval) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Updating load-balancer health-check for %q", name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		healthCheck := &elb.HealthCheck{}
0000000000000000000000000000000000000000;;		healthCheck.HealthyThreshold = &expectedHealthyThreshold
0000000000000000000000000000000000000000;;		healthCheck.UnhealthyThreshold = &expectedUnhealthyThreshold
0000000000000000000000000000000000000000;;		healthCheck.Timeout = &expectedTimeout
0000000000000000000000000000000000000000;;		healthCheck.Interval = &expectedInterval
0000000000000000000000000000000000000000;;		healthCheck.Target = &expectedTarget
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &elb.ConfigureHealthCheckInput{}
0000000000000000000000000000000000000000;;		request.HealthCheck = healthCheck
0000000000000000000000000000000000000000;;		request.LoadBalancerName = loadBalancer.LoadBalancerName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := c.elb.ConfigureHealthCheck(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error configuring load-balancer health-check for %q: %q", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes sure that exactly the specified hosts are registered as instances with the load balancer
0000000000000000000000000000000000000000;;	func (c *Cloud) ensureLoadBalancerInstances(loadBalancerName string, lbInstances []*elb.Instance, instanceIDs map[awsInstanceID]*ec2.Instance) error {
0000000000000000000000000000000000000000;;		expected := sets.NewString()
0000000000000000000000000000000000000000;;		for id := range instanceIDs {
0000000000000000000000000000000000000000;;			expected.Insert(string(id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual := sets.NewString()
0000000000000000000000000000000000000000;;		for _, lbInstance := range lbInstances {
0000000000000000000000000000000000000000;;			actual.Insert(orEmpty(lbInstance.InstanceId))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		additions := expected.Difference(actual)
0000000000000000000000000000000000000000;;		removals := actual.Difference(expected)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addInstances := []*elb.Instance{}
0000000000000000000000000000000000000000;;		for _, instanceId := range additions.List() {
0000000000000000000000000000000000000000;;			addInstance := &elb.Instance{}
0000000000000000000000000000000000000000;;			addInstance.InstanceId = aws.String(instanceId)
0000000000000000000000000000000000000000;;			addInstances = append(addInstances, addInstance)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		removeInstances := []*elb.Instance{}
0000000000000000000000000000000000000000;;		for _, instanceId := range removals.List() {
0000000000000000000000000000000000000000;;			removeInstance := &elb.Instance{}
0000000000000000000000000000000000000000;;			removeInstance.InstanceId = aws.String(instanceId)
0000000000000000000000000000000000000000;;			removeInstances = append(removeInstances, removeInstance)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(addInstances) > 0 {
0000000000000000000000000000000000000000;;			registerRequest := &elb.RegisterInstancesWithLoadBalancerInput{}
0000000000000000000000000000000000000000;;			registerRequest.Instances = addInstances
0000000000000000000000000000000000000000;;			registerRequest.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;			_, err := c.elb.RegisterInstancesWithLoadBalancer(registerRequest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Instances added to load-balancer %s", loadBalancerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(removeInstances) > 0 {
0000000000000000000000000000000000000000;;			deregisterRequest := &elb.DeregisterInstancesFromLoadBalancerInput{}
0000000000000000000000000000000000000000;;			deregisterRequest.Instances = removeInstances
0000000000000000000000000000000000000000;;			deregisterRequest.LoadBalancerName = aws.String(loadBalancerName)
0000000000000000000000000000000000000000;;			_, err := c.elb.DeregisterInstancesFromLoadBalancer(deregisterRequest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Instances removed from load-balancer %s", loadBalancerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) createProxyProtocolPolicy(loadBalancerName string) error {
0000000000000000000000000000000000000000;;		request := &elb.CreateLoadBalancerPolicyInput{
0000000000000000000000000000000000000000;;			LoadBalancerName: aws.String(loadBalancerName),
0000000000000000000000000000000000000000;;			PolicyName:       aws.String(ProxyProtocolPolicyName),
0000000000000000000000000000000000000000;;			PolicyTypeName:   aws.String("ProxyProtocolPolicyType"),
0000000000000000000000000000000000000000;;			PolicyAttributes: []*elb.PolicyAttribute{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					AttributeName:  aws.String("ProxyProtocol"),
0000000000000000000000000000000000000000;;					AttributeValue: aws.String("true"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Creating proxy protocol policy on load balancer")
0000000000000000000000000000000000000000;;		_, err := c.elb.CreateLoadBalancerPolicy(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error creating proxy protocol policy on load balancer: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) setBackendPolicies(loadBalancerName string, instancePort int64, policies []*string) error {
0000000000000000000000000000000000000000;;		request := &elb.SetLoadBalancerPoliciesForBackendServerInput{
0000000000000000000000000000000000000000;;			InstancePort:     aws.Int64(instancePort),
0000000000000000000000000000000000000000;;			LoadBalancerName: aws.String(loadBalancerName),
0000000000000000000000000000000000000000;;			PolicyNames:      policies,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(policies) > 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Adding AWS loadbalancer backend policies on node port %d", instancePort)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Removing AWS loadbalancer backend policies on node port %d", instancePort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := c.elb.SetLoadBalancerPoliciesForBackendServer(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error adjusting AWS loadbalancer backend policies: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func proxyProtocolEnabled(backend *elb.BackendServerDescription) bool {
0000000000000000000000000000000000000000;;		for _, policy := range backend.PolicyNames {
0000000000000000000000000000000000000000;;			if aws.StringValue(policy) == ProxyProtocolPolicyName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findInstancesForELB gets the EC2 instances corresponding to the Nodes, for setting up an ELB
0000000000000000000000000000000000000000;;	// We ignore Nodes (with a log message) where the instanceid cannot be determined from the provider,
0000000000000000000000000000000000000000;;	// and we ignore instances which are not found
0000000000000000000000000000000000000000;;	func (c *Cloud) findInstancesForELB(nodes []*v1.Node) (map[awsInstanceID]*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		// Map to instance ids ignoring Nodes where we cannot find the id (but logging)
0000000000000000000000000000000000000000;;		instanceIDs := mapToAWSInstanceIDsTolerant(nodes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cacheCriteria := cacheCriteria{
0000000000000000000000000000000000000000;;			// MaxAge not required, because we only care about security groups, which should not change
0000000000000000000000000000000000000000;;			HasInstances: instanceIDs, // Refresh if any of the instance ids are missing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		snapshot, err := c.instanceCache.describeAllInstancesCached(cacheCriteria)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances := snapshot.FindInstances(instanceIDs)
0000000000000000000000000000000000000000;;		// We ignore instances that cannot be found
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return instances, nil
0000000000000000000000000000000000000000;;	}
