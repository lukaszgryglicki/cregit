0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
fa629169a4fa4015b02ab3f24ed723ca51e50a0d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IPPermissionSet map[string]*ec2.IpPermission
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewIPPermissionSet(items ...*ec2.IpPermission) IPPermissionSet {
0000000000000000000000000000000000000000;;		s := make(IPPermissionSet)
0000000000000000000000000000000000000000;;		s.Insert(items...)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ungroup splits permissions out into individual permissions
0000000000000000000000000000000000000000;;	// EC2 will combine permissions with the same port but different SourceRanges together, for example
0000000000000000000000000000000000000000;;	// We ungroup them so we can process them
0000000000000000000000000000000000000000;;	func (s IPPermissionSet) Ungroup() IPPermissionSet {
0000000000000000000000000000000000000000;;		l := []*ec2.IpPermission{}
0000000000000000000000000000000000000000;;		for _, p := range s.List() {
0000000000000000000000000000000000000000;;			if len(p.IpRanges) <= 1 {
0000000000000000000000000000000000000000;;				l = append(l, p)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ipRange := range p.IpRanges {
0000000000000000000000000000000000000000;;				c := &ec2.IpPermission{}
0000000000000000000000000000000000000000;;				*c = *p
0000000000000000000000000000000000000000;;				c.IpRanges = []*ec2.IpRange{ipRange}
0000000000000000000000000000000000000000;;				l = append(l, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l2 := []*ec2.IpPermission{}
0000000000000000000000000000000000000000;;		for _, p := range l {
0000000000000000000000000000000000000000;;			if len(p.UserIdGroupPairs) <= 1 {
0000000000000000000000000000000000000000;;				l2 = append(l2, p)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, u := range p.UserIdGroupPairs {
0000000000000000000000000000000000000000;;				c := &ec2.IpPermission{}
0000000000000000000000000000000000000000;;				*c = *p
0000000000000000000000000000000000000000;;				c.UserIdGroupPairs = []*ec2.UserIdGroupPair{u}
0000000000000000000000000000000000000000;;				l2 = append(l, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l3 := []*ec2.IpPermission{}
0000000000000000000000000000000000000000;;		for _, p := range l2 {
0000000000000000000000000000000000000000;;			if len(p.PrefixListIds) <= 1 {
0000000000000000000000000000000000000000;;				l3 = append(l3, p)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range p.PrefixListIds {
0000000000000000000000000000000000000000;;				c := &ec2.IpPermission{}
0000000000000000000000000000000000000000;;				*c = *p
0000000000000000000000000000000000000000;;				c.PrefixListIds = []*ec2.PrefixListId{v}
0000000000000000000000000000000000000000;;				l3 = append(l3, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewIPPermissionSet(l3...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert adds items to the set.
0000000000000000000000000000000000000000;;	func (s IPPermissionSet) Insert(items ...*ec2.IpPermission) {
0000000000000000000000000000000000000000;;		for _, p := range items {
0000000000000000000000000000000000000000;;			k := keyForIPPermission(p)
0000000000000000000000000000000000000000;;			s[k] = p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns the contents as a slice.  Order is not defined.
0000000000000000000000000000000000000000;;	func (s IPPermissionSet) List() []*ec2.IpPermission {
0000000000000000000000000000000000000000;;		res := make([]*ec2.IpPermission, 0, len(s))
0000000000000000000000000000000000000000;;		for _, v := range s {
0000000000000000000000000000000000000000;;			res = append(res, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSuperset returns true if and only if s1 is a superset of s2.
0000000000000000000000000000000000000000;;	func (s1 IPPermissionSet) IsSuperset(s2 IPPermissionSet) bool {
0000000000000000000000000000000000000000;;		for k := range s2 {
0000000000000000000000000000000000000000;;			_, found := s1[k]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if and only if s1 is equal (as a set) to s2.
0000000000000000000000000000000000000000;;	// Two sets are equal if their membership is identical.
0000000000000000000000000000000000000000;;	// (In practice, this means same elements, order doesn't matter)
0000000000000000000000000000000000000000;;	func (s1 IPPermissionSet) Equal(s2 IPPermissionSet) bool {
0000000000000000000000000000000000000000;;		return len(s1) == len(s2) && s1.IsSuperset(s2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Difference returns a set of objects that are not in s2
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2, a3}
0000000000000000000000000000000000000000;;	// s2 = {a1, a2, a4, a5}
0000000000000000000000000000000000000000;;	// s1.Difference(s2) = {a3}
0000000000000000000000000000000000000000;;	// s2.Difference(s1) = {a4, a5}
0000000000000000000000000000000000000000;;	func (s IPPermissionSet) Difference(s2 IPPermissionSet) IPPermissionSet {
0000000000000000000000000000000000000000;;		result := NewIPPermissionSet()
0000000000000000000000000000000000000000;;		for k, v := range s {
0000000000000000000000000000000000000000;;			_, found := s2[k]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				result[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the size of the set.
0000000000000000000000000000000000000000;;	func (s IPPermissionSet) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func keyForIPPermission(p *ec2.IpPermission) string {
0000000000000000000000000000000000000000;;		v, err := json.Marshal(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("error building JSON representation of ec2.IpPermission: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(v)
0000000000000000000000000000000000000000;;	}
