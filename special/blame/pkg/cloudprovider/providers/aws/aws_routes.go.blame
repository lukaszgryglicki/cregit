0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
10551bac8d348c084fc7429da390ca00c6cc3b9b;pkg/cloudprovider/aws/aws_routes.go[pkg/cloudprovider/aws/aws_routes.go][pkg/cloudprovider/providers/aws/aws_routes.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) findRouteTable(clusterName string) (*ec2.RouteTable, error) {
0000000000000000000000000000000000000000;;		// This should be unnecessary (we already filter on TagNameKubernetesCluster,
0000000000000000000000000000000000000000;;		// and something is broken if cluster name doesn't match, but anyway...
0000000000000000000000000000000000000000;;		// TODO: All clouds should be cluster-aware by default
0000000000000000000000000000000000000000;;		var tables []*ec2.RouteTable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.cfg.Global.RouteTableID != "" {
0000000000000000000000000000000000000000;;			request := &ec2.DescribeRouteTablesInput{Filters: []*ec2.Filter{newEc2Filter("route-table-id", c.cfg.Global.RouteTableID)}}
0000000000000000000000000000000000000000;;			response, err := c.ec2.DescribeRouteTables(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tables = response
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			request := &ec2.DescribeRouteTablesInput{Filters: c.tagging.addFilters(nil)}
0000000000000000000000000000000000000000;;			response, err := c.ec2.DescribeRouteTables(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, table := range response {
0000000000000000000000000000000000000000;;				if c.tagging.hasClusterTag(table.Tags) {
0000000000000000000000000000000000000000;;					tables = append(tables, table)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(tables) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to find route table for AWS cluster: %s", clusterName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(tables) != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("found multiple matching AWS route tables for AWS cluster: %s", clusterName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tables[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListRoutes implements Routes.ListRoutes
0000000000000000000000000000000000000000;;	// List all routes that match the filter
0000000000000000000000000000000000000000;;	func (c *Cloud) ListRoutes(clusterName string) ([]*cloudprovider.Route, error) {
0000000000000000000000000000000000000000;;		table, err := c.findRouteTable(clusterName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var routes []*cloudprovider.Route
0000000000000000000000000000000000000000;;		var instanceIDs []*string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range table.Routes {
0000000000000000000000000000000000000000;;			instanceID := orEmpty(r.InstanceId)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if instanceID == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			instanceIDs = append(instanceIDs, &instanceID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, err := c.getInstancesByIDs(instanceIDs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range table.Routes {
0000000000000000000000000000000000000000;;			destinationCIDR := aws.StringValue(r.DestinationCidrBlock)
0000000000000000000000000000000000000000;;			if destinationCIDR == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			route := &cloudprovider.Route{
0000000000000000000000000000000000000000;;				Name:            clusterName + "-" + destinationCIDR,
0000000000000000000000000000000000000000;;				DestinationCIDR: destinationCIDR,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Capture blackhole routes
0000000000000000000000000000000000000000;;			if aws.StringValue(r.State) == ec2.RouteStateBlackhole {
0000000000000000000000000000000000000000;;				route.Blackhole = true
0000000000000000000000000000000000000000;;				routes = append(routes, route)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Capture instance routes
0000000000000000000000000000000000000000;;			instanceID := aws.StringValue(r.InstanceId)
0000000000000000000000000000000000000000;;			if instanceID != "" {
0000000000000000000000000000000000000000;;				instance, found := instances[instanceID]
0000000000000000000000000000000000000000;;				if found {
0000000000000000000000000000000000000000;;					route.TargetNode = mapInstanceToNodeName(instance)
0000000000000000000000000000000000000000;;					routes = append(routes, route)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Warningf("unable to find instance ID %s in the list of instances being routed to", instanceID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return routes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sets the instance attribute "source-dest-check" to the specified value
0000000000000000000000000000000000000000;;	func (c *Cloud) configureInstanceSourceDestCheck(instanceID string, sourceDestCheck bool) error {
0000000000000000000000000000000000000000;;		request := &ec2.ModifyInstanceAttributeInput{}
0000000000000000000000000000000000000000;;		request.InstanceId = aws.String(instanceID)
0000000000000000000000000000000000000000;;		request.SourceDestCheck = &ec2.AttributeBooleanValue{Value: aws.Bool(sourceDestCheck)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := c.ec2.ModifyInstanceAttribute(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error configuring source-dest-check on instance %s: %q", instanceID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateRoute implements Routes.CreateRoute
0000000000000000000000000000000000000000;;	// Create the described route
0000000000000000000000000000000000000000;;	func (c *Cloud) CreateRoute(clusterName string, nameHint string, route *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		instance, err := c.getInstanceByNodeName(route.TargetNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In addition to configuring the route itself, we also need to configure the instance to accept that traffic
0000000000000000000000000000000000000000;;		// On AWS, this requires turning source-dest checks off
0000000000000000000000000000000000000000;;		err = c.configureInstanceSourceDestCheck(orEmpty(instance.InstanceId), false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table, err := c.findRouteTable(clusterName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var deleteRoute *ec2.Route
0000000000000000000000000000000000000000;;		for _, r := range table.Routes {
0000000000000000000000000000000000000000;;			destinationCIDR := aws.StringValue(r.DestinationCidrBlock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if destinationCIDR != route.DestinationCIDR {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if aws.StringValue(r.State) == ec2.RouteStateBlackhole {
0000000000000000000000000000000000000000;;				deleteRoute = r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if deleteRoute != nil {
0000000000000000000000000000000000000000;;			glog.Infof("deleting blackholed route: %s", aws.StringValue(deleteRoute.DestinationCidrBlock))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := &ec2.DeleteRouteInput{}
0000000000000000000000000000000000000000;;			request.DestinationCidrBlock = deleteRoute.DestinationCidrBlock
0000000000000000000000000000000000000000;;			request.RouteTableId = table.RouteTableId
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = c.ec2.DeleteRoute(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error deleting blackholed AWS route (%s): %q", aws.StringValue(deleteRoute.DestinationCidrBlock), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &ec2.CreateRouteInput{}
0000000000000000000000000000000000000000;;		// TODO: use ClientToken for idempotency?
0000000000000000000000000000000000000000;;		request.DestinationCidrBlock = aws.String(route.DestinationCIDR)
0000000000000000000000000000000000000000;;		request.InstanceId = instance.InstanceId
0000000000000000000000000000000000000000;;		request.RouteTableId = table.RouteTableId
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = c.ec2.CreateRoute(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error creating AWS route (%s): %q", route.DestinationCIDR, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteRoute implements Routes.DeleteRoute
0000000000000000000000000000000000000000;;	// Delete the specified route
0000000000000000000000000000000000000000;;	func (c *Cloud) DeleteRoute(clusterName string, route *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		table, err := c.findRouteTable(clusterName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &ec2.DeleteRouteInput{}
0000000000000000000000000000000000000000;;		request.DestinationCidrBlock = aws.String(route.DestinationCIDR)
0000000000000000000000000000000000000000;;		request.RouteTableId = table.RouteTableId
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = c.ec2.DeleteRoute(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error deleting AWS route (%s): %q", route.DestinationCIDR, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
