0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
40c711234d42330d162d85195c4328ad2d85a4ac;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// There follows a group of tests for the backoff logic.  There's nothing
0000000000000000000000000000000000000000;;	// particularly special about the values chosen: if we tweak the values in the
0000000000000000000000000000000000000000;;	// backoff logic then we might well have to update the tests.  However the key
0000000000000000000000000000000000000000;;	// behavioural elements should remain (e.g. no errors => no backoff), and these
0000000000000000000000000000000000000000;;	// are each tested by one of the tests below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test that we don't apply any delays when there are no errors
0000000000000000000000000000000000000000;;	func TestBackoffNoErrors(t *testing.T) {
0000000000000000000000000000000000000000;;		b := &Backoff{}
0000000000000000000000000000000000000000;;		b.init(decayIntervalSeconds, decayFraction, maxDelay)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			d := b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			if d.Nanoseconds() != 0 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected delay during no-error case")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			now = now.Add(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test that we always apply a delay when there are errors, and also that we
0000000000000000000000000000000000000000;;	// don't "flap" - that our own delay doesn't cause us to oscillate between
0000000000000000000000000000000000000000;;	// delay and no-delay.
0000000000000000000000000000000000000000;;	func TestBackoffAllErrors(t *testing.T) {
0000000000000000000000000000000000000000;;		b := &Backoff{}
0000000000000000000000000000000000000000;;		b.init(decayIntervalSeconds, decayFraction, maxDelay)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		// Warm up
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			_ = b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			b.ReportError()
0000000000000000000000000000000000000000;;			now = now.Add(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			d := b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			b.ReportError()
0000000000000000000000000000000000000000;;			if d.Seconds() < 5 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected short-delay during all-error case: %v", d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("delay @%d %v", i, d)
0000000000000000000000000000000000000000;;			now = now.Add(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test that we do come close to our max delay, when we see all errors at 1
0000000000000000000000000000000000000000;;	// second intervals (this simulates multiple concurrent requests, because we
0000000000000000000000000000000000000000;;	// don't wait for delay in between requests)
0000000000000000000000000000000000000000;;	func TestBackoffHitsMax(t *testing.T) {
0000000000000000000000000000000000000000;;		b := &Backoff{}
0000000000000000000000000000000000000000;;		b.init(decayIntervalSeconds, decayFraction, maxDelay)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			_ = b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			b.ReportError()
0000000000000000000000000000000000000000;;			now = now.Add(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			d := b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			b.ReportError()
0000000000000000000000000000000000000000;;			if float32(d.Nanoseconds()) < (float32(maxDelay.Nanoseconds()) * 0.95) {
0000000000000000000000000000000000000000;;				t.Fatalf("expected delay to be >= 95 percent of max delay, was %v", d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("delay @%d %v", i, d)
0000000000000000000000000000000000000000;;			now = now.Add(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test that after a phase of errors, we eventually stop applying a delay once there are
0000000000000000000000000000000000000000;;	// no more errors.
0000000000000000000000000000000000000000;;	func TestBackoffRecovers(t *testing.T) {
0000000000000000000000000000000000000000;;		b := &Backoff{}
0000000000000000000000000000000000000000;;		b.init(decayIntervalSeconds, decayFraction, maxDelay)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Phase of all-errors
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			_ = b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			b.ReportError()
0000000000000000000000000000000000000000;;			now = now.Add(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			d := b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			b.ReportError()
0000000000000000000000000000000000000000;;			if d.Seconds() < 5 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected short-delay during all-error phase: %v", d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("error phase delay @%d %v", i, d)
0000000000000000000000000000000000000000;;			now = now.Add(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Phase of no errors
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			_ = b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			now = now.Add(3 * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			d := b.ComputeDelayForRequest(now)
0000000000000000000000000000000000000000;;			if d.Seconds() != 0 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected delay during error recovery phase: %v", d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("no-error phase delay @%d %v", i, d)
0000000000000000000000000000000000000000;;			now = now.Add(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
