0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
5fa3cbce3551017455f31b035f00973f44ce8a0f;pkg/cloudprovider/aws/aws.go[pkg/cloudprovider/aws/aws.go][pkg/cloudprovider/providers/aws/aws.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gcfg "gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/credentials"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/credentials/ec2rolecreds"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/ec2metadata"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/session"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/autoscaling"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/ec2"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/elb"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName is the name of this cloud provider.
0000000000000000000000000000000000000000;;	const ProviderName = "aws"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagNameKubernetesService is the tag name we use to differentiate multiple
0000000000000000000000000000000000000000;;	// services. Used currently for ELBs only.
0000000000000000000000000000000000000000;;	const TagNameKubernetesService = "kubernetes.io/service-name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagNameSubnetInternalELB is the tag name used on a subnet to designate that
0000000000000000000000000000000000000000;;	// it should be used for internal ELBs
0000000000000000000000000000000000000000;;	const TagNameSubnetInternalELB = "kubernetes.io/role/internal-elb"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagNameSubnetPublicELB is the tag name used on a subnet to designate that
0000000000000000000000000000000000000000;;	// it should be used for internet ELBs
0000000000000000000000000000000000000000;;	const TagNameSubnetPublicELB = "kubernetes.io/role/elb"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerInternal is the annotation used on the service
0000000000000000000000000000000000000000;;	// to indicate that we want an internal ELB.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerInternal = "service.beta.kubernetes.io/aws-load-balancer-internal"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerProxyProtocol is the annotation used on the
0000000000000000000000000000000000000000;;	// service to enable the proxy protocol on an ELB. Right now we only accept the
0000000000000000000000000000000000000000;;	// value "*" which means enable the proxy protocol on all ELB backends. In the
0000000000000000000000000000000000000000;;	// future we could adjust this to allow setting the proxy protocol only on
0000000000000000000000000000000000000000;;	// certain backends.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerProxyProtocol = "service.beta.kubernetes.io/aws-load-balancer-proxy-protocol"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerAccessLogEmitInterval is the annotation used to
0000000000000000000000000000000000000000;;	// specify access log emit interval.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerAccessLogEmitInterval = "service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerAccessLogEnabled is the annotation used on the
0000000000000000000000000000000000000000;;	// service to enable or disable access logs.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerAccessLogEnabled = "service.beta.kubernetes.io/aws-load-balancer-access-log-enabled"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerAccessLogS3BucketName is the annotation used to
0000000000000000000000000000000000000000;;	// specify access log s3 bucket name.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerAccessLogS3BucketName = "service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerAccessLogS3BucketPrefix is the annotation used
0000000000000000000000000000000000000000;;	// to specify access log s3 bucket prefix.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerAccessLogS3BucketPrefix = "service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerConnectionDrainingEnabled is the annnotation
0000000000000000000000000000000000000000;;	// used on the service to enable or disable connection draining.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerConnectionDrainingEnabled = "service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerConnectionDrainingTimeout is the annotation
0000000000000000000000000000000000000000;;	// used on the service to specify a connection draining timeout.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerConnectionDrainingTimeout = "service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerConnectionIdleTimeout is the annotation used
0000000000000000000000000000000000000000;;	// on the service to specify the idle connection timeout.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerConnectionIdleTimeout = "service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerCrossZoneLoadBalancingEnabled is the annotation
0000000000000000000000000000000000000000;;	// used on the service to enable or disable cross-zone load balancing.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerCrossZoneLoadBalancingEnabled = "service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerExtraSecurityGroups is the annotation used
0000000000000000000000000000000000000000;;	// one the service to specify additional security groups to be added to ELB created
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerExtraSecurityGroups = "service.beta.kubernetes.io/aws-load-balancer-extra-security-groups"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerCertificate is the annotation used on the
0000000000000000000000000000000000000000;;	// service to request a secure listener. Value is a valid certificate ARN.
0000000000000000000000000000000000000000;;	// For more, see http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-listener-config.html
0000000000000000000000000000000000000000;;	// CertARN is an IAM or CM certificate ARN, e.g. arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerCertificate = "service.beta.kubernetes.io/aws-load-balancer-ssl-cert"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerSSLPorts is the annotation used on the service
0000000000000000000000000000000000000000;;	// to specify a comma-separated list of ports that will use SSL/HTTPS
0000000000000000000000000000000000000000;;	// listeners. Defaults to '*' (all).
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerSSLPorts = "service.beta.kubernetes.io/aws-load-balancer-ssl-ports"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerBEProtocol is the annotation used on the service
0000000000000000000000000000000000000000;;	// to specify the protocol spoken by the backend (pod) behind a listener.
0000000000000000000000000000000000000000;;	// If `http` (default) or `https`, an HTTPS listener that terminates the
0000000000000000000000000000000000000000;;	//  connection and parses headers is created.
0000000000000000000000000000000000000000;;	// If set to `ssl` or `tcp`, a "raw" SSL listener is used.
0000000000000000000000000000000000000000;;	// If set to `http` and `aws-load-balancer-ssl-cert` is not used then
0000000000000000000000000000000000000000;;	// a HTTP listener is used.
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerBEProtocol = "service.beta.kubernetes.io/aws-load-balancer-backend-protocol"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAnnotationLoadBalancerAdditionalTags is the annotation used on the service
0000000000000000000000000000000000000000;;	// to specify a comma-separated list of key-value pairs which will be recorded as
0000000000000000000000000000000000000000;;	// additional tags in the ELB.
0000000000000000000000000000000000000000;;	// For example: "Key1=Val1,Key2=Val2,KeyNoVal1=,KeyNoVal2"
0000000000000000000000000000000000000000;;	const ServiceAnnotationLoadBalancerAdditionalTags = "service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// volumeAttachmentConsecutiveErrorLimit is the number of consecutive errors we will ignore when waiting for a volume to attach/detach
0000000000000000000000000000000000000000;;		volumeAttachmentStatusConsecutiveErrorLimit = 10
0000000000000000000000000000000000000000;;		// volumeAttachmentStatus* is configuration of exponential backoff for
0000000000000000000000000000000000000000;;		// waiting for attach/detach operation to complete. Starting with 10
0000000000000000000000000000000000000000;;		// seconds, multiplying by 1.2 with each step and taking 21 steps at maximum
0000000000000000000000000000000000000000;;		// it will time out after 31.11 minutes, which roughly corresponds to GCE
0000000000000000000000000000000000000000;;		// timeout (30 minutes).
0000000000000000000000000000000000000000;;		volumeAttachmentStatusInitialDelay = 10 * time.Second
0000000000000000000000000000000000000000;;		volumeAttachmentStatusFactor       = 1.2
0000000000000000000000000000000000000000;;		volumeAttachmentStatusSteps        = 21
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// createTag* is configuration of exponential backoff for CreateTag call. We
0000000000000000000000000000000000000000;;		// retry mainly because if we create an object, we cannot tag it until it is
0000000000000000000000000000000000000000;;		// "fully created" (eventual consistency). Starting with 1 second, doubling
0000000000000000000000000000000000000000;;		// it every step and taking 9 steps results in 255 second total waiting
0000000000000000000000000000000000000000;;		// time.
0000000000000000000000000000000000000000;;		createTagInitialDelay = 1 * time.Second
0000000000000000000000000000000000000000;;		createTagFactor       = 2.0
0000000000000000000000000000000000000000;;		createTagSteps        = 9
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of node names that can be added to a filter. The AWS limit is 200
0000000000000000000000000000000000000000;;		// but we are using a lower limit on purpose
0000000000000000000000000000000000000000;;		filterNodeLimit = 150
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awsTagNameMasterRoles is a set of well-known AWS tag names that indicate the instance is a master
0000000000000000000000000000000000000000;;	// The major consequence is that it is then not considered for AWS zone discovery for dynamic volume creation.
0000000000000000000000000000000000000000;;	var awsTagNameMasterRoles = sets.NewString("kubernetes.io/role/master", "k8s.io/role/master")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Maps from backend protocol to ELB protocol
0000000000000000000000000000000000000000;;	var backendProtocolMapping = map[string]string{
0000000000000000000000000000000000000000;;		"https": "https",
0000000000000000000000000000000000000000;;		"http":  "https",
0000000000000000000000000000000000000000;;		"ssl":   "ssl",
0000000000000000000000000000000000000000;;		"tcp":   "ssl",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxReadThenCreateRetries sets the maximum number of attempts we will make when
0000000000000000000000000000000000000000;;	// we read to see if something exists and then try to create it if we didn't find it.
0000000000000000000000000000000000000000;;	// This can fail once in a consistent system if done in parallel
0000000000000000000000000000000000000000;;	// In an eventually consistent system, it could fail unboundedly
0000000000000000000000000000000000000000;;	const MaxReadThenCreateRetries = 30
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultVolumeType specifies which storage to use for newly created Volumes
0000000000000000000000000000000000000000;;	// TODO: Remove when user/admin can configure volume types and thus we don't
0000000000000000000000000000000000000000;;	// need hardcoded defaults.
0000000000000000000000000000000000000000;;	const DefaultVolumeType = "gp2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultMaxEBSVolumes is the limit for volumes attached to an instance.
0000000000000000000000000000000000000000;;	// Amazon recommends no more than 40; the system root volume uses at least one.
0000000000000000000000000000000000000000;;	// See http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/volume_limits.html#linux-specific-volume-limits
0000000000000000000000000000000000000000;;	const DefaultMaxEBSVolumes = 39
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used to call RecognizeWellKnownRegions just once
0000000000000000000000000000000000000000;;	var once sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Services is an abstraction over AWS, to allow mocking/other implementations
0000000000000000000000000000000000000000;;	type Services interface {
0000000000000000000000000000000000000000;;		Compute(region string) (EC2, error)
0000000000000000000000000000000000000000;;		LoadBalancing(region string) (ELB, error)
0000000000000000000000000000000000000000;;		Autoscaling(region string) (ASG, error)
0000000000000000000000000000000000000000;;		Metadata() (EC2Metadata, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EC2 is an abstraction over AWS', to allow mocking/other implementations
0000000000000000000000000000000000000000;;	// Note that the DescribeX functions return a list, so callers don't need to deal with paging
0000000000000000000000000000000000000000;;	// TODO: Should we rename this to AWS (EBS & ELB are not technically part of EC2)
0000000000000000000000000000000000000000;;	type EC2 interface {
0000000000000000000000000000000000000000;;		// Query EC2 for instances matching the filter
0000000000000000000000000000000000000000;;		DescribeInstances(request *ec2.DescribeInstancesInput) ([]*ec2.Instance, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attach a volume to an instance
0000000000000000000000000000000000000000;;		AttachVolume(*ec2.AttachVolumeInput) (*ec2.VolumeAttachment, error)
0000000000000000000000000000000000000000;;		// Detach a volume from an instance it is attached to
0000000000000000000000000000000000000000;;		DetachVolume(request *ec2.DetachVolumeInput) (resp *ec2.VolumeAttachment, err error)
0000000000000000000000000000000000000000;;		// Lists volumes
0000000000000000000000000000000000000000;;		DescribeVolumes(request *ec2.DescribeVolumesInput) ([]*ec2.Volume, error)
0000000000000000000000000000000000000000;;		// Create an EBS volume
0000000000000000000000000000000000000000;;		CreateVolume(request *ec2.CreateVolumeInput) (resp *ec2.Volume, err error)
0000000000000000000000000000000000000000;;		// Delete an EBS volume
0000000000000000000000000000000000000000;;		DeleteVolume(*ec2.DeleteVolumeInput) (*ec2.DeleteVolumeOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DescribeSecurityGroups(request *ec2.DescribeSecurityGroupsInput) ([]*ec2.SecurityGroup, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CreateSecurityGroup(*ec2.CreateSecurityGroupInput) (*ec2.CreateSecurityGroupOutput, error)
0000000000000000000000000000000000000000;;		DeleteSecurityGroup(request *ec2.DeleteSecurityGroupInput) (*ec2.DeleteSecurityGroupOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AuthorizeSecurityGroupIngress(*ec2.AuthorizeSecurityGroupIngressInput) (*ec2.AuthorizeSecurityGroupIngressOutput, error)
0000000000000000000000000000000000000000;;		RevokeSecurityGroupIngress(*ec2.RevokeSecurityGroupIngressInput) (*ec2.RevokeSecurityGroupIngressOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DescribeSubnets(*ec2.DescribeSubnetsInput) ([]*ec2.Subnet, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CreateTags(*ec2.CreateTagsInput) (*ec2.CreateTagsOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DescribeRouteTables(request *ec2.DescribeRouteTablesInput) ([]*ec2.RouteTable, error)
0000000000000000000000000000000000000000;;		CreateRoute(request *ec2.CreateRouteInput) (*ec2.CreateRouteOutput, error)
0000000000000000000000000000000000000000;;		DeleteRoute(request *ec2.DeleteRouteInput) (*ec2.DeleteRouteOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ModifyInstanceAttribute(request *ec2.ModifyInstanceAttributeInput) (*ec2.ModifyInstanceAttributeOutput, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ELB is a simple pass-through of AWS' ELB client interface, which allows for testing
0000000000000000000000000000000000000000;;	type ELB interface {
0000000000000000000000000000000000000000;;		CreateLoadBalancer(*elb.CreateLoadBalancerInput) (*elb.CreateLoadBalancerOutput, error)
0000000000000000000000000000000000000000;;		DeleteLoadBalancer(*elb.DeleteLoadBalancerInput) (*elb.DeleteLoadBalancerOutput, error)
0000000000000000000000000000000000000000;;		DescribeLoadBalancers(*elb.DescribeLoadBalancersInput) (*elb.DescribeLoadBalancersOutput, error)
0000000000000000000000000000000000000000;;		RegisterInstancesWithLoadBalancer(*elb.RegisterInstancesWithLoadBalancerInput) (*elb.RegisterInstancesWithLoadBalancerOutput, error)
0000000000000000000000000000000000000000;;		DeregisterInstancesFromLoadBalancer(*elb.DeregisterInstancesFromLoadBalancerInput) (*elb.DeregisterInstancesFromLoadBalancerOutput, error)
0000000000000000000000000000000000000000;;		CreateLoadBalancerPolicy(*elb.CreateLoadBalancerPolicyInput) (*elb.CreateLoadBalancerPolicyOutput, error)
0000000000000000000000000000000000000000;;		SetLoadBalancerPoliciesForBackendServer(*elb.SetLoadBalancerPoliciesForBackendServerInput) (*elb.SetLoadBalancerPoliciesForBackendServerOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DetachLoadBalancerFromSubnets(*elb.DetachLoadBalancerFromSubnetsInput) (*elb.DetachLoadBalancerFromSubnetsOutput, error)
0000000000000000000000000000000000000000;;		AttachLoadBalancerToSubnets(*elb.AttachLoadBalancerToSubnetsInput) (*elb.AttachLoadBalancerToSubnetsOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CreateLoadBalancerListeners(*elb.CreateLoadBalancerListenersInput) (*elb.CreateLoadBalancerListenersOutput, error)
0000000000000000000000000000000000000000;;		DeleteLoadBalancerListeners(*elb.DeleteLoadBalancerListenersInput) (*elb.DeleteLoadBalancerListenersOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ApplySecurityGroupsToLoadBalancer(*elb.ApplySecurityGroupsToLoadBalancerInput) (*elb.ApplySecurityGroupsToLoadBalancerOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ConfigureHealthCheck(*elb.ConfigureHealthCheckInput) (*elb.ConfigureHealthCheckOutput, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DescribeLoadBalancerAttributes(*elb.DescribeLoadBalancerAttributesInput) (*elb.DescribeLoadBalancerAttributesOutput, error)
0000000000000000000000000000000000000000;;		ModifyLoadBalancerAttributes(*elb.ModifyLoadBalancerAttributesInput) (*elb.ModifyLoadBalancerAttributesOutput, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASG is a simple pass-through of the Autoscaling client interface, which
0000000000000000000000000000000000000000;;	// allows for testing.
0000000000000000000000000000000000000000;;	type ASG interface {
0000000000000000000000000000000000000000;;		UpdateAutoScalingGroup(*autoscaling.UpdateAutoScalingGroupInput) (*autoscaling.UpdateAutoScalingGroupOutput, error)
0000000000000000000000000000000000000000;;		DescribeAutoScalingGroups(*autoscaling.DescribeAutoScalingGroupsInput) (*autoscaling.DescribeAutoScalingGroupsOutput, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EC2Metadata is an abstraction over the AWS metadata service.
0000000000000000000000000000000000000000;;	type EC2Metadata interface {
0000000000000000000000000000000000000000;;		// Query the EC2 metadata service (used to discover instance-id etc)
0000000000000000000000000000000000000000;;		GetMetadata(path string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AWS volume types
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Provisioned IOPS SSD
0000000000000000000000000000000000000000;;		VolumeTypeIO1 = "io1"
0000000000000000000000000000000000000000;;		// General Purpose SSD
0000000000000000000000000000000000000000;;		VolumeTypeGP2 = "gp2"
0000000000000000000000000000000000000000;;		// Cold HDD (sc1)
0000000000000000000000000000000000000000;;		VolumeTypeSC1 = "sc1"
0000000000000000000000000000000000000000;;		// Throughput Optimized HDD
0000000000000000000000000000000000000000;;		VolumeTypeST1 = "st1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AWS provisioning limits.
0000000000000000000000000000000000000000;;	// Source: http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MinTotalIOPS = 100
0000000000000000000000000000000000000000;;		MaxTotalIOPS = 20000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeOptions specifies capacity and tags for a volume.
0000000000000000000000000000000000000000;;	type VolumeOptions struct {
0000000000000000000000000000000000000000;;		CapacityGB        int
0000000000000000000000000000000000000000;;		Tags              map[string]string
0000000000000000000000000000000000000000;;		PVCName           string
0000000000000000000000000000000000000000;;		VolumeType        string
0000000000000000000000000000000000000000;;		ZonePresent       bool
0000000000000000000000000000000000000000;;		ZonesPresent      bool
0000000000000000000000000000000000000000;;		AvailabilityZone  string
0000000000000000000000000000000000000000;;		AvailabilityZones string
0000000000000000000000000000000000000000;;		// IOPSPerGB x CapacityGB will give total IOPS of the volume to create.
0000000000000000000000000000000000000000;;		// Calculated total IOPS will be capped at MaxTotalIOPS.
0000000000000000000000000000000000000000;;		IOPSPerGB int
0000000000000000000000000000000000000000;;		Encrypted bool
0000000000000000000000000000000000000000;;		// fully qualified resource name to the key to use for encryption.
0000000000000000000000000000000000000000;;		// example: arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef
0000000000000000000000000000000000000000;;		KmsKeyId string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volumes is an interface for managing cloud-provisioned volumes
0000000000000000000000000000000000000000;;	// TODO: Allow other clouds to implement this
0000000000000000000000000000000000000000;;	type Volumes interface {
0000000000000000000000000000000000000000;;		// Attach the disk to the node with the specified NodeName
0000000000000000000000000000000000000000;;		// nodeName can be empty to mean "the instance on which we are running"
0000000000000000000000000000000000000000;;		// Returns the device (e.g. /dev/xvdf) where we attached the volume
0000000000000000000000000000000000000000;;		AttachDisk(diskName KubernetesVolumeID, nodeName types.NodeName, readOnly bool) (string, error)
0000000000000000000000000000000000000000;;		// Detach the disk from the node with the specified NodeName
0000000000000000000000000000000000000000;;		// nodeName can be empty to mean "the instance on which we are running"
0000000000000000000000000000000000000000;;		// Returns the device where the volume was attached
0000000000000000000000000000000000000000;;		DetachDisk(diskName KubernetesVolumeID, nodeName types.NodeName) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a volume with the specified options
0000000000000000000000000000000000000000;;		CreateDisk(volumeOptions *VolumeOptions) (volumeName KubernetesVolumeID, err error)
0000000000000000000000000000000000000000;;		// Delete the specified volume
0000000000000000000000000000000000000000;;		// Returns true iff the volume was deleted
0000000000000000000000000000000000000000;;		// If the was not found, returns (false, nil)
0000000000000000000000000000000000000000;;		DeleteDisk(volumeName KubernetesVolumeID) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get labels to apply to volume on creation
0000000000000000000000000000000000000000;;		GetVolumeLabels(volumeName KubernetesVolumeID) (map[string]string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get volume's disk path from volume name
0000000000000000000000000000000000000000;;		// return the device path where the volume is attached
0000000000000000000000000000000000000000;;		GetDiskPath(volumeName KubernetesVolumeID) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the volume is already attached to the node with the specified NodeName
0000000000000000000000000000000000000000;;		DiskIsAttached(diskName KubernetesVolumeID, nodeName types.NodeName) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if disks specified in argument map are still attached to their respective nodes.
0000000000000000000000000000000000000000;;		DisksAreAttached(map[types.NodeName][]KubernetesVolumeID) (map[types.NodeName]map[KubernetesVolumeID]bool, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceGroups is an interface for managing cloud-managed instance groups / autoscaling instance groups
0000000000000000000000000000000000000000;;	// TODO: Allow other clouds to implement this
0000000000000000000000000000000000000000;;	type InstanceGroups interface {
0000000000000000000000000000000000000000;;		// Set the size to the fixed size
0000000000000000000000000000000000000000;;		ResizeInstanceGroup(instanceGroupName string, size int) error
0000000000000000000000000000000000000000;;		// Queries the cloud provider for information about the specified instance group
0000000000000000000000000000000000000000;;		DescribeInstanceGroup(instanceGroupName string) (InstanceGroupInfo, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceGroupInfo is returned by InstanceGroups.Describe, and exposes information about the group.
0000000000000000000000000000000000000000;;	type InstanceGroupInfo interface {
0000000000000000000000000000000000000000;;		// The number of instances currently running under control of this group
0000000000000000000000000000000000000000;;		CurrentSize() (int, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cloud is an implementation of Interface, LoadBalancer and Instances for Amazon Web Services.
0000000000000000000000000000000000000000;;	type Cloud struct {
0000000000000000000000000000000000000000;;		ec2      EC2
0000000000000000000000000000000000000000;;		elb      ELB
0000000000000000000000000000000000000000;;		asg      ASG
0000000000000000000000000000000000000000;;		metadata EC2Metadata
0000000000000000000000000000000000000000;;		cfg      *CloudConfig
0000000000000000000000000000000000000000;;		region   string
0000000000000000000000000000000000000000;;		vpcID    string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tagging awsTagging
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The AWS instance that we are running on
0000000000000000000000000000000000000000;;		// Note that we cache some state in awsInstance (mountpoints), so we must preserve the instance
0000000000000000000000000000000000000000;;		selfAWSInstance *awsInstance
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instanceCache instanceCache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We keep an active list of devices we have assigned but not yet
0000000000000000000000000000000000000000;;		// attached, to avoid a race condition where we assign a device mapping
0000000000000000000000000000000000000000;;		// and then get a second request before we attach the volume
0000000000000000000000000000000000000000;;		attachingMutex sync.Mutex
0000000000000000000000000000000000000000;;		attaching      map[types.NodeName]map[mountDevice]awsVolumeID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// state of our device allocator for each node
0000000000000000000000000000000000000000;;		deviceAllocators map[types.NodeName]DeviceAllocator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Volumes = &Cloud{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloudConfig wraps the settings for the AWS cloud provider.
0000000000000000000000000000000000000000;;	type CloudConfig struct {
0000000000000000000000000000000000000000;;		Global struct {
0000000000000000000000000000000000000000;;			// TODO: Is there any use for this?  We can get it from the instance metadata service
0000000000000000000000000000000000000000;;			// Maybe if we're not running on AWS, e.g. bootstrap; for now it is not very useful
0000000000000000000000000000000000000000;;			Zone string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The AWS VPC flag enables the possibility to run the master components
0000000000000000000000000000000000000000;;			// on a different aws account, on a different cloud provider or on-premise.
0000000000000000000000000000000000000000;;			// If the flag is set also the KubernetesClusterTag must be provided
0000000000000000000000000000000000000000;;			VPC string
0000000000000000000000000000000000000000;;			// SubnetID enables using a specific subnet to use for ELB's
0000000000000000000000000000000000000000;;			SubnetID string
0000000000000000000000000000000000000000;;			// RouteTableID enables using a specific RouteTable
0000000000000000000000000000000000000000;;			RouteTableID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// KubernetesClusterTag is the legacy cluster id we'll use to identify our cluster resources
0000000000000000000000000000000000000000;;			KubernetesClusterTag string
0000000000000000000000000000000000000000;;			// KubernetesClusterTag is the cluster id we'll use to identify our cluster resources
0000000000000000000000000000000000000000;;			KubernetesClusterID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//The aws provider creates an inbound rule per load balancer on the node security
0000000000000000000000000000000000000000;;			//group. However, this can run into the AWS security group rule limit of 50 if
0000000000000000000000000000000000000000;;			//many LoadBalancers are created.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			//This flag disables the automatic ingress creation. It requires that the user
0000000000000000000000000000000000000000;;			//has setup a rule that allows inbound traffic on kubelet ports from the
0000000000000000000000000000000000000000;;			//local VPC subnet (so load balancers can access it). E.g. 10.82.0.0/16 30000-32000.
0000000000000000000000000000000000000000;;			DisableSecurityGroupIngress bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//AWS has a hard limit of 500 security groups. For large clusters creating a security group for each ELB
0000000000000000000000000000000000000000;;			//can cause the max number of security groups to be reached. If this is set instead of creating a new
0000000000000000000000000000000000000000;;			//Security group for each ELB this security group will be used instead.
0000000000000000000000000000000000000000;;			ElbSecurityGroup string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//During the instantiation of an new AWS cloud provider, the detected region
0000000000000000000000000000000000000000;;			//is validated against a known set of regions.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			//In a non-standard, AWS like environment (e.g. Eucalyptus), this check may
0000000000000000000000000000000000000000;;			//be undesirable.  Setting this to true will disable the check and provide
0000000000000000000000000000000000000000;;			//a warning that the check was skipped.  Please note that this is an
0000000000000000000000000000000000000000;;			//experimental feature and work-in-progress for the moment.  If you find
0000000000000000000000000000000000000000;;			//yourself in an non-AWS cloud and open an issue, please indicate that in the
0000000000000000000000000000000000000000;;			//issue body.
0000000000000000000000000000000000000000;;			DisableStrictZoneCheck bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awsSdkEC2 is an implementation of the EC2 interface, backed by aws-sdk-go
0000000000000000000000000000000000000000;;	type awsSdkEC2 struct {
0000000000000000000000000000000000000000;;		ec2 *ec2.EC2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsSDKProvider struct {
0000000000000000000000000000000000000000;;		creds *credentials.Credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mutex          sync.Mutex
0000000000000000000000000000000000000000;;		regionDelayers map[string]*CrossRequestRetryDelay
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAWSSDKProvider(creds *credentials.Credentials) *awsSDKProvider {
0000000000000000000000000000000000000000;;		return &awsSDKProvider{
0000000000000000000000000000000000000000;;			creds:          creds,
0000000000000000000000000000000000000000;;			regionDelayers: make(map[string]*CrossRequestRetryDelay),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *awsSDKProvider) addHandlers(regionName string, h *request.Handlers) {
0000000000000000000000000000000000000000;;		h.Sign.PushFrontNamed(request.NamedHandler{
0000000000000000000000000000000000000000;;			Name: "k8s/logger",
0000000000000000000000000000000000000000;;			Fn:   awsHandlerLogger,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delayer := p.getCrossRequestRetryDelay(regionName)
0000000000000000000000000000000000000000;;		if delayer != nil {
0000000000000000000000000000000000000000;;			h.Sign.PushFrontNamed(request.NamedHandler{
0000000000000000000000000000000000000000;;				Name: "k8s/delay-presign",
0000000000000000000000000000000000000000;;				Fn:   delayer.BeforeSign,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			h.AfterRetry.PushFrontNamed(request.NamedHandler{
0000000000000000000000000000000000000000;;				Name: "k8s/delay-afterretry",
0000000000000000000000000000000000000000;;				Fn:   delayer.AfterRetry,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a CrossRequestRetryDelay, scoped to the region, not to the request.
0000000000000000000000000000000000000000;;	// This means that when we hit a limit on a call, we will delay _all_ calls to the API.
0000000000000000000000000000000000000000;;	// We do this to protect the AWS account from becoming overloaded and effectively locked.
0000000000000000000000000000000000000000;;	// We also log when we hit request limits.
0000000000000000000000000000000000000000;;	// Note that this delays the current goroutine; this is bad behaviour and will
0000000000000000000000000000000000000000;;	// likely cause k8s to become slow or unresponsive for cloud operations.
0000000000000000000000000000000000000000;;	// However, this throttle is intended only as a last resort.  When we observe
0000000000000000000000000000000000000000;;	// this throttling, we need to address the root cause (e.g. add a delay to a
0000000000000000000000000000000000000000;;	// controller retry loop)
0000000000000000000000000000000000000000;;	func (p *awsSDKProvider) getCrossRequestRetryDelay(regionName string) *CrossRequestRetryDelay {
0000000000000000000000000000000000000000;;		p.mutex.Lock()
0000000000000000000000000000000000000000;;		defer p.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delayer, found := p.regionDelayers[regionName]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			delayer = NewCrossRequestRetryDelay()
0000000000000000000000000000000000000000;;			p.regionDelayers[regionName] = delayer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return delayer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *awsSDKProvider) Compute(regionName string) (EC2, error) {
0000000000000000000000000000000000000000;;		awsConfig := &aws.Config{
0000000000000000000000000000000000000000;;			Region:      &regionName,
0000000000000000000000000000000000000000;;			Credentials: p.creds,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsConfig = awsConfig.WithCredentialsChainVerboseErrors(true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service := ec2.New(session.New(awsConfig))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.addHandlers(regionName, &service.Handlers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ec2 := &awsSdkEC2{
0000000000000000000000000000000000000000;;			ec2: service,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ec2, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *awsSDKProvider) LoadBalancing(regionName string) (ELB, error) {
0000000000000000000000000000000000000000;;		awsConfig := &aws.Config{
0000000000000000000000000000000000000000;;			Region:      &regionName,
0000000000000000000000000000000000000000;;			Credentials: p.creds,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsConfig = awsConfig.WithCredentialsChainVerboseErrors(true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elbClient := elb.New(session.New(awsConfig))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.addHandlers(regionName, &elbClient.Handlers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return elbClient, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *awsSDKProvider) Autoscaling(regionName string) (ASG, error) {
0000000000000000000000000000000000000000;;		awsConfig := &aws.Config{
0000000000000000000000000000000000000000;;			Region:      &regionName,
0000000000000000000000000000000000000000;;			Credentials: p.creds,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsConfig = awsConfig.WithCredentialsChainVerboseErrors(true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := autoscaling.New(session.New(awsConfig))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.addHandlers(regionName, &client.Handlers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *awsSDKProvider) Metadata() (EC2Metadata, error) {
0000000000000000000000000000000000000000;;		client := ec2metadata.New(session.New(&aws.Config{}))
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stringPointerArray creates a slice of string pointers from a slice of strings
0000000000000000000000000000000000000000;;	// Deprecated: consider using aws.StringSlice - but note the slightly different behaviour with a nil input
0000000000000000000000000000000000000000;;	func stringPointerArray(orig []string) []*string {
0000000000000000000000000000000000000000;;		if orig == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return aws.StringSlice(orig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isNilOrEmpty returns true if the value is nil or ""
0000000000000000000000000000000000000000;;	// Deprecated: prefer aws.StringValue(x) == "" (and elimination of this check altogether where possible)
0000000000000000000000000000000000000000;;	func isNilOrEmpty(s *string) bool {
0000000000000000000000000000000000000000;;		return s == nil || *s == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// orEmpty returns the string value, or "" if the pointer is nil
0000000000000000000000000000000000000000;;	// Deprecated: prefer aws.StringValue
0000000000000000000000000000000000000000;;	func orEmpty(s *string) string {
0000000000000000000000000000000000000000;;		return aws.StringValue(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEc2Filter(name string, values ...string) *ec2.Filter {
0000000000000000000000000000000000000000;;		filter := &ec2.Filter{
0000000000000000000000000000000000000000;;			Name: aws.String(name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, value := range values {
0000000000000000000000000000000000000000;;			filter.Values = append(filter.Values, aws.String(value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddSSHKeyToAllInstances is currently not implemented.
0000000000000000000000000000000000000000;;	func (c *Cloud) AddSSHKeyToAllInstances(user string, keyData []byte) error {
0000000000000000000000000000000000000000;;		return errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CurrentNodeName returns the name of the current node
0000000000000000000000000000000000000000;;	func (c *Cloud) CurrentNodeName(hostname string) (types.NodeName, error) {
0000000000000000000000000000000000000000;;		return c.selfAWSInstance.nodeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of EC2.Instances
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DescribeInstances(request *ec2.DescribeInstancesInput) ([]*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		// Instances are paged
0000000000000000000000000000000000000000;;		results := []*ec2.Instance{}
0000000000000000000000000000000000000000;;		var nextToken *string
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			response, err := s.ec2.DescribeInstances(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				recordAwsMetric("describe_instance", 0, err)
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error listing AWS instances: %q", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, reservation := range response.Reservations {
0000000000000000000000000000000000000000;;				results = append(results, reservation.Instances...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nextToken = response.NextToken
0000000000000000000000000000000000000000;;			if isNilOrEmpty(nextToken) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			request.NextToken = nextToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeTaken := time.Since(requestTime).Seconds()
0000000000000000000000000000000000000000;;		recordAwsMetric("describe_instance", timeTaken, nil)
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements EC2.DescribeSecurityGroups
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DescribeSecurityGroups(request *ec2.DescribeSecurityGroupsInput) ([]*ec2.SecurityGroup, error) {
0000000000000000000000000000000000000000;;		// Security groups are not paged
0000000000000000000000000000000000000000;;		response, err := s.ec2.DescribeSecurityGroups(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error listing AWS security groups: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return response.SecurityGroups, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) AttachVolume(request *ec2.AttachVolumeInput) (*ec2.VolumeAttachment, error) {
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		resp, err := s.ec2.AttachVolume(request)
0000000000000000000000000000000000000000;;		timeTaken := time.Since(requestTime).Seconds()
0000000000000000000000000000000000000000;;		recordAwsMetric("attach_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DetachVolume(request *ec2.DetachVolumeInput) (*ec2.VolumeAttachment, error) {
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		resp, err := s.ec2.DetachVolume(request)
0000000000000000000000000000000000000000;;		timeTaken := time.Since(requestTime).Seconds()
0000000000000000000000000000000000000000;;		recordAwsMetric("detach_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DescribeVolumes(request *ec2.DescribeVolumesInput) ([]*ec2.Volume, error) {
0000000000000000000000000000000000000000;;		// Volumes are paged
0000000000000000000000000000000000000000;;		results := []*ec2.Volume{}
0000000000000000000000000000000000000000;;		var nextToken *string
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			response, err := s.ec2.DescribeVolumes(request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				recordAwsMetric("describe_volume", 0, err)
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error listing AWS volumes: %q", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			results = append(results, response.Volumes...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nextToken = response.NextToken
0000000000000000000000000000000000000000;;			if isNilOrEmpty(nextToken) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			request.NextToken = nextToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeTaken := time.Since(requestTime).Seconds()
0000000000000000000000000000000000000000;;		recordAwsMetric("describe_volume", timeTaken, nil)
0000000000000000000000000000000000000000;;		return results, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) CreateVolume(request *ec2.CreateVolumeInput) (*ec2.Volume, error) {
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		resp, err := s.ec2.CreateVolume(request)
0000000000000000000000000000000000000000;;		timeTaken := time.Since(requestTime).Seconds()
0000000000000000000000000000000000000000;;		recordAwsMetric("create_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DeleteVolume(request *ec2.DeleteVolumeInput) (*ec2.DeleteVolumeOutput, error) {
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		resp, err := s.ec2.DeleteVolume(request)
0000000000000000000000000000000000000000;;		timeTaken := time.Since(requestTime).Seconds()
0000000000000000000000000000000000000000;;		recordAwsMetric("delete_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DescribeSubnets(request *ec2.DescribeSubnetsInput) ([]*ec2.Subnet, error) {
0000000000000000000000000000000000000000;;		// Subnets are not paged
0000000000000000000000000000000000000000;;		response, err := s.ec2.DescribeSubnets(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error listing AWS subnets: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return response.Subnets, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) CreateSecurityGroup(request *ec2.CreateSecurityGroupInput) (*ec2.CreateSecurityGroupOutput, error) {
0000000000000000000000000000000000000000;;		return s.ec2.CreateSecurityGroup(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DeleteSecurityGroup(request *ec2.DeleteSecurityGroupInput) (*ec2.DeleteSecurityGroupOutput, error) {
0000000000000000000000000000000000000000;;		return s.ec2.DeleteSecurityGroup(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) AuthorizeSecurityGroupIngress(request *ec2.AuthorizeSecurityGroupIngressInput) (*ec2.AuthorizeSecurityGroupIngressOutput, error) {
0000000000000000000000000000000000000000;;		return s.ec2.AuthorizeSecurityGroupIngress(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) RevokeSecurityGroupIngress(request *ec2.RevokeSecurityGroupIngressInput) (*ec2.RevokeSecurityGroupIngressOutput, error) {
0000000000000000000000000000000000000000;;		return s.ec2.RevokeSecurityGroupIngress(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) CreateTags(request *ec2.CreateTagsInput) (*ec2.CreateTagsOutput, error) {
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		resp, err := s.ec2.CreateTags(request)
0000000000000000000000000000000000000000;;		timeTaken := time.Since(requestTime).Seconds()
0000000000000000000000000000000000000000;;		recordAwsMetric("create_tags", timeTaken, err)
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DescribeRouteTables(request *ec2.DescribeRouteTablesInput) ([]*ec2.RouteTable, error) {
0000000000000000000000000000000000000000;;		// Not paged
0000000000000000000000000000000000000000;;		response, err := s.ec2.DescribeRouteTables(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error listing AWS route tables: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return response.RouteTables, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) CreateRoute(request *ec2.CreateRouteInput) (*ec2.CreateRouteOutput, error) {
0000000000000000000000000000000000000000;;		return s.ec2.CreateRoute(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) DeleteRoute(request *ec2.DeleteRouteInput) (*ec2.DeleteRouteOutput, error) {
0000000000000000000000000000000000000000;;		return s.ec2.DeleteRoute(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *awsSdkEC2) ModifyInstanceAttribute(request *ec2.ModifyInstanceAttributeInput) (*ec2.ModifyInstanceAttributeOutput, error) {
0000000000000000000000000000000000000000;;		return s.ec2.ModifyInstanceAttribute(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		registerMetrics()
0000000000000000000000000000000000000000;;		cloudprovider.RegisterCloudProvider(ProviderName, func(config io.Reader) (cloudprovider.Interface, error) {
0000000000000000000000000000000000000000;;			creds := credentials.NewChainCredentials(
0000000000000000000000000000000000000000;;				[]credentials.Provider{
0000000000000000000000000000000000000000;;					&credentials.EnvProvider{},
0000000000000000000000000000000000000000;;					&ec2rolecreds.EC2RoleProvider{
0000000000000000000000000000000000000000;;						Client: ec2metadata.New(session.New(&aws.Config{})),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					&credentials.SharedCredentialsProvider{},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			aws := newAWSSDKProvider(creds)
0000000000000000000000000000000000000000;;			return newAWSCloud(config, aws)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readAWSCloudConfig reads an instance of AWSCloudConfig from config reader.
0000000000000000000000000000000000000000;;	func readAWSCloudConfig(config io.Reader, metadata EC2Metadata) (*CloudConfig, error) {
0000000000000000000000000000000000000000;;		var cfg CloudConfig
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config != nil {
0000000000000000000000000000000000000000;;			err = gcfg.ReadInto(&cfg, config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Global.Zone == "" {
0000000000000000000000000000000000000000;;			if metadata != nil {
0000000000000000000000000000000000000000;;				glog.Info("Zone not specified in configuration file; querying AWS metadata service")
0000000000000000000000000000000000000000;;				cfg.Global.Zone, err = getAvailabilityZone(metadata)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cfg.Global.Zone == "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("no zone specified in configuration file")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &cfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInstanceType(metadata EC2Metadata) (string, error) {
0000000000000000000000000000000000000000;;		return metadata.GetMetadata("instance-type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAvailabilityZone(metadata EC2Metadata) (string, error) {
0000000000000000000000000000000000000000;;		return metadata.GetMetadata("placement/availability-zone")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Derives the region from a valid az name.
0000000000000000000000000000000000000000;;	// Returns an error if the az is known invalid (empty)
0000000000000000000000000000000000000000;;	func azToRegion(az string) (string, error) {
0000000000000000000000000000000000000000;;		if len(az) < 1 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid (empty) AZ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		region := az[:len(az)-1]
0000000000000000000000000000000000000000;;		return region, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAWSCloud creates a new instance of AWSCloud.
0000000000000000000000000000000000000000;;	// AWSProvider and instanceId are primarily for tests
0000000000000000000000000000000000000000;;	func newAWSCloud(config io.Reader, awsServices Services) (*Cloud, error) {
0000000000000000000000000000000000000000;;		// We have some state in the Cloud object - in particular the attaching map
0000000000000000000000000000000000000000;;		// Log so that if we are building multiple Cloud objects, it is obvious!
0000000000000000000000000000000000000000;;		glog.Infof("Building AWS cloudprovider")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metadata, err := awsServices.Metadata()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating AWS metadata client: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg, err := readAWSCloudConfig(config, metadata)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to read AWS cloud provider config file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zone := cfg.Global.Zone
0000000000000000000000000000000000000000;;		if len(zone) <= 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AWS zone in config file: %s", zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		regionName, err := azToRegion(zone)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trust that if we get a region from configuration or AWS metadata that it is valid,
0000000000000000000000000000000000000000;;		// and register ECR providers
0000000000000000000000000000000000000000;;		RecognizeRegion(regionName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cfg.Global.DisableStrictZoneCheck {
0000000000000000000000000000000000000000;;			valid := isRegionValid(regionName)
0000000000000000000000000000000000000000;;			if !valid {
0000000000000000000000000000000000000000;;				// This _should_ now be unreachable, given we call RecognizeRegion
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("not a valid AWS zone (unknown region): %s", zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Warningf("Strict AWS zone checking is disabled.  Proceeding with zone: %s", zone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ec2, err := awsServices.Compute(regionName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating AWS EC2 client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elb, err := awsServices.LoadBalancing(regionName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating AWS ELB client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asg, err := awsServices.Autoscaling(regionName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error creating AWS autoscaling client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsCloud := &Cloud{
0000000000000000000000000000000000000000;;			ec2:      ec2,
0000000000000000000000000000000000000000;;			elb:      elb,
0000000000000000000000000000000000000000;;			asg:      asg,
0000000000000000000000000000000000000000;;			metadata: metadata,
0000000000000000000000000000000000000000;;			cfg:      cfg,
0000000000000000000000000000000000000000;;			region:   regionName,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attaching:        make(map[types.NodeName]map[mountDevice]awsVolumeID),
0000000000000000000000000000000000000000;;			deviceAllocators: make(map[types.NodeName]DeviceAllocator),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsCloud.instanceCache.cloud = awsCloud
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Global.VPC != "" && cfg.Global.SubnetID != "" && (cfg.Global.KubernetesClusterTag != "" || cfg.Global.KubernetesClusterID != "") {
0000000000000000000000000000000000000000;;			// When the master is running on a different AWS account, cloud provider or on-premise
0000000000000000000000000000000000000000;;			// build up a dummy instance and use the VPC from the nodes account
0000000000000000000000000000000000000000;;			glog.Info("Master is configured to run on a different AWS account, different cloud provider or on-premise")
0000000000000000000000000000000000000000;;			awsCloud.selfAWSInstance = &awsInstance{
0000000000000000000000000000000000000000;;				nodeName: "master-dummy",
0000000000000000000000000000000000000000;;				vpcID:    cfg.Global.VPC,
0000000000000000000000000000000000000000;;				subnetID: cfg.Global.SubnetID,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			awsCloud.vpcID = cfg.Global.VPC
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			selfAWSInstance, err := awsCloud.buildSelfAWSInstance()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			awsCloud.selfAWSInstance = selfAWSInstance
0000000000000000000000000000000000000000;;			awsCloud.vpcID = selfAWSInstance.vpcID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Global.KubernetesClusterTag != "" || cfg.Global.KubernetesClusterID != "" {
0000000000000000000000000000000000000000;;			if err := awsCloud.tagging.init(cfg.Global.KubernetesClusterTag, cfg.Global.KubernetesClusterID); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: Clean up double-API query
0000000000000000000000000000000000000000;;			info, err := awsCloud.selfAWSInstance.describeInstance()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := awsCloud.tagging.initFromTags(info.Tags); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register regions, in particular for ECR credentials
0000000000000000000000000000000000000000;;		once.Do(func() {
0000000000000000000000000000000000000000;;			RecognizeWellKnownRegions()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return awsCloud, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize passes a Kubernetes clientBuilder interface to the cloud provider
0000000000000000000000000000000000000000;;	func (c *Cloud) Initialize(clientBuilder controller.ControllerClientBuilder) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clusters returns the list of clusters.
0000000000000000000000000000000000000000;;	func (c *Cloud) Clusters() (cloudprovider.Clusters, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;	func (c *Cloud) ProviderName() string {
0000000000000000000000000000000000000000;;		return ProviderName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScrubDNS filters DNS settings for pods.
0000000000000000000000000000000000000000;;	func (c *Cloud) ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string) {
0000000000000000000000000000000000000000;;		return nameservers, searches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer returns an implementation of LoadBalancer for Amazon Web Services.
0000000000000000000000000000000000000000;;	func (c *Cloud) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
0000000000000000000000000000000000000000;;		return c, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances returns an implementation of Instances for Amazon Web Services.
0000000000000000000000000000000000000000;;	func (c *Cloud) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		return c, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zones returns an implementation of Zones for Amazon Web Services.
0000000000000000000000000000000000000000;;	func (c *Cloud) Zones() (cloudprovider.Zones, bool) {
0000000000000000000000000000000000000000;;		return c, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Routes returns an implementation of Routes for Amazon Web Services.
0000000000000000000000000000000000000000;;	func (c *Cloud) Routes() (cloudprovider.Routes, bool) {
0000000000000000000000000000000000000000;;		return c, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddresses is an implementation of Instances.NodeAddresses.
0000000000000000000000000000000000000000;;	func (c *Cloud) NodeAddresses(name types.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		if c.selfAWSInstance.nodeName == name || len(name) == 0 {
0000000000000000000000000000000000000000;;			addresses := []v1.NodeAddress{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			internalIP, err := c.metadata.GetMetadata("local-ipv4")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error querying AWS metadata for %q: %q", "local-ipv4", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addresses = append(addresses, v1.NodeAddress{Type: v1.NodeInternalIP, Address: internalIP})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			externalIP, err := c.metadata.GetMetadata("public-ipv4")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				//TODO: It would be nice to be able to determine the reason for the failure,
0000000000000000000000000000000000000000;;				// but the AWS client masks all failures with the same error description.
0000000000000000000000000000000000000000;;				glog.V(4).Info("Could not determine public IP from AWS metadata.")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				addresses = append(addresses, v1.NodeAddress{Type: v1.NodeExternalIP, Address: externalIP})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			internalDNS, err := c.metadata.GetMetadata("local-hostname")
0000000000000000000000000000000000000000;;			if err != nil || len(internalDNS) == 0 {
0000000000000000000000000000000000000000;;				//TODO: It would be nice to be able to determine the reason for the failure,
0000000000000000000000000000000000000000;;				// but the AWS client masks all failures with the same error description.
0000000000000000000000000000000000000000;;				glog.V(2).Info("Could not determine private DNS from AWS metadata.")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				addresses = append(addresses, v1.NodeAddress{Type: v1.NodeInternalDNS, Address: internalDNS})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			externalDNS, err := c.metadata.GetMetadata("public-hostname")
0000000000000000000000000000000000000000;;			if err != nil || len(externalDNS) == 0 {
0000000000000000000000000000000000000000;;				//TODO: It would be nice to be able to determine the reason for the failure,
0000000000000000000000000000000000000000;;				// but the AWS client masks all failures with the same error description.
0000000000000000000000000000000000000000;;				glog.V(2).Info("Could not determine public DNS from AWS metadata.")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				addresses = append(addresses, v1.NodeAddress{Type: v1.NodeExternalDNS, Address: externalDNS})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return addresses, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instance, err := c.getInstanceByNodeName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("getInstanceByNodeName failed for %q with %q", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return extractNodeAddresses(instance)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractNodeAddresses maps the instance information from EC2 to an array of NodeAddresses
0000000000000000000000000000000000000000;;	func extractNodeAddresses(instance *ec2.Instance) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		// Not clear if the order matters here, but we might as well indicate a sensible preference order
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if instance == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("nil instance passed to extractNodeAddresses")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addresses := []v1.NodeAddress{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateIPAddress := aws.StringValue(instance.PrivateIpAddress)
0000000000000000000000000000000000000000;;		if privateIPAddress != "" {
0000000000000000000000000000000000000000;;			ip := net.ParseIP(privateIPAddress)
0000000000000000000000000000000000000000;;			if ip == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("EC2 instance had invalid private address: %s (%s)", aws.StringValue(instance.InstanceId), privateIPAddress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addresses = append(addresses, v1.NodeAddress{Type: v1.NodeInternalIP, Address: ip.String()})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Other IP addresses (multiple ips)?
0000000000000000000000000000000000000000;;		publicIPAddress := aws.StringValue(instance.PublicIpAddress)
0000000000000000000000000000000000000000;;		if publicIPAddress != "" {
0000000000000000000000000000000000000000;;			ip := net.ParseIP(publicIPAddress)
0000000000000000000000000000000000000000;;			if ip == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("EC2 instance had invalid public address: %s (%s)", aws.StringValue(instance.InstanceId), publicIPAddress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addresses = append(addresses, v1.NodeAddress{Type: v1.NodeExternalIP, Address: ip.String()})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateDNSName := aws.StringValue(instance.PrivateDnsName)
0000000000000000000000000000000000000000;;		if privateDNSName != "" {
0000000000000000000000000000000000000000;;			addresses = append(addresses, v1.NodeAddress{Type: v1.NodeInternalDNS, Address: privateDNSName})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		publicDNSName := aws.StringValue(instance.PublicDnsName)
0000000000000000000000000000000000000000;;		if publicDNSName != "" {
0000000000000000000000000000000000000000;;			addresses = append(addresses, v1.NodeAddress{Type: v1.NodeExternalDNS, Address: publicDNSName})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return addresses, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddressesByProviderID returns the node addresses of an instances with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (c *Cloud) NodeAddressesByProviderID(providerID string) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		instanceID, err := kubernetesInstanceID(providerID).mapToAWSInstanceID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instance, err := describeInstance(c.ec2, instanceID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return extractNodeAddresses(instance)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalID returns the cloud provider ID of the node with the specified nodeName (deprecated).
0000000000000000000000000000000000000000;;	func (c *Cloud) ExternalID(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		if c.selfAWSInstance.nodeName == nodeName {
0000000000000000000000000000000000000000;;			// We assume that if this is run on the instance itself, the instance exists and is alive
0000000000000000000000000000000000000000;;			return c.selfAWSInstance.awsID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We must verify that the instance still exists
0000000000000000000000000000000000000000;;		// Note that if the instance does not exist or is no longer running, we must return ("", cloudprovider.InstanceNotFound)
0000000000000000000000000000000000000000;;		instance, err := c.findInstanceByNodeName(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if instance == nil {
0000000000000000000000000000000000000000;;			return "", cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return orEmpty(instance.InstanceId), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the cloud provider ID of the node with the specified nodeName.
0000000000000000000000000000000000000000;;	func (c *Cloud) InstanceID(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		// In the future it is possible to also return an endpoint as:
0000000000000000000000000000000000000000;;		// <endpoint>/<zone>/<instanceid>
0000000000000000000000000000000000000000;;		if c.selfAWSInstance.nodeName == nodeName {
0000000000000000000000000000000000000000;;			return "/" + c.selfAWSInstance.availabilityZone + "/" + c.selfAWSInstance.awsID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inst, err := c.getInstanceByNodeName(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("getInstanceByNodeName failed for %q with %q", nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "/" + orEmpty(inst.Placement.AvailabilityZone) + "/" + orEmpty(inst.InstanceId), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceTypeByProviderID returns the cloudprovider instance type of the node with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (c *Cloud) InstanceTypeByProviderID(providerID string) (string, error) {
0000000000000000000000000000000000000000;;		instanceID, err := kubernetesInstanceID(providerID).mapToAWSInstanceID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instance, err := describeInstance(c.ec2, instanceID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return aws.StringValue(instance.InstanceType), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceType returns the type of the node with the specified nodeName.
0000000000000000000000000000000000000000;;	func (c *Cloud) InstanceType(nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		if c.selfAWSInstance.nodeName == nodeName {
0000000000000000000000000000000000000000;;			return c.selfAWSInstance.instanceType, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inst, err := c.getInstanceByNodeName(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("getInstanceByNodeName failed for %q with %q", nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return aws.StringValue(inst.InstanceType), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCandidateZonesForDynamicVolume retrieves  a list of all the zones in which nodes are running
0000000000000000000000000000000000000000;;	// It currently involves querying all instances
0000000000000000000000000000000000000000;;	func (c *Cloud) getCandidateZonesForDynamicVolume() (sets.String, error) {
0000000000000000000000000000000000000000;;		// We don't currently cache this; it is currently used only in volume
0000000000000000000000000000000000000000;;		// creation which is expected to be a comparatively rare occurrence.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Caching / expose v1.Nodes to the cloud provider?
0000000000000000000000000000000000000000;;		// TODO: We could also query for subnets, I think
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filters := []*ec2.Filter{newEc2Filter("instance-state-name", "running")}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, err := c.describeInstances(filters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(instances) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no instances returned")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zones := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, instance := range instances {
0000000000000000000000000000000000000000;;			// We skip over master nodes, if the installation tool labels them with one of the well-known master labels
0000000000000000000000000000000000000000;;			// This avoids creating a volume in a zone where only the master is running - e.g. #34583
0000000000000000000000000000000000000000;;			// This is a short-term workaround until the scheduler takes care of zone selection
0000000000000000000000000000000000000000;;			master := false
0000000000000000000000000000000000000000;;			for _, tag := range instance.Tags {
0000000000000000000000000000000000000000;;				tagKey := aws.StringValue(tag.Key)
0000000000000000000000000000000000000000;;				if awsTagNameMasterRoles.Has(tagKey) {
0000000000000000000000000000000000000000;;					master = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if master {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Ignoring master instance %q in zone discovery", aws.StringValue(instance.InstanceId))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if instance.Placement != nil {
0000000000000000000000000000000000000000;;				zone := aws.StringValue(instance.Placement.AvailabilityZone)
0000000000000000000000000000000000000000;;				zones.Insert(zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Found instances in zones %s", zones)
0000000000000000000000000000000000000000;;		return zones, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetZone implements Zones.GetZone
0000000000000000000000000000000000000000;;	func (c *Cloud) GetZone() (cloudprovider.Zone, error) {
0000000000000000000000000000000000000000;;		return cloudprovider.Zone{
0000000000000000000000000000000000000000;;			FailureDomain: c.selfAWSInstance.availabilityZone,
0000000000000000000000000000000000000000;;			Region:        c.region,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstraction around AWS Instance Types
0000000000000000000000000000000000000000;;	// There isn't an API to get information for a particular instance type (that I know of)
0000000000000000000000000000000000000000;;	type awsInstanceType struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used to represent a mount device for attaching an EBS volume
0000000000000000000000000000000000000000;;	// This should be stored as a single letter (i.e. c, not sdc or /dev/sdc)
0000000000000000000000000000000000000000;;	type mountDevice string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsInstance struct {
0000000000000000000000000000000000000000;;		ec2 EC2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// id in AWS
0000000000000000000000000000000000000000;;		awsID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// node name in k8s
0000000000000000000000000000000000000000;;		nodeName types.NodeName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// availability zone the instance resides in
0000000000000000000000000000000000000000;;		availabilityZone string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ID of VPC the instance resides in
0000000000000000000000000000000000000000;;		vpcID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ID of subnet the instance resides in
0000000000000000000000000000000000000000;;		subnetID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// instance type
0000000000000000000000000000000000000000;;		instanceType string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAWSInstance creates a new awsInstance object
0000000000000000000000000000000000000000;;	func newAWSInstance(ec2Service EC2, instance *ec2.Instance) *awsInstance {
0000000000000000000000000000000000000000;;		az := ""
0000000000000000000000000000000000000000;;		if instance.Placement != nil {
0000000000000000000000000000000000000000;;			az = aws.StringValue(instance.Placement.AvailabilityZone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self := &awsInstance{
0000000000000000000000000000000000000000;;			ec2:              ec2Service,
0000000000000000000000000000000000000000;;			awsID:            aws.StringValue(instance.InstanceId),
0000000000000000000000000000000000000000;;			nodeName:         mapInstanceToNodeName(instance),
0000000000000000000000000000000000000000;;			availabilityZone: az,
0000000000000000000000000000000000000000;;			instanceType:     aws.StringValue(instance.InstanceType),
0000000000000000000000000000000000000000;;			vpcID:            aws.StringValue(instance.VpcId),
0000000000000000000000000000000000000000;;			subnetID:         aws.StringValue(instance.SubnetId),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return self
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the awsInstanceType that models the instance type of this instance
0000000000000000000000000000000000000000;;	func (i *awsInstance) getInstanceType() *awsInstanceType {
0000000000000000000000000000000000000000;;		// TODO: Make this real
0000000000000000000000000000000000000000;;		awsInstanceType := &awsInstanceType{}
0000000000000000000000000000000000000000;;		return awsInstanceType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the full information about this instance from the EC2 API
0000000000000000000000000000000000000000;;	func (i *awsInstance) describeInstance() (*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		return describeInstance(i.ec2, awsInstanceID(i.awsID))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the mountDevice already assigned to the volume, or assigns an unused mountDevice.
0000000000000000000000000000000000000000;;	// If the volume is already assigned, this will return the existing mountDevice with alreadyAttached=true.
0000000000000000000000000000000000000000;;	// Otherwise the mountDevice is assigned by finding the first available mountDevice, and it is returned with alreadyAttached=false.
0000000000000000000000000000000000000000;;	func (c *Cloud) getMountDevice(
0000000000000000000000000000000000000000;;		i *awsInstance,
0000000000000000000000000000000000000000;;		info *ec2.Instance,
0000000000000000000000000000000000000000;;		volumeID awsVolumeID,
0000000000000000000000000000000000000000;;		assign bool) (assigned mountDevice, alreadyAttached bool, err error) {
0000000000000000000000000000000000000000;;		instanceType := i.getInstanceType()
0000000000000000000000000000000000000000;;		if instanceType == nil {
0000000000000000000000000000000000000000;;			return "", false, fmt.Errorf("could not get instance type for instance: %s", i.awsID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceMappings := map[mountDevice]awsVolumeID{}
0000000000000000000000000000000000000000;;		for _, blockDevice := range info.BlockDeviceMappings {
0000000000000000000000000000000000000000;;			name := aws.StringValue(blockDevice.DeviceName)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(name, "/dev/sd") {
0000000000000000000000000000000000000000;;				name = name[7:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(name, "/dev/xvd") {
0000000000000000000000000000000000000000;;				name = name[8:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(name) < 1 || len(name) > 2 {
0000000000000000000000000000000000000000;;				glog.Warningf("Unexpected EBS DeviceName: %q", aws.StringValue(blockDevice.DeviceName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			deviceMappings[mountDevice(name)] = awsVolumeID(aws.StringValue(blockDevice.Ebs.VolumeId))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We lock to prevent concurrent mounts from conflicting
0000000000000000000000000000000000000000;;		// We may still conflict if someone calls the API concurrently,
0000000000000000000000000000000000000000;;		// but the AWS API will then fail one of the two attach operations
0000000000000000000000000000000000000000;;		c.attachingMutex.Lock()
0000000000000000000000000000000000000000;;		defer c.attachingMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for mountDevice, volume := range c.attaching[i.nodeName] {
0000000000000000000000000000000000000000;;			deviceMappings[mountDevice] = volume
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check to see if this volume is already assigned a device on this machine
0000000000000000000000000000000000000000;;		for mountDevice, mappingVolumeID := range deviceMappings {
0000000000000000000000000000000000000000;;			if volumeID == mappingVolumeID {
0000000000000000000000000000000000000000;;				if assign {
0000000000000000000000000000000000000000;;					glog.Warningf("Got assignment call for already-assigned volume: %s@%s", mountDevice, mappingVolumeID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return mountDevice, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !assign {
0000000000000000000000000000000000000000;;			return mountDevice(""), false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the next unused device name
0000000000000000000000000000000000000000;;		deviceAllocator := c.deviceAllocators[i.nodeName]
0000000000000000000000000000000000000000;;		if deviceAllocator == nil {
0000000000000000000000000000000000000000;;			// we want device names with two significant characters, starting with /dev/xvdbb
0000000000000000000000000000000000000000;;			// the allowed range is /dev/xvd[b-c][a-z]
0000000000000000000000000000000000000000;;			// http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html
0000000000000000000000000000000000000000;;			deviceAllocator = NewDeviceAllocator()
0000000000000000000000000000000000000000;;			c.deviceAllocators[i.nodeName] = deviceAllocator
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We need to lock deviceAllocator to prevent possible race with Deprioritize function
0000000000000000000000000000000000000000;;		deviceAllocator.Lock()
0000000000000000000000000000000000000000;;		defer deviceAllocator.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chosen, err := deviceAllocator.GetNext(deviceMappings)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Could not assign a mount device.  mappings=%v, error: %v", deviceMappings, err)
0000000000000000000000000000000000000000;;			return "", false, fmt.Errorf("Too many EBS volumes attached to node %s.", i.nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attaching := c.attaching[i.nodeName]
0000000000000000000000000000000000000000;;		if attaching == nil {
0000000000000000000000000000000000000000;;			attaching = make(map[mountDevice]awsVolumeID)
0000000000000000000000000000000000000000;;			c.attaching[i.nodeName] = attaching
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attaching[chosen] = volumeID
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Assigned mount device %s -> volume %s", chosen, volumeID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return chosen, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// endAttaching removes the entry from the "attachments in progress" map
0000000000000000000000000000000000000000;;	// It returns true if it was found (and removed), false otherwise
0000000000000000000000000000000000000000;;	func (c *Cloud) endAttaching(i *awsInstance, volumeID awsVolumeID, mountDevice mountDevice) bool {
0000000000000000000000000000000000000000;;		c.attachingMutex.Lock()
0000000000000000000000000000000000000000;;		defer c.attachingMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		existingVolumeID, found := c.attaching[i.nodeName][mountDevice]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volumeID != existingVolumeID {
0000000000000000000000000000000000000000;;			// This actually can happen, because getMountDevice combines the attaching map with the volumes
0000000000000000000000000000000000000000;;			// attached to the instance (as reported by the EC2 API).  So if endAttaching comes after
0000000000000000000000000000000000000000;;			// a 10 second poll delay, we might well have had a concurrent request to allocate a mountpoint,
0000000000000000000000000000000000000000;;			// which because we allocate sequentially is _very_ likely to get the immediately freed volume
0000000000000000000000000000000000000000;;			glog.Infof("endAttaching on device %q assigned to different volume: %q vs %q", mountDevice, volumeID, existingVolumeID)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Releasing in-process attachment entry: %s -> volume %s", mountDevice, volumeID)
0000000000000000000000000000000000000000;;		delete(c.attaching[i.nodeName], mountDevice)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsDisk struct {
0000000000000000000000000000000000000000;;		ec2 EC2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name in k8s
0000000000000000000000000000000000000000;;		name KubernetesVolumeID
0000000000000000000000000000000000000000;;		// id in AWS
0000000000000000000000000000000000000000;;		awsID awsVolumeID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAWSDisk(aws *Cloud, name KubernetesVolumeID) (*awsDisk, error) {
0000000000000000000000000000000000000000;;		awsID, err := name.mapToAWSVolumeID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disk := &awsDisk{ec2: aws.ec2, name: name, awsID: awsID}
0000000000000000000000000000000000000000;;		return disk, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the full information about this volume from the EC2 API
0000000000000000000000000000000000000000;;	func (d *awsDisk) describeVolume() (*ec2.Volume, error) {
0000000000000000000000000000000000000000;;		volumeID := d.awsID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &ec2.DescribeVolumesInput{
0000000000000000000000000000000000000000;;			VolumeIds: []*string{volumeID.awsString()},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumes, err := d.ec2.DescribeVolumes(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error querying ec2 for volume %q: %q", volumeID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volumes) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no volumes found for volume %q", volumeID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(volumes) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple volumes found for volume %q", volumeID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumes[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForAttachmentStatus polls until the attachment status is the expected value
0000000000000000000000000000000000000000;;	// On success, it returns the last attachment state.
0000000000000000000000000000000000000000;;	func (d *awsDisk) waitForAttachmentStatus(status string) (*ec2.VolumeAttachment, error) {
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: volumeAttachmentStatusInitialDelay,
0000000000000000000000000000000000000000;;			Factor:   volumeAttachmentStatusFactor,
0000000000000000000000000000000000000000;;			Steps:    volumeAttachmentStatusSteps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Because of rate limiting, we often see errors from describeVolume
0000000000000000000000000000000000000000;;		// So we tolerate a limited number of failures.
0000000000000000000000000000000000000000;;		// But once we see more than 10 errors in a row, we return the error
0000000000000000000000000000000000000000;;		describeErrorCount := 0
0000000000000000000000000000000000000000;;		var attachment *ec2.VolumeAttachment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := wait.ExponentialBackoff(backoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			info, err := d.describeVolume()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				describeErrorCount++
0000000000000000000000000000000000000000;;				if describeErrorCount > volumeAttachmentStatusConsecutiveErrorLimit {
0000000000000000000000000000000000000000;;					// report the error
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Warningf("Ignoring error from describe volume; will retry: %q", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				describeErrorCount = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(info.Attachments) > 1 {
0000000000000000000000000000000000000000;;				// Shouldn't happen; log so we know if it is
0000000000000000000000000000000000000000;;				glog.Warningf("Found multiple attachments for volume %q: %v", d.awsID, info)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attachmentStatus := ""
0000000000000000000000000000000000000000;;			for _, a := range info.Attachments {
0000000000000000000000000000000000000000;;				if attachmentStatus != "" {
0000000000000000000000000000000000000000;;					// Shouldn't happen; log so we know if it is
0000000000000000000000000000000000000000;;					glog.Warningf("Found multiple attachments for volume %q: %v", d.awsID, info)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if a.State != nil {
0000000000000000000000000000000000000000;;					attachment = a
0000000000000000000000000000000000000000;;					attachmentStatus = *a.State
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Shouldn't happen; log so we know if it is
0000000000000000000000000000000000000000;;					glog.Warningf("Ignoring nil attachment state for volume %q: %v", d.awsID, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if attachmentStatus == "" {
0000000000000000000000000000000000000000;;				attachmentStatus = "detached"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if attachmentStatus == status {
0000000000000000000000000000000000000000;;				// Attachment is in requested state, finish waiting
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// continue waiting
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Waiting for volume %q state: actual=%s, desired=%s", d.awsID, attachmentStatus, status)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attachment, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes the EBS disk
0000000000000000000000000000000000000000;;	func (d *awsDisk) deleteVolume() (bool, error) {
0000000000000000000000000000000000000000;;		request := &ec2.DeleteVolumeInput{VolumeId: d.awsID.awsString()}
0000000000000000000000000000000000000000;;		_, err := d.ec2.DeleteVolume(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if awsError, ok := err.(awserr.Error); ok {
0000000000000000000000000000000000000000;;				if awsError.Code() == "InvalidVolume.NotFound" {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if awsError.Code() == "VolumeInUse" {
0000000000000000000000000000000000000000;;					return false, volume.NewDeletedVolumeInUseError(err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error deleting EBS volume %q: %q", d.awsID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Builds the awsInstance for the EC2 instance on which we are running.
0000000000000000000000000000000000000000;;	// This is called when the AWSCloud is initialized, and should not be called otherwise (because the awsInstance for the local instance is a singleton with drive mapping state)
0000000000000000000000000000000000000000;;	func (c *Cloud) buildSelfAWSInstance() (*awsInstance, error) {
0000000000000000000000000000000000000000;;		if c.selfAWSInstance != nil {
0000000000000000000000000000000000000000;;			panic("do not call buildSelfAWSInstance directly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instanceID, err := c.metadata.GetMetadata("instance-id")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error fetching instance-id from ec2 metadata service: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We want to fetch the hostname via the EC2 metadata service
0000000000000000000000000000000000000000;;		// (`GetMetadata("local-hostname")`): But see #11543 - we need to use
0000000000000000000000000000000000000000;;		// the EC2 API to get the privateDnsName in case of a private DNS zone
0000000000000000000000000000000000000000;;		// e.g. mydomain.io, because the metadata service returns the wrong
0000000000000000000000000000000000000000;;		// hostname.  Once we're doing that, we might as well get all our
0000000000000000000000000000000000000000;;		// information from the instance returned by the EC2 API - it is a
0000000000000000000000000000000000000000;;		// single API call to get all the information, and it means we don't
0000000000000000000000000000000000000000;;		// have two code paths.
0000000000000000000000000000000000000000;;		instance, err := c.getInstanceByID(instanceID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error finding instance %s: %q", instanceID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newAWSInstance(c.ec2, instance), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the awsInstance with for the node with the specified nodeName, or the 'self' instance if nodeName == ""
0000000000000000000000000000000000000000;;	func (c *Cloud) getAwsInstance(nodeName types.NodeName) (*awsInstance, error) {
0000000000000000000000000000000000000000;;		var awsInstance *awsInstance
0000000000000000000000000000000000000000;;		if nodeName == "" {
0000000000000000000000000000000000000000;;			awsInstance = c.selfAWSInstance
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			instance, err := c.getInstanceByNodeName(nodeName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			awsInstance = newAWSInstance(c.ec2, instance)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return awsInstance, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wrapAttachError wraps the error returned by an AttachVolume request with
0000000000000000000000000000000000000000;;	// additional information, if needed and possible.
0000000000000000000000000000000000000000;;	func wrapAttachError(err error, disk *awsDisk, instance string) error {
0000000000000000000000000000000000000000;;		if awsError, ok := err.(awserr.Error); ok {
0000000000000000000000000000000000000000;;			if awsError.Code() == "VolumeInUse" {
0000000000000000000000000000000000000000;;				info, err := disk.describeVolume()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Error describing volume %q: %q", disk.awsID, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					for _, a := range info.Attachments {
0000000000000000000000000000000000000000;;						if disk.awsID != awsVolumeID(aws.StringValue(a.VolumeId)) {
0000000000000000000000000000000000000000;;							glog.Warningf("Expected to get attachment info of volume %q but instead got info of %q", disk.awsID, aws.StringValue(a.VolumeId))
0000000000000000000000000000000000000000;;						} else if aws.StringValue(a.State) == "attached" {
0000000000000000000000000000000000000000;;							return fmt.Errorf("Error attaching EBS volume %q to instance %q: %q. The volume is currently attached to instance %q", disk.awsID, instance, awsError, aws.StringValue(a.InstanceId))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Error attaching EBS volume %q to instance %q: %q", disk.awsID, instance, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachDisk implements Volumes.AttachDisk
0000000000000000000000000000000000000000;;	func (c *Cloud) AttachDisk(diskName KubernetesVolumeID, nodeName types.NodeName, readOnly bool) (string, error) {
0000000000000000000000000000000000000000;;		disk, err := newAWSDisk(c, diskName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsInstance, info, err := c.getFullInstance(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error finding instance %s: %q", nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if readOnly {
0000000000000000000000000000000000000000;;			// TODO: We could enforce this when we mount the volume (?)
0000000000000000000000000000000000000000;;			// TODO: We could also snapshot the volume and attach copies of it
0000000000000000000000000000000000000000;;			return "", errors.New("AWS volumes cannot be mounted read-only")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mountDevice will hold the device where we should try to attach the disk
0000000000000000000000000000000000000000;;		var mountDevice mountDevice
0000000000000000000000000000000000000000;;		// alreadyAttached is true if we have already called AttachVolume on this disk
0000000000000000000000000000000000000000;;		var alreadyAttached bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attachEnded is set to true if the attach operation completed
0000000000000000000000000000000000000000;;		// (successfully or not), and is thus no longer in progress
0000000000000000000000000000000000000000;;		attachEnded := false
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if attachEnded {
0000000000000000000000000000000000000000;;				if !c.endAttaching(awsInstance, disk.awsID, mountDevice) {
0000000000000000000000000000000000000000;;					glog.Errorf("endAttaching called for disk %q when attach not in progress", disk.awsID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountDevice, alreadyAttached, err = c.getMountDevice(awsInstance, info, disk.awsID, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inside the instance, the mountpoint always looks like /dev/xvdX (?)
0000000000000000000000000000000000000000;;		hostDevice := "/dev/xvd" + string(mountDevice)
0000000000000000000000000000000000000000;;		// We are using xvd names (so we are HVM only)
0000000000000000000000000000000000000000;;		// See http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html
0000000000000000000000000000000000000000;;		ec2Device := "/dev/xvd" + string(mountDevice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !alreadyAttached {
0000000000000000000000000000000000000000;;			request := &ec2.AttachVolumeInput{
0000000000000000000000000000000000000000;;				Device:     aws.String(ec2Device),
0000000000000000000000000000000000000000;;				InstanceId: aws.String(awsInstance.awsID),
0000000000000000000000000000000000000000;;				VolumeId:   disk.awsID.awsString(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attachResponse, err := c.ec2.AttachVolume(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				attachEnded = true
0000000000000000000000000000000000000000;;				// TODO: Check if the volume was concurrently attached?
0000000000000000000000000000000000000000;;				return "", wrapAttachError(err, disk, awsInstance.awsID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if da, ok := c.deviceAllocators[awsInstance.nodeName]; ok {
0000000000000000000000000000000000000000;;				da.Deprioritize(mountDevice)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("AttachVolume volume=%q instance=%q request returned %v", disk.awsID, awsInstance.awsID, attachResponse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachment, err := disk.waitForAttachmentStatus("attached")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The attach operation has finished
0000000000000000000000000000000000000000;;		attachEnded = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Double check the attachment to be 100% sure we attached the correct volume at the correct mountpoint
0000000000000000000000000000000000000000;;		// It could happen otherwise that we see the volume attached from a previous/separate AttachVolume call,
0000000000000000000000000000000000000000;;		// which could theoretically be against a different device (or even instance).
0000000000000000000000000000000000000000;;		if attachment == nil {
0000000000000000000000000000000000000000;;			// Impossible?
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected state: attachment nil after attached %q to %q", diskName, nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ec2Device != aws.StringValue(attachment.Device) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("disk attachment of %q to %q failed: requested device %q but found %q", diskName, nodeName, ec2Device, aws.StringValue(attachment.Device))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if awsInstance.awsID != aws.StringValue(attachment.InstanceId) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("disk attachment of %q to %q failed: requested instance %q but found %q", diskName, nodeName, awsInstance.awsID, aws.StringValue(attachment.InstanceId))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hostDevice, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetachDisk implements Volumes.DetachDisk
0000000000000000000000000000000000000000;;	func (c *Cloud) DetachDisk(diskName KubernetesVolumeID, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		disk, err := newAWSDisk(c, diskName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsInstance, info, err := c.getFullInstance(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == cloudprovider.InstanceNotFound {
0000000000000000000000000000000000000000;;				// If instance no longer exists, safe to assume volume is not attached.
0000000000000000000000000000000000000000;;				glog.Warningf(
0000000000000000000000000000000000000000;;					"Instance %q does not exist. DetachDisk will assume disk %q is not attached to it.",
0000000000000000000000000000000000000000;;					nodeName,
0000000000000000000000000000000000000000;;					diskName)
0000000000000000000000000000000000000000;;				return "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountDevice, alreadyAttached, err := c.getMountDevice(awsInstance, info, disk.awsID, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !alreadyAttached {
0000000000000000000000000000000000000000;;			glog.Warningf("DetachDisk called on non-attached disk: %s", diskName)
0000000000000000000000000000000000000000;;			// TODO: Continue?  Tolerate non-attached error from the AWS DetachVolume call?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := ec2.DetachVolumeInput{
0000000000000000000000000000000000000000;;			InstanceId: &awsInstance.awsID,
0000000000000000000000000000000000000000;;			VolumeId:   disk.awsID.awsString(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := c.ec2.DetachVolume(&request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error detaching EBS volume %q from %q: %q", disk.awsID, awsInstance.awsID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response == nil {
0000000000000000000000000000000000000000;;			return "", errors.New("no response from DetachVolume")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachment, err := disk.waitForAttachmentStatus("detached")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if da, ok := c.deviceAllocators[awsInstance.nodeName]; ok {
0000000000000000000000000000000000000000;;			da.Deprioritize(mountDevice)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if attachment != nil {
0000000000000000000000000000000000000000;;			// We expect it to be nil, it is (maybe) interesting if it is not
0000000000000000000000000000000000000000;;			glog.V(2).Infof("waitForAttachmentStatus returned non-nil attachment with state=detached: %v", attachment)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mountDevice != "" {
0000000000000000000000000000000000000000;;			c.endAttaching(awsInstance, disk.awsID, mountDevice)
0000000000000000000000000000000000000000;;			// We don't check the return value - we don't really expect the attachment to have been
0000000000000000000000000000000000000000;;			// in progress, though it might have been
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostDevicePath := "/dev/xvd" + string(mountDevice)
0000000000000000000000000000000000000000;;		return hostDevicePath, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateDisk implements Volumes.CreateDisk
0000000000000000000000000000000000000000;;	func (c *Cloud) CreateDisk(volumeOptions *VolumeOptions) (KubernetesVolumeID, error) {
0000000000000000000000000000000000000000;;		allZones, err := c.getCandidateZonesForDynamicVolume()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error querying for all zones: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var createAZ string
0000000000000000000000000000000000000000;;		if !volumeOptions.ZonePresent && !volumeOptions.ZonesPresent {
0000000000000000000000000000000000000000;;			createAZ = volume.ChooseZoneForVolume(allZones, volumeOptions.PVCName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !volumeOptions.ZonePresent && volumeOptions.ZonesPresent {
0000000000000000000000000000000000000000;;			if adminSetOfZones, err := volume.ZonesToSet(volumeOptions.AvailabilityZones); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				createAZ = volume.ChooseZoneForVolume(adminSetOfZones, volumeOptions.PVCName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volumeOptions.ZonePresent && !volumeOptions.ZonesPresent {
0000000000000000000000000000000000000000;;			if err := volume.ValidateZone(volumeOptions.AvailabilityZone); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			createAZ = volumeOptions.AvailabilityZone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var createType string
0000000000000000000000000000000000000000;;		var iops int64
0000000000000000000000000000000000000000;;		switch volumeOptions.VolumeType {
0000000000000000000000000000000000000000;;		case VolumeTypeGP2, VolumeTypeSC1, VolumeTypeST1:
0000000000000000000000000000000000000000;;			createType = volumeOptions.VolumeType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case VolumeTypeIO1:
0000000000000000000000000000000000000000;;			// See http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateVolume.html
0000000000000000000000000000000000000000;;			// for IOPS constraints. AWS will throw an error if IOPS per GB gets out
0000000000000000000000000000000000000000;;			// of supported bounds, no need to check it here.
0000000000000000000000000000000000000000;;			createType = volumeOptions.VolumeType
0000000000000000000000000000000000000000;;			iops = int64(volumeOptions.CapacityGB * volumeOptions.IOPSPerGB)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Cap at min/max total IOPS, AWS would throw an error if it gets too
0000000000000000000000000000000000000000;;			// low/high.
0000000000000000000000000000000000000000;;			if iops < MinTotalIOPS {
0000000000000000000000000000000000000000;;				iops = MinTotalIOPS
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if iops > MaxTotalIOPS {
0000000000000000000000000000000000000000;;				iops = MaxTotalIOPS
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			createType = DefaultVolumeType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid AWS VolumeType %q", volumeOptions.VolumeType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Should we tag this with the cluster id (so it gets deleted when the cluster does?)
0000000000000000000000000000000000000000;;		request := &ec2.CreateVolumeInput{}
0000000000000000000000000000000000000000;;		request.AvailabilityZone = aws.String(createAZ)
0000000000000000000000000000000000000000;;		request.Size = aws.Int64(int64(volumeOptions.CapacityGB))
0000000000000000000000000000000000000000;;		request.VolumeType = aws.String(createType)
0000000000000000000000000000000000000000;;		request.Encrypted = aws.Bool(volumeOptions.Encrypted)
0000000000000000000000000000000000000000;;		if len(volumeOptions.KmsKeyId) > 0 {
0000000000000000000000000000000000000000;;			request.KmsKeyId = aws.String(volumeOptions.KmsKeyId)
0000000000000000000000000000000000000000;;			request.Encrypted = aws.Bool(true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if iops > 0 {
0000000000000000000000000000000000000000;;			request.Iops = aws.Int64(iops)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := c.ec2.CreateVolume(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsID := awsVolumeID(aws.StringValue(response.VolumeId))
0000000000000000000000000000000000000000;;		if awsID == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("VolumeID was not returned by CreateVolume")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeName := KubernetesVolumeID("aws://" + aws.StringValue(response.AvailabilityZone) + "/" + string(awsID))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// apply tags
0000000000000000000000000000000000000000;;		if err := c.tagging.createTags(c.ec2, string(awsID), ResourceLifecycleOwned, volumeOptions.Tags); err != nil {
0000000000000000000000000000000000000000;;			// delete the volume and hope it succeeds
0000000000000000000000000000000000000000;;			_, delerr := c.DeleteDisk(volumeName)
0000000000000000000000000000000000000000;;			if delerr != nil {
0000000000000000000000000000000000000000;;				// delete did not succeed, we have a stray volume!
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("error tagging volume %s, could not delete the volume: %q", volumeName, delerr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error tagging volume %s: %q", volumeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteDisk implements Volumes.DeleteDisk
0000000000000000000000000000000000000000;;	func (c *Cloud) DeleteDisk(volumeName KubernetesVolumeID) (bool, error) {
0000000000000000000000000000000000000000;;		awsDisk, err := newAWSDisk(c, volumeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return awsDisk.deleteVolume()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetVolumeLabels implements Volumes.GetVolumeLabels
0000000000000000000000000000000000000000;;	func (c *Cloud) GetVolumeLabels(volumeName KubernetesVolumeID) (map[string]string, error) {
0000000000000000000000000000000000000000;;		awsDisk, err := newAWSDisk(c, volumeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, err := awsDisk.describeVolume()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		az := aws.StringValue(info.AvailabilityZone)
0000000000000000000000000000000000000000;;		if az == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("volume did not have AZ information: %q", info.VolumeId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels[kubeletapis.LabelZoneFailureDomain] = az
0000000000000000000000000000000000000000;;		region, err := azToRegion(az)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels[kubeletapis.LabelZoneRegion] = region
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDiskPath implements Volumes.GetDiskPath
0000000000000000000000000000000000000000;;	func (c *Cloud) GetDiskPath(volumeName KubernetesVolumeID) (string, error) {
0000000000000000000000000000000000000000;;		awsDisk, err := newAWSDisk(c, volumeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, err := awsDisk.describeVolume()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(info.Attachments) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("No attachment to volume %s", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return aws.StringValue(info.Attachments[0].Device), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiskIsAttached implements Volumes.DiskIsAttached
0000000000000000000000000000000000000000;;	func (c *Cloud) DiskIsAttached(diskName KubernetesVolumeID, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		_, instance, err := c.getFullInstance(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == cloudprovider.InstanceNotFound {
0000000000000000000000000000000000000000;;				// If instance no longer exists, safe to assume volume is not attached.
0000000000000000000000000000000000000000;;				glog.Warningf(
0000000000000000000000000000000000000000;;					"Instance %q does not exist. DiskIsAttached will assume disk %q is not attached to it.",
0000000000000000000000000000000000000000;;					nodeName,
0000000000000000000000000000000000000000;;					diskName)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskID, err := diskName.mapToAWSVolumeID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error mapping volume spec %q to aws id: %v", diskName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, blockDevice := range instance.BlockDeviceMappings {
0000000000000000000000000000000000000000;;			id := awsVolumeID(aws.StringValue(blockDevice.Ebs.VolumeId))
0000000000000000000000000000000000000000;;			if id == diskID {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) DisksAreAttached(nodeDisks map[types.NodeName][]KubernetesVolumeID) (map[types.NodeName]map[KubernetesVolumeID]bool, error) {
0000000000000000000000000000000000000000;;		attached := make(map[types.NodeName]map[KubernetesVolumeID]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(nodeDisks) == 0 {
0000000000000000000000000000000000000000;;			return attached, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeNames := []string{}
0000000000000000000000000000000000000000;;		for nodeName, diskNames := range nodeDisks {
0000000000000000000000000000000000000000;;			for _, diskName := range diskNames {
0000000000000000000000000000000000000000;;				setNodeDisk(attached, diskName, nodeName, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nodeNames = append(nodeNames, mapNodeNameToPrivateDNSName(nodeName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note that we get instances regardless of state.
0000000000000000000000000000000000000000;;		// This means there might be multiple nodes with the same node names.
0000000000000000000000000000000000000000;;		awsInstances, err := c.getInstancesByNodeNames(nodeNames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// When there is an error fetching instance information
0000000000000000000000000000000000000000;;			// it is safer to return nil and let volume information not be touched.
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(awsInstances) == 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("DisksAreAttached found no instances matching node names; will assume disks not attached")
0000000000000000000000000000000000000000;;			return attached, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note that we check that the volume is attached to the correct node, not that it is attached to _a_ node
0000000000000000000000000000000000000000;;		for _, awsInstance := range awsInstances {
0000000000000000000000000000000000000000;;			nodeName := mapInstanceToNodeName(awsInstance)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			diskNames := nodeDisks[nodeName]
0000000000000000000000000000000000000000;;			if len(diskNames) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			awsInstanceState := "<nil>"
0000000000000000000000000000000000000000;;			if awsInstance != nil && awsInstance.State != nil {
0000000000000000000000000000000000000000;;				awsInstanceState = aws.StringValue(awsInstance.State.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if awsInstanceState == "terminated" {
0000000000000000000000000000000000000000;;				// Instance is terminated, safe to assume volumes not attached
0000000000000000000000000000000000000000;;				// Note that we keep volumes attached to instances in other states (most notably, stopped)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			idToDiskName := make(map[awsVolumeID]KubernetesVolumeID)
0000000000000000000000000000000000000000;;			for _, diskName := range diskNames {
0000000000000000000000000000000000000000;;				volumeID, err := diskName.mapToAWSVolumeID()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("error mapping volume spec %q to aws id: %v", diskName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				idToDiskName[volumeID] = diskName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, blockDevice := range awsInstance.BlockDeviceMappings {
0000000000000000000000000000000000000000;;				volumeID := awsVolumeID(aws.StringValue(blockDevice.Ebs.VolumeId))
0000000000000000000000000000000000000000;;				diskName, found := idToDiskName[volumeID]
0000000000000000000000000000000000000000;;				if found {
0000000000000000000000000000000000000000;;					// Disk is still attached to node
0000000000000000000000000000000000000000;;					setNodeDisk(attached, diskName, nodeName, true)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attached, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the current load balancer state
0000000000000000000000000000000000000000;;	func (c *Cloud) describeLoadBalancer(name string) (*elb.LoadBalancerDescription, error) {
0000000000000000000000000000000000000000;;		request := &elb.DescribeLoadBalancersInput{}
0000000000000000000000000000000000000000;;		request.LoadBalancerNames = []*string{&name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := c.elb.DescribeLoadBalancers(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if awsError, ok := err.(awserr.Error); ok {
0000000000000000000000000000000000000000;;				if awsError.Code() == "LoadBalancerNotFound" {
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ret *elb.LoadBalancerDescription
0000000000000000000000000000000000000000;;		for _, loadBalancer := range response.LoadBalancerDescriptions {
0000000000000000000000000000000000000000;;			if ret != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Found multiple load balancers with name: %s", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret = loadBalancer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieves instance's vpc id from metadata
0000000000000000000000000000000000000000;;	func (c *Cloud) findVPCID() (string, error) {
0000000000000000000000000000000000000000;;		macs, err := c.metadata.GetMetadata("network/interfaces/macs/")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Could not list interfaces of the instance: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// loop over interfaces, first vpc id returned wins
0000000000000000000000000000000000000000;;		for _, macPath := range strings.Split(macs, "\n") {
0000000000000000000000000000000000000000;;			if len(macPath) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			url := fmt.Sprintf("network/interfaces/macs/%svpc-id", macPath)
0000000000000000000000000000000000000000;;			vpcID, err := c.metadata.GetMetadata(url)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return vpcID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("Could not find VPC ID in instance metadata")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieves the specified security group from the AWS API, or returns nil if not found
0000000000000000000000000000000000000000;;	func (c *Cloud) findSecurityGroup(securityGroupID string) (*ec2.SecurityGroup, error) {
0000000000000000000000000000000000000000;;		describeSecurityGroupsRequest := &ec2.DescribeSecurityGroupsInput{
0000000000000000000000000000000000000000;;			GroupIds: []*string{&securityGroupID},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We don't apply our tag filters because we are retrieving by ID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups, err := c.ec2.DescribeSecurityGroups(describeSecurityGroupsRequest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error retrieving security group: %q", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(groups) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(groups) != 1 {
0000000000000000000000000000000000000000;;			// This should not be possible - ids should be unique
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple security groups found with same id %q", securityGroupID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		group := groups[0]
0000000000000000000000000000000000000000;;		return group, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEqualIntPointer(l, r *int64) bool {
0000000000000000000000000000000000000000;;		if l == nil {
0000000000000000000000000000000000000000;;			return r == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return l == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *l == *r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEqualStringPointer(l, r *string) bool {
0000000000000000000000000000000000000000;;		if l == nil {
0000000000000000000000000000000000000000;;			return r == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return l == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *l == *r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ipPermissionExists(newPermission, existing *ec2.IpPermission, compareGroupUserIDs bool) bool {
0000000000000000000000000000000000000000;;		if !isEqualIntPointer(newPermission.FromPort, existing.FromPort) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isEqualIntPointer(newPermission.ToPort, existing.ToPort) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isEqualStringPointer(newPermission.IpProtocol, existing.IpProtocol) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check only if newPermission is a subset of existing. Usually it has zero or one elements.
0000000000000000000000000000000000000000;;		// Not doing actual CIDR math yet; not clear it's needed, either.
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Comparing %v to %v", newPermission, existing)
0000000000000000000000000000000000000000;;		if len(newPermission.IpRanges) > len(existing.IpRanges) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for j := range newPermission.IpRanges {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for k := range existing.IpRanges {
0000000000000000000000000000000000000000;;				if isEqualStringPointer(newPermission.IpRanges[j].CidrIp, existing.IpRanges[k].CidrIp) {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, leftPair := range newPermission.UserIdGroupPairs {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, rightPair := range existing.UserIdGroupPairs {
0000000000000000000000000000000000000000;;				if isEqualUserGroupPair(leftPair, rightPair, compareGroupUserIDs) {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEqualUserGroupPair(l, r *ec2.UserIdGroupPair, compareGroupUserIDs bool) bool {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Comparing %v to %v", *l.GroupId, *r.GroupId)
0000000000000000000000000000000000000000;;		if isEqualStringPointer(l.GroupId, r.GroupId) {
0000000000000000000000000000000000000000;;			if compareGroupUserIDs {
0000000000000000000000000000000000000000;;				if isEqualStringPointer(l.UserId, r.UserId) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes sure the security group ingress is exactly the specified permissions
0000000000000000000000000000000000000000;;	// Returns true if and only if changes were made
0000000000000000000000000000000000000000;;	// The security group must already exist
0000000000000000000000000000000000000000;;	func (c *Cloud) setSecurityGroupIngress(securityGroupID string, permissions IPPermissionSet) (bool, error) {
0000000000000000000000000000000000000000;;		group, err := c.findSecurityGroup(securityGroupID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error retrieving security group %q", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if group == nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("security group not found: %s", securityGroupID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Existing security group ingress: %s %v", securityGroupID, group.IpPermissions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual := NewIPPermissionSet(group.IpPermissions...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EC2 groups rules together, for example combining:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// { Port=80, Range=[A] } and { Port=80, Range=[B] }
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// into { Port=80, Range=[A,B] }
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We have to ungroup them, because otherwise the logic becomes really
0000000000000000000000000000000000000000;;		// complicated, and also because if we have Range=[A,B] and we try to
0000000000000000000000000000000000000000;;		// add Range=[A] then EC2 complains about a duplicate rule.
0000000000000000000000000000000000000000;;		permissions = permissions.Ungroup()
0000000000000000000000000000000000000000;;		actual = actual.Ungroup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remove := actual.Difference(permissions)
0000000000000000000000000000000000000000;;		add := permissions.Difference(actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if add.Len() == 0 && remove.Len() == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: There is a limit in VPC of 100 rules per security group, so we
0000000000000000000000000000000000000000;;		// probably should try grouping or combining to fit under this limit.
0000000000000000000000000000000000000000;;		// But this is only used on the ELB security group currently, so it
0000000000000000000000000000000000000000;;		// would require (ports * CIDRS) > 100.  Also, it isn't obvious exactly
0000000000000000000000000000000000000000;;		// how removing single permissions from compound rules works, and we
0000000000000000000000000000000000000000;;		// don't want to accidentally open more than intended while we're
0000000000000000000000000000000000000000;;		// applying changes.
0000000000000000000000000000000000000000;;		if add.Len() != 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Adding security group ingress: %s %v", securityGroupID, add.List())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := &ec2.AuthorizeSecurityGroupIngressInput{}
0000000000000000000000000000000000000000;;			request.GroupId = &securityGroupID
0000000000000000000000000000000000000000;;			request.IpPermissions = add.List()
0000000000000000000000000000000000000000;;			_, err = c.ec2.AuthorizeSecurityGroupIngress(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("error authorizing security group ingress: %q", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if remove.Len() != 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Remove security group ingress: %s %v", securityGroupID, remove.List())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := &ec2.RevokeSecurityGroupIngressInput{}
0000000000000000000000000000000000000000;;			request.GroupId = &securityGroupID
0000000000000000000000000000000000000000;;			request.IpPermissions = remove.List()
0000000000000000000000000000000000000000;;			_, err = c.ec2.RevokeSecurityGroupIngress(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("error revoking security group ingress: %q", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes sure the security group includes the specified permissions
0000000000000000000000000000000000000000;;	// Returns true if and only if changes were made
0000000000000000000000000000000000000000;;	// The security group must already exist
0000000000000000000000000000000000000000;;	func (c *Cloud) addSecurityGroupIngress(securityGroupID string, addPermissions []*ec2.IpPermission) (bool, error) {
0000000000000000000000000000000000000000;;		group, err := c.findSecurityGroup(securityGroupID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error retrieving security group: %q", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if group == nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("security group not found: %s", securityGroupID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Existing security group ingress: %s %v", securityGroupID, group.IpPermissions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes := []*ec2.IpPermission{}
0000000000000000000000000000000000000000;;		for _, addPermission := range addPermissions {
0000000000000000000000000000000000000000;;			hasUserID := false
0000000000000000000000000000000000000000;;			for i := range addPermission.UserIdGroupPairs {
0000000000000000000000000000000000000000;;				if addPermission.UserIdGroupPairs[i].UserId != nil {
0000000000000000000000000000000000000000;;					hasUserID = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, groupPermission := range group.IpPermissions {
0000000000000000000000000000000000000000;;				if ipPermissionExists(addPermission, groupPermission, hasUserID) {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				changes = append(changes, addPermission)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(changes) == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Adding security group ingress: %s %v", securityGroupID, changes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &ec2.AuthorizeSecurityGroupIngressInput{}
0000000000000000000000000000000000000000;;		request.GroupId = &securityGroupID
0000000000000000000000000000000000000000;;		request.IpPermissions = changes
0000000000000000000000000000000000000000;;		_, err = c.ec2.AuthorizeSecurityGroupIngress(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error authorizing security group ingress %q", err)
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("error authorizing security group ingress: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes sure the security group no longer includes the specified permissions
0000000000000000000000000000000000000000;;	// Returns true if and only if changes were made
0000000000000000000000000000000000000000;;	// If the security group no longer exists, will return (false, nil)
0000000000000000000000000000000000000000;;	func (c *Cloud) removeSecurityGroupIngress(securityGroupID string, removePermissions []*ec2.IpPermission) (bool, error) {
0000000000000000000000000000000000000000;;		group, err := c.findSecurityGroup(securityGroupID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error retrieving security group: %q", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if group == nil {
0000000000000000000000000000000000000000;;			glog.Warning("Security group not found: ", securityGroupID)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes := []*ec2.IpPermission{}
0000000000000000000000000000000000000000;;		for _, removePermission := range removePermissions {
0000000000000000000000000000000000000000;;			hasUserID := false
0000000000000000000000000000000000000000;;			for i := range removePermission.UserIdGroupPairs {
0000000000000000000000000000000000000000;;				if removePermission.UserIdGroupPairs[i].UserId != nil {
0000000000000000000000000000000000000000;;					hasUserID = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var found *ec2.IpPermission
0000000000000000000000000000000000000000;;			for _, groupPermission := range group.IpPermissions {
0000000000000000000000000000000000000000;;				if ipPermissionExists(removePermission, groupPermission, hasUserID) {
0000000000000000000000000000000000000000;;					found = removePermission
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if found != nil {
0000000000000000000000000000000000000000;;				changes = append(changes, found)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(changes) == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Removing security group ingress: %s %v", securityGroupID, changes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &ec2.RevokeSecurityGroupIngressInput{}
0000000000000000000000000000000000000000;;		request.GroupId = &securityGroupID
0000000000000000000000000000000000000000;;		request.IpPermissions = changes
0000000000000000000000000000000000000000;;		_, err = c.ec2.RevokeSecurityGroupIngress(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error revoking security group ingress: %q", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes sure the security group exists.
0000000000000000000000000000000000000000;;	// For multi-cluster isolation, name must be globally unique, for example derived from the service UUID.
0000000000000000000000000000000000000000;;	// Returns the security group id or error
0000000000000000000000000000000000000000;;	func (c *Cloud) ensureSecurityGroup(name string, description string) (string, error) {
0000000000000000000000000000000000000000;;		groupID := ""
0000000000000000000000000000000000000000;;		attempt := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			attempt++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := &ec2.DescribeSecurityGroupsInput{}
0000000000000000000000000000000000000000;;			filters := []*ec2.Filter{
0000000000000000000000000000000000000000;;				newEc2Filter("group-name", name),
0000000000000000000000000000000000000000;;				newEc2Filter("vpc-id", c.vpcID),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Note that we do _not_ add our tag filters; group-name + vpc-id is the EC2 primary key.
0000000000000000000000000000000000000000;;			// However, we do check that it matches our tags.
0000000000000000000000000000000000000000;;			// If it doesn't have any tags, we tag it; this is how we recover if we failed to tag before.
0000000000000000000000000000000000000000;;			// If it has a different cluster's tags, that is an error.
0000000000000000000000000000000000000000;;			// This shouldn't happen because name is expected to be globally unique (UUID derived)
0000000000000000000000000000000000000000;;			request.Filters = filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			securityGroups, err := c.ec2.DescribeSecurityGroups(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(securityGroups) >= 1 {
0000000000000000000000000000000000000000;;				if len(securityGroups) > 1 {
0000000000000000000000000000000000000000;;					glog.Warningf("Found multiple security groups with name: %q", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := c.tagging.readRepairClusterTags(
0000000000000000000000000000000000000000;;					c.ec2, aws.StringValue(securityGroups[0].GroupId),
0000000000000000000000000000000000000000;;					ResourceLifecycleOwned, nil, securityGroups[0].Tags)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return aws.StringValue(securityGroups[0].GroupId), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createRequest := &ec2.CreateSecurityGroupInput{}
0000000000000000000000000000000000000000;;			createRequest.VpcId = &c.vpcID
0000000000000000000000000000000000000000;;			createRequest.GroupName = &name
0000000000000000000000000000000000000000;;			createRequest.Description = &description
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			createResponse, err := c.ec2.CreateSecurityGroup(createRequest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				ignore := false
0000000000000000000000000000000000000000;;				switch err := err.(type) {
0000000000000000000000000000000000000000;;				case awserr.Error:
0000000000000000000000000000000000000000;;					if err.Code() == "InvalidGroup.Duplicate" && attempt < MaxReadThenCreateRetries {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Got InvalidGroup.Duplicate while creating security group (race?); will retry")
0000000000000000000000000000000000000000;;						ignore = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !ignore {
0000000000000000000000000000000000000000;;					glog.Errorf("Error creating security group: %q", err)
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				groupID = orEmpty(createResponse.GroupId)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if groupID == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("created security group, but id was not returned: %s", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.tagging.createTags(c.ec2, groupID, ResourceLifecycleOwned, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If we retry, ensureClusterTags will recover from this - it
0000000000000000000000000000000000000000;;			// will add the missing tags.  We could delete the security
0000000000000000000000000000000000000000;;			// group here, but that doesn't feel like the right thing, as
0000000000000000000000000000000000000000;;			// the caller is likely to retry the create
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error tagging security group: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return groupID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Finds the value for a given tag.
0000000000000000000000000000000000000000;;	func findTag(tags []*ec2.Tag, key string) (string, bool) {
0000000000000000000000000000000000000000;;		for _, tag := range tags {
0000000000000000000000000000000000000000;;			if aws.StringValue(tag.Key) == key {
0000000000000000000000000000000000000000;;				return aws.StringValue(tag.Value), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Finds the subnets associated with the cluster, by matching tags.
0000000000000000000000000000000000000000;;	// For maximal backwards compatibility, if no subnets are tagged, it will fall-back to the current subnet.
0000000000000000000000000000000000000000;;	// However, in future this will likely be treated as an error.
0000000000000000000000000000000000000000;;	func (c *Cloud) findSubnets() ([]*ec2.Subnet, error) {
0000000000000000000000000000000000000000;;		request := &ec2.DescribeSubnetsInput{}
0000000000000000000000000000000000000000;;		filters := []*ec2.Filter{newEc2Filter("vpc-id", c.vpcID)}
0000000000000000000000000000000000000000;;		request.Filters = c.tagging.addFilters(filters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subnets, err := c.ec2.DescribeSubnets(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error describing subnets: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var matches []*ec2.Subnet
0000000000000000000000000000000000000000;;		for _, subnet := range subnets {
0000000000000000000000000000000000000000;;			if c.tagging.hasClusterTag(subnet.Tags) {
0000000000000000000000000000000000000000;;				matches = append(matches, subnet)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(matches) != 0 {
0000000000000000000000000000000000000000;;			return matches, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fall back to the current instance subnets, if nothing is tagged
0000000000000000000000000000000000000000;;		glog.Warningf("No tagged subnets found; will fall-back to the current subnet only.  This is likely to be an error in a future version of k8s.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request = &ec2.DescribeSubnetsInput{}
0000000000000000000000000000000000000000;;		filters = []*ec2.Filter{newEc2Filter("subnet-id", c.selfAWSInstance.subnetID)}
0000000000000000000000000000000000000000;;		request.Filters = filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subnets, err = c.ec2.DescribeSubnets(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error describing subnets: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return subnets, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Finds the subnets to use for an ELB we are creating.
0000000000000000000000000000000000000000;;	// Normal (Internet-facing) ELBs must use public subnets, so we skip private subnets.
0000000000000000000000000000000000000000;;	// Internal ELBs can use public or private subnets, but if we have a private subnet we should prefer that.
0000000000000000000000000000000000000000;;	func (c *Cloud) findELBSubnets(internalELB bool) ([]string, error) {
0000000000000000000000000000000000000000;;		vpcIDFilter := newEc2Filter("vpc-id", c.vpcID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subnets, err := c.findSubnets()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rRequest := &ec2.DescribeRouteTablesInput{}
0000000000000000000000000000000000000000;;		rRequest.Filters = []*ec2.Filter{vpcIDFilter}
0000000000000000000000000000000000000000;;		rt, err := c.ec2.DescribeRouteTables(rRequest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error describe route table: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subnetsByAZ := make(map[string]*ec2.Subnet)
0000000000000000000000000000000000000000;;		for _, subnet := range subnets {
0000000000000000000000000000000000000000;;			az := aws.StringValue(subnet.AvailabilityZone)
0000000000000000000000000000000000000000;;			id := aws.StringValue(subnet.SubnetId)
0000000000000000000000000000000000000000;;			if az == "" || id == "" {
0000000000000000000000000000000000000000;;				glog.Warningf("Ignoring subnet with empty az/id: %v", subnet)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isPublic, err := isSubnetPublic(rt, id)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !internalELB && !isPublic {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Ignoring private subnet for public ELB %q", id)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			existing := subnetsByAZ[az]
0000000000000000000000000000000000000000;;			if existing == nil {
0000000000000000000000000000000000000000;;				subnetsByAZ[az] = subnet
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to break the tie using a tag
0000000000000000000000000000000000000000;;			var tagName string
0000000000000000000000000000000000000000;;			if internalELB {
0000000000000000000000000000000000000000;;				tagName = TagNameSubnetInternalELB
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tagName = TagNameSubnetPublicELB
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, existingHasTag := findTag(existing.Tags, tagName)
0000000000000000000000000000000000000000;;			_, subnetHasTag := findTag(subnet.Tags, tagName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if existingHasTag != subnetHasTag {
0000000000000000000000000000000000000000;;				if subnetHasTag {
0000000000000000000000000000000000000000;;					subnetsByAZ[az] = subnet
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: Should this be an error?
0000000000000000000000000000000000000000;;			glog.Warningf("Found multiple subnets in AZ %q; making arbitrary choice between subnets %q and %q", az, *existing.SubnetId, *subnet.SubnetId)
0000000000000000000000000000000000000000;;			continue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var subnetIDs []string
0000000000000000000000000000000000000000;;		for _, subnet := range subnetsByAZ {
0000000000000000000000000000000000000000;;			subnetIDs = append(subnetIDs, aws.StringValue(subnet.SubnetId))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return subnetIDs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSubnetPublic(rt []*ec2.RouteTable, subnetID string) (bool, error) {
0000000000000000000000000000000000000000;;		var subnetTable *ec2.RouteTable
0000000000000000000000000000000000000000;;		for _, table := range rt {
0000000000000000000000000000000000000000;;			for _, assoc := range table.Associations {
0000000000000000000000000000000000000000;;				if aws.StringValue(assoc.SubnetId) == subnetID {
0000000000000000000000000000000000000000;;					subnetTable = table
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if subnetTable == nil {
0000000000000000000000000000000000000000;;			// If there is no explicit association, the subnet will be implicitly
0000000000000000000000000000000000000000;;			// associated with the VPC's main routing table.
0000000000000000000000000000000000000000;;			for _, table := range rt {
0000000000000000000000000000000000000000;;				for _, assoc := range table.Associations {
0000000000000000000000000000000000000000;;					if aws.BoolValue(assoc.Main) == true {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Assuming implicit use of main routing table %s for %s",
0000000000000000000000000000000000000000;;							aws.StringValue(table.RouteTableId), subnetID)
0000000000000000000000000000000000000000;;						subnetTable = table
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if subnetTable == nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Could not locate routing table for subnet %s", subnetID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, route := range subnetTable.Routes {
0000000000000000000000000000000000000000;;			// There is no direct way in the AWS API to determine if a subnet is public or private.
0000000000000000000000000000000000000000;;			// A public subnet is one which has an internet gateway route
0000000000000000000000000000000000000000;;			// we look for the gatewayId and make sure it has the prefix of igw to differentiate
0000000000000000000000000000000000000000;;			// from the default in-subnet route which is called "local"
0000000000000000000000000000000000000000;;			// or other virtual gateway (starting with vgv)
0000000000000000000000000000000000000000;;			// or vpc peering connections (starting with pcx).
0000000000000000000000000000000000000000;;			if strings.HasPrefix(aws.StringValue(route.GatewayId), "igw") {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portSets struct {
0000000000000000000000000000000000000000;;		names   sets.String
0000000000000000000000000000000000000000;;		numbers sets.Int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPortSets returns a portSets structure representing port names and numbers
0000000000000000000000000000000000000000;;	// that the comma-separated string describes. If the input is empty or equal to
0000000000000000000000000000000000000000;;	// "*", a nil pointer is returned.
0000000000000000000000000000000000000000;;	func getPortSets(annotation string) (ports *portSets) {
0000000000000000000000000000000000000000;;		if annotation != "" && annotation != "*" {
0000000000000000000000000000000000000000;;			ports = &portSets{
0000000000000000000000000000000000000000;;				sets.NewString(),
0000000000000000000000000000000000000000;;				sets.NewInt64(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			portStringSlice := strings.Split(annotation, ",")
0000000000000000000000000000000000000000;;			for _, item := range portStringSlice {
0000000000000000000000000000000000000000;;				port, err := strconv.Atoi(item)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					ports.names.Insert(item)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ports.numbers.Insert(int64(port))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildELBSecurityGroupList returns list of SecurityGroups which should be
0000000000000000000000000000000000000000;;	// attached to ELB created by a service. List always consist of at least
0000000000000000000000000000000000000000;;	// 1 member which is an SG created for this service. Extra groups can be
0000000000000000000000000000000000000000;;	// specified via annotation
0000000000000000000000000000000000000000;;	func (c *Cloud) buildELBSecurityGroupList(serviceName types.NamespacedName, loadBalancerName, annotation string) ([]string, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var securityGroupID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.cfg.Global.ElbSecurityGroup != "" {
0000000000000000000000000000000000000000;;			securityGroupID = c.cfg.Global.ElbSecurityGroup
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Create a security group for the load balancer
0000000000000000000000000000000000000000;;			sgName := "k8s-elb-" + loadBalancerName
0000000000000000000000000000000000000000;;			sgDescription := fmt.Sprintf("Security group for Kubernetes ELB %s (%v)", loadBalancerName, serviceName)
0000000000000000000000000000000000000000;;			securityGroupID, err = c.ensureSecurityGroup(sgName, sgDescription)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error creating load balancer security group: %q", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sgList := []string{securityGroupID}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, extraSG := range strings.Split(annotation, ",") {
0000000000000000000000000000000000000000;;			extraSG = strings.TrimSpace(extraSG)
0000000000000000000000000000000000000000;;			if len(extraSG) > 0 {
0000000000000000000000000000000000000000;;				sgList = append(sgList, extraSG)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sgList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildListener creates a new listener from the given port, adding an SSL certificate
0000000000000000000000000000000000000000;;	// if indicated by the appropriate annotations.
0000000000000000000000000000000000000000;;	func buildListener(port v1.ServicePort, annotations map[string]string, sslPorts *portSets) (*elb.Listener, error) {
0000000000000000000000000000000000000000;;		loadBalancerPort := int64(port.Port)
0000000000000000000000000000000000000000;;		portName := strings.ToLower(port.Name)
0000000000000000000000000000000000000000;;		instancePort := int64(port.NodePort)
0000000000000000000000000000000000000000;;		protocol := strings.ToLower(string(port.Protocol))
0000000000000000000000000000000000000000;;		instanceProtocol := protocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listener := &elb.Listener{}
0000000000000000000000000000000000000000;;		listener.InstancePort = &instancePort
0000000000000000000000000000000000000000;;		listener.LoadBalancerPort = &loadBalancerPort
0000000000000000000000000000000000000000;;		certID := annotations[ServiceAnnotationLoadBalancerCertificate]
0000000000000000000000000000000000000000;;		if certID != "" && (sslPorts == nil || sslPorts.numbers.Has(loadBalancerPort) || sslPorts.names.Has(portName)) {
0000000000000000000000000000000000000000;;			instanceProtocol = annotations[ServiceAnnotationLoadBalancerBEProtocol]
0000000000000000000000000000000000000000;;			if instanceProtocol == "" {
0000000000000000000000000000000000000000;;				protocol = "ssl"
0000000000000000000000000000000000000000;;				instanceProtocol = "tcp"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				protocol = backendProtocolMapping[instanceProtocol]
0000000000000000000000000000000000000000;;				if protocol == "" {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Invalid backend protocol %s for %s in %s", instanceProtocol, certID, ServiceAnnotationLoadBalancerBEProtocol)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			listener.SSLCertificateId = &certID
0000000000000000000000000000000000000000;;		} else if annotationProtocol := annotations[ServiceAnnotationLoadBalancerBEProtocol]; annotationProtocol == "http" {
0000000000000000000000000000000000000000;;			instanceProtocol = annotationProtocol
0000000000000000000000000000000000000000;;			protocol = "http"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listener.Protocol = &protocol
0000000000000000000000000000000000000000;;		listener.InstanceProtocol = &instanceProtocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return listener, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancer implements LoadBalancer.EnsureLoadBalancer
0000000000000000000000000000000000000000;;	func (c *Cloud) EnsureLoadBalancer(clusterName string, apiService *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		annotations := apiService.Annotations
0000000000000000000000000000000000000000;;		glog.V(2).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v, %v, %v, %v)",
0000000000000000000000000000000000000000;;			clusterName, apiService.Namespace, apiService.Name, c.region, apiService.Spec.LoadBalancerIP, apiService.Spec.Ports, nodes, annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if apiService.Spec.SessionAffinity != v1.ServiceAffinityNone {
0000000000000000000000000000000000000000;;			// ELB supports sticky sessions, but only when configured for HTTP/HTTPS
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported load balancer affinity: %v", apiService.Spec.SessionAffinity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(apiService.Spec.Ports) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("requested load balancer with no ports")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Figure out what mappings we want on the load balancer
0000000000000000000000000000000000000000;;		listeners := []*elb.Listener{}
0000000000000000000000000000000000000000;;		portList := getPortSets(annotations[ServiceAnnotationLoadBalancerSSLPorts])
0000000000000000000000000000000000000000;;		for _, port := range apiService.Spec.Ports {
0000000000000000000000000000000000000000;;			if port.Protocol != v1.ProtocolTCP {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Only TCP LoadBalancer is supported for AWS ELB")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if port.NodePort == 0 {
0000000000000000000000000000000000000000;;				glog.Errorf("Ignoring port without NodePort defined: %v", port)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			listener, err := buildListener(port, annotations, portList)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			listeners = append(listeners, listener)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if apiService.Spec.LoadBalancerIP != "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("LoadBalancerIP cannot be specified for AWS ELB")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, err := c.findInstancesForELB(nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sourceRanges, err := service.GetLoadBalancerSourceRanges(apiService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if this is tagged as an Internal ELB
0000000000000000000000000000000000000000;;		internalELB := false
0000000000000000000000000000000000000000;;		internalAnnotation := apiService.Annotations[ServiceAnnotationLoadBalancerInternal]
0000000000000000000000000000000000000000;;		if internalAnnotation != "" {
0000000000000000000000000000000000000000;;			internalELB = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if we need to set the Proxy protocol policy
0000000000000000000000000000000000000000;;		proxyProtocol := false
0000000000000000000000000000000000000000;;		proxyProtocolAnnotation := apiService.Annotations[ServiceAnnotationLoadBalancerProxyProtocol]
0000000000000000000000000000000000000000;;		if proxyProtocolAnnotation != "" {
0000000000000000000000000000000000000000;;			if proxyProtocolAnnotation != "*" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("annotation %q=%q detected, but the only value supported currently is '*'", ServiceAnnotationLoadBalancerProxyProtocol, proxyProtocolAnnotation)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxyProtocol = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Some load balancer attributes are required, so defaults are set. These can be overridden by annotations.
0000000000000000000000000000000000000000;;		loadBalancerAttributes := &elb.LoadBalancerAttributes{
0000000000000000000000000000000000000000;;			AccessLog:              &elb.AccessLog{Enabled: aws.Bool(false)},
0000000000000000000000000000000000000000;;			ConnectionDraining:     &elb.ConnectionDraining{Enabled: aws.Bool(false)},
0000000000000000000000000000000000000000;;			ConnectionSettings:     &elb.ConnectionSettings{IdleTimeout: aws.Int64(60)},
0000000000000000000000000000000000000000;;			CrossZoneLoadBalancing: &elb.CrossZoneLoadBalancing{Enabled: aws.Bool(false)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if an access log emit interval has been specified
0000000000000000000000000000000000000000;;		accessLogEmitIntervalAnnotation := annotations[ServiceAnnotationLoadBalancerAccessLogEmitInterval]
0000000000000000000000000000000000000000;;		if accessLogEmitIntervalAnnotation != "" {
0000000000000000000000000000000000000000;;			accessLogEmitInterval, err := strconv.ParseInt(accessLogEmitIntervalAnnotation, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error parsing service annotation: %s=%s",
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerAccessLogEmitInterval,
0000000000000000000000000000000000000000;;					accessLogEmitIntervalAnnotation,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadBalancerAttributes.AccessLog.EmitInterval = &accessLogEmitInterval
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if access log enabled/disabled has been specified
0000000000000000000000000000000000000000;;		accessLogEnabledAnnotation := annotations[ServiceAnnotationLoadBalancerAccessLogEnabled]
0000000000000000000000000000000000000000;;		if accessLogEnabledAnnotation != "" {
0000000000000000000000000000000000000000;;			accessLogEnabled, err := strconv.ParseBool(accessLogEnabledAnnotation)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error parsing service annotation: %s=%s",
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerAccessLogEnabled,
0000000000000000000000000000000000000000;;					accessLogEnabledAnnotation,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadBalancerAttributes.AccessLog.Enabled = &accessLogEnabled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if access log s3 bucket name has been specified
0000000000000000000000000000000000000000;;		accessLogS3BucketNameAnnotation := annotations[ServiceAnnotationLoadBalancerAccessLogS3BucketName]
0000000000000000000000000000000000000000;;		if accessLogS3BucketNameAnnotation != "" {
0000000000000000000000000000000000000000;;			loadBalancerAttributes.AccessLog.S3BucketName = &accessLogS3BucketNameAnnotation
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if access log s3 bucket prefix has been specified
0000000000000000000000000000000000000000;;		accessLogS3BucketPrefixAnnotation := annotations[ServiceAnnotationLoadBalancerAccessLogS3BucketPrefix]
0000000000000000000000000000000000000000;;		if accessLogS3BucketPrefixAnnotation != "" {
0000000000000000000000000000000000000000;;			loadBalancerAttributes.AccessLog.S3BucketPrefix = &accessLogS3BucketPrefixAnnotation
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if connection draining enabled/disabled has been specified
0000000000000000000000000000000000000000;;		connectionDrainingEnabledAnnotation := annotations[ServiceAnnotationLoadBalancerConnectionDrainingEnabled]
0000000000000000000000000000000000000000;;		if connectionDrainingEnabledAnnotation != "" {
0000000000000000000000000000000000000000;;			connectionDrainingEnabled, err := strconv.ParseBool(connectionDrainingEnabledAnnotation)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error parsing service annotation: %s=%s",
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerConnectionDrainingEnabled,
0000000000000000000000000000000000000000;;					connectionDrainingEnabledAnnotation,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadBalancerAttributes.ConnectionDraining.Enabled = &connectionDrainingEnabled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if connection draining timeout has been specified
0000000000000000000000000000000000000000;;		connectionDrainingTimeoutAnnotation := annotations[ServiceAnnotationLoadBalancerConnectionDrainingTimeout]
0000000000000000000000000000000000000000;;		if connectionDrainingTimeoutAnnotation != "" {
0000000000000000000000000000000000000000;;			connectionDrainingTimeout, err := strconv.ParseInt(connectionDrainingTimeoutAnnotation, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error parsing service annotation: %s=%s",
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerConnectionDrainingTimeout,
0000000000000000000000000000000000000000;;					connectionDrainingTimeoutAnnotation,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadBalancerAttributes.ConnectionDraining.Timeout = &connectionDrainingTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if connection idle timeout has been specified
0000000000000000000000000000000000000000;;		connectionIdleTimeoutAnnotation := annotations[ServiceAnnotationLoadBalancerConnectionIdleTimeout]
0000000000000000000000000000000000000000;;		if connectionIdleTimeoutAnnotation != "" {
0000000000000000000000000000000000000000;;			connectionIdleTimeout, err := strconv.ParseInt(connectionIdleTimeoutAnnotation, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error parsing service annotation: %s=%s",
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerConnectionIdleTimeout,
0000000000000000000000000000000000000000;;					connectionIdleTimeoutAnnotation,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadBalancerAttributes.ConnectionSettings.IdleTimeout = &connectionIdleTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine if cross zone load balancing enabled/disabled has been specified
0000000000000000000000000000000000000000;;		crossZoneLoadBalancingEnabledAnnotation := annotations[ServiceAnnotationLoadBalancerCrossZoneLoadBalancingEnabled]
0000000000000000000000000000000000000000;;		if crossZoneLoadBalancingEnabledAnnotation != "" {
0000000000000000000000000000000000000000;;			crossZoneLoadBalancingEnabled, err := strconv.ParseBool(crossZoneLoadBalancingEnabledAnnotation)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error parsing service annotation: %s=%s",
0000000000000000000000000000000000000000;;					ServiceAnnotationLoadBalancerCrossZoneLoadBalancingEnabled,
0000000000000000000000000000000000000000;;					crossZoneLoadBalancingEnabledAnnotation,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadBalancerAttributes.CrossZoneLoadBalancing.Enabled = &crossZoneLoadBalancingEnabled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the subnets that the ELB will live in
0000000000000000000000000000000000000000;;		subnetIDs, err := c.findELBSubnets(internalELB)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error listing subnets in VPC: %q", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bail out early if there are no subnets
0000000000000000000000000000000000000000;;		if len(subnetIDs) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not find any suitable subnets for creating the ELB")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(apiService)
0000000000000000000000000000000000000000;;		serviceName := types.NamespacedName{Namespace: apiService.Namespace, Name: apiService.Name}
0000000000000000000000000000000000000000;;		securityGroupIDs, err := c.buildELBSecurityGroupList(serviceName, loadBalancerName, annotations[ServiceAnnotationLoadBalancerExtraSecurityGroups])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(securityGroupIDs) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("[BUG] ELB can't have empty list of Security Groups to be assigned, this is a Kubernetes bug, please report")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			ec2SourceRanges := []*ec2.IpRange{}
0000000000000000000000000000000000000000;;			for _, sourceRange := range sourceRanges.StringSlice() {
0000000000000000000000000000000000000000;;				ec2SourceRanges = append(ec2SourceRanges, &ec2.IpRange{CidrIp: aws.String(sourceRange)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			permissions := NewIPPermissionSet()
0000000000000000000000000000000000000000;;			for _, port := range apiService.Spec.Ports {
0000000000000000000000000000000000000000;;				portInt64 := int64(port.Port)
0000000000000000000000000000000000000000;;				protocol := strings.ToLower(string(port.Protocol))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				permission := &ec2.IpPermission{}
0000000000000000000000000000000000000000;;				permission.FromPort = &portInt64
0000000000000000000000000000000000000000;;				permission.ToPort = &portInt64
0000000000000000000000000000000000000000;;				permission.IpRanges = ec2SourceRanges
0000000000000000000000000000000000000000;;				permission.IpProtocol = &protocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				permissions.Insert(permission)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Allow ICMP fragmentation packets, important for MTU discovery
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				permission := &ec2.IpPermission{
0000000000000000000000000000000000000000;;					IpProtocol: aws.String("icmp"),
0000000000000000000000000000000000000000;;					FromPort:   aws.Int64(3),
0000000000000000000000000000000000000000;;					ToPort:     aws.Int64(4),
0000000000000000000000000000000000000000;;					IpRanges:   []*ec2.IpRange{{CidrIp: aws.String("0.0.0.0/0")}},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				permissions.Insert(permission)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = c.setSecurityGroupIngress(securityGroupIDs[0], permissions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build the load balancer itself
0000000000000000000000000000000000000000;;		loadBalancer, err := c.ensureLoadBalancer(
0000000000000000000000000000000000000000;;			serviceName,
0000000000000000000000000000000000000000;;			loadBalancerName,
0000000000000000000000000000000000000000;;			listeners,
0000000000000000000000000000000000000000;;			subnetIDs,
0000000000000000000000000000000000000000;;			securityGroupIDs,
0000000000000000000000000000000000000000;;			internalELB,
0000000000000000000000000000000000000000;;			proxyProtocol,
0000000000000000000000000000000000000000;;			loadBalancerAttributes,
0000000000000000000000000000000000000000;;			annotations,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if path, healthCheckNodePort := service.GetServiceHealthCheckPathPort(apiService); path != "" {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("service %v (%v) needs health checks on :%d%s)", apiService.Name, loadBalancerName, healthCheckNodePort, path)
0000000000000000000000000000000000000000;;			err = c.ensureLoadBalancerHealthCheck(loadBalancer, "HTTP", healthCheckNodePort, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to ensure health check for localized service %v on node port %v: %q", loadBalancerName, healthCheckNodePort, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("service %v does not need custom health checks", apiService.Name)
0000000000000000000000000000000000000000;;			// We only configure a TCP health-check on the first port
0000000000000000000000000000000000000000;;			var tcpHealthCheckPort int32
0000000000000000000000000000000000000000;;			for _, listener := range listeners {
0000000000000000000000000000000000000000;;				if listener.InstancePort == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tcpHealthCheckPort = int32(*listener.InstancePort)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// there must be no path on TCP health check
0000000000000000000000000000000000000000;;			err = c.ensureLoadBalancerHealthCheck(loadBalancer, "TCP", tcpHealthCheckPort, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.updateInstanceSecurityGroupsForLoadBalancer(loadBalancer, instances)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error opening ingress rules for the load balancer to the instances: %q", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.ensureLoadBalancerInstances(orEmpty(loadBalancer.LoadBalancerName), loadBalancer.Instances, instances)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error registering instances with the load balancer: %q", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Loadbalancer %s (%v) has DNS name %s", loadBalancerName, serviceName, orEmpty(loadBalancer.DNSName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Wait for creation?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := toStatus(loadBalancer)
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLoadBalancer is an implementation of LoadBalancer.GetLoadBalancer
0000000000000000000000000000000000000000;;	func (c *Cloud) GetLoadBalancer(clusterName string, service *v1.Service) (*v1.LoadBalancerStatus, bool, error) {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		lb, err := c.describeLoadBalancer(loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb == nil {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := toStatus(lb)
0000000000000000000000000000000000000000;;		return status, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toStatus(lb *elb.LoadBalancerDescription) *v1.LoadBalancerStatus {
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !isNilOrEmpty(lb.DNSName) {
0000000000000000000000000000000000000000;;			var ingress v1.LoadBalancerIngress
0000000000000000000000000000000000000000;;			ingress.Hostname = orEmpty(lb.DNSName)
0000000000000000000000000000000000000000;;			status.Ingress = []v1.LoadBalancerIngress{ingress}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the first security group for an instance, or nil
0000000000000000000000000000000000000000;;	// We only create instances with one security group, so we don't expect multiple security groups.
0000000000000000000000000000000000000000;;	// However, if there are multiple security groups, we will choose the one tagged with our cluster filter.
0000000000000000000000000000000000000000;;	// Otherwise we will return an error.
0000000000000000000000000000000000000000;;	func findSecurityGroupForInstance(instance *ec2.Instance, taggedSecurityGroups map[string]*ec2.SecurityGroup) (*ec2.GroupIdentifier, error) {
0000000000000000000000000000000000000000;;		instanceID := aws.StringValue(instance.InstanceId)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tagged []*ec2.GroupIdentifier
0000000000000000000000000000000000000000;;		var untagged []*ec2.GroupIdentifier
0000000000000000000000000000000000000000;;		for _, group := range instance.SecurityGroups {
0000000000000000000000000000000000000000;;			groupID := aws.StringValue(group.GroupId)
0000000000000000000000000000000000000000;;			if groupID == "" {
0000000000000000000000000000000000000000;;				glog.Warningf("Ignoring security group without id for instance %q: %v", instanceID, group)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, isTagged := taggedSecurityGroups[groupID]
0000000000000000000000000000000000000000;;			if isTagged {
0000000000000000000000000000000000000000;;				tagged = append(tagged, group)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				untagged = append(untagged, group)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(tagged) > 0 {
0000000000000000000000000000000000000000;;			// We create instances with one SG
0000000000000000000000000000000000000000;;			// If users create multiple SGs, they must tag one of them as being k8s owned
0000000000000000000000000000000000000000;;			if len(tagged) != 1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Multiple tagged security groups found for instance %s; ensure only the k8s security group is tagged", instanceID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return tagged[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(untagged) > 0 {
0000000000000000000000000000000000000000;;			// For back-compat, we will allow a single untagged SG
0000000000000000000000000000000000000000;;			if len(untagged) != 1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Multiple untagged security groups found for instance %s; ensure the k8s security group is tagged", instanceID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return untagged[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Warningf("No security group found for instance %q", instanceID)
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return all the security groups that are tagged as being part of our cluster
0000000000000000000000000000000000000000;;	func (c *Cloud) getTaggedSecurityGroups() (map[string]*ec2.SecurityGroup, error) {
0000000000000000000000000000000000000000;;		request := &ec2.DescribeSecurityGroupsInput{}
0000000000000000000000000000000000000000;;		request.Filters = c.tagging.addFilters(nil)
0000000000000000000000000000000000000000;;		groups, err := c.ec2.DescribeSecurityGroups(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error querying security groups: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(map[string]*ec2.SecurityGroup)
0000000000000000000000000000000000000000;;		for _, group := range groups {
0000000000000000000000000000000000000000;;			if !c.tagging.hasClusterTag(group.Tags) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			id := aws.StringValue(group.GroupId)
0000000000000000000000000000000000000000;;			if id == "" {
0000000000000000000000000000000000000000;;				glog.Warningf("Ignoring group without id: %v", group)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m[id] = group
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open security group ingress rules on the instances so that the load balancer can talk to them
0000000000000000000000000000000000000000;;	// Will also remove any security groups ingress rules for the load balancer that are _not_ needed for allInstances
0000000000000000000000000000000000000000;;	func (c *Cloud) updateInstanceSecurityGroupsForLoadBalancer(lb *elb.LoadBalancerDescription, instances map[awsInstanceID]*ec2.Instance) error {
0000000000000000000000000000000000000000;;		if c.cfg.Global.DisableSecurityGroupIngress {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the load balancer security group id
0000000000000000000000000000000000000000;;		loadBalancerSecurityGroupID := ""
0000000000000000000000000000000000000000;;		for _, securityGroup := range lb.SecurityGroups {
0000000000000000000000000000000000000000;;			if isNilOrEmpty(securityGroup) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if loadBalancerSecurityGroupID != "" {
0000000000000000000000000000000000000000;;				// We create LBs with one SG
0000000000000000000000000000000000000000;;				glog.Warningf("Multiple security groups for load balancer: %q", orEmpty(lb.LoadBalancerName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadBalancerSecurityGroupID = *securityGroup
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if loadBalancerSecurityGroupID == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Could not determine security group for load balancer: %s", orEmpty(lb.LoadBalancerName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the actual list of groups that allow ingress from the load-balancer
0000000000000000000000000000000000000000;;		var actualGroups []*ec2.SecurityGroup
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			describeRequest := &ec2.DescribeSecurityGroupsInput{}
0000000000000000000000000000000000000000;;			filters := []*ec2.Filter{
0000000000000000000000000000000000000000;;				newEc2Filter("ip-permission.group-id", loadBalancerSecurityGroupID),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			describeRequest.Filters = c.tagging.addFilters(filters)
0000000000000000000000000000000000000000;;			response, err := c.ec2.DescribeSecurityGroups(describeRequest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error querying security groups for ELB: %q", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, sg := range response {
0000000000000000000000000000000000000000;;				if !c.tagging.hasClusterTag(sg.Tags) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				actualGroups = append(actualGroups, sg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		taggedSecurityGroups, err := c.getTaggedSecurityGroups()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error querying for tagged security groups: %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Open the firewall from the load balancer to the instance
0000000000000000000000000000000000000000;;		// We don't actually have a trivial way to know in advance which security group the instance is in
0000000000000000000000000000000000000000;;		// (it is probably the node security group, but we don't easily have that).
0000000000000000000000000000000000000000;;		// However, we _do_ have the list of security groups on the instance records.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map containing the changes we want to make; true to add, false to remove
0000000000000000000000000000000000000000;;		instanceSecurityGroupIds := map[string]bool{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan instances for groups we want open
0000000000000000000000000000000000000000;;		for _, instance := range instances {
0000000000000000000000000000000000000000;;			securityGroup, err := findSecurityGroupForInstance(instance, taggedSecurityGroups)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if securityGroup == nil {
0000000000000000000000000000000000000000;;				glog.Warning("Ignoring instance without security group: ", orEmpty(instance.InstanceId))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			id := aws.StringValue(securityGroup.GroupId)
0000000000000000000000000000000000000000;;			if id == "" {
0000000000000000000000000000000000000000;;				glog.Warningf("found security group without id: %v", securityGroup)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			instanceSecurityGroupIds[id] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compare to actual groups
0000000000000000000000000000000000000000;;		for _, actualGroup := range actualGroups {
0000000000000000000000000000000000000000;;			actualGroupID := aws.StringValue(actualGroup.GroupId)
0000000000000000000000000000000000000000;;			if actualGroupID == "" {
0000000000000000000000000000000000000000;;				glog.Warning("Ignoring group without ID: ", actualGroup)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			adding, found := instanceSecurityGroupIds[actualGroupID]
0000000000000000000000000000000000000000;;			if found && adding {
0000000000000000000000000000000000000000;;				// We don't need to make a change; the permission is already in place
0000000000000000000000000000000000000000;;				delete(instanceSecurityGroupIds, actualGroupID)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// This group is not needed by allInstances; delete it
0000000000000000000000000000000000000000;;				instanceSecurityGroupIds[actualGroupID] = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for instanceSecurityGroupID, add := range instanceSecurityGroupIds {
0000000000000000000000000000000000000000;;			if add {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Adding rule for traffic from the load balancer (%s) to instances (%s)", loadBalancerSecurityGroupID, instanceSecurityGroupID)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Removing rule for traffic from the load balancer (%s) to instance (%s)", loadBalancerSecurityGroupID, instanceSecurityGroupID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sourceGroupID := &ec2.UserIdGroupPair{}
0000000000000000000000000000000000000000;;			sourceGroupID.GroupId = &loadBalancerSecurityGroupID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allProtocols := "-1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			permission := &ec2.IpPermission{}
0000000000000000000000000000000000000000;;			permission.IpProtocol = &allProtocols
0000000000000000000000000000000000000000;;			permission.UserIdGroupPairs = []*ec2.UserIdGroupPair{sourceGroupID}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			permissions := []*ec2.IpPermission{permission}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if add {
0000000000000000000000000000000000000000;;				changed, err := c.addSecurityGroupIngress(instanceSecurityGroupID, permissions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !changed {
0000000000000000000000000000000000000000;;					glog.Warning("Allowing ingress was not needed; concurrent change? groupId=", instanceSecurityGroupID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				changed, err := c.removeSecurityGroupIngress(instanceSecurityGroupID, permissions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !changed {
0000000000000000000000000000000000000000;;					glog.Warning("Revoking ingress was not needed; concurrent change? groupId=", instanceSecurityGroupID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureLoadBalancerDeleted implements LoadBalancer.EnsureLoadBalancerDeleted.
0000000000000000000000000000000000000000;;	func (c *Cloud) EnsureLoadBalancerDeleted(clusterName string, service *v1.Service) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		lb, err := c.describeLoadBalancer(loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb == nil {
0000000000000000000000000000000000000000;;			glog.Info("Load balancer already deleted: ", loadBalancerName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// De-authorize the load balancer security group from the instances security group
0000000000000000000000000000000000000000;;			err = c.updateInstanceSecurityGroupsForLoadBalancer(lb, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error deregistering load balancer from instance security groups: %q", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Delete the load balancer itself
0000000000000000000000000000000000000000;;			request := &elb.DeleteLoadBalancerInput{}
0000000000000000000000000000000000000000;;			request.LoadBalancerName = lb.LoadBalancerName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = c.elb.DeleteLoadBalancer(request)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO: Check if error was because load balancer was concurrently deleted
0000000000000000000000000000000000000000;;				glog.Errorf("Error deleting load balancer: %q", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			// Delete the security group(s) for the load balancer
0000000000000000000000000000000000000000;;			// Note that this is annoying: the load balancer disappears from the API immediately, but it is still
0000000000000000000000000000000000000000;;			// deleting in the background.  We get a DependencyViolation until the load balancer has deleted itself
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Collect the security groups to delete
0000000000000000000000000000000000000000;;			securityGroupIDs := map[string]struct{}{}
0000000000000000000000000000000000000000;;			for _, securityGroupID := range lb.SecurityGroups {
0000000000000000000000000000000000000000;;				if *securityGroupID == c.cfg.Global.ElbSecurityGroup {
0000000000000000000000000000000000000000;;					//We don't want to delete a security group that was defined in the Cloud Configurationn.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isNilOrEmpty(securityGroupID) {
0000000000000000000000000000000000000000;;					glog.Warning("Ignoring empty security group in ", service.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				securityGroupIDs[*securityGroupID] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Loop through and try to delete them
0000000000000000000000000000000000000000;;			timeoutAt := time.Now().Add(time.Second * 600)
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				for securityGroupID := range securityGroupIDs {
0000000000000000000000000000000000000000;;					request := &ec2.DeleteSecurityGroupInput{}
0000000000000000000000000000000000000000;;					request.GroupId = &securityGroupID
0000000000000000000000000000000000000000;;					_, err := c.ec2.DeleteSecurityGroup(request)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						delete(securityGroupIDs, securityGroupID)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						ignore := false
0000000000000000000000000000000000000000;;						if awsError, ok := err.(awserr.Error); ok {
0000000000000000000000000000000000000000;;							if awsError.Code() == "DependencyViolation" {
0000000000000000000000000000000000000000;;								glog.V(2).Infof("Ignoring DependencyViolation while deleting load-balancer security group (%s), assuming because LB is in process of deleting", securityGroupID)
0000000000000000000000000000000000000000;;								ignore = true
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !ignore {
0000000000000000000000000000000000000000;;							return fmt.Errorf("error while deleting load balancer security group (%s): %q", securityGroupID, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(securityGroupIDs) == 0 {
0000000000000000000000000000000000000000;;					glog.V(2).Info("Deleted all security groups for load balancer: ", service.Name)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if time.Now().After(timeoutAt) {
0000000000000000000000000000000000000000;;					ids := []string{}
0000000000000000000000000000000000000000;;					for id := range securityGroupIDs {
0000000000000000000000000000000000000000;;						ids = append(ids, id)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return fmt.Errorf("timed out deleting ELB: %s. Could not delete security groups %v", service.Name, strings.Join(ids, ","))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(2).Info("Waiting for load-balancer to delete so we can delete security groups: ", service.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				time.Sleep(10 * time.Second)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateLoadBalancer implements LoadBalancer.UpdateLoadBalancer
0000000000000000000000000000000000000000;;	func (c *Cloud) UpdateLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		instances, err := c.findInstancesForELB(nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		lb, err := c.describeLoadBalancer(loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Load balancer not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.ensureLoadBalancerInstances(aws.StringValue(lb.LoadBalancerName), lb.Instances, instances)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.updateInstanceSecurityGroupsForLoadBalancer(lb, instances)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the instance with the specified ID
0000000000000000000000000000000000000000;;	func (c *Cloud) getInstanceByID(instanceID string) (*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		instances, err := c.getInstancesByIDs([]*string{&instanceID})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(instances) == 0 {
0000000000000000000000000000000000000000;;			return nil, cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(instances) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple instances found for instance: %s", instanceID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return instances[instanceID], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) getInstancesByIDs(instanceIDs []*string) (map[string]*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		instancesByID := make(map[string]*ec2.Instance)
0000000000000000000000000000000000000000;;		if len(instanceIDs) == 0 {
0000000000000000000000000000000000000000;;			return instancesByID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := &ec2.DescribeInstancesInput{
0000000000000000000000000000000000000000;;			InstanceIds: instanceIDs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, err := c.ec2.DescribeInstances(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, instance := range instances {
0000000000000000000000000000000000000000;;			instanceID := orEmpty(instance.InstanceId)
0000000000000000000000000000000000000000;;			if instanceID == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			instancesByID[instanceID] = instance
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return instancesByID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) getInstancesByNodeNames(nodeNames []string, states ...string) ([]*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		names := aws.StringSlice(nodeNames)
0000000000000000000000000000000000000000;;		ec2Instances := []*ec2.Instance{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(names); i += filterNodeLimit {
0000000000000000000000000000000000000000;;			end := i + filterNodeLimit
0000000000000000000000000000000000000000;;			if end > len(names) {
0000000000000000000000000000000000000000;;				end = len(names)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nameSlice := names[i:end]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeNameFilter := &ec2.Filter{
0000000000000000000000000000000000000000;;				Name:   aws.String("private-dns-name"),
0000000000000000000000000000000000000000;;				Values: nameSlice,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			filters := []*ec2.Filter{nodeNameFilter}
0000000000000000000000000000000000000000;;			if len(states) > 0 {
0000000000000000000000000000000000000000;;				filters = append(filters, newEc2Filter("instance-state-name", states...))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			instances, err := c.describeInstances(filters)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Failed to describe instances %v", nodeNames)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ec2Instances = append(ec2Instances, instances...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ec2Instances) == 0 {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Failed to find any instances %v", nodeNames)
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ec2Instances, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Move to instanceCache
0000000000000000000000000000000000000000;;	func (c *Cloud) describeInstances(filters []*ec2.Filter) ([]*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		filters = c.tagging.addFilters(filters)
0000000000000000000000000000000000000000;;		request := &ec2.DescribeInstancesInput{
0000000000000000000000000000000000000000;;			Filters: filters,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := c.ec2.DescribeInstances(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var matches []*ec2.Instance
0000000000000000000000000000000000000000;;		for _, instance := range response {
0000000000000000000000000000000000000000;;			if c.tagging.hasClusterTag(instance.Tags) {
0000000000000000000000000000000000000000;;				matches = append(matches, instance)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return matches, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapNodeNameToPrivateDNSName maps a k8s NodeName to an AWS Instance PrivateDNSName
0000000000000000000000000000000000000000;;	// This is a simple string cast
0000000000000000000000000000000000000000;;	func mapNodeNameToPrivateDNSName(nodeName types.NodeName) string {
0000000000000000000000000000000000000000;;		return string(nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapInstanceToNodeName maps a EC2 instance to a k8s NodeName, by extracting the PrivateDNSName
0000000000000000000000000000000000000000;;	func mapInstanceToNodeName(i *ec2.Instance) types.NodeName {
0000000000000000000000000000000000000000;;		return types.NodeName(aws.StringValue(i.PrivateDnsName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the instance with the specified node name
0000000000000000000000000000000000000000;;	// Returns nil if it does not exist
0000000000000000000000000000000000000000;;	func (c *Cloud) findInstanceByNodeName(nodeName types.NodeName) (*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		privateDNSName := mapNodeNameToPrivateDNSName(nodeName)
0000000000000000000000000000000000000000;;		filters := []*ec2.Filter{
0000000000000000000000000000000000000000;;			newEc2Filter("private-dns-name", privateDNSName),
0000000000000000000000000000000000000000;;			newEc2Filter("instance-state-name", "running"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instances, err := c.describeInstances(filters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(instances) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(instances) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple instances found for name: %s", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return instances[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the instance with the specified node name
0000000000000000000000000000000000000000;;	// Like findInstanceByNodeName, but returns error if node not found
0000000000000000000000000000000000000000;;	func (c *Cloud) getInstanceByNodeName(nodeName types.NodeName) (*ec2.Instance, error) {
0000000000000000000000000000000000000000;;		instance, err := c.findInstanceByNodeName(nodeName)
0000000000000000000000000000000000000000;;		if err == nil && instance == nil {
0000000000000000000000000000000000000000;;			return nil, cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return instance, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloud) getFullInstance(nodeName types.NodeName) (*awsInstance, *ec2.Instance, error) {
0000000000000000000000000000000000000000;;		if nodeName == "" {
0000000000000000000000000000000000000000;;			instance, err := c.getInstanceByID(c.selfAWSInstance.awsID)
0000000000000000000000000000000000000000;;			return c.selfAWSInstance, instance, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instance, err := c.getInstanceByNodeName(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		awsInstance := newAWSInstance(c.ec2, instance)
0000000000000000000000000000000000000000;;		return awsInstance, instance, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNodeDisk(
0000000000000000000000000000000000000000;;		nodeDiskMap map[types.NodeName]map[KubernetesVolumeID]bool,
0000000000000000000000000000000000000000;;		volumeID KubernetesVolumeID,
0000000000000000000000000000000000000000;;		nodeName types.NodeName,
0000000000000000000000000000000000000000;;		check bool) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeMap := nodeDiskMap[nodeName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volumeMap == nil {
0000000000000000000000000000000000000000;;			volumeMap = make(map[KubernetesVolumeID]bool)
0000000000000000000000000000000000000000;;			nodeDiskMap[nodeName] = volumeMap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeMap[volumeID] = check
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recordAwsMetric(actionName string, timeTaken float64, err error) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			awsApiErrorMetric.With(prometheus.Labels{"request": actionName}).Inc()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			awsApiMetric.With(prometheus.Labels{"request": actionName}).Observe(timeTaken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
