0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6448488a5355da2b4d80b12aa8b413809b339d39;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExistingDevices is a map of assigned devices. Presence of a key with a device
0000000000000000000000000000000000000000;;	// name in the map means that the device is allocated. Value is irrelevant and
0000000000000000000000000000000000000000;;	// can be used for anything that DeviceAllocator user wants.
0000000000000000000000000000000000000000;;	// Only the relevant part of device name should be in the map, e.g. "ba" for
0000000000000000000000000000000000000000;;	// "/dev/xvdba".
0000000000000000000000000000000000000000;;	type ExistingDevices map[mountDevice]awsVolumeID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// On AWS, we should assign new (not yet used) device names to attached volumes.
0000000000000000000000000000000000000000;;	// If we reuse a previously used name, we may get the volume "attaching" forever,
0000000000000000000000000000000000000000;;	// see https://aws.amazon.com/premiumsupport/knowledge-center/ebs-stuck-attaching/.
0000000000000000000000000000000000000000;;	// DeviceAllocator finds available device name, taking into account already
0000000000000000000000000000000000000000;;	// assigned device names from ExistingDevices map. It tries to find the next
0000000000000000000000000000000000000000;;	// device name to the previously assigned one (from previous DeviceAllocator
0000000000000000000000000000000000000000;;	// call), so all available device names are used eventually and it minimizes
0000000000000000000000000000000000000000;;	// device name reuse.
0000000000000000000000000000000000000000;;	// All these allocations are in-memory, nothing is written to / read from
0000000000000000000000000000000000000000;;	// /dev directory.
0000000000000000000000000000000000000000;;	type DeviceAllocator interface {
0000000000000000000000000000000000000000;;		// GetNext returns a free device name or error when there is no free device
0000000000000000000000000000000000000000;;		// name. Only the device suffix is returned, e.g. "ba" for "/dev/xvdba".
0000000000000000000000000000000000000000;;		// It's up to the called to add appropriate "/dev/sd" or "/dev/xvd" prefix.
0000000000000000000000000000000000000000;;		GetNext(existingDevices ExistingDevices) (mountDevice, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deprioritize the device so as it can't be used immediately again
0000000000000000000000000000000000000000;;		Deprioritize(mountDevice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lock the deviceAllocator
0000000000000000000000000000000000000000;;		Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unlock the deviceAllocator
0000000000000000000000000000000000000000;;		Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deviceAllocator struct {
0000000000000000000000000000000000000000;;		possibleDevices map[mountDevice]int
0000000000000000000000000000000000000000;;		counter         int
0000000000000000000000000000000000000000;;		deviceLock      sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ DeviceAllocator = &deviceAllocator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type devicePair struct {
0000000000000000000000000000000000000000;;		deviceName  mountDevice
0000000000000000000000000000000000000000;;		deviceIndex int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type devicePairList []devicePair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p devicePairList) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p devicePairList) Less(i, j int) bool { return p[i].deviceIndex < p[j].deviceIndex }
0000000000000000000000000000000000000000;;	func (p devicePairList) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allocates device names according to scheme ba..bz, ca..cz
0000000000000000000000000000000000000000;;	// it moves along the ring and always picks next device until
0000000000000000000000000000000000000000;;	// device list is exhausted.
0000000000000000000000000000000000000000;;	func NewDeviceAllocator() DeviceAllocator {
0000000000000000000000000000000000000000;;		possibleDevices := make(map[mountDevice]int)
0000000000000000000000000000000000000000;;		for _, firstChar := range []rune{'b', 'c'} {
0000000000000000000000000000000000000000;;			for i := 'a'; i <= 'z'; i++ {
0000000000000000000000000000000000000000;;				dev := mountDevice([]rune{firstChar, i})
0000000000000000000000000000000000000000;;				possibleDevices[dev] = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &deviceAllocator{
0000000000000000000000000000000000000000;;			possibleDevices: possibleDevices,
0000000000000000000000000000000000000000;;			counter:         0,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNext gets next available device from the pool, this function assumes that caller
0000000000000000000000000000000000000000;;	// holds the necessary lock on deviceAllocator
0000000000000000000000000000000000000000;;	func (d *deviceAllocator) GetNext(existingDevices ExistingDevices) (mountDevice, error) {
0000000000000000000000000000000000000000;;		for _, devicePair := range d.sortByCount() {
0000000000000000000000000000000000000000;;			if _, found := existingDevices[devicePair.deviceName]; !found {
0000000000000000000000000000000000000000;;				return devicePair.deviceName, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("no devices are available")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *deviceAllocator) sortByCount() devicePairList {
0000000000000000000000000000000000000000;;		dpl := make(devicePairList, 0)
0000000000000000000000000000000000000000;;		for deviceName, deviceIndex := range d.possibleDevices {
0000000000000000000000000000000000000000;;			dpl = append(dpl, devicePair{deviceName, deviceIndex})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(dpl)
0000000000000000000000000000000000000000;;		return dpl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *deviceAllocator) Lock() {
0000000000000000000000000000000000000000;;		d.deviceLock.Lock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *deviceAllocator) Unlock() {
0000000000000000000000000000000000000000;;		d.deviceLock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deprioritize the device so as it can't be used immediately again
0000000000000000000000000000000000000000;;	func (d *deviceAllocator) Deprioritize(chosen mountDevice) {
0000000000000000000000000000000000000000;;		d.deviceLock.Lock()
0000000000000000000000000000000000000000;;		defer d.deviceLock.Unlock()
0000000000000000000000000000000000000000;;		if _, ok := d.possibleDevices[chosen]; ok {
0000000000000000000000000000000000000000;;			d.counter++
0000000000000000000000000000000000000000;;			d.possibleDevices[chosen] = d.counter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
