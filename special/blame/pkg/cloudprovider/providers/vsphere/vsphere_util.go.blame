0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
fab7df78a1367134c1d54b3a56c6aa9166dc83fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package vsphere
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/find"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/object"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/pbm"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pbmtypes "github.com/vmware/govmomi/pbm/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DatastoreProperty     = "datastore"
0000000000000000000000000000000000000000;;		DatastoreInfoProperty = "info"
0000000000000000000000000000000000000000;;		Folder                = "Folder"
0000000000000000000000000000000000000000;;		VirtualMachine        = "VirtualMachine"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reads vSphere configuration from system environment and construct vSphere object
0000000000000000000000000000000000000000;;	func GetVSphere() (*VSphere, error) {
0000000000000000000000000000000000000000;;		cfg := getVSphereConfig()
0000000000000000000000000000000000000000;;		client, err := GetgovmomiClient(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vs := &VSphere{
0000000000000000000000000000000000000000;;			client:          client,
0000000000000000000000000000000000000000;;			cfg:             cfg,
0000000000000000000000000000000000000000;;			localInstanceID: "",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runtime.SetFinalizer(vs, logout)
0000000000000000000000000000000000000000;;		return vs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVSphereConfig() *VSphereConfig {
0000000000000000000000000000000000000000;;		var cfg VSphereConfig
0000000000000000000000000000000000000000;;		cfg.Global.VCenterIP = os.Getenv("VSPHERE_VCENTER")
0000000000000000000000000000000000000000;;		cfg.Global.User = os.Getenv("VSPHERE_USER")
0000000000000000000000000000000000000000;;		cfg.Global.Password = os.Getenv("VSPHERE_PASSWORD")
0000000000000000000000000000000000000000;;		cfg.Global.Datacenter = os.Getenv("VSPHERE_DATACENTER")
0000000000000000000000000000000000000000;;		cfg.Global.Datastore = os.Getenv("VSPHERE_DATASTORE")
0000000000000000000000000000000000000000;;		cfg.Global.WorkingDir = os.Getenv("VSPHERE_WORKING_DIR")
0000000000000000000000000000000000000000;;		cfg.Global.VMName = os.Getenv("VSPHERE_VM_NAME")
0000000000000000000000000000000000000000;;		cfg.Global.InsecureFlag = false
0000000000000000000000000000000000000000;;		if strings.ToLower(os.Getenv("VSPHERE_INSECURE")) == "true" {
0000000000000000000000000000000000000000;;			cfg.Global.InsecureFlag = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetgovmomiClient(cfg *VSphereConfig) (*govmomi.Client, error) {
0000000000000000000000000000000000000000;;		if cfg == nil {
0000000000000000000000000000000000000000;;			cfg = getVSphereConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client, err := newClient(context.TODO(), cfg)
0000000000000000000000000000000000000000;;		return client, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get placement compatibility result based on storage policy requirements.
0000000000000000000000000000000000000000;;	func (vs *VSphere) GetPlacementCompatibilityResult(ctx context.Context, pbmClient *pbm.Client, storagePolicyID string) (pbm.PlacementCompatibilityResult, error) {
0000000000000000000000000000000000000000;;		datastores, err := vs.getSharedDatastoresInK8SCluster(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var hubs []pbmtypes.PbmPlacementHub
0000000000000000000000000000000000000000;;		for _, ds := range datastores {
0000000000000000000000000000000000000000;;			hubs = append(hubs, pbmtypes.PbmPlacementHub{
0000000000000000000000000000000000000000;;				HubType: ds.Type,
0000000000000000000000000000000000000000;;				HubId:   ds.Value,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := []pbmtypes.BasePbmPlacementRequirement{
0000000000000000000000000000000000000000;;			&pbmtypes.PbmPlacementCapabilityProfileRequirement{
0000000000000000000000000000000000000000;;				ProfileId: pbmtypes.PbmProfileId{
0000000000000000000000000000000000000000;;					UniqueId: storagePolicyID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err := pbmClient.CheckRequirements(ctx, hubs, nil, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify if the user specified datastore is in the list of non-compatible datastores.
0000000000000000000000000000000000000000;;	// If yes, return the non compatible datastore reference.
0000000000000000000000000000000000000000;;	func (vs *VSphere) IsUserSpecifiedDatastoreNonCompatible(ctx context.Context, compatibilityResult pbm.PlacementCompatibilityResult, dsName string) (bool, *types.ManagedObjectReference) {
0000000000000000000000000000000000000000;;		dsMoList := vs.GetNonCompatibleDatastoresMo(ctx, compatibilityResult)
0000000000000000000000000000000000000000;;		for _, ds := range dsMoList {
0000000000000000000000000000000000000000;;			if ds.Info.GetDatastoreInfo().Name == dsName {
0000000000000000000000000000000000000000;;				dsMoRef := ds.Reference()
0000000000000000000000000000000000000000;;				return true, &dsMoRef
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetNonCompatibleDatastoreFaultMsg(compatibilityResult pbm.PlacementCompatibilityResult, dsMoref types.ManagedObjectReference) string {
0000000000000000000000000000000000000000;;		var faultMsg string
0000000000000000000000000000000000000000;;		for _, res := range compatibilityResult {
0000000000000000000000000000000000000000;;			if res.Hub.HubId == dsMoref.Value {
0000000000000000000000000000000000000000;;				for _, err := range res.Error {
0000000000000000000000000000000000000000;;					faultMsg = faultMsg + err.LocalizedMessage
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return faultMsg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the best fit compatible datastore by free space.
0000000000000000000000000000000000000000;;	func GetMostFreeDatastore(dsMo []mo.Datastore) mo.Datastore {
0000000000000000000000000000000000000000;;		var curMax int64
0000000000000000000000000000000000000000;;		curMax = -1
0000000000000000000000000000000000000000;;		var index int
0000000000000000000000000000000000000000;;		for i, ds := range dsMo {
0000000000000000000000000000000000000000;;			dsFreeSpace := ds.Info.GetDatastoreInfo().FreeSpace
0000000000000000000000000000000000000000;;			if dsFreeSpace > curMax {
0000000000000000000000000000000000000000;;				curMax = dsFreeSpace
0000000000000000000000000000000000000000;;				index = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dsMo[index]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) GetCompatibleDatastoresMo(ctx context.Context, compatibilityResult pbm.PlacementCompatibilityResult) ([]mo.Datastore, error) {
0000000000000000000000000000000000000000;;		compatibleHubs := compatibilityResult.CompatibleDatastores()
0000000000000000000000000000000000000000;;		// Return an error if there are no compatible datastores.
0000000000000000000000000000000000000000;;		if len(compatibleHubs) < 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("There are no compatible datastores that satisfy the storage policy requirements")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dsMoList, err := vs.getDatastoreMo(ctx, compatibleHubs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dsMoList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) GetNonCompatibleDatastoresMo(ctx context.Context, compatibilityResult pbm.PlacementCompatibilityResult) []mo.Datastore {
0000000000000000000000000000000000000000;;		nonCompatibleHubs := compatibilityResult.NonCompatibleDatastores()
0000000000000000000000000000000000000000;;		// Return an error if there are no compatible datastores.
0000000000000000000000000000000000000000;;		if len(nonCompatibleHubs) < 1 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dsMoList, err := vs.getDatastoreMo(ctx, nonCompatibleHubs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dsMoList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the datastore managed objects for the place hubs using property collector.
0000000000000000000000000000000000000000;;	func (vs *VSphere) getDatastoreMo(ctx context.Context, hubs []pbmtypes.PbmPlacementHub) ([]mo.Datastore, error) {
0000000000000000000000000000000000000000;;		var dsMoRefs []types.ManagedObjectReference
0000000000000000000000000000000000000000;;		for _, hub := range hubs {
0000000000000000000000000000000000000000;;			dsMoRefs = append(dsMoRefs, types.ManagedObjectReference{
0000000000000000000000000000000000000000;;				Type:  hub.HubType,
0000000000000000000000000000000000000000;;				Value: hub.HubId,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc := property.DefaultCollector(vs.client.Client)
0000000000000000000000000000000000000000;;		var dsMoList []mo.Datastore
0000000000000000000000000000000000000000;;		err := pc.Retrieve(ctx, dsMoRefs, []string{DatastoreInfoProperty}, &dsMoList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dsMoList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get all datastores accessible for the virtual machine object.
0000000000000000000000000000000000000000;;	func (vs *VSphere) getSharedDatastoresInK8SCluster(ctx context.Context) ([]types.ManagedObjectReference, error) {
0000000000000000000000000000000000000000;;		f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;		dc, err := f.Datacenter(ctx, vs.cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;		f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;		vmFolder, err := f.Folder(ctx, strings.TrimSuffix(vs.cfg.Global.WorkingDir, "/"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vmMoList, err := vs.GetVMsInsideFolder(ctx, vmFolder, []string{NameProperty})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index := 0
0000000000000000000000000000000000000000;;		var sharedDs []string
0000000000000000000000000000000000000000;;		for _, vmMo := range vmMoList {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(vmMo.Name, DummyVMPrefixName) {
0000000000000000000000000000000000000000;;				accessibleDatastores, err := vs.getAllAccessibleDatastores(ctx, vmMo)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if index == 0 {
0000000000000000000000000000000000000000;;					sharedDs = accessibleDatastores
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sharedDs = intersect(sharedDs, accessibleDatastores)
0000000000000000000000000000000000000000;;					if len(sharedDs) == 0 {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("No shared datastores found in the Kubernetes cluster")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				index++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var sharedDSMorefs []types.ManagedObjectReference
0000000000000000000000000000000000000000;;		for _, ds := range sharedDs {
0000000000000000000000000000000000000000;;			sharedDSMorefs = append(sharedDSMorefs, types.ManagedObjectReference{
0000000000000000000000000000000000000000;;				Value: ds,
0000000000000000000000000000000000000000;;				Type:  "Datastore",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sharedDSMorefs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intersect(list1 []string, list2 []string) []string {
0000000000000000000000000000000000000000;;		var sharedList []string
0000000000000000000000000000000000000000;;		for _, val1 := range list1 {
0000000000000000000000000000000000000000;;			// Check if val1 is found in list2
0000000000000000000000000000000000000000;;			for _, val2 := range list2 {
0000000000000000000000000000000000000000;;				if val1 == val2 {
0000000000000000000000000000000000000000;;					sharedList = append(sharedList, val1)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sharedList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the VM list inside a folder.
0000000000000000000000000000000000000000;;	func (vs *VSphere) GetVMsInsideFolder(ctx context.Context, vmFolder *object.Folder, properties []string) ([]mo.VirtualMachine, error) {
0000000000000000000000000000000000000000;;		vmFolders, err := vmFolder.Children(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc := property.DefaultCollector(vs.client.Client)
0000000000000000000000000000000000000000;;		var vmRefs []types.ManagedObjectReference
0000000000000000000000000000000000000000;;		var vmMoList []mo.VirtualMachine
0000000000000000000000000000000000000000;;		for _, vmFolder := range vmFolders {
0000000000000000000000000000000000000000;;			if vmFolder.Reference().Type == VirtualMachine {
0000000000000000000000000000000000000000;;				vmRefs = append(vmRefs, vmFolder.Reference())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = pc.Retrieve(ctx, vmRefs, properties, &vmMoList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vmMoList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the datastores accessible for the virtual machine object.
0000000000000000000000000000000000000000;;	func (vs *VSphere) getAllAccessibleDatastores(ctx context.Context, vmMo mo.VirtualMachine) ([]string, error) {
0000000000000000000000000000000000000000;;		f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;		dc, err := f.Datacenter(ctx, vs.cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;		vmRegex := vs.cfg.Global.WorkingDir + vmMo.Name
0000000000000000000000000000000000000000;;		vmObj, err := f.VirtualMachine(ctx, vmRegex)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, err := vmObj.HostSystem(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hostSystemMo mo.HostSystem
0000000000000000000000000000000000000000;;		s := object.NewSearchIndex(vs.client.Client)
0000000000000000000000000000000000000000;;		err = s.Properties(ctx, host.Reference(), []string{DatastoreProperty}, &hostSystemMo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dsRefValues []string
0000000000000000000000000000000000000000;;		for _, dsRef := range hostSystemMo.Datastore {
0000000000000000000000000000000000000000;;			dsRefValues = append(dsRefValues, dsRef.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dsRefValues, nil
0000000000000000000000000000000000000000;;	}
