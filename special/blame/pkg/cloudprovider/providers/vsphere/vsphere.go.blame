0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
57533cf6bb728ec46476f2d0677ac79490905d05;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package vsphere
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/find"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/object"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/session"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pbm "github.com/vmware/govmomi/pbm"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		k8stypes "k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		k8runtime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProviderName                     = "vsphere"
0000000000000000000000000000000000000000;;		ActivePowerState                 = "poweredOn"
0000000000000000000000000000000000000000;;		SCSIControllerType               = "scsi"
0000000000000000000000000000000000000000;;		LSILogicControllerType           = "lsiLogic"
0000000000000000000000000000000000000000;;		BusLogicControllerType           = "busLogic"
0000000000000000000000000000000000000000;;		PVSCSIControllerType             = "pvscsi"
0000000000000000000000000000000000000000;;		LSILogicSASControllerType        = "lsiLogic-sas"
0000000000000000000000000000000000000000;;		SCSIControllerLimit              = 4
0000000000000000000000000000000000000000;;		SCSIControllerDeviceLimit        = 15
0000000000000000000000000000000000000000;;		SCSIDeviceSlots                  = 16
0000000000000000000000000000000000000000;;		SCSIReservedSlot                 = 7
0000000000000000000000000000000000000000;;		ThinDiskType                     = "thin"
0000000000000000000000000000000000000000;;		PreallocatedDiskType             = "preallocated"
0000000000000000000000000000000000000000;;		EagerZeroedThickDiskType         = "eagerZeroedThick"
0000000000000000000000000000000000000000;;		ZeroedThickDiskType              = "zeroedThick"
0000000000000000000000000000000000000000;;		VolDir                           = "kubevols"
0000000000000000000000000000000000000000;;		RoundTripperDefaultCount         = 3
0000000000000000000000000000000000000000;;		DummyVMPrefixName                = "vsphere-k8s"
0000000000000000000000000000000000000000;;		VSANDatastoreType                = "vsan"
0000000000000000000000000000000000000000;;		MAC_OUI_VC                       = "00:50:56"
0000000000000000000000000000000000000000;;		MAC_OUI_ESX                      = "00:0c:29"
0000000000000000000000000000000000000000;;		DiskNotFoundErrMsg               = "No vSphere disk ID found"
0000000000000000000000000000000000000000;;		NoDiskUUIDFoundErrMsg            = "No disk UUID found"
0000000000000000000000000000000000000000;;		NoDevicesFoundErrMsg             = "No devices found"
0000000000000000000000000000000000000000;;		NonSupportedControllerTypeErrMsg = "Disk is attached to non-supported controller type"
0000000000000000000000000000000000000000;;		FileAlreadyExistErrMsg           = "File requested already exist"
0000000000000000000000000000000000000000;;		CleanUpDummyVMRoutine_Interval   = 5
0000000000000000000000000000000000000000;;		UUIDPath                         = "/sys/class/dmi/id/product_serial"
0000000000000000000000000000000000000000;;		UUIDPrefix                       = "VMware-"
0000000000000000000000000000000000000000;;		NameProperty                     = "name"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Controller types that are currently supported for hot attach of disks
0000000000000000000000000000000000000000;;	// lsilogic driver type is currently not supported because,when a device gets detached
0000000000000000000000000000000000000000;;	// it fails to remove the device from the /dev path (which should be manually done)
0000000000000000000000000000000000000000;;	// making the subsequent attaches to the node to fail.
0000000000000000000000000000000000000000;;	// TODO: Add support for lsilogic driver type
0000000000000000000000000000000000000000;;	var supportedSCSIControllerType = []string{strings.ToLower(LSILogicSASControllerType), PVSCSIControllerType}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Maps user options to API parameters.
0000000000000000000000000000000000000000;;	// Keeping user options consistent with docker volume plugin for vSphere.
0000000000000000000000000000000000000000;;	// API: http://pubs.vmware.com/vsphere-60/index.jsp#com.vmware.wssdk.apiref.doc/vim.VirtualDiskManager.VirtualDiskType.html
0000000000000000000000000000000000000000;;	var diskFormatValidType = map[string]string{
0000000000000000000000000000000000000000;;		ThinDiskType:                              ThinDiskType,
0000000000000000000000000000000000000000;;		strings.ToLower(EagerZeroedThickDiskType): EagerZeroedThickDiskType,
0000000000000000000000000000000000000000;;		strings.ToLower(ZeroedThickDiskType):      PreallocatedDiskType,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DiskformatValidOptions = generateDiskFormatValidOptions()
0000000000000000000000000000000000000000;;	var cleanUpRoutineInitialized = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrNoDiskUUIDFound = errors.New(NoDiskUUIDFoundErrMsg)
0000000000000000000000000000000000000000;;	var ErrNoDiskIDFound = errors.New(DiskNotFoundErrMsg)
0000000000000000000000000000000000000000;;	var ErrNoDevicesFound = errors.New(NoDevicesFoundErrMsg)
0000000000000000000000000000000000000000;;	var ErrNonSupportedControllerType = errors.New(NonSupportedControllerTypeErrMsg)
0000000000000000000000000000000000000000;;	var ErrFileAlreadyExist = errors.New(FileAlreadyExistErrMsg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var clientLock sync.Mutex
0000000000000000000000000000000000000000;;	var cleanUpRoutineInitLock sync.Mutex
0000000000000000000000000000000000000000;;	var cleanUpDummyVMLock sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VSphere is an implementation of cloud provider Interface for VSphere.
0000000000000000000000000000000000000000;;	type VSphere struct {
0000000000000000000000000000000000000000;;		client *govmomi.Client
0000000000000000000000000000000000000000;;		cfg    *VSphereConfig
0000000000000000000000000000000000000000;;		// InstanceID of the server where this VSphere object is instantiated.
0000000000000000000000000000000000000000;;		localInstanceID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type VSphereConfig struct {
0000000000000000000000000000000000000000;;		Global struct {
0000000000000000000000000000000000000000;;			// vCenter username.
0000000000000000000000000000000000000000;;			User string `gcfg:"user"`
0000000000000000000000000000000000000000;;			// vCenter password in clear text.
0000000000000000000000000000000000000000;;			Password string `gcfg:"password"`
0000000000000000000000000000000000000000;;			// vCenter IP.
0000000000000000000000000000000000000000;;			VCenterIP string `gcfg:"server"`
0000000000000000000000000000000000000000;;			// vCenter port.
0000000000000000000000000000000000000000;;			VCenterPort string `gcfg:"port"`
0000000000000000000000000000000000000000;;			// True if vCenter uses self-signed cert.
0000000000000000000000000000000000000000;;			InsecureFlag bool `gcfg:"insecure-flag"`
0000000000000000000000000000000000000000;;			// Datacenter in which VMs are located.
0000000000000000000000000000000000000000;;			Datacenter string `gcfg:"datacenter"`
0000000000000000000000000000000000000000;;			// Datastore in which vmdks are stored.
0000000000000000000000000000000000000000;;			Datastore string `gcfg:"datastore"`
0000000000000000000000000000000000000000;;			// WorkingDir is path where VMs can be found.
0000000000000000000000000000000000000000;;			WorkingDir string `gcfg:"working-dir"`
0000000000000000000000000000000000000000;;			// Soap round tripper count (retries = RoundTripper - 1)
0000000000000000000000000000000000000000;;			RoundTripperCount uint `gcfg:"soap-roundtrip-count"`
0000000000000000000000000000000000000000;;			// VMUUID is the VM Instance UUID of virtual machine which can be retrieved from instanceUuid
0000000000000000000000000000000000000000;;			// property in VmConfigInfo, or also set as vc.uuid in VMX file.
0000000000000000000000000000000000000000;;			// If not set, will be fetched from the machine via sysfs (requires root)
0000000000000000000000000000000000000000;;			VMUUID string `gcfg:"vm-uuid"`
0000000000000000000000000000000000000000;;			// VMName is the VM name of virtual machine
0000000000000000000000000000000000000000;;			// Combining the WorkingDir and VMName can form a unique InstanceID.
0000000000000000000000000000000000000000;;			// When vm-name is set, no username/password is required on worker nodes.
0000000000000000000000000000000000000000;;			VMName string `gcfg:"vm-name"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Network struct {
0000000000000000000000000000000000000000;;			// PublicNetwork is name of the network the VMs are joined to.
0000000000000000000000000000000000000000;;			PublicNetwork string `gcfg:"public-network"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Disk struct {
0000000000000000000000000000000000000000;;			// SCSIControllerType defines SCSI controller to be used.
0000000000000000000000000000000000000000;;			SCSIControllerType string `dcfg:"scsicontrollertype"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Volumes interface {
0000000000000000000000000000000000000000;;		// AttachDisk attaches given disk to given node. Current node
0000000000000000000000000000000000000000;;		// is used when nodeName is empty string.
0000000000000000000000000000000000000000;;		AttachDisk(vmDiskPath string, storagePolicyID string, nodeName k8stypes.NodeName) (diskID string, diskUUID string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DetachDisk detaches given disk to given node. Current node
0000000000000000000000000000000000000000;;		// is used when nodeName is empty string.
0000000000000000000000000000000000000000;;		// Assumption: If node doesn't exist, disk is already detached from node.
0000000000000000000000000000000000000000;;		DetachDisk(volPath string, nodeName k8stypes.NodeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DiskIsAttached checks if a disk is attached to the given node.
0000000000000000000000000000000000000000;;		// Assumption: If node doesn't exist, disk is not attached to the node.
0000000000000000000000000000000000000000;;		DiskIsAttached(volPath string, nodeName k8stypes.NodeName) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DisksAreAttached checks if a list disks are attached to the given node.
0000000000000000000000000000000000000000;;		// Assumption: If node doesn't exist, disks are not attached to the node.
0000000000000000000000000000000000000000;;		DisksAreAttached(volPath []string, nodeName k8stypes.NodeName) (map[string]bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreateVolume creates a new vmdk with specified parameters.
0000000000000000000000000000000000000000;;		CreateVolume(volumeOptions *VolumeOptions) (volumePath string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeleteVolume deletes vmdk.
0000000000000000000000000000000000000000;;		DeleteVolume(vmDiskPath string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeOptions specifies capacity, tags, name and diskFormat for a volume.
0000000000000000000000000000000000000000;;	type VolumeOptions struct {
0000000000000000000000000000000000000000;;		CapacityKB             int
0000000000000000000000000000000000000000;;		Tags                   map[string]string
0000000000000000000000000000000000000000;;		Name                   string
0000000000000000000000000000000000000000;;		DiskFormat             string
0000000000000000000000000000000000000000;;		Datastore              string
0000000000000000000000000000000000000000;;		VSANStorageProfileData string
0000000000000000000000000000000000000000;;		StoragePolicyName      string
0000000000000000000000000000000000000000;;		StoragePolicyID        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generates Valid Options for Diskformat
0000000000000000000000000000000000000000;;	func generateDiskFormatValidOptions() string {
0000000000000000000000000000000000000000;;		validopts := ""
0000000000000000000000000000000000000000;;		for diskformat := range diskFormatValidType {
0000000000000000000000000000000000000000;;			validopts += (diskformat + ", ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		validopts = strings.TrimSuffix(validopts, ", ")
0000000000000000000000000000000000000000;;		return validopts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parses vSphere cloud config file and stores it into VSphereConfig.
0000000000000000000000000000000000000000;;	func readConfig(config io.Reader) (VSphereConfig, error) {
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("no vSphere cloud provider config file given")
0000000000000000000000000000000000000000;;			return VSphereConfig{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cfg VSphereConfig
0000000000000000000000000000000000000000;;		err := gcfg.ReadInto(&cfg, config)
0000000000000000000000000000000000000000;;		return cfg, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		registerMetrics()
0000000000000000000000000000000000000000;;		cloudprovider.RegisterCloudProvider(ProviderName, func(config io.Reader) (cloudprovider.Interface, error) {
0000000000000000000000000000000000000000;;			cfg, err := readConfig(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newVSphere(cfg)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize passes a Kubernetes clientBuilder interface to the cloud provider
0000000000000000000000000000000000000000;;	func (vs *VSphere) Initialize(clientBuilder controller.ControllerClientBuilder) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UUID gets the BIOS UUID via the sys interface.  This UUID is known by vsphere
0000000000000000000000000000000000000000;;	func getvmUUID() (string, error) {
0000000000000000000000000000000000000000;;		id, err := ioutil.ReadFile(UUIDPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error retrieving vm uuid: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uuidFromFile := string(id[:])
0000000000000000000000000000000000000000;;		//strip leading and trailing white space and new line char
0000000000000000000000000000000000000000;;		uuid := strings.TrimSpace(uuidFromFile)
0000000000000000000000000000000000000000;;		// check the uuid starts with "VMware-"
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(uuid, UUIDPrefix) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to match Prefix, UUID read from the file is %v", uuidFromFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Strip the prefix and while spaces and -
0000000000000000000000000000000000000000;;		uuid = strings.Replace(uuid[len(UUIDPrefix):(len(uuid))], " ", "", -1)
0000000000000000000000000000000000000000;;		uuid = strings.Replace(uuid, "-", "", -1)
0000000000000000000000000000000000000000;;		if len(uuid) != 32 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Length check failed, UUID read from the file is %v", uuidFromFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// need to add dashes, e.g. "564d395e-d807-e18a-cb25-b79f65eb2b9f"
0000000000000000000000000000000000000000;;		uuid = fmt.Sprintf("%s-%s-%s-%s-%s", uuid[0:8], uuid[8:12], uuid[12:16], uuid[16:20], uuid[20:32])
0000000000000000000000000000000000000000;;		return uuid, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the name of the VM on which this code is running.
0000000000000000000000000000000000000000;;	// Will attempt to determine the machine's name via it's UUID in this precedence order, failing if neither have a UUID:
0000000000000000000000000000000000000000;;	// * cloud config value VMUUID
0000000000000000000000000000000000000000;;	// * sysfs entry
0000000000000000000000000000000000000000;;	func getVMName(client *govmomi.Client, cfg *VSphereConfig) (string, error) {
0000000000000000000000000000000000000000;;		var vmUUID string
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Global.VMUUID != "" {
0000000000000000000000000000000000000000;;			vmUUID = cfg.Global.VMUUID
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// This needs root privileges on the host, and will fail otherwise.
0000000000000000000000000000000000000000;;			vmUUID, err = getvmUUID()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cfg.Global.VMUUID = vmUUID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vmUUID == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to determine machine ID from cloud configuration or sysfs")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create context
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new finder
0000000000000000000000000000000000000000;;		f := find.NewFinder(client.Client, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fetch and set data center
0000000000000000000000000000000000000000;;		dc, err := f.Datacenter(ctx, cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := object.NewSearchIndex(client.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svm, err := s.FindByUuid(ctx, dc, strings.ToLower(strings.TrimSpace(vmUUID)), true, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if svm == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to find machine reference by UUID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var vm mo.VirtualMachine
0000000000000000000000000000000000000000;;		err = s.Properties(ctx, svm.Reference(), []string{"name"}, &vm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vm.Name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newVSphere(cfg VSphereConfig) (*VSphere, error) {
0000000000000000000000000000000000000000;;		if cfg.Disk.SCSIControllerType == "" {
0000000000000000000000000000000000000000;;			cfg.Disk.SCSIControllerType = PVSCSIControllerType
0000000000000000000000000000000000000000;;		} else if !checkControllerSupported(cfg.Disk.SCSIControllerType) {
0000000000000000000000000000000000000000;;			glog.Errorf("%v is not a supported SCSI Controller type. Please configure 'lsilogic-sas' OR 'pvscsi'", cfg.Disk.SCSIControllerType)
0000000000000000000000000000000000000000;;			return nil, errors.New("Controller type not supported. Please configure 'lsilogic-sas' OR 'pvscsi'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.WorkingDir != "" {
0000000000000000000000000000000000000000;;			cfg.Global.WorkingDir = path.Clean(cfg.Global.WorkingDir) + "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.RoundTripperCount == 0 {
0000000000000000000000000000000000000000;;			cfg.Global.RoundTripperCount = RoundTripperDefaultCount
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.VCenterPort != "" {
0000000000000000000000000000000000000000;;			glog.Warningf("port is a deprecated field in vsphere.conf and will be removed in future release.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var c *govmomi.Client
0000000000000000000000000000000000000000;;		var id string
0000000000000000000000000000000000000000;;		if cfg.Global.VMName == "" {
0000000000000000000000000000000000000000;;			// if VMName is not set in the cloud config file, each nodes (including worker nodes) need credentials to obtain VMName from vCenter
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Cannot find VMName from cloud config file, start obtaining it from vCenter")
0000000000000000000000000000000000000000;;			c, err := newClient(context.TODO(), &cfg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			id, err = getVMName(c, &cfg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			id = cfg.Global.VMName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vs := VSphere{
0000000000000000000000000000000000000000;;			client:          c,
0000000000000000000000000000000000000000;;			cfg:             &cfg,
0000000000000000000000000000000000000000;;			localInstanceID: id,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runtime.SetFinalizer(&vs, logout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &vs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns if the given controller type is supported by the plugin
0000000000000000000000000000000000000000;;	func checkControllerSupported(ctrlType string) bool {
0000000000000000000000000000000000000000;;		for _, c := range supportedSCSIControllerType {
0000000000000000000000000000000000000000;;			if ctrlType == c {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logout(vs *VSphere) {
0000000000000000000000000000000000000000;;		if vs.client != nil {
0000000000000000000000000000000000000000;;			vs.client.Logout(context.TODO())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClient(ctx context.Context, cfg *VSphereConfig) (*govmomi.Client, error) {
0000000000000000000000000000000000000000;;		// Parse URL from string
0000000000000000000000000000000000000000;;		u, err := url.Parse(fmt.Sprintf("https://%s/sdk", cfg.Global.VCenterIP))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// set username and password for the URL
0000000000000000000000000000000000000000;;		u.User = url.UserPassword(cfg.Global.User, cfg.Global.Password)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Connect and log in to ESX or vCenter
0000000000000000000000000000000000000000;;		c, err := govmomi.NewClient(ctx, u, cfg.Global.InsecureFlag)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add retry functionality
0000000000000000000000000000000000000000;;		c.RoundTripper = vim25.Retry(c.RoundTripper, vim25.TemporaryNetworkError(int(cfg.Global.RoundTripperCount)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a client which communicates with vCenter.
0000000000000000000000000000000000000000;;	// This client can used to perform further vCenter operations.
0000000000000000000000000000000000000000;;	func vSphereLogin(ctx context.Context, vs *VSphere) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		clientLock.Lock()
0000000000000000000000000000000000000000;;		defer clientLock.Unlock()
0000000000000000000000000000000000000000;;		if vs.client == nil {
0000000000000000000000000000000000000000;;			vs.client, err = newClient(ctx, vs.cfg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := session.NewManager(vs.client.Client)
0000000000000000000000000000000000000000;;		// retrieve client's current session
0000000000000000000000000000000000000000;;		u, err := m.UserSession(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error while obtaining user session. err: %q", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Warningf("Creating new client session since the existing session is not valid or not authenticated")
0000000000000000000000000000000000000000;;		vs.client.Logout(ctx)
0000000000000000000000000000000000000000;;		vs.client, err = newClient(ctx, vs.cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns vSphere object `virtual machine` by its name.
0000000000000000000000000000000000000000;;	func getVirtualMachineByName(ctx context.Context, cfg *VSphereConfig, c *govmomi.Client, nodeName k8stypes.NodeName) (*object.VirtualMachine, error) {
0000000000000000000000000000000000000000;;		name := nodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new finder
0000000000000000000000000000000000000000;;		f := find.NewFinder(c.Client, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fetch and set data center
0000000000000000000000000000000000000000;;		dc, err := f.Datacenter(ctx, cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmRegex := cfg.Global.WorkingDir + name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve vm by name
0000000000000000000000000000000000000000;;		//TODO: also look for vm inside subfolders
0000000000000000000000000000000000000000;;		vm, err := f.VirtualMachine(ctx, vmRegex)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vm, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances returns an implementation of Instances for vSphere.
0000000000000000000000000000000000000000;;	func (vs *VSphere) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		return vs, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getLocalIP() ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		addrs := []v1.NodeAddress{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ifaces, err := net.Interfaces()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("net.Interfaces() failed for NodeAddresses - %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, i := range ifaces {
0000000000000000000000000000000000000000;;			localAddrs, err := i.Addrs()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to extract addresses for NodeAddresses - %v", err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, addr := range localAddrs {
0000000000000000000000000000000000000000;;					if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
0000000000000000000000000000000000000000;;						if ipnet.IP.To4() != nil {
0000000000000000000000000000000000000000;;							// Filter external IP by MAC address OUIs from vCenter and from ESX
0000000000000000000000000000000000000000;;							var addressType v1.NodeAddressType
0000000000000000000000000000000000000000;;							if strings.HasPrefix(i.HardwareAddr.String(), MAC_OUI_VC) ||
0000000000000000000000000000000000000000;;								strings.HasPrefix(i.HardwareAddr.String(), MAC_OUI_ESX) {
0000000000000000000000000000000000000000;;								v1helper.AddToNodeAddresses(&addrs,
0000000000000000000000000000000000000000;;									v1.NodeAddress{
0000000000000000000000000000000000000000;;										Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;										Address: ipnet.IP.String(),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									v1.NodeAddress{
0000000000000000000000000000000000000000;;										Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;										Address: ipnet.IP.String(),
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							glog.V(4).Infof("Find local IP address %v and set type to %v", ipnet.IP.String(), addressType)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getVMandMO returns the VM object and required field from the VM object
0000000000000000000000000000000000000000;;	func (vs *VSphere) getVMandMO(ctx context.Context, nodeName k8stypes.NodeName, field string) (vm *object.VirtualMachine, mvm *mo.VirtualMachine, err error) {
0000000000000000000000000000000000000000;;		// Ensure client is logged in and session is valid
0000000000000000000000000000000000000000;;		err = vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to login into vCenter - %v", err)
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vm, err = getVirtualMachineByName(ctx, vs.cfg, vs.client, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(*find.NotFoundError); ok {
0000000000000000000000000000000000000000;;				return nil, nil, cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve required field from VM object
0000000000000000000000000000000000000000;;		var movm mo.VirtualMachine
0000000000000000000000000000000000000000;;		collector := property.DefaultCollector(vs.client.Client)
0000000000000000000000000000000000000000;;		err = collector.RetrieveOne(ctx, vm.Reference(), []string{field}, &movm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vm, &movm, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddresses is an implementation of Instances.NodeAddresses.
0000000000000000000000000000000000000000;;	func (vs *VSphere) NodeAddresses(nodeName k8stypes.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		if vs.localInstanceID == nodeNameToVMName(nodeName) {
0000000000000000000000000000000000000000;;			/* Get local IP addresses if node is local node */
0000000000000000000000000000000000000000;;			return getLocalIP()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addrs := []v1.NodeAddress{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create context
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, mvm, err := vs.getVMandMO(ctx, nodeName, "guest.net")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to getVMandMO for NodeAddresses: err %v", err)
0000000000000000000000000000000000000000;;			return addrs, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve VM's ip(s)
0000000000000000000000000000000000000000;;		for _, v := range mvm.Guest.Net {
0000000000000000000000000000000000000000;;			if vs.cfg.Network.PublicNetwork == v.Network {
0000000000000000000000000000000000000000;;				for _, ip := range v.IpAddress {
0000000000000000000000000000000000000000;;					if net.ParseIP(ip).To4() != nil {
0000000000000000000000000000000000000000;;						v1helper.AddToNodeAddresses(&addrs,
0000000000000000000000000000000000000000;;							v1.NodeAddress{
0000000000000000000000000000000000000000;;								Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;								Address: ip,
0000000000000000000000000000000000000000;;							}, v1.NodeAddress{
0000000000000000000000000000000000000000;;								Type:    v1.NodeInternalIP,
0000000000000000000000000000000000000000;;								Address: ip,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddressesByProviderID returns the node addresses of an instances with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (vs *VSphere) NodeAddressesByProviderID(providerID string) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		vmName := path.Base(providerID)
0000000000000000000000000000000000000000;;		return vs.NodeAddresses(vmNameToNodeName(vmName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) AddSSHKeyToAllInstances(user string, keyData []byte) error {
0000000000000000000000000000000000000000;;		return errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) CurrentNodeName(hostname string) (k8stypes.NodeName, error) {
0000000000000000000000000000000000000000;;		return vmNameToNodeName(vs.localInstanceID), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeNameToVMName maps a NodeName to the vmware infrastructure name
0000000000000000000000000000000000000000;;	func nodeNameToVMName(nodeName k8stypes.NodeName) string {
0000000000000000000000000000000000000000;;		return string(nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeNameToVMName maps a vmware infrastructure name to a NodeName
0000000000000000000000000000000000000000;;	func vmNameToNodeName(vmName string) k8stypes.NodeName {
0000000000000000000000000000000000000000;;		return k8stypes.NodeName(vmName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalID returns the cloud provider ID of the node with the specified Name (deprecated).
0000000000000000000000000000000000000000;;	func (vs *VSphere) ExternalID(nodeName k8stypes.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		if vs.localInstanceID == nodeNameToVMName(nodeName) {
0000000000000000000000000000000000000000;;			return vs.cfg.Global.WorkingDir + vs.localInstanceID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create context
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vm, mvm, err := vs.getVMandMO(ctx, nodeName, "summary")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to getVMandMO for ExternalID: err %v", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mvm.Summary.Runtime.PowerState == ActivePowerState {
0000000000000000000000000000000000000000;;			return vm.InventoryPath, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mvm.Summary.Config.Template == false {
0000000000000000000000000000000000000000;;			glog.Warningf("VM %s, is not in %s state", nodeName, ActivePowerState)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Warningf("VM %s, is a template", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the cloud provider ID of the node with the specified Name.
0000000000000000000000000000000000000000;;	func (vs *VSphere) InstanceID(nodeName k8stypes.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		if vs.localInstanceID == nodeNameToVMName(nodeName) {
0000000000000000000000000000000000000000;;			return vs.cfg.Global.WorkingDir + vs.localInstanceID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create context
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vm, mvm, err := vs.getVMandMO(ctx, nodeName, "summary")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to getVMandMO for InstanceID: err %v", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mvm.Summary.Runtime.PowerState == ActivePowerState {
0000000000000000000000000000000000000000;;			return "/" + vm.InventoryPath, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mvm.Summary.Config.Template == false {
0000000000000000000000000000000000000000;;			glog.Warningf("VM %s, is not in %s state", nodeName, ActivePowerState)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Warningf("VM %s, is a template", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceTypeByProviderID returns the cloudprovider instance type of the node with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (vs *VSphere) InstanceTypeByProviderID(providerID string) (string, error) {
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) InstanceType(name k8stypes.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) Clusters() (cloudprovider.Clusters, bool) {
0000000000000000000000000000000000000000;;		return nil, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;	func (vs *VSphere) ProviderName() string {
0000000000000000000000000000000000000000;;		return ProviderName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer returns an implementation of LoadBalancer for vSphere.
0000000000000000000000000000000000000000;;	func (vs *VSphere) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zones returns an implementation of Zones for Google vSphere.
0000000000000000000000000000000000000000;;	func (vs *VSphere) Zones() (cloudprovider.Zones, bool) {
0000000000000000000000000000000000000000;;		glog.V(1).Info("The vSphere cloud provider does not support zones")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Routes returns a false since the interface is not supported for vSphere.
0000000000000000000000000000000000000000;;	func (vs *VSphere) Routes() (cloudprovider.Routes, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScrubDNS filters DNS settings for pods.
0000000000000000000000000000000000000000;;	func (vs *VSphere) ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string) {
0000000000000000000000000000000000000000;;		return nameservers, searches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns vSphere objects virtual machine, virtual device list, datastore and datacenter.
0000000000000000000000000000000000000000;;	func getVirtualMachineDevices(ctx context.Context, cfg *VSphereConfig, c *govmomi.Client, name string) (*object.VirtualMachine, object.VirtualDeviceList, *object.Datacenter, error) {
0000000000000000000000000000000000000000;;		// Create a new finder
0000000000000000000000000000000000000000;;		f := find.NewFinder(c.Client, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fetch and set data center
0000000000000000000000000000000000000000;;		dc, err := f.Datacenter(ctx, cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmRegex := cfg.Global.WorkingDir + name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vm, err := f.VirtualMachine(ctx, vmRegex)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get devices from VM
0000000000000000000000000000000000000000;;		vmDevices, err := vm.Device(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vm, vmDevices, dc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes SCSI controller which is latest attached to VM.
0000000000000000000000000000000000000000;;	func cleanUpController(ctx context.Context, newSCSIController types.BaseVirtualDevice, vmDevices object.VirtualDeviceList, vm *object.VirtualMachine) error {
0000000000000000000000000000000000000000;;		if newSCSIController == nil || vmDevices == nil || vm == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctls := vmDevices.SelectByType(newSCSIController)
0000000000000000000000000000000000000000;;		if len(ctls) < 1 {
0000000000000000000000000000000000000000;;			return ErrNoDevicesFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newScsi := ctls[len(ctls)-1]
0000000000000000000000000000000000000000;;		err := vm.RemoveDevice(ctx, true, newScsi)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attaches given virtual disk volume to the compute running kubelet.
0000000000000000000000000000000000000000;;	func (vs *VSphere) AttachDisk(vmDiskPath string, storagePolicyID string, nodeName k8stypes.NodeName) (diskID string, diskUUID string, err error) {
0000000000000000000000000000000000000000;;		attachDiskInternal := func(vmDiskPath string, storagePolicyID string, nodeName k8stypes.NodeName) (diskID string, diskUUID string, err error) {
0000000000000000000000000000000000000000;;			var newSCSIController types.BaseVirtualDevice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create context
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure client is logged in and session is valid
0000000000000000000000000000000000000000;;			err = vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to login into vCenter - %v", err)
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find virtual machine to attach disk to
0000000000000000000000000000000000000000;;			var vSphereInstance string
0000000000000000000000000000000000000000;;			if nodeName == "" {
0000000000000000000000000000000000000000;;				vSphereInstance = vs.localInstanceID
0000000000000000000000000000000000000000;;				nodeName = vmNameToNodeName(vSphereInstance)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vSphereInstance = nodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get VM device list
0000000000000000000000000000000000000000;;			vm, vmDevices, dc, err := getVirtualMachineDevices(ctx, vs.cfg, vs.client, vSphereInstance)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attached, err := checkDiskAttached(vmDiskPath, vmDevices, dc, vs.client)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if attached {
0000000000000000000000000000000000000000;;				diskID, _ = getVirtualDiskID(vmDiskPath, vmDevices, dc, vs.client)
0000000000000000000000000000000000000000;;				diskUUID, _ = getVirtualDiskUUIDByPath(vmDiskPath, dc, vs.client)
0000000000000000000000000000000000000000;;				return diskID, diskUUID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var diskControllerType = vs.cfg.Disk.SCSIControllerType
0000000000000000000000000000000000000000;;			// find SCSI controller of particular type from VM devices
0000000000000000000000000000000000000000;;			scsiControllersOfRequiredType := getSCSIControllersOfType(vmDevices, diskControllerType)
0000000000000000000000000000000000000000;;			scsiController := getAvailableSCSIController(scsiControllersOfRequiredType)
0000000000000000000000000000000000000000;;			newSCSICreated := false
0000000000000000000000000000000000000000;;			if scsiController == nil {
0000000000000000000000000000000000000000;;				newSCSIController, err = createAndAttachSCSIControllerToVM(ctx, vm, diskControllerType)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to create SCSI controller for VM :%q with err: %+v", vm.Name(), err)
0000000000000000000000000000000000000000;;					return "", "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Get VM device list
0000000000000000000000000000000000000000;;				_, vmDevices, _, err := getVirtualMachineDevices(ctx, vs.cfg, vs.client, vSphereInstance)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("cannot get vmDevices for VM err=%s", err)
0000000000000000000000000000000000000000;;					return "", "", fmt.Errorf("cannot get vmDevices for VM err=%s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				scsiControllersOfRequiredType := getSCSIControllersOfType(vmDevices, diskControllerType)
0000000000000000000000000000000000000000;;				scsiController := getAvailableSCSIController(scsiControllersOfRequiredType)
0000000000000000000000000000000000000000;;				if scsiController == nil {
0000000000000000000000000000000000000000;;					glog.Errorf("cannot find SCSI controller in VM")
0000000000000000000000000000000000000000;;					// attempt clean up of scsi controller
0000000000000000000000000000000000000000;;					cleanUpController(ctx, newSCSIController, vmDevices, vm)
0000000000000000000000000000000000000000;;					return "", "", fmt.Errorf("cannot find SCSI controller in VM")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newSCSICreated = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a new finder
0000000000000000000000000000000000000000;;			f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;			// Set data center
0000000000000000000000000000000000000000;;			f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			datastorePathObj := new(object.DatastorePath)
0000000000000000000000000000000000000000;;			isSuccess := datastorePathObj.FromString(vmDiskPath)
0000000000000000000000000000000000000000;;			if !isSuccess {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to parse vmDiskPath: %+q", vmDiskPath)
0000000000000000000000000000000000000000;;				return "", "", errors.New("Failed to parse vmDiskPath")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ds, err := f.Datastore(ctx, datastorePathObj.Datastore)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed while searching for datastore %+q. err %s", datastorePathObj.Datastore, err)
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vmDiskPath = removeClusterFromVDiskPath(vmDiskPath)
0000000000000000000000000000000000000000;;			disk := vmDevices.CreateDisk(scsiController, ds.Reference(), vmDiskPath)
0000000000000000000000000000000000000000;;			unitNumber, err := getNextUnitNumber(vmDevices, scsiController)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("cannot attach disk to VM, limit reached - %v.", err)
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*disk.UnitNumber = unitNumber
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			backing := disk.Backing.(*types.VirtualDiskFlatVer2BackingInfo)
0000000000000000000000000000000000000000;;			backing.DiskMode = string(types.VirtualDiskModeIndependent_persistent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			virtualMachineConfigSpec := types.VirtualMachineConfigSpec{}
0000000000000000000000000000000000000000;;			deviceConfigSpec := &types.VirtualDeviceConfigSpec{
0000000000000000000000000000000000000000;;				Device:    disk,
0000000000000000000000000000000000000000;;				Operation: types.VirtualDeviceConfigSpecOperationAdd,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Configure the disk with the SPBM profile only if ProfileID is not empty.
0000000000000000000000000000000000000000;;			if storagePolicyID != "" {
0000000000000000000000000000000000000000;;				profileSpec := &types.VirtualMachineDefinedProfileSpec{
0000000000000000000000000000000000000000;;					ProfileId: storagePolicyID,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				deviceConfigSpec.Profile = append(deviceConfigSpec.Profile, profileSpec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			virtualMachineConfigSpec.DeviceChange = append(virtualMachineConfigSpec.DeviceChange, deviceConfigSpec)
0000000000000000000000000000000000000000;;			requestTime := time.Now()
0000000000000000000000000000000000000000;;			task, err := vm.Reconfigure(ctx, virtualMachineConfigSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				recordvSphereMetric(api_attachvolume, requestTime, err)
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to attach the disk with storagePolicy: %+q with err - %v", storagePolicyID, err)
0000000000000000000000000000000000000000;;				if newSCSICreated {
0000000000000000000000000000000000000000;;					cleanUpController(ctx, newSCSIController, vmDevices, vm)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = task.Wait(ctx)
0000000000000000000000000000000000000000;;			recordvSphereMetric(api_attachvolume, requestTime, err)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to attach the disk with storagePolicy: %+q with err - %v", storagePolicyID, err)
0000000000000000000000000000000000000000;;				if newSCSICreated {
0000000000000000000000000000000000000000;;					cleanUpController(ctx, newSCSIController, vmDevices, vm)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			deviceName, diskUUID, err := getVMDiskInfo(ctx, vm, disk)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if newSCSICreated {
0000000000000000000000000000000000000000;;					cleanUpController(ctx, newSCSIController, vmDevices, vm)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				vs.DetachDisk(deviceName, nodeName)
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return deviceName, diskUUID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		diskID, diskUUID, err = attachDiskInternal(vmDiskPath, storagePolicyID, nodeName)
0000000000000000000000000000000000000000;;		recordvSphereMetric(operation_attachvolume, requestTime, err)
0000000000000000000000000000000000000000;;		return diskID, diskUUID, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVMDiskInfo(ctx context.Context, vm *object.VirtualMachine, disk *types.VirtualDisk) (string, string, error) {
0000000000000000000000000000000000000000;;		vmDevices, err := vm.Device(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		devices := vmDevices.SelectByType(disk)
0000000000000000000000000000000000000000;;		if len(devices) < 1 {
0000000000000000000000000000000000000000;;			return "", "", ErrNoDevicesFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get new disk id
0000000000000000000000000000000000000000;;		newDevice := devices[len(devices)-1]
0000000000000000000000000000000000000000;;		deviceName := devices.Name(newDevice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get device uuid
0000000000000000000000000000000000000000;;		diskUUID, err := getVirtualDiskUUID(newDevice)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return deviceName, diskUUID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func getNextUnitNumber(devices object.VirtualDeviceList, c types.BaseVirtualController) (int32, error) {
0000000000000000000000000000000000000000;;		// get next available SCSI controller unit number
0000000000000000000000000000000000000000;;		var takenUnitNumbers [SCSIDeviceSlots]bool
0000000000000000000000000000000000000000;;		takenUnitNumbers[SCSIReservedSlot] = true
0000000000000000000000000000000000000000;;		key := c.GetVirtualController().Key
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, device := range devices {
0000000000000000000000000000000000000000;;			d := device.GetVirtualDevice()
0000000000000000000000000000000000000000;;			if d.ControllerKey == key {
0000000000000000000000000000000000000000;;				if d.UnitNumber != nil {
0000000000000000000000000000000000000000;;					takenUnitNumbers[*d.UnitNumber] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for unitNumber, takenUnitNumber := range takenUnitNumbers {
0000000000000000000000000000000000000000;;			if !takenUnitNumber {
0000000000000000000000000000000000000000;;				return int32(unitNumber), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, fmt.Errorf("SCSI Controller with key=%d does not have any available slots (LUN).", key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSCSIController(vmDevices object.VirtualDeviceList, scsiType string) *types.VirtualController {
0000000000000000000000000000000000000000;;		// get virtual scsi controller of passed argument type
0000000000000000000000000000000000000000;;		for _, device := range vmDevices {
0000000000000000000000000000000000000000;;			devType := vmDevices.Type(device)
0000000000000000000000000000000000000000;;			if devType == scsiType {
0000000000000000000000000000000000000000;;				if c, ok := device.(types.BaseVirtualController); ok {
0000000000000000000000000000000000000000;;					return c.GetVirtualController()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSCSIControllersOfType(vmDevices object.VirtualDeviceList, scsiType string) []*types.VirtualController {
0000000000000000000000000000000000000000;;		// get virtual scsi controllers of passed argument type
0000000000000000000000000000000000000000;;		var scsiControllers []*types.VirtualController
0000000000000000000000000000000000000000;;		for _, device := range vmDevices {
0000000000000000000000000000000000000000;;			devType := vmDevices.Type(device)
0000000000000000000000000000000000000000;;			if devType == scsiType {
0000000000000000000000000000000000000000;;				if c, ok := device.(types.BaseVirtualController); ok {
0000000000000000000000000000000000000000;;					scsiControllers = append(scsiControllers, c.GetVirtualController())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scsiControllers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSCSIControllers(vmDevices object.VirtualDeviceList) []*types.VirtualController {
0000000000000000000000000000000000000000;;		// get all virtual scsi controllers
0000000000000000000000000000000000000000;;		var scsiControllers []*types.VirtualController
0000000000000000000000000000000000000000;;		for _, device := range vmDevices {
0000000000000000000000000000000000000000;;			devType := vmDevices.Type(device)
0000000000000000000000000000000000000000;;			switch devType {
0000000000000000000000000000000000000000;;			case SCSIControllerType, strings.ToLower(LSILogicControllerType), strings.ToLower(BusLogicControllerType), PVSCSIControllerType, strings.ToLower(LSILogicSASControllerType):
0000000000000000000000000000000000000000;;				if c, ok := device.(types.BaseVirtualController); ok {
0000000000000000000000000000000000000000;;					scsiControllers = append(scsiControllers, c.GetVirtualController())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scsiControllers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAvailableSCSIController(scsiControllers []*types.VirtualController) *types.VirtualController {
0000000000000000000000000000000000000000;;		// get SCSI controller which has space for adding more devices
0000000000000000000000000000000000000000;;		for _, controller := range scsiControllers {
0000000000000000000000000000000000000000;;			if len(controller.Device) < SCSIControllerDeviceLimit {
0000000000000000000000000000000000000000;;				return controller
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiskIsAttached returns if disk is attached to the VM using controllers supported by the plugin.
0000000000000000000000000000000000000000;;	func (vs *VSphere) DiskIsAttached(volPath string, nodeName k8stypes.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		diskIsAttachedInternal := func(volPath string, nodeName k8stypes.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure client is logged in and session is valid
0000000000000000000000000000000000000000;;			err := vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to login into vCenter - %v", err)
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find VM to detach disk from
0000000000000000000000000000000000000000;;			var vSphereInstance string
0000000000000000000000000000000000000000;;			if nodeName == "" {
0000000000000000000000000000000000000000;;				vSphereInstance = vs.localInstanceID
0000000000000000000000000000000000000000;;				nodeName = vmNameToNodeName(vSphereInstance)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vSphereInstance = nodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeExist, err := vs.NodeExists(nodeName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to check whether node exist. err: %s.", err)
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !nodeExist {
0000000000000000000000000000000000000000;;				glog.Errorf("DiskIsAttached failed to determine whether disk %q is still attached: node %q does not exist",
0000000000000000000000000000000000000000;;					volPath,
0000000000000000000000000000000000000000;;					vSphereInstance)
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("DiskIsAttached failed to determine whether disk %q is still attached: node %q does not exist",
0000000000000000000000000000000000000000;;					volPath,
0000000000000000000000000000000000000000;;					vSphereInstance)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get VM device list
0000000000000000000000000000000000000000;;			_, vmDevices, dc, err := getVirtualMachineDevices(ctx, vs.cfg, vs.client, vSphereInstance)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to get VM devices for VM %#q. err: %s", vSphereInstance, err)
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attached, err := checkDiskAttached(volPath, vmDevices, dc, vs.client)
0000000000000000000000000000000000000000;;			return attached, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		isAttached, err := diskIsAttachedInternal(volPath, nodeName)
0000000000000000000000000000000000000000;;		recordvSphereMetric(operation_diskIsAttached, requestTime, err)
0000000000000000000000000000000000000000;;		return isAttached, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisksAreAttached returns if disks are attached to the VM using controllers supported by the plugin.
0000000000000000000000000000000000000000;;	func (vs *VSphere) DisksAreAttached(volPaths []string, nodeName k8stypes.NodeName) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		disksAreAttachedInternal := func(volPaths []string, nodeName k8stypes.NodeName) (map[string]bool, error) {
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create vSphere client
0000000000000000000000000000000000000000;;			err := vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to login into vCenter, err: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find VM to detach disk from
0000000000000000000000000000000000000000;;			var vSphereInstance string
0000000000000000000000000000000000000000;;			if nodeName == "" {
0000000000000000000000000000000000000000;;				vSphereInstance = vs.localInstanceID
0000000000000000000000000000000000000000;;				nodeName = vmNameToNodeName(vSphereInstance)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vSphereInstance = nodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nodeExist, err := vs.NodeExists(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to check whether node exist. err: %s.", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !nodeExist {
0000000000000000000000000000000000000000;;				glog.Errorf("DisksAreAttached failed to determine whether disks %v are still attached: node %q does not exist",
0000000000000000000000000000000000000000;;					volPaths,
0000000000000000000000000000000000000000;;					vSphereInstance)
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("DisksAreAttached failed to determine whether disks %v are still attached: node %q does not exist",
0000000000000000000000000000000000000000;;					volPaths,
0000000000000000000000000000000000000000;;					vSphereInstance)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get VM device list
0000000000000000000000000000000000000000;;			_, vmDevices, dc, err := getVirtualMachineDevices(ctx, vs.cfg, vs.client, vSphereInstance)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to get VM devices for VM %#q. err: %s", vSphereInstance, err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attached := make(map[string]bool)
0000000000000000000000000000000000000000;;			for _, volPath := range volPaths {
0000000000000000000000000000000000000000;;				result, err := checkDiskAttached(volPath, vmDevices, dc, vs.client)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if result {
0000000000000000000000000000000000000000;;						attached[volPath] = true
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						attached[volPath] = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return attached, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		attached, err := disksAreAttachedInternal(volPaths, nodeName)
0000000000000000000000000000000000000000;;		recordvSphereMetric(operation_disksAreAttached, requestTime, err)
0000000000000000000000000000000000000000;;		return attached, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkDiskAttached(volPath string, vmdevices object.VirtualDeviceList, dc *object.Datacenter, client *govmomi.Client) (bool, error) {
0000000000000000000000000000000000000000;;		_, err := getVirtualDiskControllerKey(volPath, vmdevices, dc, client)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == ErrNoDevicesFound {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to check whether disk is attached. err: %s", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the object key that denotes the controller object to which vmdk is attached.
0000000000000000000000000000000000000000;;	func getVirtualDiskControllerKey(volPath string, vmDevices object.VirtualDeviceList, dc *object.Datacenter, client *govmomi.Client) (int32, error) {
0000000000000000000000000000000000000000;;		volPath = removeClusterFromVDiskPath(volPath)
0000000000000000000000000000000000000000;;		volumeUUID, err := getVirtualDiskUUIDByPath(volPath, dc, client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("disk uuid not found for %v. err: %s", volPath, err)
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// filter vm devices to retrieve disk ID for the given vmdk file
0000000000000000000000000000000000000000;;		for _, device := range vmDevices {
0000000000000000000000000000000000000000;;			if vmDevices.TypeName(device) == "VirtualDisk" {
0000000000000000000000000000000000000000;;				diskUUID, _ := getVirtualDiskUUID(device)
0000000000000000000000000000000000000000;;				if diskUUID == volumeUUID {
0000000000000000000000000000000000000000;;					return device.GetVirtualDevice().ControllerKey, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, ErrNoDevicesFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns key of the controller.
0000000000000000000000000000000000000000;;	// Key is unique id that distinguishes one device from other devices in the same virtual machine.
0000000000000000000000000000000000000000;;	func getControllerKey(scsiType string, vmDevices object.VirtualDeviceList) (int32, error) {
0000000000000000000000000000000000000000;;		for _, device := range vmDevices {
0000000000000000000000000000000000000000;;			devType := vmDevices.Type(device)
0000000000000000000000000000000000000000;;			if devType == scsiType {
0000000000000000000000000000000000000000;;				if c, ok := device.(types.BaseVirtualController); ok {
0000000000000000000000000000000000000000;;					return c.GetVirtualController().Key, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, ErrNoDevicesFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns formatted UUID for a virtual disk device.
0000000000000000000000000000000000000000;;	func getVirtualDiskUUID(newDevice types.BaseVirtualDevice) (string, error) {
0000000000000000000000000000000000000000;;		vd := newDevice.GetVirtualDevice()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b, ok := vd.Backing.(*types.VirtualDiskFlatVer2BackingInfo); ok {
0000000000000000000000000000000000000000;;			uuid := formatVirtualDiskUUID(b.Uuid)
0000000000000000000000000000000000000000;;			return uuid, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", ErrNoDiskUUIDFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatVirtualDiskUUID(uuid string) string {
0000000000000000000000000000000000000000;;		uuidwithNoSpace := strings.Replace(uuid, " ", "", -1)
0000000000000000000000000000000000000000;;		uuidWithNoHypens := strings.Replace(uuidwithNoSpace, "-", "", -1)
0000000000000000000000000000000000000000;;		return strings.ToLower(uuidWithNoHypens)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets virtual disk UUID by datastore (namespace) path
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// volPath can be namespace path (e.g. "[vsanDatastore] volumes/test.vmdk") or
0000000000000000000000000000000000000000;;	// uuid path (e.g. "[vsanDatastore] 59427457-6c5a-a917-7997-0200103eedbc/test.vmdk").
0000000000000000000000000000000000000000;;	// `volumes` in this case would be a symlink to
0000000000000000000000000000000000000000;;	// `59427457-6c5a-a917-7997-0200103eedbc`.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We want users to use namespace path. It is good for attaching the disk,
0000000000000000000000000000000000000000;;	// but for detaching the API requires uuid path.  Hence, to detach the right
0000000000000000000000000000000000000000;;	// device we have to convert the namespace path to uuid path.
0000000000000000000000000000000000000000;;	func getVirtualDiskUUIDByPath(volPath string, dc *object.Datacenter, client *govmomi.Client) (string, error) {
0000000000000000000000000000000000000000;;		if len(volPath) > 0 && filepath.Ext(volPath) != ".vmdk" {
0000000000000000000000000000000000000000;;			volPath += ".vmdk"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VirtualDiskManager provides a way to manage and manipulate virtual disks on vmware datastores.
0000000000000000000000000000000000000000;;		vdm := object.NewVirtualDiskManager(client.Client)
0000000000000000000000000000000000000000;;		// Returns uuid of vmdk virtual disk
0000000000000000000000000000000000000000;;		diskUUID, err := vdm.QueryVirtualDiskUuid(ctx, volPath, dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", ErrNoDiskUUIDFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskUUID = formatVirtualDiskUUID(diskUUID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return diskUUID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a device id which is internal vSphere API identifier for the attached virtual disk.
0000000000000000000000000000000000000000;;	func getVirtualDiskID(volPath string, vmDevices object.VirtualDeviceList, dc *object.Datacenter, client *govmomi.Client) (string, error) {
0000000000000000000000000000000000000000;;		volumeUUID, err := getVirtualDiskUUIDByPath(volPath, dc, client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("disk uuid not found for %v ", volPath)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// filter vm devices to retrieve disk ID for the given vmdk file
0000000000000000000000000000000000000000;;		for _, device := range vmDevices {
0000000000000000000000000000000000000000;;			if vmDevices.TypeName(device) == "VirtualDisk" {
0000000000000000000000000000000000000000;;				diskUUID, _ := getVirtualDiskUUID(device)
0000000000000000000000000000000000000000;;				if diskUUID == volumeUUID {
0000000000000000000000000000000000000000;;					return vmDevices.Name(device), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", ErrNoDiskIDFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetachDisk detaches given virtual disk volume from the compute running kubelet.
0000000000000000000000000000000000000000;;	func (vs *VSphere) DetachDisk(volPath string, nodeName k8stypes.NodeName) error {
0000000000000000000000000000000000000000;;		detachDiskInternal := func(volPath string, nodeName k8stypes.NodeName) error {
0000000000000000000000000000000000000000;;			// Create context
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure client is logged in and session is valid
0000000000000000000000000000000000000000;;			err := vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to login into vCenter - %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find virtual machine to attach disk to
0000000000000000000000000000000000000000;;			var vSphereInstance string
0000000000000000000000000000000000000000;;			if nodeName == "" {
0000000000000000000000000000000000000000;;				vSphereInstance = vs.localInstanceID
0000000000000000000000000000000000000000;;				nodeName = vmNameToNodeName(vSphereInstance)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vSphereInstance = nodeNameToVMName(nodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			vm, vmDevices, dc, err := getVirtualMachineDevices(ctx, vs.cfg, vs.client, vSphereInstance)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volPath = removeClusterFromVDiskPath(volPath)
0000000000000000000000000000000000000000;;			diskID, err := getVirtualDiskID(volPath, vmDevices, dc, vs.client)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("disk ID not found for %v ", volPath)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Gets virtual disk device
0000000000000000000000000000000000000000;;			device := vmDevices.Find(diskID)
0000000000000000000000000000000000000000;;			if device == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("device '%s' not found", diskID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach disk from VM
0000000000000000000000000000000000000000;;			requestTime := time.Now()
0000000000000000000000000000000000000000;;			err = vm.RemoveDevice(ctx, true, device)
0000000000000000000000000000000000000000;;			recordvSphereMetric(api_detachvolume, requestTime, err)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		err := detachDiskInternal(volPath, nodeName)
0000000000000000000000000000000000000000;;		recordvSphereMetric(operation_detachvolume, requestTime, nil)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateVolume creates a volume of given size (in KiB).
0000000000000000000000000000000000000000;;	func (vs *VSphere) CreateVolume(volumeOptions *VolumeOptions) (volumePath string, err error) {
0000000000000000000000000000000000000000;;		createVolumeInternal := func(volumeOptions *VolumeOptions) (volumePath string, err error) {
0000000000000000000000000000000000000000;;			var datastore string
0000000000000000000000000000000000000000;;			var destVolPath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Default datastore is the datastore in the vSphere config file that is used initialize vSphere cloud provider.
0000000000000000000000000000000000000000;;			if volumeOptions.Datastore == "" {
0000000000000000000000000000000000000000;;				datastore = vs.cfg.Global.Datastore
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				datastore = volumeOptions.Datastore
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Default diskformat as 'thin'
0000000000000000000000000000000000000000;;			if volumeOptions.DiskFormat == "" {
0000000000000000000000000000000000000000;;				volumeOptions.DiskFormat = ThinDiskType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, ok := diskFormatValidType[volumeOptions.DiskFormat]; !ok {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("Cannot create disk. Error diskformat %+q."+
0000000000000000000000000000000000000000;;					" Valid options are %s.", volumeOptions.DiskFormat, DiskformatValidOptions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create context
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure client is logged in and session is valid
0000000000000000000000000000000000000000;;			err = vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to login into vCenter - %v", err)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a new finder
0000000000000000000000000000000000000000;;			f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Fetch and set data center
0000000000000000000000000000000000000000;;			dc, err := f.Datacenter(ctx, vs.cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;			f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if volumeOptions.StoragePolicyName != "" {
0000000000000000000000000000000000000000;;				// Get the pbm client
0000000000000000000000000000000000000000;;				pbmClient, err := pbm.NewClient(ctx, vs.client.Client)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				volumeOptions.StoragePolicyID, err = pbmClient.ProfileIDByName(ctx, volumeOptions.StoragePolicyName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					recordvSphereMetric(operation_createvolume_with_policy, time.Time{}, err)
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				compatibilityResult, err := vs.GetPlacementCompatibilityResult(ctx, pbmClient, volumeOptions.StoragePolicyID)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(compatibilityResult) < 1 {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("There are no compatible datastores that satisfy the storage policy: %+q requirements", volumeOptions.StoragePolicyID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if volumeOptions.Datastore != "" {
0000000000000000000000000000000000000000;;					ok, nonCompatibleDsref := vs.IsUserSpecifiedDatastoreNonCompatible(ctx, compatibilityResult, volumeOptions.Datastore)
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						faultMsg := GetNonCompatibleDatastoreFaultMsg(compatibilityResult, *nonCompatibleDsref)
0000000000000000000000000000000000000000;;						return "", fmt.Errorf("User specified datastore: %q is not compatible with the storagePolicy: %q. Failed with faults: %+q", volumeOptions.Datastore, volumeOptions.StoragePolicyName, faultMsg)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					dsMoList, err := vs.GetCompatibleDatastoresMo(ctx, compatibilityResult)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						recordvSphereMetric(operation_createvolume_with_raw_vsan_policy, time.Time{}, err)
0000000000000000000000000000000000000000;;						return "", err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dsMo := GetMostFreeDatastore(dsMoList)
0000000000000000000000000000000000000000;;					datastore = dsMo.Info.GetDatastoreInfo().Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ds, err := f.Datastore(ctx, datastore)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed while searching for datastore %+q. err %s", datastore, err)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if volumeOptions.VSANStorageProfileData != "" {
0000000000000000000000000000000000000000;;				// Check if the datastore is VSAN if any capability requirements are specified.
0000000000000000000000000000000000000000;;				// VSphere cloud provider now only supports VSAN capabilities requirements
0000000000000000000000000000000000000000;;				ok, err := checkIfDatastoreTypeIsVSAN(vs.client, ds)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("Failed while determining whether the datastore: %q"+
0000000000000000000000000000000000000000;;						" is VSAN or not.", datastore)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("The specified datastore: %q is not a VSAN datastore."+
0000000000000000000000000000000000000000;;						" The policy parameters will work only with VSAN Datastore."+
0000000000000000000000000000000000000000;;						" So, please specify a valid VSAN datastore in Storage class definition.", datastore)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Create a disk with the VSAN storage capabilities specified in the volumeOptions.VSANStorageProfileData.
0000000000000000000000000000000000000000;;			// This is achieved by following steps:
0000000000000000000000000000000000000000;;			// 1. Create dummy VM if not already present.
0000000000000000000000000000000000000000;;			// 2. Add a new disk to the VM by performing VM reconfigure.
0000000000000000000000000000000000000000;;			// 3. Detach the new disk from the dummy VM.
0000000000000000000000000000000000000000;;			// 4. Delete the dummy VM.
0000000000000000000000000000000000000000;;			if volumeOptions.VSANStorageProfileData != "" || volumeOptions.StoragePolicyName != "" {
0000000000000000000000000000000000000000;;				// Acquire a read lock to ensure multiple PVC requests can be processed simultaneously.
0000000000000000000000000000000000000000;;				cleanUpDummyVMLock.RLock()
0000000000000000000000000000000000000000;;				defer cleanUpDummyVMLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Create a new background routine that will delete any dummy VM's that are left stale.
0000000000000000000000000000000000000000;;				// This routine will get executed for every 5 minutes and gets initiated only once in its entire lifetime.
0000000000000000000000000000000000000000;;				cleanUpRoutineInitLock.Lock()
0000000000000000000000000000000000000000;;				if !cleanUpRoutineInitialized {
0000000000000000000000000000000000000000;;					go vs.cleanUpDummyVMs(DummyVMPrefixName)
0000000000000000000000000000000000000000;;					cleanUpRoutineInitialized = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cleanUpRoutineInitLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check if the VM exists in kubernetes cluster folder.
0000000000000000000000000000000000000000;;				// The kubernetes cluster folder - vs.cfg.Global.WorkingDir is where all the nodes in the kubernetes cluster are created.
0000000000000000000000000000000000000000;;				dummyVMFullName := DummyVMPrefixName + "-" + volumeOptions.Name
0000000000000000000000000000000000000000;;				vmRegex := vs.cfg.Global.WorkingDir + dummyVMFullName
0000000000000000000000000000000000000000;;				dummyVM, err := f.VirtualMachine(ctx, vmRegex)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// 1. Create a dummy VM and return the VM reference.
0000000000000000000000000000000000000000;;					dummyVM, err = vs.createDummyVM(ctx, dc, ds, dummyVMFullName)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return "", err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// 2. Reconfigure the VM to attach the disk with the VSAN policy configured.
0000000000000000000000000000000000000000;;				vmDiskPath, err := vs.createVirtualDiskWithPolicy(ctx, dc, ds, dummyVM, volumeOptions)
0000000000000000000000000000000000000000;;				fileAlreadyExist := false
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					vmDiskPath = filepath.Clean(ds.Path(VolDir)) + "/" + volumeOptions.Name + ".vmdk"
0000000000000000000000000000000000000000;;					errorMessage := fmt.Sprintf("Cannot complete the operation because the file or folder %s already exists", vmDiskPath)
0000000000000000000000000000000000000000;;					if errorMessage == err.Error() {
0000000000000000000000000000000000000000;;						//Skip error and continue to detach the disk as the disk was already created on the datastore.
0000000000000000000000000000000000000000;;						fileAlreadyExist = true
0000000000000000000000000000000000000000;;						glog.V(1).Infof("File: %v already exists", vmDiskPath)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.Errorf("Failed to attach the disk to VM: %q with err: %+v", dummyVMFullName, err)
0000000000000000000000000000000000000000;;						return "", err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dummyVMNodeName := vmNameToNodeName(dummyVMFullName)
0000000000000000000000000000000000000000;;				// 3. Detach the disk from the dummy VM.
0000000000000000000000000000000000000000;;				err = vs.DetachDisk(vmDiskPath, dummyVMNodeName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if DiskNotFoundErrMsg == err.Error() && fileAlreadyExist {
0000000000000000000000000000000000000000;;						// Skip error if disk was already detached from the dummy VM but still present on the datastore.
0000000000000000000000000000000000000000;;						glog.V(1).Infof("File: %v is already detached", vmDiskPath)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.Errorf("Failed to detach the disk: %q from VM: %q with err: %+v", vmDiskPath, dummyVMFullName, err)
0000000000000000000000000000000000000000;;						return "", fmt.Errorf("Failed to create the volume: %q with err: %+v", volumeOptions.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// 4. Delete the dummy VM
0000000000000000000000000000000000000000;;				err = deleteVM(ctx, dummyVM)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("Failed to destroy the vm: %q with err: %+v", dummyVMFullName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				destVolPath = vmDiskPath
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Create a virtual disk directly if no VSAN storage capabilities are specified by the user.
0000000000000000000000000000000000000000;;				destVolPath, err = createVirtualDisk(ctx, vs.client, dc, ds, volumeOptions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("Failed to create the virtual disk having name: %+q with err: %+v", destVolPath, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if filepath.Base(datastore) != datastore {
0000000000000000000000000000000000000000;;				// If Datastore is within cluster, add cluster path to the destVolPath
0000000000000000000000000000000000000000;;				destVolPath = strings.Replace(destVolPath, filepath.Base(datastore), datastore, 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(1).Infof("VM Disk path is %+q", destVolPath)
0000000000000000000000000000000000000000;;			return destVolPath, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		volumePath, err = createVolumeInternal(volumeOptions)
0000000000000000000000000000000000000000;;		recordCreateVolumeMetric(volumeOptions, requestTime, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumePath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteVolume deletes a volume given volume name.
0000000000000000000000000000000000000000;;	// Also, deletes the folder where the volume resides.
0000000000000000000000000000000000000000;;	func (vs *VSphere) DeleteVolume(vmDiskPath string) error {
0000000000000000000000000000000000000000;;		deleteVolumeInternal := func(vmDiskPath string) error {
0000000000000000000000000000000000000000;;			// Create context
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure client is logged in and session is valid
0000000000000000000000000000000000000000;;			err := vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to login into vCenter - %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a new finder
0000000000000000000000000000000000000000;;			f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Fetch and set data center
0000000000000000000000000000000000000000;;			dc, err := f.Datacenter(ctx, vs.cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;			f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a virtual disk manager
0000000000000000000000000000000000000000;;			virtualDiskManager := object.NewVirtualDiskManager(vs.client.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if filepath.Ext(vmDiskPath) != ".vmdk" {
0000000000000000000000000000000000000000;;				vmDiskPath += ".vmdk"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the vmDisk Name
0000000000000000000000000000000000000000;;			diskNameWithExt := path.Base(vmDiskPath)
0000000000000000000000000000000000000000;;			diskName := strings.TrimSuffix(diskNameWithExt, filepath.Ext(diskNameWithExt))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Search for the dummyVM if present and delete it.
0000000000000000000000000000000000000000;;			dummyVMFullName := DummyVMPrefixName + "-" + diskName
0000000000000000000000000000000000000000;;			vmRegex := vs.cfg.Global.WorkingDir + dummyVMFullName
0000000000000000000000000000000000000000;;			dummyVM, err := f.VirtualMachine(ctx, vmRegex)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = deleteVM(ctx, dummyVM)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Failed to destroy the vm: %q with err: %+v", dummyVMFullName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Delete virtual disk
0000000000000000000000000000000000000000;;			vmDiskPath = removeClusterFromVDiskPath(vmDiskPath)
0000000000000000000000000000000000000000;;			requestTime := time.Now()
0000000000000000000000000000000000000000;;			task, err := virtualDiskManager.DeleteVirtualDisk(ctx, vmDiskPath, dc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				recordvSphereMetric(api_deletevolume, requestTime, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = task.Wait(ctx)
0000000000000000000000000000000000000000;;			recordvSphereMetric(api_deletevolume, requestTime, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		err := deleteVolumeInternal(vmDiskPath)
0000000000000000000000000000000000000000;;		recordvSphereMetric(operation_deletevolume, requestTime, err)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeExists checks if the node with given nodeName exist.
0000000000000000000000000000000000000000;;	// Returns false if VM doesn't exist or VM is in powerOff state.
0000000000000000000000000000000000000000;;	func (vs *VSphere) NodeExists(nodeName k8stypes.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		if nodeName == "" {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, mvm, err := vs.getVMandMO(ctx, nodeName, "summary")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to getVMandMO for NodeExists: err %v", err)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mvm.Summary.Runtime.PowerState == ActivePowerState {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mvm.Summary.Config.Template == false {
0000000000000000000000000000000000000000;;			glog.Warningf("VM %s, is not in %s state", nodeName, ActivePowerState)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Warningf("VM %s, is a template", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A background routine which will be responsible for deleting stale dummy VM's.
0000000000000000000000000000000000000000;;	func (vs *VSphere) cleanUpDummyVMs(dummyVMPrefix string) {
0000000000000000000000000000000000000000;;		// Create context
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			time.Sleep(CleanUpDummyVMRoutine_Interval * time.Minute)
0000000000000000000000000000000000000000;;			// Ensure client is logged in and session is valid
0000000000000000000000000000000000000000;;			err := vSphereLogin(ctx, vs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("[cleanUpDummyVMs] Unable to login to vSphere with err: %+v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a new finder
0000000000000000000000000000000000000000;;			f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Fetch and set data center
0000000000000000000000000000000000000000;;			dc, err := f.Datacenter(ctx, vs.cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("[cleanUpDummyVMs] Unable to fetch the datacenter: %q with err: %+v", vs.cfg.Global.Datacenter, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the folder reference for global working directory where the dummy VM needs to be created.
0000000000000000000000000000000000000000;;			vmFolder, err := f.Folder(ctx, strings.TrimSuffix(vs.cfg.Global.WorkingDir, "/"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("[cleanUpDummyVMs] Unable to get the kubernetes folder: %q reference with err: %+v", vs.cfg.Global.WorkingDir, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A write lock is acquired to make sure the cleanUp routine doesn't delete any VM's created by ongoing PVC requests.
0000000000000000000000000000000000000000;;			cleanUpDummyVMLock.Lock()
0000000000000000000000000000000000000000;;			vmMoList, err := vs.GetVMsInsideFolder(ctx, vmFolder, []string{NameProperty})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("[cleanUpDummyVMs] Unable to get VM list in the kubernetes cluster: %q reference with err: %+v", vs.cfg.Global.WorkingDir, err)
0000000000000000000000000000000000000000;;				cleanUpDummyVMLock.Unlock()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var dummyVMRefList []*object.VirtualMachine
0000000000000000000000000000000000000000;;			for _, vmMo := range vmMoList {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(vmMo.Name, dummyVMPrefix) {
0000000000000000000000000000000000000000;;					dummyVMRefList = append(dummyVMRefList, object.NewVirtualMachine(vs.client.Client, vmMo.Reference()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, dummyVMRef := range dummyVMRefList {
0000000000000000000000000000000000000000;;				err = deleteVM(ctx, dummyVMRef)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("[cleanUpDummyVMs] Unable to delete dummy VM: %q with err: %+v", dummyVMRef.Name(), err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cleanUpDummyVMLock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) createDummyVM(ctx context.Context, datacenter *object.Datacenter, datastore *object.Datastore, vmName string) (*object.VirtualMachine, error) {
0000000000000000000000000000000000000000;;		// Create a virtual machine config spec with 1 SCSI adapter.
0000000000000000000000000000000000000000;;		virtualMachineConfigSpec := types.VirtualMachineConfigSpec{
0000000000000000000000000000000000000000;;			Name: vmName,
0000000000000000000000000000000000000000;;			Files: &types.VirtualMachineFileInfo{
0000000000000000000000000000000000000000;;				VmPathName: "[" + datastore.Name() + "]",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NumCPUs:  1,
0000000000000000000000000000000000000000;;			MemoryMB: 4,
0000000000000000000000000000000000000000;;			DeviceChange: []types.BaseVirtualDeviceConfigSpec{
0000000000000000000000000000000000000000;;				&types.VirtualDeviceConfigSpec{
0000000000000000000000000000000000000000;;					Operation: types.VirtualDeviceConfigSpecOperationAdd,
0000000000000000000000000000000000000000;;					Device: &types.ParaVirtualSCSIController{
0000000000000000000000000000000000000000;;						VirtualSCSIController: types.VirtualSCSIController{
0000000000000000000000000000000000000000;;							SharedBus: types.VirtualSCSISharingNoSharing,
0000000000000000000000000000000000000000;;							VirtualController: types.VirtualController{
0000000000000000000000000000000000000000;;								BusNumber: 0,
0000000000000000000000000000000000000000;;								VirtualDevice: types.VirtualDevice{
0000000000000000000000000000000000000000;;									Key: 1000,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the resource pool for current node. This is where dummy VM will be created.
0000000000000000000000000000000000000000;;		resourcePool, err := vs.getCurrentNodeResourcePool(ctx, datacenter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get the folder reference for global working directory where the dummy VM needs to be created.
0000000000000000000000000000000000000000;;		f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;		dc, err := f.Datacenter(ctx, vs.cfg.Global.Datacenter)
0000000000000000000000000000000000000000;;		f.SetDatacenter(dc)
0000000000000000000000000000000000000000;;		vmFolder, err := f.Folder(ctx, strings.TrimSuffix(vs.cfg.Global.WorkingDir, "/"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to get the folder reference for %q with err: %+v", vs.cfg.Global.WorkingDir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		task, err := vmFolder.CreateVM(ctx, virtualMachineConfigSpec, resourcePool, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dummyVMTaskInfo, err := task.WaitForResult(ctx, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmRef := dummyVMTaskInfo.Result.(object.Reference)
0000000000000000000000000000000000000000;;		dummyVM := object.NewVirtualMachine(vs.client.Client, vmRef.Reference())
0000000000000000000000000000000000000000;;		return dummyVM, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs *VSphere) getCurrentNodeResourcePool(ctx context.Context, datacenter *object.Datacenter) (*object.ResourcePool, error) {
0000000000000000000000000000000000000000;;		// Create a new finder
0000000000000000000000000000000000000000;;		f := find.NewFinder(vs.client.Client, true)
0000000000000000000000000000000000000000;;		f.SetDatacenter(datacenter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmRegex := vs.cfg.Global.WorkingDir + vs.localInstanceID
0000000000000000000000000000000000000000;;		currentVM, err := f.VirtualMachine(ctx, vmRegex)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentVMHost, err := currentVM.HostSystem(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the resource pool for the current node.
0000000000000000000000000000000000000000;;		// We create the dummy VM in the same resource pool as current node.
0000000000000000000000000000000000000000;;		resourcePool, err := currentVMHost.ResourcePool(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resourcePool, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a virtual disk with the policy configured to the disk.
0000000000000000000000000000000000000000;;	// A call to this function is made only when a user specifies VSAN storage capabilties in the storage class definition.
0000000000000000000000000000000000000000;;	func (vs *VSphere) createVirtualDiskWithPolicy(ctx context.Context, datacenter *object.Datacenter, datastore *object.Datastore, virtualMachine *object.VirtualMachine, volumeOptions *VolumeOptions) (string, error) {
0000000000000000000000000000000000000000;;		var diskFormat string
0000000000000000000000000000000000000000;;		diskFormat = diskFormatValidType[volumeOptions.DiskFormat]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmDevices, err := virtualMachine.Device(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var diskControllerType = vs.cfg.Disk.SCSIControllerType
0000000000000000000000000000000000000000;;		// find SCSI controller of particular type from VM devices
0000000000000000000000000000000000000000;;		scsiControllersOfRequiredType := getSCSIControllersOfType(vmDevices, diskControllerType)
0000000000000000000000000000000000000000;;		scsiController := scsiControllersOfRequiredType[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeVolsPath := filepath.Clean(datastore.Path(VolDir)) + "/"
0000000000000000000000000000000000000000;;		// Create a kubevols directory in the datastore if one doesn't exist.
0000000000000000000000000000000000000000;;		err = makeDirectoryInDatastore(vs.client, datacenter, kubeVolsPath, false)
0000000000000000000000000000000000000000;;		if err != nil && err != ErrFileAlreadyExist {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot create dir %#v. err %s", kubeVolsPath, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Created dir with path as %+q", kubeVolsPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmDiskPath := kubeVolsPath + volumeOptions.Name + ".vmdk"
0000000000000000000000000000000000000000;;		disk := vmDevices.CreateDisk(scsiController, datastore.Reference(), vmDiskPath)
0000000000000000000000000000000000000000;;		unitNumber, err := getNextUnitNumber(vmDevices, scsiController)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot attach disk to VM, limit reached - %v.", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*disk.UnitNumber = unitNumber
0000000000000000000000000000000000000000;;		disk.CapacityInKB = int64(volumeOptions.CapacityKB)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backing := disk.Backing.(*types.VirtualDiskFlatVer2BackingInfo)
0000000000000000000000000000000000000000;;		backing.DiskMode = string(types.VirtualDiskModeIndependent_persistent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch diskFormat {
0000000000000000000000000000000000000000;;		case ThinDiskType:
0000000000000000000000000000000000000000;;			backing.ThinProvisioned = types.NewBool(true)
0000000000000000000000000000000000000000;;		case EagerZeroedThickDiskType:
0000000000000000000000000000000000000000;;			backing.EagerlyScrub = types.NewBool(true)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			backing.ThinProvisioned = types.NewBool(false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reconfigure VM
0000000000000000000000000000000000000000;;		virtualMachineConfigSpec := types.VirtualMachineConfigSpec{}
0000000000000000000000000000000000000000;;		deviceConfigSpec := &types.VirtualDeviceConfigSpec{
0000000000000000000000000000000000000000;;			Device:        disk,
0000000000000000000000000000000000000000;;			Operation:     types.VirtualDeviceConfigSpecOperationAdd,
0000000000000000000000000000000000000000;;			FileOperation: types.VirtualDeviceConfigSpecFileOperationCreate,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageProfileSpec := &types.VirtualMachineDefinedProfileSpec{}
0000000000000000000000000000000000000000;;		// Is PBM storage policy ID is present, set the storage spec profile ID,
0000000000000000000000000000000000000000;;		// else, set raw the VSAN policy string.
0000000000000000000000000000000000000000;;		if volumeOptions.StoragePolicyID != "" {
0000000000000000000000000000000000000000;;			storageProfileSpec.ProfileId = volumeOptions.StoragePolicyID
0000000000000000000000000000000000000000;;		} else if volumeOptions.VSANStorageProfileData != "" {
0000000000000000000000000000000000000000;;			storageProfileSpec.ProfileId = ""
0000000000000000000000000000000000000000;;			storageProfileSpec.ProfileData = &types.VirtualMachineProfileRawData{
0000000000000000000000000000000000000000;;				ExtensionKey: "com.vmware.vim.sps",
0000000000000000000000000000000000000000;;				ObjectData:   volumeOptions.VSANStorageProfileData,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceConfigSpec.Profile = append(deviceConfigSpec.Profile, storageProfileSpec)
0000000000000000000000000000000000000000;;		virtualMachineConfigSpec.DeviceChange = append(virtualMachineConfigSpec.DeviceChange, deviceConfigSpec)
0000000000000000000000000000000000000000;;		task, err := virtualMachine.Reconfigure(ctx, virtualMachineConfigSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to reconfigure the VM with the disk with err - %v.", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = task.Wait(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to reconfigure the VM with the disk with err - %v.", err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vmDiskPath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// creating a scsi controller as there is none found.
0000000000000000000000000000000000000000;;	func createAndAttachSCSIControllerToVM(ctx context.Context, vm *object.VirtualMachine, diskControllerType string) (types.BaseVirtualDevice, error) {
0000000000000000000000000000000000000000;;		// Get VM device list
0000000000000000000000000000000000000000;;		vmDevices, err := vm.Device(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allSCSIControllers := getSCSIControllers(vmDevices)
0000000000000000000000000000000000000000;;		if len(allSCSIControllers) >= SCSIControllerLimit {
0000000000000000000000000000000000000000;;			// we reached the maximum number of controllers we can attach
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("SCSI Controller Limit of %d has been reached, cannot create another SCSI controller", SCSIControllerLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newSCSIController, err := vmDevices.CreateSCSIController(diskControllerType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			k8runtime.HandleError(fmt.Errorf("error creating new SCSI controller: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		configNewSCSIController := newSCSIController.(types.BaseVirtualSCSIController).GetVirtualSCSIController()
0000000000000000000000000000000000000000;;		hotAndRemove := true
0000000000000000000000000000000000000000;;		configNewSCSIController.HotAddRemove = &hotAndRemove
0000000000000000000000000000000000000000;;		configNewSCSIController.SharedBus = types.VirtualSCSISharing(types.VirtualSCSISharingNoSharing)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add the scsi controller to virtual machine
0000000000000000000000000000000000000000;;		err = vm.AddDevice(context.TODO(), newSCSIController)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(1).Infof("cannot add SCSI controller to vm - %v", err)
0000000000000000000000000000000000000000;;			// attempt clean up of scsi controller
0000000000000000000000000000000000000000;;			if vmDevices, err := vm.Device(ctx); err == nil {
0000000000000000000000000000000000000000;;				cleanUpController(ctx, newSCSIController, vmDevices, vm)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newSCSIController, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a virtual disk.
0000000000000000000000000000000000000000;;	func createVirtualDisk(ctx context.Context, c *govmomi.Client, dc *object.Datacenter, ds *object.Datastore, volumeOptions *VolumeOptions) (string, error) {
0000000000000000000000000000000000000000;;		kubeVolsPath := filepath.Clean(ds.Path(VolDir)) + "/"
0000000000000000000000000000000000000000;;		// Create a kubevols directory in the datastore if one doesn't exist.
0000000000000000000000000000000000000000;;		err := makeDirectoryInDatastore(c, dc, kubeVolsPath, false)
0000000000000000000000000000000000000000;;		if err != nil && err != ErrFileAlreadyExist {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot create dir %#v. err %s", kubeVolsPath, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Created dir with path as %+q", kubeVolsPath)
0000000000000000000000000000000000000000;;		vmDiskPath := kubeVolsPath + volumeOptions.Name + ".vmdk"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskFormat := diskFormatValidType[volumeOptions.DiskFormat]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a virtual disk manager
0000000000000000000000000000000000000000;;		virtualDiskManager := object.NewVirtualDiskManager(c.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create specification for new virtual disk
0000000000000000000000000000000000000000;;		vmDiskSpec := &types.FileBackedVirtualDiskSpec{
0000000000000000000000000000000000000000;;			VirtualDiskSpec: types.VirtualDiskSpec{
0000000000000000000000000000000000000000;;				AdapterType: LSILogicControllerType,
0000000000000000000000000000000000000000;;				DiskType:    diskFormat,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			CapacityKb: int64(volumeOptions.CapacityKB),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create virtual disk
0000000000000000000000000000000000000000;;		requestTime := time.Now()
0000000000000000000000000000000000000000;;		task, err := virtualDiskManager.CreateVirtualDisk(ctx, vmDiskPath, dc, vmDiskSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			recordvSphereMetric(api_createvolume, requestTime, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = task.Wait(ctx)
0000000000000000000000000000000000000000;;		recordvSphereMetric(api_createvolume, requestTime, err)
0000000000000000000000000000000000000000;;		return vmDiskPath, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the provided datastore is VSAN
0000000000000000000000000000000000000000;;	func checkIfDatastoreTypeIsVSAN(c *govmomi.Client, datastore *object.Datastore) (bool, error) {
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc := property.DefaultCollector(c.Client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert datastores into list of references
0000000000000000000000000000000000000000;;		var dsRefs []types.ManagedObjectReference
0000000000000000000000000000000000000000;;		dsRefs = append(dsRefs, datastore.Reference())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve summary property for the given datastore
0000000000000000000000000000000000000000;;		var dsMorefs []mo.Datastore
0000000000000000000000000000000000000000;;		err := pc.Retrieve(ctx, dsRefs, []string{"summary"}, &dsMorefs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ds := range dsMorefs {
0000000000000000000000000000000000000000;;			if ds.Summary.Type == VSANDatastoreType {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a folder using the specified name.
0000000000000000000000000000000000000000;;	// If the intermediate level folders do not exist,
0000000000000000000000000000000000000000;;	// and the parameter createParents is true,
0000000000000000000000000000000000000000;;	// all the non-existent folders are created.
0000000000000000000000000000000000000000;;	func makeDirectoryInDatastore(c *govmomi.Client, dc *object.Datacenter, path string, createParents bool) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileManager := object.NewFileManager(c.Client)
0000000000000000000000000000000000000000;;		err := fileManager.MakeDirectory(ctx, path, dc, createParents)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if soap.IsSoapFault(err) {
0000000000000000000000000000000000000000;;				soapFault := soap.ToSoapFault(err)
0000000000000000000000000000000000000000;;				if _, ok := soapFault.VimFault().(types.FileAlreadyExists); ok {
0000000000000000000000000000000000000000;;					return ErrFileAlreadyExist
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete the VM.
0000000000000000000000000000000000000000;;	func deleteVM(ctx context.Context, vm *object.VirtualMachine) error {
0000000000000000000000000000000000000000;;		destroyTask, err := vm.Destroy(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return destroyTask.Wait(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove the cluster or folder path from the vDiskPath
0000000000000000000000000000000000000000;;	// for vDiskPath [DatastoreCluster/sharedVmfs-0] kubevols/e2e-vmdk-1234.vmdk, return value is [sharedVmfs-0] kubevols/e2e-vmdk-1234.vmdk
0000000000000000000000000000000000000000;;	// for vDiskPath [sharedVmfs-0] kubevols/e2e-vmdk-1234.vmdk, return value remains same [sharedVmfs-0] kubevols/e2e-vmdk-1234.vmdk
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeClusterFromVDiskPath(vDiskPath string) string {
0000000000000000000000000000000000000000;;		datastore := regexp.MustCompile("\\[(.*?)\\]").FindStringSubmatch(vDiskPath)[1]
0000000000000000000000000000000000000000;;		if filepath.Base(datastore) != datastore {
0000000000000000000000000000000000000000;;			vDiskPath = strings.Replace(vDiskPath, datastore, filepath.Base(datastore), 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vDiskPath
0000000000000000000000000000000000000000;;	}
