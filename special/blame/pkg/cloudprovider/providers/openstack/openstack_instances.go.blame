0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5f7e58e9f8094754dec0531e760658c3538731f2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/pagination"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Instances struct {
0000000000000000000000000000000000000000;;		compute *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances returns an implementation of Instances for OpenStack.
0000000000000000000000000000000000000000;;	func (os *OpenStack) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		glog.V(4).Info("openstack.Instances() called")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compute, err := os.NewComputeV2()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(1).Info("Claiming to support Instances")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Instances{compute}, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *Instances) List(name_filter string) ([]types.NodeName, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("openstack List(%v) called", name_filter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := servers.ListOpts{
0000000000000000000000000000000000000000;;			Name:   name_filter,
0000000000000000000000000000000000000000;;			Status: "ACTIVE",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := servers.List(i.compute, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := make([]types.NodeName, 0)
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			sList, err := servers.ExtractServers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range sList {
0000000000000000000000000000000000000000;;				ret = append(ret, mapServerToNodeName(&sList[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Found %v instances matching %v: %v",
0000000000000000000000000000000000000000;;			len(ret), name_filter, ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of Instances.CurrentNodeName
0000000000000000000000000000000000000000;;	// Note this is *not* necessarily the same as hostname.
0000000000000000000000000000000000000000;;	func (i *Instances) CurrentNodeName(hostname string) (types.NodeName, error) {
0000000000000000000000000000000000000000;;		md, err := getMetadata()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types.NodeName(md.Name), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *Instances) AddSSHKeyToAllInstances(user string, keyData []byte) error {
0000000000000000000000000000000000000000;;		return errors.New("unimplemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *Instances) NodeAddresses(name types.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("NodeAddresses(%v) called", name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addrs, err := getAddressesByName(i.compute, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("NodeAddresses(%v) => %v", name, addrs)
0000000000000000000000000000000000000000;;		return addrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddressesByProviderID returns the node addresses of an instances with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (i *Instances) NodeAddressesByProviderID(providerID string) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		instanceID, err := instanceIDFromProviderID(providerID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []v1.NodeAddress{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server, err := servers.Get(i.compute, instanceID).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []v1.NodeAddress{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addresses, err := nodeAddresses(server)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []v1.NodeAddress{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return addresses, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExternalID returns the cloud provider ID of the specified instance (deprecated).
0000000000000000000000000000000000000000;;	func (i *Instances) ExternalID(name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		srv, err := getServerByName(i.compute, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == ErrNotFound {
0000000000000000000000000000000000000000;;				return "", cloudprovider.InstanceNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return srv.ID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the kubelet's cloud provider ID.
0000000000000000000000000000000000000000;;	func (os *OpenStack) InstanceID() (string, error) {
0000000000000000000000000000000000000000;;		return os.localInstanceID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceID returns the cloud provider ID of the specified instance.
0000000000000000000000000000000000000000;;	func (i *Instances) InstanceID(name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		srv, err := getServerByName(i.compute, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// In the future it is possible to also return an endpoint as:
0000000000000000000000000000000000000000;;		// <endpoint>/<instanceid>
0000000000000000000000000000000000000000;;		return "/" + srv.ID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceTypeByProviderID returns the cloudprovider instance type of the node with the specified unique providerID
0000000000000000000000000000000000000000;;	// This method will not be called from the node that is requesting this ID. i.e. metadata service
0000000000000000000000000000000000000000;;	// and other local methods cannot be used here
0000000000000000000000000000000000000000;;	func (i *Instances) InstanceTypeByProviderID(providerID string) (string, error) {
0000000000000000000000000000000000000000;;		instanceID, err := instanceIDFromProviderID(providerID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server, err := servers.Get(i.compute, instanceID).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return srvInstanceType(server)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstanceType returns the type of the specified instance.
0000000000000000000000000000000000000000;;	func (i *Instances) InstanceType(name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		srv, err := getServerByName(i.compute, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return srvInstanceType(srv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func srvInstanceType(srv *servers.Server) (string, error) {
0000000000000000000000000000000000000000;;		val, ok := srv.Flavor["name"]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("flavor name not present in server info")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flavor, ok := val.(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("flavor name is not a string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return flavor, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func instanceIDFromProviderID(providerID string) (instanceID string, err error) {
0000000000000000000000000000000000000000;;		parsedID, err := url.Parse(providerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parsedID.Scheme != ProviderName {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unrecognized provider %q", parsedID.Scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parsedID.Host, nil
0000000000000000000000000000000000000000;;	}
