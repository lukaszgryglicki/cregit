0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
b479dda633a5ae6c943b0b305935330cc872b28b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/layer3/routers"
0000000000000000000000000000000000000000;;		neutronports "github.com/gophercloud/gophercloud/openstack/networking/v2/ports"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrNoRouterId = errors.New("router-id not set in cloud provider config")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Routes struct {
0000000000000000000000000000000000000000;;		compute *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;		network *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;		opts    RouterOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRoutes(compute *gophercloud.ServiceClient, network *gophercloud.ServiceClient, opts RouterOpts) (cloudprovider.Routes, error) {
0000000000000000000000000000000000000000;;		if opts.RouterId == "" {
0000000000000000000000000000000000000000;;			return nil, ErrNoRouterId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Routes{
0000000000000000000000000000000000000000;;			compute: compute,
0000000000000000000000000000000000000000;;			network: network,
0000000000000000000000000000000000000000;;			opts:    opts,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Routes) ListRoutes(clusterName string) ([]*cloudprovider.Route, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("ListRoutes(%v)", clusterName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodeNamesByAddr := make(map[string]types.NodeName)
0000000000000000000000000000000000000000;;		err := foreachServer(r.compute, servers.ListOpts{Status: "ACTIVE"}, func(srv *servers.Server) (bool, error) {
0000000000000000000000000000000000000000;;			addrs, err := nodeAddresses(srv)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			name := mapServerToNodeName(srv)
0000000000000000000000000000000000000000;;			for _, addr := range addrs {
0000000000000000000000000000000000000000;;				nodeNamesByAddr[addr.Address] = name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		router, err := routers.Get(r.network, r.opts.RouterId).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var routes []*cloudprovider.Route
0000000000000000000000000000000000000000;;		for _, item := range router.Routes {
0000000000000000000000000000000000000000;;			nodeName, ok := nodeNamesByAddr[item.NextHop]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// Not one of our routes?
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Skipping route with unknown nexthop %v", item.NextHop)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			route := cloudprovider.Route{
0000000000000000000000000000000000000000;;				Name:            item.DestinationCIDR,
0000000000000000000000000000000000000000;;				TargetNode:      nodeName,
0000000000000000000000000000000000000000;;				DestinationCIDR: item.DestinationCIDR,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			routes = append(routes, &route)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return routes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateRoutes(network *gophercloud.ServiceClient, router *routers.Router, newRoutes []routers.Route) (func(), error) {
0000000000000000000000000000000000000000;;		origRoutes := router.Routes // shallow copy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := routers.Update(network, router.ID, routers.UpdateOpts{
0000000000000000000000000000000000000000;;			Routes: newRoutes,
0000000000000000000000000000000000000000;;		}).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unwinder := func() {
0000000000000000000000000000000000000000;;			glog.V(4).Info("Reverting routes change to router ", router.ID)
0000000000000000000000000000000000000000;;			_, err := routers.Update(network, router.ID, routers.UpdateOpts{
0000000000000000000000000000000000000000;;				Routes: origRoutes,
0000000000000000000000000000000000000000;;			}).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warning("Unable to reset routes during error unwind: ", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unwinder, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateAllowedAddressPairs(network *gophercloud.ServiceClient, port *neutronports.Port, newPairs []neutronports.AddressPair) (func(), error) {
0000000000000000000000000000000000000000;;		origPairs := port.AllowedAddressPairs // shallow copy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := neutronports.Update(network, port.ID, neutronports.UpdateOpts{
0000000000000000000000000000000000000000;;			AllowedAddressPairs: newPairs,
0000000000000000000000000000000000000000;;		}).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unwinder := func() {
0000000000000000000000000000000000000000;;			glog.V(4).Info("Reverting allowed-address-pairs change to port ", port.ID)
0000000000000000000000000000000000000000;;			_, err := neutronports.Update(network, port.ID, neutronports.UpdateOpts{
0000000000000000000000000000000000000000;;				AllowedAddressPairs: origPairs,
0000000000000000000000000000000000000000;;			}).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warning("Unable to reset allowed-address-pairs during error unwind: ", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unwinder, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Routes) CreateRoute(clusterName string, nameHint string, route *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("CreateRoute(%v, %v, %v)", clusterName, nameHint, route)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		onFailure := NewCaller()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr, err := getAddressByName(r.compute, route.TargetNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Using nexthop %v for node %v", addr, route.TargetNode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		router, err := routers.Get(r.network, r.opts.RouterId).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routes := router.Routes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range routes {
0000000000000000000000000000000000000000;;			if item.DestinationCIDR == route.DestinationCIDR && item.NextHop == addr {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Skipping existing route: %v", route)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routes = append(routes, routers.Route{
0000000000000000000000000000000000000000;;			DestinationCIDR: route.DestinationCIDR,
0000000000000000000000000000000000000000;;			NextHop:         addr,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unwind, err := updateRoutes(r.network, router, routes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer onFailure.Call(unwind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		port, err := getPortByIP(r.network, addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		for _, item := range port.AllowedAddressPairs {
0000000000000000000000000000000000000000;;			if item.IPAddress == route.DestinationCIDR {
0000000000000000000000000000000000000000;;				glog.V(4).Info("Found existing allowed-address-pair: ", item)
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			newPairs := append(port.AllowedAddressPairs, neutronports.AddressPair{
0000000000000000000000000000000000000000;;				IPAddress: route.DestinationCIDR,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			unwind, err := updateAllowedAddressPairs(r.network, &port, newPairs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer onFailure.Call(unwind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Route created: %v", route)
0000000000000000000000000000000000000000;;		onFailure.Disarm()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Routes) DeleteRoute(clusterName string, route *cloudprovider.Route) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DeleteRoute(%v, %v)", clusterName, route)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		onFailure := NewCaller()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr, err := getAddressByName(r.compute, route.TargetNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		router, err := routers.Get(r.network, r.opts.RouterId).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routes := router.Routes
0000000000000000000000000000000000000000;;		index := -1
0000000000000000000000000000000000000000;;		for i, item := range routes {
0000000000000000000000000000000000000000;;			if item.DestinationCIDR == route.DestinationCIDR && item.NextHop == addr {
0000000000000000000000000000000000000000;;				index = i
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if index == -1 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Skipping non-existent route: %v", route)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete element `index`
0000000000000000000000000000000000000000;;		routes[index] = routes[len(routes)-1]
0000000000000000000000000000000000000000;;		routes = routes[:len(routes)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unwind, err := updateRoutes(r.network, router, routes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer onFailure.Call(unwind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		port, err := getPortByIP(r.network, addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr_pairs := port.AllowedAddressPairs
0000000000000000000000000000000000000000;;		index = -1
0000000000000000000000000000000000000000;;		for i, item := range addr_pairs {
0000000000000000000000000000000000000000;;			if item.IPAddress == route.DestinationCIDR {
0000000000000000000000000000000000000000;;				index = i
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if index != -1 {
0000000000000000000000000000000000000000;;			// Delete element `index`
0000000000000000000000000000000000000000;;			addr_pairs[index] = addr_pairs[len(addr_pairs)-1]
0000000000000000000000000000000000000000;;			addr_pairs = addr_pairs[:len(addr_pairs)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			unwind, err := updateAllowedAddressPairs(r.network, &port, addr_pairs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer onFailure.Call(unwind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Route deleted: %v", route)
0000000000000000000000000000000000000000;;		onFailure.Disarm()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
