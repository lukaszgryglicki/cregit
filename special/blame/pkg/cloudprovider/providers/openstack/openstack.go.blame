0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0bdc5b25c1641c2bffdfb0a6f5f80cb829771a8a;pkg/cloudprovider/openstack/openstack.go[pkg/cloudprovider/openstack/openstack.go][pkg/cloudprovider/providers/openstack/openstack.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack"
0000000000000000000000000000000000000000;;		apiversions_v1 "github.com/gophercloud/gophercloud/openstack/blockstorage/v1/apiversions"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/identity/v3/extensions/trusts"
0000000000000000000000000000000000000000;;		tokens3 "github.com/gophercloud/gophercloud/openstack/identity/v3/tokens"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/pagination"
0000000000000000000000000000000000000000;;		"github.com/mitchellh/mapstructure"
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		netutil "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ProviderName = "openstack"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrNotFound = errors.New("Failed to find object")
0000000000000000000000000000000000000000;;	var ErrMultipleResults = errors.New("Multiple results where only one expected")
0000000000000000000000000000000000000000;;	var ErrNoAddressFound = errors.New("No address found for host")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encoding.TextUnmarshaler interface for time.Duration
0000000000000000000000000000000000000000;;	type MyDuration struct {
0000000000000000000000000000000000000000;;		time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *MyDuration) UnmarshalText(text []byte) error {
0000000000000000000000000000000000000000;;		res, err := time.ParseDuration(string(text))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.Duration = res
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LoadBalancer struct {
0000000000000000000000000000000000000000;;		network *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;		compute *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;		opts    LoadBalancerOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LoadBalancerOpts struct {
0000000000000000000000000000000000000000;;		LBVersion            string     `gcfg:"lb-version"`          // overrides autodetection. v1 or v2
0000000000000000000000000000000000000000;;		SubnetId             string     `gcfg:"subnet-id"`           // required
0000000000000000000000000000000000000000;;		FloatingNetworkId    string     `gcfg:"floating-network-id"` // If specified, will create floating ip for loadbalancer, or do not create floating ip.
0000000000000000000000000000000000000000;;		LBMethod             string     `gcfg:"lb-method"`           // default to ROUND_ROBIN.
0000000000000000000000000000000000000000;;		CreateMonitor        bool       `gcfg:"create-monitor"`
0000000000000000000000000000000000000000;;		MonitorDelay         MyDuration `gcfg:"monitor-delay"`
0000000000000000000000000000000000000000;;		MonitorTimeout       MyDuration `gcfg:"monitor-timeout"`
0000000000000000000000000000000000000000;;		MonitorMaxRetries    uint       `gcfg:"monitor-max-retries"`
0000000000000000000000000000000000000000;;		ManageSecurityGroups bool       `gcfg:"manage-security-groups"`
0000000000000000000000000000000000000000;;		NodeSecurityGroupID  string     `gcfg:"node-security-group"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BlockStorageOpts struct {
0000000000000000000000000000000000000000;;		BSVersion       string `gcfg:"bs-version"`        // overrides autodetection. v1 or v2. Defaults to auto
0000000000000000000000000000000000000000;;		TrustDevicePath bool   `gcfg:"trust-device-path"` // See Issue #33128
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RouterOpts struct {
0000000000000000000000000000000000000000;;		RouterId string `gcfg:"router-id"` // required
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenStack is an implementation of cloud provider Interface for OpenStack.
0000000000000000000000000000000000000000;;	type OpenStack struct {
0000000000000000000000000000000000000000;;		provider  *gophercloud.ProviderClient
0000000000000000000000000000000000000000;;		region    string
0000000000000000000000000000000000000000;;		lbOpts    LoadBalancerOpts
0000000000000000000000000000000000000000;;		bsOpts    BlockStorageOpts
0000000000000000000000000000000000000000;;		routeOpts RouterOpts
0000000000000000000000000000000000000000;;		// InstanceID of the server where this OpenStack object is instantiated.
0000000000000000000000000000000000000000;;		localInstanceID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		Global struct {
0000000000000000000000000000000000000000;;			AuthUrl    string `gcfg:"auth-url"`
0000000000000000000000000000000000000000;;			Username   string
0000000000000000000000000000000000000000;;			UserId     string `gcfg:"user-id"`
0000000000000000000000000000000000000000;;			Password   string
0000000000000000000000000000000000000000;;			TenantId   string `gcfg:"tenant-id"`
0000000000000000000000000000000000000000;;			TenantName string `gcfg:"tenant-name"`
0000000000000000000000000000000000000000;;			TrustId    string `gcfg:"trust-id"`
0000000000000000000000000000000000000000;;			DomainId   string `gcfg:"domain-id"`
0000000000000000000000000000000000000000;;			DomainName string `gcfg:"domain-name"`
0000000000000000000000000000000000000000;;			Region     string
0000000000000000000000000000000000000000;;			CAFile     string `gcfg:"ca-file"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		LoadBalancer LoadBalancerOpts
0000000000000000000000000000000000000000;;		BlockStorage BlockStorageOpts
0000000000000000000000000000000000000000;;		Route        RouterOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		RegisterMetrics()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloudprovider.RegisterCloudProvider(ProviderName, func(config io.Reader) (cloudprovider.Interface, error) {
0000000000000000000000000000000000000000;;			cfg, err := readConfig(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newOpenStack(cfg)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cfg Config) toAuthOptions() gophercloud.AuthOptions {
0000000000000000000000000000000000000000;;		return gophercloud.AuthOptions{
0000000000000000000000000000000000000000;;			IdentityEndpoint: cfg.Global.AuthUrl,
0000000000000000000000000000000000000000;;			Username:         cfg.Global.Username,
0000000000000000000000000000000000000000;;			UserID:           cfg.Global.UserId,
0000000000000000000000000000000000000000;;			Password:         cfg.Global.Password,
0000000000000000000000000000000000000000;;			TenantID:         cfg.Global.TenantId,
0000000000000000000000000000000000000000;;			TenantName:       cfg.Global.TenantName,
0000000000000000000000000000000000000000;;			DomainID:         cfg.Global.DomainId,
0000000000000000000000000000000000000000;;			DomainName:       cfg.Global.DomainName,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Persistent service, so we need to be able to renew tokens.
0000000000000000000000000000000000000000;;			AllowReauth: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cfg Config) toAuth3Options() tokens3.AuthOptions {
0000000000000000000000000000000000000000;;		return tokens3.AuthOptions{
0000000000000000000000000000000000000000;;			IdentityEndpoint: cfg.Global.AuthUrl,
0000000000000000000000000000000000000000;;			Username:         cfg.Global.Username,
0000000000000000000000000000000000000000;;			UserID:           cfg.Global.UserId,
0000000000000000000000000000000000000000;;			Password:         cfg.Global.Password,
0000000000000000000000000000000000000000;;			DomainID:         cfg.Global.DomainId,
0000000000000000000000000000000000000000;;			DomainName:       cfg.Global.DomainName,
0000000000000000000000000000000000000000;;			AllowReauth:      true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readConfig(config io.Reader) (Config, error) {
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("no OpenStack cloud provider config file given")
0000000000000000000000000000000000000000;;			return Config{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cfg Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set default values for config params
0000000000000000000000000000000000000000;;		cfg.BlockStorage.BSVersion = "auto"
0000000000000000000000000000000000000000;;		cfg.BlockStorage.TrustDevicePath = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := gcfg.ReadInto(&cfg, config)
0000000000000000000000000000000000000000;;		return cfg, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tiny helper for conditional unwind logic
0000000000000000000000000000000000000000;;	type Caller bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCaller() Caller   { return Caller(true) }
0000000000000000000000000000000000000000;;	func (c *Caller) Disarm() { *c = false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Caller) Call(f func()) {
0000000000000000000000000000000000000000;;		if *c {
0000000000000000000000000000000000000000;;			f()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readInstanceID() (string, error) {
0000000000000000000000000000000000000000;;		// Try to find instance ID on the local filesystem (created by cloud-init)
0000000000000000000000000000000000000000;;		const instanceIDFile = "/var/lib/cloud/data/instance-id"
0000000000000000000000000000000000000000;;		idBytes, err := ioutil.ReadFile(instanceIDFile)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			instanceID := string(idBytes)
0000000000000000000000000000000000000000;;			instanceID = strings.TrimSpace(instanceID)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Got instance id from %s: %s", instanceIDFile, instanceID)
0000000000000000000000000000000000000000;;			if instanceID != "" {
0000000000000000000000000000000000000000;;				return instanceID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Fall through to metadata server lookup
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		md, err := getMetadata()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return md.Uuid, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// check opts for OpenStack
0000000000000000000000000000000000000000;;	func checkOpenStackOpts(openstackOpts *OpenStack) error {
0000000000000000000000000000000000000000;;		lbOpts := openstackOpts.lbOpts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// subnet-id is required
0000000000000000000000000000000000000000;;		if len(lbOpts.SubnetId) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("subnet-id not set in cloud provider config")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if need to create health monitor for Neutron LB,
0000000000000000000000000000000000000000;;		// monitor-delay, monitor-timeout and monitor-max-retries should be set.
0000000000000000000000000000000000000000;;		emptyDuration := MyDuration{}
0000000000000000000000000000000000000000;;		if lbOpts.CreateMonitor {
0000000000000000000000000000000000000000;;			if lbOpts.MonitorDelay == emptyDuration {
0000000000000000000000000000000000000000;;				return fmt.Errorf("monitor-delay not set in cloud provider config")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lbOpts.MonitorTimeout == emptyDuration {
0000000000000000000000000000000000000000;;				return fmt.Errorf("monitor-timeout not set in cloud provider config")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lbOpts.MonitorMaxRetries == uint(0) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("monitor-max-retries not set in cloud provider config")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if enable ManageSecurityGroups, node-security-group should be set.
0000000000000000000000000000000000000000;;		if lbOpts.ManageSecurityGroups {
0000000000000000000000000000000000000000;;			if len(lbOpts.NodeSecurityGroupID) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("node-security-group not set in cloud provider config")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newOpenStack(cfg Config) (*OpenStack, error) {
0000000000000000000000000000000000000000;;		provider, err := openstack.NewClient(cfg.Global.AuthUrl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.CAFile != "" {
0000000000000000000000000000000000000000;;			roots, err := certutil.NewPool(cfg.Global.CAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config := &tls.Config{}
0000000000000000000000000000000000000000;;			config.RootCAs = roots
0000000000000000000000000000000000000000;;			provider.HTTPClient.Transport = netutil.SetOldTransportDefaults(&http.Transport{TLSClientConfig: config})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Global.TrustId != "" {
0000000000000000000000000000000000000000;;			opts := cfg.toAuth3Options()
0000000000000000000000000000000000000000;;			authOptsExt := trusts.AuthOptsExt{
0000000000000000000000000000000000000000;;				TrustID:            cfg.Global.TrustId,
0000000000000000000000000000000000000000;;				AuthOptionsBuilder: &opts,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = openstack.AuthenticateV3(provider, authOptsExt, gophercloud.EndpointOpts{})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = openstack.Authenticate(provider, cfg.toAuthOptions())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id, err := readInstanceID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os := OpenStack{
0000000000000000000000000000000000000000;;			provider:        provider,
0000000000000000000000000000000000000000;;			region:          cfg.Global.Region,
0000000000000000000000000000000000000000;;			lbOpts:          cfg.LoadBalancer,
0000000000000000000000000000000000000000;;			bsOpts:          cfg.BlockStorage,
0000000000000000000000000000000000000000;;			routeOpts:       cfg.Route,
0000000000000000000000000000000000000000;;			localInstanceID: id,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = checkOpenStackOpts(&os)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &os, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize passes a Kubernetes clientBuilder interface to the cloud provider
0000000000000000000000000000000000000000;;	func (os *OpenStack) Initialize(clientBuilder controller.ControllerClientBuilder) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapNodeNameToServerName maps a k8s NodeName to an OpenStack Server Name
0000000000000000000000000000000000000000;;	// This is a simple string cast.
0000000000000000000000000000000000000000;;	func mapNodeNameToServerName(nodeName types.NodeName) string {
0000000000000000000000000000000000000000;;		return string(nodeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapServerToNodeName maps an OpenStack Server to a k8s NodeName
0000000000000000000000000000000000000000;;	func mapServerToNodeName(server *servers.Server) types.NodeName {
0000000000000000000000000000000000000000;;		// Node names are always lowercase, and (at least)
0000000000000000000000000000000000000000;;		// routecontroller does case-sensitive string comparisons
0000000000000000000000000000000000000000;;		// assuming this
0000000000000000000000000000000000000000;;		return types.NodeName(strings.ToLower(server.Name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func foreachServer(client *gophercloud.ServiceClient, opts servers.ListOptsBuilder, handler func(*servers.Server) (bool, error)) error {
0000000000000000000000000000000000000000;;		pager := servers.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			s, err := servers.ExtractServers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, server := range s {
0000000000000000000000000000000000000000;;				ok, err := handler(&server)
0000000000000000000000000000000000000000;;				if !ok || err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getServerByName(client *gophercloud.ServiceClient, name types.NodeName) (*servers.Server, error) {
0000000000000000000000000000000000000000;;		opts := servers.ListOpts{
0000000000000000000000000000000000000000;;			Name:   fmt.Sprintf("^%s$", regexp.QuoteMeta(mapNodeNameToServerName(name))),
0000000000000000000000000000000000000000;;			Status: "ACTIVE",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := servers.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverList := make([]servers.Server, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			s, err := servers.ExtractServers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serverList = append(serverList, s...)
0000000000000000000000000000000000000000;;			if len(serverList) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(serverList) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &serverList[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodeAddresses(srv *servers.Server) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		addrs := []v1.NodeAddress{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Address struct {
0000000000000000000000000000000000000000;;			IpType string `mapstructure:"OS-EXT-IPS:type"`
0000000000000000000000000000000000000000;;			Addr   string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var addresses map[string][]Address
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(srv.Addresses, &addresses)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for network, addrList := range addresses {
0000000000000000000000000000000000000000;;			for _, props := range addrList {
0000000000000000000000000000000000000000;;				var addressType v1.NodeAddressType
0000000000000000000000000000000000000000;;				if props.IpType == "floating" || network == "public" {
0000000000000000000000000000000000000000;;					addressType = v1.NodeExternalIP
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					addressType = v1.NodeInternalIP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				v1helper.AddToNodeAddresses(&addrs,
0000000000000000000000000000000000000000;;					v1.NodeAddress{
0000000000000000000000000000000000000000;;						Type:    addressType,
0000000000000000000000000000000000000000;;						Address: props.Addr,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPs are usually duplicates of "public" addresses.
0000000000000000000000000000000000000000;;		if srv.AccessIPv4 != "" {
0000000000000000000000000000000000000000;;			v1helper.AddToNodeAddresses(&addrs,
0000000000000000000000000000000000000000;;				v1.NodeAddress{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: srv.AccessIPv4,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if srv.AccessIPv6 != "" {
0000000000000000000000000000000000000000;;			v1helper.AddToNodeAddresses(&addrs,
0000000000000000000000000000000000000000;;				v1.NodeAddress{
0000000000000000000000000000000000000000;;					Type:    v1.NodeExternalIP,
0000000000000000000000000000000000000000;;					Address: srv.AccessIPv6,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return addrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAddressesByName(client *gophercloud.ServiceClient, name types.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		srv, err := getServerByName(client, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodeAddresses(srv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAddressByName(client *gophercloud.ServiceClient, name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		addrs, err := getAddressesByName(client, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		} else if len(addrs) == 0 {
0000000000000000000000000000000000000000;;			return "", ErrNoAddressFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, addr := range addrs {
0000000000000000000000000000000000000000;;			if addr.Type == v1.NodeInternalIP {
0000000000000000000000000000000000000000;;				return addr.Address, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return addrs[0].Address, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *OpenStack) Clusters() (cloudprovider.Clusters, bool) {
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;	func (os *OpenStack) ProviderName() string {
0000000000000000000000000000000000000000;;		return ProviderName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScrubDNS filters DNS settings for pods.
0000000000000000000000000000000000000000;;	func (os *OpenStack) ScrubDNS(nameServers, searches []string) ([]string, []string) {
0000000000000000000000000000000000000000;;		return nameServers, searches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *OpenStack) LoadBalancer() (cloudprovider.LoadBalancer, bool) {
0000000000000000000000000000000000000000;;		glog.V(4).Info("openstack.LoadBalancer() called")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Search for and support Rackspace loadbalancer API, and others.
0000000000000000000000000000000000000000;;		network, err := os.NewNetworkV2()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compute, err := os.NewComputeV2()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbVersion := os.lbOpts.LBVersion
0000000000000000000000000000000000000000;;		if lbVersion == "" {
0000000000000000000000000000000000000000;;			// No version specified, try newest supported by server
0000000000000000000000000000000000000000;;			netExts, err := networkExtensions(network)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to list neutron extensions: %v", err)
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if netExts["lbaasv2"] {
0000000000000000000000000000000000000000;;				lbVersion = "v2"
0000000000000000000000000000000000000000;;			} else if netExts["lbaas"] {
0000000000000000000000000000000000000000;;				lbVersion = "v1"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to find neutron LBaaS extension (v1 or v2)")
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Using LBaaS extension %v", lbVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(1).Info("Claiming to support LoadBalancer")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lbVersion == "v2" {
0000000000000000000000000000000000000000;;			return &LbaasV2{LoadBalancer{network, compute, os.lbOpts}}, true
0000000000000000000000000000000000000000;;		} else if lbVersion == "v1" {
0000000000000000000000000000000000000000;;			return &LbaasV1{LoadBalancer{network, compute, os.lbOpts}}, true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Warningf("Config error: unrecognised lb-version \"%v\"", lbVersion)
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNotFound(err error) bool {
0000000000000000000000000000000000000000;;		e, ok := err.(*gophercloud.ErrUnexpectedResponseCode)
0000000000000000000000000000000000000000;;		return ok && e.Actual == http.StatusNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *OpenStack) Zones() (cloudprovider.Zones, bool) {
0000000000000000000000000000000000000000;;		glog.V(1).Info("Claiming to support Zones")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return os, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (os *OpenStack) GetZone() (cloudprovider.Zone, error) {
0000000000000000000000000000000000000000;;		md, err := getMetadata()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return cloudprovider.Zone{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zone := cloudprovider.Zone{
0000000000000000000000000000000000000000;;			FailureDomain: md.AvailabilityZone,
0000000000000000000000000000000000000000;;			Region:        os.region,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(1).Infof("Current zone is %v", zone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return zone, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *OpenStack) Routes() (cloudprovider.Routes, bool) {
0000000000000000000000000000000000000000;;		glog.V(4).Info("openstack.Routes() called")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		network, err := os.NewNetworkV2()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netExts, err := networkExtensions(network)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to list neutron extensions: %v", err)
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !netExts["extraroute"] {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Neutron extraroute extension not found, required for Routes support")
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compute, err := os.NewComputeV2()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, err := NewRoutes(compute, network, os.routeOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Error initialising Routes support: %v", err)
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(1).Info("Claiming to support Routes")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of sort interface for blockstorage version probing
0000000000000000000000000000000000000000;;	type APIVersionsByID []apiversions_v1.APIVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (apiVersions APIVersionsByID) Len() int {
0000000000000000000000000000000000000000;;		return len(apiVersions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (apiVersions APIVersionsByID) Swap(i, j int) {
0000000000000000000000000000000000000000;;		apiVersions[i], apiVersions[j] = apiVersions[j], apiVersions[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (apiVersions APIVersionsByID) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return apiVersions[i].ID > apiVersions[j].ID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func autoVersionSelector(apiVersion *apiversions_v1.APIVersion) string {
0000000000000000000000000000000000000000;;		switch strings.ToLower(apiVersion.ID) {
0000000000000000000000000000000000000000;;		case "v2.0":
0000000000000000000000000000000000000000;;			return "v2"
0000000000000000000000000000000000000000;;		case "v1.0":
0000000000000000000000000000000000000000;;			return "v1"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doBsApiVersionAutodetect(availableApiVersions []apiversions_v1.APIVersion) string {
0000000000000000000000000000000000000000;;		sort.Sort(APIVersionsByID(availableApiVersions))
0000000000000000000000000000000000000000;;		for _, status := range []string{"CURRENT", "SUPPORTED"} {
0000000000000000000000000000000000000000;;			for _, version := range availableApiVersions {
0000000000000000000000000000000000000000;;				if strings.ToUpper(version.Status) == status {
0000000000000000000000000000000000000000;;					if detectedApiVersion := autoVersionSelector(&version); detectedApiVersion != "" {
0000000000000000000000000000000000000000;;						glog.V(3).Infof("Blockstorage API version probing has found a suitable %s api version: %s", status, detectedApiVersion)
0000000000000000000000000000000000000000;;						return detectedApiVersion
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *OpenStack) volumeService(forceVersion string) (volumeService, error) {
0000000000000000000000000000000000000000;;		bsVersion := ""
0000000000000000000000000000000000000000;;		if forceVersion == "" {
0000000000000000000000000000000000000000;;			bsVersion = os.bsOpts.BSVersion
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bsVersion = forceVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch bsVersion {
0000000000000000000000000000000000000000;;		case "v1":
0000000000000000000000000000000000000000;;			sClient, err := os.NewBlockStorageV1()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &VolumesV1{sClient, os.bsOpts}, nil
0000000000000000000000000000000000000000;;		case "v2":
0000000000000000000000000000000000000000;;			sClient, err := os.NewBlockStorageV2()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &VolumesV2{sClient, os.bsOpts}, nil
0000000000000000000000000000000000000000;;		case "auto":
0000000000000000000000000000000000000000;;			sClient, err := os.NewBlockStorageV1()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			availableApiVersions := []apiversions_v1.APIVersion{}
0000000000000000000000000000000000000000;;			err = apiversions_v1.List(sClient).EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;				// returning false from this handler stops page iteration, error is propagated to the upper function
0000000000000000000000000000000000000000;;				apiversions, err := apiversions_v1.ExtractAPIVersions(page)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Unable to extract api versions from page: %v", err)
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				availableApiVersions = append(availableApiVersions, apiversions...)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error when retrieving list of supported blockstorage api versions: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if autodetectedVersion := doBsApiVersionAutodetect(availableApiVersions); autodetectedVersion != "" {
0000000000000000000000000000000000000000;;				return os.volumeService(autodetectedVersion)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Nothing suitable found, failed autodetection
0000000000000000000000000000000000000000;;				return nil, errors.New("BS API version autodetection failed.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err_txt := fmt.Sprintf("Config error: unrecognised bs-version \"%v\"", os.bsOpts.BSVersion)
0000000000000000000000000000000000000000;;			glog.Warningf(err_txt)
0000000000000000000000000000000000000000;;			return nil, errors.New(err_txt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
