0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
5f7e58e9f8094754dec0531e760658c3538731f2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k8s_volume "k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		volumes_v1 "github.com/gophercloud/gophercloud/openstack/blockstorage/v1/volumes"
0000000000000000000000000000000000000000;;		volumes_v2 "github.com/gophercloud/gophercloud/openstack/blockstorage/v2/volumes"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/volumeattach"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type volumeService interface {
0000000000000000000000000000000000000000;;		createVolume(opts VolumeCreateOpts) (string, string, error)
0000000000000000000000000000000000000000;;		getVolume(volumeID string) (Volume, error)
0000000000000000000000000000000000000000;;		deleteVolume(volumeName string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volumes implementation for v1
0000000000000000000000000000000000000000;;	type VolumesV1 struct {
0000000000000000000000000000000000000000;;		blockstorage *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;		opts         BlockStorageOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volumes implementation for v2
0000000000000000000000000000000000000000;;	type VolumesV2 struct {
0000000000000000000000000000000000000000;;		blockstorage *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;		opts         BlockStorageOpts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Volume struct {
0000000000000000000000000000000000000000;;		// ID of the instance, to which this volume is attached. "" if not attached
0000000000000000000000000000000000000000;;		AttachedServerId string
0000000000000000000000000000000000000000;;		// Device file path
0000000000000000000000000000000000000000;;		AttachedDevice string
0000000000000000000000000000000000000000;;		// Unique identifier for the volume.
0000000000000000000000000000000000000000;;		ID string
0000000000000000000000000000000000000000;;		// Human-readable display name for the volume.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Current status of the volume.
0000000000000000000000000000000000000000;;		Status string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type VolumeCreateOpts struct {
0000000000000000000000000000000000000000;;		Size         int
0000000000000000000000000000000000000000;;		Availability string
0000000000000000000000000000000000000000;;		Name         string
0000000000000000000000000000000000000000;;		VolumeType   string
0000000000000000000000000000000000000000;;		Metadata     map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		VolumeAvailableStatus = "available"
0000000000000000000000000000000000000000;;		VolumeInUseStatus     = "in-use"
0000000000000000000000000000000000000000;;		VolumeDeletedStatus   = "deleted"
0000000000000000000000000000000000000000;;		VolumeErrorStatus     = "error"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volumes *VolumesV1) createVolume(opts VolumeCreateOpts) (string, string, error) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		create_opts := volumes_v1.CreateOpts{
0000000000000000000000000000000000000000;;			Name:             opts.Name,
0000000000000000000000000000000000000000;;			Size:             opts.Size,
0000000000000000000000000000000000000000;;			VolumeType:       opts.VolumeType,
0000000000000000000000000000000000000000;;			AvailabilityZone: opts.Availability,
0000000000000000000000000000000000000000;;			Metadata:         opts.Metadata,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := volumes_v1.Create(volumes.blockstorage, create_opts).Extract()
0000000000000000000000000000000000000000;;		timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;		recordOpenstackOperationMetric("create_v1_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vol.ID, vol.AvailabilityZone, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volumes *VolumesV2) createVolume(opts VolumeCreateOpts) (string, string, error) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		create_opts := volumes_v2.CreateOpts{
0000000000000000000000000000000000000000;;			Name:             opts.Name,
0000000000000000000000000000000000000000;;			Size:             opts.Size,
0000000000000000000000000000000000000000;;			VolumeType:       opts.VolumeType,
0000000000000000000000000000000000000000;;			AvailabilityZone: opts.Availability,
0000000000000000000000000000000000000000;;			Metadata:         opts.Metadata,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := volumes_v2.Create(volumes.blockstorage, create_opts).Extract()
0000000000000000000000000000000000000000;;		timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;		recordOpenstackOperationMetric("create_v2_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vol.ID, vol.AvailabilityZone, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volumes *VolumesV1) getVolume(volumeID string) (Volume, error) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		volumeV1, err := volumes_v1.Get(volumes.blockstorage, volumeID).Extract()
0000000000000000000000000000000000000000;;		timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;		recordOpenstackOperationMetric("get_v1_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error occurred getting volume by ID: %s", volumeID)
0000000000000000000000000000000000000000;;			return Volume{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume := Volume{
0000000000000000000000000000000000000000;;			ID:     volumeV1.ID,
0000000000000000000000000000000000000000;;			Name:   volumeV1.Name,
0000000000000000000000000000000000000000;;			Status: volumeV1.Status,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumeV1.Attachments) > 0 && volumeV1.Attachments[0]["server_id"] != nil {
0000000000000000000000000000000000000000;;			volume.AttachedServerId = volumeV1.Attachments[0]["server_id"].(string)
0000000000000000000000000000000000000000;;			volume.AttachedDevice = volumeV1.Attachments[0]["device"].(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volumes *VolumesV2) getVolume(volumeID string) (Volume, error) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		volumeV2, err := volumes_v2.Get(volumes.blockstorage, volumeID).Extract()
0000000000000000000000000000000000000000;;		timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;		recordOpenstackOperationMetric("get_v2_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error occurred getting volume by ID: %s", volumeID)
0000000000000000000000000000000000000000;;			return Volume{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume := Volume{
0000000000000000000000000000000000000000;;			ID:     volumeV2.ID,
0000000000000000000000000000000000000000;;			Name:   volumeV2.Name,
0000000000000000000000000000000000000000;;			Status: volumeV2.Status,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(volumeV2.Attachments) > 0 {
0000000000000000000000000000000000000000;;			volume.AttachedServerId = volumeV2.Attachments[0].ServerID
0000000000000000000000000000000000000000;;			volume.AttachedDevice = volumeV2.Attachments[0].Device
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volumes *VolumesV1) deleteVolume(volumeID string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		err := volumes_v1.Delete(volumes.blockstorage, volumeID).ExtractErr()
0000000000000000000000000000000000000000;;		timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;		recordOpenstackOperationMetric("delete_v1_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot delete volume %s: %v", volumeID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volumes *VolumesV2) deleteVolume(volumeID string) error {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		err := volumes_v2.Delete(volumes.blockstorage, volumeID).ExtractErr()
0000000000000000000000000000000000000000;;		timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;		recordOpenstackOperationMetric("delete_v2_volume", timeTaken, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot delete volume %s: %v", volumeID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *OpenStack) OperationPending(diskName string) (bool, string, error) {
0000000000000000000000000000000000000000;;		volume, err := os.getVolume(diskName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeStatus := volume.Status
0000000000000000000000000000000000000000;;		if volumeStatus == VolumeErrorStatus {
0000000000000000000000000000000000000000;;			glog.Errorf("status of volume %s is %s", diskName, volumeStatus)
0000000000000000000000000000000000000000;;			return false, volumeStatus, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volumeStatus == VolumeAvailableStatus || volumeStatus == VolumeInUseStatus || volumeStatus == VolumeDeletedStatus {
0000000000000000000000000000000000000000;;			return false, volume.Status, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, volumeStatus, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attaches given cinder volume to the compute running kubelet
0000000000000000000000000000000000000000;;	func (os *OpenStack) AttachDisk(instanceID, volumeID string) (string, error) {
0000000000000000000000000000000000000000;;		volume, err := os.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.Status != VolumeAvailableStatus {
0000000000000000000000000000000000000000;;			errmsg := fmt.Sprintf("volume %s status is %s, not %s, can not be attached to instance %s.", volume.Name, volume.Status, VolumeAvailableStatus, instanceID)
0000000000000000000000000000000000000000;;			glog.Errorf(errmsg)
0000000000000000000000000000000000000000;;			return "", errors.New(errmsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cClient, err := os.NewComputeV2()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volume.AttachedServerId != "" {
0000000000000000000000000000000000000000;;			if instanceID == volume.AttachedServerId {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Disk %s is already attached to instance %s", volumeID, instanceID)
0000000000000000000000000000000000000000;;				return volume.ID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Disk %s is attached to a different instance (%s), detaching", volumeID, volume.AttachedServerId)
0000000000000000000000000000000000000000;;			err = os.DetachDisk(volume.AttachedServerId, volumeID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		// add read only flag here if possible spothanis
0000000000000000000000000000000000000000;;		_, err = volumeattach.Create(cClient, instanceID, &volumeattach.CreateOpts{
0000000000000000000000000000000000000000;;			VolumeID: volume.ID,
0000000000000000000000000000000000000000;;		}).Extract()
0000000000000000000000000000000000000000;;		timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;		recordOpenstackOperationMetric("attach_disk", timeTaken, err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to attach %s volume to %s compute: %v", volumeID, instanceID, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully attached %s volume to %s compute", volumeID, instanceID)
0000000000000000000000000000000000000000;;		return volume.ID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetachDisk detaches given cinder volume from the compute running kubelet
0000000000000000000000000000000000000000;;	func (os *OpenStack) DetachDisk(instanceID, volumeID string) error {
0000000000000000000000000000000000000000;;		volume, err := os.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.Status != VolumeInUseStatus {
0000000000000000000000000000000000000000;;			errmsg := fmt.Sprintf("can not detach volume %s, its status is %s.", volume.Name, volume.Status)
0000000000000000000000000000000000000000;;			glog.Errorf(errmsg)
0000000000000000000000000000000000000000;;			return errors.New(errmsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cClient, err := os.NewComputeV2()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.AttachedServerId != instanceID {
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("Disk: %s has no attachments or is not attached to compute: %s", volume.Name, instanceID)
0000000000000000000000000000000000000000;;			glog.Errorf(errMsg)
0000000000000000000000000000000000000000;;			return errors.New(errMsg)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			startTime := time.Now()
0000000000000000000000000000000000000000;;			// This is a blocking call and effects kubelet's performance directly.
0000000000000000000000000000000000000000;;			// We should consider kicking it out into a separate routine, if it is bad.
0000000000000000000000000000000000000000;;			err = volumeattach.Delete(cClient, instanceID, volume.ID).ExtractErr()
0000000000000000000000000000000000000000;;			timeTaken := time.Since(startTime).Seconds()
0000000000000000000000000000000000000000;;			recordOpenstackOperationMetric("detach_disk", timeTaken, err)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to delete volume %s from compute %s attached %v", volume.ID, instanceID, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Successfully detached volume: %s from compute: %s", volume.ID, instanceID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieves Volume by its ID.
0000000000000000000000000000000000000000;;	func (os *OpenStack) getVolume(volumeID string) (Volume, error) {
0000000000000000000000000000000000000000;;		volumes, err := os.volumeService("")
0000000000000000000000000000000000000000;;		if err != nil || volumes == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to initialize cinder client for region: %s", os.region)
0000000000000000000000000000000000000000;;			return Volume{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumes.getVolume(volumeID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a volume of given size (in GiB)
0000000000000000000000000000000000000000;;	func (os *OpenStack) CreateVolume(name string, size int, vtype, availability string, tags *map[string]string) (string, string, error) {
0000000000000000000000000000000000000000;;		volumes, err := os.volumeService("")
0000000000000000000000000000000000000000;;		if err != nil || volumes == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to initialize cinder client for region: %s", os.region)
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := VolumeCreateOpts{
0000000000000000000000000000000000000000;;			Name:         name,
0000000000000000000000000000000000000000;;			Size:         size,
0000000000000000000000000000000000000000;;			VolumeType:   vtype,
0000000000000000000000000000000000000000;;			Availability: availability,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tags != nil {
0000000000000000000000000000000000000000;;			opts.Metadata = *tags
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID, volumeAZ, err := volumes.createVolume(opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to create a %d GB volume: %v", size, err)
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Created volume %v in Availability Zone: %v", volumeID, volumeAZ)
0000000000000000000000000000000000000000;;		return volumeID, volumeAZ, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDevicePath returns the path of an attached block storage volume, specified by its id.
0000000000000000000000000000000000000000;;	func (os *OpenStack) GetDevicePath(volumeID string) string {
0000000000000000000000000000000000000000;;		// Build a list of candidate device paths
0000000000000000000000000000000000000000;;		candidateDeviceNodes := []string{
0000000000000000000000000000000000000000;;			// KVM
0000000000000000000000000000000000000000;;			fmt.Sprintf("virtio-%s", volumeID[:20]),
0000000000000000000000000000000000000000;;			// KVM virtio-scsi
0000000000000000000000000000000000000000;;			fmt.Sprintf("scsi-0QEMU_QEMU_HARDDISK_%s", volumeID[:20]),
0000000000000000000000000000000000000000;;			// ESXi
0000000000000000000000000000000000000000;;			fmt.Sprintf("wwn-0x%s", strings.Replace(volumeID, "-", "", -1)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files, _ := ioutil.ReadDir("/dev/disk/by-id/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			for _, c := range candidateDeviceNodes {
0000000000000000000000000000000000000000;;				if c == f.Name() {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Found disk attached as %q; full devicepath: %s\n", f.Name(), path.Join("/dev/disk/by-id/", f.Name()))
0000000000000000000000000000000000000000;;					return path.Join("/dev/disk/by-id/", f.Name())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Warningf("Failed to find device for the volumeID: %q\n", volumeID)
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (os *OpenStack) DeleteVolume(volumeID string) error {
0000000000000000000000000000000000000000;;		used, err := os.diskIsUsed(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if used {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Cannot delete the volume %q, it's still attached to a node", volumeID)
0000000000000000000000000000000000000000;;			return k8s_volume.NewDeletedVolumeInUseError(msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumes, err := os.volumeService("")
0000000000000000000000000000000000000000;;		if err != nil || volumes == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to initialize cinder client for region: %s", os.region)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = volumes.deleteVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot delete volume %s: %v", volumeID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get device path of attached volume to the compute running kubelet, as known by cinder
0000000000000000000000000000000000000000;;	func (os *OpenStack) GetAttachmentDiskPath(instanceID, volumeID string) (string, error) {
0000000000000000000000000000000000000000;;		// See issue #33128 - Cinder does not always tell you the right device path, as such
0000000000000000000000000000000000000000;;		// we must only use this value as a last resort.
0000000000000000000000000000000000000000;;		volume, err := os.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.Status != VolumeInUseStatus {
0000000000000000000000000000000000000000;;			errmsg := fmt.Sprintf("can not get device path of volume %s, its status is %s.", volume.Name, volume.Status)
0000000000000000000000000000000000000000;;			glog.Errorf(errmsg)
0000000000000000000000000000000000000000;;			return "", errors.New(errmsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volume.AttachedServerId != "" {
0000000000000000000000000000000000000000;;			if instanceID == volume.AttachedServerId {
0000000000000000000000000000000000000000;;				// Attachment[0]["device"] points to the device path
0000000000000000000000000000000000000000;;				// see http://developer.openstack.org/api-ref-blockstorage-v1.html
0000000000000000000000000000000000000000;;				return volume.AttachedDevice, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errMsg := fmt.Sprintf("Disk %q is attached to a different compute: %q, should be detached before proceeding", volumeID, volume.AttachedServerId)
0000000000000000000000000000000000000000;;				glog.Errorf(errMsg)
0000000000000000000000000000000000000000;;				return "", errors.New(errMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("volume %s has no ServerId.", volumeID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// query if a volume is attached to a compute instance
0000000000000000000000000000000000000000;;	func (os *OpenStack) DiskIsAttached(instanceID, volumeID string) (bool, error) {
0000000000000000000000000000000000000000;;		volume, err := os.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return instanceID == volume.AttachedServerId, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// query if a list of volumes are attached to a compute instance
0000000000000000000000000000000000000000;;	func (os *OpenStack) DisksAreAttached(instanceID string, volumeIDs []string) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		attached := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, volumeID := range volumeIDs {
0000000000000000000000000000000000000000;;			isAttached, _ := os.DiskIsAttached(instanceID, volumeID)
0000000000000000000000000000000000000000;;			attached[volumeID] = isAttached
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return attached, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diskIsUsed returns true a disk is attached to any node.
0000000000000000000000000000000000000000;;	func (os *OpenStack) diskIsUsed(volumeID string) (bool, error) {
0000000000000000000000000000000000000000;;		volume, err := os.getVolume(volumeID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.AttachedServerId != "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// query if we should trust the cinder provide deviceName, See issue #33128
0000000000000000000000000000000000000000;;	func (os *OpenStack) ShouldTrustDevicePath() bool {
0000000000000000000000000000000000000000;;		return os.bsOpts.TrustDevicePath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recordOpenstackOperationMetric records openstack operation metrics
0000000000000000000000000000000000000000;;	func recordOpenstackOperationMetric(operation string, timeTaken float64, err error) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			OpenstackApiRequestErrors.With(prometheus.Labels{"request": operation}).Inc()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			OpenstackOperationsLatency.With(prometheus.Labels{"request": operation}).Observe(timeTaken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
