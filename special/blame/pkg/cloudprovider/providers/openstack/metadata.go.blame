0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
124fde27261349bdcd84ba3aa14da22f0130b997;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// metadataUrl is URL to OpenStack metadata server. It's hardcoded IPv4
0000000000000000000000000000000000000000;;	// link-local address as documented in "OpenStack Cloud Administrator Guide",
0000000000000000000000000000000000000000;;	// chapter Compute - Networking with nova-network.
0000000000000000000000000000000000000000;;	// https://docs.openstack.org/admin-guide/compute-networking-nova.html#metadata-service
0000000000000000000000000000000000000000;;	const metadataUrl = "http://169.254.169.254/openstack/2012-08-10/meta_data.json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config drive is defined as an iso9660 or vfat (deprecated) drive
0000000000000000000000000000000000000000;;	// with the "config-2" label.
0000000000000000000000000000000000000000;;	// http://docs.openstack.org/user-guide/cli-config-drive.html
0000000000000000000000000000000000000000;;	const configDriveLabel = "config-2"
0000000000000000000000000000000000000000;;	const configDrivePath = "openstack/2012-08-10/meta_data.json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrBadMetadata = errors.New("Invalid OpenStack metadata, got empty uuid")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assumes the "2012-08-10" meta_data.json format.
0000000000000000000000000000000000000000;;	// See http://docs.openstack.org/user-guide/cli_config_drive.html
0000000000000000000000000000000000000000;;	type Metadata struct {
0000000000000000000000000000000000000000;;		Uuid             string `json:"uuid"`
0000000000000000000000000000000000000000;;		Name             string `json:"name"`
0000000000000000000000000000000000000000;;		AvailabilityZone string `json:"availability_zone"`
0000000000000000000000000000000000000000;;		// .. and other fields we don't care about.  Expand as necessary.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseMetadata reads JSON from OpenStack metadata server and parses
0000000000000000000000000000000000000000;;	// instance ID out of it.
0000000000000000000000000000000000000000;;	func parseMetadata(r io.Reader) (*Metadata, error) {
0000000000000000000000000000000000000000;;		var metadata Metadata
0000000000000000000000000000000000000000;;		json := json.NewDecoder(r)
0000000000000000000000000000000000000000;;		if err := json.Decode(&metadata); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if metadata.Uuid == "" {
0000000000000000000000000000000000000000;;			return nil, ErrBadMetadata
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &metadata, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMetadataFromConfigDrive() (*Metadata, error) {
0000000000000000000000000000000000000000;;		// Try to read instance UUID from config drive.
0000000000000000000000000000000000000000;;		dev := "/dev/disk/by-label/" + configDriveLabel
0000000000000000000000000000000000000000;;		if _, err := os.Stat(dev); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			out, err := exec.New().Command(
0000000000000000000000000000000000000000;;				"blkid", "-l",
0000000000000000000000000000000000000000;;				"-t", "LABEL="+configDriveLabel,
0000000000000000000000000000000000000000;;				"-o", "device",
0000000000000000000000000000000000000000;;			).CombinedOutput()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Unable to run blkid: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dev = strings.TrimSpace(string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mntdir, err := ioutil.TempDir("", "configdrive")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(mntdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Attempting to mount configdrive %s on %s", dev, mntdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounter := mount.New("" /* default mount path */)
0000000000000000000000000000000000000000;;		err = mounter.Mount(dev, mntdir, "iso9660", []string{"ro"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = mounter.Mount(dev, mntdir, "vfat", []string{"ro"})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error mounting configdrive %s: %v", dev, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer mounter.Unmount(mntdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Configdrive mounted on %s", mntdir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open(
0000000000000000000000000000000000000000;;			filepath.Join(mntdir, configDrivePath))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error reading %s on config drive: %v", configDrivePath, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseMetadata(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMetadataFromMetadataService() (*Metadata, error) {
0000000000000000000000000000000000000000;;		// Try to get JSON from metdata server.
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Attempting to fetch metadata from %s", metadataUrl)
0000000000000000000000000000000000000000;;		resp, err := http.Get(metadataUrl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Cannot read %s: %v", metadataUrl, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Unexpected status code when reading metadata from %s: %s", metadataUrl, resp.Status)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("%v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseMetadata(resp.Body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Metadata is fixed for the current host, so cache the value process-wide
0000000000000000000000000000000000000000;;	var metadataCache *Metadata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMetadata() (*Metadata, error) {
0000000000000000000000000000000000000000;;		if metadataCache == nil {
0000000000000000000000000000000000000000;;			md, err := getMetadataFromConfigDrive()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				md, err = getMetadataFromMetadataService()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metadataCache = md
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metadataCache, nil
0000000000000000000000000000000000000000;;	}
