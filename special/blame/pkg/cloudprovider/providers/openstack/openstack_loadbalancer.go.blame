0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1562e7e22b99393bb5ccd9d04bc0d8483fc11599;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/layer3/floatingips"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas/members"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas/monitors"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas/pools"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas/vips"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas_v2/listeners"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas_v2/loadbalancers"
0000000000000000000000000000000000000000;;		v2monitors "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas_v2/monitors"
0000000000000000000000000000000000000000;;		v2pools "github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/lbaas_v2/pools"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/security/groups"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/openstack/networking/v2/extensions/security/rules"
0000000000000000000000000000000000000000;;		neutronports "github.com/gophercloud/gophercloud/openstack/networking/v2/ports"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/pagination"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/service"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: when creating a new Loadbalancer (VM), it can take some time before it is ready for use,
0000000000000000000000000000000000000000;;	// this timeout is used for waiting until the Loadbalancer provisioning status goes to ACTIVE state.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// loadbalancerActive* is configuration of exponential backoff for
0000000000000000000000000000000000000000;;		// going into ACTIVE loadbalancer provisioning status. Starting with 1
0000000000000000000000000000000000000000;;		// seconds, multiplying by 1.2 with each step and taking 19 steps at maximum
0000000000000000000000000000000000000000;;		// it will time out after 128s, which roughly corresponds to 120s
0000000000000000000000000000000000000000;;		loadbalancerActiveInitDealy = 1 * time.Second
0000000000000000000000000000000000000000;;		loadbalancerActiveFactor    = 1.2
0000000000000000000000000000000000000000;;		loadbalancerActiveSteps     = 19
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// loadbalancerDelete* is configuration of exponential backoff for
0000000000000000000000000000000000000000;;		// waiting for delete operation to complete. Starting with 1
0000000000000000000000000000000000000000;;		// seconds, multiplying by 1.2 with each step and taking 13 steps at maximum
0000000000000000000000000000000000000000;;		// it will time out after 32s, which roughly corresponds to 30s
0000000000000000000000000000000000000000;;		loadbalancerDeleteInitDealy = 1 * time.Second
0000000000000000000000000000000000000000;;		loadbalancerDeleteFactor    = 1.2
0000000000000000000000000000000000000000;;		loadbalancerDeleteSteps     = 13
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		activeStatus = "ACTIVE"
0000000000000000000000000000000000000000;;		errorStatus  = "ERROR"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer implementation for LBaaS v1
0000000000000000000000000000000000000000;;	type LbaasV1 struct {
0000000000000000000000000000000000000000;;		LoadBalancer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer implementation for LBaaS v2
0000000000000000000000000000000000000000;;	type LbaasV2 struct {
0000000000000000000000000000000000000000;;		LoadBalancer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type empty struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func networkExtensions(client *gophercloud.ServiceClient) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		seen := make(map[string]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pager := extensions.List(client)
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			exts, err := extensions.ExtractExtensions(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ext := range exts {
0000000000000000000000000000000000000000;;				seen[ext.Alias] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return seen, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPortByIP(client *gophercloud.ServiceClient, ipAddress string) (neutronports.Port, error) {
0000000000000000000000000000000000000000;;		var targetPort neutronports.Port
0000000000000000000000000000000000000000;;		var portFound = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := neutronports.List(client, neutronports.ListOpts{}).EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			portList, err := neutronports.ExtractPorts(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, port := range portList {
0000000000000000000000000000000000000000;;				for _, ip := range port.FixedIPs {
0000000000000000000000000000000000000000;;					if ip.IPAddress == ipAddress {
0000000000000000000000000000000000000000;;						targetPort = port
0000000000000000000000000000000000000000;;						portFound = true
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == nil && !portFound {
0000000000000000000000000000000000000000;;			err = ErrNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return targetPort, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getFloatingIPByPortID(client *gophercloud.ServiceClient, portID string) (*floatingips.FloatingIP, error) {
0000000000000000000000000000000000000000;;		opts := floatingips.ListOpts{
0000000000000000000000000000000000000000;;			PortID: portID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := floatingips.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		floatingIPList := make([]floatingips.FloatingIP, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			f, err := floatingips.ExtractFloatingIPs(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			floatingIPList = append(floatingIPList, f...)
0000000000000000000000000000000000000000;;			if len(floatingIPList) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, ErrNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(floatingIPList) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		} else if len(floatingIPList) > 1 {
0000000000000000000000000000000000000000;;			return nil, ErrMultipleResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &floatingIPList[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPoolByName(client *gophercloud.ServiceClient, name string) (*pools.Pool, error) {
0000000000000000000000000000000000000000;;		opts := pools.ListOpts{
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := pools.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		poolList := make([]pools.Pool, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			p, err := pools.ExtractPools(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			poolList = append(poolList, p...)
0000000000000000000000000000000000000000;;			if len(poolList) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, ErrNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(poolList) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		} else if len(poolList) > 1 {
0000000000000000000000000000000000000000;;			return nil, ErrMultipleResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &poolList[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVipByName(client *gophercloud.ServiceClient, name string) (*vips.VirtualIP, error) {
0000000000000000000000000000000000000000;;		opts := vips.ListOpts{
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := vips.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vipList := make([]vips.VirtualIP, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			v, err := vips.ExtractVIPs(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vipList = append(vipList, v...)
0000000000000000000000000000000000000000;;			if len(vipList) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, ErrNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(vipList) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		} else if len(vipList) > 1 {
0000000000000000000000000000000000000000;;			return nil, ErrMultipleResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &vipList[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getLoadbalancerByName(client *gophercloud.ServiceClient, name string) (*loadbalancers.LoadBalancer, error) {
0000000000000000000000000000000000000000;;		opts := loadbalancers.ListOpts{
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := loadbalancers.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadbalancerList := make([]loadbalancers.LoadBalancer, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			v, err := loadbalancers.ExtractLoadBalancers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			loadbalancerList = append(loadbalancerList, v...)
0000000000000000000000000000000000000000;;			if len(loadbalancerList) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, ErrNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(loadbalancerList) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		} else if len(loadbalancerList) > 1 {
0000000000000000000000000000000000000000;;			return nil, ErrMultipleResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &loadbalancerList[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getListenersByLoadBalancerID(client *gophercloud.ServiceClient, id string) ([]listeners.Listener, error) {
0000000000000000000000000000000000000000;;		var existingListeners []listeners.Listener
0000000000000000000000000000000000000000;;		err := listeners.List(client, listeners.ListOpts{LoadbalancerID: id}).EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			listenerList, err := listeners.ExtractListeners(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, l := range listenerList {
0000000000000000000000000000000000000000;;				for _, lb := range l.Loadbalancers {
0000000000000000000000000000000000000000;;					if lb.ID == id {
0000000000000000000000000000000000000000;;						existingListeners = append(existingListeners, l)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return existingListeners, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get listener for a port or nil if does not exist
0000000000000000000000000000000000000000;;	func getListenerForPort(existingListeners []listeners.Listener, port v1.ServicePort) *listeners.Listener {
0000000000000000000000000000000000000000;;		for _, l := range existingListeners {
0000000000000000000000000000000000000000;;			if listeners.Protocol(l.Protocol) == toListenersProtocol(port.Protocol) && l.ProtocolPort == int(port.Port) {
0000000000000000000000000000000000000000;;				return &l
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get pool for a listener. A listener always has exactly one pool.
0000000000000000000000000000000000000000;;	func getPoolByListenerID(client *gophercloud.ServiceClient, loadbalancerID string, listenerID string) (*v2pools.Pool, error) {
0000000000000000000000000000000000000000;;		listenerPools := make([]v2pools.Pool, 0, 1)
0000000000000000000000000000000000000000;;		err := v2pools.List(client, v2pools.ListOpts{LoadbalancerID: loadbalancerID}).EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			poolsList, err := v2pools.ExtractPools(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, p := range poolsList {
0000000000000000000000000000000000000000;;				for _, l := range p.Listeners {
0000000000000000000000000000000000000000;;					if l.ID == listenerID {
0000000000000000000000000000000000000000;;						listenerPools = append(listenerPools, p)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(listenerPools) > 1 {
0000000000000000000000000000000000000000;;				return false, ErrMultipleResults
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, ErrNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(listenerPools) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		} else if len(listenerPools) > 1 {
0000000000000000000000000000000000000000;;			return nil, ErrMultipleResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &listenerPools[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMembersByPoolID(client *gophercloud.ServiceClient, id string) ([]v2pools.Member, error) {
0000000000000000000000000000000000000000;;		var members []v2pools.Member
0000000000000000000000000000000000000000;;		err := v2pools.ListMembers(client, id, v2pools.ListMembersOpts{}).EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			membersList, err := v2pools.ExtractMembers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			members = append(members, membersList...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return members, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a member exists for node
0000000000000000000000000000000000000000;;	func memberExists(members []v2pools.Member, addr string, port int) bool {
0000000000000000000000000000000000000000;;		for _, member := range members {
0000000000000000000000000000000000000000;;			if member.Address == addr && member.ProtocolPort == port {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func popListener(existingListeners []listeners.Listener, id string) []listeners.Listener {
0000000000000000000000000000000000000000;;		for i, existingListener := range existingListeners {
0000000000000000000000000000000000000000;;			if existingListener.ID == id {
0000000000000000000000000000000000000000;;				existingListeners[i] = existingListeners[len(existingListeners)-1]
0000000000000000000000000000000000000000;;				existingListeners = existingListeners[:len(existingListeners)-1]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return existingListeners
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func popMember(members []v2pools.Member, addr string, port int) []v2pools.Member {
0000000000000000000000000000000000000000;;		for i, member := range members {
0000000000000000000000000000000000000000;;			if member.Address == addr && member.ProtocolPort == port {
0000000000000000000000000000000000000000;;				members[i] = members[len(members)-1]
0000000000000000000000000000000000000000;;				members = members[:len(members)-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return members
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSecurityGroupName(clusterName string, service *v1.Service) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("lb-sg-%s-%v", clusterName, service.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSecurityGroupRules(client *gophercloud.ServiceClient, opts rules.ListOpts) ([]rules.SecGroupRule, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pager := rules.List(client, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var securityRules []rules.SecGroupRule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			ruleList, err := rules.ExtractRules(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			securityRules = append(securityRules, ruleList...)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return securityRules, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitLoadbalancerActiveProvisioningStatus(client *gophercloud.ServiceClient, loadbalancerID string) (string, error) {
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: loadbalancerActiveInitDealy,
0000000000000000000000000000000000000000;;			Factor:   loadbalancerActiveFactor,
0000000000000000000000000000000000000000;;			Steps:    loadbalancerActiveSteps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var provisioningStatus string
0000000000000000000000000000000000000000;;		err := wait.ExponentialBackoff(backoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			loadbalancer, err := loadbalancers.Get(client, loadbalancerID).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			provisioningStatus = loadbalancer.ProvisioningStatus
0000000000000000000000000000000000000000;;			if loadbalancer.ProvisioningStatus == activeStatus {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			} else if loadbalancer.ProvisioningStatus == errorStatus {
0000000000000000000000000000000000000000;;				return true, fmt.Errorf("Loadbalancer has gone into ERROR state")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Loadbalancer failed to go into ACTIVE provisioning status within alloted time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return provisioningStatus, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitLoadbalancerDeleted(client *gophercloud.ServiceClient, loadbalancerID string) error {
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: loadbalancerDeleteInitDealy,
0000000000000000000000000000000000000000;;			Factor:   loadbalancerDeleteFactor,
0000000000000000000000000000000000000000;;			Steps:    loadbalancerDeleteSteps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := wait.ExponentialBackoff(backoff, func() (bool, error) {
0000000000000000000000000000000000000000;;			_, err := loadbalancers.Get(client, loadbalancerID).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == ErrNotFound {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Loadbalancer failed to delete within the alloted time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toRuleProtocol(protocol v1.Protocol) rules.RuleProtocol {
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case v1.ProtocolTCP:
0000000000000000000000000000000000000000;;			return rules.ProtocolTCP
0000000000000000000000000000000000000000;;		case v1.ProtocolUDP:
0000000000000000000000000000000000000000;;			return rules.ProtocolUDP
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return rules.RuleProtocol(strings.ToLower(string(protocol)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toListenersProtocol(protocol v1.Protocol) listeners.Protocol {
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case v1.ProtocolTCP:
0000000000000000000000000000000000000000;;			return listeners.ProtocolTCP
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return listeners.Protocol(string(protocol))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createNodeSecurityGroup(client *gophercloud.ServiceClient, nodeSecurityGroupID string, port int, protocol v1.Protocol, lbSecGroup string) error {
0000000000000000000000000000000000000000;;		v4NodeSecGroupRuleCreateOpts := rules.CreateOpts{
0000000000000000000000000000000000000000;;			Direction:     rules.DirIngress,
0000000000000000000000000000000000000000;;			PortRangeMax:  port,
0000000000000000000000000000000000000000;;			PortRangeMin:  port,
0000000000000000000000000000000000000000;;			Protocol:      toRuleProtocol(protocol),
0000000000000000000000000000000000000000;;			RemoteGroupID: lbSecGroup,
0000000000000000000000000000000000000000;;			SecGroupID:    nodeSecurityGroupID,
0000000000000000000000000000000000000000;;			EtherType:     rules.EtherType4,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v6NodeSecGroupRuleCreateOpts := rules.CreateOpts{
0000000000000000000000000000000000000000;;			Direction:     rules.DirIngress,
0000000000000000000000000000000000000000;;			PortRangeMax:  port,
0000000000000000000000000000000000000000;;			PortRangeMin:  port,
0000000000000000000000000000000000000000;;			Protocol:      toRuleProtocol(protocol),
0000000000000000000000000000000000000000;;			RemoteGroupID: lbSecGroup,
0000000000000000000000000000000000000000;;			SecGroupID:    nodeSecurityGroupID,
0000000000000000000000000000000000000000;;			EtherType:     rules.EtherType6,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := rules.Create(client, v4NodeSecGroupRuleCreateOpts).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = rules.Create(client, v6NodeSecGroupRuleCreateOpts).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbaas *LbaasV2) createLoadBalancer(service *v1.Service, name string) (*loadbalancers.LoadBalancer, error) {
0000000000000000000000000000000000000000;;		createOpts := loadbalancers.CreateOpts{
0000000000000000000000000000000000000000;;			Name:        name,
0000000000000000000000000000000000000000;;			Description: fmt.Sprintf("Kubernetes external service %s", name),
0000000000000000000000000000000000000000;;			VipSubnetID: lbaas.opts.SubnetId,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancerIP := service.Spec.LoadBalancerIP
0000000000000000000000000000000000000000;;		if loadBalancerIP != "" {
0000000000000000000000000000000000000000;;			createOpts.VipAddress = loadBalancerIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadbalancer, err := loadbalancers.Create(lbaas.network, createOpts).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error creating loadbalancer %v: %v", createOpts, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return loadbalancer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbaas *LbaasV2) GetLoadBalancer(clusterName string, service *v1.Service) (*v1.LoadBalancerStatus, bool, error) {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		loadbalancer, err := getLoadbalancerByName(lbaas.network, loadBalancerName)
0000000000000000000000000000000000000000;;		if err == ErrNotFound {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if loadbalancer == nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		status.Ingress = []v1.LoadBalancerIngress{{IP: loadbalancer.VipAddress}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The LB needs to be configured with instance addresses on the same
0000000000000000000000000000000000000000;;	// subnet as the LB (aka opts.SubnetId).  Currently we're just
0000000000000000000000000000000000000000;;	// guessing that the node's InternalIP is the right address - and that
0000000000000000000000000000000000000000;;	// should be sufficient for all "normal" cases.
0000000000000000000000000000000000000000;;	func nodeAddressForLB(node *v1.Node) (string, error) {
0000000000000000000000000000000000000000;;		addrs := node.Status.Addresses
0000000000000000000000000000000000000000;;		if len(addrs) == 0 {
0000000000000000000000000000000000000000;;			return "", ErrNoAddressFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, addr := range addrs {
0000000000000000000000000000000000000000;;			if addr.Type == v1.NodeInternalIP {
0000000000000000000000000000000000000000;;				return addr.Address, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return addrs[0].Address, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This code currently ignores 'region' and always creates a
0000000000000000000000000000000000000000;;	// loadbalancer in only the current OpenStack region.  We should take
0000000000000000000000000000000000000000;;	// a list of regions (from config) and query/create loadbalancers in
0000000000000000000000000000000000000000;;	// each region.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbaas *LbaasV2) EnsureLoadBalancer(clusterName string, apiService *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v, %v, %v)", clusterName, apiService.Namespace, apiService.Name, apiService.Spec.LoadBalancerIP, apiService.Spec.Ports, nodes, apiService.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ports := apiService.Spec.Ports
0000000000000000000000000000000000000000;;		if len(ports) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no ports provided to openstack load balancer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for TCP protocol on each port
0000000000000000000000000000000000000000;;		// TODO: Convert all error messages to use an event recorder
0000000000000000000000000000000000000000;;		for _, port := range ports {
0000000000000000000000000000000000000000;;			if port.Protocol != v1.ProtocolTCP {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Only TCP LoadBalancer is supported for openstack load balancers")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sourceRanges, err := service.GetLoadBalancerSourceRanges(apiService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !service.IsAllowAll(sourceRanges) && !lbaas.opts.ManageSecurityGroups {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Source range restrictions are not supported for openstack load balancers without managing security groups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		affinity := apiService.Spec.SessionAffinity
0000000000000000000000000000000000000000;;		var persistence *v2pools.SessionPersistence
0000000000000000000000000000000000000000;;		switch affinity {
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityNone:
0000000000000000000000000000000000000000;;			persistence = nil
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityClientIP:
0000000000000000000000000000000000000000;;			persistence = &v2pools.SessionPersistence{Type: "SOURCE_IP"}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported load balancer affinity: %v", affinity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := cloudprovider.GetLoadBalancerName(apiService)
0000000000000000000000000000000000000000;;		loadbalancer, err := getLoadbalancerByName(lbaas.network, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err != ErrNotFound {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error getting loadbalancer %s: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Creating loadbalancer %s", name)
0000000000000000000000000000000000000000;;			loadbalancer, err = lbaas.createLoadBalancer(apiService, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Unknown error, retry later
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error creating loadbalancer %s: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("LoadBalancer %s already exists", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbmethod := v2pools.LBMethod(lbaas.opts.LBMethod)
0000000000000000000000000000000000000000;;		if lbmethod == "" {
0000000000000000000000000000000000000000;;			lbmethod = v2pools.LBMethodRoundRobin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldListeners, err := getListenersByLoadBalancerID(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error getting LB %s listeners: %v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for portIndex, port := range ports {
0000000000000000000000000000000000000000;;			listener := getListenerForPort(oldListeners, port)
0000000000000000000000000000000000000000;;			if listener == nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Creating listener for port %d", int(port.Port))
0000000000000000000000000000000000000000;;				listener, err = listeners.Create(lbaas.network, listeners.CreateOpts{
0000000000000000000000000000000000000000;;					Name:           fmt.Sprintf("listener_%s_%d", name, portIndex),
0000000000000000000000000000000000000000;;					Protocol:       listeners.Protocol(port.Protocol),
0000000000000000000000000000000000000000;;					ProtocolPort:   int(port.Port),
0000000000000000000000000000000000000000;;					LoadbalancerID: loadbalancer.ID,
0000000000000000000000000000000000000000;;				}).Extract()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Unknown error, retry later
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Error creating LB listener: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Listener for %s port %d: %s", string(port.Protocol), int(port.Port), listener.ID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// After all ports have been processed, remaining listeners are removed as obsolete.
0000000000000000000000000000000000000000;;			// Pop valid listeners.
0000000000000000000000000000000000000000;;			oldListeners = popListener(oldListeners, listener.ID)
0000000000000000000000000000000000000000;;			pool, err := getPoolByListenerID(lbaas.network, loadbalancer.ID, listener.ID)
0000000000000000000000000000000000000000;;			if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;				// Unknown error, retry later
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error getting pool for listener %s: %v", listener.ID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pool == nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Creating pool for listener %s", listener.ID)
0000000000000000000000000000000000000000;;				pool, err = v2pools.Create(lbaas.network, v2pools.CreateOpts{
0000000000000000000000000000000000000000;;					Name:        fmt.Sprintf("pool_%s_%d", name, portIndex),
0000000000000000000000000000000000000000;;					Protocol:    v2pools.Protocol(port.Protocol),
0000000000000000000000000000000000000000;;					LBMethod:    lbmethod,
0000000000000000000000000000000000000000;;					ListenerID:  listener.ID,
0000000000000000000000000000000000000000;;					Persistence: persistence,
0000000000000000000000000000000000000000;;				}).Extract()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Unknown error, retry later
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Error creating pool for listener %s: %v", listener.ID, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Pool for listener %s: %s", listener.ID, pool.ID)
0000000000000000000000000000000000000000;;			members, err := getMembersByPoolID(lbaas.network, pool.ID)
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error getting pool members %s: %v", pool.ID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, node := range nodes {
0000000000000000000000000000000000000000;;				addr, err := nodeAddressForLB(node)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if err == ErrNotFound {
0000000000000000000000000000000000000000;;						// Node failure, do not create member
0000000000000000000000000000000000000000;;						glog.Warningf("Failed to create LB pool member for node %s: %v", node.Name, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("Error getting address for node %s: %v", node.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !memberExists(members, addr, int(port.NodePort)) {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Creating member for pool %s", pool.ID)
0000000000000000000000000000000000000000;;					_, err := v2pools.CreateMember(lbaas.network, pool.ID, v2pools.CreateMemberOpts{
0000000000000000000000000000000000000000;;						ProtocolPort: int(port.NodePort),
0000000000000000000000000000000000000000;;						Address:      addr,
0000000000000000000000000000000000000000;;						SubnetID:     lbaas.opts.SubnetId,
0000000000000000000000000000000000000000;;					}).Extract()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("Error creating LB pool member for node: %s, %v", node.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// After all members have been processed, remaining members are deleted as obsolete.
0000000000000000000000000000000000000000;;					members = popMember(members, addr, int(port.NodePort))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Ensured pool %s has member for %s at %s", pool.ID, node.Name, addr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Delete obsolete members for this pool
0000000000000000000000000000000000000000;;			for _, member := range members {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Deleting obsolete member %s for pool %s address %s", member.ID, pool.ID, member.Address)
0000000000000000000000000000000000000000;;				err := v2pools.DeleteMember(lbaas.network, pool.ID, member.ID).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Error deleting obsolete member %s for pool %s address %s: %v", member.ID, pool.ID, member.Address, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			monitorID := pool.MonitorID
0000000000000000000000000000000000000000;;			if monitorID == "" && lbaas.opts.CreateMonitor {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Creating monitor for pool %s", pool.ID)
0000000000000000000000000000000000000000;;				monitor, err := v2monitors.Create(lbaas.network, v2monitors.CreateOpts{
0000000000000000000000000000000000000000;;					PoolID:     pool.ID,
0000000000000000000000000000000000000000;;					Type:       string(port.Protocol),
0000000000000000000000000000000000000000;;					Delay:      int(lbaas.opts.MonitorDelay.Duration.Seconds()),
0000000000000000000000000000000000000000;;					Timeout:    int(lbaas.opts.MonitorTimeout.Duration.Seconds()),
0000000000000000000000000000000000000000;;					MaxRetries: int(lbaas.opts.MonitorMaxRetries),
0000000000000000000000000000000000000000;;				}).Extract()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Error creating LB pool healthmonitor: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;				monitorID = monitor.ID
0000000000000000000000000000000000000000;;			} else if lbaas.opts.CreateMonitor == false {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Do not create monitor for pool %s when create-monitor is false", pool.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if monitorID != "" {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Monitor for pool %s: %s", pool.ID, monitorID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All remaining listeners are obsolete, delete
0000000000000000000000000000000000000000;;		for _, listener := range oldListeners {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Deleting obsolete listener %s:", listener.ID)
0000000000000000000000000000000000000000;;			// get pool for listener
0000000000000000000000000000000000000000;;			pool, err := getPoolByListenerID(lbaas.network, loadbalancer.ID, listener.ID)
0000000000000000000000000000000000000000;;			if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error getting pool for obsolete listener %s: %v", listener.ID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pool != nil {
0000000000000000000000000000000000000000;;				// get and delete monitor
0000000000000000000000000000000000000000;;				monitorID := pool.MonitorID
0000000000000000000000000000000000000000;;				if monitorID != "" {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Deleting obsolete monitor %s for pool %s", monitorID, pool.ID)
0000000000000000000000000000000000000000;;					err = v2monitors.Delete(lbaas.network, monitorID).ExtractErr()
0000000000000000000000000000000000000000;;					if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("Error deleting obsolete monitor %s for pool %s: %v", monitorID, pool.ID, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// get and delete pool members
0000000000000000000000000000000000000000;;				members, err := getMembersByPoolID(lbaas.network, pool.ID)
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Error getting members for pool %s: %v", pool.ID, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if members != nil {
0000000000000000000000000000000000000000;;					for _, member := range members {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Deleting obsolete member %s for pool %s address %s", member.ID, pool.ID, member.Address)
0000000000000000000000000000000000000000;;						err := v2pools.DeleteMember(lbaas.network, pool.ID, member.ID).ExtractErr()
0000000000000000000000000000000000000000;;						if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;							return nil, fmt.Errorf("Error deleting obsolete member %s for pool %s address %s: %v", member.ID, pool.ID, member.Address, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Deleting obsolete pool %s for listener %s", pool.ID, listener.ID)
0000000000000000000000000000000000000000;;				// delete pool
0000000000000000000000000000000000000000;;				err = v2pools.Delete(lbaas.network, pool.ID).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Error deleting obsolete pool %s for listener %s: %v", pool.ID, listener.ID, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// delete listener
0000000000000000000000000000000000000000;;			err = listeners.Delete(lbaas.network, listener.ID).ExtractErr()
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error deleteting obsolete listener: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Deleted obsolete listener: %s", listener.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status.Ingress = []v1.LoadBalancerIngress{{IP: loadbalancer.VipAddress}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portID := loadbalancer.VipPortID
0000000000000000000000000000000000000000;;		floatIP, err := getFloatingIPByPortID(lbaas.network, portID)
0000000000000000000000000000000000000000;;		if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error getting floating ip for port %s: %v", portID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if floatIP == nil && lbaas.opts.FloatingNetworkId != "" {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Creating floating ip for loadbalancer %s port %s", loadbalancer.ID, portID)
0000000000000000000000000000000000000000;;			floatIPOpts := floatingips.CreateOpts{
0000000000000000000000000000000000000000;;				FloatingNetworkID: lbaas.opts.FloatingNetworkId,
0000000000000000000000000000000000000000;;				PortID:            portID,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			floatIP, err = floatingips.Create(lbaas.network, floatIPOpts).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error creating LB floatingip %+v: %v", floatIPOpts, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if floatIP != nil {
0000000000000000000000000000000000000000;;			status.Ingress = append(status.Ingress, v1.LoadBalancerIngress{IP: floatIP.FloatingIP})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lbaas.opts.ManageSecurityGroups {
0000000000000000000000000000000000000000;;			lbSecGroupCreateOpts := groups.CreateOpts{
0000000000000000000000000000000000000000;;				Name:        getSecurityGroupName(clusterName, apiService),
0000000000000000000000000000000000000000;;				Description: fmt.Sprintf("Securty Group for %v Service LoadBalancer", apiService.Name),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lbSecGroup, err := groups.Create(lbaas.network, lbSecGroupCreateOpts).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// cleanup what was created so far
0000000000000000000000000000000000000000;;				_ = lbaas.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, port := range ports {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, sourceRange := range sourceRanges.StringSlice() {
0000000000000000000000000000000000000000;;					ethertype := rules.EtherType4
0000000000000000000000000000000000000000;;					network, _, err := net.ParseCIDR(sourceRange)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// cleanup what was created so far
0000000000000000000000000000000000000000;;						glog.Errorf("Error parsing source range %s as a CIDR", sourceRange)
0000000000000000000000000000000000000000;;						_ = lbaas.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if network.To4() == nil {
0000000000000000000000000000000000000000;;						ethertype = rules.EtherType6
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					lbSecGroupRuleCreateOpts := rules.CreateOpts{
0000000000000000000000000000000000000000;;						Direction:      rules.DirIngress,
0000000000000000000000000000000000000000;;						PortRangeMax:   int(port.Port),
0000000000000000000000000000000000000000;;						PortRangeMin:   int(port.Port),
0000000000000000000000000000000000000000;;						Protocol:       toRuleProtocol(port.Protocol),
0000000000000000000000000000000000000000;;						RemoteIPPrefix: sourceRange,
0000000000000000000000000000000000000000;;						SecGroupID:     lbSecGroup.ID,
0000000000000000000000000000000000000000;;						EtherType:      ethertype,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					_, err = rules.Create(lbaas.network, lbSecGroupRuleCreateOpts).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// cleanup what was created so far
0000000000000000000000000000000000000000;;						_ = lbaas.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err := createNodeSecurityGroup(lbaas.network, lbaas.opts.NodeSecurityGroupID, int(port.NodePort), port.Protocol, lbSecGroup.ID)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Error occured creating security group for loadbalancer %s:", loadbalancer.ID)
0000000000000000000000000000000000000000;;					_ = lbaas.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lbSecGroupRuleCreateOpts := rules.CreateOpts{
0000000000000000000000000000000000000000;;				Direction:      rules.DirIngress,
0000000000000000000000000000000000000000;;				PortRangeMax:   4, // ICMP: Code -  Values for ICMP  "Destination Unreachable: Fragmentation Needed and Don't Fragment was Set"
0000000000000000000000000000000000000000;;				PortRangeMin:   3, // ICMP: Type
0000000000000000000000000000000000000000;;				Protocol:       rules.ProtocolICMP,
0000000000000000000000000000000000000000;;				RemoteIPPrefix: "0.0.0.0/0", // The Fragmentation packet can come from anywhere along the path back to the sourceRange - we need to all this from all
0000000000000000000000000000000000000000;;				SecGroupID:     lbSecGroup.ID,
0000000000000000000000000000000000000000;;				EtherType:      rules.EtherType4,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = rules.Create(lbaas.network, lbSecGroupRuleCreateOpts).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// cleanup what was created so far
0000000000000000000000000000000000000000;;				_ = lbaas.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lbSecGroupRuleCreateOpts = rules.CreateOpts{
0000000000000000000000000000000000000000;;				Direction:      rules.DirIngress,
0000000000000000000000000000000000000000;;				PortRangeMax:   0, // ICMP: Code - Values for ICMP "Packet Too Big"
0000000000000000000000000000000000000000;;				PortRangeMin:   2, // ICMP: Type
0000000000000000000000000000000000000000;;				Protocol:       rules.ProtocolICMP,
0000000000000000000000000000000000000000;;				RemoteIPPrefix: "::/0", // The Fragmentation packet can come from anywhere along the path back to the sourceRange - we need to all this from all
0000000000000000000000000000000000000000;;				SecGroupID:     lbSecGroup.ID,
0000000000000000000000000000000000000000;;				EtherType:      rules.EtherType6,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = rules.Create(lbaas.network, lbSecGroupRuleCreateOpts).Extract()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// cleanup what was created so far
0000000000000000000000000000000000000000;;				_ = lbaas.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			portID := loadbalancer.VipPortID
0000000000000000000000000000000000000000;;			update_opts := neutronports.UpdateOpts{SecurityGroups: []string{lbSecGroup.ID}}
0000000000000000000000000000000000000000;;			res := neutronports.Update(lbaas.network, portID, update_opts)
0000000000000000000000000000000000000000;;			if res.Err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error occured updating port: %s", portID)
0000000000000000000000000000000000000000;;				// cleanup what was created so far
0000000000000000000000000000000000000000;;				_ = lbaas.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;				return nil, res.Err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbaas *LbaasV2) UpdateLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("UpdateLoadBalancer(%v, %v, %v)", clusterName, loadBalancerName, nodes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ports := service.Spec.Ports
0000000000000000000000000000000000000000;;		if len(ports) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no ports provided to openstack load balancer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadbalancer, err := getLoadbalancerByName(lbaas.network, loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if loadbalancer == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Loadbalancer %s does not exist", loadBalancerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get all listeners for this loadbalancer, by "port key".
0000000000000000000000000000000000000000;;		type portKey struct {
0000000000000000000000000000000000000000;;			Protocol listeners.Protocol
0000000000000000000000000000000000000000;;			Port     int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var listenerIDs []string
0000000000000000000000000000000000000000;;		lbListeners := make(map[portKey]listeners.Listener)
0000000000000000000000000000000000000000;;		allListeners, err := getListenersByLoadBalancerID(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error getting listeners for LB %s: %v", loadBalancerName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, l := range allListeners {
0000000000000000000000000000000000000000;;			key := portKey{Protocol: listeners.Protocol(l.Protocol), Port: l.ProtocolPort}
0000000000000000000000000000000000000000;;			lbListeners[key] = l
0000000000000000000000000000000000000000;;			listenerIDs = append(listenerIDs, l.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get all pools for this loadbalancer, by listener ID.
0000000000000000000000000000000000000000;;		lbPools := make(map[string]v2pools.Pool)
0000000000000000000000000000000000000000;;		for _, listenerID := range listenerIDs {
0000000000000000000000000000000000000000;;			pool, err := getPoolByListenerID(lbaas.network, loadbalancer.ID, listenerID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error getting pool for listener %s: %v", listenerID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lbPools[listenerID] = *pool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compose Set of member (addresses) that _should_ exist
0000000000000000000000000000000000000000;;		addrs := map[string]empty{}
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			addr, err := nodeAddressForLB(node)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addrs[addr] = empty{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for adding/removing members associated with each port
0000000000000000000000000000000000000000;;		for _, port := range ports {
0000000000000000000000000000000000000000;;			// Get listener associated with this port
0000000000000000000000000000000000000000;;			listener, ok := lbListeners[portKey{
0000000000000000000000000000000000000000;;				Protocol: toListenersProtocol(port.Protocol),
0000000000000000000000000000000000000000;;				Port:     int(port.Port),
0000000000000000000000000000000000000000;;			}]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Loadbalancer %s does not contain required listener for port %d and protocol %s", loadBalancerName, port.Port, port.Protocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get pool associated with this listener
0000000000000000000000000000000000000000;;			pool, ok := lbPools[listener.ID]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Loadbalancer %s does not contain required pool for listener %s", loadBalancerName, listener.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find existing pool members (by address) for this port
0000000000000000000000000000000000000000;;			getMembers, err := getMembersByPoolID(lbaas.network, pool.ID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error getting pool members %s: %v", pool.ID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			members := make(map[string]v2pools.Member)
0000000000000000000000000000000000000000;;			for _, member := range getMembers {
0000000000000000000000000000000000000000;;				members[member.Address] = member
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add any new members for this port
0000000000000000000000000000000000000000;;			for addr := range addrs {
0000000000000000000000000000000000000000;;				if _, ok := members[addr]; ok && members[addr].ProtocolPort == int(port.NodePort) {
0000000000000000000000000000000000000000;;					// Already exists, do not create member
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err := v2pools.CreateMember(lbaas.network, pool.ID, v2pools.CreateMemberOpts{
0000000000000000000000000000000000000000;;					Address:      addr,
0000000000000000000000000000000000000000;;					ProtocolPort: int(port.NodePort),
0000000000000000000000000000000000000000;;					SubnetID:     lbaas.opts.SubnetId,
0000000000000000000000000000000000000000;;				}).Extract()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove any old members for this port
0000000000000000000000000000000000000000;;			for _, member := range members {
0000000000000000000000000000000000000000;;				if _, ok := addrs[member.Address]; ok && member.ProtocolPort == int(port.NodePort) {
0000000000000000000000000000000000000000;;					// Still present, do not delete member
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = v2pools.DeleteMember(lbaas.network, pool.ID, member.ID).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lbaas *LbaasV2) EnsureLoadBalancerDeleted(clusterName string, service *v1.Service) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancerDeleted(%v, %v)", clusterName, loadBalancerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadbalancer, err := getLoadbalancerByName(lbaas.network, loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if loadbalancer == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lbaas.opts.FloatingNetworkId != "" && loadbalancer != nil {
0000000000000000000000000000000000000000;;			portID := loadbalancer.VipPortID
0000000000000000000000000000000000000000;;			floatingIP, err := getFloatingIPByPortID(lbaas.network, portID)
0000000000000000000000000000000000000000;;			if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if floatingIP != nil {
0000000000000000000000000000000000000000;;				err = floatingips.Delete(lbaas.network, floatingIP.ID).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get all listeners associated with this loadbalancer
0000000000000000000000000000000000000000;;		listenerList, err := getListenersByLoadBalancerID(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error getting LB %s listeners: %v", loadbalancer.ID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get all pools (and health monitors) associated with this loadbalancer
0000000000000000000000000000000000000000;;		var poolIDs []string
0000000000000000000000000000000000000000;;		var monitorIDs []string
0000000000000000000000000000000000000000;;		for _, listener := range listenerList {
0000000000000000000000000000000000000000;;			pool, err := getPoolByListenerID(lbaas.network, loadbalancer.ID, listener.ID)
0000000000000000000000000000000000000000;;			if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error getting pool for listener %s: %v", listener.ID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			poolIDs = append(poolIDs, pool.ID)
0000000000000000000000000000000000000000;;			// If create-monitor of cloud-config is false, pool has not monitor.
0000000000000000000000000000000000000000;;			if pool.MonitorID != "" {
0000000000000000000000000000000000000000;;				monitorIDs = append(monitorIDs, pool.MonitorID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get all members associated with each poolIDs
0000000000000000000000000000000000000000;;		var memberIDs []string
0000000000000000000000000000000000000000;;		for _, pool := range poolIDs {
0000000000000000000000000000000000000000;;			membersList, err := getMembersByPoolID(lbaas.network, pool)
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Error getting pool members %s: %v", pool, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, member := range membersList {
0000000000000000000000000000000000000000;;				memberIDs = append(memberIDs, member.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete all monitors
0000000000000000000000000000000000000000;;		for _, monitorID := range monitorIDs {
0000000000000000000000000000000000000000;;			err := v2monitors.Delete(lbaas.network, monitorID).ExtractErr()
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete all members and pools
0000000000000000000000000000000000000000;;		for _, poolID := range poolIDs {
0000000000000000000000000000000000000000;;			// delete all members for this pool
0000000000000000000000000000000000000000;;			for _, memberID := range memberIDs {
0000000000000000000000000000000000000000;;				err := v2pools.DeleteMember(lbaas.network, poolID, memberID).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// delete pool
0000000000000000000000000000000000000000;;			err := v2pools.Delete(lbaas.network, poolID).ExtractErr()
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete all listeners
0000000000000000000000000000000000000000;;		for _, listener := range listenerList {
0000000000000000000000000000000000000000;;			err := listeners.Delete(lbaas.network, listener.ID).ExtractErr()
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			waitLoadbalancerActiveProvisioningStatus(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete loadbalancer
0000000000000000000000000000000000000000;;		err = loadbalancers.Delete(lbaas.network, loadbalancer.ID).ExtractErr()
0000000000000000000000000000000000000000;;		if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitLoadbalancerDeleted(lbaas.network, loadbalancer.ID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the Security Group
0000000000000000000000000000000000000000;;		if lbaas.opts.ManageSecurityGroups {
0000000000000000000000000000000000000000;;			// Generate Name
0000000000000000000000000000000000000000;;			lbSecGroupName := getSecurityGroupName(clusterName, service)
0000000000000000000000000000000000000000;;			lbSecGroupID, err := groups.IDFromName(lbaas.network, lbSecGroupName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Error occurred finding security group: %s: %v", lbSecGroupName, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lbSecGroup := groups.Delete(lbaas.network, lbSecGroupID)
0000000000000000000000000000000000000000;;			if lbSecGroup.Err != nil && !isNotFound(lbSecGroup.Err) {
0000000000000000000000000000000000000000;;				return lbSecGroup.Err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Delete the rules in the Node Security Group
0000000000000000000000000000000000000000;;			opts := rules.ListOpts{
0000000000000000000000000000000000000000;;				SecGroupID:    lbaas.opts.NodeSecurityGroupID,
0000000000000000000000000000000000000000;;				RemoteGroupID: lbSecGroupID,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secGroupRules, err := getSecurityGroupRules(lbaas.network, opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("Error finding rules for remote group id %s in security group id %s", lbSecGroupID, lbaas.opts.NodeSecurityGroupID)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, rule := range secGroupRules {
0000000000000000000000000000000000000000;;				res := rules.Delete(lbaas.network, rule.ID)
0000000000000000000000000000000000000000;;				if res.Err != nil && !isNotFound(res.Err) {
0000000000000000000000000000000000000000;;					glog.V(1).Infof("Error occurred deleting security group rule: %s: %v", rule.ID, res.Err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LbaasV1) GetLoadBalancer(clusterName string, service *v1.Service) (*v1.LoadBalancerStatus, bool, error) {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		vip, err := getVipByName(lb.network, loadBalancerName)
0000000000000000000000000000000000000000;;		if err == ErrNotFound {
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vip == nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;		status.Ingress = []v1.LoadBalancerIngress{{IP: vip.Address}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This code currently ignores 'region' and always creates a
0000000000000000000000000000000000000000;;	// loadbalancer in only the current OpenStack region.  We should take
0000000000000000000000000000000000000000;;	// a list of regions (from config) and query/create loadbalancers in
0000000000000000000000000000000000000000;;	// each region.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LbaasV1) EnsureLoadBalancer(clusterName string, apiService *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v, %v, %v)", clusterName, apiService.Namespace, apiService.Name, apiService.Spec.LoadBalancerIP, apiService.Spec.Ports, nodes, apiService.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ports := apiService.Spec.Ports
0000000000000000000000000000000000000000;;		if len(ports) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple ports are not supported in openstack v1 load balancers")
0000000000000000000000000000000000000000;;		} else if len(ports) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no ports provided to openstack load balancer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The service controller verified all the protocols match on the ports, just check and use the first one
0000000000000000000000000000000000000000;;		// TODO: Convert all error messages to use an event recorder
0000000000000000000000000000000000000000;;		if ports[0].Protocol != v1.ProtocolTCP {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Only TCP LoadBalancer is supported for openstack load balancers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		affinity := apiService.Spec.SessionAffinity
0000000000000000000000000000000000000000;;		var persistence *vips.SessionPersistence
0000000000000000000000000000000000000000;;		switch affinity {
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityNone:
0000000000000000000000000000000000000000;;			persistence = nil
0000000000000000000000000000000000000000;;		case v1.ServiceAffinityClientIP:
0000000000000000000000000000000000000000;;			persistence = &vips.SessionPersistence{Type: "SOURCE_IP"}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported load balancer affinity: %v", affinity)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sourceRanges, err := service.GetLoadBalancerSourceRanges(apiService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !service.IsAllowAll(sourceRanges) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Source range restrictions are not supported for openstack load balancers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Checking if openstack load balancer already exists: %s", cloudprovider.GetLoadBalancerName(apiService))
0000000000000000000000000000000000000000;;		_, exists, err := lb.GetLoadBalancer(clusterName, apiService)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error checking if openstack load balancer already exists: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Implement a more efficient update strategy for common changes than delete & create
0000000000000000000000000000000000000000;;		// In particular, if we implement hosts update, we can get rid of UpdateHosts
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			err := lb.EnsureLoadBalancerDeleted(clusterName, apiService)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error deleting existing openstack load balancer: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lbmethod := pools.LBMethod(lb.opts.LBMethod)
0000000000000000000000000000000000000000;;		if lbmethod == "" {
0000000000000000000000000000000000000000;;			lbmethod = pools.LBMethodRoundRobin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := cloudprovider.GetLoadBalancerName(apiService)
0000000000000000000000000000000000000000;;		pool, err := pools.Create(lb.network, pools.CreateOpts{
0000000000000000000000000000000000000000;;			Name:     name,
0000000000000000000000000000000000000000;;			Protocol: pools.ProtocolTCP,
0000000000000000000000000000000000000000;;			SubnetID: lb.opts.SubnetId,
0000000000000000000000000000000000000000;;			LBMethod: lbmethod,
0000000000000000000000000000000000000000;;		}).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			addr, err := nodeAddressForLB(node)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = members.Create(lb.network, members.CreateOpts{
0000000000000000000000000000000000000000;;				PoolID:       pool.ID,
0000000000000000000000000000000000000000;;				ProtocolPort: int(ports[0].NodePort), //Note: only handles single port
0000000000000000000000000000000000000000;;				Address:      addr,
0000000000000000000000000000000000000000;;			}).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				pools.Delete(lb.network, pool.ID)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var mon *monitors.Monitor
0000000000000000000000000000000000000000;;		if lb.opts.CreateMonitor {
0000000000000000000000000000000000000000;;			mon, err = monitors.Create(lb.network, monitors.CreateOpts{
0000000000000000000000000000000000000000;;				Type:       monitors.TypeTCP,
0000000000000000000000000000000000000000;;				Delay:      int(lb.opts.MonitorDelay.Duration.Seconds()),
0000000000000000000000000000000000000000;;				Timeout:    int(lb.opts.MonitorTimeout.Duration.Seconds()),
0000000000000000000000000000000000000000;;				MaxRetries: int(lb.opts.MonitorMaxRetries),
0000000000000000000000000000000000000000;;			}).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				pools.Delete(lb.network, pool.ID)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = pools.AssociateMonitor(lb.network, pool.ID, mon.ID).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				monitors.Delete(lb.network, mon.ID)
0000000000000000000000000000000000000000;;				pools.Delete(lb.network, pool.ID)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createOpts := vips.CreateOpts{
0000000000000000000000000000000000000000;;			Name:         name,
0000000000000000000000000000000000000000;;			Description:  fmt.Sprintf("Kubernetes external service %s", name),
0000000000000000000000000000000000000000;;			Protocol:     "TCP",
0000000000000000000000000000000000000000;;			ProtocolPort: int(ports[0].Port), //TODO: need to handle multi-port
0000000000000000000000000000000000000000;;			PoolID:       pool.ID,
0000000000000000000000000000000000000000;;			SubnetID:     lb.opts.SubnetId,
0000000000000000000000000000000000000000;;			Persistence:  persistence,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loadBalancerIP := apiService.Spec.LoadBalancerIP
0000000000000000000000000000000000000000;;		if loadBalancerIP != "" {
0000000000000000000000000000000000000000;;			createOpts.Address = loadBalancerIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vip, err := vips.Create(lb.network, createOpts).Extract()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if mon != nil {
0000000000000000000000000000000000000000;;				monitors.Delete(lb.network, mon.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pools.Delete(lb.network, pool.ID)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := &v1.LoadBalancerStatus{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status.Ingress = []v1.LoadBalancerIngress{{IP: vip.Address}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb.opts.FloatingNetworkId != "" {
0000000000000000000000000000000000000000;;			floatIPOpts := floatingips.CreateOpts{
0000000000000000000000000000000000000000;;				FloatingNetworkID: lb.opts.FloatingNetworkId,
0000000000000000000000000000000000000000;;				PortID:            vip.PortID,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			floatIP, err := floatingips.Create(lb.network, floatIPOpts).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status.Ingress = append(status.Ingress, v1.LoadBalancerIngress{IP: floatIP.FloatingIP})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LbaasV1) UpdateLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("UpdateLoadBalancer(%v, %v, %v)", clusterName, loadBalancerName, nodes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vip, err := getVipByName(lb.network, loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set of member (addresses) that _should_ exist
0000000000000000000000000000000000000000;;		addrs := map[string]bool{}
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			addr, err := nodeAddressForLB(node)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			addrs[addr] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Iterate over members that _do_ exist
0000000000000000000000000000000000000000;;		pager := members.List(lb.network, members.ListOpts{PoolID: vip.PoolID})
0000000000000000000000000000000000000000;;		err = pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			memList, err := members.ExtractMembers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, member := range memList {
0000000000000000000000000000000000000000;;				if _, found := addrs[member.Address]; found {
0000000000000000000000000000000000000000;;					// Member already exists
0000000000000000000000000000000000000000;;					delete(addrs, member.Address)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Member needs to be deleted
0000000000000000000000000000000000000000;;					err = members.Delete(lb.network, member.ID).ExtractErr()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Anything left in addrs is a new member that needs to be added
0000000000000000000000000000000000000000;;		for addr := range addrs {
0000000000000000000000000000000000000000;;			_, err := members.Create(lb.network, members.CreateOpts{
0000000000000000000000000000000000000000;;				PoolID:       vip.PoolID,
0000000000000000000000000000000000000000;;				Address:      addr,
0000000000000000000000000000000000000000;;				ProtocolPort: vip.ProtocolPort,
0000000000000000000000000000000000000000;;			}).Extract()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lb *LbaasV1) EnsureLoadBalancerDeleted(clusterName string, service *v1.Service) error {
0000000000000000000000000000000000000000;;		loadBalancerName := cloudprovider.GetLoadBalancerName(service)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("EnsureLoadBalancerDeleted(%v, %v)", clusterName, loadBalancerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vip, err := getVipByName(lb.network, loadBalancerName)
0000000000000000000000000000000000000000;;		if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lb.opts.FloatingNetworkId != "" && vip != nil {
0000000000000000000000000000000000000000;;			floatingIP, err := getFloatingIPByPortID(lb.network, vip.PortID)
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if floatingIP != nil {
0000000000000000000000000000000000000000;;				err = floatingips.Delete(lb.network, floatingIP.ID).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have to delete the VIP before the pool can be deleted,
0000000000000000000000000000000000000000;;		// so no point continuing if this fails.
0000000000000000000000000000000000000000;;		if vip != nil {
0000000000000000000000000000000000000000;;			err := vips.Delete(lb.network, vip.ID).ExtractErr()
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pool *pools.Pool
0000000000000000000000000000000000000000;;		if vip != nil {
0000000000000000000000000000000000000000;;			pool, err = pools.Get(lb.network, vip.PoolID).Extract()
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The VIP is gone, but it is conceivable that a Pool
0000000000000000000000000000000000000000;;			// still exists that we failed to delete on some
0000000000000000000000000000000000000000;;			// previous occasion.  Make a best effort attempt to
0000000000000000000000000000000000000000;;			// cleanup any pools with the same name as the VIP.
0000000000000000000000000000000000000000;;			pool, err = getPoolByName(lb.network, service.Name)
0000000000000000000000000000000000000000;;			if err != nil && err != ErrNotFound {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pool != nil {
0000000000000000000000000000000000000000;;			for _, monId := range pool.MonitorIDs {
0000000000000000000000000000000000000000;;				_, err = pools.DisassociateMonitor(lb.network, pool.ID, monId).Extract()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = monitors.Delete(lb.network, monId).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, memberId := range pool.MemberIDs {
0000000000000000000000000000000000000000;;				err = members.Delete(lb.network, memberId).ExtractErr()
0000000000000000000000000000000000000000;;				if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = pools.Delete(lb.network, pool.ID).ExtractErr()
0000000000000000000000000000000000000000;;			if err != nil && !isNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
