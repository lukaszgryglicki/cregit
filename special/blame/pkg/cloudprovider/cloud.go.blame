0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d31dcf734feb05aa86260bc1f1d21098af4f0b6e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cloudprovider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface is an abstract, pluggable interface for cloud providers.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// Initialize provides the cloud with a kubernetes client builder and may spawn goroutines
0000000000000000000000000000000000000000;;		// to perform housekeeping activities within the cloud provider.
0000000000000000000000000000000000000000;;		Initialize(clientBuilder controller.ControllerClientBuilder)
0000000000000000000000000000000000000000;;		// LoadBalancer returns a balancer interface. Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;		LoadBalancer() (LoadBalancer, bool)
0000000000000000000000000000000000000000;;		// Instances returns an instances interface. Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;		Instances() (Instances, bool)
0000000000000000000000000000000000000000;;		// Zones returns a zones interface. Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;		Zones() (Zones, bool)
0000000000000000000000000000000000000000;;		// Clusters returns a clusters interface.  Also returns true if the interface is supported, false otherwise.
0000000000000000000000000000000000000000;;		Clusters() (Clusters, bool)
0000000000000000000000000000000000000000;;		// Routes returns a routes interface along with whether the interface is supported.
0000000000000000000000000000000000000000;;		Routes() (Routes, bool)
0000000000000000000000000000000000000000;;		// ProviderName returns the cloud provider ID.
0000000000000000000000000000000000000000;;		ProviderName() string
0000000000000000000000000000000000000000;;		// ScrubDNS provides an opportunity for cloud-provider-specific code to process DNS settings for pods.
0000000000000000000000000000000000000000;;		ScrubDNS(nameservers, searches []string) (nsOut, srchOut []string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clusters is an abstract, pluggable interface for clusters of containers.
0000000000000000000000000000000000000000;;	type Clusters interface {
0000000000000000000000000000000000000000;;		// ListClusters lists the names of the available clusters.
0000000000000000000000000000000000000000;;		ListClusters() ([]string, error)
0000000000000000000000000000000000000000;;		// Master gets back the address (either DNS name or IP address) of the master node for the cluster.
0000000000000000000000000000000000000000;;		Master(clusterName string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(#6812): Use a shorter name that's less likely to be longer than cloud
0000000000000000000000000000000000000000;;	// providers' name length limits.
0000000000000000000000000000000000000000;;	func GetLoadBalancerName(service *v1.Service) string {
0000000000000000000000000000000000000000;;		//GCE requires that the name of a load balancer starts with a lower case letter.
0000000000000000000000000000000000000000;;		ret := "a" + string(service.UID)
0000000000000000000000000000000000000000;;		ret = strings.Replace(ret, "-", "", -1)
0000000000000000000000000000000000000000;;		//AWS requires that the name of a load balancer is shorter than 32 bytes.
0000000000000000000000000000000000000000;;		if len(ret) > 32 {
0000000000000000000000000000000000000000;;			ret = ret[:32]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetInstanceProviderID builds a ProviderID for a node in a cloud.
0000000000000000000000000000000000000000;;	func GetInstanceProviderID(cloud Interface, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		instances, ok := cloud.Instances()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get instances from cloud provider")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instanceID, err := instances.InstanceID(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get instance ID from cloud provider: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cloud.ProviderName() + "://" + instanceID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancer is an abstract, pluggable interface for load balancers.
0000000000000000000000000000000000000000;;	type LoadBalancer interface {
0000000000000000000000000000000000000000;;		// TODO: Break this up into different interfaces (LB, etc) when we have more than one type of service
0000000000000000000000000000000000000000;;		// GetLoadBalancer returns whether the specified load balancer exists, and
0000000000000000000000000000000000000000;;		// if so, what its status is.
0000000000000000000000000000000000000000;;		// Implementations must treat the *v1.Service parameter as read-only and not modify it.
0000000000000000000000000000000000000000;;		// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
0000000000000000000000000000000000000000;;		GetLoadBalancer(clusterName string, service *v1.Service) (status *v1.LoadBalancerStatus, exists bool, err error)
0000000000000000000000000000000000000000;;		// EnsureLoadBalancer creates a new load balancer 'name', or updates the existing one. Returns the status of the balancer
0000000000000000000000000000000000000000;;		// Implementations must treat the *v1.Service and *v1.Node
0000000000000000000000000000000000000000;;		// parameters as read-only and not modify them.
0000000000000000000000000000000000000000;;		// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
0000000000000000000000000000000000000000;;		EnsureLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error)
0000000000000000000000000000000000000000;;		// UpdateLoadBalancer updates hosts under the specified load balancer.
0000000000000000000000000000000000000000;;		// Implementations must treat the *v1.Service and *v1.Node
0000000000000000000000000000000000000000;;		// parameters as read-only and not modify them.
0000000000000000000000000000000000000000;;		// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
0000000000000000000000000000000000000000;;		UpdateLoadBalancer(clusterName string, service *v1.Service, nodes []*v1.Node) error
0000000000000000000000000000000000000000;;		// EnsureLoadBalancerDeleted deletes the specified load balancer if it
0000000000000000000000000000000000000000;;		// exists, returning nil if the load balancer specified either didn't exist or
0000000000000000000000000000000000000000;;		// was successfully deleted.
0000000000000000000000000000000000000000;;		// This construction is useful because many cloud providers' load balancers
0000000000000000000000000000000000000000;;		// have multiple underlying components, meaning a Get could say that the LB
0000000000000000000000000000000000000000;;		// doesn't exist even if some part of it is still laying around.
0000000000000000000000000000000000000000;;		// Implementations must treat the *v1.Service parameter as read-only and not modify it.
0000000000000000000000000000000000000000;;		// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
0000000000000000000000000000000000000000;;		EnsureLoadBalancerDeleted(clusterName string, service *v1.Service) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instances is an abstract, pluggable interface for sets of instances.
0000000000000000000000000000000000000000;;	type Instances interface {
0000000000000000000000000000000000000000;;		// NodeAddresses returns the addresses of the specified instance.
0000000000000000000000000000000000000000;;		// TODO(roberthbailey): This currently is only used in such a way that it
0000000000000000000000000000000000000000;;		// returns the address of the calling instance. We should do a rename to
0000000000000000000000000000000000000000;;		// make this clearer.
0000000000000000000000000000000000000000;;		NodeAddresses(name types.NodeName) ([]v1.NodeAddress, error)
0000000000000000000000000000000000000000;;		// NodeAddressesByProviderID returns the addresses of the specified instance.
0000000000000000000000000000000000000000;;		// The instance is specified using the providerID of the node. The
0000000000000000000000000000000000000000;;		// ProviderID is a unique identifier of the node. This will not be called
0000000000000000000000000000000000000000;;		// from the node whose nodeaddresses are being queried. i.e. local metadata
0000000000000000000000000000000000000000;;		// services cannot be used in this method to obtain nodeaddresses
0000000000000000000000000000000000000000;;		NodeAddressesByProviderID(providerId string) ([]v1.NodeAddress, error)
0000000000000000000000000000000000000000;;		// ExternalID returns the cloud provider ID of the node with the specified NodeName.
0000000000000000000000000000000000000000;;		// Note that if the instance does not exist or is no longer running, we must return ("", cloudprovider.InstanceNotFound)
0000000000000000000000000000000000000000;;		ExternalID(nodeName types.NodeName) (string, error)
0000000000000000000000000000000000000000;;		// InstanceID returns the cloud provider ID of the node with the specified NodeName.
0000000000000000000000000000000000000000;;		InstanceID(nodeName types.NodeName) (string, error)
0000000000000000000000000000000000000000;;		// InstanceType returns the type of the specified instance.
0000000000000000000000000000000000000000;;		InstanceType(name types.NodeName) (string, error)
0000000000000000000000000000000000000000;;		// InstanceTypeByProviderID returns the type of the specified instance.
0000000000000000000000000000000000000000;;		InstanceTypeByProviderID(providerID string) (string, error)
0000000000000000000000000000000000000000;;		// AddSSHKeyToAllInstances adds an SSH public key as a legal identity for all instances
0000000000000000000000000000000000000000;;		// expected format for the key is standard ssh-keygen format: <protocol> <blob>
0000000000000000000000000000000000000000;;		AddSSHKeyToAllInstances(user string, keyData []byte) error
0000000000000000000000000000000000000000;;		// CurrentNodeName returns the name of the node we are currently running on
0000000000000000000000000000000000000000;;		// On most clouds (e.g. GCE) this is the hostname, so we provide the hostname
0000000000000000000000000000000000000000;;		CurrentNodeName(hostname string) (types.NodeName, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Route is a representation of an advanced routing rule.
0000000000000000000000000000000000000000;;	type Route struct {
0000000000000000000000000000000000000000;;		// Name is the name of the routing rule in the cloud-provider.
0000000000000000000000000000000000000000;;		// It will be ignored in a Create (although nameHint may influence it)
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// TargetNode is the NodeName of the target instance.
0000000000000000000000000000000000000000;;		TargetNode types.NodeName
0000000000000000000000000000000000000000;;		// DestinationCIDR is the CIDR format IP range that this routing rule
0000000000000000000000000000000000000000;;		// applies to.
0000000000000000000000000000000000000000;;		DestinationCIDR string
0000000000000000000000000000000000000000;;		// Blackhole is set to true if this is a blackhole route
0000000000000000000000000000000000000000;;		// The node controller will delete the route if it is in the managed range.
0000000000000000000000000000000000000000;;		Blackhole bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Routes is an abstract, pluggable interface for advanced routing rules.
0000000000000000000000000000000000000000;;	type Routes interface {
0000000000000000000000000000000000000000;;		// ListRoutes lists all managed routes that belong to the specified clusterName
0000000000000000000000000000000000000000;;		ListRoutes(clusterName string) ([]*Route, error)
0000000000000000000000000000000000000000;;		// CreateRoute creates the described managed route
0000000000000000000000000000000000000000;;		// route.Name will be ignored, although the cloud-provider may use nameHint
0000000000000000000000000000000000000000;;		// to create a more user-meaningful name.
0000000000000000000000000000000000000000;;		CreateRoute(clusterName string, nameHint string, route *Route) error
0000000000000000000000000000000000000000;;		// DeleteRoute deletes the specified managed route
0000000000000000000000000000000000000000;;		// Route should be as returned by ListRoutes
0000000000000000000000000000000000000000;;		DeleteRoute(clusterName string, route *Route) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		InstanceNotFound = errors.New("instance not found")
0000000000000000000000000000000000000000;;		DiskNotFound     = errors.New("disk is not found")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zone represents the location of a particular machine.
0000000000000000000000000000000000000000;;	type Zone struct {
0000000000000000000000000000000000000000;;		FailureDomain string
0000000000000000000000000000000000000000;;		Region        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zones is an abstract, pluggable interface for zone enumeration.
0000000000000000000000000000000000000000;;	type Zones interface {
0000000000000000000000000000000000000000;;		// GetZone returns the Zone containing the current failure zone and locality region that the program is running in
0000000000000000000000000000000000000000;;		GetZone() (Zone, error)
0000000000000000000000000000000000000000;;	}
