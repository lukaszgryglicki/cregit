0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/empty_dir/empty_dir.go[pkg/kubelet/volume/empty_dir/empty_dir.go][pkg/volume/empty_dir/empty_dir.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package empty_dir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: in the near future, this will be changed to be more restrictive
0000000000000000000000000000000000000000;;	// and the group will be set to allow containers to use emptyDir volumes
0000000000000000000000000000000000000000;;	// from the group attribute.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://issue.k8s.io/2630
0000000000000000000000000000000000000000;;	const perm os.FileMode = 0777
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{
0000000000000000000000000000000000000000;;			&emptyDirPlugin{nil},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type emptyDirPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &emptyDirPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		emptyDirPluginName = "kubernetes.io/empty-dir"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPath(uid types.UID, volName string, host volume.VolumeHost) string {
0000000000000000000000000000000000000000;;		return host.GetPodVolumeDir(uid, strings.EscapeQualifiedNameForDisk(emptyDirPluginName), volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return emptyDirPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _ := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if volumeSource == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Spec does not reference an EmptyDir volume type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return user defined volume name, since this is an ephemeral volume type
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.EmptyDir != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod, plugin.host.GetMounter(), &realMountDetector{plugin.host.GetMounter()}, opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) newMounterInternal(spec *volume.Spec, pod *v1.Pod, mounter mount.Interface, mountDetector mountDetector, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		medium := v1.StorageMediumDefault
0000000000000000000000000000000000000000;;		if spec.Volume.EmptyDir != nil { // Support a non-specified source as EmptyDir.
0000000000000000000000000000000000000000;;			medium = spec.Volume.EmptyDir.Medium
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &emptyDir{
0000000000000000000000000000000000000000;;			pod:             pod,
0000000000000000000000000000000000000000;;			volName:         spec.Name(),
0000000000000000000000000000000000000000;;			medium:          medium,
0000000000000000000000000000000000000000;;			mounter:         mounter,
0000000000000000000000000000000000000000;;			mountDetector:   mountDetector,
0000000000000000000000000000000000000000;;			plugin:          plugin,
0000000000000000000000000000000000000000;;			MetricsProvider: volume.NewMetricsDu(getPath(pod.UID, spec.Name(), plugin.host)),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, plugin.host.GetMounter(), &realMountDetector{plugin.host.GetMounter()})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) newUnmounterInternal(volName string, podUID types.UID, mounter mount.Interface, mountDetector mountDetector) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		ed := &emptyDir{
0000000000000000000000000000000000000000;;			pod:             &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: podUID}},
0000000000000000000000000000000000000000;;			volName:         volName,
0000000000000000000000000000000000000000;;			medium:          v1.StorageMediumDefault, // might be changed later
0000000000000000000000000000000000000000;;			mounter:         mounter,
0000000000000000000000000000000000000000;;			mountDetector:   mountDetector,
0000000000000000000000000000000000000000;;			plugin:          plugin,
0000000000000000000000000000000000000000;;			MetricsProvider: volume.NewMetricsDu(getPath(podUID, volName, plugin.host)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *emptyDirPlugin) ConstructVolumeSpec(volName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		emptyDirVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				EmptyDir: &v1.EmptyDirVolumeSource{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(emptyDirVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mountDetector abstracts how to find what kind of mount a path is backed by.
0000000000000000000000000000000000000000;;	type mountDetector interface {
0000000000000000000000000000000000000000;;		// GetMountMedium determines what type of medium a given path is backed
0000000000000000000000000000000000000000;;		// by and whether that path is a mount point.  For example, if this
0000000000000000000000000000000000000000;;		// returns (mediumMemory, false, nil), the caller knows that the path is
0000000000000000000000000000000000000000;;		// on a memory FS (tmpfs on Linux) but is not the root mountpoint of
0000000000000000000000000000000000000000;;		// that tmpfs.
0000000000000000000000000000000000000000;;		GetMountMedium(path string) (storageMedium, bool, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageMedium int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		mediumUnknown storageMedium = 0 // assume anything we don't explicitly handle is this
0000000000000000000000000000000000000000;;		mediumMemory  storageMedium = 1 // memory (e.g. tmpfs on linux)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EmptyDir volumes are temporary directories exposed to the pod.
0000000000000000000000000000000000000000;;	// These do not persist beyond the lifetime of a pod.
0000000000000000000000000000000000000000;;	type emptyDir struct {
0000000000000000000000000000000000000000;;		pod           *v1.Pod
0000000000000000000000000000000000000000;;		volName       string
0000000000000000000000000000000000000000;;		medium        v1.StorageMedium
0000000000000000000000000000000000000000;;		mounter       mount.Interface
0000000000000000000000000000000000000000;;		mountDetector mountDetector
0000000000000000000000000000000000000000;;		plugin        *emptyDirPlugin
0000000000000000000000000000000000000000;;		volume.MetricsProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ed *emptyDir) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        false,
0000000000000000000000000000000000000000;;			Managed:         true,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *emptyDir) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp creates new directory.
0000000000000000000000000000000000000000;;	func (ed *emptyDir) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return ed.SetUpAt(ed.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt creates new directory.
0000000000000000000000000000000000000000;;	func (ed *emptyDir) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		notMnt, err := ed.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		// Getting an os.IsNotExist err from is a contingency; the directory
0000000000000000000000000000000000000000;;		// may not exist yet, in which case, setup should run.
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the plugin readiness file is present for this volume, and the
0000000000000000000000000000000000000000;;		// storage medium is the default, then the volume is ready.  If the
0000000000000000000000000000000000000000;;		// medium is memory, and a mountpoint is present, then the volume is
0000000000000000000000000000000000000000;;		// ready.
0000000000000000000000000000000000000000;;		if volumeutil.IsReady(ed.getMetaDir()) {
0000000000000000000000000000000000000000;;			if ed.medium == v1.StorageMediumMemory && !notMnt {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if ed.medium == v1.StorageMediumDefault {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch ed.medium {
0000000000000000000000000000000000000000;;		case v1.StorageMediumDefault:
0000000000000000000000000000000000000000;;			err = ed.setupDir(dir)
0000000000000000000000000000000000000000;;		case v1.StorageMediumMemory:
0000000000000000000000000000000000000000;;			err = ed.setupTmpfs(dir)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("unknown storage medium %q", ed.medium)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume.SetVolumeOwnership(ed, fsGroup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			volumeutil.SetReady(ed.getMetaDir())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setupTmpfs creates a tmpfs mount at the specified directory with the
0000000000000000000000000000000000000000;;	// specified SELinux context.
0000000000000000000000000000000000000000;;	func (ed *emptyDir) setupTmpfs(dir string) error {
0000000000000000000000000000000000000000;;		if ed.mounter == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("memory storage requested, but mounter is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ed.setupDir(dir); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make SetUp idempotent.
0000000000000000000000000000000000000000;;		medium, isMnt, err := ed.mountDetector.GetMountMedium(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the directory is a mountpoint with medium memory, there is no
0000000000000000000000000000000000000000;;		// work to do since we are already in the desired state.
0000000000000000000000000000000000000000;;		if isMnt && medium == mediumMemory {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("pod %v: mounting tmpfs for volume %v", ed.pod.UID, ed.volName)
0000000000000000000000000000000000000000;;		return ed.mounter.Mount("tmpfs", dir, "tmpfs", nil /* options */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setupDir creates the directory with the specified SELinux context and
0000000000000000000000000000000000000000;;	// the default permissions specified by the perm constant.
0000000000000000000000000000000000000000;;	func (ed *emptyDir) setupDir(dir string) error {
0000000000000000000000000000000000000000;;		// Create the directory if it doesn't already exist.
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, perm); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stat the directory to read permission bits
0000000000000000000000000000000000000000;;		fileinfo, err := os.Lstat(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fileinfo.Mode().Perm() != perm.Perm() {
0000000000000000000000000000000000000000;;			// If the permissions on the created directory are wrong, the
0000000000000000000000000000000000000000;;			// kubelet is probably running with a umask set.  In order to
0000000000000000000000000000000000000000;;			// avoid clearing the umask for the entire process or locking
0000000000000000000000000000000000000000;;			// the thread, clearing the umask, creating the dir, restoring
0000000000000000000000000000000000000000;;			// the umask, and unlocking the thread, we do a chmod to set
0000000000000000000000000000000000000000;;			// the specific bits we need.
0000000000000000000000000000000000000000;;			err := os.Chmod(dir, perm)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fileinfo, err = os.Lstat(dir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fileinfo.Mode().Perm() != perm.Perm() {
0000000000000000000000000000000000000000;;				glog.Errorf("Expected directory %q permissions to be: %s; got: %s", dir, perm.Perm(), fileinfo.Mode().Perm())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ed *emptyDir) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(ed.pod.UID, ed.volName, ed.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDown simply discards everything in the directory.
0000000000000000000000000000000000000000;;	func (ed *emptyDir) TearDown() error {
0000000000000000000000000000000000000000;;		return ed.TearDownAt(ed.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDownAt simply discards everything in the directory.
0000000000000000000000000000000000000000;;	func (ed *emptyDir) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		if pathExists, pathErr := volumeutil.PathExists(dir); pathErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error checking if path exists: %v", pathErr)
0000000000000000000000000000000000000000;;		} else if !pathExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: Unmount skipped because path does not exist: %v", dir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Figure out the medium.
0000000000000000000000000000000000000000;;		medium, isMnt, err := ed.mountDetector.GetMountMedium(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isMnt && medium == mediumMemory {
0000000000000000000000000000000000000000;;			ed.medium = v1.StorageMediumMemory
0000000000000000000000000000000000000000;;			return ed.teardownTmpfs(dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// assume StorageMediumDefault
0000000000000000000000000000000000000000;;		return ed.teardownDefault(dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ed *emptyDir) teardownDefault(dir string) error {
0000000000000000000000000000000000000000;;		// Renaming the directory is not required anymore because the operation executor
0000000000000000000000000000000000000000;;		// now handles duplicate operations on the same volume
0000000000000000000000000000000000000000;;		err := os.RemoveAll(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ed *emptyDir) teardownTmpfs(dir string) error {
0000000000000000000000000000000000000000;;		if ed.mounter == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("memory storage requested, but mounter is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ed.mounter.Unmount(dir); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.RemoveAll(dir); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ed *emptyDir) getMetaDir() string {
0000000000000000000000000000000000000000;;		return path.Join(ed.plugin.host.GetPodPluginDir(ed.pod.UID, strings.EscapeQualifiedNameForDisk(emptyDirPluginName)), ed.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.EmptyDirVolumeSource, bool) {
0000000000000000000000000000000000000000;;		var readOnly bool
0000000000000000000000000000000000000000;;		var volumeSource *v1.EmptyDirVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.EmptyDir != nil {
0000000000000000000000000000000000000000;;			volumeSource = spec.Volume.EmptyDir
0000000000000000000000000000000000000000;;			readOnly = spec.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource, readOnly
0000000000000000000000000000000000000000;;	}
