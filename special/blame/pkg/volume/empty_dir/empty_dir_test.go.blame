0000000000000000000000000000000000000000;;	// +build linux
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/empty_dir/empty_dir_test.go[pkg/kubelet/volume/empty_dir/empty_dir_test.go][pkg/volume/empty_dir/empty_dir_test.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package empty_dir
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Construct an instance of a plugin, by name.
0000000000000000000000000000000000000000;;	func makePluginUnderTest(t *testing.T, plugName, basePath string) volume.VolumePlugin {
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(basePath, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName(plugName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plug
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("emptydirTest")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("can't make a temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		plug := makePluginUnderTest(t, "kubernetes.io/empty-dir", tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if plug.GetPluginName() != "kubernetes.io/empty-dir" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plug.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeMountDetector struct {
0000000000000000000000000000000000000000;;		medium  storageMedium
0000000000000000000000000000000000000000;;		isMount bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeMountDetector) GetMountMedium(path string) (storageMedium, bool, error) {
0000000000000000000000000000000000000000;;		return fake.medium, fake.isMount, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginEmptyRootContext(t *testing.T) {
0000000000000000000000000000000000000000;;		doTestPlugin(t, pluginTestConfig{
0000000000000000000000000000000000000000;;			medium:                 v1.StorageMediumDefault,
0000000000000000000000000000000000000000;;			expectedSetupMounts:    0,
0000000000000000000000000000000000000000;;			expectedTeardownMounts: 0})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pluginTestConfig struct {
0000000000000000000000000000000000000000;;		medium                        v1.StorageMedium
0000000000000000000000000000000000000000;;		idempotent                    bool
0000000000000000000000000000000000000000;;		expectedSetupMounts           int
0000000000000000000000000000000000000000;;		shouldBeMountedBeforeTeardown bool
0000000000000000000000000000000000000000;;		expectedTeardownMounts        int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doTestPlugin sets up a volume and tears it back down.
0000000000000000000000000000000000000000;;	func doTestPlugin(t *testing.T, config pluginTestConfig) {
0000000000000000000000000000000000000000;;		basePath, err := utiltesting.MkTmpdir("emptydir_volume_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("can't make a temp rootdir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(basePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			volumePath  = path.Join(basePath, "pods/poduid/volumes/kubernetes.io~empty-dir/test-volume")
0000000000000000000000000000000000000000;;			metadataDir = path.Join(basePath, "pods/poduid/plugins/kubernetes.io~empty-dir/test-volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			plug       = makePluginUnderTest(t, "kubernetes.io/empty-dir", basePath)
0000000000000000000000000000000000000000;;			volumeName = "test-volume"
0000000000000000000000000000000000000000;;			spec       = &v1.Volume{
0000000000000000000000000000000000000000;;				Name:         volumeName,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{Medium: config.medium}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			physicalMounter = mount.FakeMounter{}
0000000000000000000000000000000000000000;;			mountDetector   = fakeMountDetector{}
0000000000000000000000000000000000000000;;			pod             = &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.idempotent {
0000000000000000000000000000000000000000;;			physicalMounter.MountPoints = []mount.MountPoint{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Path: volumePath,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			util.SetReady(metadataDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounter, err := plug.(*emptyDirPlugin).newMounterInternal(volume.NewSpecFromVolume(spec),
0000000000000000000000000000000000000000;;			pod,
0000000000000000000000000000000000000000;;			&physicalMounter,
0000000000000000000000000000000000000000;;			&mountDetector,
0000000000000000000000000000000000000000;;			volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volPath := mounter.GetPath()
0000000000000000000000000000000000000000;;		if volPath != volumePath {
0000000000000000000000000000000000000000;;			t.Errorf("Got unexpected path: %s", volPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := mounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stat the directory and check the permission bits
0000000000000000000000000000000000000000;;		fileinfo, err := os.Stat(volPath)
0000000000000000000000000000000000000000;;		if !config.idempotent {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					t.Errorf("SetUp() failed, volume path not created: %s", volPath)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := perm, fileinfo.Mode().Perm(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected file mode for %v: expected: %v, got: %v", volPath, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if err == nil {
0000000000000000000000000000000000000000;;			// If this test is for idempotency and we were able
0000000000000000000000000000000000000000;;			// to stat the volume path, it's an error.
0000000000000000000000000000000000000000;;			t.Errorf("Volume directory was created unexpectedly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the number of mounts performed during setup
0000000000000000000000000000000000000000;;		if e, a := config.expectedSetupMounts, len(physicalMounter.Log); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v physicalMounter calls during setup, got %v", e, a)
0000000000000000000000000000000000000000;;		} else if config.expectedSetupMounts == 1 &&
0000000000000000000000000000000000000000;;			(physicalMounter.Log[0].Action != mount.FakeActionMount || physicalMounter.Log[0].FSType != "tmpfs") {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected physicalMounter action during setup: %#v", physicalMounter.Log[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		physicalMounter.ResetLog()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make an unmounter for the volume
0000000000000000000000000000000000000000;;		teardownMedium := mediumUnknown
0000000000000000000000000000000000000000;;		if config.medium == v1.StorageMediumMemory {
0000000000000000000000000000000000000000;;			teardownMedium = mediumMemory
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unmounterMountDetector := &fakeMountDetector{medium: teardownMedium, isMount: config.shouldBeMountedBeforeTeardown}
0000000000000000000000000000000000000000;;		unmounter, err := plug.(*emptyDirPlugin).newUnmounterInternal(volumeName, types.UID("poduid"), &physicalMounter, unmounterMountDetector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unmounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Unmounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tear down the volume
0000000000000000000000000000000000000000;;		if err := unmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(volPath); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("TearDown() failed, volume path still exists: %s", volPath)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the number of physicalMounter calls during tardown
0000000000000000000000000000000000000000;;		if e, a := config.expectedTeardownMounts, len(physicalMounter.Log); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v physicalMounter calls during teardown, got %v", e, a)
0000000000000000000000000000000000000000;;		} else if config.expectedTeardownMounts == 1 && physicalMounter.Log[0].Action != mount.FakeActionUnmount {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected physicalMounter action during teardown: %#v", physicalMounter.Log[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		physicalMounter.ResetLog()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginBackCompat(t *testing.T) {
0000000000000000000000000000000000000000;;		basePath, err := utiltesting.MkTmpdir("emptydirTest")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("can't make a temp dir： %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(basePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug := makePluginUnderTest(t, "kubernetes.io/empty-dir", basePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: "vol1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, err := plug.NewMounter(volume.NewSpecFromVolume(spec), pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volPath := mounter.GetPath()
0000000000000000000000000000000000000000;;		if volPath != path.Join(basePath, "pods/poduid/volumes/kubernetes.io~empty-dir/vol1") {
0000000000000000000000000000000000000000;;			t.Errorf("Got unexpected path: %s", volPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestMetrics tests that MetricProvider methods return sane values.
0000000000000000000000000000000000000000;;	func TestMetrics(t *testing.T) {
0000000000000000000000000000000000000000;;		// Create an empty temp directory for the volume
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("empty_dir_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Can't make a tmp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug := makePluginUnderTest(t, "kubernetes.io/empty-dir", tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: "vol1",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, err := plug.NewMounter(volume.NewSpecFromVolume(spec), pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Need to create the subdirectory
0000000000000000000000000000000000000000;;		os.MkdirAll(mounter.GetPath(), 0755)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedEmptyDirUsage, err := volumetest.FindEmptyDirectoryUsageOnTmpfs()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error finding expected empty directory usage on tmpfs: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(pwittroc): Move this into a reusable testing utility
0000000000000000000000000000000000000000;;		metrics, err := mounter.GetMetrics()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when calling GetMetrics %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := expectedEmptyDirUsage.Value(), metrics.Used.Value(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected value for empty directory; expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if metrics.Capacity.Value() <= 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected Capacity to be greater than 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if metrics.Available.Value() <= 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected Available to be greater than 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
