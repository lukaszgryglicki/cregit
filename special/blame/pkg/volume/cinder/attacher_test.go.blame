0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0ee15bdf8f86e7c5e9417f5ba4abe86873076e9f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cinder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		VolumeStatusPending = "pending"
0000000000000000000000000000000000000000;;		VolumeStatusDone    = "done"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var attachStatus = "Attach"
0000000000000000000000000000000000000000;;	var detachStatus = "Detach"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceName_Volume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		name := "my-cinder-volume"
0000000000000000000000000000000000000000;;		spec := createVolSpec(name, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deviceName != name {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: expected %s, got %s", name, deviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceName_PersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		name := "my-cinder-pv"
0000000000000000000000000000000000000000;;		spec := createPVSpec(name, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deviceName != name {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: expected %s, got %s", name, deviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceMountPath(t *testing.T) {
0000000000000000000000000000000000000000;;		name := "cinder-volume-id"
0000000000000000000000000000000000000000;;		spec := createVolSpec(name, false)
0000000000000000000000000000000000000000;;		rootDir := "/var/lib/kubelet/"
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost(rootDir, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attacher := &cinderDiskAttacher{
0000000000000000000000000000000000000000;;			host: host,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//test the path
0000000000000000000000000000000000000000;;		path, err := attacher.GetDeviceMountPath(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Get device mount path error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedPath := rootDir + "plugins/kubernetes.io/cinder/mounts/" + name
0000000000000000000000000000000000000000;;		if path != expectedPath {
0000000000000000000000000000000000000000;;			t.Errorf("Device mount path error: expected %s, got %s ", expectedPath, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// One testcase for TestAttachDetach table test below
0000000000000000000000000000000000000000;;	type testcase struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// For fake GCE:
0000000000000000000000000000000000000000;;		attach           attachCall
0000000000000000000000000000000000000000;;		detach           detachCall
0000000000000000000000000000000000000000;;		operationPending operationPendingCall
0000000000000000000000000000000000000000;;		diskIsAttached   diskIsAttachedCall
0000000000000000000000000000000000000000;;		disksAreAttached disksAreAttachedCall
0000000000000000000000000000000000000000;;		diskPath         diskPathCall
0000000000000000000000000000000000000000;;		t                *testing.T
0000000000000000000000000000000000000000;;		attachOrDetach   *string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instanceID string
0000000000000000000000000000000000000000;;		// Actual test to run
0000000000000000000000000000000000000000;;		test func(test *testcase) (string, error)
0000000000000000000000000000000000000000;;		// Expected return of the test
0000000000000000000000000000000000000000;;		expectedResult string
0000000000000000000000000000000000000000;;		expectedError  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAttachDetach(t *testing.T) {
0000000000000000000000000000000000000000;;		volumeID := "disk"
0000000000000000000000000000000000000000;;		instanceID := "instance"
0000000000000000000000000000000000000000;;		pending := VolumeStatusPending
0000000000000000000000000000000000000000;;		done := VolumeStatusDone
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("nodeName")
0000000000000000000000000000000000000000;;		readOnly := false
0000000000000000000000000000000000000000;;		spec := createVolSpec(volumeID, readOnly)
0000000000000000000000000000000000000000;;		attachError := errors.New("Fake attach error")
0000000000000000000000000000000000000000;;		detachError := errors.New("Fake detach error")
0000000000000000000000000000000000000000;;		diskCheckError := errors.New("Fake DiskIsAttached error")
0000000000000000000000000000000000000000;;		diskPathError := errors.New("Fake GetAttachmentDiskPath error")
0000000000000000000000000000000000000000;;		disksCheckError := errors.New("Fake DisksAreAttached error")
0000000000000000000000000000000000000000;;		operationFinishTimeout := errors.New("Fake waitOperationFinished error")
0000000000000000000000000000000000000000;;		tests := []testcase{
0000000000000000000000000000000000000000;;			// Successful Attach call
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Attach_Positive",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, false, nil},
0000000000000000000000000000000000000000;;				attach:           attachCall{instanceID, volumeID, "", nil},
0000000000000000000000000000000000000000;;				diskPath:         diskPathCall{instanceID, volumeID, "/dev/sda", nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedResult: "/dev/sda",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disk is already attached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Attach_Positive_AlreadyAttached",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, true, nil},
0000000000000000000000000000000000000000;;				diskPath:         diskPathCall{instanceID, volumeID, "/dev/sda", nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedResult: "/dev/sda",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disk is attaching
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Attach_is_attaching",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, true, pending, operationFinishTimeout},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: operationFinishTimeout,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Attach call fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Attach_Negative",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, false, diskCheckError},
0000000000000000000000000000000000000000;;				attach:           attachCall{instanceID, volumeID, "/dev/sda", attachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: attachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// GetAttachmentDiskPath call fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Attach_Negative_DiskPatchFails",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, false, nil},
0000000000000000000000000000000000000000;;				attach:           attachCall{instanceID, volumeID, "", nil},
0000000000000000000000000000000000000000;;				diskPath:         diskPathCall{instanceID, volumeID, "", diskPathError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: diskPathError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Successful VolumesAreAttached call, attached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "VolumesAreAttached_Positive",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				disksAreAttached: disksAreAttachedCall{instanceID, []string{volumeID}, map[string]bool{volumeID: true}, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					attachments, err := attacher.VolumesAreAttached([]*volume.Spec{spec}, nodeName)
0000000000000000000000000000000000000000;;					return serializeAttachments(attachments), err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedResult: serializeAttachments(map[*volume.Spec]bool{spec: true}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Successful VolumesAreAttached call, not attached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "VolumesAreAttached_Negative",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				disksAreAttached: disksAreAttachedCall{instanceID, []string{volumeID}, map[string]bool{volumeID: false}, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					attachments, err := attacher.VolumesAreAttached([]*volume.Spec{spec}, nodeName)
0000000000000000000000000000000000000000;;					return serializeAttachments(attachments), err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedResult: serializeAttachments(map[*volume.Spec]bool{spec: false}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Treat as attached when DisksAreAttached call fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "VolumesAreAttached_CinderFailed",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				disksAreAttached: disksAreAttachedCall{instanceID, []string{volumeID}, nil, disksCheckError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					attachments, err := attacher.VolumesAreAttached([]*volume.Spec{spec}, nodeName)
0000000000000000000000000000000000000000;;					return serializeAttachments(attachments), err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedResult: serializeAttachments(map[*volume.Spec]bool{spec: true}),
0000000000000000000000000000000000000000;;				expectedError:  disksCheckError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Detach_Positive",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, true, nil},
0000000000000000000000000000000000000000;;				detach:           detachCall{instanceID, volumeID, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(volumeID, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disk is already detached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Detach_Positive_AlreadyDetached",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, false, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(volumeID, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds when DiskIsAttached fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Detach_Positive_CheckFails",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:           detachCall{instanceID, volumeID, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(volumeID, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Detach_Negative",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, false, done, nil},
0000000000000000000000000000000000000000;;				diskIsAttached:   diskIsAttachedCall{instanceID, volumeID, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:           detachCall{instanceID, volumeID, detachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(volumeID, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: detachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// // Disk is detaching
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:             "Detach_Is_Detaching",
0000000000000000000000000000000000000000;;				instanceID:       instanceID,
0000000000000000000000000000000000000000;;				operationPending: operationPendingCall{volumeID, true, pending, operationFinishTimeout},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(volumeID, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: operationFinishTimeout,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testcase := range tests {
0000000000000000000000000000000000000000;;			testcase.t = t
0000000000000000000000000000000000000000;;			attachOrDetach := ""
0000000000000000000000000000000000000000;;			testcase.attachOrDetach = &attachOrDetach
0000000000000000000000000000000000000000;;			result, err := testcase.test(&testcase)
0000000000000000000000000000000000000000;;			if err != testcase.expectedError {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed: expected err=%q, got %q", testcase.name, testcase.expectedError, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result != testcase.expectedResult {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed: expected result=%q, got %q", testcase.name, testcase.expectedResult, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type volumeAttachmentFlag struct {
0000000000000000000000000000000000000000;;		volumeID string
0000000000000000000000000000000000000000;;		attached bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type volumeAttachmentFlags []volumeAttachmentFlag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (va volumeAttachmentFlags) Len() int {
0000000000000000000000000000000000000000;;		return len(va)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (va volumeAttachmentFlags) Swap(i, j int) {
0000000000000000000000000000000000000000;;		va[i], va[j] = va[j], va[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (va volumeAttachmentFlags) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if va[i].volumeID < va[j].volumeID {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if va[i].volumeID > va[j].volumeID {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return va[j].attached
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serializeAttachments(attachments map[*volume.Spec]bool) string {
0000000000000000000000000000000000000000;;		var attachmentFlags volumeAttachmentFlags
0000000000000000000000000000000000000000;;		for spec, attached := range attachments {
0000000000000000000000000000000000000000;;			attachmentFlags = append(attachmentFlags, volumeAttachmentFlag{spec.Name(), attached})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(attachmentFlags)
0000000000000000000000000000000000000000;;		return fmt.Sprint(attachmentFlags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPlugin creates a new gcePersistentDiskPlugin with fake cloud, NewAttacher
0000000000000000000000000000000000000000;;	// and NewDetacher won't work.
0000000000000000000000000000000000000000;;	func newPlugin() *cinderPlugin {
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost("/tmp", nil, nil)
0000000000000000000000000000000000000000;;		plugins := ProbeVolumePlugins()
0000000000000000000000000000000000000000;;		plugin := plugins[0]
0000000000000000000000000000000000000000;;		plugin.Init(host)
0000000000000000000000000000000000000000;;		return plugin.(*cinderPlugin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAttacher(testcase *testcase) *cinderDiskAttacher {
0000000000000000000000000000000000000000;;		return &cinderDiskAttacher{
0000000000000000000000000000000000000000;;			host:           nil,
0000000000000000000000000000000000000000;;			cinderProvider: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDetacher(testcase *testcase) *cinderDiskDetacher {
0000000000000000000000000000000000000000;;		return &cinderDiskDetacher{
0000000000000000000000000000000000000000;;			cinderProvider: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createVolSpec(name string, readOnly bool) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					Cinder: &v1.CinderVolumeSource{
0000000000000000000000000000000000000000;;						VolumeID: name,
0000000000000000000000000000000000000000;;						ReadOnly: readOnly,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPVSpec(name string, readOnly bool) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			PersistentVolume: &v1.PersistentVolume{
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						Cinder: &v1.CinderVolumeSource{
0000000000000000000000000000000000000000;;							VolumeID: name,
0000000000000000000000000000000000000000;;							ReadOnly: readOnly,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake GCE implementation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type attachCall struct {
0000000000000000000000000000000000000000;;		instanceID    string
0000000000000000000000000000000000000000;;		volumeID      string
0000000000000000000000000000000000000000;;		retDeviceName string
0000000000000000000000000000000000000000;;		ret           error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type detachCall struct {
0000000000000000000000000000000000000000;;		instanceID string
0000000000000000000000000000000000000000;;		devicePath string
0000000000000000000000000000000000000000;;		ret        error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type operationPendingCall struct {
0000000000000000000000000000000000000000;;		diskName     string
0000000000000000000000000000000000000000;;		pending      bool
0000000000000000000000000000000000000000;;		volumeStatus string
0000000000000000000000000000000000000000;;		ret          error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type diskIsAttachedCall struct {
0000000000000000000000000000000000000000;;		instanceID string
0000000000000000000000000000000000000000;;		volumeID   string
0000000000000000000000000000000000000000;;		isAttached bool
0000000000000000000000000000000000000000;;		ret        error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type diskPathCall struct {
0000000000000000000000000000000000000000;;		instanceID string
0000000000000000000000000000000000000000;;		volumeID   string
0000000000000000000000000000000000000000;;		retPath    string
0000000000000000000000000000000000000000;;		ret        error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type disksAreAttachedCall struct {
0000000000000000000000000000000000000000;;		instanceID  string
0000000000000000000000000000000000000000;;		volumeIDs   []string
0000000000000000000000000000000000000000;;		areAttached map[string]bool
0000000000000000000000000000000000000000;;		ret         error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) AttachDisk(instanceID, volumeID string) (string, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.attach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.volumeID == "" && expected.instanceID == "" {
0000000000000000000000000000000000000000;;			// testcase.attach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// AttachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.volumeID != volumeID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected volumeID %s, got %s", expected.volumeID, volumeID)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected AttachDisk call: wrong volumeID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.instanceID != instanceID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected instanceID %s, got %s", expected.instanceID, instanceID)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected AttachDisk call: wrong instanceID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("AttachDisk call: %s, %s, returning %q, %v", volumeID, instanceID, expected.retDeviceName, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcase.attachOrDetach = &attachStatus
0000000000000000000000000000000000000000;;		return expected.retDeviceName, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DetachDisk(instanceID, volumeID string) error {
0000000000000000000000000000000000000000;;		expected := &testcase.detach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.devicePath == "" && expected.instanceID == "" {
0000000000000000000000000000000000000000;;			// testcase.detach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// DetachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.devicePath != volumeID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected volumeID %s, got %s", expected.devicePath, volumeID)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call: wrong volumeID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.instanceID != instanceID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected instanceID %s, got %s", expected.instanceID, instanceID)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call: wrong instanceID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DetachDisk call: %s, %s, returning %v", volumeID, instanceID, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcase.attachOrDetach = &detachStatus
0000000000000000000000000000000000000000;;		return expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) OperationPending(diskName string) (bool, string, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.operationPending
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.volumeStatus == VolumeStatusPending {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("OperationPending call: %s, returning %v, %v, %v", diskName, expected.pending, expected.volumeStatus, expected.ret)
0000000000000000000000000000000000000000;;			return true, expected.volumeStatus, expected.ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("OperationPending call: %s, returning %v, %v, %v", diskName, expected.pending, expected.volumeStatus, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, expected.volumeStatus, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DiskIsAttached(instanceID, volumeID string) (bool, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.diskIsAttached
0000000000000000000000000000000000000000;;		// If testcase call DetachDisk*, return false
0000000000000000000000000000000000000000;;		if *testcase.attachOrDetach == detachStatus {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If testcase call AttachDisk*, return true
0000000000000000000000000000000000000000;;		if *testcase.attachOrDetach == attachStatus {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.volumeID == "" && expected.instanceID == "" {
0000000000000000000000000000000000000000;;			// testcase.diskIsAttached looks uninitialized, test did not expect to
0000000000000000000000000000000000000000;;			// call DiskIsAttached
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.volumeID != volumeID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected volumeID %s, got %s", expected.volumeID, volumeID)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong volumeID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.instanceID != instanceID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected instanceID %s, got %s", expected.instanceID, instanceID)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong instanceID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DiskIsAttached call: %s, %s, returning %v, %v", volumeID, instanceID, expected.isAttached, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.isAttached, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) GetAttachmentDiskPath(instanceID, volumeID string) (string, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.diskPath
0000000000000000000000000000000000000000;;		if expected.volumeID == "" && expected.instanceID == "" {
0000000000000000000000000000000000000000;;			// testcase.diskPath looks uninitialized, test did not expect to
0000000000000000000000000000000000000000;;			// call GetAttachmentDiskPath
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected GetAttachmentDiskPath call!")
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected GetAttachmentDiskPath call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.volumeID != volumeID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected GetAttachmentDiskPath call: expected volumeID %s, got %s", expected.volumeID, volumeID)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected GetAttachmentDiskPath call: wrong volumeID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.instanceID != instanceID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected GetAttachmentDiskPath call: expected instanceID %s, got %s", expected.instanceID, instanceID)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected GetAttachmentDiskPath call: wrong instanceID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("GetAttachmentDiskPath call: %s, %s, returning %v, %v", volumeID, instanceID, expected.retPath, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.retPath, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) ShouldTrustDevicePath() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) CreateVolume(name string, size int, vtype, availability string, tags *map[string]string) (string, string, error) {
0000000000000000000000000000000000000000;;		return "", "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) GetDevicePath(volumeID string) string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) InstanceID() (string, error) {
0000000000000000000000000000000000000000;;		return testcase.instanceID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DeleteVolume(volumeID string) error {
0000000000000000000000000000000000000000;;		return errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) GetAutoLabelsForPD(name string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		return map[string]string{}, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) Instances() (cloudprovider.Instances, bool) {
0000000000000000000000000000000000000000;;		return &instances{testcase.instanceID}, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DisksAreAttached(instanceID string, volumeIDs []string) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.disksAreAttached
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		areAttached := make(map[string]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(expected.volumeIDs) == 0 && expected.instanceID == "" {
0000000000000000000000000000000000000000;;			// testcase.volumeIDs looks uninitialized, test did not expect to call DisksAreAttached
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DisksAreAttached call!")
0000000000000000000000000000000000000000;;			return areAttached, errors.New("Unexpected DisksAreAttached call")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(expected.volumeIDs, volumeIDs) {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DisksAreAttached call: expected volumeIDs %v, got %v", expected.volumeIDs, volumeIDs)
0000000000000000000000000000000000000000;;			return areAttached, errors.New("Unexpected DisksAreAttached call: wrong volumeID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.instanceID != instanceID {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DisksAreAttached call: expected instanceID %s, got %s", expected.instanceID, instanceID)
0000000000000000000000000000000000000000;;			return areAttached, errors.New("Unexpected DisksAreAttached call: wrong instanceID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DisksAreAttached call: %v, %s, returning %v, %v", volumeIDs, instanceID, expected.areAttached, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.areAttached, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of fake cloudprovider.Instances
0000000000000000000000000000000000000000;;	type instances struct {
0000000000000000000000000000000000000000;;		instanceID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) NodeAddresses(name types.NodeName) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		return []v1.NodeAddress{}, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) NodeAddressesByProviderID(providerID string) ([]v1.NodeAddress, error) {
0000000000000000000000000000000000000000;;		return []v1.NodeAddress{}, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) ExternalID(name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) InstanceID(name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		return instances.instanceID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) InstanceType(name types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) InstanceTypeByProviderID(providerID string) (string, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) List(filter string) ([]types.NodeName, error) {
0000000000000000000000000000000000000000;;		return []types.NodeName{}, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) AddSSHKeyToAllInstances(user string, keyData []byte) error {
0000000000000000000000000000000000000000;;		return errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (instances *instances) CurrentNodeName(hostname string) (types.NodeName, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
