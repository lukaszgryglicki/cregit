0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e29101cc418bdf0e77b32bc1b0ed9e35766c8b85;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cinder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/openstack"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/rackspace"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/keymutex"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&cinderPlugin{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CinderProvider interface {
0000000000000000000000000000000000000000;;		AttachDisk(instanceID, volumeID string) (string, error)
0000000000000000000000000000000000000000;;		DetachDisk(instanceID, volumeID string) error
0000000000000000000000000000000000000000;;		DeleteVolume(volumeID string) error
0000000000000000000000000000000000000000;;		CreateVolume(name string, size int, vtype, availability string, tags *map[string]string) (string, string, error)
0000000000000000000000000000000000000000;;		GetDevicePath(volumeID string) string
0000000000000000000000000000000000000000;;		InstanceID() (string, error)
0000000000000000000000000000000000000000;;		GetAttachmentDiskPath(instanceID, volumeID string) (string, error)
0000000000000000000000000000000000000000;;		OperationPending(diskName string) (bool, string, error)
0000000000000000000000000000000000000000;;		DiskIsAttached(instanceID, volumeID string) (bool, error)
0000000000000000000000000000000000000000;;		DisksAreAttached(instanceID string, volumeIDs []string) (map[string]bool, error)
0000000000000000000000000000000000000000;;		ShouldTrustDevicePath() bool
0000000000000000000000000000000000000000;;		Instances() (cloudprovider.Instances, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cinderPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;		// Guarding SetUp and TearDown operations
0000000000000000000000000000000000000000;;		volumeLocks keymutex.KeyMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &cinderPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &cinderPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &cinderPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &cinderPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cinderVolumePluginName = "kubernetes.io/cinder"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		plugin.volumeLocks = keymutex.NewKeyMutex()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return cinderVolumePluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource.VolumeID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.Volume != nil && spec.Volume.Cinder != nil) || (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Cinder != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, &CinderDiskUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, manager cdManager, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		cinder, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdName := cinder.VolumeID
0000000000000000000000000000000000000000;;		fsType := cinder.FSType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &cinderVolumeMounter{
0000000000000000000000000000000000000000;;			cinderVolume: &cinderVolume{
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				volName: spec.Name(),
0000000000000000000000000000000000000000;;				pdName:  pdName,
0000000000000000000000000000000000000000;;				mounter: mounter,
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			fsType:             fsType,
0000000000000000000000000000000000000000;;			readOnly:           readOnly,
0000000000000000000000000000000000000000;;			blockDeviceMounter: &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, &CinderDiskUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) newUnmounterInternal(volName string, podUID types.UID, manager cdManager, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &cinderVolumeUnmounter{
0000000000000000000000000000000000000000;;			&cinderVolume{
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				mounter: mounter,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		return plugin.newDeleterInternal(spec, &CinderDiskUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) newDeleterInternal(spec *volume.Spec, manager cdManager) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Cinder == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.Cinder is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &cinderVolumeDeleter{
0000000000000000000000000000000000000000;;			&cinderVolume{
0000000000000000000000000000000000000000;;				volName: spec.Name(),
0000000000000000000000000000000000000000;;				pdName:  spec.PersistentVolume.Spec.Cinder.VolumeID,
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return plugin.newProvisionerInternal(options, &CinderDiskUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) newProvisionerInternal(options volume.VolumeOptions, manager cdManager) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &cinderVolumeProvisioner{
0000000000000000000000000000000000000000;;			cinderVolume: &cinderVolume{
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options: options,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCloudProvider(cloudProvider cloudprovider.Interface) (CinderProvider, error) {
0000000000000000000000000000000000000000;;		if cloud, ok := cloudProvider.(*rackspace.Rackspace); ok && cloud != nil {
0000000000000000000000000000000000000000;;			return cloud, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cloud, ok := cloudProvider.(*openstack.OpenStack); ok && cloud != nil {
0000000000000000000000000000000000000000;;			return cloud, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("wrong cloud type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) getCloudProvider() (CinderProvider, error) {
0000000000000000000000000000000000000000;;		cloud := plugin.host.GetCloudProvider()
0000000000000000000000000000000000000000;;		if cloud == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Cloud provider not initialized properly")
0000000000000000000000000000000000000000;;			return nil, errors.New("Cloud provider not initialized properly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch cloud := cloud.(type) {
0000000000000000000000000000000000000000;;		case *rackspace.Rackspace:
0000000000000000000000000000000000000000;;			return cloud, nil
0000000000000000000000000000000000000000;;		case *openstack.OpenStack:
0000000000000000000000000000000000000000;;			return cloud, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("Invalid cloud provider: expected OpenStack or Rackspace.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cinderPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		pluginDir := plugin.host.GetPluginDir(plugin.GetPluginName())
0000000000000000000000000000000000000000;;		sourceName, err := mounter.GetDeviceNameFromMount(mountPath, pluginDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Found volume %s mounted to %s", sourceName, mountPath)
0000000000000000000000000000000000000000;;		cinderVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				Cinder: &v1.CinderVolumeSource{
0000000000000000000000000000000000000000;;					VolumeID: sourceName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(cinderVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstract interface to PD operations.
0000000000000000000000000000000000000000;;	type cdManager interface {
0000000000000000000000000000000000000000;;		// Attaches the disk to the kubelet's host machine.
0000000000000000000000000000000000000000;;		AttachDisk(mounter *cinderVolumeMounter, globalPDPath string) error
0000000000000000000000000000000000000000;;		// Detaches the disk from the kubelet's host machine.
0000000000000000000000000000000000000000;;		DetachDisk(unmounter *cinderVolumeUnmounter) error
0000000000000000000000000000000000000000;;		// Creates a volume
0000000000000000000000000000000000000000;;		CreateVolume(provisioner *cinderVolumeProvisioner) (volumeID string, volumeSizeGB int, labels map[string]string, err error)
0000000000000000000000000000000000000000;;		// Deletes a volume
0000000000000000000000000000000000000000;;		DeleteVolume(deleter *cinderVolumeDeleter) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &cinderVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cinderVolumeMounter struct {
0000000000000000000000000000000000000000;;		*cinderVolume
0000000000000000000000000000000000000000;;		fsType             string
0000000000000000000000000000000000000000;;		readOnly           bool
0000000000000000000000000000000000000000;;		blockDeviceMounter *mount.SafeFormatAndMount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cinderPersistentDisk volumes are disk resources provided by C3
0000000000000000000000000000000000000000;;	// that are attached to the kubelet's host machine and exposed to the pod.
0000000000000000000000000000000000000000;;	type cinderVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		// Unique identifier of the volume, used to find the disk resource in the provider.
0000000000000000000000000000000000000000;;		pdName string
0000000000000000000000000000000000000000;;		// Filesystem type, optional.
0000000000000000000000000000000000000000;;		fsType string
0000000000000000000000000000000000000000;;		// Specifies whether the disk will be attached as read-only.
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;		// Utility interface that provides API calls to the provider to attach/detach disks.
0000000000000000000000000000000000000000;;		manager cdManager
0000000000000000000000000000000000000000;;		// Mounter interface that provides system calls to mount the global path to the pod local path.
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		// diskMounter provides the interface that is used to mount the actual block device.
0000000000000000000000000000000000000000;;		blockDeviceMounter mount.Interface
0000000000000000000000000000000000000000;;		plugin             *cinderPlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func detachDiskLogError(cd *cinderVolume) {
0000000000000000000000000000000000000000;;		err := cd.manager.DetachDisk(&cinderVolumeUnmounter{cd})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to detach disk: %v (%v)", cd, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *cinderVolumeMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         !b.readOnly,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *cinderVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *cinderVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *cinderVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Cinder SetUp %s to %s", b.pdName, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.plugin.volumeLocks.LockKey(b.pdName)
0000000000000000000000000000000000000000;;		defer b.plugin.volumeLocks.UnlockKey(b.pdName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: handle failed mounts here.
0000000000000000000000000000000000000000;;		notmnt, err := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot validate mount point: %s %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notmnt {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Something is already mounted to target %s", dir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		globalPDPath := makeGlobalPDName(b.plugin.host, b.pdName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := []string{"bind"}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			// TODO: we should really eject the attach/detach out into its own control loop.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Could not create directory %s: %v", dir, err)
0000000000000000000000000000000000000000;;			detachDiskLogError(b.cinderVolume)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a bind mount to the full path to allow duplicate mounts of the same PD.
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Attempting to mount cinder volume %s to %s with options %v", b.pdName, dir, options)
0000000000000000000000000000000000000000;;		err = b.mounter.Mount(globalPDPath, dir, "", options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Mount failed: %v", err)
0000000000000000000000000000000000000000;;			notmnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;			if mntErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !notmnt {
0000000000000000000000000000000000000000;;				if mntErr = b.mounter.Unmount(dir); mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to unmount: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notmnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;				if mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !notmnt {
0000000000000000000000000000000000000000;;					// This is very odd, we don't expect it.  We'll try again next sync loop.
0000000000000000000000000000000000000000;;					glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.", b.GetPath())
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Remove(dir)
0000000000000000000000000000000000000000;;			// TODO: we should really eject the attach/detach out into its own control loop.
0000000000000000000000000000000000000000;;			detachDiskLogError(b.cinderVolume)
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to mount %s: %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !b.readOnly {
0000000000000000000000000000000000000000;;			volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Cinder volume %s mounted to %s", b.pdName, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeGlobalPDName(host volume.VolumeHost, devName string) string {
0000000000000000000000000000000000000000;;		return path.Join(host.GetPluginDir(cinderVolumePluginName), mount.MountsInGlobalPDPath, devName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cd *cinderVolume) GetPath() string {
0000000000000000000000000000000000000000;;		name := cinderVolumePluginName
0000000000000000000000000000000000000000;;		return cd.plugin.host.GetPodVolumeDir(cd.podUID, strings.EscapeQualifiedNameForDisk(name), cd.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cinderVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*cinderVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &cinderVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cinderVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *cinderVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		if pathExists, pathErr := util.PathExists(dir); pathErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error checking if path exists: %v", pathErr)
0000000000000000000000000000000000000000;;		} else if !pathExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: Unmount skipped because path does not exist: %v", dir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Cinder TearDown of %s", dir)
0000000000000000000000000000000000000000;;		notmnt, err := c.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("IsLikelyNotMountPoint check failed: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notmnt {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Nothing is mounted to %s, ignoring", dir)
0000000000000000000000000000000000000000;;			return os.Remove(dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find Cinder volumeID to lock the right volume
0000000000000000000000000000000000000000;;		// TODO: refactor VolumePlugin.NewUnmounter to get full volume.Spec just like
0000000000000000000000000000000000000000;;		// NewMounter. We could then find volumeID there without probing MountRefs.
0000000000000000000000000000000000000000;;		refs, err := mount.GetMountRefs(c.mounter, dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("GetMountRefs failed: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(refs) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Directory %s is not mounted", dir)
0000000000000000000000000000000000000000;;			return fmt.Errorf("directory %s is not mounted", dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.pdName = path.Base(refs[0])
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Found volume %s mounted to %s", c.pdName, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lock the volume (and thus wait for any concurrrent SetUpAt to finish)
0000000000000000000000000000000000000000;;		c.plugin.volumeLocks.LockKey(c.pdName)
0000000000000000000000000000000000000000;;		defer c.plugin.volumeLocks.UnlockKey(c.pdName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reload list of references, there might be SetUpAt finished in the meantime
0000000000000000000000000000000000000000;;		refs, err = mount.GetMountRefs(c.mounter, dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("GetMountRefs failed: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.mounter.Unmount(dir); err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Unmount failed: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Successfully unmounted: %s\n", dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		notmnt, mntErr := c.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		if mntErr != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notmnt {
0000000000000000000000000000000000000000;;			if err := os.Remove(dir); err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Failed to remove directory after unmount: %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cinderVolumeDeleter struct {
0000000000000000000000000000000000000000;;		*cinderVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Deleter = &cinderVolumeDeleter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *cinderVolumeDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		name := cinderVolumePluginName
0000000000000000000000000000000000000000;;		return r.plugin.host.GetPodVolumeDir(r.podUID, strings.EscapeQualifiedNameForDisk(name), r.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *cinderVolumeDeleter) Delete() error {
0000000000000000000000000000000000000000;;		return r.manager.DeleteVolume(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cinderVolumeProvisioner struct {
0000000000000000000000000000000000000000;;		*cinderVolume
0000000000000000000000000000000000000000;;		options volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Provisioner = &cinderVolumeProvisioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cinderVolumeProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if !volume.AccessModesContainedInAll(c.plugin.GetAccessModes(), c.options.PVC.Spec.AccessModes) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported", c.options.PVC.Spec.AccessModes, c.plugin.GetAccessModes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID, sizeGB, labels, err := c.manager.CreateVolume(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   c.options.PVName,
0000000000000000000000000000000000000000;;				Labels: labels,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeDynamicallyCreatedByKey: "cinder-dynamic-provisioner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: c.options.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				AccessModes:                   c.options.PVC.Spec.AccessModes,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dGi", sizeGB)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					Cinder: &v1.CinderVolumeSource{
0000000000000000000000000000000000000000;;						VolumeID: volumeID,
0000000000000000000000000000000000000000;;						FSType:   "ext4",
0000000000000000000000000000000000000000;;						ReadOnly: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.options.PVC.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = c.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.CinderVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.Cinder != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.Cinder, spec.Volume.Cinder.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.Cinder != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.Cinder, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a Cinder volume type")
0000000000000000000000000000000000000000;;	}
