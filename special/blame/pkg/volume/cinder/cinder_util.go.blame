0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e29101cc418bdf0e77b32bc1b0ed9e35766c8b85;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cinder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		kubeletapis "k8s.io/kubernetes/pkg/kubelet/apis"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CinderDiskUtil struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attaches a disk specified by a volume.CinderPersistenDisk to the current kubelet.
0000000000000000000000000000000000000000;;	// Mounts the disk to its global path.
0000000000000000000000000000000000000000;;	func (util *CinderDiskUtil) AttachDisk(b *cinderVolumeMounter, globalPDPath string) error {
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cloud, err := b.plugin.getCloudProvider()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instanceid, err := cloud.InstanceID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diskid, err := cloud.AttachDisk(instanceid, b.pdName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var devicePath string
0000000000000000000000000000000000000000;;		numTries := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			devicePath = cloud.GetDevicePath(diskid)
0000000000000000000000000000000000000000;;			probeAttachedVolume()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err := os.Stat(devicePath)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			numTries++
0000000000000000000000000000000000000000;;			if numTries == 10 {
0000000000000000000000000000000000000000;;				return errors.New("Could not attach disk: Timeout after 60s")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(time.Second * 6)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		notmnt, err := b.mounter.IsLikelyNotMountPoint(globalPDPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(globalPDPath, 0750); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notmnt = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notmnt {
0000000000000000000000000000000000000000;;			err = b.blockDeviceMounter.FormatAndMount(devicePath, globalPDPath, b.fsType, options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				os.Remove(globalPDPath)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Safe mount successful: %q\n", devicePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the device and detaches the disk from the kubelet's host machine.
0000000000000000000000000000000000000000;;	func (util *CinderDiskUtil) DetachDisk(cd *cinderVolumeUnmounter) error {
0000000000000000000000000000000000000000;;		globalPDPath := makeGlobalPDName(cd.plugin.host, cd.pdName)
0000000000000000000000000000000000000000;;		if err := cd.mounter.Unmount(globalPDPath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.Remove(globalPDPath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully unmounted main device: %s\n", globalPDPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cloud, err := cd.plugin.getCloudProvider()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instanceid, err := cloud.InstanceID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = cloud.DetachDisk(instanceid, cd.pdName); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully detached cinder volume %s", cd.pdName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *CinderDiskUtil) DeleteVolume(cd *cinderVolumeDeleter) error {
0000000000000000000000000000000000000000;;		cloud, err := cd.plugin.getCloudProvider()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = cloud.DeleteVolume(cd.pdName); err != nil {
0000000000000000000000000000000000000000;;			// OpenStack cloud provider returns volume.tryAgainError when necessary,
0000000000000000000000000000000000000000;;			// no handling needed here.
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error deleting cinder volume %s: %v", cd.pdName, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully deleted cinder volume %s", cd.pdName)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getZonesFromNodes(kubeClient clientset.Interface) (sets.String, error) {
0000000000000000000000000000000000000000;;		// TODO: caching, currently it is overkill because it calls this function
0000000000000000000000000000000000000000;;		// only when it creates dynamic PV
0000000000000000000000000000000000000000;;		zones := make(sets.String)
0000000000000000000000000000000000000000;;		nodes, err := kubeClient.Core().Nodes().List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error listing nodes")
0000000000000000000000000000000000000000;;			return zones, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, node := range nodes.Items {
0000000000000000000000000000000000000000;;			if zone, ok := node.Labels[kubeletapis.LabelZoneFailureDomain]; ok {
0000000000000000000000000000000000000000;;				zones.Insert(zone)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("zones found: %v", zones)
0000000000000000000000000000000000000000;;		return zones, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *CinderDiskUtil) CreateVolume(c *cinderVolumeProvisioner) (volumeID string, volumeSizeGB int, volumeLabels map[string]string, err error) {
0000000000000000000000000000000000000000;;		cloud, err := c.plugin.getCloudProvider()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capacity := c.options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		volSizeBytes := capacity.Value()
0000000000000000000000000000000000000000;;		// Cinder works with gigabytes, convert to GiB with rounding up
0000000000000000000000000000000000000000;;		volSizeGB := int(volume.RoundUpSize(volSizeBytes, 1024*1024*1024))
0000000000000000000000000000000000000000;;		name := volume.GenerateVolumeName(c.options.ClusterName, c.options.PVName, 255) // Cinder volume name can have up to 255 characters
0000000000000000000000000000000000000000;;		vtype := ""
0000000000000000000000000000000000000000;;		availability := ""
0000000000000000000000000000000000000000;;		// Apply ProvisionerParameters (case-insensitive). We leave validation of
0000000000000000000000000000000000000000;;		// the values to the cloud provider.
0000000000000000000000000000000000000000;;		for k, v := range c.options.Parameters {
0000000000000000000000000000000000000000;;			switch strings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "type":
0000000000000000000000000000000000000000;;				vtype = v
0000000000000000000000000000000000000000;;			case "availability":
0000000000000000000000000000000000000000;;				availability = v
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return "", 0, nil, fmt.Errorf("invalid option %q for volume plugin %s", k, c.plugin.GetPluginName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: implement PVC.Selector parsing
0000000000000000000000000000000000000000;;		if c.options.PVC.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			return "", 0, nil, fmt.Errorf("claim.Spec.Selector is not supported for dynamic provisioning on Cinder")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if availability == "" {
0000000000000000000000000000000000000000;;			// No zone specified, choose one randomly in the same region
0000000000000000000000000000000000000000;;			zones, err := getZonesFromNodes(c.plugin.host.GetKubeClient())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("error getting zone information: %v", err)
0000000000000000000000000000000000000000;;				return "", 0, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if we did not get any zones, lets leave it blank and gophercloud will
0000000000000000000000000000000000000000;;			// use zone "nova" as default
0000000000000000000000000000000000000000;;			if len(zones) > 0 {
0000000000000000000000000000000000000000;;				availability = volume.ChooseZoneForVolume(zones, c.options.PVC.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID, volumeAZ, errr := cloud.CreateVolume(name, volSizeGB, vtype, availability, c.options.CloudTags)
0000000000000000000000000000000000000000;;		if errr != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error creating cinder volume: %v", errr)
0000000000000000000000000000000000000000;;			return "", 0, nil, errr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully created cinder volume %s", volumeID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// these are needed that pod is spawning to same AZ
0000000000000000000000000000000000000000;;		volumeLabels = make(map[string]string)
0000000000000000000000000000000000000000;;		volumeLabels[kubeletapis.LabelZoneFailureDomain] = volumeAZ
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeID, volSizeGB, volumeLabels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func probeAttachedVolume() error {
0000000000000000000000000000000000000000;;		// rescan scsi bus
0000000000000000000000000000000000000000;;		scsiHostRescan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		executor := exec.New()
0000000000000000000000000000000000000000;;		args := []string{"trigger"}
0000000000000000000000000000000000000000;;		cmd := executor.Command("udevadm", args...)
0000000000000000000000000000000000000000;;		_, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("error running udevadm trigger %v\n", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Successfully probed all attachments")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scsiHostRescan() {
0000000000000000000000000000000000000000;;		scsi_path := "/sys/class/scsi_host/"
0000000000000000000000000000000000000000;;		if dirs, err := ioutil.ReadDir(scsi_path); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				name := scsi_path + f.Name() + "/scan"
0000000000000000000000000000000000000000;;				data := []byte("- - -")
0000000000000000000000000000000000000000;;				ioutil.WriteFile(name, data, 0666)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
