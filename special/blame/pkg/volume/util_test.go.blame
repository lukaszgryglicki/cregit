0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
187272dfa1c131870024b91c471fedda6295fe77;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/slice"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testcase struct {
0000000000000000000000000000000000000000;;		// Input of the test
0000000000000000000000000000000000000000;;		name        string
0000000000000000000000000000000000000000;;		existingPod *v1.Pod
0000000000000000000000000000000000000000;;		createPod   *v1.Pod
0000000000000000000000000000000000000000;;		// eventSequence is list of events that are simulated during recycling. It
0000000000000000000000000000000000000000;;		// can be either event generated by a recycler pod or a state change of
0000000000000000000000000000000000000000;;		// the pod. (see newPodEvent and newEvent below).
0000000000000000000000000000000000000000;;		eventSequence []watch.Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expected output.
0000000000000000000000000000000000000000;;		// expectedEvents is list of events that were sent to the volume that was
0000000000000000000000000000000000000000;;		// recycled.
0000000000000000000000000000000000000000;;		expectedEvents []mockEvent
0000000000000000000000000000000000000000;;		expectedError  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPodEvent(eventtype watch.EventType, name string, phase v1.PodPhase, message string) watch.Event {
0000000000000000000000000000000000000000;;		return watch.Event{
0000000000000000000000000000000000000000;;			Type:   eventtype,
0000000000000000000000000000000000000000;;			Object: newPod(name, phase, message),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEvent(eventtype, message string) watch.Event {
0000000000000000000000000000000000000000;;		return watch.Event{
0000000000000000000000000000000000000000;;			Type: watch.Added,
0000000000000000000000000000000000000000;;			Object: &v1.Event{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Reason:  "MockEvent",
0000000000000000000000000000000000000000;;				Message: message,
0000000000000000000000000000000000000000;;				Type:    eventtype,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPod(name string, phase v1.PodPhase, message string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				Name:      name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PodStatus{
0000000000000000000000000000000000000000;;				Phase:   phase,
0000000000000000000000000000000000000000;;				Message: message,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRecyclerPod(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []testcase{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Test recycler success with some events
0000000000000000000000000000000000000000;;				name:      "RecyclerSuccess",
0000000000000000000000000000000000000000;;				createPod: newPod("podRecyclerSuccess", v1.PodPending, ""),
0000000000000000000000000000000000000000;;				eventSequence: []watch.Event{
0000000000000000000000000000000000000000;;					// Pod gets Running and Succeeded
0000000000000000000000000000000000000000;;					newPodEvent(watch.Added, "podRecyclerSuccess", v1.PodPending, ""),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeNormal, "Successfully assigned recycler-for-podRecyclerSuccess to 127.0.0.1"),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeNormal, "pulling image \"gcr.io/google_containers/busybox\""),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeNormal, "Successfully pulled image \"gcr.io/google_containers/busybox\""),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeNormal, "Created container with docker id 83d929aeac82"),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeNormal, "Started container with docker id 83d929aeac82"),
0000000000000000000000000000000000000000;;					newPodEvent(watch.Modified, "podRecyclerSuccess", v1.PodRunning, ""),
0000000000000000000000000000000000000000;;					newPodEvent(watch.Modified, "podRecyclerSuccess", v1.PodSucceeded, ""),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvents: []mockEvent{
0000000000000000000000000000000000000000;;					{v1.EventTypeNormal, "Successfully assigned recycler-for-podRecyclerSuccess to 127.0.0.1"},
0000000000000000000000000000000000000000;;					{v1.EventTypeNormal, "pulling image \"gcr.io/google_containers/busybox\""},
0000000000000000000000000000000000000000;;					{v1.EventTypeNormal, "Successfully pulled image \"gcr.io/google_containers/busybox\""},
0000000000000000000000000000000000000000;;					{v1.EventTypeNormal, "Created container with docker id 83d929aeac82"},
0000000000000000000000000000000000000000;;					{v1.EventTypeNormal, "Started container with docker id 83d929aeac82"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Test recycler failure with some events
0000000000000000000000000000000000000000;;				name:      "RecyclerFailure",
0000000000000000000000000000000000000000;;				createPod: newPod("podRecyclerFailure", v1.PodPending, ""),
0000000000000000000000000000000000000000;;				eventSequence: []watch.Event{
0000000000000000000000000000000000000000;;					// Pod gets Running and Succeeded
0000000000000000000000000000000000000000;;					newPodEvent(watch.Added, "podRecyclerFailure", v1.PodPending, ""),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeNormal, "Successfully assigned recycler-for-podRecyclerFailure to 127.0.0.1"),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeWarning, "Unable to mount volumes for pod \"recycler-for-podRecyclerFailure_default(3c9809e5-347c-11e6-a79b-3c970e965218)\": timeout expired waiting for volumes to attach/mount"),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeWarning, "Error syncing pod, skipping: timeout expired waiting for volumes to attach/mount for pod \"default\"/\"recycler-for-podRecyclerFailure\". list of unattached/unmounted"),
0000000000000000000000000000000000000000;;					newPodEvent(watch.Modified, "podRecyclerFailure", v1.PodRunning, ""),
0000000000000000000000000000000000000000;;					newPodEvent(watch.Modified, "podRecyclerFailure", v1.PodFailed, "Pod was active on the node longer than specified deadline"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvents: []mockEvent{
0000000000000000000000000000000000000000;;					{v1.EventTypeNormal, "Successfully assigned recycler-for-podRecyclerFailure to 127.0.0.1"},
0000000000000000000000000000000000000000;;					{v1.EventTypeWarning, "Unable to mount volumes for pod \"recycler-for-podRecyclerFailure_default(3c9809e5-347c-11e6-a79b-3c970e965218)\": timeout expired waiting for volumes to attach/mount"},
0000000000000000000000000000000000000000;;					{v1.EventTypeWarning, "Error syncing pod, skipping: timeout expired waiting for volumes to attach/mount for pod \"default\"/\"recycler-for-podRecyclerFailure\". list of unattached/unmounted"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: "Pod was active on the node longer than specified deadline",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Recycler pod gets deleted
0000000000000000000000000000000000000000;;				name:      "RecyclerDeleted",
0000000000000000000000000000000000000000;;				createPod: newPod("podRecyclerDeleted", v1.PodPending, ""),
0000000000000000000000000000000000000000;;				eventSequence: []watch.Event{
0000000000000000000000000000000000000000;;					// Pod gets Running and Succeeded
0000000000000000000000000000000000000000;;					newPodEvent(watch.Added, "podRecyclerDeleted", v1.PodPending, ""),
0000000000000000000000000000000000000000;;					newEvent(v1.EventTypeNormal, "Successfully assigned recycler-for-podRecyclerDeleted to 127.0.0.1"),
0000000000000000000000000000000000000000;;					newPodEvent(watch.Deleted, "podRecyclerDeleted", v1.PodPending, ""),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedEvents: []mockEvent{
0000000000000000000000000000000000000000;;					{v1.EventTypeNormal, "Successfully assigned recycler-for-podRecyclerDeleted to 127.0.0.1"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: "recycler pod was deleted",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Another recycler pod is already running
0000000000000000000000000000000000000000;;				name:        "RecyclerRunning",
0000000000000000000000000000000000000000;;				existingPod: newPod("podOldRecycler", v1.PodRunning, ""),
0000000000000000000000000000000000000000;;				createPod:   newPod("podNewRecycler", v1.PodFailed, "mock message"),
0000000000000000000000000000000000000000;;				eventSequence: []watch.Event{
0000000000000000000000000000000000000000;;					// Old pod succeeds
0000000000000000000000000000000000000000;;					newPodEvent(watch.Modified, "podOldRecycler", v1.PodSucceeded, ""),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// No error = old pod succeeded. If the new pod was used, there
0000000000000000000000000000000000000000;;				// would be error with "mock message".
0000000000000000000000000000000000000000;;				expectedError: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Another recycler pod is already running and fails
0000000000000000000000000000000000000000;;				name:        "FailedRecyclerRunning",
0000000000000000000000000000000000000000;;				existingPod: newPod("podOldRecycler", v1.PodRunning, ""),
0000000000000000000000000000000000000000;;				createPod:   newPod("podNewRecycler", v1.PodFailed, "mock message"),
0000000000000000000000000000000000000000;;				eventSequence: []watch.Event{
0000000000000000000000000000000000000000;;					// Old pod failure
0000000000000000000000000000000000000000;;					newPodEvent(watch.Modified, "podOldRecycler", v1.PodFailed, "Pod was active on the node longer than specified deadline"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// If the new pod was used, there would be error with "mock message".
0000000000000000000000000000000000000000;;				expectedError: "Pod was active on the node longer than specified deadline",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Logf("Test %q", test.name)
0000000000000000000000000000000000000000;;			client := &mockRecyclerClient{
0000000000000000000000000000000000000000;;				events: test.eventSequence,
0000000000000000000000000000000000000000;;				pod:    test.existingPod,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := internalRecycleVolumeByWatchingPodUntilCompletion(test.createPod.Name, test.createPod, client)
0000000000000000000000000000000000000000;;			receivedError := ""
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				receivedError = err.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if receivedError != test.expectedError {
0000000000000000000000000000000000000000;;				t.Errorf("Test %q failed, expected error %q, got %q", test.name, test.expectedError, receivedError)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !client.deletedCalled {
0000000000000000000000000000000000000000;;				t.Errorf("Test %q failed, expected deferred client.Delete to be called on recycler pod", test.name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, expectedEvent := range test.expectedEvents {
0000000000000000000000000000000000000000;;				if len(client.receivedEvents) <= i {
0000000000000000000000000000000000000000;;					t.Errorf("Test %q failed, expected event %d: %q not received", test.name, i, expectedEvent.message)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				receivedEvent := client.receivedEvents[i]
0000000000000000000000000000000000000000;;				if expectedEvent.eventtype != receivedEvent.eventtype {
0000000000000000000000000000000000000000;;					t.Errorf("Test %q failed, event %d does not match: expected eventtype %q, got %q", test.name, i, expectedEvent.eventtype, receivedEvent.eventtype)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if expectedEvent.message != receivedEvent.message {
0000000000000000000000000000000000000000;;					t.Errorf("Test %q failed, event %d does not match: expected message %q, got %q", test.name, i, expectedEvent.message, receivedEvent.message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := len(test.expectedEvents); i < len(client.receivedEvents); i++ {
0000000000000000000000000000000000000000;;				t.Errorf("Test %q failed, unexpected event received: %s, %q", test.name, client.receivedEvents[i].eventtype, client.receivedEvents[i].message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockRecyclerClient struct {
0000000000000000000000000000000000000000;;		pod            *v1.Pod
0000000000000000000000000000000000000000;;		deletedCalled  bool
0000000000000000000000000000000000000000;;		receivedEvents []mockEvent
0000000000000000000000000000000000000000;;		events         []watch.Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockEvent struct {
0000000000000000000000000000000000000000;;		eventtype, message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockRecyclerClient) CreatePod(pod *v1.Pod) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		if c.pod == nil {
0000000000000000000000000000000000000000;;			c.pod = pod
0000000000000000000000000000000000000000;;			return c.pod, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Simulate "already exists" error
0000000000000000000000000000000000000000;;		return nil, errors.NewAlreadyExists(api.Resource("pods"), pod.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockRecyclerClient) GetPod(name, namespace string) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		if c.pod != nil {
0000000000000000000000000000000000000000;;			return c.pod, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("pod does not exist")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockRecyclerClient) DeletePod(name, namespace string) error {
0000000000000000000000000000000000000000;;		c.deletedCalled = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockRecyclerClient) WatchPod(name, namespace string, stopChannel chan struct{}) (<-chan watch.Event, error) {
0000000000000000000000000000000000000000;;		eventCh := make(chan watch.Event, 0)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for _, e := range c.events {
0000000000000000000000000000000000000000;;				eventCh <- e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return eventCh, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockRecyclerClient) Event(eventtype, message string) {
0000000000000000000000000000000000000000;;		c.receivedEvents = append(c.receivedEvents, mockEvent{eventtype, message})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCalculateTimeoutForVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse("500M"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeout := CalculateTimeoutForVolume(50, 30, pv)
0000000000000000000000000000000000000000;;		if timeout != 50 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 50 for timeout but got %v", timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv.Spec.Capacity[v1.ResourceStorage] = resource.MustParse("2Gi")
0000000000000000000000000000000000000000;;		timeout = CalculateTimeoutForVolume(50, 30, pv)
0000000000000000000000000000000000000000;;		if timeout != 60 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 60 for timeout but got %v", timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv.Spec.Capacity[v1.ResourceStorage] = resource.MustParse("150Gi")
0000000000000000000000000000000000000000;;		timeout = CalculateTimeoutForVolume(50, 30, pv)
0000000000000000000000000000000000000000;;		if timeout != 4500 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected 4500 for timeout but got %v", timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenerateVolumeName(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Normal operation, no truncate
0000000000000000000000000000000000000000;;		v1 := GenerateVolumeName("kubernetes", "pv-cinder-abcde", 255)
0000000000000000000000000000000000000000;;		if v1 != "kubernetes-dynamic-pv-cinder-abcde" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected kubernetes-dynamic-pv-cinder-abcde, got %s", v1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Truncate trailing "6789-dynamic"
0000000000000000000000000000000000000000;;		prefix := strings.Repeat("0123456789", 9) // 90 characters prefix + 8 chars. of "-dynamic"
0000000000000000000000000000000000000000;;		v2 := GenerateVolumeName(prefix, "pv-cinder-abcde", 100)
0000000000000000000000000000000000000000;;		expect := prefix[:84] + "-pv-cinder-abcde"
0000000000000000000000000000000000000000;;		if v2 != expect {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s, got %s", expect, v2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Truncate really long cluster name
0000000000000000000000000000000000000000;;		prefix = strings.Repeat("0123456789", 1000) // 10000 characters prefix
0000000000000000000000000000000000000000;;		v3 := GenerateVolumeName(prefix, "pv-cinder-abcde", 100)
0000000000000000000000000000000000000000;;		if v3 != expect {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s, got %s", expect, v3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMountOptionFromSpec(t *testing.T) {
0000000000000000000000000000000000000000;;		scenarios := map[string]struct {
0000000000000000000000000000000000000000;;			volume            *Spec
0000000000000000000000000000000000000000;;			expectedMountList []string
0000000000000000000000000000000000000000;;			systemOptions     []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"volume-with-mount-options": {
0000000000000000000000000000000000000000;;				volume: createVolumeSpecWithMountOption("good-mount-opts", "ro,nfsvers=3", v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						NFS: &v1.NFSVolumeSource{Server: "localhost", Path: "/srv", ReadOnly: false},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				expectedMountList: []string{"ro", "nfsvers=3"},
0000000000000000000000000000000000000000;;				systemOptions:     nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"volume-with-bad-mount-options": {
0000000000000000000000000000000000000000;;				volume: createVolumeSpecWithMountOption("good-mount-opts", "", v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						NFS: &v1.NFSVolumeSource{Server: "localhost", Path: "/srv", ReadOnly: false},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				expectedMountList: []string{},
0000000000000000000000000000000000000000;;				systemOptions:     nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"vol-with-sys-opts": {
0000000000000000000000000000000000000000;;				volume: createVolumeSpecWithMountOption("good-mount-opts", "ro,nfsvers=3", v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						NFS: &v1.NFSVolumeSource{Server: "localhost", Path: "/srv", ReadOnly: false},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				expectedMountList: []string{"ro", "nfsvers=3", "fsid=100", "hard"},
0000000000000000000000000000000000000000;;				systemOptions:     []string{"fsid=100", "hard"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"vol-with-sys-opts-with-dup": {
0000000000000000000000000000000000000000;;				volume: createVolumeSpecWithMountOption("good-mount-opts", "ro,nfsvers=3", v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						NFS: &v1.NFSVolumeSource{Server: "localhost", Path: "/srv", ReadOnly: false},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				expectedMountList: []string{"ro", "nfsvers=3", "fsid=100"},
0000000000000000000000000000000000000000;;				systemOptions:     []string{"fsid=100", "ro"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, scenario := range scenarios {
0000000000000000000000000000000000000000;;			mountOptions := MountOptionFromSpec(scenario.volume, scenario.systemOptions...)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(slice.SortStrings(mountOptions), slice.SortStrings(scenario.expectedMountList)) {
0000000000000000000000000000000000000000;;				t.Errorf("for %s expected mount options : %v got %v", name, scenario.expectedMountList, mountOptions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createVolumeSpecWithMountOption(name string, mountOptions string, spec v1.PersistentVolumeSpec) *Spec {
0000000000000000000000000000000000000000;;		annotations := map[string]string{
0000000000000000000000000000000000000000;;			v1.MountOptionAnnotation: mountOptions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objMeta := metav1.ObjectMeta{
0000000000000000000000000000000000000000;;			Name:        name,
0000000000000000000000000000000000000000;;			Annotations: annotations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: objMeta,
0000000000000000000000000000000000000000;;			Spec:       spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Spec{PersistentVolume: pv}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkFnv32(t *testing.T, s string, expected int) {
0000000000000000000000000000000000000000;;		h := fnv.New32()
0000000000000000000000000000000000000000;;		h.Write([]byte(s))
0000000000000000000000000000000000000000;;		h.Sum32()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if int(h.Sum32()) != expected {
0000000000000000000000000000000000000000;;			t.Fatalf("hash of %q was %v, expected %v", s, h.Sum32(), expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestChooseZoneForVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		checkFnv32(t, "henley", 1180403676)
0000000000000000000000000000000000000000;;		// 1180403676 mod 3 == 0, so the offset from "henley" is 0, which makes it easier to verify this by inspection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A few others
0000000000000000000000000000000000000000;;		checkFnv32(t, "henley-", 2652299129)
0000000000000000000000000000000000000000;;		checkFnv32(t, "henley-a", 1459735322)
0000000000000000000000000000000000000000;;		checkFnv32(t, "", 2166136261)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			Zones      []string
0000000000000000000000000000000000000000;;			VolumeName string
0000000000000000000000000000000000000000;;			Expected   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Test for PVC names that don't have a dash
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley",
0000000000000000000000000000000000000000;;				Expected:   "a", // hash("henley") == 0
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Tests for PVC names that end in - number, but don't look like statefulset PVCs
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley-0",
0000000000000000000000000000000000000000;;				Expected:   "a", // hash("henley") == 0
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley-1",
0000000000000000000000000000000000000000;;				Expected:   "b", // hash("henley") + 1 == 1
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley-2",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("henley") + 2 == 2
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley-3",
0000000000000000000000000000000000000000;;				Expected:   "a", // hash("henley") + 3 == 3 === 0 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley-4",
0000000000000000000000000000000000000000;;				Expected:   "b", // hash("henley") + 4 == 4 === 1 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Tests for PVC names that are edge cases
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley-",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("henley-") = 2652299129 === 2 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "henley-a",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("henley-a") = 1459735322 === 2 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium--1",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("") + 1 == 2166136261 + 1 === 2 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Tests for PVC names for simple StatefulSet cases
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-henley-1",
0000000000000000000000000000000000000000;;				Expected:   "b", // hash("henley") + 1 == 1
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "loud-henley-1",
0000000000000000000000000000000000000000;;				Expected:   "b", // hash("henley") + 1 == 1
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "quiet-henley-2",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("henley") + 2 == 2
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-henley-2",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("henley") + 2 == 2
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-henley-3",
0000000000000000000000000000000000000000;;				Expected:   "a", // hash("henley") + 3 == 3 === 0 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-henley-4",
0000000000000000000000000000000000000000;;				Expected:   "b", // hash("henley") + 4 == 4 === 1 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Tests for statefulsets (or claims) with dashes in the names
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-alpha-henley-2",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("henley") + 2 == 2
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-beta-henley-3",
0000000000000000000000000000000000000000;;				Expected:   "a", // hash("henley") + 3 == 3 === 0 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-gamma-henley-4",
0000000000000000000000000000000000000000;;				Expected:   "b", // hash("henley") + 4 == 4 === 1 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Tests for statefulsets name ending in -
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-henley--2",
0000000000000000000000000000000000000000;;				Expected:   "a", // hash("") + 2 == 0 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-henley--3",
0000000000000000000000000000000000000000;;				Expected:   "b", // hash("") + 3 == 1 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Zones:      []string{"a", "b", "c"},
0000000000000000000000000000000000000000;;				VolumeName: "medium-henley--4",
0000000000000000000000000000000000000000;;				Expected:   "c", // hash("") + 4 == 2 mod 3
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			zonesSet := sets.NewString(test.Zones...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actual := ChooseZoneForVolume(zonesSet, test.VolumeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for actual != test.Expected {
0000000000000000000000000000000000000000;;				t.Errorf("Test %v failed, expected zone %q, actual %q", test, test.Expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestZonesToSet(t *testing.T) {
0000000000000000000000000000000000000000;;		functionUnderTest := "ZonesToSet"
0000000000000000000000000000000000000000;;		// First part: want an error
0000000000000000000000000000000000000000;;		sliceOfZones := []string{"", ",", "us-east-1a, , us-east-1d", ", us-west-1b", "us-west-2b,"}
0000000000000000000000000000000000000000;;		for _, zones := range sliceOfZones {
0000000000000000000000000000000000000000;;			if got, err := ZonesToSet(zones); err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v(%v) returned (%v), want (%v)", functionUnderTest, zones, got, "an error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Second part: want no error
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			zones string
0000000000000000000000000000000000000000;;			want  sets.String
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				zones: "us-east-1a",
0000000000000000000000000000000000000000;;				want:  sets.String{"us-east-1a": sets.Empty{}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				zones: "us-east-1a, us-west-2a",
0000000000000000000000000000000000000000;;				want: sets.String{
0000000000000000000000000000000000000000;;					"us-east-1a": sets.Empty{},
0000000000000000000000000000000000000000;;					"us-west-2a": sets.Empty{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tt := range tests {
0000000000000000000000000000000000000000;;			if got, err := ZonesToSet(tt.zones); err != nil || !got.Equal(tt.want) {
0000000000000000000000000000000000000000;;				t.Errorf("%v(%v) returned (%v), want (%v)", functionUnderTest, tt.zones, got, tt.want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateZone(t *testing.T) {
0000000000000000000000000000000000000000;;		functionUnderTest := "ValidateZone"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First part: want an error
0000000000000000000000000000000000000000;;		errCases := []string{"", " 	 	 "}
0000000000000000000000000000000000000000;;		for _, errCase := range errCases {
0000000000000000000000000000000000000000;;			if got := ValidateZone(errCase); got == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v(%v) returned (%v), want (%v)", functionUnderTest, errCase, got, "an error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Second part: want no error
0000000000000000000000000000000000000000;;		succCases := []string{" us-east-1a	"}
0000000000000000000000000000000000000000;;		for _, succCase := range succCases {
0000000000000000000000000000000000000000;;			if got := ValidateZone(succCase); got != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v(%v) returned (%v), want (%v)", functionUnderTest, succCase, got, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
