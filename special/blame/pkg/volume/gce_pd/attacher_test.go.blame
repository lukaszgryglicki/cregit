0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
dd15e905d9768edbc0fc8d3b82f776c04f2ef4f0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce_pd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceName_Volume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		name := "my-pd-volume"
0000000000000000000000000000000000000000;;		spec := createVolSpec(name, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deviceName != name {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: expected %s, got %s", name, deviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceName_PersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		name := "my-pd-pv"
0000000000000000000000000000000000000000;;		spec := createPVSpec(name, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deviceName != name {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: expected %s, got %s", name, deviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// One testcase for TestAttachDetach table test below
0000000000000000000000000000000000000000;;	type testcase struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// For fake GCE:
0000000000000000000000000000000000000000;;		attach         attachCall
0000000000000000000000000000000000000000;;		detach         detachCall
0000000000000000000000000000000000000000;;		diskIsAttached diskIsAttachedCall
0000000000000000000000000000000000000000;;		t              *testing.T
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Actual test to run
0000000000000000000000000000000000000000;;		test func(test *testcase) error
0000000000000000000000000000000000000000;;		// Expected return of the test
0000000000000000000000000000000000000000;;		expectedReturn error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAttachDetach(t *testing.T) {
0000000000000000000000000000000000000000;;		diskName := "disk"
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("instance")
0000000000000000000000000000000000000000;;		readOnly := false
0000000000000000000000000000000000000000;;		spec := createVolSpec(diskName, readOnly)
0000000000000000000000000000000000000000;;		attachError := errors.New("Fake attach error")
0000000000000000000000000000000000000000;;		detachError := errors.New("Fake detach error")
0000000000000000000000000000000000000000;;		diskCheckError := errors.New("Fake DiskIsAttached error")
0000000000000000000000000000000000000000;;		tests := []testcase{
0000000000000000000000000000000000000000;;			// Successful Attach call
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Attach_Positive",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, nil},
0000000000000000000000000000000000000000;;				attach:         attachCall{diskName, nodeName, readOnly, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					devicePath, err := attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;					if devicePath != "/dev/disk/by-id/google-disk" {
0000000000000000000000000000000000000000;;						return fmt.Errorf("devicePath incorrect. Expected<\"/dev/disk/by-id/google-disk\"> Actual: <%q>", devicePath)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disk is already attached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Attach_Positive_AlreadyAttached",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, true, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					devicePath, err := attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;					if devicePath != "/dev/disk/by-id/google-disk" {
0000000000000000000000000000000000000000;;						return fmt.Errorf("devicePath incorrect. Expected<\"/dev/disk/by-id/google-disk\"> Actual: <%q>", devicePath)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// DiskIsAttached fails and Attach succeeds
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Attach_Positive_CheckFails",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				attach:         attachCall{diskName, nodeName, readOnly, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					devicePath, err := attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;					if devicePath != "/dev/disk/by-id/google-disk" {
0000000000000000000000000000000000000000;;						return fmt.Errorf("devicePath incorrect. Expected<\"/dev/disk/by-id/google-disk\"> Actual: <%q>", devicePath)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Attach call fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Attach_Negative",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				attach:         attachCall{diskName, nodeName, readOnly, attachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					devicePath, err := attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;					if devicePath != "" {
0000000000000000000000000000000000000000;;						return fmt.Errorf("devicePath incorrect. Expected<\"\"> Actual: <%q>", devicePath)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedReturn: attachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, true, nil},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disk is already detached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive_AlreadyDetached",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds when DiskIsAttached fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive_CheckFails",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Negative",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, detachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) error {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedReturn: detachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testcase := range tests {
0000000000000000000000000000000000000000;;			testcase.t = t
0000000000000000000000000000000000000000;;			err := testcase.test(&testcase)
0000000000000000000000000000000000000000;;			if err != testcase.expectedReturn {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed: expected err=%q, got %q", testcase.name, testcase.expectedReturn.Error(), err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("Test %q succeeded", testcase.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPlugin creates a new gcePersistentDiskPlugin with fake cloud, NewAttacher
0000000000000000000000000000000000000000;;	// and NewDetacher won't work.
0000000000000000000000000000000000000000;;	func newPlugin() *gcePersistentDiskPlugin {
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost(
0000000000000000000000000000000000000000;;			"/tmp", /* rootDir */
0000000000000000000000000000000000000000;;			nil,    /* kubeClient */
0000000000000000000000000000000000000000;;			nil /* plugins */)
0000000000000000000000000000000000000000;;		plugins := ProbeVolumePlugins()
0000000000000000000000000000000000000000;;		plugin := plugins[0]
0000000000000000000000000000000000000000;;		plugin.Init(host)
0000000000000000000000000000000000000000;;		return plugin.(*gcePersistentDiskPlugin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAttacher(testcase *testcase) *gcePersistentDiskAttacher {
0000000000000000000000000000000000000000;;		return &gcePersistentDiskAttacher{
0000000000000000000000000000000000000000;;			host:     nil,
0000000000000000000000000000000000000000;;			gceDisks: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDetacher(testcase *testcase) *gcePersistentDiskDetacher {
0000000000000000000000000000000000000000;;		return &gcePersistentDiskDetacher{
0000000000000000000000000000000000000000;;			gceDisks: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createVolSpec(name string, readOnly bool) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;						PDName:   name,
0000000000000000000000000000000000000000;;						ReadOnly: readOnly,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPVSpec(name string, readOnly bool) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			PersistentVolume: &v1.PersistentVolume{
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;							PDName:   name,
0000000000000000000000000000000000000000;;							ReadOnly: readOnly,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake GCE implementation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type attachCall struct {
0000000000000000000000000000000000000000;;		diskName string
0000000000000000000000000000000000000000;;		nodeName types.NodeName
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;		ret      error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type detachCall struct {
0000000000000000000000000000000000000000;;		devicePath string
0000000000000000000000000000000000000000;;		nodeName   types.NodeName
0000000000000000000000000000000000000000;;		ret        error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type diskIsAttachedCall struct {
0000000000000000000000000000000000000000;;		diskName   string
0000000000000000000000000000000000000000;;		nodeName   types.NodeName
0000000000000000000000000000000000000000;;		isAttached bool
0000000000000000000000000000000000000000;;		ret        error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) AttachDisk(diskName string, nodeName types.NodeName, readOnly bool) error {
0000000000000000000000000000000000000000;;		expected := &testcase.attach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.attach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// AttachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;			return errors.New("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected AttachDisk call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected AttachDisk call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.readOnly != readOnly {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected readOnly %v, got %v", expected.readOnly, readOnly)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected AttachDisk call: wrong readOnly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("AttachDisk call: %s, %s, %v, returning %v", diskName, nodeName, readOnly, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DetachDisk(devicePath string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		expected := &testcase.detach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.devicePath == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.detach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// DetachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.devicePath != devicePath {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected devicePath %s, got %s", expected.devicePath, devicePath)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DetachDisk call: %s, %s, returning %v", devicePath, nodeName, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DiskIsAttached(diskName string, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.diskIsAttached
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.diskIsAttached looks uninitialized, test did not expect to
0000000000000000000000000000000000000000;;			// call DiskIsAttached
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DiskIsAttached call: %s, %s, returning %v, %v", diskName, nodeName, expected.isAttached, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.isAttached, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DisksAreAttached(diskNames []string, nodeName types.NodeName) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		return nil, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) CreateDisk(name string, diskType string, zone string, sizeGb int64, tags map[string]string) error {
0000000000000000000000000000000000000000;;		return errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DeleteDisk(diskToDelete string) error {
0000000000000000000000000000000000000000;;		return errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) GetAutoLabelsForPD(name string, zone string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		return map[string]string{}, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
