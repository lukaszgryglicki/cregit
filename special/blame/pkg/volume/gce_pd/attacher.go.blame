0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
588c00aecd2659cef327268d938bb24f3646acb5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gce_pd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type gcePersistentDiskAttacher struct {
0000000000000000000000000000000000000000;;		host     volume.VolumeHost
0000000000000000000000000000000000000000;;		gceDisks gce.Disks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Attacher = &gcePersistentDiskAttacher{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.AttachableVolumePlugin = &gcePersistentDiskPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gcePersistentDiskPlugin) NewAttacher() (volume.Attacher, error) {
0000000000000000000000000000000000000000;;		gceCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &gcePersistentDiskAttacher{
0000000000000000000000000000000000000000;;			host:     plugin.host,
0000000000000000000000000000000000000000;;			gceDisks: gceCloud,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gcePersistentDiskPlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		return mount.GetMountRefs(mounter, deviceMountPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attach checks with the GCE cloud provider if the specified volume is already
0000000000000000000000000000000000000000;;	// attached to the node with the specified Name.
0000000000000000000000000000000000000000;;	// If the volume is attached, it succeeds (returns nil).
0000000000000000000000000000000000000000;;	// If it is not, Attach issues a call to the GCE cloud provider to attach it.
0000000000000000000000000000000000000000;;	// Callers are responsible for retrying on failure.
0000000000000000000000000000000000000000;;	// Callers are responsible for thread safety between concurrent attach and
0000000000000000000000000000000000000000;;	// detach operations.
0000000000000000000000000000000000000000;;	func (attacher *gcePersistentDiskAttacher) Attach(spec *volume.Spec, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdName := volumeSource.PDName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attached, err := attacher.gceDisks.DiskIsAttached(pdName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log error and continue with attach
0000000000000000000000000000000000000000;;			glog.Errorf(
0000000000000000000000000000000000000000;;				"Error checking if PD (%q) is already attached to current node (%q). Will continue and try attach anyway. err=%v",
0000000000000000000000000000000000000000;;				pdName, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil && attached {
0000000000000000000000000000000000000000;;			// Volume is already attached to node.
0000000000000000000000000000000000000000;;			glog.Infof("Attach operation is successful. PD %q is already attached to node %q.", pdName, nodeName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err := attacher.gceDisks.AttachDisk(pdName, nodeName, readOnly); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error attaching PD %q to node %q: %+v", pdName, nodeName, err)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path.Join(diskByIdPath, diskGooglePrefix+pdName), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *gcePersistentDiskAttacher) VolumesAreAttached(specs []*volume.Spec, nodeName types.NodeName) (map[*volume.Spec]bool, error) {
0000000000000000000000000000000000000000;;		volumesAttachedCheck := make(map[*volume.Spec]bool)
0000000000000000000000000000000000000000;;		volumePdNameMap := make(map[string]*volume.Spec)
0000000000000000000000000000000000000000;;		pdNameList := []string{}
0000000000000000000000000000000000000000;;		for _, spec := range specs {
0000000000000000000000000000000000000000;;			volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;			// If error is occured, skip this volume and move to the next one
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error getting volume (%q) source : %v", spec.Name(), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pdNameList = append(pdNameList, volumeSource.PDName)
0000000000000000000000000000000000000000;;			volumesAttachedCheck[spec] = true
0000000000000000000000000000000000000000;;			volumePdNameMap[volumeSource.PDName] = spec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachedResult, err := attacher.gceDisks.DisksAreAttached(pdNameList, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log error and continue with attach
0000000000000000000000000000000000000000;;			glog.Errorf(
0000000000000000000000000000000000000000;;				"Error checking if PDs (%v) are already attached to current node (%q). err=%v",
0000000000000000000000000000000000000000;;				pdNameList, nodeName, err)
0000000000000000000000000000000000000000;;			return volumesAttachedCheck, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for pdName, attached := range attachedResult {
0000000000000000000000000000000000000000;;			if !attached {
0000000000000000000000000000000000000000;;				spec := volumePdNameMap[pdName]
0000000000000000000000000000000000000000;;				volumesAttachedCheck[spec] = false
0000000000000000000000000000000000000000;;				glog.V(2).Infof("VolumesAreAttached: check volume %q (specName: %q) is no longer attached", pdName, spec.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumesAttachedCheck, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *gcePersistentDiskAttacher) WaitForAttach(spec *volume.Spec, devicePath string, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(checkSleepDuration)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		timer := time.NewTimer(timeout)
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdName := volumeSource.PDName
0000000000000000000000000000000000000000;;		partition := ""
0000000000000000000000000000000000000000;;		if volumeSource.Partition != 0 {
0000000000000000000000000000000000000000;;			partition = strconv.Itoa(int(volumeSource.Partition))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sdBefore, err := filepath.Glob(diskSDPattern)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error filepath.Glob(\"%s\"): %v\r\n", diskSDPattern, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sdBeforeSet := sets.NewString(sdBefore...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		devicePaths := getDiskByIdPaths(pdName, partition)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Checking GCE PD %q is attached.", pdName)
0000000000000000000000000000000000000000;;				path, err := verifyDevicePath(devicePaths, sdBeforeSet)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Log error, if any, and continue checking periodically. See issue #11321
0000000000000000000000000000000000000000;;					glog.Errorf("Error verifying GCE PD (%q) is attached: %v", pdName, err)
0000000000000000000000000000000000000000;;				} else if path != "" {
0000000000000000000000000000000000000000;;					// A device path has successfully been created for the PD
0000000000000000000000000000000000000000;;					glog.Infof("Successfully found attached GCE PD %q.", pdName)
0000000000000000000000000000000000000000;;					return path, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer.C:
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("Could not find attached GCE PD %q. Timeout waiting for mount paths to be created.", pdName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *gcePersistentDiskAttacher) GetDeviceMountPath(
0000000000000000000000000000000000000000;;		spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return makeGlobalPDName(attacher.host, volumeSource.PDName), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *gcePersistentDiskAttacher) MountDevice(spec *volume.Spec, devicePath string, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		// Only mount the PD globally once.
0000000000000000000000000000000000000000;;		mounter := attacher.host.GetMounter()
0000000000000000000000000000000000000000;;		notMnt, err := mounter.IsLikelyNotMountPoint(deviceMountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(deviceMountPath, 0750); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSource, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;		if readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			diskMounter := &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()}
0000000000000000000000000000000000000000;;			mountOptions := volume.MountOptionFromSpec(spec, options...)
0000000000000000000000000000000000000000;;			err = diskMounter.FormatAndMount(devicePath, deviceMountPath, volumeSource.FSType, mountOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				os.Remove(deviceMountPath)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("formatting spec %v devicePath %v deviceMountPath %v fs %v with options %+v", spec.Name(), devicePath, deviceMountPath, volumeSource.FSType, options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type gcePersistentDiskDetacher struct {
0000000000000000000000000000000000000000;;		host     volume.VolumeHost
0000000000000000000000000000000000000000;;		gceDisks gce.Disks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Detacher = &gcePersistentDiskDetacher{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gcePersistentDiskPlugin) NewDetacher() (volume.Detacher, error) {
0000000000000000000000000000000000000000;;		gceCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &gcePersistentDiskDetacher{
0000000000000000000000000000000000000000;;			host:     plugin.host,
0000000000000000000000000000000000000000;;			gceDisks: gceCloud,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detach checks with the GCE cloud provider if the specified volume is already
0000000000000000000000000000000000000000;;	// attached to the specified node. If the volume is not attached, it succeeds
0000000000000000000000000000000000000000;;	// (returns nil). If it is attached, Detach issues a call to the GCE cloud
0000000000000000000000000000000000000000;;	// provider to attach it.
0000000000000000000000000000000000000000;;	// Callers are responsible for retrying on failure.
0000000000000000000000000000000000000000;;	// Callers are responsible for thread safety between concurrent attach and detach
0000000000000000000000000000000000000000;;	// operations.
0000000000000000000000000000000000000000;;	func (detacher *gcePersistentDiskDetacher) Detach(deviceMountPath string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		pdName := path.Base(deviceMountPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attached, err := detacher.gceDisks.DiskIsAttached(pdName, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log error and continue with detach
0000000000000000000000000000000000000000;;			glog.Errorf(
0000000000000000000000000000000000000000;;				"Error checking if PD (%q) is already attached to current node (%q). Will continue and try detach anyway. err=%v",
0000000000000000000000000000000000000000;;				pdName, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil && !attached {
0000000000000000000000000000000000000000;;			// Volume is not attached to node. Success!
0000000000000000000000000000000000000000;;			glog.Infof("Detach operation is successful. PD %q was not attached to node %q.", pdName, nodeName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = detacher.gceDisks.DetachDisk(pdName, nodeName); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error detaching PD %q from node %q: %v", pdName, nodeName, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (detacher *gcePersistentDiskDetacher) UnmountDevice(deviceMountPath string) error {
0000000000000000000000000000000000000000;;		return volumeutil.UnmountPath(deviceMountPath, detacher.host.GetMounter())
0000000000000000000000000000000000000000;;	}
