0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
786be53ab2bb3f160a2b603b450e34122308ff03;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package projected
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/configmap"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/downwardapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/secret"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeVolumePlugins is the entry point for plugin detection in a package.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&projectedPlugin{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		projectedPluginName = "kubernetes.io/projected"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type projectedPlugin struct {
0000000000000000000000000000000000000000;;		host         volume.VolumeHost
0000000000000000000000000000000000000000;;		getSecret    func(namespace, name string) (*v1.Secret, error)
0000000000000000000000000000000000000000;;		getConfigMap func(namespace, name string) (*v1.ConfigMap, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &projectedPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrappedVolumeSpec() volume.Spec {
0000000000000000000000000000000000000000;;		return volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					EmptyDir: &v1.EmptyDirVolumeSource{Medium: v1.StorageMediumMemory},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPath(uid types.UID, volName string, host volume.VolumeHost) string {
0000000000000000000000000000000000000000;;		return host.GetPodVolumeDir(uid, utilstrings.EscapeQualifiedNameForDisk(projectedPluginName), volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		plugin.getSecret = host.GetSecretFunc()
0000000000000000000000000000000000000000;;		plugin.getConfigMap = host.GetConfigMapFunc()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return projectedPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		_, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return spec.Volume != nil && spec.Volume.Projected != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return &projectedVolumeMounter{
0000000000000000000000000000000000000000;;			projectedVolume: &projectedVolume{
0000000000000000000000000000000000000000;;				volName: spec.Name(),
0000000000000000000000000000000000000000;;				sources: spec.Volume.Projected.Sources,
0000000000000000000000000000000000000000;;				podUID:  pod.UID,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			source: *spec.Volume.Projected,
0000000000000000000000000000000000000000;;			pod:    pod,
0000000000000000000000000000000000000000;;			opts:   &opts,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &projectedVolumeUnmounter{
0000000000000000000000000000000000000000;;			&projectedVolume{
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *projectedPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		projectedVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				Projected: &v1.ProjectedVolumeSource{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(projectedVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type projectedVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		sources []v1.VolumeProjection
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		plugin  *projectedPlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Volume = &projectedVolume{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv *projectedVolume) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(sv.podUID, sv.volName, sv.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type projectedVolumeMounter struct {
0000000000000000000000000000000000000000;;		*projectedVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		source v1.ProjectedVolumeSource
0000000000000000000000000000000000000000;;		pod    *v1.Pod
0000000000000000000000000000000000000000;;		opts   *volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &projectedVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv *projectedVolume) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        true,
0000000000000000000000000000000000000000;;			Managed:         true,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (s *projectedVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *projectedVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return s.SetUpAt(s.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *projectedVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Setting up volume %v for pod %v at %v", s.volName, s.pod.UID, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wrapped, err := s.plugin.host.NewWrapperMounter(s.volName, wrappedVolumeSpec(), s.pod, *s.opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wrapped.SetUpAt(dir, fsGroup); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := s.collectData()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error preparing data for projected volume %v for pod %v/%v: %s", s.volName, s.pod.Namespace, s.pod.Name, err.Error())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writerContext := fmt.Sprintf("pod %v/%v volume %v", s.pod.Namespace, s.pod.Name, s.volName)
0000000000000000000000000000000000000000;;		writer, err := volumeutil.NewAtomicWriter(dir, writerContext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error creating atomic writer: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = writer.Write(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error writing payload to dir: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = volume.SetVolumeOwnership(s, fsGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error applying volume ownership settings for group: %v", fsGroup)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *projectedVolumeMounter) collectData() (map[string]volumeutil.FileProjection, error) {
0000000000000000000000000000000000000000;;		if s.source.DefaultMode == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No defaultMode used, not even the default value for it")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeClient := s.plugin.host.GetKubeClient()
0000000000000000000000000000000000000000;;		if kubeClient == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Cannot setup projected volume %v because kube client is not configured", s.volName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errlist := []error{}
0000000000000000000000000000000000000000;;		payload := make(map[string]volumeutil.FileProjection)
0000000000000000000000000000000000000000;;		for _, source := range s.source.Sources {
0000000000000000000000000000000000000000;;			if source.Secret != nil {
0000000000000000000000000000000000000000;;				optional := source.Secret.Optional != nil && *source.Secret.Optional
0000000000000000000000000000000000000000;;				secretapi, err := s.plugin.getSecret(s.pod.Namespace, source.Secret.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !(errors.IsNotFound(err) && optional) {
0000000000000000000000000000000000000000;;						glog.Errorf("Couldn't get secret %v/%v: %v", s.pod.Namespace, source.Secret.Name, err)
0000000000000000000000000000000000000000;;						errlist = append(errlist, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					secretapi = &v1.Secret{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Namespace: s.pod.Namespace,
0000000000000000000000000000000000000000;;							Name:      source.Secret.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				secretPayload, err := secret.MakePayload(source.Secret.Items, secretapi, s.source.DefaultMode, optional)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Couldn't get secret payload %v/%v: %v", s.pod.Namespace, source.Secret.Name, err)
0000000000000000000000000000000000000000;;					errlist = append(errlist, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range secretPayload {
0000000000000000000000000000000000000000;;					payload[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if source.ConfigMap != nil {
0000000000000000000000000000000000000000;;				optional := source.ConfigMap.Optional != nil && *source.ConfigMap.Optional
0000000000000000000000000000000000000000;;				configMap, err := s.plugin.getConfigMap(s.pod.Namespace, source.ConfigMap.Name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !(errors.IsNotFound(err) && optional) {
0000000000000000000000000000000000000000;;						glog.Errorf("Couldn't get configMap %v/%v: %v", s.pod.Namespace, source.ConfigMap.Name, err)
0000000000000000000000000000000000000000;;						errlist = append(errlist, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					configMap = &v1.ConfigMap{
0000000000000000000000000000000000000000;;						ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;							Namespace: s.pod.Namespace,
0000000000000000000000000000000000000000;;							Name:      source.ConfigMap.Name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				configMapPayload, err := configmap.MakePayload(source.ConfigMap.Items, configMap, s.source.DefaultMode, optional)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Couldn't get configMap payload %v/%v: %v", s.pod.Namespace, source.ConfigMap.Name, err)
0000000000000000000000000000000000000000;;					errlist = append(errlist, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range configMapPayload {
0000000000000000000000000000000000000000;;					payload[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if source.DownwardAPI != nil {
0000000000000000000000000000000000000000;;				downwardAPIPayload, err := downwardapi.CollectData(source.DownwardAPI.Items, s.pod, s.plugin.host, s.source.DefaultMode)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errlist = append(errlist, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for k, v := range downwardAPIPayload {
0000000000000000000000000000000000000000;;					payload[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return payload, utilerrors.NewAggregate(errlist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sortLines(values string) string {
0000000000000000000000000000000000000000;;		splitted := strings.Split(values, "\n")
0000000000000000000000000000000000000000;;		sort.Strings(splitted)
0000000000000000000000000000000000000000;;		return strings.Join(splitted, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type projectedVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*projectedVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &projectedVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *projectedVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *projectedVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Tearing down volume %v for pod %v at %v", c.volName, c.podUID, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wrapped, err := c.plugin.host.NewWrapperUnmounter(c.volName, wrappedVolumeSpec(), c.podUID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wrapped.TearDownAt(dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.ProjectedVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		var readOnly bool
0000000000000000000000000000000000000000;;		var volumeSource *v1.ProjectedVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.Projected != nil {
0000000000000000000000000000000000000000;;			volumeSource = spec.Volume.Projected
0000000000000000000000000000000000000000;;			readOnly = spec.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource, readOnly, fmt.Errorf("Spec does not reference a projected volume type")
0000000000000000000000000000000000000000;;	}
