0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2e641106a0cfa90394b63d17e63f0aaa7d797934;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cephfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&cephfsPlugin{nil}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cephfsPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &cephfsPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cephfsPluginName = "kubernetes.io/cephfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return cephfsPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v", volumeSource.Monitors), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.Volume != nil && spec.Volume.CephFS != nil) || (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.CephFS != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;			v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;			v1.ReadWriteMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		cephvs, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secret := ""
0000000000000000000000000000000000000000;;		if cephvs.SecretRef != nil {
0000000000000000000000000000000000000000;;			kubeClient := plugin.host.GetKubeClient()
0000000000000000000000000000000000000000;;			if kubeClient == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Cannot get kube client")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			secretName, err := kubeClient.Core().Secrets(pod.Namespace).Get(cephvs.SecretRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Couldn't get secret %v/%v err: %v", pod.Namespace, cephvs.SecretRef, err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for name, data := range secretName.Data {
0000000000000000000000000000000000000000;;				secret = string(data)
0000000000000000000000000000000000000000;;				glog.V(4).Infof("found ceph secret info: %s", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, plugin.host.GetMounter(), secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, mounter mount.Interface, secret string) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		cephvs, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := cephvs.User
0000000000000000000000000000000000000000;;		if id == "" {
0000000000000000000000000000000000000000;;			id = "admin"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path := cephvs.Path
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			path = "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(path, "/") {
0000000000000000000000000000000000000000;;			path = "/" + path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secret_file := cephvs.SecretFile
0000000000000000000000000000000000000000;;		if secret_file == "" {
0000000000000000000000000000000000000000;;			secret_file = "/etc/ceph/" + id + ".secret"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &cephfsMounter{
0000000000000000000000000000000000000000;;			cephfs: &cephfs{
0000000000000000000000000000000000000000;;				podUID:       podUID,
0000000000000000000000000000000000000000;;				volName:      spec.Name(),
0000000000000000000000000000000000000000;;				mon:          cephvs.Monitors,
0000000000000000000000000000000000000000;;				path:         path,
0000000000000000000000000000000000000000;;				secret:       secret,
0000000000000000000000000000000000000000;;				id:           id,
0000000000000000000000000000000000000000;;				secret_file:  secret_file,
0000000000000000000000000000000000000000;;				readonly:     cephvs.ReadOnly,
0000000000000000000000000000000000000000;;				mounter:      mounter,
0000000000000000000000000000000000000000;;				plugin:       plugin,
0000000000000000000000000000000000000000;;				mountOptions: volume.MountOptionFromSpec(spec),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) newUnmounterInternal(volName string, podUID types.UID, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &cephfsUnmounter{
0000000000000000000000000000000000000000;;			cephfs: &cephfs{
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				mounter: mounter,
0000000000000000000000000000000000000000;;				plugin:  plugin},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *cephfsPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		cephfsVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				CephFS: &v1.CephFSVolumeSource{
0000000000000000000000000000000000000000;;					Monitors: []string{},
0000000000000000000000000000000000000000;;					Path:     volumeName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(cephfsVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CephFS volumes represent a bare host file or directory mount of an CephFS export.
0000000000000000000000000000000000000000;;	type cephfs struct {
0000000000000000000000000000000000000000;;		volName     string
0000000000000000000000000000000000000000;;		podUID      types.UID
0000000000000000000000000000000000000000;;		mon         []string
0000000000000000000000000000000000000000;;		path        string
0000000000000000000000000000000000000000;;		id          string
0000000000000000000000000000000000000000;;		secret      string
0000000000000000000000000000000000000000;;		secret_file string
0000000000000000000000000000000000000000;;		readonly    bool
0000000000000000000000000000000000000000;;		mounter     mount.Interface
0000000000000000000000000000000000000000;;		plugin      *cephfsPlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;		mountOptions []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cephfsMounter struct {
0000000000000000000000000000000000000000;;		*cephfs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &cephfsMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cephfsVolume *cephfsMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        cephfsVolume.readonly,
0000000000000000000000000000000000000000;;			Managed:         false,
0000000000000000000000000000000000000000;;			SupportsSELinux: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (cephfsMounter *cephfsMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (cephfsVolume *cephfsMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return cephfsVolume.SetUpAt(cephfsVolume.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (cephfsVolume *cephfsMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		notMnt, err := cephfsVolume.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("CephFS mount set up: %s %v %v", dir, !notMnt, err)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.MkdirAll(dir, 0750)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = cephfsVolume.execMount(dir)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cleanup upon failure
0000000000000000000000000000000000000000;;		util.UnmountPath(dir, cephfsVolume.mounter)
0000000000000000000000000000000000000000;;		// return error
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cephfsUnmounter struct {
0000000000000000000000000000000000000000;;		*cephfs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &cephfsUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDown unmounts the bind mount
0000000000000000000000000000000000000000;;	func (cephfsVolume *cephfsUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return cephfsVolume.TearDownAt(cephfsVolume.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDownAt unmounts the bind mount
0000000000000000000000000000000000000000;;	func (cephfsVolume *cephfsUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return util.UnmountPath(dir, cephfsVolume.mounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GatePath creates global mount path
0000000000000000000000000000000000000000;;	func (cephfsVolume *cephfs) GetPath() string {
0000000000000000000000000000000000000000;;		name := cephfsPluginName
0000000000000000000000000000000000000000;;		return cephfsVolume.plugin.host.GetPodVolumeDir(cephfsVolume.podUID, utilstrings.EscapeQualifiedNameForDisk(name), cephfsVolume.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cephfsVolume *cephfs) execMount(mountpoint string) error {
0000000000000000000000000000000000000000;;		// cephfs mount option
0000000000000000000000000000000000000000;;		ceph_opt := ""
0000000000000000000000000000000000000000;;		// override secretfile if secret is provided
0000000000000000000000000000000000000000;;		if cephfsVolume.secret != "" {
0000000000000000000000000000000000000000;;			ceph_opt = "name=" + cephfsVolume.id + ",secret=" + cephfsVolume.secret
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ceph_opt = "name=" + cephfsVolume.id + ",secretfile=" + cephfsVolume.secret_file
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// build option array
0000000000000000000000000000000000000000;;		opt := []string{}
0000000000000000000000000000000000000000;;		if cephfsVolume.readonly {
0000000000000000000000000000000000000000;;			opt = append(opt, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opt = append(opt, ceph_opt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build src like mon1:6789,mon2:6789,mon3:6789:/
0000000000000000000000000000000000000000;;		hosts := cephfsVolume.mon
0000000000000000000000000000000000000000;;		l := len(hosts)
0000000000000000000000000000000000000000;;		// pass all monitors and let ceph randomize and fail over
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		src := ""
0000000000000000000000000000000000000000;;		for i = 0; i < l-1; i++ {
0000000000000000000000000000000000000000;;			src += hosts[i] + ","
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		src += hosts[i] + ":" + cephfsVolume.path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountOptions := volume.JoinMountOptions(cephfsVolume.mountOptions, opt)
0000000000000000000000000000000000000000;;		if err := cephfsVolume.mounter.Mount(src, mountpoint, "ceph", mountOptions); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CephFS: mount failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.CephFSVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.CephFS != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.CephFS, spec.Volume.CephFS.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.CephFS != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.CephFS, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a CephFS volume type")
0000000000000000000000000000000000000000;;	}
