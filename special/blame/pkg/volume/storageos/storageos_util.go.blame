0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
bed3bbbd20d07cd2188d11c1be163c46f1d22c8d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storageos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		storageosapi "github.com/storageos/go-api"
0000000000000000000000000000000000000000;;		storageostypes "github.com/storageos/go-api/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		losetupPath = "losetup"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modeBlock deviceType = iota
0000000000000000000000000000000000000000;;		modeFile
0000000000000000000000000000000000000000;;		modeUnsupported
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrDeviceNotFound     = "device not found"
0000000000000000000000000000000000000000;;		ErrDeviceNotSupported = "device not supported"
0000000000000000000000000000000000000000;;		ErrNotAvailable       = "not available"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deviceType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// storageosVolume describes a provisioned volume
0000000000000000000000000000000000000000;;	type storageosVolume struct {
0000000000000000000000000000000000000000;;		ID          string
0000000000000000000000000000000000000000;;		Name        string
0000000000000000000000000000000000000000;;		Namespace   string
0000000000000000000000000000000000000000;;		Description string
0000000000000000000000000000000000000000;;		Pool        string
0000000000000000000000000000000000000000;;		SizeGB      int
0000000000000000000000000000000000000000;;		Labels      map[string]string
0000000000000000000000000000000000000000;;		FSType      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageosAPIConfig struct {
0000000000000000000000000000000000000000;;		apiAddr    string
0000000000000000000000000000000000000000;;		apiUser    string
0000000000000000000000000000000000000000;;		apiPass    string
0000000000000000000000000000000000000000;;		apiVersion string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type apiImplementer interface {
0000000000000000000000000000000000000000;;		Volume(namespace string, ref string) (*storageostypes.Volume, error)
0000000000000000000000000000000000000000;;		VolumeCreate(opts storageostypes.VolumeCreateOptions) (*storageostypes.Volume, error)
0000000000000000000000000000000000000000;;		VolumeMount(opts storageostypes.VolumeMountOptions) error
0000000000000000000000000000000000000000;;		VolumeUnmount(opts storageostypes.VolumeUnmountOptions) error
0000000000000000000000000000000000000000;;		VolumeDelete(opt storageostypes.DeleteOptions) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// storageosUtil is the utility structure to interact with the StorageOS API.
0000000000000000000000000000000000000000;;	type storageosUtil struct {
0000000000000000000000000000000000000000;;		api apiImplementer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *storageosUtil) NewAPI(apiCfg *storageosAPIConfig) error {
0000000000000000000000000000000000000000;;		if u.api != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiCfg == nil {
0000000000000000000000000000000000000000;;			apiCfg = &storageosAPIConfig{
0000000000000000000000000000000000000000;;				apiAddr:    defaultAPIAddress,
0000000000000000000000000000000000000000;;				apiUser:    defaultAPIUser,
0000000000000000000000000000000000000000;;				apiPass:    defaultAPIPassword,
0000000000000000000000000000000000000000;;				apiVersion: defaultAPIVersion,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Using default StorageOS API settings: addr %s, version: %s", apiCfg.apiAddr, defaultAPIVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		api, err := storageosapi.NewVersionedClient(apiCfg.apiAddr, defaultAPIVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		api.SetAuth(apiCfg.apiUser, apiCfg.apiPass)
0000000000000000000000000000000000000000;;		u.api = api
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a new StorageOS volume and makes it available as a device within
0000000000000000000000000000000000000000;;	// /var/lib/storageos/volumes.
0000000000000000000000000000000000000000;;	func (u *storageosUtil) CreateVolume(p *storageosProvisioner) (*storageosVolume, error) {
0000000000000000000000000000000000000000;;		if err := u.NewAPI(p.apiCfg); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.labels == nil {
0000000000000000000000000000000000000000;;			p.labels = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts := storageostypes.VolumeCreateOptions{
0000000000000000000000000000000000000000;;			Name:        p.volName,
0000000000000000000000000000000000000000;;			Size:        p.sizeGB,
0000000000000000000000000000000000000000;;			Description: p.description,
0000000000000000000000000000000000000000;;			Pool:        p.pool,
0000000000000000000000000000000000000000;;			FSType:      p.fsType,
0000000000000000000000000000000000000000;;			Namespace:   p.volNamespace,
0000000000000000000000000000000000000000;;			Labels:      p.labels,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := u.api.VolumeCreate(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("volume create failed for volume %q (%v)", opts.Name, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &storageosVolume{
0000000000000000000000000000000000000000;;			ID:          vol.ID,
0000000000000000000000000000000000000000;;			Name:        vol.Name,
0000000000000000000000000000000000000000;;			Namespace:   vol.Namespace,
0000000000000000000000000000000000000000;;			Description: vol.Description,
0000000000000000000000000000000000000000;;			Pool:        vol.Pool,
0000000000000000000000000000000000000000;;			FSType:      vol.FSType,
0000000000000000000000000000000000000000;;			SizeGB:      int(vol.Size),
0000000000000000000000000000000000000000;;			Labels:      vol.Labels,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attach exposes a volume on the host as a block device.  StorageOS uses a
0000000000000000000000000000000000000000;;	// global namespace, so if the volume exists, it should already be available as
0000000000000000000000000000000000000000;;	// a device within `/var/lib/storageos/volumes/<id>`.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Depending on the host capabilities, the device may be either a block device
0000000000000000000000000000000000000000;;	// or a file device.  Block devices can be used directly, but file devices must
0000000000000000000000000000000000000000;;	// be made accessible as a block device before using.
0000000000000000000000000000000000000000;;	func (u *storageosUtil) AttachVolume(b *storageosMounter) (string, error) {
0000000000000000000000000000000000000000;;		if err := u.NewAPI(b.apiCfg); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := u.api.Volume(b.volNamespace, b.volName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("volume retrieve failed for volume %q with namespace %q (%v)", b.volName, b.volNamespace, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clear any existing mount reference from the API.  These may be leftover
0000000000000000000000000000000000000000;;		// from previous mounts where the unmount operation couldn't get access to
0000000000000000000000000000000000000000;;		// the API credentials.
0000000000000000000000000000000000000000;;		if vol.Mounted {
0000000000000000000000000000000000000000;;			opts := storageostypes.VolumeUnmountOptions{
0000000000000000000000000000000000000000;;				Name:      vol.Name,
0000000000000000000000000000000000000000;;				Namespace: vol.Namespace,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := u.api.VolumeUnmount(opts); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Couldn't clear existing StorageOS mount reference: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srcPath := path.Join(b.devicePath, vol.ID)
0000000000000000000000000000000000000000;;		dt, err := pathDeviceType(srcPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("volume source path %q for volume %q not ready (%v)", srcPath, b.volName, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch dt {
0000000000000000000000000000000000000000;;		case modeBlock:
0000000000000000000000000000000000000000;;			return srcPath, nil
0000000000000000000000000000000000000000;;		case modeFile:
0000000000000000000000000000000000000000;;			return attachFileDevice(srcPath)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(ErrDeviceNotSupported)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detach detaches a volume from the host.  This is only needed when NBD is not
0000000000000000000000000000000000000000;;	// enabled and loop devices are used to simulate a block device.
0000000000000000000000000000000000000000;;	func (u *storageosUtil) DetachVolume(b *storageosUnmounter, devicePath string) error {
0000000000000000000000000000000000000000;;		if !isLoopDevice(devicePath) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(devicePath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return removeLoopDevice(devicePath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mount mounts the volume on the host.
0000000000000000000000000000000000000000;;	func (u *storageosUtil) MountVolume(b *storageosMounter, mntDevice, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(deviceMountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				if err = os.MkdirAll(deviceMountPath, 0750); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = os.MkdirAll(deviceMountPath, 0750); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("mkdir failed on disk %s (%v)", deviceMountPath, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			err = b.diskMounter.FormatAndMount(mntDevice, deviceMountPath, b.fsType, options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				os.Remove(deviceMountPath)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := u.NewAPI(b.apiCfg); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := storageostypes.VolumeMountOptions{
0000000000000000000000000000000000000000;;			Name:       b.volName,
0000000000000000000000000000000000000000;;			Namespace:  b.volNamespace,
0000000000000000000000000000000000000000;;			FsType:     b.fsType,
0000000000000000000000000000000000000000;;			Mountpoint: deviceMountPath,
0000000000000000000000000000000000000000;;			Client:     b.plugin.host.GetHostName(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.api.VolumeMount(opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmount removes the mount reference from the volume allowing it to be
0000000000000000000000000000000000000000;;	// re-mounted elsewhere.
0000000000000000000000000000000000000000;;	func (u *storageosUtil) UnmountVolume(b *storageosUnmounter) error {
0000000000000000000000000000000000000000;;		if err := u.NewAPI(b.apiCfg); err != nil {
0000000000000000000000000000000000000000;;			// We can't always get the config we need, so allow the unmount to
0000000000000000000000000000000000000000;;			// succeed even if we can't remove the mount reference from the API.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Could not remove mount reference in the StorageOS API as no credentials available to the unmount operation")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := storageostypes.VolumeUnmountOptions{
0000000000000000000000000000000000000000;;			Name:      b.volName,
0000000000000000000000000000000000000000;;			Namespace: b.volNamespace,
0000000000000000000000000000000000000000;;			Client:    b.plugin.host.GetHostName(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.api.VolumeUnmount(opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes a StorageOS volume.  Assumes it has already been unmounted and detached.
0000000000000000000000000000000000000000;;	func (u *storageosUtil) DeleteVolume(d *storageosDeleter) error {
0000000000000000000000000000000000000000;;		if err := u.NewAPI(d.apiCfg); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deletes must be forced as the StorageOS API will not normally delete
0000000000000000000000000000000000000000;;		// volumes that it thinks are mounted.  We can't be sure the unmount was
0000000000000000000000000000000000000000;;		// registered via the API so we trust k8s to only delete volumes it knows
0000000000000000000000000000000000000000;;		// are unmounted.
0000000000000000000000000000000000000000;;		opts := storageostypes.DeleteOptions{
0000000000000000000000000000000000000000;;			Name:      d.volName,
0000000000000000000000000000000000000000;;			Namespace: d.volNamespace,
0000000000000000000000000000000000000000;;			Force:     true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.api.VolumeDelete(opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pathMode returns the FileMode for a path.
0000000000000000000000000000000000000000;;	func pathDeviceType(path string) (deviceType, error) {
0000000000000000000000000000000000000000;;		fi, err := os.Stat(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return modeUnsupported, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch mode := fi.Mode(); {
0000000000000000000000000000000000000000;;		case mode&os.ModeDevice != 0:
0000000000000000000000000000000000000000;;			return modeBlock, nil
0000000000000000000000000000000000000000;;		case mode.IsRegular():
0000000000000000000000000000000000000000;;			return modeFile, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return modeUnsupported, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// attachFileDevice takes a path to a regular file and makes it available as an
0000000000000000000000000000000000000000;;	// attached block device.
0000000000000000000000000000000000000000;;	func attachFileDevice(path string) (string, error) {
0000000000000000000000000000000000000000;;		blockDevicePath, err := getLoopDevice(path)
0000000000000000000000000000000000000000;;		if err != nil && err.Error() != ErrDeviceNotFound {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If no existing loop device for the path, create one
0000000000000000000000000000000000000000;;		if blockDevicePath == "" {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Creating device for path: %s", path)
0000000000000000000000000000000000000000;;			blockDevicePath, err = makeLoopDevice(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return blockDevicePath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the full path to the loop device associated with the given path.
0000000000000000000000000000000000000000;;	func getLoopDevice(path string) (string, error) {
0000000000000000000000000000000000000000;;		_, err := os.Stat(path)
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return "", errors.New(ErrNotAvailable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("not attachable: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exec := exec.New()
0000000000000000000000000000000000000000;;		args := []string{"-j", path}
0000000000000000000000000000000000000000;;		out, err := exec.Command(losetupPath, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed device discover command for path %s: %v", path, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseLosetupOutputForDevice(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLoopDevice(path string) (string, error) {
0000000000000000000000000000000000000000;;		exec := exec.New()
0000000000000000000000000000000000000000;;		args := []string{"-f", "--show", path}
0000000000000000000000000000000000000000;;		out, err := exec.Command(losetupPath, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Failed device create command for path %s: %v", path, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseLosetupOutputForDevice(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeLoopDevice(device string) error {
0000000000000000000000000000000000000000;;		exec := exec.New()
0000000000000000000000000000000000000000;;		args := []string{"-d", device}
0000000000000000000000000000000000000000;;		out, err := exec.Command(losetupPath, args...).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !strings.Contains(string(out), "No such device or address") {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isLoopDevice(device string) bool {
0000000000000000000000000000000000000000;;		return strings.HasPrefix(device, "/dev/loop")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseLosetupOutputForDevice(output []byte) (string, error) {
0000000000000000000000000000000000000000;;		if len(output) == 0 {
0000000000000000000000000000000000000000;;			return "", errors.New(ErrDeviceNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// losetup returns device in the format:
0000000000000000000000000000000000000000;;		// /dev/loop1: [0073]:148662 (/var/lib/storageos/volumes/308f14af-cf0a-08ff-c9c3-b48104318e05)
0000000000000000000000000000000000000000;;		device := strings.TrimSpace(strings.SplitN(string(output), ":", 2)[0])
0000000000000000000000000000000000000000;;		if len(device) == 0 {
0000000000000000000000000000000000000000;;			return "", errors.New(ErrDeviceNotFound)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return device, nil
0000000000000000000000000000000000000000;;	}
