0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
bed3bbbd20d07cd2188d11c1be163c46f1d22c8d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storageos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		kstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeVolumePlugins is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&storageosPlugin{nil}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageosPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &storageosPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &storageosPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &storageosPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &storageosPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		storageosPluginName = "kubernetes.io/storageos"
0000000000000000000000000000000000000000;;		storageosDevicePath = "/var/lib/storageos/volumes"
0000000000000000000000000000000000000000;;		defaultAPIAddress   = "tcp://localhost:5705"
0000000000000000000000000000000000000000;;		defaultAPIUser      = "storageos"
0000000000000000000000000000000000000000;;		defaultAPIPassword  = "storageos"
0000000000000000000000000000000000000000;;		defaultAPIVersion   = "1"
0000000000000000000000000000000000000000;;		defaultFSType       = "ext4"
0000000000000000000000000000000000000000;;		defaultNamespace    = "default"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPath(uid types.UID, volNamespace string, volName string, pvName string, host volume.VolumeHost) string {
0000000000000000000000000000000000000000;;		if len(volNamespace) != 0 && len(volName) != 0 && strings.Count(volName, ".") == 0 {
0000000000000000000000000000000000000000;;			return host.GetPodVolumeDir(uid, kstrings.EscapeQualifiedNameForDisk(storageosPluginName), pvName+"."+volNamespace+"."+volName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host.GetPodVolumeDir(uid, kstrings.EscapeQualifiedNameForDisk(storageosPluginName), pvName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return storageosPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s", volumeSource.VolumeNamespace, volumeSource.VolumeName), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.StorageOS != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.StorageOS != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;			v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiCfg, err := getAPICfg(spec, pod, plugin.host.GetKubeClient())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod, apiCfg, &storageosUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) newMounterInternal(spec *volume.Spec, pod *v1.Pod, apiCfg *storageosAPIConfig, manager storageosManager, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volName, volNamespace, fsType, readOnly, err := getVolumeInfoFromSpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &storageosMounter{
0000000000000000000000000000000000000000;;			storageos: &storageos{
0000000000000000000000000000000000000000;;				podUID:          pod.UID,
0000000000000000000000000000000000000000;;				podNamespace:    pod.GetNamespace(),
0000000000000000000000000000000000000000;;				pvName:          spec.Name(),
0000000000000000000000000000000000000000;;				volName:         volName,
0000000000000000000000000000000000000000;;				volNamespace:    volNamespace,
0000000000000000000000000000000000000000;;				fsType:          fsType,
0000000000000000000000000000000000000000;;				readOnly:        readOnly,
0000000000000000000000000000000000000000;;				apiCfg:          apiCfg,
0000000000000000000000000000000000000000;;				manager:         manager,
0000000000000000000000000000000000000000;;				mounter:         mounter,
0000000000000000000000000000000000000000;;				plugin:          plugin,
0000000000000000000000000000000000000000;;				MetricsProvider: volume.NewMetricsStatFS(getPath(pod.UID, volNamespace, volName, spec.Name(), plugin.host)),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			devicePath:  storageosDevicePath,
0000000000000000000000000000000000000000;;			diskMounter: &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) NewUnmounter(pvName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(pvName, podUID, &storageosUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) newUnmounterInternal(pvName string, podUID types.UID, manager storageosManager, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse volume namespace & name from mountpoint if mounted
0000000000000000000000000000000000000000;;		volNamespace, volName, err := getVolumeInfo(pvName, podUID, plugin.host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &storageosUnmounter{
0000000000000000000000000000000000000000;;			storageos: &storageos{
0000000000000000000000000000000000000000;;				podUID:          podUID,
0000000000000000000000000000000000000000;;				pvName:          pvName,
0000000000000000000000000000000000000000;;				volName:         volName,
0000000000000000000000000000000000000000;;				volNamespace:    volNamespace,
0000000000000000000000000000000000000000;;				manager:         manager,
0000000000000000000000000000000000000000;;				mounter:         mounter,
0000000000000000000000000000000000000000;;				plugin:          plugin,
0000000000000000000000000000000000000000;;				MetricsProvider: volume.NewMetricsStatFS(getPath(podUID, volNamespace, volName, pvName, plugin.host)),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.StorageOS == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.StorageOS is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		class, err := util.GetClassForVolume(plugin.host.GetKubeClient(), spec.PersistentVolume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var adminSecretName, adminSecretNamespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range class.Parameters {
0000000000000000000000000000000000000000;;			switch strings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "adminsecretname":
0000000000000000000000000000000000000000;;				adminSecretName = v
0000000000000000000000000000000000000000;;			case "adminsecretnamespace":
0000000000000000000000000000000000000000;;				adminSecretNamespace = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiCfg, err := parsePVSecret(adminSecretNamespace, adminSecretName, plugin.host.GetKubeClient())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get admin secret from [%q/%q]: %v", adminSecretNamespace, adminSecretName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plugin.newDeleterInternal(spec, apiCfg, &storageosUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) newDeleterInternal(spec *volume.Spec, apiCfg *storageosAPIConfig, manager storageosManager) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &storageosDeleter{
0000000000000000000000000000000000000000;;			storageosMounter: &storageosMounter{
0000000000000000000000000000000000000000;;				storageos: &storageos{
0000000000000000000000000000000000000000;;					pvName:       spec.Name(),
0000000000000000000000000000000000000000;;					volName:      spec.PersistentVolume.Spec.StorageOS.VolumeName,
0000000000000000000000000000000000000000;;					volNamespace: spec.PersistentVolume.Spec.StorageOS.VolumeNamespace,
0000000000000000000000000000000000000000;;					apiCfg:       apiCfg,
0000000000000000000000000000000000000000;;					manager:      manager,
0000000000000000000000000000000000000000;;					plugin:       plugin,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			pvUID: spec.PersistentVolume.UID,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return plugin.newProvisionerInternal(options, &storageosUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) newProvisionerInternal(options volume.VolumeOptions, manager storageosManager) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &storageosProvisioner{
0000000000000000000000000000000000000000;;			storageosMounter: &storageosMounter{
0000000000000000000000000000000000000000;;				storageos: &storageos{
0000000000000000000000000000000000000000;;					manager: manager,
0000000000000000000000000000000000000000;;					plugin:  plugin,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options: options,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		volNamespace, volName, err := getVolumeFromRef(volumeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			volNamespace = defaultNamespace
0000000000000000000000000000000000000000;;			volName = volumeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storageosVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				StorageOS: &v1.StorageOSVolumeSource{
0000000000000000000000000000000000000000;;					VolumeName:      volName,
0000000000000000000000000000000000000000;;					VolumeNamespace: volNamespace,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(storageosVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *storageosPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.StorageOSVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.StorageOS != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.StorageOS, spec.Volume.StorageOS.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a StorageOS volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPersistentVolumeSource(spec *volume.Spec) (*v1.StorageOSPersistentVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.StorageOS != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.StorageOS, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a StorageOS persistent volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// storageosManager is the abstract interface to StorageOS volume ops.
0000000000000000000000000000000000000000;;	type storageosManager interface {
0000000000000000000000000000000000000000;;		// Connects to the StorageOS API using the supplied configuration.
0000000000000000000000000000000000000000;;		NewAPI(apiCfg *storageosAPIConfig) error
0000000000000000000000000000000000000000;;		// Creates a StorageOS volume.
0000000000000000000000000000000000000000;;		CreateVolume(provisioner *storageosProvisioner) (*storageosVolume, error)
0000000000000000000000000000000000000000;;		// Attaches the disk to the kubelet's host machine.
0000000000000000000000000000000000000000;;		AttachVolume(mounter *storageosMounter) (string, error)
0000000000000000000000000000000000000000;;		// Detaches the disk from the kubelet's host machine.
0000000000000000000000000000000000000000;;		DetachVolume(unmounter *storageosUnmounter, dir string) error
0000000000000000000000000000000000000000;;		// Mounts the disk on the Kubelet's host machine.
0000000000000000000000000000000000000000;;		MountVolume(mounter *storageosMounter, mnt, dir string) error
0000000000000000000000000000000000000000;;		// Unmounts the disk from the Kubelet's host machine.
0000000000000000000000000000000000000000;;		UnmountVolume(unounter *storageosUnmounter) error
0000000000000000000000000000000000000000;;		// Deletes the storageos volume.  All data will be lost.
0000000000000000000000000000000000000000;;		DeleteVolume(deleter *storageosDeleter) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// storageos volumes represent a bare host directory mount of an StorageOS export.
0000000000000000000000000000000000000000;;	type storageos struct {
0000000000000000000000000000000000000000;;		podUID       types.UID
0000000000000000000000000000000000000000;;		podNamespace string
0000000000000000000000000000000000000000;;		pvName       string
0000000000000000000000000000000000000000;;		volName      string
0000000000000000000000000000000000000000;;		volNamespace string
0000000000000000000000000000000000000000;;		secretName   string
0000000000000000000000000000000000000000;;		readOnly     bool
0000000000000000000000000000000000000000;;		description  string
0000000000000000000000000000000000000000;;		pool         string
0000000000000000000000000000000000000000;;		fsType       string
0000000000000000000000000000000000000000;;		sizeGB       int
0000000000000000000000000000000000000000;;		labels       map[string]string
0000000000000000000000000000000000000000;;		apiCfg       *storageosAPIConfig
0000000000000000000000000000000000000000;;		manager      storageosManager
0000000000000000000000000000000000000000;;		mounter      mount.Interface
0000000000000000000000000000000000000000;;		plugin       *storageosPlugin
0000000000000000000000000000000000000000;;		volume.MetricsProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageosMounter struct {
0000000000000000000000000000000000000000;;		*storageos
0000000000000000000000000000000000000000;;		devicePath string
0000000000000000000000000000000000000000;;		// Interface used to mount the file or block device
0000000000000000000000000000000000000000;;		diskMounter *mount.SafeFormatAndMount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &storageosMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *storageosMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         !b.readOnly,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *storageosMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *storageosMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		// Need a namespace to find the volume, try pod's namespace if not set.
0000000000000000000000000000000000000000;;		if b.volNamespace == "" {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Setting StorageOS volume namespace to pod namespace: %s", b.podNamespace)
0000000000000000000000000000000000000000;;			b.volNamespace = b.podNamespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attach the StorageOS volume as a block device
0000000000000000000000000000000000000000;;		devicePath, err := b.manager.AttachVolume(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to attach StorageOS volume %s: %s", b.volName, err.Error())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mount the loop device into the plugin's disk global mount dir.
0000000000000000000000000000000000000000;;		globalPDPath := makeGlobalPDName(b.plugin.host, b.pvName, b.podNamespace, b.volName)
0000000000000000000000000000000000000000;;		err = b.manager.MountVolume(b, devicePath, globalPDPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Successfully mounted StorageOS volume %s into global mount directory", b.volName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bind mount the volume into the pod
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp bind mounts the disk global mount to the give volume path.
0000000000000000000000000000000000000000;;	func (b *storageosMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("StorageOS volume set up: %s %v %v", dir, !notMnt, err)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot validate mount point: %s %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("mkdir failed on disk %s (%v)", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a bind mount to the full path to allow duplicate mounts of the same PD.
0000000000000000000000000000000000000000;;		options := []string{"bind"}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		globalPDPath := makeGlobalPDName(b.plugin.host, b.pvName, b.volNamespace, b.volName)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Attempting to bind mount to pod volume at %s", dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = b.mounter.Mount(globalPDPath, dir, "", options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;			if mntErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !notMnt {
0000000000000000000000000000000000000000;;				if mntErr = b.mounter.Unmount(dir); mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to unmount: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;				if mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !notMnt {
0000000000000000000000000000000000000000;;					glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.", dir)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Remove(dir)
0000000000000000000000000000000000000000;;			glog.Errorf("Mount of disk %s failed: %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !b.readOnly {
0000000000000000000000000000000000000000;;			volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("StorageOS volume setup complete on %s", dir)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeGlobalPDName(host volume.VolumeHost, pvName, volNamespace, volName string) string {
0000000000000000000000000000000000000000;;		return path.Join(host.GetPluginDir(kstrings.EscapeQualifiedNameForDisk(storageosPluginName)), mount.MountsInGlobalPDPath, pvName+"."+volNamespace+"."+volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Given the pod id and PV name, finds the volume's namespace and name from the
0000000000000000000000000000000000000000;;	// name or volume mount.  We mount as volNamespace.pvName, but k8s will specify
0000000000000000000000000000000000000000;;	// only the pvName to unmount.
0000000000000000000000000000000000000000;;	// Will return empty volNamespace/pvName if the volume is not mounted.
0000000000000000000000000000000000000000;;	func getVolumeInfo(pvName string, podUID types.UID, host volume.VolumeHost) (string, string, error) {
0000000000000000000000000000000000000000;;		if volNamespace, volName, err := getVolumeFromRef(pvName); err == nil {
0000000000000000000000000000000000000000;;			return volNamespace, volName, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeDir := filepath.Dir(host.GetPodVolumeDir(podUID, kstrings.EscapeQualifiedNameForDisk(storageosPluginName), pvName))
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(volumeDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("Could not read mounts from pod volume dir: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			if f.Mode().IsDir() && strings.HasPrefix(f.Name(), pvName+".") {
0000000000000000000000000000000000000000;;				if volNamespace, volName, err := getVolumeFromRef(f.Name()); err == nil {
0000000000000000000000000000000000000000;;					return volNamespace, volName, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", fmt.Errorf("Could not get info from unmounted pv %q at %q", pvName, volumeDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Splits the volume ref on "." to return the volNamespace and pvName.  Neither
0000000000000000000000000000000000000000;;	// namespaces nor service names allow "." in their names.
0000000000000000000000000000000000000000;;	func getVolumeFromRef(ref string) (volNamespace string, volName string, err error) {
0000000000000000000000000000000000000000;;		refParts := strings.Split(ref, ".")
0000000000000000000000000000000000000000;;		switch len(refParts) {
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			return refParts[0], refParts[1], nil
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			return refParts[1], refParts[2], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", fmt.Errorf("ref not in format volNamespace.volName or pvName.volNamespace.volName")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPath returns the path to the user specific mount of a StorageOS volume
0000000000000000000000000000000000000000;;	func (storageosVolume *storageos) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(storageosVolume.podUID, storageosVolume.volNamespace, storageosVolume.volName, storageosVolume.pvName, storageosVolume.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageosUnmounter struct {
0000000000000000000000000000000000000000;;		*storageos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &storageosUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *storageosUnmounter) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(b.podUID, b.volNamespace, b.volName, b.pvName, b.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (b *storageosUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		if len(b.volNamespace) == 0 || len(b.volName) == 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("volNamespace: %q, volName: %q not set, skipping TearDown", b.volNamespace, b.volName)
0000000000000000000000000000000000000000;;			return fmt.Errorf("pvName not specified for TearDown, waiting for next sync loop")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Unmount from pod
0000000000000000000000000000000000000000;;		mountPath := b.GetPath()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := b.TearDownAt(mountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unmount from pod failed: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find device name from global mount
0000000000000000000000000000000000000000;;		globalPDPath := makeGlobalPDName(b.plugin.host, b.pvName, b.volNamespace, b.volName)
0000000000000000000000000000000000000000;;		devicePath, _, err := mount.GetDeviceNameFromMount(b.mounter, globalPDPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Detach failed when getting device from global mount: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unmount from plugin's disk global mount dir.
0000000000000000000000000000000000000000;;		err = b.TearDownAt(globalPDPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Detach failed during unmount: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Detach loop device
0000000000000000000000000000000000000000;;		err = b.manager.DetachVolume(b, devicePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Detach device %s failed for volume %s: %v", devicePath, b.pvName, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Successfully unmounted StorageOS volume %s and detached devices", b.pvName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (b *storageosUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		if err := util.UnmountPath(dir, b.mounter); err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Unmounted StorageOS volume %s failed with: %v", b.pvName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := b.manager.UnmountVolume(b); err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Mount reference for volume %s could not be removed from StorageOS: %v", b.pvName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageosDeleter struct {
0000000000000000000000000000000000000000;;		*storageosMounter
0000000000000000000000000000000000000000;;		pvUID types.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Deleter = &storageosDeleter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *storageosDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(d.podUID, d.volNamespace, d.volName, d.pvName, d.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *storageosDeleter) Delete() error {
0000000000000000000000000000000000000000;;		return d.manager.DeleteVolume(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageosProvisioner struct {
0000000000000000000000000000000000000000;;		*storageosMounter
0000000000000000000000000000000000000000;;		options volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Provisioner = &storageosProvisioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *storageosProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if !volume.AccessModesContainedInAll(c.plugin.GetAccessModes(), c.options.PVC.Spec.AccessModes) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported", c.options.PVC.Spec.AccessModes, c.plugin.GetAccessModes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var adminSecretName, adminSecretNamespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply ProvisionerParameters (case-insensitive). We leave validation of
0000000000000000000000000000000000000000;;		// the values to the cloud provider.
0000000000000000000000000000000000000000;;		for k, v := range c.options.Parameters {
0000000000000000000000000000000000000000;;			switch strings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "adminsecretname":
0000000000000000000000000000000000000000;;				adminSecretName = v
0000000000000000000000000000000000000000;;			case "adminsecretnamespace":
0000000000000000000000000000000000000000;;				adminSecretNamespace = v
0000000000000000000000000000000000000000;;			case "volumenamespace":
0000000000000000000000000000000000000000;;				c.volNamespace = v
0000000000000000000000000000000000000000;;			case "description":
0000000000000000000000000000000000000000;;				c.description = v
0000000000000000000000000000000000000000;;			case "pool":
0000000000000000000000000000000000000000;;				c.pool = v
0000000000000000000000000000000000000000;;			case "fstype":
0000000000000000000000000000000000000000;;				c.fsType = v
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid option %q for volume plugin %s", k, c.plugin.GetPluginName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set from PVC
0000000000000000000000000000000000000000;;		c.podNamespace = c.options.PVC.Namespace
0000000000000000000000000000000000000000;;		c.volName = c.options.PVName
0000000000000000000000000000000000000000;;		if c.volNamespace == "" {
0000000000000000000000000000000000000000;;			c.volNamespace = c.options.PVC.Namespace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.labels = make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range c.options.PVC.Labels {
0000000000000000000000000000000000000000;;			c.labels[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		capacity := c.options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		c.sizeGB = int(volume.RoundUpSize(capacity.Value(), 1024*1024*1024))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiCfg, err := parsePVSecret(adminSecretNamespace, adminSecretName, c.plugin.host.GetKubeClient())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.apiCfg = apiCfg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := c.manager.CreateVolume(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to create volume: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vol.FSType == "" {
0000000000000000000000000000000000000000;;			vol.FSType = defaultFSType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   vol.Name,
0000000000000000000000000000000000000000;;				Labels: map[string]string{},
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeDynamicallyCreatedByKey: "storageos-dynamic-provisioner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: c.options.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				AccessModes:                   c.options.PVC.Spec.AccessModes,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dGi", vol.SizeGB)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					StorageOS: &v1.StorageOSPersistentVolumeSource{
0000000000000000000000000000000000000000;;						VolumeName:      vol.Name,
0000000000000000000000000000000000000000;;						VolumeNamespace: vol.Namespace,
0000000000000000000000000000000000000000;;						FSType:          vol.FSType,
0000000000000000000000000000000000000000;;						ReadOnly:        false,
0000000000000000000000000000000000000000;;						SecretRef: &v1.ObjectReference{
0000000000000000000000000000000000000000;;							Name:      adminSecretName,
0000000000000000000000000000000000000000;;							Namespace: adminSecretNamespace,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.options.PVC.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = c.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(vol.Labels) != 0 {
0000000000000000000000000000000000000000;;			if pv.Labels == nil {
0000000000000000000000000000000000000000;;				pv.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range vol.Labels {
0000000000000000000000000000000000000000;;				pv.Labels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns StorageOS volume name, namespace, fstype and readonly from spec
0000000000000000000000000000000000000000;;	func getVolumeInfoFromSpec(spec *volume.Spec) (string, string, string, bool, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil {
0000000000000000000000000000000000000000;;			source, readOnly, err := getPersistentVolumeSource(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", "", false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return source.VolumeName, source.VolumeNamespace, source.FSType, readOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil {
0000000000000000000000000000000000000000;;			source, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", "", false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return source.VolumeName, source.VolumeNamespace, source.FSType, readOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", "", false, fmt.Errorf("spec not Volume or PersistentVolume")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns API config if secret set, otherwise empty struct so defaults can be
0000000000000000000000000000000000000000;;	// attempted.
0000000000000000000000000000000000000000;;	func getAPICfg(spec *volume.Spec, pod *v1.Pod, kubeClient clientset.Interface) (*storageosAPIConfig, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil {
0000000000000000000000000000000000000000;;			source, _, err := getPersistentVolumeSource(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if source.SecretRef == nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return parsePVSecret(source.SecretRef.Namespace, source.SecretRef.Name, kubeClient)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil {
0000000000000000000000000000000000000000;;			source, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if source.SecretRef == nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return parsePodSecret(pod, source.SecretRef.Name, kubeClient)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("spec not Volume or PersistentVolume")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePodSecret(pod *v1.Pod, secretName string, kubeClient clientset.Interface) (*storageosAPIConfig, error) {
0000000000000000000000000000000000000000;;		secret, err := util.GetSecretForPod(pod, secretName, kubeClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to get secret from [%q/%q]", pod.Namespace, secretName)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get secret from [%q/%q]", pod.Namespace, secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseAPIConfig(secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Important: Only to be called with data from a PV to avoid secrets being
0000000000000000000000000000000000000000;;	// loaded from a user-suppler namespace.
0000000000000000000000000000000000000000;;	func parsePVSecret(namespace, secretName string, kubeClient clientset.Interface) (*storageosAPIConfig, error) {
0000000000000000000000000000000000000000;;		secret, err := util.GetSecretForPV(namespace, secretName, storageosPluginName, kubeClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to get secret from [%q/%q]", namespace, secretName)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get secret from [%q/%q]", namespace, secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseAPIConfig(secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse API configuration from parameters or secret
0000000000000000000000000000000000000000;;	func parseAPIConfig(params map[string]string) (*storageosAPIConfig, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(params) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("empty API config")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &storageosAPIConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, data := range params {
0000000000000000000000000000000000000000;;			switch strings.ToLower(name) {
0000000000000000000000000000000000000000;;			case "apiaddress":
0000000000000000000000000000000000000000;;				c.apiAddr = string(data)
0000000000000000000000000000000000000000;;			case "apiusername":
0000000000000000000000000000000000000000;;				c.apiUser = string(data)
0000000000000000000000000000000000000000;;			case "apipassword":
0000000000000000000000000000000000000000;;				c.apiPass = string(data)
0000000000000000000000000000000000000000;;			case "apiversion":
0000000000000000000000000000000000000000;;				c.apiVersion = string(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
