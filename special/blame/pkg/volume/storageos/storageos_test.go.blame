0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
bed3bbbd20d07cd2188d11c1be163c46f1d22c8d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storageos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("storageos_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/storageos")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.GetPluginName() != "kubernetes.io/storageos" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plug.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{StorageOS: &v1.StorageOSVolumeSource{}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plug.CanSupport(&volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{StorageOS: &v1.StorageOSPersistentVolumeSource{}}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("storageos_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPersistentPluginByName("kubernetes.io/storageos")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !contains(plug.GetAccessModes(), v1.ReadWriteOnce) || !contains(plug.GetAccessModes(), v1.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected two AccessModeTypes:  %s and %s", v1.ReadWriteOnce, v1.ReadOnlyMany)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePDManager struct {
0000000000000000000000000000000000000000;;		api           apiImplementer
0000000000000000000000000000000000000000;;		attachCalled  bool
0000000000000000000000000000000000000000;;		detachCalled  bool
0000000000000000000000000000000000000000;;		mountCalled   bool
0000000000000000000000000000000000000000;;		unmountCalled bool
0000000000000000000000000000000000000000;;		createCalled  bool
0000000000000000000000000000000000000000;;		deleteCalled  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakePDManager) NewAPI(apiCfg *storageosAPIConfig) error {
0000000000000000000000000000000000000000;;		fake.api = fakeAPI{}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakePDManager) CreateVolume(p *storageosProvisioner) (*storageosVolume, error) {
0000000000000000000000000000000000000000;;		fake.createCalled = true
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		labels["fakepdmanager"] = "yes"
0000000000000000000000000000000000000000;;		return &storageosVolume{
0000000000000000000000000000000000000000;;			Name:      "test-storageos-name",
0000000000000000000000000000000000000000;;			Namespace: "test-storageos-namespace",
0000000000000000000000000000000000000000;;			Pool:      "test-storageos-pool",
0000000000000000000000000000000000000000;;			SizeGB:    100,
0000000000000000000000000000000000000000;;			Labels:    labels,
0000000000000000000000000000000000000000;;			FSType:    "ext2",
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakePDManager) AttachVolume(b *storageosMounter) (string, error) {
0000000000000000000000000000000000000000;;		fake.attachCalled = true
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakePDManager) DetachVolume(b *storageosUnmounter, loopDevice string) error {
0000000000000000000000000000000000000000;;		fake.detachCalled = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakePDManager) MountVolume(b *storageosMounter, mntDevice, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		fake.mountCalled = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakePDManager) UnmountVolume(b *storageosUnmounter) error {
0000000000000000000000000000000000000000;;		fake.unmountCalled = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakePDManager) DeleteVolume(d *storageosDeleter) error {
0000000000000000000000000000000000000000;;		fake.deleteCalled = true
0000000000000000000000000000000000000000;;		if d.volName != "test-storageos-name" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Deleter got unexpected volume name: %s", d.volName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPlugin(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("storageos_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("can't make a temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/storageos")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secretName := "very-secret"
0000000000000000000000000000000000000000;;		spec := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: "vol1-pvname",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				StorageOS: &v1.StorageOSVolumeSource{
0000000000000000000000000000000000000000;;					VolumeName:      "vol1",
0000000000000000000000000000000000000000;;					VolumeNamespace: "ns1",
0000000000000000000000000000000000000000;;					FSType:          "ext3",
0000000000000000000000000000000000000000;;					SecretRef: &v1.LocalObjectReference{
0000000000000000000000000000000000000000;;						Name: secretName,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.Core().Secrets("default").Create(&v1.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      secretName,
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: "kubernetes.io/storageos",
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"apiUsername": []byte("storageos"),
0000000000000000000000000000000000000000;;				"apiPassword": []byte("storageos"),
0000000000000000000000000000000000000000;;				"apiAddr":     []byte("tcp://localhost:5705"),
0000000000000000000000000000000000000000;;			}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug.(*storageosPlugin).host = volumetest.NewFakeVolumeHost(tmpDir, client, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test Mounter
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid"), Namespace: "default"}}
0000000000000000000000000000000000000000;;		fakeManager := &fakePDManager{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiCfg, err := parsePodSecret(pod, secretName, plug.(*storageosPlugin).host.GetKubeClient())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Couldn't get secret from %v/%v", pod.Namespace, secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounter, err := plug.(*storageosPlugin).newMounterInternal(volume.NewSpecFromVolume(spec), pod, apiCfg, fakeManager, &mount.FakeMounter{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPath := path.Join(tmpDir, "pods/poduid/volumes/kubernetes.io~storageos/vol1-pvname.ns1.vol1")
0000000000000000000000000000000000000000;;		volPath := mounter.GetPath()
0000000000000000000000000000000000000000;;		if volPath != expectedPath {
0000000000000000000000000000000000000000;;			t.Errorf("Expected path: '%s' got: '%s'", expectedPath, volPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := mounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(volPath); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed, volume path not created: %s", volPath)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !fakeManager.attachCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Attach not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.mountCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Mount not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test Unmounter
0000000000000000000000000000000000000000;;		fakeManager = &fakePDManager{}
0000000000000000000000000000000000000000;;		unmounter, err := plug.(*storageosPlugin).newUnmounterInternal("vol1-pvname", types.UID("poduid"), fakeManager, &mount.FakeMounter{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unmounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Unmounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volPath = unmounter.GetPath()
0000000000000000000000000000000000000000;;		if volPath != expectedPath {
0000000000000000000000000000000000000000;;			t.Errorf("Expected path: '%s' got: '%s'", expectedPath, volPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := unmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(volPath); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("TearDown() failed, volume path still exists: %s", volPath)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !fakeManager.unmountCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Unmount not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.detachCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Detach not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test Provisioner
0000000000000000000000000000000000000000;;		fakeManager = &fakePDManager{}
0000000000000000000000000000000000000000;;		options := volume.VolumeOptions{
0000000000000000000000000000000000000000;;			PVC: volumetest.CreateTestPVC("100Mi", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}),
0000000000000000000000000000000000000000;;			// PVName: "test-volume-name",
0000000000000000000000000000000000000000;;			PersistentVolumeReclaimPolicy: v1.PersistentVolumeReclaimDelete,
0000000000000000000000000000000000000000;;			Parameters: map[string]string{
0000000000000000000000000000000000000000;;				"VolumeNamespace": "test-volume-namespace",
0000000000000000000000000000000000000000;;				"adminSecretName": secretName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		provisioner, err := plug.(*storageosPlugin).newProvisionerInternal(options, fakeManager)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("newProvisionerInternal() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		persistentSpec, err := provisioner.Provision()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Provision() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if persistentSpec.Spec.PersistentVolumeSource.StorageOS.VolumeName != "test-storageos-name" {
0000000000000000000000000000000000000000;;			t.Errorf("Provision() returned unexpected volume Name: %s, expected test-storageos-name", persistentSpec.Spec.PersistentVolumeSource.StorageOS.VolumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if persistentSpec.Spec.PersistentVolumeSource.StorageOS.VolumeNamespace != "test-storageos-namespace" {
0000000000000000000000000000000000000000;;			t.Errorf("Provision() returned unexpected volume Namespace: %s", persistentSpec.Spec.PersistentVolumeSource.StorageOS.VolumeNamespace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cap := persistentSpec.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;		size := cap.Value()
0000000000000000000000000000000000000000;;		if size != 100*1024*1024*1024 {
0000000000000000000000000000000000000000;;			t.Errorf("Provision() returned unexpected volume size: %v", size)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if persistentSpec.Spec.PersistentVolumeSource.StorageOS.FSType != "ext2" {
0000000000000000000000000000000000000000;;			t.Errorf("Provision() returned unexpected volume FSType: %s", persistentSpec.Spec.PersistentVolumeSource.StorageOS.FSType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if persistentSpec.Labels["fakepdmanager"] != "yes" {
0000000000000000000000000000000000000000;;			t.Errorf("Provision() returned unexpected labels: %v", persistentSpec.Labels)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.createCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Create not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test Deleter
0000000000000000000000000000000000000000;;		fakeManager = &fakePDManager{}
0000000000000000000000000000000000000000;;		volSpec := &volume.Spec{
0000000000000000000000000000000000000000;;			PersistentVolume: persistentSpec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deleter, err := plug.(*storageosPlugin).newDeleterInternal(volSpec, apiCfg, fakeManager)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("newDeleterInternal() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = deleter.Delete()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Deleter() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.deleteCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Delete not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(modes []v1.PersistentVolumeAccessMode, mode v1.PersistentVolumeAccessMode) bool {
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if m == mode {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentClaimReadOnlyFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("storageos_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					StorageOS: &v1.StorageOSPersistentVolumeSource{VolumeName: "pvA", VolumeNamespace: "vnsA", ReadOnly: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ClaimRef: &v1.ObjectReference{
0000000000000000000000000000000000000000;;					Name: "claimA",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claimA",
0000000000000000000000000000000000000000;;				Namespace: "nsA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				VolumeName: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PersistentVolumeClaimStatus{
0000000000000000000000000000000000000000;;				Phase: v1.ClaimBound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(pv, claim)
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, client, nil))
0000000000000000000000000000000000000000;;		plug, _ := plugMgr.FindPluginByName(storageosPluginName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readOnly bool is supplied by persistent-claim volume source when its mounter creates other volumes
0000000000000000000000000000000000000000;;		spec := volume.NewSpecFromPersistentVolume(pv, true)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Namespace: "nsA", UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		fakeManager := &fakePDManager{}
0000000000000000000000000000000000000000;;		fakeConfig := &fakeConfig{}
0000000000000000000000000000000000000000;;		apiCfg := fakeConfig.GetAPIConfig()
0000000000000000000000000000000000000000;;		mounter, err := plug.(*storageosPlugin).newMounterInternal(spec, pod, apiCfg, fakeManager, &mount.FakeMounter{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !mounter.GetAttributes().ReadOnly {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true for mounter.IsReadOnly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
