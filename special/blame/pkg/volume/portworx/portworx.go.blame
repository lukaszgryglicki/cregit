0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
53795d8dd25f2c7edfe0581e1b07058df18938f5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portworx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		kstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&portworxVolumePlugin{nil, nil}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portworxVolumePlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;		util *PortworxVolumeUtil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &portworxVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &portworxVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &portworxVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &portworxVolumePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		portworxVolumePluginName = "kubernetes.io/portworx-volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPath(uid types.UID, volName string, host volume.VolumeHost) string {
0000000000000000000000000000000000000000;;		return host.GetPodVolumeDir(uid, kstrings.EscapeQualifiedNameForDisk(portworxVolumePluginName), volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		plugin.util = &PortworxVolumeUtil{}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return portworxVolumePluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource.VolumeID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.PortworxVolume != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.PortworxVolume != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;			v1.ReadWriteMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, plugin.util, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, manager portworxManager, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		pwx, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID := pwx.VolumeID
0000000000000000000000000000000000000000;;		fsType := pwx.FSType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &portworxVolumeMounter{
0000000000000000000000000000000000000000;;			portworxVolume: &portworxVolume{
0000000000000000000000000000000000000000;;				podUID:          podUID,
0000000000000000000000000000000000000000;;				volName:         spec.Name(),
0000000000000000000000000000000000000000;;				volumeID:        volumeID,
0000000000000000000000000000000000000000;;				manager:         manager,
0000000000000000000000000000000000000000;;				mounter:         mounter,
0000000000000000000000000000000000000000;;				plugin:          plugin,
0000000000000000000000000000000000000000;;				MetricsProvider: volume.NewMetricsStatFS(getPath(podUID, spec.Name(), plugin.host)),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			fsType:      fsType,
0000000000000000000000000000000000000000;;			readOnly:    readOnly,
0000000000000000000000000000000000000000;;			diskMounter: &mount.SafeFormatAndMount{Interface: plugin.host.GetMounter(), Runner: exec.New()}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, plugin.util, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) newUnmounterInternal(volName string, podUID types.UID, manager portworxManager,
0000000000000000000000000000000000000000;;		mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &portworxVolumeUnmounter{
0000000000000000000000000000000000000000;;			&portworxVolume{
0000000000000000000000000000000000000000;;				podUID:          podUID,
0000000000000000000000000000000000000000;;				volName:         volName,
0000000000000000000000000000000000000000;;				manager:         manager,
0000000000000000000000000000000000000000;;				mounter:         mounter,
0000000000000000000000000000000000000000;;				plugin:          plugin,
0000000000000000000000000000000000000000;;				MetricsProvider: volume.NewMetricsStatFS(getPath(podUID, volName, plugin.host)),
0000000000000000000000000000000000000000;;			}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		return plugin.newDeleterInternal(spec, plugin.util)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) newDeleterInternal(spec *volume.Spec, manager portworxManager) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.PortworxVolume == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.PortworxVolume is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &portworxVolumeDeleter{
0000000000000000000000000000000000000000;;			portworxVolume: &portworxVolume{
0000000000000000000000000000000000000000;;				volName:  spec.Name(),
0000000000000000000000000000000000000000;;				volumeID: spec.PersistentVolume.Spec.PortworxVolume.VolumeID,
0000000000000000000000000000000000000000;;				manager:  manager,
0000000000000000000000000000000000000000;;				plugin:   plugin,
0000000000000000000000000000000000000000;;			}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return plugin.newProvisionerInternal(options, plugin.util)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) newProvisionerInternal(options volume.VolumeOptions, manager portworxManager) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &portworxVolumeProvisioner{
0000000000000000000000000000000000000000;;			portworxVolume: &portworxVolume{
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options: options,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		portworxVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				PortworxVolume: &v1.PortworxVolumeSource{
0000000000000000000000000000000000000000;;					VolumeID: volumeName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(portworxVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *portworxVolumePlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(
0000000000000000000000000000000000000000;;		spec *volume.Spec) (*v1.PortworxVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.PortworxVolume != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.PortworxVolume, spec.Volume.PortworxVolume.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.PortworxVolume != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.PortworxVolume, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a Portworx Volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstract interface to PD operations.
0000000000000000000000000000000000000000;;	type portworxManager interface {
0000000000000000000000000000000000000000;;		// Creates a volume
0000000000000000000000000000000000000000;;		CreateVolume(provisioner *portworxVolumeProvisioner) (volumeID string, volumeSizeGB int, labels map[string]string, err error)
0000000000000000000000000000000000000000;;		// Deletes a volume
0000000000000000000000000000000000000000;;		DeleteVolume(deleter *portworxVolumeDeleter) error
0000000000000000000000000000000000000000;;		// Attach a volume
0000000000000000000000000000000000000000;;		AttachVolume(mounter *portworxVolumeMounter) (string, error)
0000000000000000000000000000000000000000;;		// Detach a volume
0000000000000000000000000000000000000000;;		DetachVolume(unmounter *portworxVolumeUnmounter) error
0000000000000000000000000000000000000000;;		// Mount a volume
0000000000000000000000000000000000000000;;		MountVolume(mounter *portworxVolumeMounter, mountDir string) error
0000000000000000000000000000000000000000;;		// Unmount a volume
0000000000000000000000000000000000000000;;		UnmountVolume(unmounter *portworxVolumeUnmounter, mountDir string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// portworxVolume volumes are portworx block devices
0000000000000000000000000000000000000000;;	// that are attached to the kubelet's host machine and exposed to the pod.
0000000000000000000000000000000000000000;;	type portworxVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		// Unique id of the PD, used to find the disk resource in the provider.
0000000000000000000000000000000000000000;;		volumeID string
0000000000000000000000000000000000000000;;		// Utility interface that provides API calls to the provider to attach/detach disks.
0000000000000000000000000000000000000000;;		manager portworxManager
0000000000000000000000000000000000000000;;		// Mounter interface that provides system calls to mount the global path to the pod local path.
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		plugin  *portworxVolumePlugin
0000000000000000000000000000000000000000;;		volume.MetricsProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portworxVolumeMounter struct {
0000000000000000000000000000000000000000;;		*portworxVolume
0000000000000000000000000000000000000000;;		// Filesystem type, optional.
0000000000000000000000000000000000000000;;		fsType string
0000000000000000000000000000000000000000;;		// Specifies whether the disk will be attached as read-only.
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;		// diskMounter provides the interface that is used to mount the actual block device.
0000000000000000000000000000000000000000;;		diskMounter *mount.SafeFormatAndMount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &portworxVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *portworxVolumeMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly: b.readOnly,
0000000000000000000000000000000000000000;;			Managed:  !b.readOnly,
0000000000000000000000000000000000000000;;			// true ?
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *portworxVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *portworxVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *portworxVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Portworx Volume set up: %s %v %v", dir, !notMnt, err)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("Cannot validate mountpoint: %s", dir)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := b.manager.AttachVolume(b); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Portworx Volume %s attached", b.volumeID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := b.manager.MountVolume(b, dir); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !b.readOnly {
0000000000000000000000000000000000000000;;			volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Portworx Volume %s mounted to %s", b.volumeID, dir)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pwx *portworxVolume) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(pwx.podUID, pwx.volName, pwx.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portworxVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*portworxVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &portworxVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *portworxVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *portworxVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Portworx Volume TearDown of %s", dir)
0000000000000000000000000000000000000000;;		// Call Portworx Unmount for Portworx's book-keeping.
0000000000000000000000000000000000000000;;		if err := c.manager.UnmountVolume(c, dir); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call Portworx Detach Volume.
0000000000000000000000000000000000000000;;		if err := c.manager.DetachVolume(c); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portworxVolumeDeleter struct {
0000000000000000000000000000000000000000;;		*portworxVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Deleter = &portworxVolumeDeleter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *portworxVolumeDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(d.podUID, d.volName, d.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *portworxVolumeDeleter) Delete() error {
0000000000000000000000000000000000000000;;		return d.manager.DeleteVolume(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portworxVolumeProvisioner struct {
0000000000000000000000000000000000000000;;		*portworxVolume
0000000000000000000000000000000000000000;;		options   volume.VolumeOptions
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Provisioner = &portworxVolumeProvisioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *portworxVolumeProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if !volume.AccessModesContainedInAll(c.plugin.GetAccessModes(), c.options.PVC.Spec.AccessModes) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported", c.options.PVC.Spec.AccessModes, c.plugin.GetAccessModes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID, sizeGB, labels, err := c.manager.CreateVolume(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   c.options.PVName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{},
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeDynamicallyCreatedByKey: "portworx-volume-dynamic-provisioner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: c.options.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				AccessModes:                   c.options.PVC.Spec.AccessModes,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dGi", sizeGB)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					PortworxVolume: &v1.PortworxVolumeSource{
0000000000000000000000000000000000000000;;						VolumeID: volumeID,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(labels) != 0 {
0000000000000000000000000000000000000000;;			if pv.Labels == nil {
0000000000000000000000000000000000000000;;				pv.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range labels {
0000000000000000000000000000000000000000;;				pv.Labels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.options.PVC.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = c.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
