0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
a828df98d7349ecfe3ed32b7f78f77950d641e60;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package vsphere_volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxRetries         = 10
0000000000000000000000000000000000000000;;		checkSleepDuration = time.Second
0000000000000000000000000000000000000000;;		diskByIDPath       = "/dev/disk/by-id/"
0000000000000000000000000000000000000000;;		diskSCSIPrefix     = "wwn-0x"
0000000000000000000000000000000000000000;;		diskformat         = "diskformat"
0000000000000000000000000000000000000000;;		datastore          = "datastore"
0000000000000000000000000000000000000000;;		Fstype             = "fstype"
0000000000000000000000000000000000000000;;		StoragePolicyName  = "storagepolicyname"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HostFailuresToTolerateCapability    = "hostfailurestotolerate"
0000000000000000000000000000000000000000;;		ForceProvisioningCapability         = "forceprovisioning"
0000000000000000000000000000000000000000;;		CacheReservationCapability          = "cachereservation"
0000000000000000000000000000000000000000;;		DiskStripesCapability               = "diskstripes"
0000000000000000000000000000000000000000;;		ObjectSpaceReservationCapability    = "objectspacereservation"
0000000000000000000000000000000000000000;;		IopsLimitCapability                 = "iopslimit"
0000000000000000000000000000000000000000;;		HostFailuresToTolerateCapabilityMin = 0
0000000000000000000000000000000000000000;;		HostFailuresToTolerateCapabilityMax = 3
0000000000000000000000000000000000000000;;		ForceProvisioningCapabilityMin      = 0
0000000000000000000000000000000000000000;;		ForceProvisioningCapabilityMax      = 1
0000000000000000000000000000000000000000;;		CacheReservationCapabilityMin       = 0
0000000000000000000000000000000000000000;;		CacheReservationCapabilityMax       = 100
0000000000000000000000000000000000000000;;		DiskStripesCapabilityMin            = 1
0000000000000000000000000000000000000000;;		DiskStripesCapabilityMax            = 12
0000000000000000000000000000000000000000;;		ObjectSpaceReservationCapabilityMin = 0
0000000000000000000000000000000000000000;;		ObjectSpaceReservationCapabilityMax = 100
0000000000000000000000000000000000000000;;		IopsLimitCapabilityMin              = 0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrProbeVolume = errors.New("Error scanning attached volumes")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type VsphereDiskUtil struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type VolumeSpec struct {
0000000000000000000000000000000000000000;;		Path              string
0000000000000000000000000000000000000000;;		Size              int
0000000000000000000000000000000000000000;;		Fstype            string
0000000000000000000000000000000000000000;;		StoragePolicyID   string
0000000000000000000000000000000000000000;;		StoragePolicyName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyDevicePath(path string) (string, error) {
0000000000000000000000000000000000000000;;		if pathExists, err := volumeutil.PathExists(path); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Error checking if path exists: %v", err)
0000000000000000000000000000000000000000;;		} else if pathExists {
0000000000000000000000000000000000000000;;			return path, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateVolume creates a vSphere volume.
0000000000000000000000000000000000000000;;	func (util *VsphereDiskUtil) CreateVolume(v *vsphereVolumeProvisioner) (volSpec *VolumeSpec, err error) {
0000000000000000000000000000000000000000;;		var fstype string
0000000000000000000000000000000000000000;;		cloud, err := getCloudProvider(v.plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capacity := v.options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		volSizeBytes := capacity.Value()
0000000000000000000000000000000000000000;;		// vSphere works with kilobytes, convert to KiB with rounding up
0000000000000000000000000000000000000000;;		volSizeKB := int(volume.RoundUpSize(volSizeBytes, 1024))
0000000000000000000000000000000000000000;;		name := volume.GenerateVolumeName(v.options.ClusterName, v.options.PVName, 255)
0000000000000000000000000000000000000000;;		volumeOptions := &vsphere.VolumeOptions{
0000000000000000000000000000000000000000;;			CapacityKB: volSizeKB,
0000000000000000000000000000000000000000;;			Tags:       *v.options.CloudTags,
0000000000000000000000000000000000000000;;			Name:       name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply Parameters (case-insensitive). We leave validation of
0000000000000000000000000000000000000000;;		// the values to the cloud provider.
0000000000000000000000000000000000000000;;		for parameter, value := range v.options.Parameters {
0000000000000000000000000000000000000000;;			switch strings.ToLower(parameter) {
0000000000000000000000000000000000000000;;			case diskformat:
0000000000000000000000000000000000000000;;				volumeOptions.DiskFormat = value
0000000000000000000000000000000000000000;;			case datastore:
0000000000000000000000000000000000000000;;				volumeOptions.Datastore = value
0000000000000000000000000000000000000000;;			case Fstype:
0000000000000000000000000000000000000000;;				fstype = value
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Setting fstype as %q", fstype)
0000000000000000000000000000000000000000;;			case StoragePolicyName:
0000000000000000000000000000000000000000;;				volumeOptions.StoragePolicyName = value
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Setting StoragePolicyName as %q", volumeOptions.StoragePolicyName)
0000000000000000000000000000000000000000;;			case HostFailuresToTolerateCapability, ForceProvisioningCapability,
0000000000000000000000000000000000000000;;				CacheReservationCapability, DiskStripesCapability,
0000000000000000000000000000000000000000;;				ObjectSpaceReservationCapability, IopsLimitCapability:
0000000000000000000000000000000000000000;;				capabilityData, err := validateVSANCapability(strings.ToLower(parameter), value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				volumeOptions.VSANStorageProfileData += capabilityData
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid option %q for volume plugin %s", parameter, v.plugin.GetPluginName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volumeOptions.VSANStorageProfileData != "" {
0000000000000000000000000000000000000000;;			if volumeOptions.StoragePolicyName != "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Cannot specify storage policy capabilities along with storage policy name. Please specify only one.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeOptions.VSANStorageProfileData = "(" + volumeOptions.VSANStorageProfileData + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("VSANStorageProfileData in vsphere volume %q", volumeOptions.VSANStorageProfileData)
0000000000000000000000000000000000000000;;		// TODO: implement PVC.Selector parsing
0000000000000000000000000000000000000000;;		if v.options.PVC.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("claim.Spec.Selector is not supported for dynamic provisioning on vSphere")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vmDiskPath, err := cloud.CreateVolume(volumeOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error creating vsphere volume: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volSpec = &VolumeSpec{
0000000000000000000000000000000000000000;;			Path:              vmDiskPath,
0000000000000000000000000000000000000000;;			Size:              volSizeKB,
0000000000000000000000000000000000000000;;			Fstype:            fstype,
0000000000000000000000000000000000000000;;			StoragePolicyName: volumeOptions.StoragePolicyName,
0000000000000000000000000000000000000000;;			StoragePolicyID:   volumeOptions.StoragePolicyID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully created vsphere volume %s", name)
0000000000000000000000000000000000000000;;		return volSpec, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteVolume deletes a vSphere volume.
0000000000000000000000000000000000000000;;	func (util *VsphereDiskUtil) DeleteVolume(vd *vsphereVolumeDeleter) error {
0000000000000000000000000000000000000000;;		cloud, err := getCloudProvider(vd.plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = cloud.DeleteVolume(vd.volPath); err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Error deleting vsphere volume %s: %v", vd.volPath, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Successfully deleted vsphere volume %s", vd.volPath)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolPathfromDeviceMountPath(deviceMountPath string) string {
0000000000000000000000000000000000000000;;		// Assumption: No file or folder is named starting with '[' in datastore
0000000000000000000000000000000000000000;;		volPath := deviceMountPath[strings.LastIndex(deviceMountPath, "["):]
0000000000000000000000000000000000000000;;		// space between datastore and vmdk name in volumePath is encoded as '\040' when returned by GetMountRefs().
0000000000000000000000000000000000000000;;		// volumePath eg: "[local] xxx.vmdk" provided to attach/mount
0000000000000000000000000000000000000000;;		// replacing \040 with space to match the actual volumePath
0000000000000000000000000000000000000000;;		return strings.Replace(volPath, "\\040", " ", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCloudProvider(cloud cloudprovider.Interface) (*vsphere.VSphere, error) {
0000000000000000000000000000000000000000;;		if cloud == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Cloud provider not initialized properly")
0000000000000000000000000000000000000000;;			return nil, errors.New("Cloud provider not initialized properly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vs := cloud.(*vsphere.VSphere)
0000000000000000000000000000000000000000;;		if vs == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("Invalid cloud provider: expected vSphere")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate the capability requirement for the user specified policy attributes.
0000000000000000000000000000000000000000;;	func validateVSANCapability(capabilityName string, capabilityValue string) (string, error) {
0000000000000000000000000000000000000000;;		var capabilityData string
0000000000000000000000000000000000000000;;		capabilityIntVal, ok := verifyCapabilityValueIsInteger(capabilityValue)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Invalid value for %s. The capabilityValue: %s must be a valid integer value", capabilityName, capabilityValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch strings.ToLower(capabilityName) {
0000000000000000000000000000000000000000;;		case HostFailuresToTolerateCapability:
0000000000000000000000000000000000000000;;			if capabilityIntVal >= HostFailuresToTolerateCapabilityMin && capabilityIntVal <= HostFailuresToTolerateCapabilityMax {
0000000000000000000000000000000000000000;;				capabilityData = " (\"hostFailuresToTolerate\" i" + capabilityValue + ")"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(`Invalid value for hostFailuresToTolerate.
0000000000000000000000000000000000000000;;					The default value is %d, minimum value is %d and maximum value is %d.`,
0000000000000000000000000000000000000000;;					1, HostFailuresToTolerateCapabilityMin, HostFailuresToTolerateCapabilityMax)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ForceProvisioningCapability:
0000000000000000000000000000000000000000;;			if capabilityIntVal >= ForceProvisioningCapabilityMin && capabilityIntVal <= ForceProvisioningCapabilityMax {
0000000000000000000000000000000000000000;;				capabilityData = " (\"forceProvisioning\" i" + capabilityValue + ")"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(`Invalid value for forceProvisioning.
0000000000000000000000000000000000000000;;					The value can be either %d or %d.`,
0000000000000000000000000000000000000000;;					ForceProvisioningCapabilityMin, ForceProvisioningCapabilityMax)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CacheReservationCapability:
0000000000000000000000000000000000000000;;			if capabilityIntVal >= CacheReservationCapabilityMin && capabilityIntVal <= CacheReservationCapabilityMax {
0000000000000000000000000000000000000000;;				capabilityData = " (\"cacheReservation\" i" + strconv.Itoa(capabilityIntVal*10000) + ")"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(`Invalid value for cacheReservation.
0000000000000000000000000000000000000000;;					The minimum percentage is %d and maximum percentage is %d.`,
0000000000000000000000000000000000000000;;					CacheReservationCapabilityMin, CacheReservationCapabilityMax)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case DiskStripesCapability:
0000000000000000000000000000000000000000;;			if capabilityIntVal >= DiskStripesCapabilityMin && capabilityIntVal <= DiskStripesCapabilityMax {
0000000000000000000000000000000000000000;;				capabilityData = " (\"stripeWidth\" i" + capabilityValue + ")"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(`Invalid value for diskStripes.
0000000000000000000000000000000000000000;;					The minimum value is %d and maximum value is %d.`,
0000000000000000000000000000000000000000;;					DiskStripesCapabilityMin, DiskStripesCapabilityMax)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ObjectSpaceReservationCapability:
0000000000000000000000000000000000000000;;			if capabilityIntVal >= ObjectSpaceReservationCapabilityMin && capabilityIntVal <= ObjectSpaceReservationCapabilityMax {
0000000000000000000000000000000000000000;;				capabilityData = " (\"proportionalCapacity\" i" + capabilityValue + ")"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(`Invalid value for ObjectSpaceReservation.
0000000000000000000000000000000000000000;;					The minimum percentage is %d and maximum percentage is %d.`,
0000000000000000000000000000000000000000;;					ObjectSpaceReservationCapabilityMin, ObjectSpaceReservationCapabilityMax)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case IopsLimitCapability:
0000000000000000000000000000000000000000;;			if capabilityIntVal >= IopsLimitCapabilityMin {
0000000000000000000000000000000000000000;;				capabilityData = " (\"iopsLimit\" i" + capabilityValue + ")"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf(`Invalid value for iopsLimit.
0000000000000000000000000000000000000000;;					The value should be greater than %d.`, IopsLimitCapabilityMin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return capabilityData, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify if the capability value is of type integer.
0000000000000000000000000000000000000000;;	func verifyCapabilityValueIsInteger(capabilityValue string) (int, bool) {
0000000000000000000000000000000000000000;;		i, err := strconv.Atoi(capabilityValue)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i, true
0000000000000000000000000000000000000000;;	}
