0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
9eb4d432b448d169e4f7ec0574876a0c4254faf2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package vsphere_volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/vsphere"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceName_Volume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		volPath := "[local] volumes/test"
0000000000000000000000000000000000000000;;		spec := createVolSpec(volPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deviceName != volPath {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: expected %s, got %s", volPath, deviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetDeviceName_PersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		volPath := "[local] volumes/test"
0000000000000000000000000000000000000000;;		spec := createPVSpec(volPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deviceName != volPath {
0000000000000000000000000000000000000000;;			t.Errorf("GetDeviceName error: expected %s, got %s", volPath, deviceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// One testcase for TestAttachDetach table test below
0000000000000000000000000000000000000000;;	type testcase struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// For fake vSphere:
0000000000000000000000000000000000000000;;		attach         attachCall
0000000000000000000000000000000000000000;;		detach         detachCall
0000000000000000000000000000000000000000;;		diskIsAttached diskIsAttachedCall
0000000000000000000000000000000000000000;;		t              *testing.T
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Actual test to run
0000000000000000000000000000000000000000;;		test func(test *testcase) (string, error)
0000000000000000000000000000000000000000;;		// Expected return of the test
0000000000000000000000000000000000000000;;		expectedDevice string
0000000000000000000000000000000000000000;;		expectedError  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAttachDetach(t *testing.T) {
0000000000000000000000000000000000000000;;		uuid := "00000000000000"
0000000000000000000000000000000000000000;;		diskName := "[local] volumes/test"
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("host")
0000000000000000000000000000000000000000;;		spec := createVolSpec(diskName)
0000000000000000000000000000000000000000;;		attachError := errors.New("Fake attach error")
0000000000000000000000000000000000000000;;		detachError := errors.New("Fake detach error")
0000000000000000000000000000000000000000;;		diskCheckError := errors.New("Fake DiskIsAttached error")
0000000000000000000000000000000000000000;;		tests := []testcase{
0000000000000000000000000000000000000000;;			// Successful Attach call
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "Attach_Positive",
0000000000000000000000000000000000000000;;				attach: attachCall{diskName, nodeName, uuid, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedDevice: "/dev/disk/by-id/wwn-0x" + uuid,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Attach call fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "Attach_Negative",
0000000000000000000000000000000000000000;;				attach: attachCall{diskName, nodeName, "", attachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: attachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, true, nil},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disk is already detached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive_AlreadyDetached",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds when DiskIsAttached fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive_CheckFails",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Negative",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, detachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(diskName, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: detachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testcase := range tests {
0000000000000000000000000000000000000000;;			testcase.t = t
0000000000000000000000000000000000000000;;			device, err := testcase.test(&testcase)
0000000000000000000000000000000000000000;;			if err != testcase.expectedError {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed: expected err=%q, got %q", testcase.name, testcase.expectedError.Error(), err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if device != testcase.expectedDevice {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed: expected device=%q, got %q", testcase.name, testcase.expectedDevice, device)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("Test %q succeeded", testcase.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPlugin creates a new vsphereVolumePlugin with fake cloud, NewAttacher
0000000000000000000000000000000000000000;;	// and NewDetacher won't work.
0000000000000000000000000000000000000000;;	func newPlugin() *vsphereVolumePlugin {
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost("/tmp", nil, nil)
0000000000000000000000000000000000000000;;		plugins := ProbeVolumePlugins()
0000000000000000000000000000000000000000;;		plugin := plugins[0]
0000000000000000000000000000000000000000;;		plugin.Init(host)
0000000000000000000000000000000000000000;;		return plugin.(*vsphereVolumePlugin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAttacher(testcase *testcase) *vsphereVMDKAttacher {
0000000000000000000000000000000000000000;;		return &vsphereVMDKAttacher{
0000000000000000000000000000000000000000;;			host:           nil,
0000000000000000000000000000000000000000;;			vsphereVolumes: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDetacher(testcase *testcase) *vsphereVMDKDetacher {
0000000000000000000000000000000000000000;;		return &vsphereVMDKDetacher{
0000000000000000000000000000000000000000;;			vsphereVolumes: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createVolSpec(name string) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					VsphereVolume: &v1.VsphereVirtualDiskVolumeSource{
0000000000000000000000000000000000000000;;						VolumePath: name,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPVSpec(name string) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			PersistentVolume: &v1.PersistentVolume{
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						VsphereVolume: &v1.VsphereVirtualDiskVolumeSource{
0000000000000000000000000000000000000000;;							VolumePath: name,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake vSphere implementation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type attachCall struct {
0000000000000000000000000000000000000000;;		diskName      string
0000000000000000000000000000000000000000;;		nodeName      types.NodeName
0000000000000000000000000000000000000000;;		retDeviceUUID string
0000000000000000000000000000000000000000;;		ret           error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type detachCall struct {
0000000000000000000000000000000000000000;;		diskName string
0000000000000000000000000000000000000000;;		nodeName types.NodeName
0000000000000000000000000000000000000000;;		ret      error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type diskIsAttachedCall struct {
0000000000000000000000000000000000000000;;		diskName   string
0000000000000000000000000000000000000000;;		nodeName   types.NodeName
0000000000000000000000000000000000000000;;		isAttached bool
0000000000000000000000000000000000000000;;		ret        error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) AttachDisk(diskName string, storagePolicyName string, nodeName types.NodeName) (string, string, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.attach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.attach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// AttachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;			return "", "", errors.New("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return "", "", errors.New("Unexpected AttachDisk call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return "", "", errors.New("Unexpected AttachDisk call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("AttachDisk call: %s, %s, returning %q, %v", diskName, nodeName, expected.retDeviceUUID, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", expected.retDeviceUUID, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DetachDisk(diskName string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		expected := &testcase.detach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.detach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// DetachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return errors.New("Unexpected DetachDisk call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DetachDisk call: %s, %s, returning %v", diskName, nodeName, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DiskIsAttached(diskName string, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.diskIsAttached
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.diskIsAttached looks uninitialized, test did not expect to
0000000000000000000000000000000000000000;;			// call DiskIsAttached
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DiskIsAttached call: %s, %s, returning %v, %v", diskName, nodeName, expected.isAttached, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.isAttached, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DisksAreAttached(diskNames []string, nodeName types.NodeName) (map[string]bool, error) {
0000000000000000000000000000000000000000;;		return nil, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) CreateVolume(volumeOptions *vsphere.VolumeOptions) (volumePath string, err error) {
0000000000000000000000000000000000000000;;		return "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DeleteVolume(vmDiskPath string) error {
0000000000000000000000000000000000000000;;		return errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
