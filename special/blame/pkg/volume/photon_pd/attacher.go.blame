0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d6825686a3614f2a83a58338ae1cabf7e3bbea85;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package photon_pd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/photon"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type photonPersistentDiskAttacher struct {
0000000000000000000000000000000000000000;;		host        volume.VolumeHost
0000000000000000000000000000000000000000;;		photonDisks photon.Disks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Attacher = &photonPersistentDiskAttacher{}
0000000000000000000000000000000000000000;;	var _ volume.AttachableVolumePlugin = &photonPersistentDiskPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *photonPersistentDiskPlugin) NewAttacher() (volume.Attacher, error) {
0000000000000000000000000000000000000000;;		photonCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Controller attacher: NewAttacher failed to get cloud provider")
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &photonPersistentDiskAttacher{
0000000000000000000000000000000000000000;;			host:        plugin.host,
0000000000000000000000000000000000000000;;			photonDisks: photonCloud,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attaches the volume specified by the given spec to the given host.
0000000000000000000000000000000000000000;;	// On success, returns the device path where the device was attached on the
0000000000000000000000000000000000000000;;	// node.
0000000000000000000000000000000000000000;;	// Callers are responsible for retryinging on failure.
0000000000000000000000000000000000000000;;	// Callers are responsible for thread safety between concurrent attach and
0000000000000000000000000000000000000000;;	// detach operations.
0000000000000000000000000000000000000000;;	func (attacher *photonPersistentDiskAttacher) Attach(spec *volume.Spec, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		hostName := string(nodeName)
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Controller attacher: Attach failed to get volume source")
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Photon Controller: Attach disk called for host %s", hostName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: if disk is already attached?
0000000000000000000000000000000000000000;;		err = attacher.photonDisks.AttachDisk(volumeSource.PdID, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error attaching volume %q to node %q: %+v", volumeSource.PdID, nodeName, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PdidWithNoHypens := strings.Replace(volumeSource.PdID, "-", "", -1)
0000000000000000000000000000000000000000;;		return path.Join(diskByIDPath, diskPhotonPrefix+PdidWithNoHypens), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *photonPersistentDiskAttacher) VolumesAreAttached(specs []*volume.Spec, nodeName types.NodeName) (map[*volume.Spec]bool, error) {
0000000000000000000000000000000000000000;;		volumesAttachedCheck := make(map[*volume.Spec]bool)
0000000000000000000000000000000000000000;;		volumeSpecMap := make(map[string]*volume.Spec)
0000000000000000000000000000000000000000;;		pdIDList := []string{}
0000000000000000000000000000000000000000;;		for _, spec := range specs {
0000000000000000000000000000000000000000;;			volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error getting volume (%q) source : %v", spec.Name(), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pdIDList = append(pdIDList, volumeSource.PdID)
0000000000000000000000000000000000000000;;			volumesAttachedCheck[spec] = true
0000000000000000000000000000000000000000;;			volumeSpecMap[volumeSource.PdID] = spec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachedResult, err := attacher.photonDisks.DisksAreAttached(pdIDList, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf(
0000000000000000000000000000000000000000;;				"Error checking if volumes (%v) are attached to current node (%q). err=%v",
0000000000000000000000000000000000000000;;				pdIDList, nodeName, err)
0000000000000000000000000000000000000000;;			return volumesAttachedCheck, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for pdID, attached := range attachedResult {
0000000000000000000000000000000000000000;;			if !attached {
0000000000000000000000000000000000000000;;				spec := volumeSpecMap[pdID]
0000000000000000000000000000000000000000;;				volumesAttachedCheck[spec] = false
0000000000000000000000000000000000000000;;				glog.V(2).Infof("VolumesAreAttached: check volume %q (specName: %q) is no longer attached", pdID, spec.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumesAttachedCheck, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *photonPersistentDiskAttacher) WaitForAttach(spec *volume.Spec, devicePath string, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Controller attacher: WaitForAttach failed to get volume source")
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if devicePath == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("WaitForAttach failed for PD %s: devicePath is empty.", volumeSource.PdID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scan scsi path to discover the new disk
0000000000000000000000000000000000000000;;		scsiHostScan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(checkSleepDuration)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timer := time.NewTimer(timeout)
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Checking PD %s is attached", volumeSource.PdID)
0000000000000000000000000000000000000000;;				checkPath, err := verifyDevicePath(devicePath)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Log error, if any, and continue checking periodically. See issue #11321
0000000000000000000000000000000000000000;;					glog.Warningf("Photon Controller attacher: WaitForAttach with devicePath %s Checking PD %s Error verify path", devicePath, volumeSource.PdID)
0000000000000000000000000000000000000000;;				} else if checkPath != "" {
0000000000000000000000000000000000000000;;					// A device path has successfully been created for the VMDK
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Successfully found attached PD %s.", volumeSource.PdID)
0000000000000000000000000000000000000000;;					// map path with spec.Name()
0000000000000000000000000000000000000000;;					volName := spec.Name()
0000000000000000000000000000000000000000;;					realPath, _ := filepath.EvalSymlinks(devicePath)
0000000000000000000000000000000000000000;;					deviceName := path.Base(realPath)
0000000000000000000000000000000000000000;;					volNameToDeviceName[volName] = deviceName
0000000000000000000000000000000000000000;;					return devicePath, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer.C:
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("Could not find attached PD %s. Timeout waiting for mount paths to be created.", volumeSource.PdID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDeviceMountPath returns a path where the device should
0000000000000000000000000000000000000000;;	// point which should be bind mounted for individual volumes.
0000000000000000000000000000000000000000;;	func (attacher *photonPersistentDiskAttacher) GetDeviceMountPath(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Controller attacher: GetDeviceMountPath failed to get volume source")
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return makeGlobalPDPath(attacher.host, volumeSource.PdID), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMountDeviceRefs finds all other references to the device referenced
0000000000000000000000000000000000000000;;	// by deviceMountPath; returns a list of paths.
0000000000000000000000000000000000000000;;	func (plugin *photonPersistentDiskPlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		return mount.GetMountRefs(mounter, deviceMountPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MountDevice mounts device to global mount point.
0000000000000000000000000000000000000000;;	func (attacher *photonPersistentDiskAttacher) MountDevice(spec *volume.Spec, devicePath string, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		mounter := attacher.host.GetMounter()
0000000000000000000000000000000000000000;;		notMnt, err := mounter.IsLikelyNotMountPoint(deviceMountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(deviceMountPath, 0750); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to create directory at %#v. err: %s", deviceMountPath, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Controller attacher: MountDevice failed to get volume source. err: %s", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			diskMounter := &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()}
0000000000000000000000000000000000000000;;			mountOptions := volume.MountOptionFromSpec(spec)
0000000000000000000000000000000000000000;;			err = diskMounter.FormatAndMount(devicePath, deviceMountPath, volumeSource.FSType, mountOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				os.Remove(deviceMountPath)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("formatting spec %v devicePath %v deviceMountPath %v fs %v with options %+v", spec.Name(), devicePath, deviceMountPath, volumeSource.FSType, options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type photonPersistentDiskDetacher struct {
0000000000000000000000000000000000000000;;		mounter     mount.Interface
0000000000000000000000000000000000000000;;		photonDisks photon.Disks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Detacher = &photonPersistentDiskDetacher{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *photonPersistentDiskPlugin) NewDetacher() (volume.Detacher, error) {
0000000000000000000000000000000000000000;;		photonCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Photon Controller attacher: NewDetacher failed to get cloud provider. err: %s", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &photonPersistentDiskDetacher{
0000000000000000000000000000000000000000;;			mounter:     plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;			photonDisks: photonCloud,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detach the given device from the given host.
0000000000000000000000000000000000000000;;	func (detacher *photonPersistentDiskDetacher) Detach(deviceMountPath string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostName := string(nodeName)
0000000000000000000000000000000000000000;;		pdID := deviceMountPath
0000000000000000000000000000000000000000;;		attached, err := detacher.photonDisks.DiskIsAttached(pdID, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log error and continue with detach
0000000000000000000000000000000000000000;;			glog.Errorf(
0000000000000000000000000000000000000000;;				"Error checking if persistent disk (%q) is already attached to current node (%q). Will continue and try detach anyway. err=%v",
0000000000000000000000000000000000000000;;				pdID, hostName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil && !attached {
0000000000000000000000000000000000000000;;			// Volume is already detached from node.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("detach operation was successful. persistent disk %q is already detached from node %q.", pdID, hostName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := detacher.photonDisks.DetachDisk(pdID, nodeName); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error detaching volume %q: %v", pdID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (detacher *photonPersistentDiskDetacher) WaitForDetach(devicePath string, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(checkSleepDuration)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		timer := time.NewTimer(timeout)
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Checking device %q is detached.", devicePath)
0000000000000000000000000000000000000000;;				if pathExists, err := volumeutil.PathExists(devicePath); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Error checking if device path exists: %v", err)
0000000000000000000000000000000000000000;;				} else if !pathExists {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer.C:
0000000000000000000000000000000000000000;;				return fmt.Errorf("Timeout reached; Device %v is still attached", devicePath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (detacher *photonPersistentDiskDetacher) UnmountDevice(deviceMountPath string) error {
0000000000000000000000000000000000000000;;		return volumeutil.UnmountPath(deviceMountPath, detacher.mounter)
0000000000000000000000000000000000000000;;	}
