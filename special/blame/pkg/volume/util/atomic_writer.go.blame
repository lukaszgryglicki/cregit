0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c10aef7c9acdf312ef2acff60af961f833d59c82;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxFileNameLength = 255
0000000000000000000000000000000000000000;;		maxPathLength     = 4096
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AtomicWriter handles atomically projecting content for a set of files into
0000000000000000000000000000000000000000;;	// a target directory.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. AtomicWriter reserves the set of pathnames starting with `..`.
0000000000000000000000000000000000000000;;	// 2. AtomicWriter offers no concurrency guarantees and must be synchronized
0000000000000000000000000000000000000000;;	//    by the caller.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The visible files in this volume are symlinks to files in the writer's data
0000000000000000000000000000000000000000;;	// directory.  Actual files are stored in a hidden timestamped directory which
0000000000000000000000000000000000000000;;	// is symlinked to by the data directory. The timestamped directory and
0000000000000000000000000000000000000000;;	// data directory symlink are created in the writer's target dir.  This scheme
0000000000000000000000000000000000000000;;	// allows the files to be atomically updated by changing the target of the
0000000000000000000000000000000000000000;;	// data directory symlink.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Consumers of the target directory can monitor the ..data symlink using
0000000000000000000000000000000000000000;;	// inotify or fanotify to receive events when the content in the volume is
0000000000000000000000000000000000000000;;	// updated.
0000000000000000000000000000000000000000;;	type AtomicWriter struct {
0000000000000000000000000000000000000000;;		targetDir  string
0000000000000000000000000000000000000000;;		logContext string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FileProjection struct {
0000000000000000000000000000000000000000;;		Data []byte
0000000000000000000000000000000000000000;;		Mode int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAtomicWriter creates a new AtomicWriter configured to write to the given
0000000000000000000000000000000000000000;;	// target directory, or returns an error if the target directory does not exist.
0000000000000000000000000000000000000000;;	func NewAtomicWriter(targetDir string, logContext string) (*AtomicWriter, error) {
0000000000000000000000000000000000000000;;		_, err := os.Stat(targetDir)
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &AtomicWriter{targetDir: targetDir, logContext: logContext}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dataDirName    = "..data"
0000000000000000000000000000000000000000;;		newDataDirName = "..data_tmp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write does an atomic projection of the given payload into the writer's target
0000000000000000000000000000000000000000;;	// directory.  Input paths must not begin with '..'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Write algorithm is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  1.  The payload is validated; if the payload is invalid, the function returns
0000000000000000000000000000000000000000;;	//  2.  The user-visible portion of the volume is walked to determine whether any
0000000000000000000000000000000000000000;;	//      portion of the payload was deleted and is still present on disk.
0000000000000000000000000000000000000000;;	//      If the payload is already present on disk and there are no deleted files,
0000000000000000000000000000000000000000;;	//      the function returns
0000000000000000000000000000000000000000;;	//  3.  A check is made to determine whether data present in the payload has changed
0000000000000000000000000000000000000000;;	//  4.  A new timestamped dir is created
0000000000000000000000000000000000000000;;	//  5.  The payload is written to the new timestamped directory
0000000000000000000000000000000000000000;;	//  6.  Symlinks and directory for new user-visible files are created (if needed).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      For example, consider the files:
0000000000000000000000000000000000000000;;	//        <target-dir>/podName
0000000000000000000000000000000000000000;;	//        <target-dir>/user/labels
0000000000000000000000000000000000000000;;	//        <target-dir>/k8s/annotations
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      The user visible files are symbolic links into the internal data directory:
0000000000000000000000000000000000000000;;	//        <target-dir>/podName         -> ..data/podName
0000000000000000000000000000000000000000;;	//        <target-dir>/usr/labels      -> ../..data/usr/labels
0000000000000000000000000000000000000000;;	//        <target-dir>/k8s/annotations -> ../..data/k8s/annotations
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Relative links are created into the data directory for files in subdirectories.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      The data directory itself is a link to a timestamped directory with
0000000000000000000000000000000000000000;;	//      the real data:
0000000000000000000000000000000000000000;;	//        <target-dir>/..data          -> ..2016_02_01_15_04_05.12345678/
0000000000000000000000000000000000000000;;	//  7.  The current timestamped directory is detected by reading the data directory
0000000000000000000000000000000000000000;;	//      symlink
0000000000000000000000000000000000000000;;	//  8.  A symlink to the new timestamped directory ..data_tmp is created that will
0000000000000000000000000000000000000000;;	//      become the new data directory
0000000000000000000000000000000000000000;;	//  9.  The new data directory symlink is renamed to the data directory; rename is atomic
0000000000000000000000000000000000000000;;	// 10.  Old paths are removed from the user-visible portion of the target directory
0000000000000000000000000000000000000000;;	// 11.  The previous timestamped directory is removed, if it exists
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) Write(payload map[string]FileProjection) error {
0000000000000000000000000000000000000000;;		// (1)
0000000000000000000000000000000000000000;;		cleanPayload, err := validatePayload(payload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: invalid payload: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (2)
0000000000000000000000000000000000000000;;		pathsToRemove, err := w.pathsToRemove(cleanPayload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error determining user-visible files to remove: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (3)
0000000000000000000000000000000000000000;;		if should, err := w.shouldWritePayload(cleanPayload); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error determining whether payload should be written to disk: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if !should && len(pathsToRemove) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("%s: no update required for target directory %v", w.logContext, w.targetDir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("%s: write required for target directory %v", w.logContext, w.targetDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (4)
0000000000000000000000000000000000000000;;		tsDir, err := w.newTimestampDir()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("%s: error creating new ts data directory: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (5)
0000000000000000000000000000000000000000;;		if err = w.writePayloadToDir(cleanPayload, tsDir); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error writing payload to ts data directory %s: %v", w.logContext, tsDir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("%s: performed write of new data to ts data directory: %s", w.logContext, tsDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (6)
0000000000000000000000000000000000000000;;		if err = w.createUserVisibleFiles(cleanPayload); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error creating visible symlinks in %s: %v", w.logContext, w.targetDir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (7)
0000000000000000000000000000000000000000;;		_, tsDirName := filepath.Split(tsDir)
0000000000000000000000000000000000000000;;		dataDirPath := path.Join(w.targetDir, dataDirName)
0000000000000000000000000000000000000000;;		oldTsDir, err := os.Readlink(dataDirPath)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error reading link for data directory: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (8)
0000000000000000000000000000000000000000;;		newDataDirPath := path.Join(w.targetDir, newDataDirName)
0000000000000000000000000000000000000000;;		if err = os.Symlink(tsDirName, newDataDirPath); err != nil {
0000000000000000000000000000000000000000;;			os.RemoveAll(tsDir)
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error creating symbolic link for atomic update: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (9)
0000000000000000000000000000000000000000;;		if runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			os.Remove(dataDirPath)
0000000000000000000000000000000000000000;;			err = os.Symlink(tsDirName, dataDirPath)
0000000000000000000000000000000000000000;;			os.Remove(newDataDirPath)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = os.Rename(newDataDirPath, dataDirPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			os.Remove(newDataDirPath)
0000000000000000000000000000000000000000;;			os.RemoveAll(tsDir)
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error renaming symbolic link for data directory %s: %v", w.logContext, newDataDirPath, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (10)
0000000000000000000000000000000000000000;;		if err = w.removeUserVisiblePaths(pathsToRemove); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: error removing old visible symlinks: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// (11)
0000000000000000000000000000000000000000;;		if len(oldTsDir) > 0 {
0000000000000000000000000000000000000000;;			if err = os.RemoveAll(path.Join(w.targetDir, oldTsDir)); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("%s: error removing old data directory %s: %v", w.logContext, oldTsDir, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePayload returns an error if any path in the payload  returns a copy of the payload with the paths cleaned.
0000000000000000000000000000000000000000;;	func validatePayload(payload map[string]FileProjection) (map[string]FileProjection, error) {
0000000000000000000000000000000000000000;;		cleanPayload := make(map[string]FileProjection)
0000000000000000000000000000000000000000;;		for k, content := range payload {
0000000000000000000000000000000000000000;;			if err := validatePath(k); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cleanPayload[path.Clean(k)] = content
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cleanPayload, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePath validates a single path, returning an error if the path is
0000000000000000000000000000000000000000;;	// invalid.  paths may not:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. be absolute
0000000000000000000000000000000000000000;;	// 2. contain '..' as an element
0000000000000000000000000000000000000000;;	// 3. start with '..'
0000000000000000000000000000000000000000;;	// 4. contain filenames larger than 255 characters
0000000000000000000000000000000000000000;;	// 5. be longer than 4096 characters
0000000000000000000000000000000000000000;;	func validatePath(targetPath string) error {
0000000000000000000000000000000000000000;;		// TODO: somehow unify this with the similar api validation,
0000000000000000000000000000000000000000;;		// validateVolumeSourcePath; the error semantics are just different enough
0000000000000000000000000000000000000000;;		// from this that it was time-prohibitive trying to find the right
0000000000000000000000000000000000000000;;		// refactoring to re-use.
0000000000000000000000000000000000000000;;		if targetPath == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid path: must not be empty: %q", targetPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if path.IsAbs(targetPath) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid path: must be relative path: %s", targetPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(targetPath) > maxPathLength {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid path: must be less than %d characters", maxPathLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := strings.Split(targetPath, string(os.PathSeparator))
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if item == ".." {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid path: must not contain '..': %s", targetPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(item) > maxFileNameLength {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid path: filenames must be less than %d characters", maxFileNameLength)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(items[0], "..") && len(items[0]) > 2 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid path: must not start with '..': %s", targetPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldWritePayload returns whether the payload should be written to disk.
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) shouldWritePayload(payload map[string]FileProjection) (bool, error) {
0000000000000000000000000000000000000000;;		for userVisiblePath, fileProjection := range payload {
0000000000000000000000000000000000000000;;			shouldWrite, err := w.shouldWriteFile(path.Join(w.targetDir, userVisiblePath), fileProjection.Data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if shouldWrite {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldWriteFile returns whether a new version of a file should be written to disk.
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) shouldWriteFile(path string, content []byte) (bool, error) {
0000000000000000000000000000000000000000;;		_, err := os.Lstat(path)
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contentOnFs, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return (bytes.Compare(content, contentOnFs) != 0), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pathsToRemove walks the user-visible portion of the target directory and
0000000000000000000000000000000000000000;;	// determines which paths should be removed (if any) after the payload is
0000000000000000000000000000000000000000;;	// written to the target directory.
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) pathsToRemove(payload map[string]FileProjection) (sets.String, error) {
0000000000000000000000000000000000000000;;		paths := sets.NewString()
0000000000000000000000000000000000000000;;		visitor := func(path string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			if path == w.targetDir {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			relativePath := strings.TrimPrefix(path, w.targetDir)
0000000000000000000000000000000000000000;;			relativePath = strings.TrimPrefix(relativePath, string(os.PathSeparator))
0000000000000000000000000000000000000000;;			if strings.HasPrefix(relativePath, "..") {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			paths.Insert(relativePath)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := filepath.Walk(w.targetDir, visitor)
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("%s: current paths:   %+v", w.targetDir, paths.List())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newPaths := sets.NewString()
0000000000000000000000000000000000000000;;		for file := range payload {
0000000000000000000000000000000000000000;;			// add all subpaths for the payload to the set of new paths
0000000000000000000000000000000000000000;;			// to avoid attempting to remove non-empty dirs
0000000000000000000000000000000000000000;;			for subPath := file; subPath != ""; {
0000000000000000000000000000000000000000;;				newPaths.Insert(subPath)
0000000000000000000000000000000000000000;;				subPath, _ = filepath.Split(subPath)
0000000000000000000000000000000000000000;;				subPath = strings.TrimSuffix(subPath, string(os.PathSeparator))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("%s: new paths:       %+v", w.targetDir, newPaths.List())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := paths.Difference(newPaths)
0000000000000000000000000000000000000000;;		glog.V(5).Infof("%s: paths to remove: %+v", w.targetDir, result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTimestampDir creates a new timestamp directory
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) newTimestampDir() (string, error) {
0000000000000000000000000000000000000000;;		tsDir, err := ioutil.TempDir(w.targetDir, fmt.Sprintf("..%s.", time.Now().Format("1981_02_01_15_04_05")))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: unable to create new temp directory: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 0755 permissions are needed to allow 'group' and 'other' to recurse the
0000000000000000000000000000000000000000;;		// directory tree.  do a chmod here to ensure that permissions are set correctly
0000000000000000000000000000000000000000;;		// regardless of the process' umask.
0000000000000000000000000000000000000000;;		err = os.Chmod(tsDir, 0755)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("%s: unable to set mode on new temp directory: %v", w.logContext, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tsDir, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writePayloadToDir writes the given payload to the given directory.  The
0000000000000000000000000000000000000000;;	// directory must exist.
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) writePayloadToDir(payload map[string]FileProjection, dir string) error {
0000000000000000000000000000000000000000;;		for userVisiblePath, fileProjection := range payload {
0000000000000000000000000000000000000000;;			content := fileProjection.Data
0000000000000000000000000000000000000000;;			mode := os.FileMode(fileProjection.Mode)
0000000000000000000000000000000000000000;;			fullPath := path.Join(dir, userVisiblePath)
0000000000000000000000000000000000000000;;			baseDir, _ := filepath.Split(fullPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := os.MkdirAll(baseDir, os.ModePerm)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("%s: unable to create directory %s: %v", w.logContext, baseDir, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = ioutil.WriteFile(fullPath, content, mode)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("%s: unable to write file %s with mode %v: %v", w.logContext, fullPath, mode, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Chmod is needed because ioutil.WriteFile() ends up calling
0000000000000000000000000000000000000000;;			// open(2) to create the file, so the final mode used is "mode &
0000000000000000000000000000000000000000;;			// ~umask". But we want to make sure the specified mode is used
0000000000000000000000000000000000000000;;			// in the file no matter what the umask is.
0000000000000000000000000000000000000000;;			err = os.Chmod(fullPath, mode)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("%s: unable to write file %s with mode %v: %v", w.logContext, fullPath, mode, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createUserVisibleFiles creates the relative symlinks for all the
0000000000000000000000000000000000000000;;	// files configured in the payload. If the directory in a file path does not
0000000000000000000000000000000000000000;;	// exist, it is created.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Viz:
0000000000000000000000000000000000000000;;	// For files: "bar", "foo/bar", "baz/bar", "foo/baz/blah"
0000000000000000000000000000000000000000;;	// the following symlinks and subdirectories are created:
0000000000000000000000000000000000000000;;	// bar          -> ..data/bar
0000000000000000000000000000000000000000;;	// foo/bar      -> ../..data/foo/bar
0000000000000000000000000000000000000000;;	// baz/bar      -> ../..data/baz/bar
0000000000000000000000000000000000000000;;	// foo/baz/blah -> ../../..data/foo/baz/blah
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) createUserVisibleFiles(payload map[string]FileProjection) error {
0000000000000000000000000000000000000000;;		for userVisiblePath := range payload {
0000000000000000000000000000000000000000;;			dir, _ := filepath.Split(userVisiblePath)
0000000000000000000000000000000000000000;;			subDirs := 0
0000000000000000000000000000000000000000;;			if len(dir) > 0 {
0000000000000000000000000000000000000000;;				// If dir is not empty, the projection path contains at least one
0000000000000000000000000000000000000000;;				// subdirectory (example: userVisiblePath := "foo/bar").
0000000000000000000000000000000000000000;;				// Since filepath.Split leaves a trailing path separator, in this
0000000000000000000000000000000000000000;;				// example, dir = "foo/".  In order to calculate the number of
0000000000000000000000000000000000000000;;				// subdirectories, we must subtract 1 from the number returned by split.
0000000000000000000000000000000000000000;;				subDirs = len(strings.Split(dir, string(os.PathSeparator))) - 1
0000000000000000000000000000000000000000;;				err := os.MkdirAll(path.Join(w.targetDir, dir), os.ModePerm)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := os.Readlink(path.Join(w.targetDir, userVisiblePath))
0000000000000000000000000000000000000000;;			if err != nil && os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				// The link into the data directory for this path doesn't exist; create it,
0000000000000000000000000000000000000000;;				// respecting the number of subdirectories necessary to link
0000000000000000000000000000000000000000;;				// correctly back into the data directory.
0000000000000000000000000000000000000000;;				visibleFile := path.Join(w.targetDir, userVisiblePath)
0000000000000000000000000000000000000000;;				dataDirFile := path.Join(strings.Repeat("../", subDirs), dataDirName, userVisiblePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = os.Symlink(dataDirFile, visibleFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeUserVisiblePaths removes the set of paths from the user-visible
0000000000000000000000000000000000000000;;	// portion of the writer's target directory.
0000000000000000000000000000000000000000;;	func (w *AtomicWriter) removeUserVisiblePaths(paths sets.String) error {
0000000000000000000000000000000000000000;;		orderedPaths := paths.List()
0000000000000000000000000000000000000000;;		for ii := len(orderedPaths) - 1; ii >= 0; ii-- {
0000000000000000000000000000000000000000;;			if err := os.Remove(path.Join(w.targetDir, orderedPaths[ii])); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("%s: error pruning old user-visible path %s: %v", w.logContext, orderedPaths[ii], err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
