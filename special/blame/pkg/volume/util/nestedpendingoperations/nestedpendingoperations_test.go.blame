0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
286075669b66d5110f6cfa6ee795a8bdf44324fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package nestedpendingoperations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// testTimeout is a timeout of goroutines to finish. This _should_ be just a
0000000000000000000000000000000000000000;;		// "context switch" and it should take several ms, however, Clayton says "We
0000000000000000000000000000000000000000;;		// have had flakes due to tests that assumed that 15s is long enough to sleep")
0000000000000000000000000000000000000000;;		testTimeout time.Duration = 1 * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialOperationWaitTimeShort is the initial amount of time the test will
0000000000000000000000000000000000000000;;		// wait for an operation to complete (each successive failure results in
0000000000000000000000000000000000000000;;		// exponential backoff).
0000000000000000000000000000000000000000;;		initialOperationWaitTimeShort time.Duration = 20 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialOperationWaitTimeLong is the initial amount of time the test will
0000000000000000000000000000000000000000;;		// wait for an operation to complete (each successive failure results in
0000000000000000000000000000000000000000;;		// exponential backoff).
0000000000000000000000000000000000000000;;		initialOperationWaitTimeLong time.Duration = 500 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_SingleOp(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation := func() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := grm.Run(volumeName, "" /* operationSubName */, operation)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_TwoOps(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volume1Name := v1.UniqueVolumeName("volume1-name")
0000000000000000000000000000000000000000;;		volume2Name := v1.UniqueVolumeName("volume2-name")
0000000000000000000000000000000000000000;;		operation := func() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err1 := grm.Run(volume1Name, "" /* operationSubName */, operation)
0000000000000000000000000000000000000000;;		err2 := grm.Run(volume2Name, "" /* operationSubName */, operation)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine %q failed. Expected: <no error> Actual: <%v>", volume1Name, err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine %q failed. Expected: <no error> Actual: <%v>", volume2Name, err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_TwoSubOps(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1PodName := types.UniquePodName("operation1-podname")
0000000000000000000000000000000000000000;;		operation2PodName := types.UniquePodName("operation2-podname")
0000000000000000000000000000000000000000;;		operation := func() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, operation1PodName, operation)
0000000000000000000000000000000000000000;;		err2 := grm.Run(volumeName, operation2PodName, operation)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine %q failed. Expected: <no error> Actual: <%v>", operation1PodName, err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine %q failed. Expected: <no error> Actual: <%v>", operation2PodName, err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_SingleOpWithExpBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(true /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation := func() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err := grm.Run(volumeName, "" /* operationSubName */, operation)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_SecondOpAfterFirstCompletes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateCallbackFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;		<-operation1DoneCh // Force operation1 to complete
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(initialOperationWaitTimeShort),
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				err := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("Warning: NewGoRoutine failed with %v. Will retry.", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_SecondOpAfterFirstCompletesWithExpBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(true /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateCallbackFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;		<-operation1DoneCh // Force operation1 to complete
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(initialOperationWaitTimeShort),
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				err := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("Warning: NewGoRoutine failed with %v. Will retry.", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_SecondOpAfterFirstPanics(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1 := generatePanicFunc()
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(initialOperationWaitTimeShort),
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				err := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("Warning: NewGoRoutine failed with %v. Will retry.", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_SecondOpAfterFirstPanicsWithExpBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(true /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1 := generatePanicFunc()
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(initialOperationWaitTimeLong), // Longer duration to accommodate for backoff
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				err := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("Warning: NewGoRoutine failed with %v. Will retry.", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Negative_SecondOpBeforeFirstCompletes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not fail. Expected: <Failed to create operation with name \"%s\". An operation with that name already exists.> Actual: <no error>", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAlreadyExists(err2) {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not return alreadyExistsError, got: %v", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Negative_SecondSubOpBeforeFirstCompletes2(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operationPodName := types.UniquePodName("operation-podname")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, operationPodName, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := grm.Run(volumeName, operationPodName, operation2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not fail. Expected: <Failed to create operation with name \"%s\". An operation with that name already exists.> Actual: <no error>", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAlreadyExists(err2) {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not return alreadyExistsError, got: %v", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Negative_SecondSubOpBeforeFirstCompletes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operationPodName := types.UniquePodName("operation-podname")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, operationPodName, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := grm.Run(volumeName, operationPodName, operation2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not fail. Expected: <Failed to create operation with name \"%s\". An operation with that name already exists.> Actual: <no error>", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAlreadyExists(err2) {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not return alreadyExistsError, got: %v", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Negative_SecondOpBeforeFirstCompletesWithExpBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(true /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not fail. Expected: <Failed to create operation with name \"%s\". An operation with that name already exists.> Actual: <no error>", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAlreadyExists(err2) {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not return alreadyExistsError, got: %v", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_ThirdOpAfterFirstCompletes(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;		operation3 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not fail. Expected: <Failed to create operation with name \"%s\". An operation with that name already exists.> Actual: <no error>", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAlreadyExists(err2) {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not return alreadyExistsError, got: %v", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		operation1DoneCh <- true // Force operation1 to complete
0000000000000000000000000000000000000000;;		err3 := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(initialOperationWaitTimeShort),
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				err := grm.Run(volumeName, "" /* operationSubName */, operation3)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("Warning: NewGoRoutine failed with %v. Will retry.", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err3 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_ThirdOpAfterFirstCompletesWithExpBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(true /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err1 := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operation2 := generateNoopFunc()
0000000000000000000000000000000000000000;;		operation3 := generateNoopFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		err2 := grm.Run(volumeName, "" /* operationSubName */, operation2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err2 == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not fail. Expected: <Failed to create operation with name \"%s\". An operation with that name already exists.> Actual: <no error>", volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsAlreadyExists(err2) {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine did not return alreadyExistsError, got: %v", err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		operation1DoneCh <- true // Force operation1 to complete
0000000000000000000000000000000000000000;;		err3 := retryWithExponentialBackOff(
0000000000000000000000000000000000000000;;			time.Duration(initialOperationWaitTimeShort),
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				err := grm.Run(volumeName, "" /* operationSubName */, operation3)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Logf("Warning: NewGoRoutine failed with %v. Will retry.", err)
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if err3 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_WaitEmpty(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test than Wait() on empty GoRoutineMap always succeeds without blocking
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		waitDoneCh := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			grm.Wait()
0000000000000000000000000000000000000000;;			waitDoneCh <- true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		err := waitChannelWithTimeout(waitDoneCh, testTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error waiting for GoRoutineMap.Wait: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_WaitEmptyWithExpBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test than Wait() on empty GoRoutineMap always succeeds without blocking
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(true /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		waitDoneCh := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			grm.Wait()
0000000000000000000000000000000000000000;;			waitDoneCh <- true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		err := waitChannelWithTimeout(waitDoneCh, testTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error waiting for GoRoutineMap.Wait: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_Wait(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test that Wait() really blocks until the last operation succeeds
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(false /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		waitDoneCh := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			grm.Wait()
0000000000000000000000000000000000000000;;			waitDoneCh <- true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finish the operation
0000000000000000000000000000000000000000;;		operation1DoneCh <- true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		err = waitChannelWithTimeout(waitDoneCh, testTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error waiting for GoRoutineMap.Wait: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Test_NewGoRoutineMap_Positive_WaitWithExpBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test that Wait() really blocks until the last operation succeeds
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		grm := NewNestedPendingOperations(true /* exponentialBackOffOnError */)
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName("volume-name")
0000000000000000000000000000000000000000;;		operation1DoneCh := make(chan interface{}, 0 /* bufferSize */)
0000000000000000000000000000000000000000;;		operation1 := generateWaitFunc(operation1DoneCh)
0000000000000000000000000000000000000000;;		err := grm.Run(volumeName, "" /* operationSubName */, operation1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("NewGoRoutine failed. Expected: <no error> Actual: <%v>", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		waitDoneCh := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			grm.Wait()
0000000000000000000000000000000000000000;;			waitDoneCh <- true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finish the operation
0000000000000000000000000000000000000000;;		operation1DoneCh <- true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		err = waitChannelWithTimeout(waitDoneCh, testTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error waiting for GoRoutineMap.Wait: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateCallbackFunc(done chan<- interface{}) func() error {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			done <- true
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateWaitFunc(done <-chan interface{}) func() error {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			<-done
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generatePanicFunc() func() error {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			panic("testing panic")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateNoopFunc() func() error {
0000000000000000000000000000000000000000;;		return func() error { return nil }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func retryWithExponentialBackOff(initialDuration time.Duration, fn wait.ConditionFunc) error {
0000000000000000000000000000000000000000;;		backoff := wait.Backoff{
0000000000000000000000000000000000000000;;			Duration: initialDuration,
0000000000000000000000000000000000000000;;			Factor:   3,
0000000000000000000000000000000000000000;;			Jitter:   0,
0000000000000000000000000000000000000000;;			Steps:    4,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wait.ExponentialBackoff(backoff, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitChannelWithTimeout(ch <-chan interface{}, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		timer := time.NewTimer(timeout)
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ch:
0000000000000000000000000000000000000000;;			// Success!
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-timer.C:
0000000000000000000000000000000000000000;;			return fmt.Errorf("timeout after %v", timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
