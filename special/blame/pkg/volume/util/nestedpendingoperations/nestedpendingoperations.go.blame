0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
286075669b66d5110f6cfa6ee795a8bdf44324fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package nestedpendingoperations is a modified implementation of
0000000000000000000000000000000000000000;;	pkg/util/goroutinemap. It implements a data structure for managing go routines
0000000000000000000000000000000000000000;;	by volume/pod name. It prevents the creation of new go routines if an existing
0000000000000000000000000000000000000000;;	go routine for the volume already exists. It also allows multiple operations to
0000000000000000000000000000000000000000;;	execute in parallel for the same volume as long as they are operating on
0000000000000000000000000000000000000000;;	different pods.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package nestedpendingoperations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		k8sRuntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/goroutinemap/exponentialbackoff"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// EmptyUniquePodName is a UniquePodName for empty string.
0000000000000000000000000000000000000000;;		EmptyUniquePodName types.UniquePodName = types.UniquePodName("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EmptyUniqueVolumeName is a UniqueVolumeName for empty string
0000000000000000000000000000000000000000;;		EmptyUniqueVolumeName v1.UniqueVolumeName = v1.UniqueVolumeName("")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NestedPendingOperations defines the supported set of operations.
0000000000000000000000000000000000000000;;	type NestedPendingOperations interface {
0000000000000000000000000000000000000000;;		// Run adds the concatenation of volumeName and podName to the list of
0000000000000000000000000000000000000000;;		// running operations and spawns a new go routine to execute operationFunc.
0000000000000000000000000000000000000000;;		// If an operation with the same volumeName and same or empty podName
0000000000000000000000000000000000000000;;		// exists, an AlreadyExists or ExponentialBackoff error is returned.
0000000000000000000000000000000000000000;;		// This enables multiple operations to execute in parallel for the same
0000000000000000000000000000000000000000;;		// volumeName as long as they have different podName.
0000000000000000000000000000000000000000;;		// Once the operation is complete, the go routine is terminated and the
0000000000000000000000000000000000000000;;		// concatenation of volumeName and podName is removed from the list of
0000000000000000000000000000000000000000;;		// executing operations allowing a new operation to be started with the
0000000000000000000000000000000000000000;;		// volumeName without error.
0000000000000000000000000000000000000000;;		Run(volumeName v1.UniqueVolumeName, podName types.UniquePodName, operationFunc func() error) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait blocks until all operations are completed. This is typically
0000000000000000000000000000000000000000;;		// necessary during tests - the test should wait until all operations finish
0000000000000000000000000000000000000000;;		// and evaluate results after that.
0000000000000000000000000000000000000000;;		Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsOperationPending returns true if an operation for the given volumeName and podName is pending,
0000000000000000000000000000000000000000;;		// otherwise it returns false
0000000000000000000000000000000000000000;;		IsOperationPending(volumeName v1.UniqueVolumeName, podName types.UniquePodName) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNestedPendingOperations returns a new instance of NestedPendingOperations.
0000000000000000000000000000000000000000;;	func NewNestedPendingOperations(exponentialBackOffOnError bool) NestedPendingOperations {
0000000000000000000000000000000000000000;;		g := &nestedPendingOperations{
0000000000000000000000000000000000000000;;			operations:                []operation{},
0000000000000000000000000000000000000000;;			exponentialBackOffOnError: exponentialBackOffOnError,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.cond = sync.NewCond(&g.lock)
0000000000000000000000000000000000000000;;		return g
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nestedPendingOperations struct {
0000000000000000000000000000000000000000;;		operations                []operation
0000000000000000000000000000000000000000;;		exponentialBackOffOnError bool
0000000000000000000000000000000000000000;;		cond                      *sync.Cond
0000000000000000000000000000000000000000;;		lock                      sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type operation struct {
0000000000000000000000000000000000000000;;		volumeName       v1.UniqueVolumeName
0000000000000000000000000000000000000000;;		podName          types.UniquePodName
0000000000000000000000000000000000000000;;		operationPending bool
0000000000000000000000000000000000000000;;		expBackoff       exponentialbackoff.ExponentialBackoff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *nestedPendingOperations) Run(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		podName types.UniquePodName,
0000000000000000000000000000000000000000;;		operationFunc func() error) error {
0000000000000000000000000000000000000000;;		grm.lock.Lock()
0000000000000000000000000000000000000000;;		defer grm.lock.Unlock()
0000000000000000000000000000000000000000;;		opExists, previousOpIndex := grm.isOperationExists(volumeName, podName)
0000000000000000000000000000000000000000;;		if opExists {
0000000000000000000000000000000000000000;;			previousOp := grm.operations[previousOpIndex]
0000000000000000000000000000000000000000;;			// Operation already exists
0000000000000000000000000000000000000000;;			if previousOp.operationPending {
0000000000000000000000000000000000000000;;				// Operation is pending
0000000000000000000000000000000000000000;;				operationName := getOperationName(volumeName, podName)
0000000000000000000000000000000000000000;;				return NewAlreadyExistsError(operationName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			operationName := getOperationName(volumeName, podName)
0000000000000000000000000000000000000000;;			if err := previousOp.expBackoff.SafeToRetry(operationName); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update existing operation to mark as pending.
0000000000000000000000000000000000000000;;			grm.operations[previousOpIndex].operationPending = true
0000000000000000000000000000000000000000;;			grm.operations[previousOpIndex].volumeName = volumeName
0000000000000000000000000000000000000000;;			grm.operations[previousOpIndex].podName = podName
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Create a new operation
0000000000000000000000000000000000000000;;			grm.operations = append(grm.operations,
0000000000000000000000000000000000000000;;				operation{
0000000000000000000000000000000000000000;;					operationPending: true,
0000000000000000000000000000000000000000;;					volumeName:       volumeName,
0000000000000000000000000000000000000000;;					podName:          podName,
0000000000000000000000000000000000000000;;					expBackoff:       exponentialbackoff.ExponentialBackoff{},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() (err error) {
0000000000000000000000000000000000000000;;			// Handle unhandled panics (very unlikely)
0000000000000000000000000000000000000000;;			defer k8sRuntime.HandleCrash()
0000000000000000000000000000000000000000;;			// Handle completion of and error, if any, from operationFunc()
0000000000000000000000000000000000000000;;			defer grm.operationComplete(volumeName, podName, &err)
0000000000000000000000000000000000000000;;			// Handle panic, if any, from operationFunc()
0000000000000000000000000000000000000000;;			defer k8sRuntime.RecoverFromPanic(&err)
0000000000000000000000000000000000000000;;			return operationFunc()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *nestedPendingOperations) IsOperationPending(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		podName types.UniquePodName) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grm.lock.RLock()
0000000000000000000000000000000000000000;;		defer grm.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exist, previousOpIndex := grm.isOperationExists(volumeName, podName)
0000000000000000000000000000000000000000;;		if exist && grm.operations[previousOpIndex].operationPending {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is an internal function and caller should acquire and release the lock
0000000000000000000000000000000000000000;;	func (grm *nestedPendingOperations) isOperationExists(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		podName types.UniquePodName) (bool, int) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If volumeName is empty, operation can be executed concurrently
0000000000000000000000000000000000000000;;		if volumeName == EmptyUniqueVolumeName {
0000000000000000000000000000000000000000;;			return false, -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for previousOpIndex, previousOp := range grm.operations {
0000000000000000000000000000000000000000;;			if previousOp.volumeName != volumeName {
0000000000000000000000000000000000000000;;				// No match, keep searching
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if previousOp.podName != EmptyUniquePodName &&
0000000000000000000000000000000000000000;;				podName != EmptyUniquePodName &&
0000000000000000000000000000000000000000;;				previousOp.podName != podName {
0000000000000000000000000000000000000000;;				// No match, keep searching
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Match
0000000000000000000000000000000000000000;;			return true, previousOpIndex
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *nestedPendingOperations) getOperation(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		podName types.UniquePodName) (uint, error) {
0000000000000000000000000000000000000000;;		// Assumes lock has been acquired by caller.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, op := range grm.operations {
0000000000000000000000000000000000000000;;			if op.volumeName == volumeName &&
0000000000000000000000000000000000000000;;				op.podName == podName {
0000000000000000000000000000000000000000;;				return uint(i), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logOperationName := getOperationName(volumeName, podName)
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("Operation %q not found", logOperationName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *nestedPendingOperations) deleteOperation(
0000000000000000000000000000000000000000;;		// Assumes lock has been acquired by caller.
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		podName types.UniquePodName) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opIndex := -1
0000000000000000000000000000000000000000;;		for i, op := range grm.operations {
0000000000000000000000000000000000000000;;			if op.volumeName == volumeName &&
0000000000000000000000000000000000000000;;				op.podName == podName {
0000000000000000000000000000000000000000;;				opIndex = i
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete index without preserving order
0000000000000000000000000000000000000000;;		grm.operations[opIndex] = grm.operations[len(grm.operations)-1]
0000000000000000000000000000000000000000;;		grm.operations = grm.operations[:len(grm.operations)-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *nestedPendingOperations) operationComplete(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, podName types.UniquePodName, err *error) {
0000000000000000000000000000000000000000;;		// Defer operations are executed in Last-In is First-Out order. In this case
0000000000000000000000000000000000000000;;		// the lock is acquired first when operationCompletes begins, and is
0000000000000000000000000000000000000000;;		// released when the method finishes, after the lock is released cond is
0000000000000000000000000000000000000000;;		// signaled to wake waiting goroutine.
0000000000000000000000000000000000000000;;		defer grm.cond.Signal()
0000000000000000000000000000000000000000;;		grm.lock.Lock()
0000000000000000000000000000000000000000;;		defer grm.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *err == nil || !grm.exponentialBackOffOnError {
0000000000000000000000000000000000000000;;			// Operation completed without error, or exponentialBackOffOnError disabled
0000000000000000000000000000000000000000;;			grm.deleteOperation(volumeName, podName)
0000000000000000000000000000000000000000;;			if *err != nil {
0000000000000000000000000000000000000000;;				// Log error
0000000000000000000000000000000000000000;;				logOperationName := getOperationName(volumeName, podName)
0000000000000000000000000000000000000000;;				glog.Errorf("operation %s failed with: %v",
0000000000000000000000000000000000000000;;					logOperationName,
0000000000000000000000000000000000000000;;					*err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Operation completed with error and exponentialBackOffOnError Enabled
0000000000000000000000000000000000000000;;		existingOpIndex, getOpErr := grm.getOperation(volumeName, podName)
0000000000000000000000000000000000000000;;		if getOpErr != nil {
0000000000000000000000000000000000000000;;			// Failed to find existing operation
0000000000000000000000000000000000000000;;			logOperationName := getOperationName(volumeName, podName)
0000000000000000000000000000000000000000;;			glog.Errorf("Operation %s completed. error: %v. exponentialBackOffOnError is enabled, but failed to get operation to update.",
0000000000000000000000000000000000000000;;				logOperationName,
0000000000000000000000000000000000000000;;				*err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grm.operations[existingOpIndex].expBackoff.Update(err)
0000000000000000000000000000000000000000;;		grm.operations[existingOpIndex].operationPending = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Log error
0000000000000000000000000000000000000000;;		operationName :=
0000000000000000000000000000000000000000;;			getOperationName(volumeName, podName)
0000000000000000000000000000000000000000;;		glog.Errorf("%v", grm.operations[existingOpIndex].expBackoff.
0000000000000000000000000000000000000000;;			GenerateNoRetriesPermittedMsg(operationName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (grm *nestedPendingOperations) Wait() {
0000000000000000000000000000000000000000;;		grm.lock.Lock()
0000000000000000000000000000000000000000;;		defer grm.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(grm.operations) > 0 {
0000000000000000000000000000000000000000;;			grm.cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOperationName(
0000000000000000000000000000000000000000;;		volumeName v1.UniqueVolumeName, podName types.UniquePodName) string {
0000000000000000000000000000000000000000;;		podNameStr := ""
0000000000000000000000000000000000000000;;		if podName != EmptyUniquePodName {
0000000000000000000000000000000000000000;;			podNameStr = fmt.Sprintf(" (%q)", podName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%q%s",
0000000000000000000000000000000000000000;;			volumeName,
0000000000000000000000000000000000000000;;			podNameStr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAlreadyExistsError returns a new instance of AlreadyExists error.
0000000000000000000000000000000000000000;;	func NewAlreadyExistsError(operationName string) error {
0000000000000000000000000000000000000000;;		return alreadyExistsError{operationName}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAlreadyExists returns true if an error returned from
0000000000000000000000000000000000000000;;	// NestedPendingOperations indicates a new operation can not be started because
0000000000000000000000000000000000000000;;	// an operation with the same operation name is already executing.
0000000000000000000000000000000000000000;;	func IsAlreadyExists(err error) bool {
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case alreadyExistsError:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alreadyExistsError is the error returned by NestedPendingOperations when a
0000000000000000000000000000000000000000;;	// new operation can not be started because an operation with the same operation
0000000000000000000000000000000000000000;;	// name is already executing.
0000000000000000000000000000000000000000;;	type alreadyExistsError struct {
0000000000000000000000000000000000000000;;		operationName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ error = alreadyExistsError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err alreadyExistsError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"Failed to create operation with name %q. An operation with that name is already executing.",
0000000000000000000000000000000000000000;;			err.operationName)
0000000000000000000000000000000000000000;;	}
