0000000000000000000000000000000000000000;;	// +build linux
cfb21af4342b243358f84229906f09973994aa23;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockOsIOHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *mockOsIOHandler) ReadDir(dirname string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		switch dirname {
0000000000000000000000000000000000000000;;		case "/sys/block/dm-2/slaves/":
0000000000000000000000000000000000000000;;			f := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "sda",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []os.FileInfo{f}, nil
0000000000000000000000000000000000000000;;		case "/sys/block/":
0000000000000000000000000000000000000000;;			f1 := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "sda",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f2 := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "dm-1",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []os.FileInfo{f1, f2}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *mockOsIOHandler) Lstat(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		links := map[string]string{
0000000000000000000000000000000000000000;;			"/sys/block/dm-1/slaves/sda": "sda",
0000000000000000000000000000000000000000;;			"/dev/sda":                   "sda",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dev, ok := links[name]; ok {
0000000000000000000000000000000000000000;;			return &fakeFileInfo{name: dev}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.New("Not Implemented for Mock")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *mockOsIOHandler) EvalSymlinks(path string) (string, error) {
0000000000000000000000000000000000000000;;		links := map[string]string{
0000000000000000000000000000000000000000;;			"/returns/a/dev":                                              "/dev/sde",
0000000000000000000000000000000000000000;;			"/returns/non/dev":                                            "/sys/block",
0000000000000000000000000000000000000000;;			"/dev/disk/by-path/127.0.0.1:3260-eui.02004567A425678D-lun-0": "/dev/sda",
0000000000000000000000000000000000000000;;			"/dev/dm-2": "/dev/dm-2",
0000000000000000000000000000000000000000;;			"/dev/dm-3": "/dev/dm-3",
0000000000000000000000000000000000000000;;			"/dev/sde":  "/dev/sde",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return links[path], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *mockOsIOHandler) WriteFile(filename string, data []byte, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return errors.New("Not Implemented for Mock")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeFileInfo struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Name() string {
0000000000000000000000000000000000000000;;		return fi.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Size() int64 {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Mode() os.FileMode {
0000000000000000000000000000000000000000;;		return 777
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) ModTime() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) IsDir() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Sys() interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindMultipathDeviceForDevice(t *testing.T) {
0000000000000000000000000000000000000000;;		mockDeviceUtil := NewDeviceHandler(&mockOsIOHandler{})
0000000000000000000000000000000000000000;;		dev := mockDeviceUtil.FindMultipathDeviceForDevice("/dev/disk/by-path/127.0.0.1:3260-eui.02004567A425678D-lun-0")
0000000000000000000000000000000000000000;;		if dev != "/dev/dm-1" {
0000000000000000000000000000000000000000;;			t.Fatalf("mpio device not found dm-1 expected got [%s]", dev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dev = mockDeviceUtil.FindMultipathDeviceForDevice("/dev/disk/by-path/empty")
0000000000000000000000000000000000000000;;		if dev != "" {
0000000000000000000000000000000000000000;;			t.Fatalf("mpio device not found '' expected got [%s]", dev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFindDeviceForPath(t *testing.T) {
0000000000000000000000000000000000000000;;		io := &mockOsIOHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		disk, err := findDeviceForPath("/dev/sde", io)
0000000000000000000000000000000000000000;;		if disk != "sde" {
0000000000000000000000000000000000000000;;			t.Fatalf("disk [%s] didn't match expected sde", disk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disk, err = findDeviceForPath("/returns/a/dev", io)
0000000000000000000000000000000000000000;;		if disk != "sde" {
0000000000000000000000000000000000000000;;			t.Fatalf("disk [%s] didn't match expected sde", disk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = findDeviceForPath("/returns/non/dev", io)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("link is to incorrect dev")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = findDeviceForPath("/path/doesnt/exist", &osIOHandler{})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("path shouldn't exist but still doesn't give an error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
