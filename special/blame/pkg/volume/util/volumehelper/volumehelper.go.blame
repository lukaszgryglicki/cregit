0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
dfbf90bed07e50064054cd2545394e42b22b7c00;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package volumehelper contains consts and helper methods used by various
0000000000000000000000000000000000000000;;	// volume components (attach/detach controller, kubelet, etc.).
0000000000000000000000000000000000000000;;	package volumehelper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ControllerManagedAttachAnnotation is the key of the annotation on Node
0000000000000000000000000000000000000000;;		// objects that indicates attach/detach operations for the node should be
0000000000000000000000000000000000000000;;		// managed by the attach/detach controller
0000000000000000000000000000000000000000;;		ControllerManagedAttachAnnotation string = "volumes.kubernetes.io/controller-managed-attach-detach"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeepTerminatedPodVolumesAnnotation is the key of the annotation on Node
0000000000000000000000000000000000000000;;		// that decides if pod volumes are unmounted when pod is terminated
0000000000000000000000000000000000000000;;		KeepTerminatedPodVolumesAnnotation string = "volumes.kubernetes.io/keep-terminated-pod-volumes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeGidAnnotationKey is the of the annotation on the PersistentVolume
0000000000000000000000000000000000000000;;		// object that specifies a supplemental GID.
0000000000000000000000000000000000000000;;		VolumeGidAnnotationKey = "pv.beta.kubernetes.io/gid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeDynamicallyCreatedByKey is the key of the annotation on PersistentVolume
0000000000000000000000000000000000000000;;		// object created dynamically
0000000000000000000000000000000000000000;;		VolumeDynamicallyCreatedByKey = "kubernetes.io/createdby"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUniquePodName returns a unique identifier to reference a pod by
0000000000000000000000000000000000000000;;	func GetUniquePodName(pod *v1.Pod) types.UniquePodName {
0000000000000000000000000000000000000000;;		return types.UniquePodName(pod.UID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUniqueVolumeName returns a unique name representing the volume/plugin.
0000000000000000000000000000000000000000;;	// Caller should ensure that volumeName is a name/ID uniquely identifying the
0000000000000000000000000000000000000000;;	// actual backing device, directory, path, etc. for a particular volume.
0000000000000000000000000000000000000000;;	// The returned name can be used to uniquely reference the volume, for example,
0000000000000000000000000000000000000000;;	// to prevent operations (attach/detach or mount/unmount) from being triggered
0000000000000000000000000000000000000000;;	// on the same volume.
0000000000000000000000000000000000000000;;	func GetUniqueVolumeName(pluginName, volumeName string) v1.UniqueVolumeName {
0000000000000000000000000000000000000000;;		return v1.UniqueVolumeName(fmt.Sprintf("%s/%s", pluginName, volumeName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUniqueVolumeNameForNonAttachableVolume returns the unique volume name
0000000000000000000000000000000000000000;;	// for a non-attachable volume.
0000000000000000000000000000000000000000;;	func GetUniqueVolumeNameForNonAttachableVolume(
0000000000000000000000000000000000000000;;		podName types.UniquePodName, volumePlugin volume.VolumePlugin, volumeSpec *volume.Spec) v1.UniqueVolumeName {
0000000000000000000000000000000000000000;;		return v1.UniqueVolumeName(
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s/%v-%s", volumePlugin.GetPluginName(), podName, volumeSpec.Name()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUniqueVolumeNameFromSpec uses the given VolumePlugin to generate a unique
0000000000000000000000000000000000000000;;	// name representing the volume defined in the specified volume spec.
0000000000000000000000000000000000000000;;	// This returned name can be used to uniquely reference the actual backing
0000000000000000000000000000000000000000;;	// device, directory, path, etc. referenced by the given volumeSpec.
0000000000000000000000000000000000000000;;	// If the given plugin does not support the volume spec, this returns an error.
0000000000000000000000000000000000000000;;	func GetUniqueVolumeNameFromSpec(
0000000000000000000000000000000000000000;;		volumePlugin volume.VolumePlugin,
0000000000000000000000000000000000000000;;		volumeSpec *volume.Spec) (v1.UniqueVolumeName, error) {
0000000000000000000000000000000000000000;;		if volumePlugin == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"volumePlugin should not be nil. volumeSpec.Name=%q",
0000000000000000000000000000000000000000;;				volumeSpec.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeName, err := volumePlugin.GetVolumeName(volumeSpec)
0000000000000000000000000000000000000000;;		if err != nil || volumeName == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(
0000000000000000000000000000000000000000;;				"failed to GetVolumeName from volumePlugin for volumeSpec %q err=%v",
0000000000000000000000000000000000000000;;				volumeSpec.Name(),
0000000000000000000000000000000000000000;;				err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return GetUniqueVolumeName(
0000000000000000000000000000000000000000;;				volumePlugin.GetPluginName(),
0000000000000000000000000000000000000000;;				volumeName),
0000000000000000000000000000000000000000;;			nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPodTerminated checks if pod is terminated
0000000000000000000000000000000000000000;;	func IsPodTerminated(pod *v1.Pod, podStatus v1.PodStatus) bool {
0000000000000000000000000000000000000000;;		return podStatus.Phase == v1.PodFailed || podStatus.Phase == v1.PodSucceeded || (pod.DeletionTimestamp != nil && notRunning(podStatus.ContainerStatuses))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notRunning returns true if every status is terminated or waiting, or the status list
0000000000000000000000000000000000000000;;	// is empty.
0000000000000000000000000000000000000000;;	func notRunning(statuses []v1.ContainerStatus) bool {
0000000000000000000000000000000000000000;;		for _, status := range statuses {
0000000000000000000000000000000000000000;;			if status.State.Terminated == nil && status.State.Waiting == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitUniqueName splits the unique name to plugin name and volume name strings. It expects the uniqueName to follow
0000000000000000000000000000000000000000;;	// the fromat plugin_name/volume_name and the plugin name must be namespaced as descibed by the plugin interface,
0000000000000000000000000000000000000000;;	// i.e. namespace/plugin containing exactly one '/'. This means the unique name will always be in the form of
0000000000000000000000000000000000000000;;	// plugin_namespace/plugin/volume_name, see k8s.io/kubernetes/pkg/volume/plugins.go VolumePlugin interface
0000000000000000000000000000000000000000;;	// description and pkg/volume/util/volumehelper/volumehelper.go GetUniqueVolumeNameFromSpec that constructs
0000000000000000000000000000000000000000;;	// the unique volume names.
0000000000000000000000000000000000000000;;	func SplitUniqueName(uniqueName v1.UniqueVolumeName) (string, string, error) {
0000000000000000000000000000000000000000;;		components := strings.SplitN(string(uniqueName), "/", 3)
0000000000000000000000000000000000000000;;		if len(components) != 3 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("cannot split volume unique name %s to plugin/volume components", uniqueName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pluginName := fmt.Sprintf("%s/%s", components[0], components[1])
0000000000000000000000000000000000000000;;		return pluginName, components[2], nil
0000000000000000000000000000000000000000;;	}
