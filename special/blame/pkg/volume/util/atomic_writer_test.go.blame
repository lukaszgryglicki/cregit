0000000000000000000000000000000000000000;;	// +build linux
c10aef7c9acdf312ef2acff60af961f833d59c82;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewAtomicWriter(t *testing.T) {
0000000000000000000000000000000000000000;;		targetDir, err := utiltesting.MkTmpdir("atomic-write")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error creating tmp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(targetDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = NewAtomicWriter(targetDir, "-test-")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error creating writer for existing target dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nonExistentDir, err := utiltesting.MkTmpdir("atomic-write")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error creating tmp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = os.Remove(nonExistentDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error ensuring dir %v does not exist: %v", nonExistentDir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = NewAtomicWriter(nonExistentDir, "-test-")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected success creating writer for nonexistent target dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidatePath(t *testing.T) {
0000000000000000000000000000000000000000;;		maxPath := strings.Repeat("a", maxPathLength+1)
0000000000000000000000000000000000000000;;		maxFile := strings.Repeat("a", maxFileNameLength+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name  string
0000000000000000000000000000000000000000;;			path  string
0000000000000000000000000000000000000000;;			valid bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "valid 1",
0000000000000000000000000000000000000000;;				path:  "i/am/well/behaved.txt",
0000000000000000000000000000000000000000;;				valid: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "valid 2",
0000000000000000000000000000000000000000;;				path:  "keepyourheaddownandfollowtherules.txt",
0000000000000000000000000000000000000000;;				valid: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "max path length",
0000000000000000000000000000000000000000;;				path:  maxPath,
0000000000000000000000000000000000000000;;				valid: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "max file length",
0000000000000000000000000000000000000000;;				path:  maxFile,
0000000000000000000000000000000000000000;;				valid: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "absolute failure",
0000000000000000000000000000000000000000;;				path:  "/dev/null",
0000000000000000000000000000000000000000;;				valid: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "reserved path",
0000000000000000000000000000000000000000;;				path:  "..sneaky.txt",
0000000000000000000000000000000000000000;;				valid: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "contains doubledot 1",
0000000000000000000000000000000000000000;;				path:  "hello/there/../../../../../../etc/passwd",
0000000000000000000000000000000000000000;;				valid: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "contains doubledot 2",
0000000000000000000000000000000000000000;;				path:  "hello/../etc/somethingbad",
0000000000000000000000000000000000000000;;				valid: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "empty",
0000000000000000000000000000000000000000;;				path:  "",
0000000000000000000000000000000000000000;;				valid: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			err := validatePath(tc.path)
0000000000000000000000000000000000000000;;			if tc.valid && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected failure: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !tc.valid && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected success", tc.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPathsToRemove(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			payload1 map[string]FileProjection
0000000000000000000000000000000000000000;;			payload2 map[string]FileProjection
0000000000000000000000000000000000000000;;			expected sets.String
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "simple",
0000000000000000000000000000000000000000;;				payload1: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				payload2: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: sets.NewString("bar.txt"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "simple 2",
0000000000000000000000000000000000000000;;				payload1: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":     {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zip/bar.txt": {Mode: 0644, Data: []byte("zip/b}ar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				payload2: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: sets.NewString("zip/bar.txt", "zip"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirs 1",
0000000000000000000000000000000000000000;;				payload1: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":         {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zip/zap/bar.txt": {Mode: 0644, Data: []byte("zip/bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				payload2: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: sets.NewString("zip/zap/bar.txt", "zip", "zip/zap"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirs 2",
0000000000000000000000000000000000000000;;				payload1: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":             {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zip/1/2/3/4/bar.txt": {Mode: 0644, Data: []byte("zip/b}ar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				payload2: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: sets.NewString("zip/1/2/3/4/bar.txt", "zip", "zip/1", "zip/1/2", "zip/1/2/3", "zip/1/2/3/4"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirs 3",
0000000000000000000000000000000000000000;;				payload1: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":             {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zip/1/2/3/4/bar.txt": {Mode: 0644, Data: []byte("zip/b}ar")},
0000000000000000000000000000000000000000;;					"zap/a/b/c/bar.txt":   {Mode: 0644, Data: []byte("zap/bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				payload2: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: sets.NewString("zip/1/2/3/4/bar.txt", "zip", "zip/1", "zip/1/2", "zip/1/2/3", "zip/1/2/3/4", "zap", "zap/a", "zap/a/b", "zap/a/b/c", "zap/a/b/c/bar.txt"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirs 4",
0000000000000000000000000000000000000000;;				payload1: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":             {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zap/1/2/3/4/bar.txt": {Mode: 0644, Data: []byte("zip/bar")},
0000000000000000000000000000000000000000;;					"zap/1/2/c/bar.txt":   {Mode: 0644, Data: []byte("zap/bar")},
0000000000000000000000000000000000000000;;					"zap/1/2/magic.txt":   {Mode: 0644, Data: []byte("indigo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				payload2: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":           {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zap/1/2/magic.txt": {Mode: 0644, Data: []byte("indigo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: sets.NewString("zap/1/2/3/4/bar.txt", "zap/1/2/3", "zap/1/2/3/4", "zap/1/2/3/4/bar.txt", "zap/1/2/c", "zap/1/2/c/bar.txt"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirs 5",
0000000000000000000000000000000000000000;;				payload1: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":             {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zap/1/2/3/4/bar.txt": {Mode: 0644, Data: []byte("zip/bar")},
0000000000000000000000000000000000000000;;					"zap/1/2/c/bar.txt":   {Mode: 0644, Data: []byte("zap/bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				payload2: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.txt":           {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"zap/1/2/magic.txt": {Mode: 0644, Data: []byte("indigo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: sets.NewString("zap/1/2/3/4/bar.txt", "zap/1/2/3", "zap/1/2/3/4", "zap/1/2/3/4/bar.txt", "zap/1/2/c", "zap/1/2/c/bar.txt"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			targetDir, err := utiltesting.MkTmpdir("atomic-write")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error creating tmp dir: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.RemoveAll(targetDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writer := &AtomicWriter{targetDir: targetDir, logContext: "-test-"}
0000000000000000000000000000000000000000;;			err = writer.Write(tc.payload1)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error writing: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actual, err := writer.pathsToRemove(tc.payload2)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error determining paths to remove: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e, a := tc.expected, actual; !e.Equal(a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected paths to remove:\nexpected: %v\n     got: %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteOnce(t *testing.T) {
0000000000000000000000000000000000000000;;		// $1 if you can tell me what this binary is
0000000000000000000000000000000000000000;;		encodedMysteryBinary := `f0VMRgIBAQAAAAAAAAAAAAIAPgABAAAAeABAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAOAAB
0000000000000000000000000000000000000000;;	AAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAfQAAAAAAAAB9AAAAAAAAAAAA
0000000000000000000000000000000000000000;;	IAAAAAAAsDyZDwU=`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mysteryBinaryBytes := make([]byte, base64.StdEncoding.DecodedLen(len(encodedMysteryBinary)))
0000000000000000000000000000000000000000;;		numBytes, err := base64.StdEncoding.Decode(mysteryBinaryBytes, []byte(encodedMysteryBinary))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error decoding binary payload: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numBytes != 125 {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected decoded binary size: expected 125, got %v", numBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name    string
0000000000000000000000000000000000000000;;			payload map[string]FileProjection
0000000000000000000000000000000000000000;;			success bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "invalid payload 1",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo":        {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"..bar":      {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					"binary.bin": {Mode: 0644, Data: mysteryBinaryBytes},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "invalid payload 2",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/../bar": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "basic 1",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "basic 2",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"binary.bin":  {Mode: 0644, Data: mysteryBinaryBytes},
0000000000000000000000000000000000000000;;					".binary.bin": {Mode: 0644, Data: mysteryBinaryBytes},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "basic mode 1",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo": {Mode: 0777, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar": {Mode: 0400, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "dotfiles",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo":           {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar":           {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					".dotfile":      {Mode: 0644, Data: []byte("dotfile")},
0000000000000000000000000000000000000000;;					".dotfile.file": {Mode: 0644, Data: []byte("dotfile.file")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "dotfiles mode",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo":           {Mode: 0407, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar":           {Mode: 0440, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					".dotfile":      {Mode: 0777, Data: []byte("dotfile")},
0000000000000000000000000000000000000000;;					".dotfile.file": {Mode: 0666, Data: []byte("dotfile.file")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirectories 1",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirectories mode 1",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0400, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirectories 2",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo//bar.txt":      {Mode: 0644, Data: []byte("foo//bar")},
0000000000000000000000000000000000000000;;					"bar///bar/zab.txt": {Mode: 0644, Data: []byte("bar/../bar/zab.txt")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirectories 3",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":      {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;					"bar/zab.txt":      {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;					"foo/blaz/bar.txt": {Mode: 0644, Data: []byte("foo/blaz/bar")},
0000000000000000000000000000000000000000;;					"bar/zib/zab.txt":  {Mode: 0644, Data: []byte("bar/zib/zab.txt")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "kitchen sink",
0000000000000000000000000000000000000000;;				payload: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo.log":                           {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar.zap":                           {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					".dotfile":                          {Mode: 0644, Data: []byte("dotfile")},
0000000000000000000000000000000000000000;;					"foo/bar.txt":                       {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;					"bar/zab.txt":                       {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;					"foo/blaz/bar.txt":                  {Mode: 0644, Data: []byte("foo/blaz/bar")},
0000000000000000000000000000000000000000;;					"bar/zib/zab.txt":                   {Mode: 0400, Data: []byte("bar/zib/zab.txt")},
0000000000000000000000000000000000000000;;					"1/2/3/4/5/6/7/8/9/10/.dotfile.lib": {Mode: 0777, Data: []byte("1-2-3-dotfile")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				success: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			targetDir, err := utiltesting.MkTmpdir("atomic-write")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error creating tmp dir: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.RemoveAll(targetDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writer := &AtomicWriter{targetDir: targetDir, logContext: "-test-"}
0000000000000000000000000000000000000000;;			err = writer.Write(tc.payload)
0000000000000000000000000000000000000000;;			if err != nil && tc.success {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error writing payload: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err == nil && !tc.success {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected success", tc.name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			checkVolumeContents(targetDir, tc.name, tc.payload, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			first       map[string]FileProjection
0000000000000000000000000000000000000000;;			next        map[string]FileProjection
0000000000000000000000000000000000000000;;			shouldWrite bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "update",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo": {Mode: 0644, Data: []byte("foo2")},
0000000000000000000000000000000000000000;;					"bar": {Mode: 0640, Data: []byte("bar2")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "no update",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "no update 2",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "add 1",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					"blu/zip.txt": {Mode: 0644, Data: []byte("zip")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "add 2",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":             {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt":             {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					"blu/two/2/3/4/5/zip.txt": {Mode: 0644, Data: []byte("zip")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "add 3",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":         {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt":         {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					"bar/2/3/4/5/zip.txt": {Mode: 0644, Data: []byte("zip")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "delete 1",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "delete 2",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":       {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/1/2/3/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "delete 3",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":       {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/1/2/sip.txt":   {Mode: 0644, Data: []byte("sip")},
0000000000000000000000000000000000000000;;					"bar/1/2/3/zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":     {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/1/2/sip.txt": {Mode: 0644, Data: []byte("sip")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "delete 4",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":            {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/1/2/sip.txt":        {Mode: 0644, Data: []byte("sip")},
0000000000000000000000000000000000000000;;					"bar/1/2/3/4/5/6zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":     {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/1/2/sip.txt": {Mode: 0644, Data: []byte("sip")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "delete all",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt":            {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;					"bar/1/2/sip.txt":        {Mode: 0644, Data: []byte("sip")},
0000000000000000000000000000000000000000;;					"bar/1/2/3/4/5/6zab.txt": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next:        map[string]FileProjection{},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "add and delete 1",
0000000000000000000000000000000000000000;;				first: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"foo/bar.txt": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				next: map[string]FileProjection{
0000000000000000000000000000000000000000;;					"bar/baz.txt": {Mode: 0644, Data: []byte("baz")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				shouldWrite: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			targetDir, err := utiltesting.MkTmpdir("atomic-write")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error creating tmp dir: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.RemoveAll(targetDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writer := &AtomicWriter{targetDir: targetDir, logContext: "-test-"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = writer.Write(tc.first)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error writing: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			checkVolumeContents(targetDir, tc.name, tc.first, t)
0000000000000000000000000000000000000000;;			if !tc.shouldWrite {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = writer.Write(tc.next)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if tc.shouldWrite {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error writing: %v", tc.name, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if !tc.shouldWrite {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected success", tc.name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			checkVolumeContents(targetDir, tc.name, tc.next, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultipleUpdates(t *testing.T) {
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			payloads []map[string]FileProjection
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "update 1",
0000000000000000000000000000000000000000;;				payloads: []map[string]FileProjection{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;						"bar": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo": {Mode: 0400, Data: []byte("foo2")},
0000000000000000000000000000000000000000;;						"bar": {Mode: 0400, Data: []byte("bar2")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo": {Mode: 0600, Data: []byte("foo3")},
0000000000000000000000000000000000000000;;						"bar": {Mode: 0600, Data: []byte("bar3")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "update 2",
0000000000000000000000000000000000000000;;				payloads: []map[string]FileProjection{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt": {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;						"bar/zab.txt": {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt": {Mode: 0644, Data: []byte("foo/bar2")},
0000000000000000000000000000000000000000;;						"bar/zab.txt": {Mode: 0400, Data: []byte("bar/zab.txt2")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "clear sentinel",
0000000000000000000000000000000000000000;;				payloads: []map[string]FileProjection{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo": {Mode: 0644, Data: []byte("foo")},
0000000000000000000000000000000000000000;;						"bar": {Mode: 0644, Data: []byte("bar")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo": {Mode: 0644, Data: []byte("foo2")},
0000000000000000000000000000000000000000;;						"bar": {Mode: 0644, Data: []byte("bar2")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo": {Mode: 0644, Data: []byte("foo3")},
0000000000000000000000000000000000000000;;						"bar": {Mode: 0644, Data: []byte("bar3")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo": {Mode: 0644, Data: []byte("foo4")},
0000000000000000000000000000000000000000;;						"bar": {Mode: 0644, Data: []byte("bar4")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "subdirectories 2",
0000000000000000000000000000000000000000;;				payloads: []map[string]FileProjection{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt":      {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;						"bar/zab.txt":      {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;						"foo/blaz/bar.txt": {Mode: 0644, Data: []byte("foo/blaz/bar")},
0000000000000000000000000000000000000000;;						"bar/zib/zab.txt":  {Mode: 0644, Data: []byte("bar/zib/zab.txt")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt":      {Mode: 0644, Data: []byte("foo/bar2")},
0000000000000000000000000000000000000000;;						"bar/zab.txt":      {Mode: 0644, Data: []byte("bar/zab.txt2")},
0000000000000000000000000000000000000000;;						"foo/blaz/bar.txt": {Mode: 0644, Data: []byte("foo/blaz/bar2")},
0000000000000000000000000000000000000000;;						"bar/zib/zab.txt":  {Mode: 0644, Data: []byte("bar/zib/zab.txt2")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "add 1",
0000000000000000000000000000000000000000;;				payloads: []map[string]FileProjection{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt":            {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;						"bar//zab.txt":           {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;						"foo/blaz/bar.txt":       {Mode: 0644, Data: []byte("foo/blaz/bar")},
0000000000000000000000000000000000000000;;						"bar/zib////zib/zab.txt": {Mode: 0644, Data: []byte("bar/zib/zab.txt")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt":      {Mode: 0644, Data: []byte("foo/bar2")},
0000000000000000000000000000000000000000;;						"bar/zab.txt":      {Mode: 0644, Data: []byte("bar/zab.txt2")},
0000000000000000000000000000000000000000;;						"foo/blaz/bar.txt": {Mode: 0644, Data: []byte("foo/blaz/bar2")},
0000000000000000000000000000000000000000;;						"bar/zib/zab.txt":  {Mode: 0644, Data: []byte("bar/zib/zab.txt2")},
0000000000000000000000000000000000000000;;						"add/new/keys.txt": {Mode: 0644, Data: []byte("addNewKeys")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "add 2",
0000000000000000000000000000000000000000;;				payloads: []map[string]FileProjection{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt":      {Mode: 0644, Data: []byte("foo/bar2")},
0000000000000000000000000000000000000000;;						"bar/zab.txt":      {Mode: 0644, Data: []byte("bar/zab.txt2")},
0000000000000000000000000000000000000000;;						"foo/blaz/bar.txt": {Mode: 0644, Data: []byte("foo/blaz/bar2")},
0000000000000000000000000000000000000000;;						"bar/zib/zab.txt":  {Mode: 0644, Data: []byte("bar/zib/zab.txt2")},
0000000000000000000000000000000000000000;;						"add/new/keys.txt": {Mode: 0644, Data: []byte("addNewKeys")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt":       {Mode: 0644, Data: []byte("foo/bar2")},
0000000000000000000000000000000000000000;;						"bar/zab.txt":       {Mode: 0644, Data: []byte("bar/zab.txt2")},
0000000000000000000000000000000000000000;;						"foo/blaz/bar.txt":  {Mode: 0644, Data: []byte("foo/blaz/bar2")},
0000000000000000000000000000000000000000;;						"bar/zib/zab.txt":   {Mode: 0644, Data: []byte("bar/zib/zab.txt2")},
0000000000000000000000000000000000000000;;						"add/new/keys.txt":  {Mode: 0644, Data: []byte("addNewKeys")},
0000000000000000000000000000000000000000;;						"add/new/keys2.txt": {Mode: 0644, Data: []byte("addNewKeys2")},
0000000000000000000000000000000000000000;;						"add/new/keys3.txt": {Mode: 0644, Data: []byte("addNewKeys3")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "remove 1",
0000000000000000000000000000000000000000;;				payloads: []map[string]FileProjection{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt":         {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;						"bar//zab.txt":        {Mode: 0644, Data: []byte("bar/zab.txt")},
0000000000000000000000000000000000000000;;						"foo/blaz/bar.txt":    {Mode: 0644, Data: []byte("foo/blaz/bar")},
0000000000000000000000000000000000000000;;						"zip/zap/zup/fop.txt": {Mode: 0644, Data: []byte("zip/zap/zup/fop.txt")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt": {Mode: 0644, Data: []byte("foo/bar2")},
0000000000000000000000000000000000000000;;						"bar/zab.txt": {Mode: 0644, Data: []byte("bar/zab.txt2")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						"foo/bar.txt": {Mode: 0644, Data: []byte("foo/bar")},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range cases {
0000000000000000000000000000000000000000;;			targetDir, err := utiltesting.MkTmpdir("atomic-write")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error creating tmp dir: %v", tc.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer os.RemoveAll(targetDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writer := &AtomicWriter{targetDir: targetDir, logContext: "-test-"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, payload := range tc.payloads {
0000000000000000000000000000000000000000;;				writer.Write(payload)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkVolumeContents(targetDir, tc.name, payload, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkVolumeContents(targetDir, tcName string, payload map[string]FileProjection, t *testing.T) {
0000000000000000000000000000000000000000;;		// use filepath.Walk to reconstruct the payload, then deep equal
0000000000000000000000000000000000000000;;		observedPayload := make(map[string]FileProjection)
0000000000000000000000000000000000000000;;		visitor := func(path string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			if info.Mode().IsRegular() || info.IsDir() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			relativePath := strings.TrimPrefix(path, targetDir)
0000000000000000000000000000000000000000;;			relativePath = strings.TrimPrefix(relativePath, "/")
0000000000000000000000000000000000000000;;			if strings.HasPrefix(relativePath, "..") {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			content, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fileInfo, err := os.Stat(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mode := int32(fileInfo.Mode())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			observedPayload[relativePath] = FileProjection{Data: content, Mode: mode}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := filepath.Walk(targetDir, visitor)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v: unexpected error walking directory: %v", tcName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cleanPathPayload := make(map[string]FileProjection, len(payload))
0000000000000000000000000000000000000000;;		for k, v := range payload {
0000000000000000000000000000000000000000;;			cleanPathPayload[path.Clean(k)] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(cleanPathPayload, observedPayload) {
0000000000000000000000000000000000000000;;			t.Errorf("%v: payload and observed payload do not match.", tcName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
