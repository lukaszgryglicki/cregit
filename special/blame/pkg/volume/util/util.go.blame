0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
00fa99fdd6e01cd47f6be9e3891a56c3536d1d4c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		storage "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		v1helper "k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const readyFileName = "ready"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsReady checks for the existence of a regular file
0000000000000000000000000000000000000000;;	// called 'ready' in the given directory and returns
0000000000000000000000000000000000000000;;	// true if that file exists.
0000000000000000000000000000000000000000;;	func IsReady(dir string) bool {
0000000000000000000000000000000000000000;;		readyFile := path.Join(dir, readyFileName)
0000000000000000000000000000000000000000;;		s, err := os.Stat(readyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.Mode().IsRegular() {
0000000000000000000000000000000000000000;;			glog.Errorf("ready-file is not a file: %s", readyFile)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReady creates a file called 'ready' in the given
0000000000000000000000000000000000000000;;	// directory.  It logs an error if the file cannot be
0000000000000000000000000000000000000000;;	// created.
0000000000000000000000000000000000000000;;	func SetReady(dir string) {
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("Can't mkdir %s: %v", dir, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readyFile := path.Join(dir, readyFileName)
0000000000000000000000000000000000000000;;		file, err := os.Create(readyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Can't touch %s: %v", readyFile, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		file.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmountPath is a common unmount routine that unmounts the given path and
0000000000000000000000000000000000000000;;	// deletes the remaining directory if successful.
0000000000000000000000000000000000000000;;	func UnmountPath(mountPath string, mounter mount.Interface) error {
0000000000000000000000000000000000000000;;		return UnmountMountPoint(mountPath, mounter, false /* extensiveMountPointCheck */)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmountMountPoint is a common unmount routine that unmounts the given path and
0000000000000000000000000000000000000000;;	// deletes the remaining directory if successful.
0000000000000000000000000000000000000000;;	// if extensiveMountPointCheck is true
0000000000000000000000000000000000000000;;	// IsNotMountPoint will be called instead of IsLikelyNotMountPoint.
0000000000000000000000000000000000000000;;	// IsNotMountPoint is more expensive but properly handles bind mounts.
0000000000000000000000000000000000000000;;	func UnmountMountPoint(mountPath string, mounter mount.Interface, extensiveMountPointCheck bool) error {
0000000000000000000000000000000000000000;;		if pathExists, pathErr := PathExists(mountPath); pathErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error checking if path exists: %v", pathErr)
0000000000000000000000000000000000000000;;		} else if !pathExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: Unmount skipped because path does not exist: %v", mountPath)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var notMnt bool
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if extensiveMountPointCheck {
0000000000000000000000000000000000000000;;			notMnt, err = mount.IsNotMountPoint(mounter, mountPath)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			notMnt, err = mounter.IsLikelyNotMountPoint(mountPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: %q is not a mountpoint, deleting", mountPath)
0000000000000000000000000000000000000000;;			return os.Remove(mountPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unmount the mount path
0000000000000000000000000000000000000000;;		glog.V(4).Infof("%q is a mountpoint, unmounting", mountPath)
0000000000000000000000000000000000000000;;		if err := mounter.Unmount(mountPath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		notMnt, mntErr := mounter.IsLikelyNotMountPoint(mountPath)
0000000000000000000000000000000000000000;;		if mntErr != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("%q is unmounted, deleting the directory", mountPath)
0000000000000000000000000000000000000000;;			return os.Remove(mountPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Failed to unmount path %v", mountPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathExists returns true if the specified path exists.
0000000000000000000000000000000000000000;;	func PathExists(path string) (bool, error) {
0000000000000000000000000000000000000000;;		_, err := os.Stat(path)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		} else if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSecretForPod locates secret by name in the pod's namespace and returns secret map
0000000000000000000000000000000000000000;;	func GetSecretForPod(pod *v1.Pod, secretName string, kubeClient clientset.Interface) (map[string]string, error) {
0000000000000000000000000000000000000000;;		secret := make(map[string]string)
0000000000000000000000000000000000000000;;		if kubeClient == nil {
0000000000000000000000000000000000000000;;			return secret, fmt.Errorf("Cannot get kube client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secrets, err := kubeClient.Core().Secrets(pod.Namespace).Get(secretName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return secret, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, data := range secrets.Data {
0000000000000000000000000000000000000000;;			secret[name] = string(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return secret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSecretForPV locates secret by name and namespace, verifies the secret type, and returns secret map
0000000000000000000000000000000000000000;;	func GetSecretForPV(secretNamespace, secretName, volumePluginName string, kubeClient clientset.Interface) (map[string]string, error) {
0000000000000000000000000000000000000000;;		secret := make(map[string]string)
0000000000000000000000000000000000000000;;		if kubeClient == nil {
0000000000000000000000000000000000000000;;			return secret, fmt.Errorf("Cannot get kube client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secrets, err := kubeClient.Core().Secrets(secretNamespace).Get(secretName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return secret, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if secrets.Type != v1.SecretType(volumePluginName) {
0000000000000000000000000000000000000000;;			return secret, fmt.Errorf("Cannot get secret of type %s", volumePluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, data := range secrets.Data {
0000000000000000000000000000000000000000;;			secret[name] = string(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return secret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetClassForVolume(kubeClient clientset.Interface, pv *v1.PersistentVolume) (*storage.StorageClass, error) {
0000000000000000000000000000000000000000;;		if kubeClient == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Cannot get kube client")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		className := v1helper.GetPersistentVolumeClass(pv)
0000000000000000000000000000000000000000;;		if className == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Volume has no storage class")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		class, err := kubeClient.StorageV1().StorageClasses().Get(className, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return class, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckNodeAffinity looks at the PV node affinity, and checks if the node has the same corresponding labels
0000000000000000000000000000000000000000;;	// This ensures that we don't mount a volume that doesn't belong to this node
0000000000000000000000000000000000000000;;	func CheckNodeAffinity(pv *v1.PersistentVolume, nodeLabels map[string]string) error {
0000000000000000000000000000000000000000;;		affinity, err := v1helper.GetStorageNodeAffinityFromAnnotation(pv.Annotations)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error getting storage node affinity: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if affinity == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if affinity.RequiredDuringSchedulingIgnoredDuringExecution != nil {
0000000000000000000000000000000000000000;;			terms := affinity.RequiredDuringSchedulingIgnoredDuringExecution.NodeSelectorTerms
0000000000000000000000000000000000000000;;			glog.V(10).Infof("Match for RequiredDuringSchedulingIgnoredDuringExecution node selector terms %+v", terms)
0000000000000000000000000000000000000000;;			for _, term := range terms {
0000000000000000000000000000000000000000;;				selector, err := v1helper.NodeSelectorRequirementsAsSelector(term.MatchExpressions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Failed to parse MatchExpressions: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !selector.Matches(labels.Set(nodeLabels)) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("NodeSelectorTerm %+v does not match node labels", term.MatchExpressions)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadPodFromFile will read, decode, and return a Pod from a file.
0000000000000000000000000000000000000000;;	func LoadPodFromFile(filePath string) (*v1.Pod, error) {
0000000000000000000000000000000000000000;;		if filePath == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("file path not specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podDef, err := ioutil.ReadFile(filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to read file path %s: %+v", filePath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(podDef) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("file was empty: %s", filePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := api.Codecs.LegacyCodec(api.Registry.GroupOrDie(v1.GroupName).GroupVersion)
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, podDef, pod); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed decoding file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod, nil
0000000000000000000000000000000000000000;;	}
