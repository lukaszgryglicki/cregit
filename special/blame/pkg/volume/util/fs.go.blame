0000000000000000000000000000000000000000;;	// +build linux darwin
550df90b0dfa6edde5ce972d9c9d21d156911343;pkg/volume/util/fs_linux.go[pkg/volume/util/fs_linux.go][pkg/volume/util/fs.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FSInfo linux returns (available bytes, byte capacity, byte usage, total inodes, inodes free, inode usage, error)
0000000000000000000000000000000000000000;;	// for the filesystem that path resides upon.
0000000000000000000000000000000000000000;;	func FsInfo(path string) (int64, int64, int64, int64, int64, int64, error) {
0000000000000000000000000000000000000000;;		statfs := &syscall.Statfs_t{}
0000000000000000000000000000000000000000;;		err := syscall.Statfs(path, statfs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Available is blocks available * fragment size
0000000000000000000000000000000000000000;;		available := int64(statfs.Bavail) * int64(statfs.Bsize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Capacity is total block count * fragment size
0000000000000000000000000000000000000000;;		capacity := int64(statfs.Blocks) * int64(statfs.Bsize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Usage is block being used * fragment size (aka block size).
0000000000000000000000000000000000000000;;		usage := (int64(statfs.Blocks) - int64(statfs.Bfree)) * int64(statfs.Bsize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inodes := int64(statfs.Files)
0000000000000000000000000000000000000000;;		inodesFree := int64(statfs.Ffree)
0000000000000000000000000000000000000000;;		inodesUsed := inodes - inodesFree
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return available, capacity, usage, inodes, inodesFree, inodesUsed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Du(path string) (*resource.Quantity, error) {
0000000000000000000000000000000000000000;;		// Uses the same niceness level as cadvisor.fs does when running du
0000000000000000000000000000000000000000;;		// Uses -B 1 to always scale to a blocksize of 1 byte
0000000000000000000000000000000000000000;;		out, err := exec.Command("nice", "-n", "19", "du", "-s", "-B", "1", path).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed command 'du' ($ nice -n 19 du -s -B 1) on path %s with error %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		used, err := resource.ParseQuantity(strings.Fields(string(out))[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to parse 'du' output %s due to error %v", out, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		used.Format = resource.BinarySI
0000000000000000000000000000000000000000;;		return &used, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find uses the equivalent of the command `find <path> -dev -printf '.' | wc -c` to count files and directories.
0000000000000000000000000000000000000000;;	// While this is not an exact measure of inodes used, it is a very good approximation.
0000000000000000000000000000000000000000;;	func Find(path string) (int64, error) {
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid directory")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var counter byteCounter
0000000000000000000000000000000000000000;;		var stderr bytes.Buffer
0000000000000000000000000000000000000000;;		findCmd := exec.Command("find", path, "-xdev", "-printf", ".")
0000000000000000000000000000000000000000;;		findCmd.Stdout, findCmd.Stderr = &counter, &stderr
0000000000000000000000000000000000000000;;		if err := findCmd.Start(); err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to exec cmd %v - %v; stderr: %v", findCmd.Args, err, stderr.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := findCmd.Wait(); err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("cmd %v failed. stderr: %s; err: %v", findCmd.Args, stderr.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return counter.bytesWritten, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Simple io.Writer implementation that counts how many bytes were written.
0000000000000000000000000000000000000000;;	type byteCounter struct{ bytesWritten int64 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *byteCounter) Write(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		b.bytesWritten += int64(len(p))
0000000000000000000000000000000000000000;;		return len(p), nil
0000000000000000000000000000000000000000;;	}
