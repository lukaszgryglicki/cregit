0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bddce78bb230f6bbff826455be1206d180c3046a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package operationexecutor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetypes "k8s.io/kubernetes/pkg/volume/util/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		numVolumesToMount                    = 2
0000000000000000000000000000000000000000;;		numAttachableVolumesToUnmount        = 2
0000000000000000000000000000000000000000;;		numNonAttachableVolumesToUnmount     = 2
0000000000000000000000000000000000000000;;		numDevicesToUnmount                  = 2
0000000000000000000000000000000000000000;;		numVolumesToAttach                   = 2
0000000000000000000000000000000000000000;;		numVolumesToDetach                   = 2
0000000000000000000000000000000000000000;;		numVolumesToVerifyAttached           = 2
0000000000000000000000000000000000000000;;		numVolumesToVerifyControllerAttached = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ OperationGenerator = &fakeOperationGenerator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_MountVolume_ConcurrentMountForNonAttachablePlugins(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;		volumesToMount := make([]VolumeToMount, numVolumesToMount)
0000000000000000000000000000000000000000;;		secretName := "secret-volume"
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName(secretName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := range volumesToMount {
0000000000000000000000000000000000000000;;			podName := "pod-" + strconv.Itoa((i + 1))
0000000000000000000000000000000000000000;;			pod := getTestPodWithSecret(podName, secretName)
0000000000000000000000000000000000000000;;			volumesToMount[i] = VolumeToMount{
0000000000000000000000000000000000000000;;				Pod:                pod,
0000000000000000000000000000000000000000;;				VolumeName:         volumeName,
0000000000000000000000000000000000000000;;				PluginIsAttachable: false, // this field determines whether the plugin is attachable
0000000000000000000000000000000000000000;;				ReportedInUse:      true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oe.MountVolume(0 /* waitForAttachTimeOut */, volumesToMount[i], nil /* actualStateOfWorldMounterUpdater */, false /* isRemount */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunConcurrently(ch, quit, numVolumesToMount) {
0000000000000000000000000000000000000000;;			t.Fatalf("Unable to start mount operations in Concurrent for non-attachable volumes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_MountVolume_ConcurrentMountForAttachablePlugins(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;		volumesToMount := make([]VolumeToMount, numVolumesToAttach)
0000000000000000000000000000000000000000;;		pdName := "pd-volume"
0000000000000000000000000000000000000000;;		volumeName := v1.UniqueVolumeName(pdName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := range volumesToMount {
0000000000000000000000000000000000000000;;			podName := "pod-" + strconv.Itoa((i + 1))
0000000000000000000000000000000000000000;;			pod := getTestPodWithGCEPD(podName, pdName)
0000000000000000000000000000000000000000;;			volumesToMount[i] = VolumeToMount{
0000000000000000000000000000000000000000;;				Pod:                pod,
0000000000000000000000000000000000000000;;				VolumeName:         volumeName,
0000000000000000000000000000000000000000;;				PluginIsAttachable: true, // this field determines whether the plugin is attachable
0000000000000000000000000000000000000000;;				ReportedInUse:      true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oe.MountVolume(0 /* waitForAttachTimeout */, volumesToMount[i], nil /* actualStateOfWorldMounterUpdater */, false /* isRemount */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunSerially(ch, quit) {
0000000000000000000000000000000000000000;;			t.Fatalf("Mount operations should not start concurrently for attachable volumes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_UnmountVolume_ConcurrentUnmountForAllPlugins(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;		volumesToUnmount := make([]MountedVolume, numAttachableVolumesToUnmount+numNonAttachableVolumesToUnmount)
0000000000000000000000000000000000000000;;		pdName := "pd-volume"
0000000000000000000000000000000000000000;;		secretName := "secret-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := 0; i < numNonAttachableVolumesToUnmount+numAttachableVolumesToUnmount; i++ {
0000000000000000000000000000000000000000;;			podName := "pod-" + strconv.Itoa(i+1)
0000000000000000000000000000000000000000;;			if i < numNonAttachableVolumesToUnmount {
0000000000000000000000000000000000000000;;				pod := getTestPodWithSecret(podName, secretName)
0000000000000000000000000000000000000000;;				volumesToUnmount[i] = MountedVolume{
0000000000000000000000000000000000000000;;					PodName:    volumetypes.UniquePodName(podName),
0000000000000000000000000000000000000000;;					VolumeName: v1.UniqueVolumeName(secretName),
0000000000000000000000000000000000000000;;					PodUID:     pod.UID,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pod := getTestPodWithGCEPD(podName, pdName)
0000000000000000000000000000000000000000;;				volumesToUnmount[i] = MountedVolume{
0000000000000000000000000000000000000000;;					PodName:    volumetypes.UniquePodName(podName),
0000000000000000000000000000000000000000;;					VolumeName: v1.UniqueVolumeName(pdName),
0000000000000000000000000000000000000000;;					PodUID:     pod.UID,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oe.UnmountVolume(volumesToUnmount[i], nil /* actualStateOfWorldMounterUpdater */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunConcurrently(ch, quit, numNonAttachableVolumesToUnmount+numAttachableVolumesToUnmount) {
0000000000000000000000000000000000000000;;			t.Fatalf("Unable to start unmount operations concurrently for volume plugins")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_UnmountDeviceConcurrently(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;		attachedVolumes := make([]AttachedVolume, numDevicesToUnmount)
0000000000000000000000000000000000000000;;		pdName := "pd-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := range attachedVolumes {
0000000000000000000000000000000000000000;;			attachedVolumes[i] = AttachedVolume{
0000000000000000000000000000000000000000;;				VolumeName: v1.UniqueVolumeName(pdName),
0000000000000000000000000000000000000000;;				NodeName:   "node-name",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oe.UnmountDevice(attachedVolumes[i], nil /* actualStateOfWorldMounterUpdater */, nil /* mount.Interface */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunSerially(ch, quit) {
0000000000000000000000000000000000000000;;			t.Fatalf("Unmount device operations should not start concurrently")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_AttachVolumeConcurrently(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;		volumesToAttach := make([]VolumeToAttach, numVolumesToAttach)
0000000000000000000000000000000000000000;;		pdName := "pd-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := range volumesToAttach {
0000000000000000000000000000000000000000;;			volumesToAttach[i] = VolumeToAttach{
0000000000000000000000000000000000000000;;				VolumeName: v1.UniqueVolumeName(pdName),
0000000000000000000000000000000000000000;;				NodeName:   "node",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oe.AttachVolume(volumesToAttach[i], nil /* actualStateOfWorldAttacherUpdater */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunSerially(ch, quit) {
0000000000000000000000000000000000000000;;			t.Fatalf("Attach volume operations should not start concurrently")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_DetachVolumeConcurrently(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;		attachedVolumes := make([]AttachedVolume, numVolumesToDetach)
0000000000000000000000000000000000000000;;		pdName := "pd-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := range attachedVolumes {
0000000000000000000000000000000000000000;;			attachedVolumes[i] = AttachedVolume{
0000000000000000000000000000000000000000;;				VolumeName: v1.UniqueVolumeName(pdName),
0000000000000000000000000000000000000000;;				NodeName:   "node",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oe.DetachVolume(attachedVolumes[i], true /* verifySafeToDetach */, nil /* actualStateOfWorldAttacherUpdater */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunSerially(ch, quit) {
0000000000000000000000000000000000000000;;			t.Fatalf("DetachVolume operations should not run concurrently")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_VerifyVolumesAreAttachedConcurrently(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := 0; i < numVolumesToVerifyAttached; i++ {
0000000000000000000000000000000000000000;;			oe.VerifyVolumesAreAttachedPerNode(nil /* attachedVolumes */, "node-name", nil /* actualStateOfWorldAttacherUpdater */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunConcurrently(ch, quit, numVolumesToVerifyAttached) {
0000000000000000000000000000000000000000;;			t.Fatalf("VerifyVolumesAreAttached operation is not being run concurrently")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOperationExecutor_VerifyControllerAttachedVolumeConcurrently(t *testing.T) {
0000000000000000000000000000000000000000;;		// Arrange
0000000000000000000000000000000000000000;;		ch, quit, oe := setup()
0000000000000000000000000000000000000000;;		volumesToMount := make([]VolumeToMount, numVolumesToVerifyControllerAttached)
0000000000000000000000000000000000000000;;		pdName := "pd-volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Act
0000000000000000000000000000000000000000;;		for i := range volumesToMount {
0000000000000000000000000000000000000000;;			volumesToMount[i] = VolumeToMount{
0000000000000000000000000000000000000000;;				VolumeName: v1.UniqueVolumeName(pdName),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oe.VerifyControllerAttachedVolume(volumesToMount[i], types.NodeName("node-name"), nil /* actualStateOfWorldMounterUpdater */)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assert
0000000000000000000000000000000000000000;;		if !isOperationRunSerially(ch, quit) {
0000000000000000000000000000000000000000;;			t.Fatalf("VerifyControllerAttachedVolume should not run concurrently")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeOperationGenerator struct {
0000000000000000000000000000000000000000;;		ch   chan interface{}
0000000000000000000000000000000000000000;;		quit chan interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFakeOperationGenerator(ch chan interface{}, quit chan interface{}) OperationGenerator {
0000000000000000000000000000000000000000;;		return &fakeOperationGenerator{
0000000000000000000000000000000000000000;;			ch:   ch,
0000000000000000000000000000000000000000;;			quit: quit,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateMountVolumeFunc(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorldMounterUpdater ActualStateOfWorldMounterUpdater, isRemount bool) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateUnmountVolumeFunc(volumeToUnmount MountedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateAttachVolumeFunc(volumeToAttach VolumeToAttach, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateDetachVolumeFunc(volumeToDetach AttachedVolume, verifySafeToDetach bool, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateVolumesAreAttachedFunc(attachedVolumes []AttachedVolume, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateUnmountDeviceFunc(deviceToDetach AttachedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, mounter mount.Interface) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateVerifyControllerAttachedVolumeFunc(volumeToMount VolumeToMount, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GenerateBulkVolumeVerifyFunc(
0000000000000000000000000000000000000000;;		pluginNodeVolumes map[types.NodeName][]*volume.Spec,
0000000000000000000000000000000000000000;;		pluginNane string,
0000000000000000000000000000000000000000;;		volumeSpecMap map[*volume.Spec]v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		actualStateOfWorldAttacherUpdater ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			startOperationAndBlock(fopg.ch, fopg.quit)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fopg *fakeOperationGenerator) GetVolumePluginMgr() *volume.VolumePluginMgr {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestPodWithSecret(podName, secretName string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;				UID:  types.UID(podName),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: secretName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;								SecretName: secretName,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "secret-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/secret-volume/data-1",
0000000000000000000000000000000000000000;;							"--file_mode=/etc/secret-volume/data-1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      secretName,
0000000000000000000000000000000000000000;;								MountPath: "/data",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTestPodWithGCEPD(podName, pdName string) *v1.Pod {
0000000000000000000000000000000000000000;;		return &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: podName,
0000000000000000000000000000000000000000;;				UID:  types.UID(podName + string(uuid.NewUUID())),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: pdName,
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;							GCEPersistentDisk: &v1.GCEPersistentDiskVolumeSource{
0000000000000000000000000000000000000000;;								PDName:   pdName,
0000000000000000000000000000000000000000;;								FSType:   "ext4",
0000000000000000000000000000000000000000;;								ReadOnly: false,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:  "pd-volume-test",
0000000000000000000000000000000000000000;;						Image: "gcr.io/google_containers/mounttest:0.8",
0000000000000000000000000000000000000000;;						Args: []string{
0000000000000000000000000000000000000000;;							"--file_content=/etc/pd-volume/data-1",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      pdName,
0000000000000000000000000000000000000000;;								MountPath: "/data",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RestartPolicy: v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isOperationRunSerially(ch <-chan interface{}, quit chan<- interface{}) bool {
0000000000000000000000000000000000000000;;		defer close(quit)
0000000000000000000000000000000000000000;;		numOperationsStarted := 0
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ch:
0000000000000000000000000000000000000000;;				numOperationsStarted++
0000000000000000000000000000000000000000;;				if numOperationsStarted > 1 {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(5 * time.Second):
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isOperationRunConcurrently(ch <-chan interface{}, quit chan<- interface{}, numOperationsToRun int) bool {
0000000000000000000000000000000000000000;;		defer close(quit)
0000000000000000000000000000000000000000;;		numOperationsStarted := 0
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ch:
0000000000000000000000000000000000000000;;				numOperationsStarted++
0000000000000000000000000000000000000000;;				if numOperationsStarted == numOperationsToRun {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(5 * time.Second):
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setup() (chan interface{}, chan interface{}, OperationExecutor) {
0000000000000000000000000000000000000000;;		ch, quit := make(chan interface{}), make(chan interface{})
0000000000000000000000000000000000000000;;		return ch, quit, NewOperationExecutor(newFakeOperationGenerator(ch, quit))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function starts by writing to ch and blocks on the quit channel
0000000000000000000000000000000000000000;;	// until it is closed by the currently running test
0000000000000000000000000000000000000000;;	func startOperationAndBlock(ch chan<- interface{}, quit <-chan interface{}) {
0000000000000000000000000000000000000000;;		ch <- nil
0000000000000000000000000000000000000000;;		<-quit
0000000000000000000000000000000000000000;;	}
