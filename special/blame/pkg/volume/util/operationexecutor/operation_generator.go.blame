0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
bddce78bb230f6bbff826455be1206d180c3046a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package operationexecutor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/features"
0000000000000000000000000000000000000000;;		kevents "k8s.io/kubernetes/pkg/kubelet/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ OperationGenerator = &operationGenerator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type operationGenerator struct {
0000000000000000000000000000000000000000;;		// Used to fetch objects from the API server like Node in the
0000000000000000000000000000000000000000;;		// VerifyControllerAttachedVolume operation.
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumePluginMgr is the volume plugin manager used to create volume
0000000000000000000000000000000000000000;;		// plugin objects.
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// recorder is used to record events in the API server
0000000000000000000000000000000000000000;;		recorder record.EventRecorder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// checkNodeCapabilitiesBeforeMount, if set, enables the CanMount check,
0000000000000000000000000000000000000000;;		// which verifies that the components (binaries, etc.) required to mount
0000000000000000000000000000000000000000;;		// the volume are available on the underlying node before attempting mount.
0000000000000000000000000000000000000000;;		checkNodeCapabilitiesBeforeMount bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewOperationGenerator is returns instance of operationGenerator
0000000000000000000000000000000000000000;;	func NewOperationGenerator(kubeClient clientset.Interface,
0000000000000000000000000000000000000000;;		volumePluginMgr *volume.VolumePluginMgr,
0000000000000000000000000000000000000000;;		recorder record.EventRecorder,
0000000000000000000000000000000000000000;;		checkNodeCapabilitiesBeforeMount bool) OperationGenerator {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &operationGenerator{
0000000000000000000000000000000000000000;;			kubeClient:      kubeClient,
0000000000000000000000000000000000000000;;			volumePluginMgr: volumePluginMgr,
0000000000000000000000000000000000000000;;			recorder:        recorder,
0000000000000000000000000000000000000000;;			checkNodeCapabilitiesBeforeMount: checkNodeCapabilitiesBeforeMount,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OperationGenerator interface that extracts out the functions from operation_executor to make it dependency injectable
0000000000000000000000000000000000000000;;	type OperationGenerator interface {
0000000000000000000000000000000000000000;;		// Generates the MountVolume function needed to perform the mount of a volume plugin
0000000000000000000000000000000000000000;;		GenerateMountVolumeFunc(waitForAttachTimeout time.Duration, volumeToMount VolumeToMount, actualStateOfWorldMounterUpdater ActualStateOfWorldMounterUpdater, isRemount bool) (func() error, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generates the UnmountVolume function needed to perform the unmount of a volume plugin
0000000000000000000000000000000000000000;;		GenerateUnmountVolumeFunc(volumeToUnmount MountedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater) (func() error, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generates the AttachVolume function needed to perform attach of a volume plugin
0000000000000000000000000000000000000000;;		GenerateAttachVolumeFunc(volumeToAttach VolumeToAttach, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generates the DetachVolume function needed to perform the detach of a volume plugin
0000000000000000000000000000000000000000;;		GenerateDetachVolumeFunc(volumeToDetach AttachedVolume, verifySafeToDetach bool, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generates the VolumesAreAttached function needed to verify if volume plugins are attached
0000000000000000000000000000000000000000;;		GenerateVolumesAreAttachedFunc(attachedVolumes []AttachedVolume, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generates the UnMountDevice function needed to perform the unmount of a device
0000000000000000000000000000000000000000;;		GenerateUnmountDeviceFunc(deviceToDetach AttachedVolume, actualStateOfWorld ActualStateOfWorldMounterUpdater, mounter mount.Interface) (func() error, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generates the function needed to check if the attach_detach controller has attached the volume plugin
0000000000000000000000000000000000000000;;		GenerateVerifyControllerAttachedVolumeFunc(volumeToMount VolumeToMount, nodeName types.NodeName, actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetVolumePluginMgr returns volume plugin manager
0000000000000000000000000000000000000000;;		GetVolumePluginMgr() *volume.VolumePluginMgr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GenerateBulkVolumeVerifyFunc(
0000000000000000000000000000000000000000;;			map[types.NodeName][]*volume.Spec,
0000000000000000000000000000000000000000;;			string,
0000000000000000000000000000000000000000;;			map[*volume.Spec]v1.UniqueVolumeName, ActualStateOfWorldAttacherUpdater) (func() error, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateVolumesAreAttachedFunc(
0000000000000000000000000000000000000000;;		attachedVolumes []AttachedVolume,
0000000000000000000000000000000000000000;;		nodeName types.NodeName,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumesPerPlugin maps from a volume plugin to a list of volume specs which belong
0000000000000000000000000000000000000000;;		// to this type of plugin
0000000000000000000000000000000000000000;;		volumesPerPlugin := make(map[string][]*volume.Spec)
0000000000000000000000000000000000000000;;		// volumeSpecMap maps from a volume spec to its unique volumeName which will be used
0000000000000000000000000000000000000000;;		// when calling MarkVolumeAsDetached
0000000000000000000000000000000000000000;;		volumeSpecMap := make(map[*volume.Spec]v1.UniqueVolumeName)
0000000000000000000000000000000000000000;;		// Iterate each volume spec and put them into a map index by the pluginName
0000000000000000000000000000000000000000;;		for _, volumeAttached := range attachedVolumes {
0000000000000000000000000000000000000000;;			volumePlugin, err :=
0000000000000000000000000000000000000000;;				og.volumePluginMgr.FindPluginBySpec(volumeAttached.VolumeSpec)
0000000000000000000000000000000000000000;;			if err != nil || volumePlugin == nil {
0000000000000000000000000000000000000000;;				glog.Errorf(volumeAttached.GenerateErrorDetailed("VolumesAreAttached.FindPluginBySpec failed", err).Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeSpecList, pluginExists := volumesPerPlugin[volumePlugin.GetPluginName()]
0000000000000000000000000000000000000000;;			if !pluginExists {
0000000000000000000000000000000000000000;;				volumeSpecList = []*volume.Spec{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumeSpecList = append(volumeSpecList, volumeAttached.VolumeSpec)
0000000000000000000000000000000000000000;;			volumesPerPlugin[volumePlugin.GetPluginName()] = volumeSpecList
0000000000000000000000000000000000000000;;			volumeSpecMap[volumeAttached.VolumeSpec] = volumeAttached.VolumeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// For each volume plugin, pass the list of volume specs to VolumesAreAttached to check
0000000000000000000000000000000000000000;;			// whether the volumes are still attached.
0000000000000000000000000000000000000000;;			for pluginName, volumesSpecs := range volumesPerPlugin {
0000000000000000000000000000000000000000;;				attachableVolumePlugin, err :=
0000000000000000000000000000000000000000;;					og.volumePluginMgr.FindAttachablePluginByName(pluginName)
0000000000000000000000000000000000000000;;				if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;					glog.Errorf(
0000000000000000000000000000000000000000;;						"VolumeAreAttached.FindAttachablePluginBySpec failed for plugin %q with: %v",
0000000000000000000000000000000000000000;;						pluginName,
0000000000000000000000000000000000000000;;						err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				volumeAttacher, newAttacherErr := attachableVolumePlugin.NewAttacher()
0000000000000000000000000000000000000000;;				if newAttacherErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf(
0000000000000000000000000000000000000000;;						"VolumesAreAttached.NewAttacher failed for getting plugin %q with: %v",
0000000000000000000000000000000000000000;;						pluginName,
0000000000000000000000000000000000000000;;						newAttacherErr)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				attached, areAttachedErr := volumeAttacher.VolumesAreAttached(volumesSpecs, nodeName)
0000000000000000000000000000000000000000;;				if areAttachedErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf(
0000000000000000000000000000000000000000;;						"VolumesAreAttached failed for checking on node %q with: %v",
0000000000000000000000000000000000000000;;						nodeName,
0000000000000000000000000000000000000000;;						areAttachedErr)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for spec, check := range attached {
0000000000000000000000000000000000000000;;					if !check {
0000000000000000000000000000000000000000;;						actualStateOfWorld.MarkVolumeAsDetached(volumeSpecMap[spec], nodeName)
0000000000000000000000000000000000000000;;						glog.V(1).Infof("VerifyVolumesAreAttached determined volume %q (spec.Name: %q) is no longer attached to node %q, therefore it was marked as detached.",
0000000000000000000000000000000000000000;;							volumeSpecMap[spec], spec.Name(), nodeName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateBulkVolumeVerifyFunc(
0000000000000000000000000000000000000000;;		pluginNodeVolumes map[types.NodeName][]*volume.Spec,
0000000000000000000000000000000000000000;;		pluginName string,
0000000000000000000000000000000000000000;;		volumeSpecMap map[*volume.Spec]v1.UniqueVolumeName,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			attachableVolumePlugin, err :=
0000000000000000000000000000000000000000;;				og.volumePluginMgr.FindAttachablePluginByName(pluginName)
0000000000000000000000000000000000000000;;			if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;				glog.Errorf(
0000000000000000000000000000000000000000;;					"BulkVerifyVolume.FindAttachablePluginBySpec failed for plugin %q with: %v",
0000000000000000000000000000000000000000;;					pluginName,
0000000000000000000000000000000000000000;;					err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeAttacher, newAttacherErr := attachableVolumePlugin.NewAttacher()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if newAttacherErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf(
0000000000000000000000000000000000000000;;					"BulkVerifyVolume.NewAttacher failed for getting plugin %q with: %v",
0000000000000000000000000000000000000000;;					attachableVolumePlugin,
0000000000000000000000000000000000000000;;					newAttacherErr)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bulkVolumeVerifier, ok := volumeAttacher.(volume.BulkVolumeVerifier)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("BulkVerifyVolume failed to type assert attacher %q", bulkVolumeVerifier)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attached, bulkAttachErr := bulkVolumeVerifier.BulkVerifyVolumes(pluginNodeVolumes)
0000000000000000000000000000000000000000;;			if bulkAttachErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("BulkVerifyVolume.BulkVerifyVolumes Error checking volumes are attached with %v", bulkAttachErr)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for nodeName, volumeSpecs := range pluginNodeVolumes {
0000000000000000000000000000000000000000;;				for _, volumeSpec := range volumeSpecs {
0000000000000000000000000000000000000000;;					nodeVolumeSpecs, nodeChecked := attached[nodeName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !nodeChecked {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("VerifyVolumesAreAttached.BulkVerifyVolumes failed for node %q and leaving volume %q as attached",
0000000000000000000000000000000000000000;;							nodeName,
0000000000000000000000000000000000000000;;							volumeSpec.Name())
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					check := nodeVolumeSpecs[volumeSpec]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !check {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("VerifyVolumesAreAttached.BulkVerifyVolumes failed for node %q and volume %q",
0000000000000000000000000000000000000000;;							nodeName,
0000000000000000000000000000000000000000;;							volumeSpec.Name())
0000000000000000000000000000000000000000;;						actualStateOfWorld.MarkVolumeAsDetached(volumeSpecMap[volumeSpec], nodeName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateAttachVolumeFunc(
0000000000000000000000000000000000000000;;		volumeToAttach VolumeToAttach,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		// Get attacher plugin
0000000000000000000000000000000000000000;;		attachableVolumePlugin, err :=
0000000000000000000000000000000000000000;;			og.volumePluginMgr.FindAttachablePluginBySpec(volumeToAttach.VolumeSpec)
0000000000000000000000000000000000000000;;		if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;			return nil, volumeToAttach.GenerateErrorDetailed("AttachVolume.FindAttachablePluginBySpec failed", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeAttacher, newAttacherErr := attachableVolumePlugin.NewAttacher()
0000000000000000000000000000000000000000;;		if newAttacherErr != nil {
0000000000000000000000000000000000000000;;			return nil, volumeToAttach.GenerateErrorDetailed("AttachVolume.NewAttacher failed", newAttacherErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			// Execute attach
0000000000000000000000000000000000000000;;			devicePath, attachErr := volumeAttacher.Attach(
0000000000000000000000000000000000000000;;				volumeToAttach.VolumeSpec, volumeToAttach.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if attachErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				eventErr, detailedErr := volumeToAttach.GenerateError("AttachVolume.Attach failed", attachErr)
0000000000000000000000000000000000000000;;				for _, pod := range volumeToAttach.ScheduledPods {
0000000000000000000000000000000000000000;;					og.recorder.Eventf(pod, v1.EventTypeWarning, kevents.FailedMountVolume, eventErr.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return detailedErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof(volumeToAttach.GenerateMsgDetailed("AttachVolume.Attach succeeded", ""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update actual state of world
0000000000000000000000000000000000000000;;			addVolumeNodeErr := actualStateOfWorld.MarkVolumeAsAttached(
0000000000000000000000000000000000000000;;				v1.UniqueVolumeName(""), volumeToAttach.VolumeSpec, volumeToAttach.NodeName, devicePath)
0000000000000000000000000000000000000000;;			if addVolumeNodeErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return volumeToAttach.GenerateErrorDetailed("AttachVolume.MarkVolumeAsAttached failed", addVolumeNodeErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GetVolumePluginMgr() *volume.VolumePluginMgr {
0000000000000000000000000000000000000000;;		return og.volumePluginMgr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateDetachVolumeFunc(
0000000000000000000000000000000000000000;;		volumeToDetach AttachedVolume,
0000000000000000000000000000000000000000;;		verifySafeToDetach bool,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		var volumeName string
0000000000000000000000000000000000000000;;		var attachableVolumePlugin volume.AttachableVolumePlugin
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volumeToDetach.VolumeSpec != nil {
0000000000000000000000000000000000000000;;			// Get attacher plugin
0000000000000000000000000000000000000000;;			attachableVolumePlugin, err =
0000000000000000000000000000000000000000;;				og.volumePluginMgr.FindAttachablePluginBySpec(volumeToDetach.VolumeSpec)
0000000000000000000000000000000000000000;;			if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;				return nil, volumeToDetach.GenerateErrorDetailed("DetachVolume.FindAttachablePluginBySpec failed", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeName, err =
0000000000000000000000000000000000000000;;				attachableVolumePlugin.GetVolumeName(volumeToDetach.VolumeSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, volumeToDetach.GenerateErrorDetailed("DetachVolume.GetVolumeName failed", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var pluginName string
0000000000000000000000000000000000000000;;			// Get attacher plugin and the volumeName by splitting the volume unique name in case
0000000000000000000000000000000000000000;;			// there's no VolumeSpec: this happens only on attach/detach controller crash recovery
0000000000000000000000000000000000000000;;			// when a pod has been deleted during the controller downtime
0000000000000000000000000000000000000000;;			pluginName, volumeName, err = volumehelper.SplitUniqueName(volumeToDetach.VolumeName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, volumeToDetach.GenerateErrorDetailed("DetachVolume.SplitUniqueName failed", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attachableVolumePlugin, err = og.volumePluginMgr.FindAttachablePluginByName(pluginName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, volumeToDetach.GenerateErrorDetailed("DetachVolume.FindAttachablePluginBySpec failed", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeDetacher, err := attachableVolumePlugin.NewDetacher()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, volumeToDetach.GenerateErrorDetailed("DetachVolume.NewDetacher failed", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if verifySafeToDetach {
0000000000000000000000000000000000000000;;				err = og.verifyVolumeIsSafeToDetach(volumeToDetach)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = volumeDetacher.Detach(volumeName, volumeToDetach.NodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// On failure, add volume back to ReportAsAttached list
0000000000000000000000000000000000000000;;				actualStateOfWorld.AddVolumeToReportAsAttached(
0000000000000000000000000000000000000000;;					volumeToDetach.VolumeName, volumeToDetach.NodeName)
0000000000000000000000000000000000000000;;				return volumeToDetach.GenerateErrorDetailed("DetachVolume.Detach failed", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof(volumeToDetach.GenerateMsgDetailed("DetachVolume.Detach succeeded", ""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update actual state of world
0000000000000000000000000000000000000000;;			actualStateOfWorld.MarkVolumeAsDetached(
0000000000000000000000000000000000000000;;				volumeToDetach.VolumeName, volumeToDetach.NodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateMountVolumeFunc(
0000000000000000000000000000000000000000;;		waitForAttachTimeout time.Duration,
0000000000000000000000000000000000000000;;		volumeToMount VolumeToMount,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldMounterUpdater,
0000000000000000000000000000000000000000;;		isRemount bool) (func() error, error) {
0000000000000000000000000000000000000000;;		// Get mounter plugin
0000000000000000000000000000000000000000;;		volumePlugin, err :=
0000000000000000000000000000000000000000;;			og.volumePluginMgr.FindPluginBySpec(volumeToMount.VolumeSpec)
0000000000000000000000000000000000000000;;		if err != nil || volumePlugin == nil {
0000000000000000000000000000000000000000;;			return nil, volumeToMount.GenerateErrorDetailed("MountVolume.FindPluginBySpec failed", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		affinityErr := checkNodeAffinity(og, volumeToMount, volumePlugin)
0000000000000000000000000000000000000000;;		if affinityErr != nil {
0000000000000000000000000000000000000000;;			return nil, affinityErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeMounter, newMounterErr := volumePlugin.NewMounter(
0000000000000000000000000000000000000000;;			volumeToMount.VolumeSpec,
0000000000000000000000000000000000000000;;			volumeToMount.Pod,
0000000000000000000000000000000000000000;;			volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if newMounterErr != nil {
0000000000000000000000000000000000000000;;			eventErr, detailedErr := volumeToMount.GenerateError("MountVolume.NewMounter initialization failed", newMounterErr)
0000000000000000000000000000000000000000;;			og.recorder.Eventf(volumeToMount.Pod, v1.EventTypeWarning, kevents.FailedMountVolume, eventErr.Error())
0000000000000000000000000000000000000000;;			return nil, detailedErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountCheckError := checkMountOptionSupport(og, volumeToMount, volumePlugin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mountCheckError != nil {
0000000000000000000000000000000000000000;;			return nil, mountCheckError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get attacher, if possible
0000000000000000000000000000000000000000;;		attachableVolumePlugin, _ :=
0000000000000000000000000000000000000000;;			og.volumePluginMgr.FindAttachablePluginBySpec(volumeToMount.VolumeSpec)
0000000000000000000000000000000000000000;;		var volumeAttacher volume.Attacher
0000000000000000000000000000000000000000;;		if attachableVolumePlugin != nil {
0000000000000000000000000000000000000000;;			volumeAttacher, _ = attachableVolumePlugin.NewAttacher()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var fsGroup *int64
0000000000000000000000000000000000000000;;		if volumeToMount.Pod.Spec.SecurityContext != nil &&
0000000000000000000000000000000000000000;;			volumeToMount.Pod.Spec.SecurityContext.FSGroup != nil {
0000000000000000000000000000000000000000;;			fsGroup = volumeToMount.Pod.Spec.SecurityContext.FSGroup
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			if volumeAttacher != nil {
0000000000000000000000000000000000000000;;				// Wait for attachable volumes to finish attaching
0000000000000000000000000000000000000000;;				glog.Infof(volumeToMount.GenerateMsgDetailed("MountVolume.WaitForAttach entering", fmt.Sprintf("DevicePath %q", volumeToMount.DevicePath)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				devicePath, err := volumeAttacher.WaitForAttach(
0000000000000000000000000000000000000000;;					volumeToMount.VolumeSpec, volumeToMount.DevicePath, waitForAttachTimeout)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;					return volumeToMount.GenerateErrorDetailed("MountVolume.WaitForAttach failed", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.Infof(volumeToMount.GenerateMsgDetailed("MountVolume.WaitForAttach succeeded", ""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				deviceMountPath, err :=
0000000000000000000000000000000000000000;;					volumeAttacher.GetDeviceMountPath(volumeToMount.VolumeSpec)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;					return volumeToMount.GenerateErrorDetailed("MountVolume.GetDeviceMountPath failed", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Mount device to global mount path
0000000000000000000000000000000000000000;;				err = volumeAttacher.MountDevice(
0000000000000000000000000000000000000000;;					volumeToMount.VolumeSpec,
0000000000000000000000000000000000000000;;					devicePath,
0000000000000000000000000000000000000000;;					deviceMountPath)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;					eventErr, detailedErr := volumeToMount.GenerateError("MountVolume.MountDevice failed", err)
0000000000000000000000000000000000000000;;					og.recorder.Eventf(volumeToMount.Pod, v1.EventTypeWarning, kevents.FailedMountVolume, eventErr.Error())
0000000000000000000000000000000000000000;;					return detailedErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				glog.Infof(volumeToMount.GenerateMsgDetailed("MountVolume.MountDevice succeeded", fmt.Sprintf("device mount path %q", deviceMountPath)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Update actual state of world to reflect volume is globally mounted
0000000000000000000000000000000000000000;;				markDeviceMountedErr := actualStateOfWorld.MarkDeviceAsMounted(
0000000000000000000000000000000000000000;;					volumeToMount.VolumeName)
0000000000000000000000000000000000000000;;				if markDeviceMountedErr != nil {
0000000000000000000000000000000000000000;;					// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;					return volumeToMount.GenerateErrorDetailed("MountVolume.MarkDeviceAsMounted failed", markDeviceMountedErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if og.checkNodeCapabilitiesBeforeMount {
0000000000000000000000000000000000000000;;				if canMountErr := volumeMounter.CanMount(); canMountErr != nil {
0000000000000000000000000000000000000000;;					err = fmt.Errorf(
0000000000000000000000000000000000000000;;						"Verify that your node machine has the required components before attempting to mount this volume type. %s",
0000000000000000000000000000000000000000;;						canMountErr)
0000000000000000000000000000000000000000;;					eventErr, detailedErr := volumeToMount.GenerateError("MountVolume.CanMount failed", err)
0000000000000000000000000000000000000000;;					og.recorder.Eventf(volumeToMount.Pod, v1.EventTypeWarning, kevents.FailedMountVolume, eventErr.Error())
0000000000000000000000000000000000000000;;					return detailedErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Execute mount
0000000000000000000000000000000000000000;;			mountErr := volumeMounter.SetUp(fsGroup)
0000000000000000000000000000000000000000;;			if mountErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				eventErr, detailedErr := volumeToMount.GenerateError("MountVolume.SetUp failed", mountErr)
0000000000000000000000000000000000000000;;				og.recorder.Eventf(volumeToMount.Pod, v1.EventTypeWarning, kevents.FailedMountVolume, eventErr.Error())
0000000000000000000000000000000000000000;;				return detailedErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			simpleMsg, detailedMsg := volumeToMount.GenerateMsg("MountVolume.SetUp succeeded", "")
0000000000000000000000000000000000000000;;			verbosity := glog.Level(1)
0000000000000000000000000000000000000000;;			if isRemount {
0000000000000000000000000000000000000000;;				verbosity = glog.Level(7)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				og.recorder.Eventf(volumeToMount.Pod, v1.EventTypeNormal, kevents.SuccessfulMountVolume, simpleMsg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(verbosity).Infof(detailedMsg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update actual state of world
0000000000000000000000000000000000000000;;			markVolMountedErr := actualStateOfWorld.MarkVolumeAsMounted(
0000000000000000000000000000000000000000;;				volumeToMount.PodName,
0000000000000000000000000000000000000000;;				volumeToMount.Pod.UID,
0000000000000000000000000000000000000000;;				volumeToMount.VolumeName,
0000000000000000000000000000000000000000;;				volumeMounter,
0000000000000000000000000000000000000000;;				volumeToMount.OuterVolumeSpecName,
0000000000000000000000000000000000000000;;				volumeToMount.VolumeGidValue)
0000000000000000000000000000000000000000;;			if markVolMountedErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return volumeToMount.GenerateErrorDetailed("MountVolume.MarkVolumeAsMounted failed", markVolMountedErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateUnmountVolumeFunc(
0000000000000000000000000000000000000000;;		volumeToUnmount MountedVolume,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldMounterUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		// Get mountable plugin
0000000000000000000000000000000000000000;;		volumePlugin, err :=
0000000000000000000000000000000000000000;;			og.volumePluginMgr.FindPluginByName(volumeToUnmount.PluginName)
0000000000000000000000000000000000000000;;		if err != nil || volumePlugin == nil {
0000000000000000000000000000000000000000;;			return nil, volumeToUnmount.GenerateErrorDetailed("UnmountVolume.FindPluginByName failed", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeUnmounter, newUnmounterErr := volumePlugin.NewUnmounter(
0000000000000000000000000000000000000000;;			volumeToUnmount.InnerVolumeSpecName, volumeToUnmount.PodUID)
0000000000000000000000000000000000000000;;		if newUnmounterErr != nil {
0000000000000000000000000000000000000000;;			return nil, volumeToUnmount.GenerateErrorDetailed("UnmountVolume.NewUnmounter failed", newUnmounterErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			// Execute unmount
0000000000000000000000000000000000000000;;			unmountErr := volumeUnmounter.TearDown()
0000000000000000000000000000000000000000;;			if unmountErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return volumeToUnmount.GenerateErrorDetailed("UnmountVolume.TearDown failed", unmountErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof(
0000000000000000000000000000000000000000;;				"UnmountVolume.TearDown succeeded for volume %q (OuterVolumeSpecName: %q) pod %q (UID: %q). InnerVolumeSpecName %q. PluginName %q, VolumeGidValue %q",
0000000000000000000000000000000000000000;;				volumeToUnmount.VolumeName,
0000000000000000000000000000000000000000;;				volumeToUnmount.OuterVolumeSpecName,
0000000000000000000000000000000000000000;;				volumeToUnmount.PodName,
0000000000000000000000000000000000000000;;				volumeToUnmount.PodUID,
0000000000000000000000000000000000000000;;				volumeToUnmount.InnerVolumeSpecName,
0000000000000000000000000000000000000000;;				volumeToUnmount.PluginName,
0000000000000000000000000000000000000000;;				volumeToUnmount.VolumeGidValue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update actual state of world
0000000000000000000000000000000000000000;;			markVolMountedErr := actualStateOfWorld.MarkVolumeAsUnmounted(
0000000000000000000000000000000000000000;;				volumeToUnmount.PodName, volumeToUnmount.VolumeName)
0000000000000000000000000000000000000000;;			if markVolMountedErr != nil {
0000000000000000000000000000000000000000;;				// On failure, just log and exit
0000000000000000000000000000000000000000;;				glog.Errorf(volumeToUnmount.GenerateErrorDetailed("UnmountVolume.MarkVolumeAsUnmounted failed", markVolMountedErr).Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateUnmountDeviceFunc(
0000000000000000000000000000000000000000;;		deviceToDetach AttachedVolume,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldMounterUpdater,
0000000000000000000000000000000000000000;;		mounter mount.Interface) (func() error, error) {
0000000000000000000000000000000000000000;;		// Get attacher plugin
0000000000000000000000000000000000000000;;		attachableVolumePlugin, err :=
0000000000000000000000000000000000000000;;			og.volumePluginMgr.FindAttachablePluginBySpec(deviceToDetach.VolumeSpec)
0000000000000000000000000000000000000000;;		if err != nil || attachableVolumePlugin == nil {
0000000000000000000000000000000000000000;;			return nil, deviceToDetach.GenerateErrorDetailed("UnmountDevice.FindAttachablePluginBySpec failed", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeDetacher, err := attachableVolumePlugin.NewDetacher()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, deviceToDetach.GenerateErrorDetailed("UnmountDevice.NewDetacher failed", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeAttacher, err := attachableVolumePlugin.NewAttacher()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, deviceToDetach.GenerateErrorDetailed("UnmountDevice.NewAttacher failed", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			deviceMountPath, err :=
0000000000000000000000000000000000000000;;				volumeAttacher.GetDeviceMountPath(deviceToDetach.VolumeSpec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return deviceToDetach.GenerateErrorDetailed("GetDeviceMountPath failed", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			refs, err := attachableVolumePlugin.GetDeviceMountRefs(deviceMountPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil || hasMountRefs(deviceMountPath, refs) {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("The device mount path %q is still mounted by other references %v", deviceMountPath, refs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return deviceToDetach.GenerateErrorDetailed("GetDeviceMountRefs check failed", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Execute unmount
0000000000000000000000000000000000000000;;			unmountDeviceErr := volumeDetacher.UnmountDevice(deviceMountPath)
0000000000000000000000000000000000000000;;			if unmountDeviceErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return deviceToDetach.GenerateErrorDetailed("UnmountDevice failed", unmountDeviceErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Before logging that UnmountDevice succeeded and moving on,
0000000000000000000000000000000000000000;;			// use mounter.PathIsDevice to check if the path is a device,
0000000000000000000000000000000000000000;;			// if so use mounter.DeviceOpened to check if the device is in use anywhere
0000000000000000000000000000000000000000;;			// else on the system. Retry if it returns true.
0000000000000000000000000000000000000000;;			isDevicePath, devicePathErr := mounter.PathIsDevice(deviceToDetach.DevicePath)
0000000000000000000000000000000000000000;;			var deviceOpened bool
0000000000000000000000000000000000000000;;			var deviceOpenedErr error
0000000000000000000000000000000000000000;;			if !isDevicePath && devicePathErr == nil {
0000000000000000000000000000000000000000;;				// not a device path or path doesn't exist
0000000000000000000000000000000000000000;;				//TODO: refer to #36092
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Not checking device path %s", deviceToDetach.DevicePath)
0000000000000000000000000000000000000000;;				deviceOpened = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				deviceOpened, deviceOpenedErr = mounter.DeviceOpened(deviceToDetach.DevicePath)
0000000000000000000000000000000000000000;;				if deviceOpenedErr != nil {
0000000000000000000000000000000000000000;;					return deviceToDetach.GenerateErrorDetailed("UnmountDevice.DeviceOpened failed", deviceOpenedErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The device is still in use elsewhere. Caller will log and retry.
0000000000000000000000000000000000000000;;			if deviceOpened {
0000000000000000000000000000000000000000;;				return deviceToDetach.GenerateErrorDetailed(
0000000000000000000000000000000000000000;;					"UnmountDevice failed",
0000000000000000000000000000000000000000;;					fmt.Errorf("the device is in use when it was no longer expected to be in use"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof(deviceToDetach.GenerateMsgDetailed("UnmountDevice succeeded", ""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update actual state of world
0000000000000000000000000000000000000000;;			markDeviceUnmountedErr := actualStateOfWorld.MarkDeviceAsUnmounted(
0000000000000000000000000000000000000000;;				deviceToDetach.VolumeName)
0000000000000000000000000000000000000000;;			if markDeviceUnmountedErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return deviceToDetach.GenerateErrorDetailed("MarkDeviceAsUnmounted failed", markDeviceUnmountedErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) GenerateVerifyControllerAttachedVolumeFunc(
0000000000000000000000000000000000000000;;		volumeToMount VolumeToMount,
0000000000000000000000000000000000000000;;		nodeName types.NodeName,
0000000000000000000000000000000000000000;;		actualStateOfWorld ActualStateOfWorldAttacherUpdater) (func() error, error) {
0000000000000000000000000000000000000000;;		return func() error {
0000000000000000000000000000000000000000;;			if !volumeToMount.PluginIsAttachable {
0000000000000000000000000000000000000000;;				// If the volume does not implement the attacher interface, it is
0000000000000000000000000000000000000000;;				// assumed to be attached and the actual state of the world is
0000000000000000000000000000000000000000;;				// updated accordingly.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				addVolumeNodeErr := actualStateOfWorld.MarkVolumeAsAttached(
0000000000000000000000000000000000000000;;					volumeToMount.VolumeName, volumeToMount.VolumeSpec, nodeName, "" /* devicePath */)
0000000000000000000000000000000000000000;;				if addVolumeNodeErr != nil {
0000000000000000000000000000000000000000;;					// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;					return volumeToMount.GenerateErrorDetailed("VerifyControllerAttachedVolume.MarkVolumeAsAttachedByUniqueVolumeName failed", addVolumeNodeErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !volumeToMount.ReportedInUse {
0000000000000000000000000000000000000000;;				// If the given volume has not yet been added to the list of
0000000000000000000000000000000000000000;;				// VolumesInUse in the node's volume status, do not proceed, return
0000000000000000000000000000000000000000;;				// error. Caller will log and retry. The node status is updated
0000000000000000000000000000000000000000;;				// periodically by kubelet, so it may take as much as 10 seconds
0000000000000000000000000000000000000000;;				// before this clears.
0000000000000000000000000000000000000000;;				// Issue #28141 to enable on demand status updates.
0000000000000000000000000000000000000000;;				return volumeToMount.GenerateErrorDetailed("Volume has not been added to the list of VolumesInUse in the node's volume status", nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Fetch current node object
0000000000000000000000000000000000000000;;			node, fetchErr := og.kubeClient.Core().Nodes().Get(string(nodeName), metav1.GetOptions{})
0000000000000000000000000000000000000000;;			if fetchErr != nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return volumeToMount.GenerateErrorDetailed("VerifyControllerAttachedVolume failed fetching node from API server", fetchErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if node == nil {
0000000000000000000000000000000000000000;;				// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;				return volumeToMount.GenerateErrorDetailed(
0000000000000000000000000000000000000000;;					"VerifyControllerAttachedVolume failed",
0000000000000000000000000000000000000000;;					fmt.Errorf("Node object retrieved from API server is nil"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, attachedVolume := range node.Status.VolumesAttached {
0000000000000000000000000000000000000000;;				if attachedVolume.Name == volumeToMount.VolumeName {
0000000000000000000000000000000000000000;;					addVolumeNodeErr := actualStateOfWorld.MarkVolumeAsAttached(
0000000000000000000000000000000000000000;;						v1.UniqueVolumeName(""), volumeToMount.VolumeSpec, nodeName, attachedVolume.DevicePath)
0000000000000000000000000000000000000000;;					glog.Infof(volumeToMount.GenerateMsgDetailed("Controller attach succeeded", fmt.Sprintf("device path: %q", attachedVolume.DevicePath)))
0000000000000000000000000000000000000000;;					if addVolumeNodeErr != nil {
0000000000000000000000000000000000000000;;						// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;						return volumeToMount.GenerateErrorDetailed("VerifyControllerAttachedVolume.MarkVolumeAsAttached failed", addVolumeNodeErr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Volume not attached, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;			return volumeToMount.GenerateErrorDetailed("Volume not attached according to node status", nil)
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (og *operationGenerator) verifyVolumeIsSafeToDetach(
0000000000000000000000000000000000000000;;		volumeToDetach AttachedVolume) error {
0000000000000000000000000000000000000000;;		// Fetch current node object
0000000000000000000000000000000000000000;;		node, fetchErr := og.kubeClient.Core().Nodes().Get(string(volumeToDetach.NodeName), metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if fetchErr != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(fetchErr) {
0000000000000000000000000000000000000000;;				glog.Warningf(volumeToDetach.GenerateMsgDetailed("Node not found on API server. DetachVolume will skip safe to detach check", ""))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;			return volumeToDetach.GenerateErrorDetailed("DetachVolume failed fetching node from API server", fetchErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if node == nil {
0000000000000000000000000000000000000000;;			// On failure, return error. Caller will log and retry.
0000000000000000000000000000000000000000;;			return volumeToDetach.GenerateErrorDetailed(
0000000000000000000000000000000000000000;;				"DetachVolume failed fetching node from API server",
0000000000000000000000000000000000000000;;				fmt.Errorf("node object retrieved from API server is nil"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, inUseVolume := range node.Status.VolumesInUse {
0000000000000000000000000000000000000000;;			if inUseVolume == volumeToDetach.VolumeName {
0000000000000000000000000000000000000000;;				return volumeToDetach.GenerateErrorDetailed(
0000000000000000000000000000000000000000;;					"DetachVolume failed",
0000000000000000000000000000000000000000;;					fmt.Errorf("volume is still in use by node, according to Node status"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Volume is not marked as in use by node
0000000000000000000000000000000000000000;;		glog.Infof(volumeToDetach.GenerateMsgDetailed("Verified volume is safe to detach", ""))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkMountOptionSupport(og *operationGenerator, volumeToMount VolumeToMount, plugin volume.VolumePlugin) error {
0000000000000000000000000000000000000000;;		mountOptions := volume.MountOptionFromSpec(volumeToMount.VolumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(mountOptions) > 0 && !plugin.SupportsMountOption() {
0000000000000000000000000000000000000000;;			eventErr, detailedErr := volumeToMount.GenerateError("Mount options are not supported for this volume type", nil)
0000000000000000000000000000000000000000;;			og.recorder.Eventf(volumeToMount.Pod, v1.EventTypeWarning, kevents.UnsupportedMountOption, eventErr.Error())
0000000000000000000000000000000000000000;;			return detailedErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkNodeAffinity looks at the PV node affinity, and checks if the node has the same corresponding labels
0000000000000000000000000000000000000000;;	// This ensures that we don't mount a volume that doesn't belong to this node
0000000000000000000000000000000000000000;;	func checkNodeAffinity(og *operationGenerator, volumeToMount VolumeToMount, plugin volume.VolumePlugin) error {
0000000000000000000000000000000000000000;;		if !utilfeature.DefaultFeatureGate.Enabled(features.PersistentLocalVolumes) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := volumeToMount.VolumeSpec.PersistentVolume
0000000000000000000000000000000000000000;;		if pv != nil {
0000000000000000000000000000000000000000;;			nodeLabels, err := og.volumePluginMgr.Host.GetNodeLabels()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return volumeToMount.GenerateErrorDetailed("Error getting node labels", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = util.CheckNodeAffinity(pv, nodeLabels)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				eventErr, detailedErr := volumeToMount.GenerateError("Storage node affinity check failed", err)
0000000000000000000000000000000000000000;;				og.recorder.Eventf(volumeToMount.Pod, v1.EventTypeWarning, kevents.FailedMountVolume, eventErr.Error())
0000000000000000000000000000000000000000;;				return detailedErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
