0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
4ea547924ffa8e58c373a4ae21e621ec66ca9caa;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/helper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nodeLabels map[string]string = map[string]string{
0000000000000000000000000000000000000000;;		"test-key1": "test-value1",
0000000000000000000000000000000000000000;;		"test-key2": "test-value2",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCheckNodeAffinity(t *testing.T) {
0000000000000000000000000000000000000000;;		type affinityTest struct {
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;			expectSuccess bool
0000000000000000000000000000000000000000;;			pv            *v1.PersistentVolume
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cases := []affinityTest{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "valid-no-constraints",
0000000000000000000000000000000000000000;;				expectSuccess: true,
0000000000000000000000000000000000000000;;				pv:            testVolumeWithNodeAffinity(t, &v1.NodeAffinity{}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "valid-constraints",
0000000000000000000000000000000000000000;;				expectSuccess: true,
0000000000000000000000000000000000000000;;				pv: testVolumeWithNodeAffinity(t, &v1.NodeAffinity{
0000000000000000000000000000000000000000;;					RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;						NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "test-key1",
0000000000000000000000000000000000000000;;										Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"test-value1", "test-value3"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "test-key2",
0000000000000000000000000000000000000000;;										Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"test-value0", "test-value2"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "invalid-key",
0000000000000000000000000000000000000000;;				expectSuccess: false,
0000000000000000000000000000000000000000;;				pv: testVolumeWithNodeAffinity(t, &v1.NodeAffinity{
0000000000000000000000000000000000000000;;					RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;						NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "test-key1",
0000000000000000000000000000000000000000;;										Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"test-value1", "test-value3"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "test-key3",
0000000000000000000000000000000000000000;;										Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"test-value0", "test-value2"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "invalid-values",
0000000000000000000000000000000000000000;;				expectSuccess: false,
0000000000000000000000000000000000000000;;				pv: testVolumeWithNodeAffinity(t, &v1.NodeAffinity{
0000000000000000000000000000000000000000;;					RequiredDuringSchedulingIgnoredDuringExecution: &v1.NodeSelector{
0000000000000000000000000000000000000000;;						NodeSelectorTerms: []v1.NodeSelectorTerm{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								MatchExpressions: []v1.NodeSelectorRequirement{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "test-key1",
0000000000000000000000000000000000000000;;										Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"test-value3", "test-value4"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Key:      "test-key2",
0000000000000000000000000000000000000000;;										Operator: v1.NodeSelectorOpIn,
0000000000000000000000000000000000000000;;										Values:   []string{"test-value0", "test-value2"},
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range cases {
0000000000000000000000000000000000000000;;			err := CheckNodeAffinity(c.pv, nodeLabels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil && c.expectSuccess {
0000000000000000000000000000000000000000;;				t.Errorf("CheckTopology %v returned error: %v", c.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && !c.expectSuccess {
0000000000000000000000000000000000000000;;				t.Errorf("CheckTopology %v returned success, expected error", c.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testVolumeWithNodeAffinity(t *testing.T, affinity *v1.NodeAffinity) *v1.PersistentVolume {
0000000000000000000000000000000000000000;;		objMeta := metav1.ObjectMeta{Name: "test-constraints"}
0000000000000000000000000000000000000000;;		objMeta.Annotations = map[string]string{}
0000000000000000000000000000000000000000;;		err := helper.StorageNodeAffinityToAlphaAnnotation(objMeta.Annotations, affinity)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to get node affinity annotation: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: objMeta,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLoadPodFromFile(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			content     string
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"yaml",
0000000000000000000000000000000000000000;;				`
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Pod
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: testpod
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  containers:
0000000000000000000000000000000000000000;;	    - image: gcr.io/google_containers/busybox
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"json",
0000000000000000000000000000000000000000;;				`
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "apiVersion": "v1",
0000000000000000000000000000000000000000;;	  "kind": "Pod",
0000000000000000000000000000000000000000;;	  "metadata": {
0000000000000000000000000000000000000000;;	    "name": "testpod"
0000000000000000000000000000000000000000;;	  },
0000000000000000000000000000000000000000;;	  "spec": {
0000000000000000000000000000000000000000;;	    "containers": [
0000000000000000000000000000000000000000;;	      {
0000000000000000000000000000000000000000;;	        "image": "gcr.io/google_containers/busybox"
0000000000000000000000000000000000000000;;	      }
0000000000000000000000000000000000000000;;	    ]
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}`,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid pod",
0000000000000000000000000000000000000000;;				`
0000000000000000000000000000000000000000;;	apiVersion: v1
0000000000000000000000000000000000000000;;	kind: Pod
0000000000000000000000000000000000000000;;	metadata:
0000000000000000000000000000000000000000;;	  name: testpod
0000000000000000000000000000000000000000;;	spec:
0000000000000000000000000000000000000000;;	  - image: gcr.io/google_containers/busybox
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			tempFile, err := ioutil.TempFile("", "podfile")
0000000000000000000000000000000000000000;;			defer os.Remove(tempFile.Name())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("cannot create temporary file: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err = tempFile.Write([]byte(test.content)); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("cannot save temporary file: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = tempFile.Close(); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("cannot close temporary file: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pod, err := LoadPodFromFile(tempFile.Name())
0000000000000000000000000000000000000000;;			if test.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("test %q expected error, got nil", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// no error expected
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("error loading pod %q: %v", test.name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pod == nil {
0000000000000000000000000000000000000000;;					t.Errorf("test %q expected pod, got nil", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
