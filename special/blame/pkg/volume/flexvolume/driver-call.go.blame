0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
55a060605d4a93287e12e6723af29d654010ffcb;pkg/volume/flexvolume/flexvolume_util.go[pkg/volume/flexvolume/flexvolume_util.go][pkg/volume/flexvolume/driver-call.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flexvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Driver calls
0000000000000000000000000000000000000000;;		initCmd          = "init"
0000000000000000000000000000000000000000;;		getVolumeNameCmd = "getvolumename"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isAttached = "isattached"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachCmd        = "attach"
0000000000000000000000000000000000000000;;		waitForAttachCmd = "waitforattach"
0000000000000000000000000000000000000000;;		mountDeviceCmd   = "mountdevice"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		detachCmd        = "detach"
0000000000000000000000000000000000000000;;		waitForDetachCmd = "waitfordetach"
0000000000000000000000000000000000000000;;		unmountDeviceCmd = "unmountdevice"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountCmd   = "mount"
0000000000000000000000000000000000000000;;		unmountCmd = "unmount"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Option keys
0000000000000000000000000000000000000000;;		optionFSType         = "kubernetes.io/fsType"
0000000000000000000000000000000000000000;;		optionReadWrite      = "kubernetes.io/readwrite"
0000000000000000000000000000000000000000;;		optionKeySecret      = "kubernetes.io/secret"
0000000000000000000000000000000000000000;;		optionFSGroup        = "kubernetes.io/fsGroup"
0000000000000000000000000000000000000000;;		optionMountsDir      = "kubernetes.io/mountsDir"
0000000000000000000000000000000000000000;;		optionPVorVolumeName = "kubernetes.io/pvOrVolumeName"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optionKeyPodName      = "kubernetes.io/pod.name"
0000000000000000000000000000000000000000;;		optionKeyPodNamespace = "kubernetes.io/pod.namespace"
0000000000000000000000000000000000000000;;		optionKeyPodUID       = "kubernetes.io/pod.uid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optionKeyServiceAccountName = "kubernetes.io/serviceAccount.name"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachCapability = "attach"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// StatusSuccess represents the successful completion of command.
0000000000000000000000000000000000000000;;		StatusSuccess = "Success"
0000000000000000000000000000000000000000;;		// StatusNotSupported represents that the command is not supported.
0000000000000000000000000000000000000000;;		StatusNotSupported = "Not supported"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		TimeoutError = fmt.Errorf("Timeout")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DriverCall implements the basic contract between FlexVolume and its driver.
0000000000000000000000000000000000000000;;	// The caller is responsible for providing the required args.
0000000000000000000000000000000000000000;;	type DriverCall struct {
0000000000000000000000000000000000000000;;		Command string
0000000000000000000000000000000000000000;;		Timeout time.Duration
0000000000000000000000000000000000000000;;		plugin  *flexVolumePlugin
0000000000000000000000000000000000000000;;		args    []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) NewDriverCall(command string) *DriverCall {
0000000000000000000000000000000000000000;;		return plugin.NewDriverCallWithTimeout(command, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) NewDriverCallWithTimeout(command string, timeout time.Duration) *DriverCall {
0000000000000000000000000000000000000000;;		return &DriverCall{
0000000000000000000000000000000000000000;;			Command: command,
0000000000000000000000000000000000000000;;			Timeout: timeout,
0000000000000000000000000000000000000000;;			plugin:  plugin,
0000000000000000000000000000000000000000;;			args:    []string{command},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DriverCall) Append(arg string) {
0000000000000000000000000000000000000000;;		dc.args = append(dc.args, arg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DriverCall) AppendSpec(spec *volume.Spec, host volume.VolumeHost, extraOptions map[string]string) error {
0000000000000000000000000000000000000000;;		optionsForDriver, err := NewOptionsForDriver(spec, host, extraOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonBytes, err := json.Marshal(optionsForDriver)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to marshal spec, error: %s", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc.Append(string(jsonBytes))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *DriverCall) Run() (*DriverStatus, error) {
0000000000000000000000000000000000000000;;		if dc.plugin.isUnsupported(dc.Command) {
0000000000000000000000000000000000000000;;			return nil, errors.New(StatusNotSupported)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		execPath := dc.plugin.getExecutable()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := dc.plugin.runner.Command(execPath, dc.args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeout := false
0000000000000000000000000000000000000000;;		if dc.Timeout > 0 {
0000000000000000000000000000000000000000;;			timer := time.AfterFunc(dc.Timeout, func() {
0000000000000000000000000000000000000000;;				timeout = true
0000000000000000000000000000000000000000;;				cmd.Stop()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			defer timer.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output, execErr := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;		if execErr != nil {
0000000000000000000000000000000000000000;;			if timeout {
0000000000000000000000000000000000000000;;				return nil, TimeoutError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := handleCmdResponse(dc.Command, output)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				glog.Errorf("FlexVolume: driver bug: %s: exec error (%s) but no error in response.", execPath, execErr)
0000000000000000000000000000000000000000;;				return nil, execErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isCmdNotSupportedErr(err) {
0000000000000000000000000000000000000000;;				dc.plugin.unsupported(dc.Command)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Warningf("FlexVolume: driver call failed: executable: %s, args: %s, error: %s, output: %s", execPath, dc.args, execErr.Error(), output)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status, err := handleCmdResponse(dc.Command, output)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isCmdNotSupportedErr(err) {
0000000000000000000000000000000000000000;;				dc.plugin.unsupported(dc.Command)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OptionsForDriver represents the spec given to the driver.
0000000000000000000000000000000000000000;;	type OptionsForDriver map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOptionsForDriver(spec *volume.Spec, host volume.VolumeHost, extraOptions map[string]string) (OptionsForDriver, error) {
0000000000000000000000000000000000000000;;		volSource, readOnly := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		options := map[string]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options[optionFSType] = volSource.FSType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if readOnly {
0000000000000000000000000000000000000000;;			options[optionReadWrite] = "ro"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			options[optionReadWrite] = "rw"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options[optionPVorVolumeName] = spec.Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range extraOptions {
0000000000000000000000000000000000000000;;			options[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range volSource.Options {
0000000000000000000000000000000000000000;;			options[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return OptionsForDriver(options), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DriverStatus represents the return value of the driver callout.
0000000000000000000000000000000000000000;;	type DriverStatus struct {
0000000000000000000000000000000000000000;;		// Status of the callout. One of "Success", "Failure" or "Not supported".
0000000000000000000000000000000000000000;;		Status string `json:"status"`
0000000000000000000000000000000000000000;;		// Reason for success/failure.
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty"`
0000000000000000000000000000000000000000;;		// Path to the device attached. This field is valid only for attach calls.
0000000000000000000000000000000000000000;;		// ie: /dev/sdx
0000000000000000000000000000000000000000;;		DevicePath string `json:"device,omitempty"`
0000000000000000000000000000000000000000;;		// Cluster wide unique name of the volume.
0000000000000000000000000000000000000000;;		VolumeName string `json:"volumeName,omitempty"`
0000000000000000000000000000000000000000;;		// Represents volume is attached on the node
0000000000000000000000000000000000000000;;		Attached bool `json:"attached,omitempty"`
0000000000000000000000000000000000000000;;		// Returns capabilities of the driver.
0000000000000000000000000000000000000000;;		// By default we assume all the capabilities are supported.
0000000000000000000000000000000000000000;;		// If the plugin does not support a capability, it can return false for that capability.
0000000000000000000000000000000000000000;;		Capabilities map[string]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isCmdNotSupportedErr checks if the error corresponds to command not supported by
0000000000000000000000000000000000000000;;	// driver.
0000000000000000000000000000000000000000;;	func isCmdNotSupportedErr(err error) bool {
0000000000000000000000000000000000000000;;		if err != nil && err.Error() == StatusNotSupported {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleCmdResponse processes the command output and returns the appropriate
0000000000000000000000000000000000000000;;	// error code or message.
0000000000000000000000000000000000000000;;	func handleCmdResponse(cmd string, output []byte) (*DriverStatus, error) {
0000000000000000000000000000000000000000;;		var status DriverStatus
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(output, &status); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to unmarshal output for command: %s, output: %s, error: %s", cmd, string(output), err.Error())
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if status.Status == StatusNotSupported {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("%s command is not supported by the driver", cmd)
0000000000000000000000000000000000000000;;			return nil, errors.New(status.Status)
0000000000000000000000000000000000000000;;		} else if status.Status != StatusSuccess {
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("%s command failed, status: %s, reason: %s", cmd, status.Status, status.Message)
0000000000000000000000000000000000000000;;			glog.Errorf(errMsg)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s", errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &status, nil
0000000000000000000000000000000000000000;;	}
