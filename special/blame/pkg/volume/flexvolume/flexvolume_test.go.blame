0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
55a060605d4a93287e12e6723af29d654010ffcb;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flexvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const execScriptTempl1 = `#!/bin/bash
0000000000000000000000000000000000000000;;	if [ "$1" == "init" -a $# -eq 1 ]; then
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	PATH=$2
0000000000000000000000000000000000000000;;	if [ "$1" == "attach" -a $# -eq 2 ]; then
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "device": "{{.DevicePath}}",
0000000000000000000000000000000000000000;;	    "status": "Success"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	elif [ "$1" == "detach" -a $# -eq 2 ]; then
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	elif [ "$1" == "getvolumename" -a $# -eq 4 ]; then
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success",
0000000000000000000000000000000000000000;;	    "volume": "fakevolume"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	elif [ "$1" == "isattached" -a $# -eq 2 ]; then
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success",
0000000000000000000000000000000000000000;;	    "attached": true
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo -n '{
0000000000000000000000000000000000000000;;	  "status": "Not supported"
0000000000000000000000000000000000000000;;	}'
0000000000000000000000000000000000000000;;	exit 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Direct the arguments to a file to be tested against later
0000000000000000000000000000000000000000;;	echo -n $@ &> {{.OutputFile}}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const execScriptTempl2 = `#!/bin/bash
0000000000000000000000000000000000000000;;	if [ "$1" == "init" -a $# -eq 1 ]; then
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	if [ "$1" == "getvolumename" -a $# -eq 2 ]; then
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success",
0000000000000000000000000000000000000000;;	    "volumeName": "fakevolume"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	elif [ "$1" == "mount" -a $# -eq 4 ]; then
0000000000000000000000000000000000000000;;	  PATH=$2
0000000000000000000000000000000000000000;;	  /bin/mkdir -p $PATH
0000000000000000000000000000000000000000;;	  if [ $? -ne 0 ]; then
0000000000000000000000000000000000000000;;	    echo -n '{
0000000000000000000000000000000000000000;;	      "status": "Failure",
0000000000000000000000000000000000000000;;	      "reason": "Failed to create $PATH"
0000000000000000000000000000000000000000;;	    }'
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	elif [ "$1" == "unmount" -a $# -eq 2 ]; then
0000000000000000000000000000000000000000;;	  PATH=$2
0000000000000000000000000000000000000000;;	  /bin/rm -r $PATH
0000000000000000000000000000000000000000;;	  if [ $? -ne 0 ]; then
0000000000000000000000000000000000000000;;	    echo -n '{
0000000000000000000000000000000000000000;;	      "status": "Failure",
0000000000000000000000000000000000000000;;	      "reason": "Failed to cleanup $PATH"
0000000000000000000000000000000000000000;;	    }'
0000000000000000000000000000000000000000;;	    exit 1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  echo -n '{
0000000000000000000000000000000000000000;;	    "status": "Success"
0000000000000000000000000000000000000000;;	  }'
0000000000000000000000000000000000000000;;	  exit 0
0000000000000000000000000000000000000000;;	fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo -n '{
0000000000000000000000000000000000000000;;	  "status": "Not Supported"
0000000000000000000000000000000000000000;;	}'
0000000000000000000000000000000000000000;;	exit 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Direct the arguments to a file to be tested against later
0000000000000000000000000000000000000000;;	echo -n $@ &> {{.OutputFile}}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func installPluginUnderTest(t *testing.T, vendorName, plugName, tmpDir string, execScriptTempl string, execTemplateData *map[string]interface{}) {
0000000000000000000000000000000000000000;;		vendoredName := plugName
0000000000000000000000000000000000000000;;		if vendorName != "" {
0000000000000000000000000000000000000000;;			vendoredName = fmt.Sprintf("%s~%s", vendorName, plugName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pluginDir := path.Join(tmpDir, vendoredName)
0000000000000000000000000000000000000000;;		err := os.MkdirAll(pluginDir, 0777)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to create plugin: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pluginExec := path.Join(pluginDir, plugName)
0000000000000000000000000000000000000000;;		f, err := os.Create(pluginExec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to install plugin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = f.Chmod(0777)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to set exec perms on plugin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if execTemplateData == nil {
0000000000000000000000000000000000000000;;			execTemplateData = &map[string]interface{}{
0000000000000000000000000000000000000000;;				"DevicePath": "/dev/sdx",
0000000000000000000000000000000000000000;;				"OutputFile": path.Join(pluginDir, plugName+".out"),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tObj := template.Must(template.New("test").Parse(execScriptTempl))
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := tObj.Execute(buf, *execTemplateData); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error in executing script template - %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		execScript := buf.String()
0000000000000000000000000000000000000000;;		_, err = f.WriteString(execScript)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to write plugin exec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("flexvolume_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		installPluginUnderTest(t, "kubernetes.io", "fakeAttacher", tmpDir, execScriptTempl1, nil)
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(tmpDir), volumetest.NewFakeVolumeHost("fake", nil, nil))
0000000000000000000000000000000000000000;;		plugin, err := plugMgr.FindPluginByName("flexvolume-kubernetes.io/fakeAttacher")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plugin.GetPluginName() != "flexvolume-kubernetes.io/fakeAttacher" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plugin.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plugin.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{FlexVolume: &v1.FlexVolumeSource{Driver: "kubernetes.io/fakeAttacher"}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plugin.CanSupport(&volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{FlexVolume: &v1.FlexVolumeSource{Driver: "kubernetes.io/fakeAttacher"}}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plugin.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("flexvolume_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		installPluginUnderTest(t, "kubernetes.io", "fakeAttacher", tmpDir, execScriptTempl1, nil)
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(tmpDir), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin, err := plugMgr.FindPersistentPluginByName("flexvolume-kubernetes.io/fakeAttacher")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !contains(plugin.GetAccessModes(), v1.ReadWriteOnce) || !contains(plugin.GetAccessModes(), v1.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected two AccessModeTypes:  %s and %s", v1.ReadWriteOnce, v1.ReadOnlyMany)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(modes []v1.PersistentVolumeAccessMode, mode v1.PersistentVolumeAccessMode) bool {
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if m == mode {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
