0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d39110bb2b28931dd0cbaf34c6c9b8f568dc9e56;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flexvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		api "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const flexVolumePluginName = "kubernetes.io/flexvolume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlexVolumePlugin object.
0000000000000000000000000000000000000000;;	type flexVolumePlugin struct {
0000000000000000000000000000000000000000;;		driverName string
0000000000000000000000000000000000000000;;		execPath   string
0000000000000000000000000000000000000000;;		host       volume.VolumeHost
0000000000000000000000000000000000000000;;		runner     exec.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		unsupportedCommands []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flexVolumeAttachablePlugin struct {
0000000000000000000000000000000000000000;;		*flexVolumePlugin
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.AttachableVolumePlugin = &flexVolumeAttachablePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &flexVolumePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFlexVolumePlugin(pluginDir, name string) (volume.VolumePlugin, error) {
0000000000000000000000000000000000000000;;		execPath := path.Join(pluginDir, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		driverName := utilstrings.UnescapePluginName(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flexPlugin := &flexVolumePlugin{
0000000000000000000000000000000000000000;;			driverName:          driverName,
0000000000000000000000000000000000000000;;			execPath:            execPath,
0000000000000000000000000000000000000000;;			runner:              exec.New(),
0000000000000000000000000000000000000000;;			unsupportedCommands: []string{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check whether the plugin is attachable.
0000000000000000000000000000000000000000;;		ok, err := isAttachable(flexPlugin)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			// Plugin supports attach/detach, so return flexVolumeAttachablePlugin
0000000000000000000000000000000000000000;;			return &flexVolumeAttachablePlugin{flexVolumePlugin: flexPlugin}, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return flexPlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isAttachable(plugin *flexVolumePlugin) (bool, error) {
0000000000000000000000000000000000000000;;		call := plugin.NewDriverCall(initCmd)
0000000000000000000000000000000000000000;;		res, err := call.Run()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// By default all plugins are attachable, unless they report otherwise.
0000000000000000000000000000000000000000;;		cap, ok := res.Capabilities[attachCapability]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			// cap is false, so plugin does not support attach/detach calls.
0000000000000000000000000000000000000000;;			return cap, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init is part of the volume.VolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		// call the init script
0000000000000000000000000000000000000000;;		call := plugin.NewDriverCall(initCmd)
0000000000000000000000000000000000000000;;		_, err := call.Run()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) getExecutable() string {
0000000000000000000000000000000000000000;;		parts := strings.Split(plugin.driverName, "/")
0000000000000000000000000000000000000000;;		execName := parts[len(parts)-1]
0000000000000000000000000000000000000000;;		return path.Join(plugin.execPath, execName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name is part of the volume.VolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return "flexvolume-" + plugin.driverName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetVolumeName is part of the volume.VolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		call := plugin.NewDriverCall(getVolumeNameCmd)
0000000000000000000000000000000000000000;;		call.AppendSpec(spec, plugin.host, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := call.Run()
0000000000000000000000000000000000000000;;		if isCmdNotSupportedErr(err) {
0000000000000000000000000000000000000000;;			return (*pluginDefaults)(plugin).GetVolumeName(spec)
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name, err := (*pluginDefaults)(plugin).GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Warning(logPrefix(plugin), "GetVolumeName is not supported yet. Defaulting to PV or volume name: ", name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanSupport is part of the volume.VolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		source, _ := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		return (source != nil) && (source.Driver == plugin.driverName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequiresRemount is part of the volume.VolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAccessModes gets the allowed access modes for this plugin.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) GetAccessModes() []api.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []api.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			api.ReadWriteOnce,
0000000000000000000000000000000000000000;;			api.ReadOnlyMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMounter is part of the volume.VolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) NewMounter(spec *volume.Spec, pod *api.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod, plugin.host.GetMounter(), plugin.runner)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newMounterInternal is the internal mounter routine to build the volume.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) newMounterInternal(spec *volume.Spec, pod *api.Pod, mounter mount.Interface, runner exec.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		source, readOnly := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		return &flexVolumeMounter{
0000000000000000000000000000000000000000;;			flexVolume: &flexVolume{
0000000000000000000000000000000000000000;;				driverName:            source.Driver,
0000000000000000000000000000000000000000;;				execPath:              plugin.getExecutable(),
0000000000000000000000000000000000000000;;				mounter:               mounter,
0000000000000000000000000000000000000000;;				plugin:                plugin,
0000000000000000000000000000000000000000;;				podName:               pod.Name,
0000000000000000000000000000000000000000;;				podUID:                pod.UID,
0000000000000000000000000000000000000000;;				podNamespace:          pod.Namespace,
0000000000000000000000000000000000000000;;				podServiceAccountName: pod.Spec.ServiceAccountName,
0000000000000000000000000000000000000000;;				volName:               spec.Name(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			runner:             runner,
0000000000000000000000000000000000000000;;			spec:               spec,
0000000000000000000000000000000000000000;;			readOnly:           readOnly,
0000000000000000000000000000000000000000;;			blockDeviceMounter: &mount.SafeFormatAndMount{Interface: mounter, Runner: runner},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnmounter is part of the volume.VolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, plugin.host.GetMounter(), plugin.runner)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newUnmounterInternal is the internal unmounter routine to clean the volume.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) newUnmounterInternal(volName string, podUID types.UID, mounter mount.Interface, runner exec.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &flexVolumeUnmounter{
0000000000000000000000000000000000000000;;			flexVolume: &flexVolume{
0000000000000000000000000000000000000000;;				driverName: plugin.driverName,
0000000000000000000000000000000000000000;;				execPath:   plugin.getExecutable(),
0000000000000000000000000000000000000000;;				mounter:    mounter,
0000000000000000000000000000000000000000;;				plugin:     plugin,
0000000000000000000000000000000000000000;;				podUID:     podUID,
0000000000000000000000000000000000000000;;				volName:    volName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			runner: runner,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAttacher is part of the volume.AttachableVolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumeAttachablePlugin) NewAttacher() (volume.Attacher, error) {
0000000000000000000000000000000000000000;;		return &flexVolumeAttacher{plugin}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDetacher is part of the volume.AttachableVolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumeAttachablePlugin) NewDetacher() (volume.Detacher, error) {
0000000000000000000000000000000000000000;;		return &flexVolumeDetacher{plugin}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConstructVolumeSpec is part of the volume.AttachableVolumePlugin interface.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		flexVolume := &api.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;				FlexVolume: &api.FlexVolumeSource{
0000000000000000000000000000000000000000;;					Driver: plugin.driverName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(flexVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mark the given commands as unsupported.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) unsupported(commands ...string) {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		plugin.unsupportedCommands = append(plugin.unsupportedCommands, commands...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true iff the given command is known to be unsupported.
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) isUnsupported(command string) bool {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		for _, unsupportedCommand := range plugin.unsupportedCommands {
0000000000000000000000000000000000000000;;			if command == unsupportedCommand {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		return mount.GetMountRefs(mounter, deviceMountPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flexVolumePlugin) getDeviceMountPath(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("GetVolumeName failed from getDeviceMountPath: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountsDir := path.Join(plugin.host.GetPluginDir(flexVolumePluginName), plugin.driverName, "mounts")
0000000000000000000000000000000000000000;;		return path.Join(mountsDir, volumeName), nil
0000000000000000000000000000000000000000;;	}
