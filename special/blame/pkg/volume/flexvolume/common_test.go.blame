0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d39110bb2b28931dd0cbaf34c6c9b8f568dc9e56;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flexvolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetesting "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testPlugin() (*flexVolumeAttachablePlugin, string) {
0000000000000000000000000000000000000000;;		rootDir, err := utiltesting.MkTmpdir("flexvolume_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("error creating temp dir: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &flexVolumeAttachablePlugin{
0000000000000000000000000000000000000000;;			flexVolumePlugin: &flexVolumePlugin{
0000000000000000000000000000000000000000;;				driverName:          "test",
0000000000000000000000000000000000000000;;				execPath:            "/plugin",
0000000000000000000000000000000000000000;;				host:                volumetesting.NewFakeVolumeHost(rootDir, nil, nil),
0000000000000000000000000000000000000000;;				unsupportedCommands: []string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, rootDir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assertDriverCall(t *testing.T, output exec.FakeCombinedOutputAction, expectedCommand string, expectedArgs ...string) exec.FakeCommandAction {
0000000000000000000000000000000000000000;;		return func(cmd string, args ...string) exec.Cmd {
0000000000000000000000000000000000000000;;			if cmd != "/plugin/test" {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong executable called: got %v, expected %v", cmd, "/plugin/test")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if args[0] != expectedCommand {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong command called: got %v, expected %v", args[0], expectedCommand)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmdArgs := args[1:]
0000000000000000000000000000000000000000;;			if !sameArgs(cmdArgs, expectedArgs) {
0000000000000000000000000000000000000000;;				t.Errorf("Wrong args for %s: got %v, expected %v", args[0], cmdArgs, expectedArgs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &exec.FakeCmd{
0000000000000000000000000000000000000000;;				Argv:                 args,
0000000000000000000000000000000000000000;;				CombinedOutputScript: []exec.FakeCombinedOutputAction{output},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeRunner(fakeCommands ...exec.FakeCommandAction) exec.Interface {
0000000000000000000000000000000000000000;;		return &exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: fakeCommands,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeResultOutput(result interface{}) exec.FakeCombinedOutputAction {
0000000000000000000000000000000000000000;;		return func() ([]byte, error) {
0000000000000000000000000000000000000000;;			bytes, err := json.Marshal(result)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic("Unable to marshal result: " + err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return bytes, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func successOutput() exec.FakeCombinedOutputAction {
0000000000000000000000000000000000000000;;		return fakeResultOutput(&DriverStatus{StatusSuccess, "", "", "", true, nil})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func notSupportedOutput() exec.FakeCombinedOutputAction {
0000000000000000000000000000000000000000;;		return fakeResultOutput(&DriverStatus{StatusNotSupported, "", "", "", false, nil})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sameArgs(args, expectedArgs []string) bool {
0000000000000000000000000000000000000000;;		if len(args) != len(expectedArgs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range args {
0000000000000000000000000000000000000000;;			if v != expectedArgs[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeVolumeSpec() *volume.Spec {
0000000000000000000000000000000000000000;;		vol := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: "vol1",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				FlexVolume: &v1.FlexVolumeSource{
0000000000000000000000000000000000000000;;					Driver:   "kubernetes.io/fakeAttacher",
0000000000000000000000000000000000000000;;					ReadOnly: false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(vol)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakePersistentVolumeSpec() *volume.Spec {
0000000000000000000000000000000000000000;;		vol := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "vol1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					FlexVolume: &v1.FlexVolumeSource{
0000000000000000000000000000000000000000;;						Driver:   "kubernetes.io/fakeAttacher",
0000000000000000000000000000000000000000;;						ReadOnly: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromPersistentVolume(vol, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func specJson(plugin *flexVolumeAttachablePlugin, spec *volume.Spec, extraOptions map[string]string) string {
0000000000000000000000000000000000000000;;		o, err := NewOptionsForDriver(spec, plugin.host, extraOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("Failed to convert spec: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bytes, err := json.Marshal(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("Unable to marshal result: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(bytes)
0000000000000000000000000000000000000000;;	}
