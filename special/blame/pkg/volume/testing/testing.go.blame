0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/testing.go[pkg/kubelet/volume/testing.go][pkg/volume/testing/testing.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/io"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		. "k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakeVolumeHost is useful for testing volume plugins.
0000000000000000000000000000000000000000;;	type fakeVolumeHost struct {
0000000000000000000000000000000000000000;;		rootDir    string
0000000000000000000000000000000000000000;;		kubeClient clientset.Interface
0000000000000000000000000000000000000000;;		pluginMgr  VolumePluginMgr
0000000000000000000000000000000000000000;;		cloud      cloudprovider.Interface
0000000000000000000000000000000000000000;;		mounter    mount.Interface
0000000000000000000000000000000000000000;;		writer     io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeVolumeHost(rootDir string, kubeClient clientset.Interface, plugins []VolumePlugin) *fakeVolumeHost {
0000000000000000000000000000000000000000;;		host := &fakeVolumeHost{rootDir: rootDir, kubeClient: kubeClient, cloud: nil}
0000000000000000000000000000000000000000;;		host.mounter = &mount.FakeMounter{}
0000000000000000000000000000000000000000;;		host.writer = &io.StdWriter{}
0000000000000000000000000000000000000000;;		host.pluginMgr.InitPlugins(plugins, host)
0000000000000000000000000000000000000000;;		return host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetPluginDir(podUID string) string {
0000000000000000000000000000000000000000;;		return path.Join(f.rootDir, "plugins", podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetPodVolumeDir(podUID types.UID, pluginName, volumeName string) string {
0000000000000000000000000000000000000000;;		return path.Join(f.rootDir, "pods", string(podUID), "volumes", pluginName, volumeName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetPodPluginDir(podUID types.UID, pluginName string) string {
0000000000000000000000000000000000000000;;		return path.Join(f.rootDir, "pods", string(podUID), "plugins", pluginName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetKubeClient() clientset.Interface {
0000000000000000000000000000000000000000;;		return f.kubeClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetCloudProvider() cloudprovider.Interface {
0000000000000000000000000000000000000000;;		return f.cloud
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetMounter() mount.Interface {
0000000000000000000000000000000000000000;;		return f.mounter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetWriter() io.Writer {
0000000000000000000000000000000000000000;;		return f.writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) NewWrapperMounter(volName string, spec Spec, pod *v1.Pod, opts VolumeOptions) (Mounter, error) {
0000000000000000000000000000000000000000;;		// The name of wrapper volume is set to "wrapped_{wrapped_volume_name}"
0000000000000000000000000000000000000000;;		wrapperVolumeName := "wrapped_" + volName
0000000000000000000000000000000000000000;;		if spec.Volume != nil {
0000000000000000000000000000000000000000;;			spec.Volume.Name = wrapperVolumeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plug, err := f.pluginMgr.FindPluginBySpec(&spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plug.NewMounter(&spec, pod, opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) NewWrapperUnmounter(volName string, spec Spec, podUID types.UID) (Unmounter, error) {
0000000000000000000000000000000000000000;;		// The name of wrapper volume is set to "wrapped_{wrapped_volume_name}"
0000000000000000000000000000000000000000;;		wrapperVolumeName := "wrapped_" + volName
0000000000000000000000000000000000000000;;		if spec.Volume != nil {
0000000000000000000000000000000000000000;;			spec.Volume.Name = wrapperVolumeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plug, err := f.pluginMgr.FindPluginBySpec(&spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plug.NewUnmounter(spec.Name(), podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the hostname of the host kubelet is running on
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetHostName() string {
0000000000000000000000000000000000000000;;		return "fakeHostName"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns host IP or nil in the case of error.
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetHostIP() (net.IP, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("GetHostIP() not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetNodeAllocatable() (v1.ResourceList, error) {
0000000000000000000000000000000000000000;;		return v1.ResourceList{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetSecretFunc() func(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;		return func(namespace, name string) (*v1.Secret, error) {
0000000000000000000000000000000000000000;;			return f.kubeClient.Core().Secrets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetConfigMapFunc() func(namespace, name string) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;		return func(namespace, name string) (*v1.ConfigMap, error) {
0000000000000000000000000000000000000000;;			return f.kubeClient.Core().ConfigMaps(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeVolumeHost) GetNodeLabels() (map[string]string, error) {
0000000000000000000000000000000000000000;;		return map[string]string{"test-label": "test-value"}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins(config VolumeConfig) []VolumePlugin {
0000000000000000000000000000000000000000;;		if _, ok := config.OtherAttributes["fake-property"]; ok {
0000000000000000000000000000000000000000;;			return []VolumePlugin{
0000000000000000000000000000000000000000;;				&FakeVolumePlugin{
0000000000000000000000000000000000000000;;					PluginName: "fake-plugin",
0000000000000000000000000000000000000000;;					Host:       nil,
0000000000000000000000000000000000000000;;					// SomeFakeProperty: config.OtherAttributes["fake-property"] -- string, may require parsing by plugin
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []VolumePlugin{&FakeVolumePlugin{PluginName: "fake-plugin"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeVolumePlugin is useful for testing.  It tries to be a fully compliant
0000000000000000000000000000000000000000;;	// plugin, but all it does is make empty directories.
0000000000000000000000000000000000000000;;	// Use as:
0000000000000000000000000000000000000000;;	//   volume.RegisterPlugin(&FakePlugin{"fake-name"})
0000000000000000000000000000000000000000;;	type FakeVolumePlugin struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		PluginName             string
0000000000000000000000000000000000000000;;		Host                   VolumeHost
0000000000000000000000000000000000000000;;		Config                 VolumeConfig
0000000000000000000000000000000000000000;;		LastProvisionerOptions VolumeOptions
0000000000000000000000000000000000000000;;		NewAttacherCallCount   int
0000000000000000000000000000000000000000;;		NewDetacherCallCount   int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Mounters   []*FakeVolume
0000000000000000000000000000000000000000;;		Unmounters []*FakeVolume
0000000000000000000000000000000000000000;;		Attachers  []*FakeVolume
0000000000000000000000000000000000000000;;		Detachers  []*FakeVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ VolumePlugin = &FakeVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ RecyclableVolumePlugin = &FakeVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ DeletableVolumePlugin = &FakeVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ ProvisionableVolumePlugin = &FakeVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ AttachableVolumePlugin = &FakeVolumePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) getFakeVolume(list *[]*FakeVolume) *FakeVolume {
0000000000000000000000000000000000000000;;		volume := &FakeVolume{}
0000000000000000000000000000000000000000;;		*list = append(*list, volume)
0000000000000000000000000000000000000000;;		return volume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) Init(host VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		plugin.Host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.PluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetVolumeName(spec *Spec) (string, error) {
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) CanSupport(spec *Spec) bool {
0000000000000000000000000000000000000000;;		// TODO: maybe pattern-match on spec.Name() to decide?
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) NewMounter(spec *Spec, pod *v1.Pod, opts VolumeOptions) (Mounter, error) {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		volume := plugin.getFakeVolume(&plugin.Mounters)
0000000000000000000000000000000000000000;;		volume.PodUID = pod.UID
0000000000000000000000000000000000000000;;		volume.VolName = spec.Name()
0000000000000000000000000000000000000000;;		volume.Plugin = plugin
0000000000000000000000000000000000000000;;		volume.MetricsNil = MetricsNil{}
0000000000000000000000000000000000000000;;		return volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetMounters() (Mounters []*FakeVolume) {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.Mounters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) NewUnmounter(volName string, podUID types.UID) (Unmounter, error) {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		volume := plugin.getFakeVolume(&plugin.Unmounters)
0000000000000000000000000000000000000000;;		volume.PodUID = podUID
0000000000000000000000000000000000000000;;		volume.VolName = volName
0000000000000000000000000000000000000000;;		volume.Plugin = plugin
0000000000000000000000000000000000000000;;		volume.MetricsNil = MetricsNil{}
0000000000000000000000000000000000000000;;		return volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetUnmounters() (Unmounters []*FakeVolume) {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.Unmounters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) NewAttacher() (Attacher, error) {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		plugin.NewAttacherCallCount = plugin.NewAttacherCallCount + 1
0000000000000000000000000000000000000000;;		return plugin.getFakeVolume(&plugin.Attachers), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetAttachers() (Attachers []*FakeVolume) {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.Attachers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetNewAttacherCallCount() int {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.NewAttacherCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) NewDetacher() (Detacher, error) {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		plugin.NewDetacherCallCount = plugin.NewDetacherCallCount + 1
0000000000000000000000000000000000000000;;		return plugin.getFakeVolume(&plugin.Detachers), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetDetachers() (Detachers []*FakeVolume) {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.Detachers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetNewDetacherCallCount() int {
0000000000000000000000000000000000000000;;		plugin.RLock()
0000000000000000000000000000000000000000;;		defer plugin.RUnlock()
0000000000000000000000000000000000000000;;		return plugin.NewDetacherCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) Recycle(pvName string, spec *Spec, eventRecorder RecycleEventRecorder) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) NewDeleter(spec *Spec) (Deleter, error) {
0000000000000000000000000000000000000000;;		return &FakeDeleter{"/attributesTransferredFromSpec", MetricsNil{}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) NewProvisioner(options VolumeOptions) (Provisioner, error) {
0000000000000000000000000000000000000000;;		plugin.Lock()
0000000000000000000000000000000000000000;;		defer plugin.Unlock()
0000000000000000000000000000000000000000;;		plugin.LastProvisionerOptions = options
0000000000000000000000000000000000000000;;		return &FakeProvisioner{options, plugin.Host}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) ConstructVolumeSpec(volumeName, mountPath string) (*Spec, error) {
0000000000000000000000000000000000000000;;		return &Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *FakeVolumePlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		return []string{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeVolume struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		PodUID  types.UID
0000000000000000000000000000000000000000;;		VolName string
0000000000000000000000000000000000000000;;		Plugin  *FakeVolumePlugin
0000000000000000000000000000000000000000;;		MetricsNil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SetUpCallCount              int
0000000000000000000000000000000000000000;;		TearDownCallCount           int
0000000000000000000000000000000000000000;;		AttachCallCount             int
0000000000000000000000000000000000000000;;		DetachCallCount             int
0000000000000000000000000000000000000000;;		WaitForAttachCallCount      int
0000000000000000000000000000000000000000;;		MountDeviceCallCount        int
0000000000000000000000000000000000000000;;		UnmountDeviceCallCount      int
0000000000000000000000000000000000000000;;		GetDeviceMountPathCallCount int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ *FakeVolume) GetAttributes() Attributes {
0000000000000000000000000000000000000000;;		return Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        false,
0000000000000000000000000000000000000000;;			Managed:         true,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.SetUpCallCount++
0000000000000000000000000000000000000000;;		return fv.SetUpAt(fv.getPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetSetUpCallCount() int {
0000000000000000000000000000000000000000;;		fv.RLock()
0000000000000000000000000000000000000000;;		defer fv.RUnlock()
0000000000000000000000000000000000000000;;		return fv.SetUpCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return os.MkdirAll(dir, 0750)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetPath() string {
0000000000000000000000000000000000000000;;		fv.RLock()
0000000000000000000000000000000000000000;;		defer fv.RUnlock()
0000000000000000000000000000000000000000;;		return fv.getPath()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) getPath() string {
0000000000000000000000000000000000000000;;		return path.Join(fv.Plugin.Host.GetPodVolumeDir(fv.PodUID, utilstrings.EscapeQualifiedNameForDisk(fv.Plugin.PluginName), fv.VolName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) TearDown() error {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.TearDownCallCount++
0000000000000000000000000000000000000000;;		return fv.TearDownAt(fv.getPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetTearDownCallCount() int {
0000000000000000000000000000000000000000;;		fv.RLock()
0000000000000000000000000000000000000000;;		defer fv.RUnlock()
0000000000000000000000000000000000000000;;		return fv.TearDownCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return os.RemoveAll(dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) Attach(spec *Spec, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.AttachCallCount++
0000000000000000000000000000000000000000;;		return "/dev/vdb-test", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetAttachCallCount() int {
0000000000000000000000000000000000000000;;		fv.RLock()
0000000000000000000000000000000000000000;;		defer fv.RUnlock()
0000000000000000000000000000000000000000;;		return fv.AttachCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) WaitForAttach(spec *Spec, devicePath string, spectimeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.WaitForAttachCallCount++
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetWaitForAttachCallCount() int {
0000000000000000000000000000000000000000;;		fv.RLock()
0000000000000000000000000000000000000000;;		defer fv.RUnlock()
0000000000000000000000000000000000000000;;		return fv.WaitForAttachCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetDeviceMountPath(spec *Spec) (string, error) {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.GetDeviceMountPathCallCount++
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) MountDevice(spec *Spec, devicePath string, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.MountDeviceCallCount++
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetMountDeviceCallCount() int {
0000000000000000000000000000000000000000;;		fv.RLock()
0000000000000000000000000000000000000000;;		defer fv.RUnlock()
0000000000000000000000000000000000000000;;		return fv.MountDeviceCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) Detach(deviceMountPath string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.DetachCallCount++
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) VolumesAreAttached(spec []*Spec, nodeName types.NodeName) (map[*Spec]bool, error) {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) GetDetachCallCount() int {
0000000000000000000000000000000000000000;;		fv.RLock()
0000000000000000000000000000000000000000;;		defer fv.RUnlock()
0000000000000000000000000000000000000000;;		return fv.DetachCallCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fv *FakeVolume) UnmountDevice(globalMountPath string) error {
0000000000000000000000000000000000000000;;		fv.Lock()
0000000000000000000000000000000000000000;;		defer fv.Unlock()
0000000000000000000000000000000000000000;;		fv.UnmountDeviceCallCount++
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeDeleter struct {
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fd *FakeDeleter) Delete() error {
0000000000000000000000000000000000000000;;		// nil is success, else error
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fd *FakeDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		return fd.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeProvisioner struct {
0000000000000000000000000000000000000000;;		Options VolumeOptions
0000000000000000000000000000000000000000;;		Host    VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fc *FakeProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		fullpath := fmt.Sprintf("/tmp/hostpath_pv/%s", uuid.NewUUID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: fc.Options.PVName,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeDynamicallyCreatedByKey: "fakeplugin-provisioner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: fc.Options.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				AccessModes:                   fc.Options.PVC.Spec.AccessModes,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): fc.Options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)],
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;						Path: fullpath,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindEmptyDirectoryUsageOnTmpfs finds the expected usage of an empty directory existing on
0000000000000000000000000000000000000000;;	// a tmpfs filesystem on this system.
0000000000000000000000000000000000000000;;	func FindEmptyDirectoryUsageOnTmpfs() (*resource.Quantity, error) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("metrics_du_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		out, err := exec.Command("nice", "-n", "19", "du", "-s", "-B", "1", tmpDir).CombinedOutput()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed command 'du' on %s with error %v", tmpDir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		used, err := resource.ParseQuantity(strings.Fields(string(out))[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to parse 'du' output %s due to error %v", out, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		used.Format = resource.BinarySI
0000000000000000000000000000000000000000;;		return &used, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyAttachCallCount ensures that at least one of the Attachers for this
0000000000000000000000000000000000000000;;	// plugin has the expectedAttachCallCount number of calls. Otherwise it returns
0000000000000000000000000000000000000000;;	// an error.
0000000000000000000000000000000000000000;;	func VerifyAttachCallCount(
0000000000000000000000000000000000000000;;		expectedAttachCallCount int,
0000000000000000000000000000000000000000;;		fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, attacher := range fakeVolumePlugin.GetAttachers() {
0000000000000000000000000000000000000000;;			actualCallCount := attacher.GetAttachCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount == expectedAttachCallCount {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf(
0000000000000000000000000000000000000000;;			"No attachers have expected AttachCallCount. Expected: <%v>.",
0000000000000000000000000000000000000000;;			expectedAttachCallCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyZeroAttachCalls ensures that all of the Attachers for this plugin have
0000000000000000000000000000000000000000;;	// a zero AttachCallCount. Otherwise it returns an error.
0000000000000000000000000000000000000000;;	func VerifyZeroAttachCalls(fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, attacher := range fakeVolumePlugin.GetAttachers() {
0000000000000000000000000000000000000000;;			actualCallCount := attacher.GetAttachCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"At least one attacher has non-zero AttachCallCount: <%v>.",
0000000000000000000000000000000000000000;;					actualCallCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyWaitForAttachCallCount ensures that at least one of the Mounters for
0000000000000000000000000000000000000000;;	// this plugin has the expectedWaitForAttachCallCount number of calls. Otherwise
0000000000000000000000000000000000000000;;	// it returns an error.
0000000000000000000000000000000000000000;;	func VerifyWaitForAttachCallCount(
0000000000000000000000000000000000000000;;		expectedWaitForAttachCallCount int,
0000000000000000000000000000000000000000;;		fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, attacher := range fakeVolumePlugin.GetAttachers() {
0000000000000000000000000000000000000000;;			actualCallCount := attacher.GetWaitForAttachCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount == expectedWaitForAttachCallCount {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf(
0000000000000000000000000000000000000000;;			"No Attachers have expected WaitForAttachCallCount. Expected: <%v>.",
0000000000000000000000000000000000000000;;			expectedWaitForAttachCallCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyZeroWaitForAttachCallCount ensures that all Attachers for this plugin
0000000000000000000000000000000000000000;;	// have a zero WaitForAttachCallCount. Otherwise it returns an error.
0000000000000000000000000000000000000000;;	func VerifyZeroWaitForAttachCallCount(fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, attacher := range fakeVolumePlugin.GetAttachers() {
0000000000000000000000000000000000000000;;			actualCallCount := attacher.GetWaitForAttachCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"At least one attacher has non-zero WaitForAttachCallCount: <%v>.",
0000000000000000000000000000000000000000;;					actualCallCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyMountDeviceCallCount ensures that at least one of the Mounters for
0000000000000000000000000000000000000000;;	// this plugin has the expectedMountDeviceCallCount number of calls. Otherwise
0000000000000000000000000000000000000000;;	// it returns an error.
0000000000000000000000000000000000000000;;	func VerifyMountDeviceCallCount(
0000000000000000000000000000000000000000;;		expectedMountDeviceCallCount int,
0000000000000000000000000000000000000000;;		fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, attacher := range fakeVolumePlugin.GetAttachers() {
0000000000000000000000000000000000000000;;			actualCallCount := attacher.GetMountDeviceCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount == expectedMountDeviceCallCount {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf(
0000000000000000000000000000000000000000;;			"No Attachers have expected MountDeviceCallCount. Expected: <%v>.",
0000000000000000000000000000000000000000;;			expectedMountDeviceCallCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyZeroMountDeviceCallCount ensures that all Attachers for this plugin
0000000000000000000000000000000000000000;;	// have a zero MountDeviceCallCount. Otherwise it returns an error.
0000000000000000000000000000000000000000;;	func VerifyZeroMountDeviceCallCount(fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, attacher := range fakeVolumePlugin.GetAttachers() {
0000000000000000000000000000000000000000;;			actualCallCount := attacher.GetMountDeviceCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"At least one attacher has non-zero MountDeviceCallCount: <%v>.",
0000000000000000000000000000000000000000;;					actualCallCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifySetUpCallCount ensures that at least one of the Mounters for this
0000000000000000000000000000000000000000;;	// plugin has the expectedSetUpCallCount number of calls. Otherwise it returns
0000000000000000000000000000000000000000;;	// an error.
0000000000000000000000000000000000000000;;	func VerifySetUpCallCount(
0000000000000000000000000000000000000000;;		expectedSetUpCallCount int,
0000000000000000000000000000000000000000;;		fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, mounter := range fakeVolumePlugin.GetMounters() {
0000000000000000000000000000000000000000;;			actualCallCount := mounter.GetSetUpCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount >= expectedSetUpCallCount {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf(
0000000000000000000000000000000000000000;;			"No Mounters have expected SetUpCallCount. Expected: <%v>.",
0000000000000000000000000000000000000000;;			expectedSetUpCallCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyZeroSetUpCallCount ensures that all Mounters for this plugin have a
0000000000000000000000000000000000000000;;	// zero SetUpCallCount. Otherwise it returns an error.
0000000000000000000000000000000000000000;;	func VerifyZeroSetUpCallCount(fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, mounter := range fakeVolumePlugin.GetMounters() {
0000000000000000000000000000000000000000;;			actualCallCount := mounter.GetSetUpCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"At least one mounter has non-zero SetUpCallCount: <%v>.",
0000000000000000000000000000000000000000;;					actualCallCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyTearDownCallCount ensures that at least one of the Unounters for this
0000000000000000000000000000000000000000;;	// plugin has the expectedTearDownCallCount number of calls. Otherwise it
0000000000000000000000000000000000000000;;	// returns an error.
0000000000000000000000000000000000000000;;	func VerifyTearDownCallCount(
0000000000000000000000000000000000000000;;		expectedTearDownCallCount int,
0000000000000000000000000000000000000000;;		fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, unmounter := range fakeVolumePlugin.GetUnmounters() {
0000000000000000000000000000000000000000;;			actualCallCount := unmounter.GetTearDownCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount >= expectedTearDownCallCount {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf(
0000000000000000000000000000000000000000;;			"No Unmounters have expected SetUpCallCount. Expected: <%v>.",
0000000000000000000000000000000000000000;;			expectedTearDownCallCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyZeroTearDownCallCount ensures that all Mounters for this plugin have a
0000000000000000000000000000000000000000;;	// zero TearDownCallCount. Otherwise it returns an error.
0000000000000000000000000000000000000000;;	func VerifyZeroTearDownCallCount(fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, mounter := range fakeVolumePlugin.GetMounters() {
0000000000000000000000000000000000000000;;			actualCallCount := mounter.GetTearDownCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"At least one mounter has non-zero TearDownCallCount: <%v>.",
0000000000000000000000000000000000000000;;					actualCallCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyDetachCallCount ensures that at least one of the Attachers for this
0000000000000000000000000000000000000000;;	// plugin has the expectedDetachCallCount number of calls. Otherwise it returns
0000000000000000000000000000000000000000;;	// an error.
0000000000000000000000000000000000000000;;	func VerifyDetachCallCount(
0000000000000000000000000000000000000000;;		expectedDetachCallCount int,
0000000000000000000000000000000000000000;;		fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, detacher := range fakeVolumePlugin.GetDetachers() {
0000000000000000000000000000000000000000;;			actualCallCount := detacher.GetDetachCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount == expectedDetachCallCount {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf(
0000000000000000000000000000000000000000;;			"No Detachers have expected DetachCallCount. Expected: <%v>.",
0000000000000000000000000000000000000000;;			expectedDetachCallCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyZeroDetachCallCount ensures that all Detachers for this plugin have a
0000000000000000000000000000000000000000;;	// zero DetachCallCount. Otherwise it returns an error.
0000000000000000000000000000000000000000;;	func VerifyZeroDetachCallCount(fakeVolumePlugin *FakeVolumePlugin) error {
0000000000000000000000000000000000000000;;		for _, detacher := range fakeVolumePlugin.GetDetachers() {
0000000000000000000000000000000000000000;;			actualCallCount := detacher.GetDetachCallCount()
0000000000000000000000000000000000000000;;			if actualCallCount != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"At least one detacher has non-zero DetachCallCount: <%v>.",
0000000000000000000000000000000000000000;;					actualCallCount)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTestVolumePluginMgr creates, initializes, and returns a test volume plugin
0000000000000000000000000000000000000000;;	// manager and fake volume plugin using a fake volume host.
0000000000000000000000000000000000000000;;	func GetTestVolumePluginMgr(
0000000000000000000000000000000000000000;;		t *testing.T) (*VolumePluginMgr, *FakeVolumePlugin) {
0000000000000000000000000000000000000000;;		v := NewFakeVolumeHost(
0000000000000000000000000000000000000000;;			"",  /* rootDir */
0000000000000000000000000000000000000000;;			nil, /* kubeClient */
0000000000000000000000000000000000000000;;			nil, /* plugins */
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		plugins := ProbeVolumePlugins(VolumeConfig{})
0000000000000000000000000000000000000000;;		if err := v.pluginMgr.InitPlugins(plugins, v); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v.pluginMgr, plugins[0].(*FakeVolumePlugin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateTestPVC returns a provisionable PVC for tests
0000000000000000000000000000000000000000;;	func CreateTestPVC(capacity string, accessModes []v1.PersistentVolumeAccessMode) *v1.PersistentVolumeClaim {
0000000000000000000000000000000000000000;;		claim := v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "dummy",
0000000000000000000000000000000000000000;;				Namespace: "default",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				AccessModes: accessModes,
0000000000000000000000000000000000000000;;				Resources: v1.ResourceRequirements{
0000000000000000000000000000000000000000;;					Requests: v1.ResourceList{
0000000000000000000000000000000000000000;;						v1.ResourceName(v1.ResourceStorage): resource.MustParse(capacity),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &claim
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MetricsEqualIgnoreTimestamp(a *Metrics, b *Metrics) bool {
0000000000000000000000000000000000000000;;		available := a.Available == b.Available
0000000000000000000000000000000000000000;;		capacity := a.Capacity == b.Capacity
0000000000000000000000000000000000000000;;		used := a.Used == b.Used
0000000000000000000000000000000000000000;;		inodes := a.Inodes == b.Inodes
0000000000000000000000000000000000000000;;		inodesFree := a.InodesFree == b.InodesFree
0000000000000000000000000000000000000000;;		inodesUsed := a.InodesUsed == b.InodesUsed
0000000000000000000000000000000000000000;;		return available && capacity && used && inodes && inodesFree && inodesUsed
0000000000000000000000000000000000000000;;	}
