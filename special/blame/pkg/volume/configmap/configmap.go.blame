0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
d6783a7a91225a89188ff5349f77808a1f0b1b41;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package configmap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		ioutil "k8s.io/kubernetes/pkg/util/io"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeVolumePlugin is the entry point for plugin detection in a package.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&configMapPlugin{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		configMapPluginName = "kubernetes.io/configmap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configMapPlugin implements the VolumePlugin interface.
0000000000000000000000000000000000000000;;	type configMapPlugin struct {
0000000000000000000000000000000000000000;;		host         volume.VolumeHost
0000000000000000000000000000000000000000;;		getConfigMap func(namespace, name string) (*v1.ConfigMap, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &configMapPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		plugin.getConfigMap = host.GetConfigMapFunc()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return configMapPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _ := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if volumeSource == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Spec does not reference a ConfigMap volume type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%v/%v",
0000000000000000000000000000000000000000;;			spec.Name(),
0000000000000000000000000000000000000000;;			volumeSource.Name), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return spec.Volume != nil && spec.Volume.ConfigMap != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return &configMapVolumeMounter{
0000000000000000000000000000000000000000;;			configMapVolume: &configMapVolume{
0000000000000000000000000000000000000000;;				spec.Name(),
0000000000000000000000000000000000000000;;				pod.UID,
0000000000000000000000000000000000000000;;				plugin,
0000000000000000000000000000000000000000;;				plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;				plugin.host.GetWriter(),
0000000000000000000000000000000000000000;;				volume.MetricsNil{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			source:       *spec.Volume.ConfigMap,
0000000000000000000000000000000000000000;;			pod:          *pod,
0000000000000000000000000000000000000000;;			opts:         &opts,
0000000000000000000000000000000000000000;;			getConfigMap: plugin.getConfigMap,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &configMapVolumeUnmounter{
0000000000000000000000000000000000000000;;			&configMapVolume{
0000000000000000000000000000000000000000;;				volName,
0000000000000000000000000000000000000000;;				podUID,
0000000000000000000000000000000000000000;;				plugin,
0000000000000000000000000000000000000000;;				plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;				plugin.host.GetWriter(),
0000000000000000000000000000000000000000;;				volume.MetricsNil{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *configMapPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		configMapVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				ConfigMap: &v1.ConfigMapVolumeSource{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(configMapVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type configMapVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		plugin  *configMapPlugin
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		writer  ioutil.Writer
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Volume = &configMapVolume{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv *configMapVolume) GetPath() string {
0000000000000000000000000000000000000000;;		return sv.plugin.host.GetPodVolumeDir(sv.podUID, strings.EscapeQualifiedNameForDisk(configMapPluginName), sv.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configMapVolumeMounter handles retrieving secrets from the API server
0000000000000000000000000000000000000000;;	// and placing them into the volume on the host.
0000000000000000000000000000000000000000;;	type configMapVolumeMounter struct {
0000000000000000000000000000000000000000;;		*configMapVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		source       v1.ConfigMapVolumeSource
0000000000000000000000000000000000000000;;		pod          v1.Pod
0000000000000000000000000000000000000000;;		opts         *volume.VolumeOptions
0000000000000000000000000000000000000000;;		getConfigMap func(namespace, name string) (*v1.ConfigMap, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &configMapVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv *configMapVolume) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        true,
0000000000000000000000000000000000000000;;			Managed:         true,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrappedVolumeSpec() volume.Spec {
0000000000000000000000000000000000000000;;		// This is the spec for the volume that this plugin wraps.
0000000000000000000000000000000000000000;;		return volume.Spec{
0000000000000000000000000000000000000000;;			// This should be on a tmpfs instead of the local disk; the problem is
0000000000000000000000000000000000000000;;			// charging the memory for the tmpfs to the right cgroup.  We should make
0000000000000000000000000000000000000000;;			// this a tmpfs when we can do the accounting correctly.
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *configMapVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *configMapVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *configMapVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Setting up volume %v for pod %v at %v", b.volName, b.pod.UID, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wrap EmptyDir, let it do the setup.
0000000000000000000000000000000000000000;;		wrapped, err := b.plugin.host.NewWrapperMounter(b.volName, wrappedVolumeSpec(), &b.pod, *b.opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wrapped.SetUpAt(dir, fsGroup); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optional := b.source.Optional != nil && *b.source.Optional
0000000000000000000000000000000000000000;;		configMap, err := b.getConfigMap(b.pod.Namespace, b.source.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !(errors.IsNotFound(err) && optional) {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get configMap %v/%v: %v", b.pod.Namespace, b.source.Name, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			configMap = &v1.ConfigMap{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: b.pod.Namespace,
0000000000000000000000000000000000000000;;					Name:      b.source.Name,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		totalBytes := totalBytes(configMap)
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Received configMap %v/%v containing (%v) pieces of data, %v total bytes",
0000000000000000000000000000000000000000;;			b.pod.Namespace,
0000000000000000000000000000000000000000;;			b.source.Name,
0000000000000000000000000000000000000000;;			len(configMap.Data),
0000000000000000000000000000000000000000;;			totalBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload, err := MakePayload(b.source.Items, configMap, b.source.DefaultMode, optional)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writerContext := fmt.Sprintf("pod %v/%v volume %v", b.pod.Namespace, b.pod.Name, b.volName)
0000000000000000000000000000000000000000;;		writer, err := volumeutil.NewAtomicWriter(dir, writerContext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error creating atomic writer: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = writer.Write(payload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error writing payload to dir: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error applying volume ownership settings for group: %v", fsGroup)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: this function is exported so that it can be called from the projection volume driver
0000000000000000000000000000000000000000;;	func MakePayload(mappings []v1.KeyToPath, configMap *v1.ConfigMap, defaultMode *int32, optional bool) (map[string]volumeutil.FileProjection, error) {
0000000000000000000000000000000000000000;;		if defaultMode == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No defaultMode used, not even the default value for it")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload := make(map[string]volumeutil.FileProjection, len(configMap.Data))
0000000000000000000000000000000000000000;;		var fileProjection volumeutil.FileProjection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(mappings) == 0 {
0000000000000000000000000000000000000000;;			for name, data := range configMap.Data {
0000000000000000000000000000000000000000;;				fileProjection.Data = []byte(data)
0000000000000000000000000000000000000000;;				fileProjection.Mode = *defaultMode
0000000000000000000000000000000000000000;;				payload[name] = fileProjection
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, ktp := range mappings {
0000000000000000000000000000000000000000;;				content, ok := configMap.Data[ktp.Key]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					if optional {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					err_msg := "references non-existent config key"
0000000000000000000000000000000000000000;;					glog.Errorf(err_msg)
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf(err_msg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fileProjection.Data = []byte(content)
0000000000000000000000000000000000000000;;				if ktp.Mode != nil {
0000000000000000000000000000000000000000;;					fileProjection.Mode = *ktp.Mode
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fileProjection.Mode = *defaultMode
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				payload[ktp.Path] = fileProjection
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return payload, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func totalBytes(configMap *v1.ConfigMap) int {
0000000000000000000000000000000000000000;;		totalSize := 0
0000000000000000000000000000000000000000;;		for _, value := range configMap.Data {
0000000000000000000000000000000000000000;;			totalSize += len(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return totalSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configMapVolumeUnmounter handles cleaning up configMap volumes.
0000000000000000000000000000000000000000;;	type configMapVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*configMapVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &configMapVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *configMapVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *configMapVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return volume.UnmountViaEmptyDir(dir, c.plugin.host, c.volName, wrappedVolumeSpec(), c.podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.ConfigMapVolumeSource, bool) {
0000000000000000000000000000000000000000;;		var readOnly bool
0000000000000000000000000000000000000000;;		var volumeSource *v1.ConfigMapVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.ConfigMap != nil {
0000000000000000000000000000000000000000;;			volumeSource = spec.Volume.ConfigMap
0000000000000000000000000000000000000000;;			readOnly = spec.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource, readOnly
0000000000000000000000000000000000000000;;	}
