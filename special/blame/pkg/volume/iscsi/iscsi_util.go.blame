0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
68e342c758b61f029d703c2190cf1b6d382ba6a4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package iscsi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		chap_st = []string{
0000000000000000000000000000000000000000;;			"discovery.sendtargets.auth.username",
0000000000000000000000000000000000000000;;			"discovery.sendtargets.auth.password",
0000000000000000000000000000000000000000;;			"discovery.sendtargets.auth.username_in",
0000000000000000000000000000000000000000;;			"discovery.sendtargets.auth.password_in"}
0000000000000000000000000000000000000000;;		chap_sess = []string{
0000000000000000000000000000000000000000;;			"node.session.auth.username",
0000000000000000000000000000000000000000;;			"node.session.auth.password",
0000000000000000000000000000000000000000;;			"node.session.auth.username_in",
0000000000000000000000000000000000000000;;			"node.session.auth.password_in"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateISCSIDiscoverydb(b iscsiDiskMounter, tp string) error {
0000000000000000000000000000000000000000;;		if b.chap_discovery {
0000000000000000000000000000000000000000;;			out, err := b.plugin.execCommand("iscsiadm", []string{"-m", "discoverydb", "-t", "sendtargets", "-p", tp, "-I", b.Iface, "-o", "update", "-n", "discovery.sendtargets.auth.authmethod", "-v", "CHAP"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("iscsi: failed to update discoverydb with CHAP, output: %v", string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, k := range chap_st {
0000000000000000000000000000000000000000;;				v := b.secret[k]
0000000000000000000000000000000000000000;;				if len(v) > 0 {
0000000000000000000000000000000000000000;;					out, err := b.plugin.execCommand("iscsiadm", []string{"-m", "discoverydb", "-t", "sendtargets", "-p", tp, "-I", b.Iface, "-o", "update", "-n", k, "-v", v})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("iscsi: failed to update discoverydb key %q with value %q error: %v", k, v, string(out))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateISCSINode(b iscsiDiskMounter, tp string) error {
0000000000000000000000000000000000000000;;		if b.chap_session {
0000000000000000000000000000000000000000;;			out, err := b.plugin.execCommand("iscsiadm", []string{"-m", "node", "-p", tp, "-T", b.Iqn, "-I", b.Iface, "-o", "update", "-n", "node.session.auth.authmethod", "-v", "CHAP"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("iscsi: failed to update node with CHAP, output: %v", string(out))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, k := range chap_sess {
0000000000000000000000000000000000000000;;				v := b.secret[k]
0000000000000000000000000000000000000000;;				if len(v) > 0 {
0000000000000000000000000000000000000000;;					out, err := b.plugin.execCommand("iscsiadm", []string{"-m", "node", "-p", tp, "-T", b.Iqn, "-I", b.Iface, "-o", "update", "-n", k, "-v", v})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("iscsi: failed to update node session key %q with value %q error: %v", k, v, string(out))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stat a path, if not exists, retry maxRetries times
0000000000000000000000000000000000000000;;	// when iscsi transports other than default are used,  use glob instead as pci id of device is unknown
0000000000000000000000000000000000000000;;	type StatFunc func(string) (os.FileInfo, error)
0000000000000000000000000000000000000000;;	type GlobFunc func(string) ([]string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPathToExist(devicePath *string, maxRetries int, deviceTransport string) bool {
0000000000000000000000000000000000000000;;		// This makes unit testing a lot easier
0000000000000000000000000000000000000000;;		return waitForPathToExistInternal(devicePath, maxRetries, deviceTransport, os.Stat, filepath.Glob)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForPathToExistInternal(devicePath *string, maxRetries int, deviceTransport string, osStat StatFunc, filepathGlob GlobFunc) bool {
0000000000000000000000000000000000000000;;		if devicePath != nil {
0000000000000000000000000000000000000000;;			for i := 0; i < maxRetries; i++ {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if deviceTransport == "tcp" {
0000000000000000000000000000000000000000;;					_, err = osStat(*devicePath)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fpath, _ := filepathGlob(*devicePath)
0000000000000000000000000000000000000000;;					if fpath == nil {
0000000000000000000000000000000000000000;;						err = os.ErrNotExist
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// There might be a case that fpath contains multiple device paths if
0000000000000000000000000000000000000000;;						// multiple PCI devices connect to same iscsi target. We handle this
0000000000000000000000000000000000000000;;						// case at subsequent logic. Pick up only first path here.
0000000000000000000000000000000000000000;;						*devicePath = fpath[0]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i == maxRetries-1 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(time.Second)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDevicePrefixRefCount: given a prefix of device path, find its reference count from /proc/mounts
0000000000000000000000000000000000000000;;	// returns the reference count to the device and error code
0000000000000000000000000000000000000000;;	// for services like iscsi construct multiple device paths with the same prefix pattern.
0000000000000000000000000000000000000000;;	// this function aggregates all references to a service based on the prefix pattern
0000000000000000000000000000000000000000;;	// More specifically, this prefix semantics is to aggregate disk paths that belong to the same iSCSI target/iqn pair.
0000000000000000000000000000000000000000;;	// an iSCSI target could expose multiple LUNs through the same IQN, and Linux iSCSI initiator creates disk paths that start the same prefix but end with different LUN number
0000000000000000000000000000000000000000;;	// When we decide whether it is time to logout a target, we have to see if none of the LUNs are used any more.
0000000000000000000000000000000000000000;;	// That's where the prefix based ref count kicks in. If we only count the disks using exact match, we could log other disks out.
0000000000000000000000000000000000000000;;	func getDevicePrefixRefCount(mounter mount.Interface, deviceNamePrefix string) (int, error) {
0000000000000000000000000000000000000000;;		mps, err := mounter.List()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the number of references to the device.
0000000000000000000000000000000000000000;;		refCount := 0
0000000000000000000000000000000000000000;;		for i := range mps {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(mps[i].Path, deviceNamePrefix) {
0000000000000000000000000000000000000000;;				refCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return refCount, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// make a directory like /var/lib/kubelet/plugins/kubernetes.io/iscsi/iface_name/portal-some_iqn-lun-lun_id
0000000000000000000000000000000000000000;;	func makePDNameInternal(host volume.VolumeHost, portal string, iqn string, lun string, iface string) string {
0000000000000000000000000000000000000000;;		return path.Join(host.GetPluginDir(iscsiPluginName), "iface-"+iface, portal+"-"+iqn+"-lun-"+lun)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ISCSIUtil struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *ISCSIUtil) MakeGlobalPDName(iscsi iscsiDisk) string {
0000000000000000000000000000000000000000;;		return makePDNameInternal(iscsi.plugin.host, iscsi.Portals[0], iscsi.Iqn, iscsi.lun, iscsi.Iface)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *ISCSIUtil) persistISCSI(conf iscsiDisk, mnt string) error {
0000000000000000000000000000000000000000;;		file := path.Join(mnt, "iscsi.json")
0000000000000000000000000000000000000000;;		fp, err := os.Create(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("iscsi: create %s err %s", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer fp.Close()
0000000000000000000000000000000000000000;;		encoder := json.NewEncoder(fp)
0000000000000000000000000000000000000000;;		if err = encoder.Encode(conf); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("iscsi: encode err: %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *ISCSIUtil) loadISCSI(conf *iscsiDisk, mnt string) error {
0000000000000000000000000000000000000000;;		// NOTE: The iscsi config json is not deleted after logging out from target portals.
0000000000000000000000000000000000000000;;		file := path.Join(mnt, "iscsi.json")
0000000000000000000000000000000000000000;;		fp, err := os.Open(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("iscsi: open %s err %s", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer fp.Close()
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(fp)
0000000000000000000000000000000000000000;;		if err = decoder.Decode(conf); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("iscsi: decode err: %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *ISCSIUtil) AttachDisk(b iscsiDiskMounter) error {
0000000000000000000000000000000000000000;;		var devicePath string
0000000000000000000000000000000000000000;;		var devicePaths []string
0000000000000000000000000000000000000000;;		var iscsiTransport string
0000000000000000000000000000000000000000;;		var lastErr error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := b.plugin.execCommand("iscsiadm", []string{"-m", "iface", "-I", b.Iface, "-o", "show"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("iscsi: could not read iface %s error: %s", b.Iface, string(out))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iscsiTransport = extractTransportname(string(out))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bkpPortal := b.Portals
0000000000000000000000000000000000000000;;		for _, tp := range bkpPortal {
0000000000000000000000000000000000000000;;			// Rescan sessions to discover newly mapped LUNs. Do not specify the interface when rescanning
0000000000000000000000000000000000000000;;			// to avoid establishing additional sessions to the same target.
0000000000000000000000000000000000000000;;			out, err := b.plugin.execCommand("iscsiadm", []string{"-m", "node", "-p", tp, "-T", b.Iqn, "-R"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("iscsi: failed to rescan session with error: %s (%v)", string(out), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if iscsiTransport == "" {
0000000000000000000000000000000000000000;;				glog.Errorf("iscsi: could not find transport name in iface %s", b.Iface)
0000000000000000000000000000000000000000;;				return fmt.Errorf("Could not parse iface file for %s", b.Iface)
0000000000000000000000000000000000000000;;			} else if iscsiTransport == "tcp" {
0000000000000000000000000000000000000000;;				devicePath = strings.Join([]string{"/dev/disk/by-path/ip", tp, "iscsi", b.Iqn, "lun", b.lun}, "-")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				devicePath = strings.Join([]string{"/dev/disk/by-path/pci", "*", "ip", tp, "iscsi", b.Iqn, "lun", b.lun}, "-")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exist := waitForPathToExist(&devicePath, 1, iscsiTransport)
0000000000000000000000000000000000000000;;			if exist == false {
0000000000000000000000000000000000000000;;				// build discoverydb and discover iscsi target
0000000000000000000000000000000000000000;;				b.plugin.execCommand("iscsiadm", []string{"-m", "discoverydb", "-t", "sendtargets", "-p", tp, "-I", b.Iface, "-o", "new"})
0000000000000000000000000000000000000000;;				// update discoverydb with CHAP secret
0000000000000000000000000000000000000000;;				err = updateISCSIDiscoverydb(b, tp)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					lastErr = fmt.Errorf("iscsi: failed to update discoverydb to portal %s error: %v", tp, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out, err := b.plugin.execCommand("iscsiadm", []string{"-m", "discoverydb", "-t", "sendtargets", "-p", tp, "-I", b.Iface, "--discover"})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// delete discoverydb record
0000000000000000000000000000000000000000;;					b.plugin.execCommand("iscsiadm", []string{"-m", "discoverydb", "-t", "sendtargets", "-p", tp, "-I", b.Iface, "-o", "delete"})
0000000000000000000000000000000000000000;;					lastErr = fmt.Errorf("iscsi: failed to sendtargets to portal %s output: %s, err %v", tp, string(out), err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = updateISCSINode(b, tp)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// failure to update node db is rare. But deleting record will likely impact those who already start using it.
0000000000000000000000000000000000000000;;					lastErr = fmt.Errorf("iscsi: failed to update iscsi node to portal %s error: %v", tp, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// login to iscsi target
0000000000000000000000000000000000000000;;				out, err = b.plugin.execCommand("iscsiadm", []string{"-m", "node", "-p", tp, "-T", b.Iqn, "-I", b.Iface, "--login"})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// delete the node record from database
0000000000000000000000000000000000000000;;					b.plugin.execCommand("iscsiadm", []string{"-m", "node", "-p", tp, "-I", b.Iface, "-T", b.Iqn, "-o", "delete"})
0000000000000000000000000000000000000000;;					lastErr = fmt.Errorf("iscsi: failed to attach disk: Error: %s (%v)", string(out), err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				exist = waitForPathToExist(&devicePath, 10, iscsiTransport)
0000000000000000000000000000000000000000;;				if !exist {
0000000000000000000000000000000000000000;;					glog.Errorf("Could not attach disk: Timeout after 10s")
0000000000000000000000000000000000000000;;					// update last error
0000000000000000000000000000000000000000;;					lastErr = fmt.Errorf("Could not attach disk: Timeout after 10s")
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					devicePaths = append(devicePaths, devicePath)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("iscsi: devicepath (%s) exists", devicePath)
0000000000000000000000000000000000000000;;				devicePaths = append(devicePaths, devicePath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(devicePaths) == 0 {
0000000000000000000000000000000000000000;;			glog.Errorf("iscsi: failed to get any path for iscsi disk, last err seen:\n%v", lastErr)
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get any path for iscsi disk, last err seen:\n%v", lastErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//Make sure we use a valid devicepath to find mpio device.
0000000000000000000000000000000000000000;;		devicePath = devicePaths[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mount it
0000000000000000000000000000000000000000;;		globalPDPath := b.manager.MakeGlobalPDName(*b.iscsiDisk)
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(globalPDPath)
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			glog.Infof("iscsi: %s already mounted", globalPDPath)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(globalPDPath, 0750); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("iscsi: failed to mkdir %s, error", globalPDPath)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Persist iscsi disk config to json file for DetachDisk path
0000000000000000000000000000000000000000;;		util.persistISCSI(*(b.iscsiDisk), globalPDPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, path := range devicePaths {
0000000000000000000000000000000000000000;;			// There shouldnt be any empty device paths. However adding this check
0000000000000000000000000000000000000000;;			// for safer side to avoid the possibility of an empty entry.
0000000000000000000000000000000000000000;;			if path == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// check if the dev is using mpio and if so mount it via the dm-XX device
0000000000000000000000000000000000000000;;			if mappedDevicePath := b.deviceUtil.FindMultipathDeviceForDevice(path); mappedDevicePath != "" {
0000000000000000000000000000000000000000;;				devicePath = mappedDevicePath
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = b.mounter.FormatAndMount(devicePath, globalPDPath, b.fsType, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("iscsi: failed to mount iscsi volume %s [%s] to %s, error %v", devicePath, b.fsType, globalPDPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *ISCSIUtil) DetachDisk(c iscsiDiskUnmounter, mntPath string) error {
0000000000000000000000000000000000000000;;		_, cnt, err := mount.GetDeviceNameFromMount(c.mounter, mntPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("iscsi detach disk: failed to get device from mnt: %s\nError: %v", mntPath, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = c.mounter.Unmount(mntPath); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("iscsi detach disk: failed to unmount: %s\nError: %v", mntPath, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cnt--
0000000000000000000000000000000000000000;;		// if device is no longer used, see if need to logout the target
0000000000000000000000000000000000000000;;		if cnt == 0 {
0000000000000000000000000000000000000000;;			device, prefix, err := extractDeviceAndPrefix(mntPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			refCount, err := getDevicePrefixRefCount(c.mounter, prefix)
0000000000000000000000000000000000000000;;			if err == nil && refCount == 0 {
0000000000000000000000000000000000000000;;				var bkpPortal []string
0000000000000000000000000000000000000000;;				var iqn, iface string
0000000000000000000000000000000000000000;;				found := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// load iscsi disk config from json file
0000000000000000000000000000000000000000;;				if err := util.loadISCSI(c.iscsiDisk, mntPath); err == nil {
0000000000000000000000000000000000000000;;					bkpPortal, iqn, iface = c.iscsiDisk.Portals, c.iscsiDisk.Iqn, c.iscsiDisk.Iface
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// If the iscsi disk config is not found, fall back to the original behavior.
0000000000000000000000000000000000000000;;					// This portal/iqn/iface is no longer referenced, log out.
0000000000000000000000000000000000000000;;					// Extract the portal and iqn from device path.
0000000000000000000000000000000000000000;;					bkpPortal = make([]string, 1)
0000000000000000000000000000000000000000;;					bkpPortal[0], iqn, err = extractPortalAndIqn(device)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Extract the iface from the mountPath and use it to log out. If the iface
0000000000000000000000000000000000000000;;					// is not found, maintain the previous behavior to facilitate kubelet upgrade.
0000000000000000000000000000000000000000;;					// Logout may fail as no session may exist for the portal/IQN on the specified interface.
0000000000000000000000000000000000000000;;					iface, found = extractIface(mntPath)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, portal := range removeDuplicate(bkpPortal) {
0000000000000000000000000000000000000000;;					logout := []string{"-m", "node", "-p", portal, "-T", iqn, "--logout"}
0000000000000000000000000000000000000000;;					delete := []string{"-m", "node", "-p", portal, "-T", iqn, "-o", "delete"}
0000000000000000000000000000000000000000;;					if found {
0000000000000000000000000000000000000000;;						logout = append(logout, []string{"-I", iface}...)
0000000000000000000000000000000000000000;;						delete = append(delete, []string{"-I", iface}...)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.Infof("iscsi: log out target %s iqn %s iface %s", portal, iqn, iface)
0000000000000000000000000000000000000000;;					out, err := c.plugin.execCommand("iscsiadm", logout)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("iscsi: failed to detach disk Error: %s", string(out))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Delete the node record
0000000000000000000000000000000000000000;;					glog.Infof("iscsi: delete node record target %s iqn %s", portal, iqn)
0000000000000000000000000000000000000000;;					out, err = c.plugin.execCommand("iscsiadm", delete)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("iscsi: failed to delete node record Error: %s", string(out))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractTransportname(ifaceOutput string) (iscsiTransport string) {
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(`iface.transport_name = (.*)\n`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rex_output := re.FindStringSubmatch(ifaceOutput)
0000000000000000000000000000000000000000;;		if rex_output != nil {
0000000000000000000000000000000000000000;;			iscsiTransport = rex_output[1]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// While iface.transport_name is a required parameter, handle it being unspecified anyways
0000000000000000000000000000000000000000;;		if iscsiTransport == "<empty>" {
0000000000000000000000000000000000000000;;			iscsiTransport = "tcp"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return iscsiTransport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractDeviceAndPrefix(mntPath string) (string, string, error) {
0000000000000000000000000000000000000000;;		ind := strings.LastIndex(mntPath, "/")
0000000000000000000000000000000000000000;;		if ind < 0 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("iscsi detach disk: malformatted mnt path: %s", mntPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		device := mntPath[(ind + 1):]
0000000000000000000000000000000000000000;;		// strip -lun- from mount path
0000000000000000000000000000000000000000;;		ind = strings.LastIndex(mntPath, "-lun-")
0000000000000000000000000000000000000000;;		if ind < 0 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("iscsi detach disk: malformatted mnt path: %s", mntPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prefix := mntPath[:ind]
0000000000000000000000000000000000000000;;		return device, prefix, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractIface(mntPath string) (string, bool) {
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(`.+/iface-([^/]+)/.+`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		re_output := re.FindStringSubmatch(mntPath)
0000000000000000000000000000000000000000;;		if re_output != nil {
0000000000000000000000000000000000000000;;			return re_output[1], true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractPortalAndIqn(device string) (string, string, error) {
0000000000000000000000000000000000000000;;		ind1 := strings.Index(device, "-")
0000000000000000000000000000000000000000;;		if ind1 < 0 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("iscsi detach disk: no portal in %s", device)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portal := device[0:ind1]
0000000000000000000000000000000000000000;;		ind2 := strings.Index(device, "iqn.")
0000000000000000000000000000000000000000;;		if ind2 < 0 {
0000000000000000000000000000000000000000;;			ind2 = strings.Index(device, "eui.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ind2 < 0 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("iscsi detach disk: no iqn in %s", device)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ind := strings.LastIndex(device, "-lun-")
0000000000000000000000000000000000000000;;		iqn := device[ind2:ind]
0000000000000000000000000000000000000000;;		return portal, iqn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove duplicates or string
0000000000000000000000000000000000000000;;	func removeDuplicate(s []string) []string {
0000000000000000000000000000000000000000;;		m := map[string]bool{}
0000000000000000000000000000000000000000;;		for _, v := range s {
0000000000000000000000000000000000000000;;			if v != "" && !m[v] {
0000000000000000000000000000000000000000;;				s[len(m)] = v
0000000000000000000000000000000000000000;;				m[v] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = s[:len(m)]
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
