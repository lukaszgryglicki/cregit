0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
68e342c758b61f029d703c2190cf1b6d382ba6a4;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package iscsi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		ioutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&iscsiPlugin{nil, exec.New()}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type iscsiPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;		exe  exec.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &iscsiPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &iscsiPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		iscsiPluginName = "kubernetes.io/iscsi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return iscsiPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%v:%v:%v",
0000000000000000000000000000000000000000;;			volumeSource.TargetPortal,
0000000000000000000000000000000000000000;;			volumeSource.IQN,
0000000000000000000000000000000000000000;;			volumeSource.Lun), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		if (spec.Volume != nil && spec.Volume.ISCSI == nil) || (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.ISCSI == nil) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;			v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		var secret map[string]string
0000000000000000000000000000000000000000;;		source, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if source.SecretRef != nil {
0000000000000000000000000000000000000000;;			if secret, err = ioutil.GetSecretForPod(pod, source.SecretRef.Name, plugin.host.GetKubeClient()); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get secret from %v/%v", pod.Namespace, source.SecretRef)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, &ISCSIUtil{}, plugin.host.GetMounter(), secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, manager diskManager, mounter mount.Interface, secret map[string]string) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		// iscsi volumes used directly in a pod have a ReadOnly flag set by the pod author.
0000000000000000000000000000000000000000;;		// iscsi volumes used as a PersistentVolume gets the ReadOnly flag indirectly through the persistent-claim volume used to mount the PV
0000000000000000000000000000000000000000;;		iscsi, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lun := strconv.Itoa(int(iscsi.Lun))
0000000000000000000000000000000000000000;;		portal := portalMounter(iscsi.TargetPortal)
0000000000000000000000000000000000000000;;		var bkportal []string
0000000000000000000000000000000000000000;;		bkportal = append(bkportal, portal)
0000000000000000000000000000000000000000;;		for _, tp := range iscsi.Portals {
0000000000000000000000000000000000000000;;			bkportal = append(bkportal, portalMounter(string(tp)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iface := iscsi.ISCSIInterface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &iscsiDiskMounter{
0000000000000000000000000000000000000000;;			iscsiDisk: &iscsiDisk{
0000000000000000000000000000000000000000;;				podUID:         podUID,
0000000000000000000000000000000000000000;;				volName:        spec.Name(),
0000000000000000000000000000000000000000;;				Portals:        bkportal,
0000000000000000000000000000000000000000;;				Iqn:            iscsi.IQN,
0000000000000000000000000000000000000000;;				lun:            lun,
0000000000000000000000000000000000000000;;				Iface:          iface,
0000000000000000000000000000000000000000;;				chap_discovery: iscsi.DiscoveryCHAPAuth,
0000000000000000000000000000000000000000;;				chap_session:   iscsi.SessionCHAPAuth,
0000000000000000000000000000000000000000;;				secret:         secret,
0000000000000000000000000000000000000000;;				manager:        manager,
0000000000000000000000000000000000000000;;				plugin:         plugin},
0000000000000000000000000000000000000000;;			fsType:       iscsi.FSType,
0000000000000000000000000000000000000000;;			readOnly:     readOnly,
0000000000000000000000000000000000000000;;			mounter:      &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()},
0000000000000000000000000000000000000000;;			deviceUtil:   ioutil.NewDeviceHandler(ioutil.NewIOHandler()),
0000000000000000000000000000000000000000;;			mountOptions: volume.MountOptionFromSpec(spec),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, &ISCSIUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) newUnmounterInternal(volName string, podUID types.UID, manager diskManager, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &iscsiDiskUnmounter{
0000000000000000000000000000000000000000;;			iscsiDisk: &iscsiDisk{
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			mounter: mounter,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) execCommand(command string, args []string) ([]byte, error) {
0000000000000000000000000000000000000000;;		cmd := plugin.exe.Command(command, args...)
0000000000000000000000000000000000000000;;		return cmd.CombinedOutput()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *iscsiPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		iscsiVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				ISCSI: &v1.ISCSIVolumeSource{
0000000000000000000000000000000000000000;;					TargetPortal: volumeName,
0000000000000000000000000000000000000000;;					IQN:          volumeName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(iscsiVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type iscsiDisk struct {
0000000000000000000000000000000000000000;;		volName        string
0000000000000000000000000000000000000000;;		podUID         types.UID
0000000000000000000000000000000000000000;;		Portals        []string
0000000000000000000000000000000000000000;;		Iqn            string
0000000000000000000000000000000000000000;;		lun            string
0000000000000000000000000000000000000000;;		Iface          string
0000000000000000000000000000000000000000;;		chap_discovery bool
0000000000000000000000000000000000000000;;		chap_session   bool
0000000000000000000000000000000000000000;;		secret         map[string]string
0000000000000000000000000000000000000000;;		plugin         *iscsiPlugin
0000000000000000000000000000000000000000;;		// Utility interface that provides API calls to the provider to attach/detach disks.
0000000000000000000000000000000000000000;;		manager diskManager
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (iscsi *iscsiDisk) GetPath() string {
0000000000000000000000000000000000000000;;		name := iscsiPluginName
0000000000000000000000000000000000000000;;		// safe to use PodVolumeDir now: volume teardown occurs before pod is cleaned up
0000000000000000000000000000000000000000;;		return iscsi.plugin.host.GetPodVolumeDir(iscsi.podUID, utilstrings.EscapeQualifiedNameForDisk(name), iscsi.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type iscsiDiskMounter struct {
0000000000000000000000000000000000000000;;		*iscsiDisk
0000000000000000000000000000000000000000;;		readOnly     bool
0000000000000000000000000000000000000000;;		fsType       string
0000000000000000000000000000000000000000;;		mounter      *mount.SafeFormatAndMount
0000000000000000000000000000000000000000;;		deviceUtil   ioutil.DeviceUtil
0000000000000000000000000000000000000000;;		mountOptions []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &iscsiDiskMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *iscsiDiskMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         !b.readOnly,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *iscsiDiskMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *iscsiDiskMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *iscsiDiskMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		// diskSetUp checks mountpoints and prevent repeated calls
0000000000000000000000000000000000000000;;		err := diskSetUp(b.manager, *b, dir, b.mounter, fsGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("iscsi: failed to setup")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type iscsiDiskUnmounter struct {
0000000000000000000000000000000000000000;;		*iscsiDisk
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &iscsiDiskUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the disk
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *iscsiDiskUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *iscsiDiskUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		if pathExists, pathErr := ioutil.PathExists(dir); pathErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error checking if path exists: %v", pathErr)
0000000000000000000000000000000000000000;;		} else if !pathExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: Unmount skipped because path does not exist: %v", dir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return diskTearDown(c.manager, *c, dir, c.mounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func portalMounter(portal string) string {
0000000000000000000000000000000000000000;;		if !strings.Contains(portal, ":") {
0000000000000000000000000000000000000000;;			portal = portal + ":3260"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return portal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.ISCSIVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.ISCSI != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.ISCSI, spec.Volume.ISCSI.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.ISCSI != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.ISCSI, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference an ISCSI volume type")
0000000000000000000000000000000000000000;;	}
