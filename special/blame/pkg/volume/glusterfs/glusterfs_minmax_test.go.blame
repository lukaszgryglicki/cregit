0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
dc8299c56994d75169318d31e1684ecc8ecf035b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package glusterfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewFree(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != (max - min + 1) {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d free, but got %d", (max - min + 1), f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewInvalidRange(t *testing.T) {
0000000000000000000000000000000000000000;;		if _, err := NewMinMaxAllocator(10, 1); err != ErrInvalidRange {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get Error '%v', got '%v'", ErrInvalidRange, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetRange(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = m.SetRange(10, 1); err != ErrInvalidRange {
0000000000000000000000000000000000000000;;			t.Errorf("expected to get error '%v', got '%v'", ErrInvalidRange, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = m.SetRange(1, 2); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error setting range: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d free, but got %d", 2, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok, _ := m.Allocate(1); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("error allocate offset %v", 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get 1 free, but got %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = m.SetRange(1, 1); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error setting range: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get 0 free, but got %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = m.SetRange(2, 2); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error setting range: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get 1 free, but got %d", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateNext(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		el, ok, _ := m.AllocateNext()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !m.Has(el) {
0000000000000000000000000000000000000000;;			t.Errorf("expect element %v allocated", el)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != (max-min+1)-1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d free, but got %d", (max-min+1)-1, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateMax(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 1; i <= max; i++ {
0000000000000000000000000000000000000000;;			if _, ok, _ := m.AllocateNext(); !ok {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok, _ := m.AllocateNext(); ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d free, but got %d", 0, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocate(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;		offset := 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok, err := m.Allocate(offset); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("error allocate offset %v: %v", offset, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !m.Has(offset) {
0000000000000000000000000000000000000000;;			t.Errorf("expect element %v allocated", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := m.Free(); f != (max-min+1)-1 {
0000000000000000000000000000000000000000;;			t.Errorf("expect to get %d free, but got %d", (max-min+1)-1, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateConflict(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;		offset := 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok, err := m.Allocate(offset); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("error allocate offset %v: %v", offset, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := m.Allocate(offset)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != ErrConflict {
0000000000000000000000000000000000000000;;			t.Errorf("expected error '%v', got '%v'", ErrConflict, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAllocateOutOfRange(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;		offset := 11
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := m.Allocate(offset)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected success")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != ErrOutOfRange {
0000000000000000000000000000000000000000;;			t.Errorf("expected error '%v', got '%v'", ErrOutOfRange, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRelease(t *testing.T) {
0000000000000000000000000000000000000000;;		min := 1
0000000000000000000000000000000000000000;;		max := 10
0000000000000000000000000000000000000000;;		offset := 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m, err := NewMinMaxAllocator(min, max)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("error creating new allocator: '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok, err := m.Allocate(offset); !ok {
0000000000000000000000000000000000000000;;			t.Errorf("error allocate offset %v: %v", offset, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !m.Has(offset) {
0000000000000000000000000000000000000000;;			t.Errorf("expect offset %v allocated", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = m.Release(offset); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.Has(offset) {
0000000000000000000000000000000000000000;;			t.Errorf("expect offset %v not allocated", offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
