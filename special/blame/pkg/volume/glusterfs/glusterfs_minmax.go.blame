0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
dc8299c56994d75169318d31e1684ecc8ecf035b;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This implementation is space-efficient for a sparse
0000000000000000000000000000000000000000;;	// allocation over a big range. Could be optimized
0000000000000000000000000000000000000000;;	// for high absolute allocation number with a bitmap.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package glusterfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		//ErrConflict returned when value is already in use.
0000000000000000000000000000000000000000;;		ErrConflict = errors.New("number already allocated")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//ErrInvalidRange returned invalid range, for eg# min > max
0000000000000000000000000000000000000000;;		ErrInvalidRange = errors.New("invalid range")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//ErrOutOfRange returned when value is not in pool range.
0000000000000000000000000000000000000000;;		ErrOutOfRange = errors.New("out of range")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//ErrRangeFull returned when no more free values in the pool.
0000000000000000000000000000000000000000;;		ErrRangeFull = errors.New("range full")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//ErrInternal returned when no free item found, but a.free != 0.
0000000000000000000000000000000000000000;;		ErrInternal = errors.New("internal error")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MinMaxAllocator defines allocator struct.
0000000000000000000000000000000000000000;;	type MinMaxAllocator struct {
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;		min  int
0000000000000000000000000000000000000000;;		max  int
0000000000000000000000000000000000000000;;		free int
0000000000000000000000000000000000000000;;		used map[int]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Rangeable = &MinMaxAllocator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rangeable is an Interface that can adjust its min/max range.
0000000000000000000000000000000000000000;;	// Rangeable should be threadsafe
0000000000000000000000000000000000000000;;	type Rangeable interface {
0000000000000000000000000000000000000000;;		Allocate(int) (bool, error)
0000000000000000000000000000000000000000;;		AllocateNext() (int, bool, error)
0000000000000000000000000000000000000000;;		Release(int) error
0000000000000000000000000000000000000000;;		Has(int) bool
0000000000000000000000000000000000000000;;		Free() int
0000000000000000000000000000000000000000;;		SetRange(min, max int) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMinMaxAllocator return a new allocator or error based on provided min/max value.
0000000000000000000000000000000000000000;;	func NewMinMaxAllocator(min, max int) (*MinMaxAllocator, error) {
0000000000000000000000000000000000000000;;		if min > max {
0000000000000000000000000000000000000000;;			return nil, ErrInvalidRange
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &MinMaxAllocator{
0000000000000000000000000000000000000000;;			min:  min,
0000000000000000000000000000000000000000;;			max:  max,
0000000000000000000000000000000000000000;;			free: 1 + max - min,
0000000000000000000000000000000000000000;;			used: map[int]bool{},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//SetRange defines the range/pool with provided min and max values.
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) SetRange(min, max int) error {
0000000000000000000000000000000000000000;;		if min > max {
0000000000000000000000000000000000000000;;			return ErrInvalidRange
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if we need to change
0000000000000000000000000000000000000000;;		if a.min == min && a.max == max {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.min = min
0000000000000000000000000000000000000000;;		a.max = max
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recompute how many free we have in the range
0000000000000000000000000000000000000000;;		numUsed := 0
0000000000000000000000000000000000000000;;		for i := range a.used {
0000000000000000000000000000000000000000;;			if a.inRange(i) {
0000000000000000000000000000000000000000;;				numUsed++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.free = 1 + max - min - numUsed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Allocate allocates provided value in the allocator and mark it as used.
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) Allocate(i int) (bool, error) {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !a.inRange(i) {
0000000000000000000000000000000000000000;;			return false, ErrOutOfRange
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.has(i) {
0000000000000000000000000000000000000000;;			return false, ErrConflict
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.used[i] = true
0000000000000000000000000000000000000000;;		a.free--
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//AllocateNext allocates next value from the allocator.
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) AllocateNext() (int, bool, error) {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fast check if we're out of items
0000000000000000000000000000000000000000;;		if a.free <= 0 {
0000000000000000000000000000000000000000;;			return 0, false, ErrRangeFull
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan from the minimum until we find a free item
0000000000000000000000000000000000000000;;		for i := a.min; i <= a.max; i++ {
0000000000000000000000000000000000000000;;			if !a.has(i) {
0000000000000000000000000000000000000000;;				a.used[i] = true
0000000000000000000000000000000000000000;;				a.free--
0000000000000000000000000000000000000000;;				return i, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no free item found, but a.free != 0
0000000000000000000000000000000000000000;;		return 0, false, ErrInternal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Release free/delete provided value from the allocator.
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) Release(i int) error {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !a.has(i) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(a.used, i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.inRange(i) {
0000000000000000000000000000000000000000;;			a.free++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) has(i int) bool {
0000000000000000000000000000000000000000;;		_, ok := a.used[i]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Has check whether the provided value is used in the allocator
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) Has(i int) bool {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return a.has(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Free returns the number of free values in the allocator.
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) Free() int {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;		return a.free
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *MinMaxAllocator) inRange(i int) bool {
0000000000000000000000000000000000000000;;		return a.min <= i && i <= a.max
0000000000000000000000000000000000000000;;	}
