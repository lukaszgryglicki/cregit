0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
b5e7fbf7a9744ecaea8963c86d4fdb223219fc0f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package glusterfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readGlusterLog will take the last 2 lines of the log file
0000000000000000000000000000000000000000;;	// on failure of gluster SetUp and return those so kubelet can
0000000000000000000000000000000000000000;;	// properly expose them
0000000000000000000000000000000000000000;;	// return nil on any failure
0000000000000000000000000000000000000000;;	func readGlusterLog(path string, podName string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var line1 string
0000000000000000000000000000000000000000;;		var line2 string
0000000000000000000000000000000000000000;;		linecount := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("glusterfs: failure, now attempting to read the gluster log for pod %s", podName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check and make sure path exists
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("glusterfs: log file does not exist for pod: %s", podName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// open the log file
0000000000000000000000000000000000000000;;		file, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("glusterfs: could not open log file for pod: %s", podName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// read in and scan the file using scanner
0000000000000000000000000000000000000000;;		// from stdlib
0000000000000000000000000000000000000000;;		fscan := bufio.NewScanner(file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rather than guessing on bytes or using Seek
0000000000000000000000000000000000000000;;		// going to scan entire file and take the last two lines
0000000000000000000000000000000000000000;;		// generally the file should be small since it is pod specific
0000000000000000000000000000000000000000;;		for fscan.Scan() {
0000000000000000000000000000000000000000;;			if linecount > 0 {
0000000000000000000000000000000000000000;;				line1 = line2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line2 = "\n" + fscan.Text()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			linecount++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if linecount > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%v", line1+line2+"\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
