0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
ebd560ae040ae6b34c24b27d4eed543ec7595f30;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package glusterfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gapi "github.com/heketi/heketi/pkg/glusterfs/api"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("glusterfs_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/glusterfs")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.GetPluginName() != "kubernetes.io/glusterfs" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plug.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.CanSupport(&volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("glusterfs_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPersistentPluginByName("kubernetes.io/glusterfs")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !contains(plug.GetAccessModes(), v1.ReadWriteOnce) || !contains(plug.GetAccessModes(), v1.ReadOnlyMany) || !contains(plug.GetAccessModes(), v1.ReadWriteMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected three AccessModeTypes:  %s, %s, and %s", v1.ReadWriteOnce, v1.ReadOnlyMany, v1.ReadWriteMany)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(modes []v1.PersistentVolumeAccessMode, mode v1.PersistentVolumeAccessMode) bool {
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if m == mode {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doTestPlugin(t *testing.T, spec *volume.Spec) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("glusterfs_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/glusterfs")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ep := &v1.Endpoints{ObjectMeta: metav1.ObjectMeta{Name: "foo"}, Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;			Addresses: []v1.EndpointAddress{{IP: "127.0.0.1"}}}}}
0000000000000000000000000000000000000000;;		var fcmd exec.FakeCmd
0000000000000000000000000000000000000000;;		fcmd = exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// mount
0000000000000000000000000000000000000000;;				func() ([]byte, error) {
0000000000000000000000000000000000000000;;					return []byte{}, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fake := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, err := plug.(*glusterfsPlugin).newMounterInternal(spec, ep, pod, &mount.FakeMounter{}, &fake)
0000000000000000000000000000000000000000;;		volumePath := mounter.GetPath()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Error("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedPath := fmt.Sprintf("%s/pods/poduid/volumes/kubernetes.io~glusterfs/vol1", tmpDir)
0000000000000000000000000000000000000000;;		if volumePath != expectedPath {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected path, expected %q, got: %q", expectedPath, volumePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := mounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(volumePath); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed, volume path not created: %s", volumePath)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unmounter, err := plug.(*glusterfsPlugin).newUnmounterInternal("vol1", types.UID("poduid"), &mount.FakeMounter{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unmounter == nil {
0000000000000000000000000000000000000000;;			t.Error("Got a nil Unmounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := unmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(volumePath); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("TearDown() failed, volume path still exists: %s", volumePath)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		vol := &v1.Volume{
0000000000000000000000000000000000000000;;			Name:         "vol1",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{Glusterfs: &v1.GlusterfsVolumeSource{EndpointsName: "ep", Path: "vol", ReadOnly: false}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		doTestPlugin(t, volume.NewSpecFromVolume(vol))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginPersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		vol := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "vol1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					Glusterfs: &v1.GlusterfsVolumeSource{EndpointsName: "ep", Path: "vol", ReadOnly: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doTestPlugin(t, volume.NewSpecFromPersistentVolume(vol, false))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentClaimReadOnlyFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("glusterfs_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					Glusterfs: &v1.GlusterfsVolumeSource{EndpointsName: "ep", Path: "vol", ReadOnly: false},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ClaimRef: &v1.ObjectReference{
0000000000000000000000000000000000000000;;					Name: "claimA",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claimA",
0000000000000000000000000000000000000000;;				Namespace: "nsA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				VolumeName: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PersistentVolumeClaimStatus{
0000000000000000000000000000000000000000;;				Phase: v1.ClaimBound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep := &v1.Endpoints{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace: "nsA",
0000000000000000000000000000000000000000;;				Name:      "ep",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Subsets: []v1.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []v1.EndpointAddress{{IP: "127.0.0.1"}},
0000000000000000000000000000000000000000;;				Ports:     []v1.EndpointPort{{Name: "foo", Port: 80, Protocol: v1.ProtocolTCP}},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(pv, claim, ep)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, client, nil))
0000000000000000000000000000000000000000;;		plug, _ := plugMgr.FindPluginByName(glusterfsPluginName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readOnly bool is supplied by persistent-claim volume source when its mounter creates other volumes
0000000000000000000000000000000000000000;;		spec := volume.NewSpecFromPersistentVolume(pv, true)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Namespace: "nsA", UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, _ := plug.NewMounter(spec, pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !mounter.GetAttributes().ReadOnly {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true for mounter.IsReadOnly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseClassParameters(t *testing.T) {
0000000000000000000000000000000000000000;;		secret := v1.Secret{
0000000000000000000000000000000000000000;;			Type: "kubernetes.io/glusterfs",
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"data": []byte("mypassword"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name         string
0000000000000000000000000000000000000000;;			parameters   map[string]string
0000000000000000000000000000000000000000;;			secret       *v1.Secret
0000000000000000000000000000000000000000;;			expectError  bool
0000000000000000000000000000000000000000;;			expectConfig *provisionerConfig
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"password",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":     "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restuser":    "admin",
0000000000000000000000000000000000000000;;					"restuserkey": "password",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,   // secret
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:         "https://localhost:8080",
0000000000000000000000000000000000000000;;					user:        "admin",
0000000000000000000000000000000000000000;;					userKey:     "password",
0000000000000000000000000000000000000000;;					secretValue: "password",
0000000000000000000000000000000000000000;;					gidMin:      2000,
0000000000000000000000000000000000000000;;					gidMax:      2147483647,
0000000000000000000000000000000000000000;;					volumeType:  gapi.VolumeDurabilityInfo{Type: "replicate", Replicate: gapi.ReplicaDurability{Replica: 3}, Disperse: gapi.DisperseDurability{Data: 0, Redundancy: 0}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"secret",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restuser":        "admin",
0000000000000000000000000000000000000000;;					"secretname":      "mysecret",
0000000000000000000000000000000000000000;;					"secretnamespace": "default",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:             "https://localhost:8080",
0000000000000000000000000000000000000000;;					user:            "admin",
0000000000000000000000000000000000000000;;					secretName:      "mysecret",
0000000000000000000000000000000000000000;;					secretNamespace: "default",
0000000000000000000000000000000000000000;;					secretValue:     "mypassword",
0000000000000000000000000000000000000000;;					gidMin:          2000,
0000000000000000000000000000000000000000;;					gidMax:          2147483647,
0000000000000000000000000000000000000000;;					volumeType:      gapi.VolumeDurabilityInfo{Type: "replicate", Replicate: gapi.ReplicaDurability{Replica: 3}, Disperse: gapi.DisperseDurability{Data: 0, Redundancy: 0}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"no authentication",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:        "https://localhost:8080",
0000000000000000000000000000000000000000;;					gidMin:     2000,
0000000000000000000000000000000000000000;;					gidMax:     2147483647,
0000000000000000000000000000000000000000;;					volumeType: gapi.VolumeDurabilityInfo{Type: "replicate", Replicate: gapi.ReplicaDurability{Replica: 3}, Disperse: gapi.DisperseDurability{Data: 0, Redundancy: 0}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"missing secret",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"secretname":      "mysecret",
0000000000000000000000000000000000000000;;					"secretnamespace": "default",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,  // secret
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"secret with no namespace",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":    "https://localhost:8080",
0000000000000000000000000000000000000000;;					"secretname": "mysecret",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"missing url",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"restuser":    "admin",
0000000000000000000000000000000000000000;;					"restuserkey": "password",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,  // secret
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"unknown parameter",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"unknown":     "yes",
0000000000000000000000000000000000000000;;					"resturl":     "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restuser":    "admin",
0000000000000000000000000000000000000000;;					"restuserkey": "password",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,  // secret
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid gidMin #1",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid gidMin #2",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "1999",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid gidMin #3",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "1999",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid gidMax #1",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMax":          "0",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid gidMax #2",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMax":          "1999",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid gidMax #3",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMax":          "1999",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid gidMin:gidMax",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "5001",
0000000000000000000000000000000000000000;;					"gidMax":          "5000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"valid gidMin",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "4000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:        "https://localhost:8080",
0000000000000000000000000000000000000000;;					gidMin:     4000,
0000000000000000000000000000000000000000;;					gidMax:     2147483647,
0000000000000000000000000000000000000000;;					volumeType: gapi.VolumeDurabilityInfo{Type: "replicate", Replicate: gapi.ReplicaDurability{Replica: 3}, Disperse: gapi.DisperseDurability{Data: 0, Redundancy: 0}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"valid gidMax",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMax":          "5000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:        "https://localhost:8080",
0000000000000000000000000000000000000000;;					gidMin:     2000,
0000000000000000000000000000000000000000;;					gidMax:     5000,
0000000000000000000000000000000000000000;;					volumeType: gapi.VolumeDurabilityInfo{Type: "replicate", Replicate: gapi.ReplicaDurability{Replica: 3}, Disperse: gapi.DisperseDurability{Data: 0, Redundancy: 0}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"valid gidMin:gidMax",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "4000",
0000000000000000000000000000000000000000;;					"gidMax":          "5000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:        "https://localhost:8080",
0000000000000000000000000000000000000000;;					gidMin:     4000,
0000000000000000000000000000000000000000;;					gidMax:     5000,
0000000000000000000000000000000000000000;;					volumeType: gapi.VolumeDurabilityInfo{Type: "replicate", Replicate: gapi.ReplicaDurability{Replica: 3}, Disperse: gapi.DisperseDurability{Data: 0, Redundancy: 0}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"valid volumetype: replicate",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "4000",
0000000000000000000000000000000000000000;;					"gidMax":          "5000",
0000000000000000000000000000000000000000;;					"volumetype":      "replicate:4",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:        "https://localhost:8080",
0000000000000000000000000000000000000000;;					gidMin:     4000,
0000000000000000000000000000000000000000;;					gidMax:     5000,
0000000000000000000000000000000000000000;;					volumeType: gapi.VolumeDurabilityInfo{Type: "replicate", Replicate: gapi.ReplicaDurability{Replica: 4}, Disperse: gapi.DisperseDurability{Data: 0, Redundancy: 0}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"valid volumetype: disperse",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"gidMin":          "4000",
0000000000000000000000000000000000000000;;					"gidMax":          "5000",
0000000000000000000000000000000000000000;;					"volumetype":      "disperse:4:2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				false, // expect error
0000000000000000000000000000000000000000;;				&provisionerConfig{
0000000000000000000000000000000000000000;;					url:        "https://localhost:8080",
0000000000000000000000000000000000000000;;					gidMin:     4000,
0000000000000000000000000000000000000000;;					gidMax:     5000,
0000000000000000000000000000000000000000;;					volumeType: gapi.VolumeDurabilityInfo{Type: "disperse", Replicate: gapi.ReplicaDurability{Replica: 0}, Disperse: gapi.DisperseDurability{Data: 4, Redundancy: 2}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid volumetype (disperse) parameter",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"volumetype":      "disperse:4:asd",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid volumetype (replicate) parameter",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"volumetype":      "replicate:asd",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid volumetype: unknown volumetype",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"volumetype":      "dispersereplicate:4:2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid volumetype : negative value",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"resturl":         "https://localhost:8080",
0000000000000000000000000000000000000000;;					"restauthenabled": "false",
0000000000000000000000000000000000000000;;					"volumetype":      "replicate:-1000",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&secret,
0000000000000000000000000000000000000000;;				true, // expect error
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			client := &fake.Clientset{}
0000000000000000000000000000000000000000;;			client.AddReactor("get", "secrets", func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;				if test.secret != nil {
0000000000000000000000000000000000000000;;					return true, test.secret, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("Test %s did not set a secret", test.name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cfg, err := parseClassParameters(test.parameters, client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil && !test.expectError {
0000000000000000000000000000000000000000;;				t.Errorf("Test %s got unexpected error %v", test.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && test.expectError {
0000000000000000000000000000000000000000;;				t.Errorf("test %s expected error and got none", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.expectConfig != nil {
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(cfg, test.expectConfig) {
0000000000000000000000000000000000000000;;					t.Errorf("Test %s returned unexpected data, expected: %+v, got: %+v", test.name, test.expectConfig, cfg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
