0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
8f982c0f13e99e437f191186137a6fc67d5dd2b3;pkg/kubelet/volume/nfs/nfs.go[pkg/kubelet/volume/nfs/nfs.go][pkg/volume/nfs/nfs.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package nfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	// The volumeConfig arg provides the ability to configure recycler behavior.  It is implemented as a pointer to allow nils.
0000000000000000000000000000000000000000;;	// The nfsPlugin is used to store the volumeConfig and give it, when needed, to the func that creates NFS Recyclers.
0000000000000000000000000000000000000000;;	// Tests that exercise recycling should not use this func but instead use ProbeRecyclablePlugins() to override default behavior.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins(volumeConfig volume.VolumeConfig) []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{
0000000000000000000000000000000000000000;;			&nfsPlugin{
0000000000000000000000000000000000000000;;				host:   nil,
0000000000000000000000000000000000000000;;				config: volumeConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nfsPlugin struct {
0000000000000000000000000000000000000000;;		host   volume.VolumeHost
0000000000000000000000000000000000000000;;		config volume.VolumeConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &nfsPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &nfsPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.RecyclableVolumePlugin = &nfsPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		nfsPluginName = "kubernetes.io/nfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return nfsPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%v/%v",
0000000000000000000000000000000000000000;;			volumeSource.Server,
0000000000000000000000000000000000000000;;			volumeSource.Path), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.NFS != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.NFS != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;			v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;			v1.ReadWriteMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) newMounterInternal(spec *volume.Spec, pod *v1.Pod, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		source, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &nfsMounter{
0000000000000000000000000000000000000000;;			nfs: &nfs{
0000000000000000000000000000000000000000;;				volName: spec.Name(),
0000000000000000000000000000000000000000;;				mounter: mounter,
0000000000000000000000000000000000000000;;				pod:     pod,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			server:       source.Server,
0000000000000000000000000000000000000000;;			exportPath:   source.Path,
0000000000000000000000000000000000000000;;			readOnly:     readOnly,
0000000000000000000000000000000000000000;;			mountOptions: volume.MountOptionFromSpec(spec),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) newUnmounterInternal(volName string, podUID types.UID, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &nfsUnmounter{&nfs{
0000000000000000000000000000000000000000;;			volName: volName,
0000000000000000000000000000000000000000;;			mounter: mounter,
0000000000000000000000000000000000000000;;			pod:     &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: podUID}},
0000000000000000000000000000000000000000;;			plugin:  plugin,
0000000000000000000000000000000000000000;;		}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recycle recycles/scrubs clean an NFS volume.
0000000000000000000000000000000000000000;;	// Recycle blocks until the pod has completed or any error occurs.
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) Recycle(pvName string, spec *volume.Spec, eventRecorder volume.RecycleEventRecorder) error {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume == nil || spec.PersistentVolume.Spec.NFS == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("spec.PersistentVolumeSource.NFS is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := plugin.config.RecyclerPodTemplate
0000000000000000000000000000000000000000;;		timeout := volume.CalculateTimeoutForVolume(plugin.config.RecyclerMinimumTimeout, plugin.config.RecyclerTimeoutIncrement, spec.PersistentVolume)
0000000000000000000000000000000000000000;;		// overrides
0000000000000000000000000000000000000000;;		pod.Spec.ActiveDeadlineSeconds = &timeout
0000000000000000000000000000000000000000;;		pod.GenerateName = "pv-recycler-nfs-"
0000000000000000000000000000000000000000;;		pod.Spec.Volumes[0].VolumeSource = v1.VolumeSource{
0000000000000000000000000000000000000000;;			NFS: &v1.NFSVolumeSource{
0000000000000000000000000000000000000000;;				Server: spec.PersistentVolume.Spec.NFS.Server,
0000000000000000000000000000000000000000;;				Path:   spec.PersistentVolume.Spec.NFS.Path,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.RecycleVolumeByWatchingPodUntilCompletion(pvName, pod, plugin.host.GetKubeClient(), eventRecorder)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *nfsPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		nfsVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				NFS: &v1.NFSVolumeSource{
0000000000000000000000000000000000000000;;					Path: volumeName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(nfsVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NFS volumes represent a bare host file or directory mount of an NFS export.
0000000000000000000000000000000000000000;;	type nfs struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		pod     *v1.Pod
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		plugin  *nfsPlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nfsVolume *nfs) GetPath() string {
0000000000000000000000000000000000000000;;		name := nfsPluginName
0000000000000000000000000000000000000000;;		return nfsVolume.plugin.host.GetPodVolumeDir(nfsVolume.pod.UID, strings.EscapeQualifiedNameForDisk(name), nfsVolume.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (nfsMounter *nfsMounter) CanMount() error {
0000000000000000000000000000000000000000;;		exe := exec.New()
0000000000000000000000000000000000000000;;		switch runtime.GOOS {
0000000000000000000000000000000000000000;;		case "linux":
0000000000000000000000000000000000000000;;			if _, err := exe.Command("/bin/ls", "/sbin/mount.nfs").CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Required binary /sbin/mount.nfs is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := exe.Command("/bin/ls", "/sbin/mount.nfs4").CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Required binary /sbin/mount.nfs4 is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case "darwin":
0000000000000000000000000000000000000000;;			if _, err := exe.Command("/bin/ls", "/sbin/mount_nfs").CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Required binary /sbin/mount_nfs is missing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nfsMounter struct {
0000000000000000000000000000000000000000;;		*nfs
0000000000000000000000000000000000000000;;		server       string
0000000000000000000000000000000000000000;;		exportPath   string
0000000000000000000000000000000000000000;;		readOnly     bool
0000000000000000000000000000000000000000;;		mountOptions []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &nfsMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *nfsMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         false,
0000000000000000000000000000000000000000;;			SupportsSELinux: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *nfsMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *nfsMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("NFS mount set up: %s %v %v", dir, !notMnt, err)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		source := fmt.Sprintf("%s:%s", b.server, b.exportPath)
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mountOptions := volume.JoinMountOptions(b.mountOptions, options)
0000000000000000000000000000000000000000;;		err = b.mounter.Mount(source, dir, "nfs", mountOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;			if mntErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !notMnt {
0000000000000000000000000000000000000000;;				if mntErr = b.mounter.Unmount(dir); mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to unmount: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;				if mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !notMnt {
0000000000000000000000000000000000000000;;					// This is very odd, we don't expect it.  We'll try again next sync loop.
0000000000000000000000000000000000000000;;					glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.", dir)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Remove(dir)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &nfsUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nfsUnmounter struct {
0000000000000000000000000000000000000000;;		*nfs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *nfsUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *nfsUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return util.UnmountPath(dir, c.mounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.NFSVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.NFS != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.NFS, spec.Volume.NFS.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.NFS != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.NFS, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a NFS volume type")
0000000000000000000000000000000000000000;;	}
