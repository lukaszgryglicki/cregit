0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
90827a6c1ad71df24e240f9217dba5fe28b268b6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package downwardapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/v1/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/fieldpath"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeVolumePlugins is the entry point for plugin detection in a package.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&downwardAPIPlugin{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		downwardAPIPluginName = "kubernetes.io/downward-api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downwardAPIPlugin implements the VolumePlugin interface.
0000000000000000000000000000000000000000;;	type downwardAPIPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &downwardAPIPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrappedVolumeSpec() volume.Spec {
0000000000000000000000000000000000000000;;		return volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{Medium: v1.StorageMediumMemory}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return downwardAPIPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _ := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if volumeSource == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Spec does not reference a DownwardAPI volume type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return user defined volume name, since this is an ephemeral volume type
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return spec.Volume != nil && spec.Volume.DownwardAPI != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		v := &downwardAPIVolume{
0000000000000000000000000000000000000000;;			volName: spec.Name(),
0000000000000000000000000000000000000000;;			items:   spec.Volume.DownwardAPI.Items,
0000000000000000000000000000000000000000;;			pod:     pod,
0000000000000000000000000000000000000000;;			podUID:  pod.UID,
0000000000000000000000000000000000000000;;			plugin:  plugin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &downwardAPIVolumeMounter{
0000000000000000000000000000000000000000;;			downwardAPIVolume: v,
0000000000000000000000000000000000000000;;			source:            *spec.Volume.DownwardAPI,
0000000000000000000000000000000000000000;;			opts:              &opts,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &downwardAPIVolumeUnmounter{
0000000000000000000000000000000000000000;;			&downwardAPIVolume{
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *downwardAPIPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		downwardAPIVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				DownwardAPI: &v1.DownwardAPIVolumeSource{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(downwardAPIVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downwardAPIVolume retrieves downward API data and placing them into the volume on the host.
0000000000000000000000000000000000000000;;	type downwardAPIVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		items   []v1.DownwardAPIVolumeFile
0000000000000000000000000000000000000000;;		pod     *v1.Pod
0000000000000000000000000000000000000000;;		podUID  types.UID // TODO: remove this redundancy as soon NewUnmounter func will have *v1.POD and not only types.UID
0000000000000000000000000000000000000000;;		plugin  *downwardAPIPlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downwardAPIVolumeMounter fetches info from downward API from the pod
0000000000000000000000000000000000000000;;	// and dumps it in files
0000000000000000000000000000000000000000;;	type downwardAPIVolumeMounter struct {
0000000000000000000000000000000000000000;;		*downwardAPIVolume
0000000000000000000000000000000000000000;;		source v1.DownwardAPIVolumeSource
0000000000000000000000000000000000000000;;		opts   *volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downwardAPIVolumeMounter implements volume.Mounter interface
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &downwardAPIVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downward API volumes are always ReadOnlyManaged
0000000000000000000000000000000000000000;;	func (d *downwardAPIVolume) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        true,
0000000000000000000000000000000000000000;;			Managed:         true,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *downwardAPIVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp puts in place the volume plugin.
0000000000000000000000000000000000000000;;	// This function is not idempotent by design. We want the data to be refreshed periodically.
0000000000000000000000000000000000000000;;	// The internal sync interval of kubelet will drive the refresh of data.
0000000000000000000000000000000000000000;;	// TODO: Add volume specific ticker and refresh loop
0000000000000000000000000000000000000000;;	func (b *downwardAPIVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *downwardAPIVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Setting up a downwardAPI volume %v for pod %v/%v at %v", b.volName, b.pod.Namespace, b.pod.Name, dir)
0000000000000000000000000000000000000000;;		// Wrap EmptyDir. Here we rely on the idempotency of the wrapped plugin to avoid repeatedly mounting
0000000000000000000000000000000000000000;;		wrapped, err := b.plugin.host.NewWrapperMounter(b.volName, wrappedVolumeSpec(), b.pod, *b.opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Couldn't setup downwardAPI volume %v for pod %v/%v: %s", b.volName, b.pod.Namespace, b.pod.Name, err.Error())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wrapped.SetUpAt(dir, fsGroup); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to setup downwardAPI volume %v for pod %v/%v: %s", b.volName, b.pod.Namespace, b.pod.Name, err.Error())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := CollectData(b.source.Items, b.pod, b.plugin.host, b.source.DefaultMode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error preparing data for downwardAPI volume %v for pod %v/%v: %s", b.volName, b.pod.Namespace, b.pod.Name, err.Error())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writerContext := fmt.Sprintf("pod %v/%v volume %v", b.pod.Namespace, b.pod.Name, b.volName)
0000000000000000000000000000000000000000;;		writer, err := volumeutil.NewAtomicWriter(dir, writerContext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error creating atomic writer: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = writer.Write(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error writing payload to dir: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error applying volume ownership settings for group: %v", fsGroup)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectData collects requested downwardAPI in data map.
0000000000000000000000000000000000000000;;	// Map's key is the requested name of file to dump
0000000000000000000000000000000000000000;;	// Map's value is the (sorted) content of the field to be dumped in the file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: this function is exported so that it can be called from the projection volume driver
0000000000000000000000000000000000000000;;	func CollectData(items []v1.DownwardAPIVolumeFile, pod *v1.Pod, host volume.VolumeHost, defaultMode *int32) (map[string]volumeutil.FileProjection, error) {
0000000000000000000000000000000000000000;;		if defaultMode == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No defaultMode used, not even the default value for it")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errlist := []error{}
0000000000000000000000000000000000000000;;		data := make(map[string]volumeutil.FileProjection)
0000000000000000000000000000000000000000;;		for _, fileInfo := range items {
0000000000000000000000000000000000000000;;			var fileProjection volumeutil.FileProjection
0000000000000000000000000000000000000000;;			fPath := path.Clean(fileInfo.Path)
0000000000000000000000000000000000000000;;			if fileInfo.Mode != nil {
0000000000000000000000000000000000000000;;				fileProjection.Mode = *fileInfo.Mode
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fileProjection.Mode = *defaultMode
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fileInfo.FieldRef != nil {
0000000000000000000000000000000000000000;;				// TODO: unify with Kubelet.podFieldSelectorRuntimeValue
0000000000000000000000000000000000000000;;				if values, err := fieldpath.ExtractFieldPathAsString(pod, fileInfo.FieldRef.FieldPath); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Unable to extract field %s: %s", fileInfo.FieldRef.FieldPath, err.Error())
0000000000000000000000000000000000000000;;					errlist = append(errlist, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fileProjection.Data = []byte(sortLines(values))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if fileInfo.ResourceFieldRef != nil {
0000000000000000000000000000000000000000;;				containerName := fileInfo.ResourceFieldRef.ContainerName
0000000000000000000000000000000000000000;;				nodeAllocatable, err := host.GetNodeAllocatable()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errlist = append(errlist, err)
0000000000000000000000000000000000000000;;				} else if values, err := resource.ExtractResourceValueByContainerNameAndNodeAllocatable(api.Scheme, fileInfo.ResourceFieldRef, pod, containerName, nodeAllocatable); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Unable to extract field %s: %s", fileInfo.ResourceFieldRef.Resource, err.Error())
0000000000000000000000000000000000000000;;					errlist = append(errlist, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fileProjection.Data = []byte(sortLines(values))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			data[fPath] = fileProjection
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data, utilerrors.NewAggregate(errlist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sortLines sorts the strings generated from map based data
0000000000000000000000000000000000000000;;	// (annotations and labels)
0000000000000000000000000000000000000000;;	func sortLines(values string) string {
0000000000000000000000000000000000000000;;		splitted := strings.Split(values, "\n")
0000000000000000000000000000000000000000;;		sort.Strings(splitted)
0000000000000000000000000000000000000000;;		return strings.Join(splitted, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *downwardAPIVolume) GetPath() string {
0000000000000000000000000000000000000000;;		return d.plugin.host.GetPodVolumeDir(d.podUID, utilstrings.EscapeQualifiedNameForDisk(downwardAPIPluginName), d.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downwardAPIVolumeCleaner handles cleaning up downwardAPI volumes
0000000000000000000000000000000000000000;;	type downwardAPIVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*downwardAPIVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downwardAPIVolumeUnmounter implements volume.Unmounter interface
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &downwardAPIVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *downwardAPIVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *downwardAPIVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return volume.UnmountViaEmptyDir(dir, c.plugin.host, c.volName, wrappedVolumeSpec(), c.podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *downwardAPIVolumeMounter) getMetaDir() string {
0000000000000000000000000000000000000000;;		return path.Join(b.plugin.host.GetPodPluginDir(b.podUID, utilstrings.EscapeQualifiedNameForDisk(downwardAPIPluginName)), b.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.DownwardAPIVolumeSource, bool) {
0000000000000000000000000000000000000000;;		var readOnly bool
0000000000000000000000000000000000000000;;		var volumeSource *v1.DownwardAPIVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.DownwardAPI != nil {
0000000000000000000000000000000000000000;;			volumeSource = spec.Volume.DownwardAPI
0000000000000000000000000000000000000000;;			readOnly = spec.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource, readOnly
0000000000000000000000000000000000000000;;	}
