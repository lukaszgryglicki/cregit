0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
90827a6c1ad71df24e240f9217dba5fe28b268b6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package downwardapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/fieldpath"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/empty_dir"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		downwardAPIDir = "..data"
0000000000000000000000000000000000000000;;		testPodUID     = types.UID("test_pod_uid")
0000000000000000000000000000000000000000;;		testNamespace  = "test_metadata_namespace"
0000000000000000000000000000000000000000;;		testName       = "test_metadata_name"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestHost(t *testing.T, clientset clientset.Interface) (string, volume.VolumeHost) {
0000000000000000000000000000000000000000;;		tempDir, err := utiltesting.MkTmpdir("downwardApi_volume_test.")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("can't make a temp rootdir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tempDir, volumetest.NewFakeVolumeHost(tempDir, clientset, empty_dir.ProbeVolumePlugins())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		pluginMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		tmpDir, host := newTestHost(t, nil)
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		pluginMgr.InitPlugins(ProbeVolumePlugins(), host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugin, err := pluginMgr.FindPluginByName(downwardAPIPluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plugin.GetPluginName() != downwardAPIPluginName {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plugin.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDownwardAPI(t *testing.T) {
0000000000000000000000000000000000000000;;		labels1 := map[string]string{
0000000000000000000000000000000000000000;;			"key1": "value1",
0000000000000000000000000000000000000000;;			"key2": "value2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels2 := map[string]string{
0000000000000000000000000000000000000000;;			"key1": "value1",
0000000000000000000000000000000000000000;;			"key2": "value2",
0000000000000000000000000000000000000000;;			"key3": "value3",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations := map[string]string{
0000000000000000000000000000000000000000;;			"a1": "value1",
0000000000000000000000000000000000000000;;			"a2": "value2",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name           string
0000000000000000000000000000000000000000;;			files          map[string]string
0000000000000000000000000000000000000000;;			modes          map[string]int32
0000000000000000000000000000000000000000;;			podLabels      map[string]string
0000000000000000000000000000000000000000;;			podAnnotations map[string]string
0000000000000000000000000000000000000000;;			steps          []testStep
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "test_labels",
0000000000000000000000000000000000000000;;				files:     map[string]string{"labels": "metadata.labels"},
0000000000000000000000000000000000000000;;				podLabels: labels1,
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					// for steps that involve files, stepName is also
0000000000000000000000000000000000000000;;					// used as the name of the file to verify
0000000000000000000000000000000000000000;;					verifyMapInFile{stepName{"labels"}, labels1},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "test_annotations",
0000000000000000000000000000000000000000;;				files:          map[string]string{"annotations": "metadata.annotations"},
0000000000000000000000000000000000000000;;				podAnnotations: annotations,
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					verifyMapInFile{stepName{"annotations"}, annotations},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "test_name",
0000000000000000000000000000000000000000;;				files: map[string]string{"name_file_name": "metadata.name"},
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					verifyLinesInFile{stepName{"name_file_name"}, testName},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "test_namespace",
0000000000000000000000000000000000000000;;				files: map[string]string{"namespace_file_name": "metadata.namespace"},
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					verifyLinesInFile{stepName{"namespace_file_name"}, testNamespace},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "test_write_twice_no_update",
0000000000000000000000000000000000000000;;				files:     map[string]string{"labels": "metadata.labels"},
0000000000000000000000000000000000000000;;				podLabels: labels1,
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					reSetUp{stepName{"resetup"}, false, nil},
0000000000000000000000000000000000000000;;					verifyMapInFile{stepName{"labels"}, labels1},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "test_write_twice_with_update",
0000000000000000000000000000000000000000;;				files:     map[string]string{"labels": "metadata.labels"},
0000000000000000000000000000000000000000;;				podLabels: labels1,
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					reSetUp{stepName{"resetup"}, true, labels2},
0000000000000000000000000000000000000000;;					verifyMapInFile{stepName{"labels"}, labels2},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "test_write_with_unix_path",
0000000000000000000000000000000000000000;;				files: map[string]string{
0000000000000000000000000000000000000000;;					"these/are/my/labels":        "metadata.labels",
0000000000000000000000000000000000000000;;					"these/are/your/annotations": "metadata.annotations",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				podLabels:      labels1,
0000000000000000000000000000000000000000;;				podAnnotations: annotations,
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					verifyMapInFile{stepName{"these/are/my/labels"}, labels1},
0000000000000000000000000000000000000000;;					verifyMapInFile{stepName{"these/are/your/annotations"}, annotations},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "test_write_with_two_consecutive_slashes_in_the_path",
0000000000000000000000000000000000000000;;				files:     map[string]string{"this//labels": "metadata.labels"},
0000000000000000000000000000000000000000;;				podLabels: labels1,
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					verifyMapInFile{stepName{"this/labels"}, labels1},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "test_default_mode",
0000000000000000000000000000000000000000;;				files: map[string]string{"name_file_name": "metadata.name"},
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					verifyMode{stepName{"name_file_name"}, 0644},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:  "test_item_mode",
0000000000000000000000000000000000000000;;				files: map[string]string{"name_file_name": "metadata.name"},
0000000000000000000000000000000000000000;;				modes: map[string]int32{"name_file_name": 0400},
0000000000000000000000000000000000000000;;				steps: []testStep{
0000000000000000000000000000000000000000;;					verifyMode{stepName{"name_file_name"}, 0400},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			test := newDownwardAPITest(t, testCase.name, testCase.files, testCase.podLabels, testCase.podAnnotations, testCase.modes)
0000000000000000000000000000000000000000;;			for _, step := range testCase.steps {
0000000000000000000000000000000000000000;;				test.t.Logf("Test case: %q Step: %q", testCase.name, step.getName())
0000000000000000000000000000000000000000;;				step.run(test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			test.tearDown()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type downwardAPITest struct {
0000000000000000000000000000000000000000;;		t          *testing.T
0000000000000000000000000000000000000000;;		name       string
0000000000000000000000000000000000000000;;		plugin     volume.VolumePlugin
0000000000000000000000000000000000000000;;		pod        *v1.Pod
0000000000000000000000000000000000000000;;		mounter    volume.Mounter
0000000000000000000000000000000000000000;;		volumePath string
0000000000000000000000000000000000000000;;		rootDir    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDownwardAPITest(t *testing.T, name string, volumeFiles, podLabels, podAnnotations map[string]string, modes map[string]int32) *downwardAPITest {
0000000000000000000000000000000000000000;;		defaultMode := int32(0644)
0000000000000000000000000000000000000000;;		var files []v1.DownwardAPIVolumeFile
0000000000000000000000000000000000000000;;		for path, fieldPath := range volumeFiles {
0000000000000000000000000000000000000000;;			file := v1.DownwardAPIVolumeFile{
0000000000000000000000000000000000000000;;				Path: path,
0000000000000000000000000000000000000000;;				FieldRef: &v1.ObjectFieldSelector{
0000000000000000000000000000000000000000;;					FieldPath: fieldPath,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mode, found := modes[path]; found {
0000000000000000000000000000000000000000;;				file.Mode = &mode
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			files = append(files, file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podMeta := metav1.ObjectMeta{
0000000000000000000000000000000000000000;;			Name:        testName,
0000000000000000000000000000000000000000;;			Namespace:   testNamespace,
0000000000000000000000000000000000000000;;			Labels:      podLabels,
0000000000000000000000000000000000000000;;			Annotations: podAnnotations,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientset := fake.NewSimpleClientset(&v1.Pod{ObjectMeta: podMeta})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pluginMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		rootDir, host := newTestHost(t, clientset)
0000000000000000000000000000000000000000;;		pluginMgr.InitPlugins(ProbeVolumePlugins(), host)
0000000000000000000000000000000000000000;;		plugin, err := pluginMgr.FindPluginByName(downwardAPIPluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSpec := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				DownwardAPI: &v1.DownwardAPIVolumeSource{
0000000000000000000000000000000000000000;;					DefaultMode: &defaultMode,
0000000000000000000000000000000000000000;;					Items:       files,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		podMeta.UID = testPodUID
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: podMeta}
0000000000000000000000000000000000000000;;		mounter, err := plugin.NewMounter(volume.NewSpecFromVolume(volumeSpec), pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumePath := mounter.GetPath()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = mounter.SetUp(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to setup volume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// downwardAPI volume should create its own empty wrapper path
0000000000000000000000000000000000000000;;		podWrapperMetadataDir := fmt.Sprintf("%v/pods/%v/plugins/kubernetes.io~empty-dir/wrapped_%v", rootDir, testPodUID, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := os.Stat(podWrapperMetadataDir); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed, empty-dir wrapper path was not created: %s", podWrapperMetadataDir)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &downwardAPITest{
0000000000000000000000000000000000000000;;			t:          t,
0000000000000000000000000000000000000000;;			plugin:     plugin,
0000000000000000000000000000000000000000;;			pod:        pod,
0000000000000000000000000000000000000000;;			mounter:    mounter,
0000000000000000000000000000000000000000;;			volumePath: volumePath,
0000000000000000000000000000000000000000;;			rootDir:    rootDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (test *downwardAPITest) tearDown() {
0000000000000000000000000000000000000000;;		unmounter, err := test.plugin.NewUnmounter(test.name, testPodUID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			test.t.Errorf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unmounter == nil {
0000000000000000000000000000000000000000;;			test.t.Errorf("Got a nil Unmounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := unmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			test.t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(test.volumePath); err == nil {
0000000000000000000000000000000000000000;;			test.t.Errorf("TearDown() failed, volume path still exists: %s", test.volumePath)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			test.t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.RemoveAll(test.rootDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testStep represents a named step of downwardAPITest.
0000000000000000000000000000000000000000;;	// For steps that deal with files, step name also serves
0000000000000000000000000000000000000000;;	// as the name of the file that's used by the step.
0000000000000000000000000000000000000000;;	type testStep interface {
0000000000000000000000000000000000000000;;		getName() string
0000000000000000000000000000000000000000;;		run(*downwardAPITest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stepName struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (step stepName) getName() string { return step.name }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doVerifyLinesInFile(t *testing.T, volumePath, filename string, expected string) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(path.Join(volumePath, filename))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf(err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actualStr := sortLines(string(data))
0000000000000000000000000000000000000000;;		expectedStr := sortLines(expected)
0000000000000000000000000000000000000000;;		if actualStr != expectedStr {
0000000000000000000000000000000000000000;;			t.Errorf("Found `%s`, expected `%s`", actualStr, expectedStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type verifyLinesInFile struct {
0000000000000000000000000000000000000000;;		stepName
0000000000000000000000000000000000000000;;		expected string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (step verifyLinesInFile) run(test *downwardAPITest) {
0000000000000000000000000000000000000000;;		doVerifyLinesInFile(test.t, test.volumePath, step.name, step.expected)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type verifyMapInFile struct {
0000000000000000000000000000000000000000;;		stepName
0000000000000000000000000000000000000000;;		expected map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (step verifyMapInFile) run(test *downwardAPITest) {
0000000000000000000000000000000000000000;;		doVerifyLinesInFile(test.t, test.volumePath, step.name, fieldpath.FormatMap(step.expected))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type verifyMode struct {
0000000000000000000000000000000000000000;;		stepName
0000000000000000000000000000000000000000;;		expectedMode int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (step verifyMode) run(test *downwardAPITest) {
0000000000000000000000000000000000000000;;		fileInfo, err := os.Stat(path.Join(test.volumePath, step.name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			test.t.Errorf(err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actualMode := fileInfo.Mode()
0000000000000000000000000000000000000000;;		expectedMode := os.FileMode(step.expectedMode)
0000000000000000000000000000000000000000;;		if actualMode != expectedMode {
0000000000000000000000000000000000000000;;			test.t.Errorf("Found mode `%v` expected %v", actualMode, expectedMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reSetUp struct {
0000000000000000000000000000000000000000;;		stepName
0000000000000000000000000000000000000000;;		linkShouldChange bool
0000000000000000000000000000000000000000;;		newLabels        map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (step reSetUp) run(test *downwardAPITest) {
0000000000000000000000000000000000000000;;		if step.newLabels != nil {
0000000000000000000000000000000000000000;;			test.pod.ObjectMeta.Labels = step.newLabels
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentTarget, err := os.Readlink(path.Join(test.volumePath, downwardAPIDir))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			test.t.Errorf("labels file should be a link... %s\n", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now re-run Setup
0000000000000000000000000000000000000000;;		if err = test.mounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			test.t.Errorf("Failed to re-setup volume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the link of the link
0000000000000000000000000000000000000000;;		currentTarget2, err := os.Readlink(path.Join(test.volumePath, downwardAPIDir))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			test.t.Errorf(".current should be a link... %s\n", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case step.linkShouldChange && currentTarget2 == currentTarget:
0000000000000000000000000000000000000000;;			test.t.Errorf("Got and update between the two Setup... Target link should NOT be the same\n")
0000000000000000000000000000000000000000;;		case !step.linkShouldChange && currentTarget2 != currentTarget:
0000000000000000000000000000000000000000;;			test.t.Errorf("No update between the two Setup... Target link should be the same %s %s\n",
0000000000000000000000000000000000000000;;				currentTarget, currentTarget2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
