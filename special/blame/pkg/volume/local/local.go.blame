0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
c212d90faec482b018e0835277ee4ca5060c9e1a;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package local
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&localVolumePlugin{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type localVolumePlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &localVolumePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &localVolumePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		localVolumePluginName = "kubernetes.io/local-volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return localVolumePluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		// This volume is only supported as a PersistentVolumeSource, so the PV name is unique
0000000000000000000000000000000000000000;;		return spec.Name(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		// This volume is only supported as a PersistentVolumeSource
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Local != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		// The current meaning of AccessMode is how many nodes can attach to it, not how many pods can mount it
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.LocalVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Local != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.Local, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a Local volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		volumeSource, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &localVolumeMounter{
0000000000000000000000000000000000000000;;			localVolume: &localVolume{
0000000000000000000000000000000000000000;;				podUID:     pod.UID,
0000000000000000000000000000000000000000;;				volName:    spec.Name(),
0000000000000000000000000000000000000000;;				mounter:    plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;				plugin:     plugin,
0000000000000000000000000000000000000000;;				globalPath: volumeSource.Path,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			readOnly: readOnly,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &localVolumeUnmounter{
0000000000000000000000000000000000000000;;			localVolume: &localVolume{
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				mounter: plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: check if no path and no topology constraints are ok
0000000000000000000000000000000000000000;;	func (plugin *localVolumePlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		localVolume := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: volumeName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					Local: &v1.LocalVolumeSource{
0000000000000000000000000000000000000000;;						Path: "",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromPersistentVolume(localVolume, false), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Local volumes represent a local directory on a node.
0000000000000000000000000000000000000000;;	// The directory at the globalPath will be bind-mounted to the pod's directory
0000000000000000000000000000000000000000;;	type localVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		// Global path to the volume
0000000000000000000000000000000000000000;;		globalPath string
0000000000000000000000000000000000000000;;		// Mounter interface that provides system calls to mount the global path to the pod local path.
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		plugin  *localVolumePlugin
0000000000000000000000000000000000000000;;		// TODO: add metrics
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *localVolume) GetPath() string {
0000000000000000000000000000000000000000;;		return l.plugin.host.GetPodVolumeDir(l.podUID, strings.EscapeQualifiedNameForDisk(localVolumePluginName), l.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type localVolumeMounter struct {
0000000000000000000000000000000000000000;;		*localVolume
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &localVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *localVolumeMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        m.readOnly,
0000000000000000000000000000000000000000;;			Managed:         !m.readOnly,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanMount checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (m *localVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp bind mounts the directory to the volume path
0000000000000000000000000000000000000000;;	func (m *localVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return m.SetUpAt(m.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt bind mounts the directory to the volume path and sets up volume ownership
0000000000000000000000000000000000000000;;	func (m *localVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		if m.globalPath == "" {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("LocalVolume volume %q path is empty", m.volName)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := validation.ValidatePathNoBacksteps(m.globalPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid path: %s %v", m.globalPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		notMnt, err := m.mounter.IsNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("LocalVolume mount setup: PodDir(%s) VolDir(%s) Mounted(%t) Error(%v), ReadOnly(%t)", dir, m.globalPath, !notMnt, err, m.readOnly)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot validate mount point: %s %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("mkdir failed on disk %s (%v)", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a bind mount to the full path to allow duplicate mounts of the same volume.
0000000000000000000000000000000000000000;;		options := []string{"bind"}
0000000000000000000000000000000000000000;;		if m.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("attempting to mount %s", dir)
0000000000000000000000000000000000000000;;		err = m.mounter.Mount(m.globalPath, dir, "", options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Mount of volume %s failed: %v", dir, err)
0000000000000000000000000000000000000000;;			notMnt, mntErr := m.mounter.IsNotMountPoint(dir)
0000000000000000000000000000000000000000;;			if mntErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("IsNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !notMnt {
0000000000000000000000000000000000000000;;				if mntErr = m.mounter.Unmount(dir); mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to unmount: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt, mntErr = m.mounter.IsNotMountPoint(dir)
0000000000000000000000000000000000000000;;				if mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("IsNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !notMnt {
0000000000000000000000000000000000000000;;					// This is very odd, we don't expect it.  We'll try again next sync loop.
0000000000000000000000000000000000000000;;					glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.", dir)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Remove(dir)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !m.readOnly {
0000000000000000000000000000000000000000;;			// TODO: how to prevent multiple mounts with conflicting fsGroup?
0000000000000000000000000000000000000000;;			return volume.SetVolumeOwnership(m, fsGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type localVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*localVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &localVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDown unmounts the bind mount
0000000000000000000000000000000000000000;;	func (u *localVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return u.TearDownAt(u.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDownAt unmounts the bind mount
0000000000000000000000000000000000000000;;	func (u *localVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Unmounting volume %q at path %q\n", u.volName, dir)
0000000000000000000000000000000000000000;;		return util.UnmountMountPoint(dir, u.mounter, true) /* extensiveMountPointCheck = true */
0000000000000000000000000000000000000000;;	}
