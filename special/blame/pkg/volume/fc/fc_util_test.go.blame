0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2c60d5f2baa7aef5594f36146959ea933ad05af0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeFileInfo struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Name() string {
0000000000000000000000000000000000000000;;		return fi.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Size() int64 {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Mode() os.FileMode {
0000000000000000000000000000000000000000;;		return 777
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) ModTime() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) IsDir() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Sys() interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeIOHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *fakeIOHandler) ReadDir(dirname string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		switch dirname {
0000000000000000000000000000000000000000;;		case "/dev/disk/by-path/":
0000000000000000000000000000000000000000;;			f := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "pci-0000:41:00.0-fc-0x500a0981891b8dc5-lun-0",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []os.FileInfo{f}, nil
0000000000000000000000000000000000000000;;		case "/sys/block/":
0000000000000000000000000000000000000000;;			f := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "dm-1",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []os.FileInfo{f}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *fakeIOHandler) Lstat(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *fakeIOHandler) EvalSymlinks(path string) (string, error) {
0000000000000000000000000000000000000000;;		return "/dev/sda", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *fakeIOHandler) WriteFile(filename string, data []byte, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIoHandler(t *testing.T) {
0000000000000000000000000000000000000000;;		io := &fakeIOHandler{}
0000000000000000000000000000000000000000;;		wwns := []string{"500a0981891b8dc5"}
0000000000000000000000000000000000000000;;		lun := "0"
0000000000000000000000000000000000000000;;		disk, dm := searchDisk(wwns, lun, io)
0000000000000000000000000000000000000000;;		// if no disk matches input wwn and lun, exit
0000000000000000000000000000000000000000;;		if disk == "" && dm == "" {
0000000000000000000000000000000000000000;;			t.Errorf("no fc disk found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
