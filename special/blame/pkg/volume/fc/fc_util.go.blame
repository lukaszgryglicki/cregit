0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2c60d5f2baa7aef5594f36146959ea933ad05af0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ioHandler interface {
0000000000000000000000000000000000000000;;		ReadDir(dirname string) ([]os.FileInfo, error)
0000000000000000000000000000000000000000;;		Lstat(name string) (os.FileInfo, error)
0000000000000000000000000000000000000000;;		EvalSymlinks(path string) (string, error)
0000000000000000000000000000000000000000;;		WriteFile(filename string, data []byte, perm os.FileMode) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type osIOHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *osIOHandler) ReadDir(dirname string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return ioutil.ReadDir(dirname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (handler *osIOHandler) Lstat(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return os.Lstat(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (handler *osIOHandler) EvalSymlinks(path string) (string, error) {
0000000000000000000000000000000000000000;;		return filepath.EvalSymlinks(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (handler *osIOHandler) WriteFile(filename string, data []byte, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(filename, data, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// given a disk path like /dev/sdx, find the devicemapper parent
0000000000000000000000000000000000000000;;	// TODO #23192 Convert this code to use the generic code in ../util
0000000000000000000000000000000000000000;;	// which is used by the iSCSI implementation
0000000000000000000000000000000000000000;;	func findMultipathDeviceMapper(disk string, io ioHandler) string {
0000000000000000000000000000000000000000;;		sys_path := "/sys/block/"
0000000000000000000000000000000000000000;;		if dirs, err := io.ReadDir(sys_path); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				name := f.Name()
0000000000000000000000000000000000000000;;				if strings.HasPrefix(name, "dm-") {
0000000000000000000000000000000000000000;;					if _, err1 := io.Lstat(sys_path + name + "/slaves/" + disk); err1 == nil {
0000000000000000000000000000000000000000;;						return "/dev/" + name
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// given a wwn and lun, find the device and associated devicemapper parent
0000000000000000000000000000000000000000;;	func findDisk(wwn, lun string, io ioHandler) (string, string) {
0000000000000000000000000000000000000000;;		fc_path := "-fc-0x" + wwn + "-lun-" + lun
0000000000000000000000000000000000000000;;		dev_path := "/dev/disk/by-path/"
0000000000000000000000000000000000000000;;		if dirs, err := io.ReadDir(dev_path); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				name := f.Name()
0000000000000000000000000000000000000000;;				if strings.Contains(name, fc_path) {
0000000000000000000000000000000000000000;;					if disk, err1 := io.EvalSymlinks(dev_path + name); err1 == nil {
0000000000000000000000000000000000000000;;						arr := strings.Split(disk, "/")
0000000000000000000000000000000000000000;;						l := len(arr) - 1
0000000000000000000000000000000000000000;;						dev := arr[l]
0000000000000000000000000000000000000000;;						dm := findMultipathDeviceMapper(dev, io)
0000000000000000000000000000000000000000;;						return disk, dm
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rescan scsi bus
0000000000000000000000000000000000000000;;	func scsiHostRescan(io ioHandler) {
0000000000000000000000000000000000000000;;		scsi_path := "/sys/class/scsi_host/"
0000000000000000000000000000000000000000;;		if dirs, err := io.ReadDir(scsi_path); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				name := scsi_path + f.Name() + "/scan"
0000000000000000000000000000000000000000;;				data := []byte("- - -")
0000000000000000000000000000000000000000;;				io.WriteFile(name, data, 0666)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// make a directory like /var/lib/kubelet/plugins/kubernetes.io/pod/fc/target-lun-0
0000000000000000000000000000000000000000;;	func makePDNameInternal(host volume.VolumeHost, wwns []string, lun string) string {
0000000000000000000000000000000000000000;;		return path.Join(host.GetPluginDir(fcPluginName), wwns[0]+"-lun-"+lun)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FCUtil struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *FCUtil) MakeGlobalPDName(fc fcDisk) string {
0000000000000000000000000000000000000000;;		return makePDNameInternal(fc.plugin.host, fc.wwns, fc.lun)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func searchDisk(wwns []string, lun string, io ioHandler) (string, string) {
0000000000000000000000000000000000000000;;		disk := ""
0000000000000000000000000000000000000000;;		dm := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rescaned := false
0000000000000000000000000000000000000000;;		// two-phase search:
0000000000000000000000000000000000000000;;		// first phase, search existing device path, if a multipath dm is found, exit loop
0000000000000000000000000000000000000000;;		// otherwise, in second phase, rescan scsi bus and search again, return with any findings
0000000000000000000000000000000000000000;;		for true {
0000000000000000000000000000000000000000;;			for _, wwn := range wwns {
0000000000000000000000000000000000000000;;				disk, dm = findDisk(wwn, lun, io)
0000000000000000000000000000000000000000;;				// if multipath device is found, break
0000000000000000000000000000000000000000;;				if dm != "" {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if a dm is found, exit loop
0000000000000000000000000000000000000000;;			if rescaned || dm != "" {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// rescan and search again
0000000000000000000000000000000000000000;;			// rescan scsi bus
0000000000000000000000000000000000000000;;			scsiHostRescan(io)
0000000000000000000000000000000000000000;;			rescaned = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return disk, dm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *FCUtil) AttachDisk(b fcDiskMounter) error {
0000000000000000000000000000000000000000;;		devicePath := ""
0000000000000000000000000000000000000000;;		wwns := b.wwns
0000000000000000000000000000000000000000;;		lun := b.lun
0000000000000000000000000000000000000000;;		io := b.io
0000000000000000000000000000000000000000;;		disk, dm := searchDisk(wwns, lun, io)
0000000000000000000000000000000000000000;;		// if no disk matches input wwn and lun, exit
0000000000000000000000000000000000000000;;		if disk == "" && dm == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no fc disk found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if multipath devicemapper device is found, use it; otherwise use raw disk
0000000000000000000000000000000000000000;;		if dm != "" {
0000000000000000000000000000000000000000;;			devicePath = dm
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			devicePath = disk
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// mount it
0000000000000000000000000000000000000000;;		globalPDPath := b.manager.MakeGlobalPDName(*b.fcDisk)
0000000000000000000000000000000000000000;;		noMnt, err := b.mounter.IsLikelyNotMountPoint(globalPDPath)
0000000000000000000000000000000000000000;;		if !noMnt {
0000000000000000000000000000000000000000;;			glog.Infof("fc: %s already mounted", globalPDPath)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(globalPDPath, 0750); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("fc: failed to mkdir %s, error", globalPDPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = b.mounter.FormatAndMount(devicePath, globalPDPath, b.fsType, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("fc: failed to mount fc volume %s [%s] to %s, error %v", devicePath, b.fsType, globalPDPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *FCUtil) DetachDisk(c fcDiskUnmounter, mntPath string) error {
0000000000000000000000000000000000000000;;		if err := c.mounter.Unmount(mntPath); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("fc detach disk: failed to unmount: %s\nError: %v", mntPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
