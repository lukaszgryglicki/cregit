0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2c60d5f2baa7aef5594f36146959ea933ad05af0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("fc_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/fc")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.GetPluginName() != "kubernetes.io/fc" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plug.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("fc_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPersistentPluginByName("kubernetes.io/fc")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !contains(plug.GetAccessModes(), v1.ReadWriteOnce) || !contains(plug.GetAccessModes(), v1.ReadOnlyMany) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected two AccessModeTypes:  %s and %s", v1.ReadWriteOnce, v1.ReadOnlyMany)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(modes []v1.PersistentVolumeAccessMode, mode v1.PersistentVolumeAccessMode) bool {
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if m == mode {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeDiskManager struct {
0000000000000000000000000000000000000000;;		tmpDir       string
0000000000000000000000000000000000000000;;		attachCalled bool
0000000000000000000000000000000000000000;;		detachCalled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeDiskManager() *fakeDiskManager {
0000000000000000000000000000000000000000;;		return &fakeDiskManager{
0000000000000000000000000000000000000000;;			tmpDir: utiltesting.MkTmpdirOrDie("fc_test"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) Cleanup() {
0000000000000000000000000000000000000000;;		os.RemoveAll(fake.tmpDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) MakeGlobalPDName(disk fcDisk) string {
0000000000000000000000000000000000000000;;		return fake.tmpDir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) AttachDisk(b fcDiskMounter) error {
0000000000000000000000000000000000000000;;		globalPath := b.manager.MakeGlobalPDName(*b.fcDisk)
0000000000000000000000000000000000000000;;		err := os.MkdirAll(globalPath, 0750)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Simulate the global mount so that the fakeMounter returns the
0000000000000000000000000000000000000000;;		// expected number of mounts for the attached disk.
0000000000000000000000000000000000000000;;		b.mounter.Mount(globalPath, globalPath, b.fsType, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fake.attachCalled = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) DetachDisk(c fcDiskUnmounter, mntPath string) error {
0000000000000000000000000000000000000000;;		globalPath := c.manager.MakeGlobalPDName(*c.fcDisk)
0000000000000000000000000000000000000000;;		err := os.RemoveAll(globalPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fake.detachCalled = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doTestPlugin(t *testing.T, spec *volume.Spec) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("fc_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/fc")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeManager := NewFakeDiskManager()
0000000000000000000000000000000000000000;;		defer fakeManager.Cleanup()
0000000000000000000000000000000000000000;;		fakeMounter := &mount.FakeMounter{}
0000000000000000000000000000000000000000;;		mounter, err := plug.(*fcPlugin).newMounterInternal(spec, types.UID("poduid"), fakeManager, fakeMounter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := mounter.GetPath()
0000000000000000000000000000000000000000;;		expectedPath := fmt.Sprintf("%s/pods/poduid/volumes/kubernetes.io~fc/vol1", tmpDir)
0000000000000000000000000000000000000000;;		if path != expectedPath {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected path, expected %q, got: %q", expectedPath, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := mounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed, volume path not created: %s", path)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed, volume path not created: %s", path)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager.attachCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Attach was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeManager2 := NewFakeDiskManager()
0000000000000000000000000000000000000000;;		defer fakeManager2.Cleanup()
0000000000000000000000000000000000000000;;		unmounter, err := plug.(*fcPlugin).newUnmounterInternal("vol1", types.UID("poduid"), fakeManager2, fakeMounter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unmounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := unmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("TearDown() failed, volume path still exists: %s", path)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fakeManager2.detachCalled {
0000000000000000000000000000000000000000;;			t.Errorf("Detach was not called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		lun := int32(0)
0000000000000000000000000000000000000000;;		vol := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: "vol1",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				FC: &v1.FCVolumeSource{
0000000000000000000000000000000000000000;;					TargetWWNs: []string{"some_wwn"},
0000000000000000000000000000000000000000;;					FSType:     "ext4",
0000000000000000000000000000000000000000;;					Lun:        &lun,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		doTestPlugin(t, volume.NewSpecFromVolume(vol))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginPersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		lun := int32(0)
0000000000000000000000000000000000000000;;		vol := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "vol1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					FC: &v1.FCVolumeSource{
0000000000000000000000000000000000000000;;						TargetWWNs: []string{"some_wwn"},
0000000000000000000000000000000000000000;;						FSType:     "ext4",
0000000000000000000000000000000000000000;;						Lun:        &lun,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		doTestPlugin(t, volume.NewSpecFromPersistentVolume(vol, false))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentClaimReadOnlyFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("fc_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lun := int32(0)
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					FC: &v1.FCVolumeSource{
0000000000000000000000000000000000000000;;						TargetWWNs: []string{"some_wwn"},
0000000000000000000000000000000000000000;;						FSType:     "ext4",
0000000000000000000000000000000000000000;;						Lun:        &lun,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ClaimRef: &v1.ObjectReference{
0000000000000000000000000000000000000000;;					Name: "claimA",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claimA",
0000000000000000000000000000000000000000;;				Namespace: "nsA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				VolumeName: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PersistentVolumeClaimStatus{
0000000000000000000000000000000000000000;;				Phase: v1.ClaimBound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(pv, claim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, client, nil))
0000000000000000000000000000000000000000;;		plug, _ := plugMgr.FindPluginByName(fcPluginName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readOnly bool is supplied by persistent-claim volume source when its mounter creates other volumes
0000000000000000000000000000000000000000;;		spec := volume.NewSpecFromPersistentVolume(pv, true)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, _ := plug.NewMounter(spec, pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !mounter.GetAttributes().ReadOnly {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true for mounter.IsReadOnly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
