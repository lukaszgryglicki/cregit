0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/volume.go[pkg/kubelet/volume/volume.go][pkg/volume/volume.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volume represents a directory used by pods or hosts on a node. All method
0000000000000000000000000000000000000000;;	// implementations of methods in the volume interface must be idempotent.
0000000000000000000000000000000000000000;;	type Volume interface {
0000000000000000000000000000000000000000;;		// GetPath returns the path to which the volume should be mounted for the
0000000000000000000000000000000000000000;;		// pod.
0000000000000000000000000000000000000000;;		GetPath() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MetricsProvider embeds methods for exposing metrics (e.g.
0000000000000000000000000000000000000000;;		// used, available space).
0000000000000000000000000000000000000000;;		MetricsProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetricsProvider exposes metrics (e.g. used,available space) related to a
0000000000000000000000000000000000000000;;	// Volume.
0000000000000000000000000000000000000000;;	type MetricsProvider interface {
0000000000000000000000000000000000000000;;		// GetMetrics returns the Metrics for the Volume. Maybe expensive for
0000000000000000000000000000000000000000;;		// some implementations.
0000000000000000000000000000000000000000;;		GetMetrics() (*Metrics, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Metrics represents the used and available bytes of the Volume.
0000000000000000000000000000000000000000;;	type Metrics struct {
0000000000000000000000000000000000000000;;		// The time at which these stats were updated.
0000000000000000000000000000000000000000;;		Time metav1.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used represents the total bytes used by the Volume.
0000000000000000000000000000000000000000;;		// Note: For block devices this maybe more than the total size of the files.
0000000000000000000000000000000000000000;;		Used *resource.Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Capacity represents the total capacity (bytes) of the volume's
0000000000000000000000000000000000000000;;		// underlying storage. For Volumes that share a filesystem with the host
0000000000000000000000000000000000000000;;		// (e.g. emptydir, hostpath) this is the size of the underlying storage,
0000000000000000000000000000000000000000;;		// and will not equal Used + Available as the fs is shared.
0000000000000000000000000000000000000000;;		Capacity *resource.Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Available represents the storage space available (bytes) for the
0000000000000000000000000000000000000000;;		// Volume. For Volumes that share a filesystem with the host (e.g.
0000000000000000000000000000000000000000;;		// emptydir, hostpath), this is the available space on the underlying
0000000000000000000000000000000000000000;;		// storage, and is shared with host processes and other Volumes.
0000000000000000000000000000000000000000;;		Available *resource.Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InodesUsed represents the total inodes used by the Volume.
0000000000000000000000000000000000000000;;		InodesUsed *resource.Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inodes represents the total number of inodes available in the volume.
0000000000000000000000000000000000000000;;		// For volumes that share a filesystem with the host (e.g. emptydir, hostpath),
0000000000000000000000000000000000000000;;		// this is the inodes available in the underlying storage,
0000000000000000000000000000000000000000;;		// and will not equal InodesUsed + InodesFree as the fs is shared.
0000000000000000000000000000000000000000;;		Inodes *resource.Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InodesFree represent the inodes available for the volume.  For Volumes that share
0000000000000000000000000000000000000000;;		// a filesystem with the host (e.g. emptydir, hostpath), this is the free inodes
0000000000000000000000000000000000000000;;		// on the underlying storage, and is shared with host processes and other volumes
0000000000000000000000000000000000000000;;		InodesFree *resource.Quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attributes represents the attributes of this mounter.
0000000000000000000000000000000000000000;;	type Attributes struct {
0000000000000000000000000000000000000000;;		ReadOnly        bool
0000000000000000000000000000000000000000;;		Managed         bool
0000000000000000000000000000000000000000;;		SupportsSELinux bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mounter interface provides methods to set up/mount the volume.
0000000000000000000000000000000000000000;;	type Mounter interface {
0000000000000000000000000000000000000000;;		// Uses Interface to provide the path for Docker binds.
0000000000000000000000000000000000000000;;		Volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CanMount is called immediately prior to Setup to check if
0000000000000000000000000000000000000000;;		// the required components (binaries, etc.) are available on
0000000000000000000000000000000000000000;;		// the underlying node to complete the subsequent SetUp (mount)
0000000000000000000000000000000000000000;;		// operation. If CanMount returns error, the mount operation is
0000000000000000000000000000000000000000;;		// aborted and an event is generated indicating that the node
0000000000000000000000000000000000000000;;		// does not have the required binaries to complete the mount.
0000000000000000000000000000000000000000;;		// If CanMount succeeds, the mount operation continues
0000000000000000000000000000000000000000;;		// normally. The CanMount check can be enabled or disabled
0000000000000000000000000000000000000000;;		// using the experimental-check-mount-binaries binary flag
0000000000000000000000000000000000000000;;		CanMount() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetUp prepares and mounts/unpacks the volume to a
0000000000000000000000000000000000000000;;		// self-determined directory path. The mount point and its
0000000000000000000000000000000000000000;;		// content should be owned by 'fsGroup' so that it can be
0000000000000000000000000000000000000000;;		// accessed by the pod. This may be called more than once, so
0000000000000000000000000000000000000000;;		// implementations must be idempotent.
0000000000000000000000000000000000000000;;		SetUp(fsGroup *int64) error
0000000000000000000000000000000000000000;;		// SetUpAt prepares and mounts/unpacks the volume to the
0000000000000000000000000000000000000000;;		// specified directory path, which may or may not exist yet.
0000000000000000000000000000000000000000;;		// The mount point and its content should be owned by
0000000000000000000000000000000000000000;;		// 'fsGroup' so that it can be accessed by the pod. This may
0000000000000000000000000000000000000000;;		// be called more than once, so implementations must be
0000000000000000000000000000000000000000;;		// idempotent.
0000000000000000000000000000000000000000;;		SetUpAt(dir string, fsGroup *int64) error
0000000000000000000000000000000000000000;;		// GetAttributes returns the attributes of the mounter.
0000000000000000000000000000000000000000;;		GetAttributes() Attributes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounter interface provides methods to cleanup/unmount the volumes.
0000000000000000000000000000000000000000;;	type Unmounter interface {
0000000000000000000000000000000000000000;;		Volume
0000000000000000000000000000000000000000;;		// TearDown unmounts the volume from a self-determined directory and
0000000000000000000000000000000000000000;;		// removes traces of the SetUp procedure.
0000000000000000000000000000000000000000;;		TearDown() error
0000000000000000000000000000000000000000;;		// TearDown unmounts the volume from the specified directory and
0000000000000000000000000000000000000000;;		// removes traces of the SetUp procedure.
0000000000000000000000000000000000000000;;		TearDownAt(dir string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provisioner is an interface that creates templates for PersistentVolumes
0000000000000000000000000000000000000000;;	// and can create the volume as a new resource in the infrastructure provider.
0000000000000000000000000000000000000000;;	type Provisioner interface {
0000000000000000000000000000000000000000;;		// Provision creates the resource by allocating the underlying volume in a
0000000000000000000000000000000000000000;;		// storage system. This method should block until completion and returns
0000000000000000000000000000000000000000;;		// PersistentVolume representing the created storage resource.
0000000000000000000000000000000000000000;;		Provision() (*v1.PersistentVolume, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deleter removes the resource from the underlying storage provider. Calls
0000000000000000000000000000000000000000;;	// to this method should block until the deletion is complete. Any error
0000000000000000000000000000000000000000;;	// returned indicates the volume has failed to be reclaimed. A nil return
0000000000000000000000000000000000000000;;	// indicates success.
0000000000000000000000000000000000000000;;	type Deleter interface {
0000000000000000000000000000000000000000;;		Volume
0000000000000000000000000000000000000000;;		// This method should block until completion.
0000000000000000000000000000000000000000;;		// deletedVolumeInUseError returned from this function will not be reported
0000000000000000000000000000000000000000;;		// as error and it will be sent as "Info" event to the PV being deleted. The
0000000000000000000000000000000000000000;;		// volume controller will retry deleting the volume in the next periodic
0000000000000000000000000000000000000000;;		// sync. This can be used to postpone deletion of a volume that is being
0000000000000000000000000000000000000000;;		// detached from a node. Deletion of such volume would fail anyway and such
0000000000000000000000000000000000000000;;		// error would confuse users.
0000000000000000000000000000000000000000;;		Delete() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attacher can attach a volume to a node.
0000000000000000000000000000000000000000;;	type Attacher interface {
0000000000000000000000000000000000000000;;		// Attaches the volume specified by the given spec to the node with the given Name.
0000000000000000000000000000000000000000;;		// On success, returns the device path where the device was attached on the
0000000000000000000000000000000000000000;;		// node.
0000000000000000000000000000000000000000;;		Attach(spec *Spec, nodeName types.NodeName) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumesAreAttached checks whether the list of volumes still attached to the specified
0000000000000000000000000000000000000000;;		// node. It returns a map which maps from the volume spec to the checking result.
0000000000000000000000000000000000000000;;		// If an error is occurred during checking, the error will be returned
0000000000000000000000000000000000000000;;		VolumesAreAttached(specs []*Spec, nodeName types.NodeName) (map[*Spec]bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WaitForAttach blocks until the device is attached to this
0000000000000000000000000000000000000000;;		// node. If it successfully attaches, the path to the device
0000000000000000000000000000000000000000;;		// is returned. Otherwise, if the device does not attach after
0000000000000000000000000000000000000000;;		// the given timeout period, an error will be returned.
0000000000000000000000000000000000000000;;		WaitForAttach(spec *Spec, devicePath string, timeout time.Duration) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetDeviceMountPath returns a path where the device should
0000000000000000000000000000000000000000;;		// be mounted after it is attached. This is a global mount
0000000000000000000000000000000000000000;;		// point which should be bind mounted for individual volumes.
0000000000000000000000000000000000000000;;		GetDeviceMountPath(spec *Spec) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MountDevice mounts the disk to a global path which
0000000000000000000000000000000000000000;;		// individual pods can then bind mount
0000000000000000000000000000000000000000;;		MountDevice(spec *Spec, devicePath string, deviceMountPath string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BulkVolumeVerifier interface {
0000000000000000000000000000000000000000;;		// BulkVerifyVolumes checks whether the list of volumes still attached to the
0000000000000000000000000000000000000000;;		// the clusters in the node. It returns a map which maps from the volume spec to the checking result.
0000000000000000000000000000000000000000;;		// If an error occurs during check - error should be returned and volume on nodes
0000000000000000000000000000000000000000;;		// should be assumed as still attached.
0000000000000000000000000000000000000000;;		BulkVerifyVolumes(volumesByNode map[types.NodeName][]*Spec) (map[types.NodeName]map[*Spec]bool, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detacher can detach a volume from a node.
0000000000000000000000000000000000000000;;	type Detacher interface {
0000000000000000000000000000000000000000;;		// Detach the given device from the node with the given Name.
0000000000000000000000000000000000000000;;		Detach(deviceName string, nodeName types.NodeName) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UnmountDevice unmounts the global mount of the disk. This
0000000000000000000000000000000000000000;;		// should only be called once all bind mounts have been
0000000000000000000000000000000000000000;;		// unmounted.
0000000000000000000000000000000000000000;;		UnmountDevice(deviceMountPath string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDeletedVolumeInUseError returns a new instance of DeletedVolumeInUseError
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func NewDeletedVolumeInUseError(message string) error {
0000000000000000000000000000000000000000;;		return deletedVolumeInUseError(message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deletedVolumeInUseError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ error = deletedVolumeInUseError("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDeletedVolumeInUse returns true if an error returned from Delete() is
0000000000000000000000000000000000000000;;	// deletedVolumeInUseError
0000000000000000000000000000000000000000;;	func IsDeletedVolumeInUse(err error) bool {
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case deletedVolumeInUseError:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err deletedVolumeInUseError) Error() string {
0000000000000000000000000000000000000000;;		return string(err)
0000000000000000000000000000000000000000;;	}
