0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
8b3434d697d1c663ffe822e8b12e550e4617836f;pkg/volume/aws_pd/aws_pd.go[pkg/volume/aws_pd/aws_pd.go][pkg/volume/aws_ebs/aws_ebs.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws_ebs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		kstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&awsElasticBlockStorePlugin{nil}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsElasticBlockStorePlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &awsElasticBlockStorePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &awsElasticBlockStorePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &awsElasticBlockStorePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &awsElasticBlockStorePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		awsElasticBlockStorePluginName = "kubernetes.io/aws-ebs"
0000000000000000000000000000000000000000;;		awsURLNamePrefix               = "aws://"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPath(uid types.UID, volName string, host volume.VolumeHost) string {
0000000000000000000000000000000000000000;;		return host.GetPodVolumeDir(uid, kstrings.EscapeQualifiedNameForDisk(awsElasticBlockStorePluginName), volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return awsElasticBlockStorePluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource.VolumeID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.AWSElasticBlockStore != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.AWSElasticBlockStore != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, &AWSDiskUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, manager ebsManager, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		// EBSs used directly in a pod have a ReadOnly flag set by the pod author.
0000000000000000000000000000000000000000;;		// EBSs used as a PersistentVolume gets the ReadOnly flag indirectly through the persistent-claim volume used to mount the PV
0000000000000000000000000000000000000000;;		ebs, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID := aws.KubernetesVolumeID(ebs.VolumeID)
0000000000000000000000000000000000000000;;		fsType := ebs.FSType
0000000000000000000000000000000000000000;;		partition := ""
0000000000000000000000000000000000000000;;		if ebs.Partition != 0 {
0000000000000000000000000000000000000000;;			partition = strconv.Itoa(int(ebs.Partition))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreMounter{
0000000000000000000000000000000000000000;;			awsElasticBlockStore: &awsElasticBlockStore{
0000000000000000000000000000000000000000;;				podUID:          podUID,
0000000000000000000000000000000000000000;;				volName:         spec.Name(),
0000000000000000000000000000000000000000;;				volumeID:        volumeID,
0000000000000000000000000000000000000000;;				partition:       partition,
0000000000000000000000000000000000000000;;				manager:         manager,
0000000000000000000000000000000000000000;;				mounter:         mounter,
0000000000000000000000000000000000000000;;				plugin:          plugin,
0000000000000000000000000000000000000000;;				MetricsProvider: volume.NewMetricsStatFS(getPath(podUID, spec.Name(), plugin.host)),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			fsType:      fsType,
0000000000000000000000000000000000000000;;			readOnly:    readOnly,
0000000000000000000000000000000000000000;;			diskMounter: &mount.SafeFormatAndMount{Interface: plugin.host.GetMounter(), Runner: exec.New()}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, &AWSDiskUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) newUnmounterInternal(volName string, podUID types.UID, manager ebsManager, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreUnmounter{&awsElasticBlockStore{
0000000000000000000000000000000000000000;;			podUID:          podUID,
0000000000000000000000000000000000000000;;			volName:         volName,
0000000000000000000000000000000000000000;;			manager:         manager,
0000000000000000000000000000000000000000;;			mounter:         mounter,
0000000000000000000000000000000000000000;;			plugin:          plugin,
0000000000000000000000000000000000000000;;			MetricsProvider: volume.NewMetricsStatFS(getPath(podUID, volName, plugin.host)),
0000000000000000000000000000000000000000;;		}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		return plugin.newDeleterInternal(spec, &AWSDiskUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) newDeleterInternal(spec *volume.Spec, manager ebsManager) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.AWSElasticBlockStore == nil {
0000000000000000000000000000000000000000;;			glog.Errorf("spec.PersistentVolumeSource.AWSElasticBlockStore is nil")
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.AWSElasticBlockStore is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreDeleter{
0000000000000000000000000000000000000000;;			awsElasticBlockStore: &awsElasticBlockStore{
0000000000000000000000000000000000000000;;				volName:  spec.Name(),
0000000000000000000000000000000000000000;;				volumeID: aws.KubernetesVolumeID(spec.PersistentVolume.Spec.AWSElasticBlockStore.VolumeID),
0000000000000000000000000000000000000000;;				manager:  manager,
0000000000000000000000000000000000000000;;				plugin:   plugin,
0000000000000000000000000000000000000000;;			}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return plugin.newProvisionerInternal(options, &AWSDiskUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) newProvisionerInternal(options volume.VolumeOptions, manager ebsManager) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreProvisioner{
0000000000000000000000000000000000000000;;			awsElasticBlockStore: &awsElasticBlockStore{
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options: options,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(
0000000000000000000000000000000000000000;;		spec *volume.Spec) (*v1.AWSElasticBlockStoreVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.AWSElasticBlockStore != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.AWSElasticBlockStore, spec.Volume.AWSElasticBlockStore.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.AWSElasticBlockStore != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.AWSElasticBlockStore, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference an AWS EBS volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) ConstructVolumeSpec(volName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		pluginDir := plugin.host.GetPluginDir(plugin.GetPluginName())
0000000000000000000000000000000000000000;;		volumeID, err := mounter.GetDeviceNameFromMount(mountPath, pluginDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This is a workaround to fix the issue in converting aws volume id from globalPDPath
0000000000000000000000000000000000000000;;		// There are three aws volume id formats and their volumeID from GetDeviceNameFromMount() are:
0000000000000000000000000000000000000000;;		// aws:///vol-1234 (aws/vol-1234)
0000000000000000000000000000000000000000;;		// aws://us-east-1/vol-1234 (aws/us-east-1/vol-1234)
0000000000000000000000000000000000000000;;		// vol-1234 (vol-1234)
0000000000000000000000000000000000000000;;		// This code is for converting volume id to aws style volume id for the first two cases.
0000000000000000000000000000000000000000;;		sourceName := volumeID
0000000000000000000000000000000000000000;;		if strings.HasPrefix(volumeID, "aws/") {
0000000000000000000000000000000000000000;;			names := strings.Split(volumeID, "/")
0000000000000000000000000000000000000000;;			length := len(names)
0000000000000000000000000000000000000000;;			if length < 2 || length > 3 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to get AWS volume id from mount path %q: invalid volume name format %q", mountPath, volumeID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volName := names[length-1]
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(volName, "vol-") {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Invalid volume name format for AWS volume (%q) retrieved from mount path %q", volName, mountPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if length == 2 {
0000000000000000000000000000000000000000;;				sourceName = awsURLNamePrefix + "" + "/" + volName // empty zone label
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if length == 3 {
0000000000000000000000000000000000000000;;				sourceName = awsURLNamePrefix + names[1] + "/" + volName // names[1] is the zone label
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Convert aws volume name from %q to %q ", volumeID, sourceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		awsVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;					VolumeID: sourceName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(awsVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstract interface to PD operations.
0000000000000000000000000000000000000000;;	type ebsManager interface {
0000000000000000000000000000000000000000;;		CreateVolume(provisioner *awsElasticBlockStoreProvisioner) (volumeID aws.KubernetesVolumeID, volumeSizeGB int, labels map[string]string, err error)
0000000000000000000000000000000000000000;;		// Deletes a volume
0000000000000000000000000000000000000000;;		DeleteVolume(deleter *awsElasticBlockStoreDeleter) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awsElasticBlockStore volumes are disk resources provided by Amazon Web Services
0000000000000000000000000000000000000000;;	// that are attached to the kubelet's host machine and exposed to the pod.
0000000000000000000000000000000000000000;;	type awsElasticBlockStore struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		// Unique id of the PD, used to find the disk resource in the provider.
0000000000000000000000000000000000000000;;		volumeID aws.KubernetesVolumeID
0000000000000000000000000000000000000000;;		// Specifies the partition to mount
0000000000000000000000000000000000000000;;		partition string
0000000000000000000000000000000000000000;;		// Utility interface that provides API calls to the provider to attach/detach disks.
0000000000000000000000000000000000000000;;		manager ebsManager
0000000000000000000000000000000000000000;;		// Mounter interface that provides system calls to mount the global path to the pod local path.
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		plugin  *awsElasticBlockStorePlugin
0000000000000000000000000000000000000000;;		volume.MetricsProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsElasticBlockStoreMounter struct {
0000000000000000000000000000000000000000;;		*awsElasticBlockStore
0000000000000000000000000000000000000000;;		// Filesystem type, optional.
0000000000000000000000000000000000000000;;		fsType string
0000000000000000000000000000000000000000;;		// Specifies whether the disk will be attached as read-only.
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;		// diskMounter provides the interface that is used to mount the actual block device.
0000000000000000000000000000000000000000;;		diskMounter *mount.SafeFormatAndMount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &awsElasticBlockStoreMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *awsElasticBlockStoreMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         !b.readOnly,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *awsElasticBlockStoreMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *awsElasticBlockStoreMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *awsElasticBlockStoreMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		// TODO: handle failed mounts here.
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("PersistentDisk set up: %s %v %v", dir, !notMnt, err)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot validate mount point: %s %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		globalPDPath := makeGlobalPDPath(b.plugin.host, b.volumeID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a bind mount to the full path to allow duplicate mounts of the same PD.
0000000000000000000000000000000000000000;;		options := []string{"bind"}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = b.mounter.Mount(globalPDPath, dir, "", options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;			if mntErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("IsLikelyNotMountPoint check failed for %s: %v", dir, mntErr)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !notMnt {
0000000000000000000000000000000000000000;;				if mntErr = b.mounter.Unmount(dir); mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to unmount %s: %v", dir, mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;				if mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("IsLikelyNotMountPoint check failed for %s: %v", dir, mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !notMnt {
0000000000000000000000000000000000000000;;					// This is very odd, we don't expect it.  We'll try again next sync loop.
0000000000000000000000000000000000000000;;					glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.", dir)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Remove(dir)
0000000000000000000000000000000000000000;;			glog.Errorf("Mount of disk %s failed: %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !b.readOnly {
0000000000000000000000000000000000000000;;			volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Successfully mounted %s", dir)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeGlobalPDPath(host volume.VolumeHost, volumeID aws.KubernetesVolumeID) string {
0000000000000000000000000000000000000000;;		// Clean up the URI to be more fs-friendly
0000000000000000000000000000000000000000;;		name := string(volumeID)
0000000000000000000000000000000000000000;;		name = strings.Replace(name, "://", "/", -1)
0000000000000000000000000000000000000000;;		return path.Join(host.GetPluginDir(awsElasticBlockStorePluginName), mount.MountsInGlobalPDPath, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reverses the mapping done in makeGlobalPDPath
0000000000000000000000000000000000000000;;	func getVolumeIDFromGlobalMount(host volume.VolumeHost, globalPath string) (string, error) {
0000000000000000000000000000000000000000;;		basePath := path.Join(host.GetPluginDir(awsElasticBlockStorePluginName), mount.MountsInGlobalPDPath)
0000000000000000000000000000000000000000;;		rel, err := filepath.Rel(basePath, globalPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get volume id from global mount %s - %v", globalPath, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(rel, "../") {
0000000000000000000000000000000000000000;;			glog.Errorf("Unexpected mount path: %s", globalPath)
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected mount path: " + globalPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Reverse the :// replacement done in makeGlobalPDPath
0000000000000000000000000000000000000000;;		volumeID := rel
0000000000000000000000000000000000000000;;		if strings.HasPrefix(volumeID, "aws/") {
0000000000000000000000000000000000000000;;			volumeID = strings.Replace(volumeID, "aws/", "aws://", 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(2).Info("Mapping mount dir ", globalPath, " to volumeID ", volumeID)
0000000000000000000000000000000000000000;;		return volumeID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ebs *awsElasticBlockStore) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(ebs.podUID, ebs.volName, ebs.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsElasticBlockStoreUnmounter struct {
0000000000000000000000000000000000000000;;		*awsElasticBlockStore
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &awsElasticBlockStoreUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *awsElasticBlockStoreUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount
0000000000000000000000000000000000000000;;	func (c *awsElasticBlockStoreUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return util.UnmountPath(dir, c.mounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsElasticBlockStoreDeleter struct {
0000000000000000000000000000000000000000;;		*awsElasticBlockStore
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Deleter = &awsElasticBlockStoreDeleter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *awsElasticBlockStoreDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(d.podUID, d.volName, d.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *awsElasticBlockStoreDeleter) Delete() error {
0000000000000000000000000000000000000000;;		return d.manager.DeleteVolume(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsElasticBlockStoreProvisioner struct {
0000000000000000000000000000000000000000;;		*awsElasticBlockStore
0000000000000000000000000000000000000000;;		options   volume.VolumeOptions
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Provisioner = &awsElasticBlockStoreProvisioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *awsElasticBlockStoreProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if !volume.AccessModesContainedInAll(c.plugin.GetAccessModes(), c.options.PVC.Spec.AccessModes) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported", c.options.PVC.Spec.AccessModes, c.plugin.GetAccessModes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID, sizeGB, labels, err := c.manager.CreateVolume(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Provision failed: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   c.options.PVName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{},
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeDynamicallyCreatedByKey: "aws-ebs-dynamic-provisioner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: c.options.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				AccessModes:                   c.options.PVC.Spec.AccessModes,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dGi", sizeGB)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;						VolumeID:  string(volumeID),
0000000000000000000000000000000000000000;;						FSType:    "ext4",
0000000000000000000000000000000000000000;;						Partition: 0,
0000000000000000000000000000000000000000;;						ReadOnly:  false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.options.PVC.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = c.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(labels) != 0 {
0000000000000000000000000000000000000000;;			if pv.Labels == nil {
0000000000000000000000000000000000000000;;				pv.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range labels {
0000000000000000000000000000000000000000;;				pv.Labels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
