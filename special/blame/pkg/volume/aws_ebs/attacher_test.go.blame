0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
1d42da8122a5e60d84efb4fc0395708f32b6b241;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws_ebs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetVolumeName_Volume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		name := aws.KubernetesVolumeID("my-aws-volume")
0000000000000000000000000000000000000000;;		spec := createVolSpec(name, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetVolumeName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volumeName != string(name) {
0000000000000000000000000000000000000000;;			t.Errorf("GetVolumeName error: expected %s, got %s", name, volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetVolumeName_PersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		plugin := newPlugin()
0000000000000000000000000000000000000000;;		name := aws.KubernetesVolumeID("my-aws-pv")
0000000000000000000000000000000000000000;;		spec := createPVSpec(name, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeName, err := plugin.GetVolumeName(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("GetVolumeName error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if volumeName != string(name) {
0000000000000000000000000000000000000000;;			t.Errorf("GetVolumeName error: expected %s, got %s", name, volumeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// One testcase for TestAttachDetach table test below
0000000000000000000000000000000000000000;;	type testcase struct {
0000000000000000000000000000000000000000;;		name aws.KubernetesVolumeID
0000000000000000000000000000000000000000;;		// For fake AWS:
0000000000000000000000000000000000000000;;		attach         attachCall
0000000000000000000000000000000000000000;;		detach         detachCall
0000000000000000000000000000000000000000;;		diskIsAttached diskIsAttachedCall
0000000000000000000000000000000000000000;;		t              *testing.T
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Actual test to run
0000000000000000000000000000000000000000;;		test func(test *testcase) (string, error)
0000000000000000000000000000000000000000;;		// Expected return of the test
0000000000000000000000000000000000000000;;		expectedDevice string
0000000000000000000000000000000000000000;;		expectedError  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAttachDetach(t *testing.T) {
0000000000000000000000000000000000000000;;		diskName := aws.KubernetesVolumeID("disk")
0000000000000000000000000000000000000000;;		nodeName := types.NodeName("instance")
0000000000000000000000000000000000000000;;		readOnly := false
0000000000000000000000000000000000000000;;		spec := createVolSpec(diskName, readOnly)
0000000000000000000000000000000000000000;;		attachError := errors.New("Fake attach error")
0000000000000000000000000000000000000000;;		detachError := errors.New("Fake detach error")
0000000000000000000000000000000000000000;;		diskCheckError := errors.New("Fake DiskIsAttached error")
0000000000000000000000000000000000000000;;		tests := []testcase{
0000000000000000000000000000000000000000;;			// Successful Attach call
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "Attach_Positive",
0000000000000000000000000000000000000000;;				attach: attachCall{diskName, nodeName, readOnly, "/dev/sda", nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedDevice: "/dev/sda",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Attach call fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "Attach_Negative",
0000000000000000000000000000000000000000;;				attach: attachCall{diskName, nodeName, readOnly, "", attachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					attacher := newAttacher(testcase)
0000000000000000000000000000000000000000;;					return attacher.Attach(spec, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: attachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, true, nil},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, "/dev/sda", nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					mountPath := "/mnt/" + string(diskName)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(mountPath, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disk is already detached
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive_AlreadyDetached",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					mountPath := "/mnt/" + string(diskName)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(mountPath, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach succeeds when DiskIsAttached fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Positive_CheckFails",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, "/dev/sda", nil},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					mountPath := "/mnt/" + string(diskName)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(mountPath, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Detach fails
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:           "Detach_Negative",
0000000000000000000000000000000000000000;;				diskIsAttached: diskIsAttachedCall{diskName, nodeName, false, diskCheckError},
0000000000000000000000000000000000000000;;				detach:         detachCall{diskName, nodeName, "", detachError},
0000000000000000000000000000000000000000;;				test: func(testcase *testcase) (string, error) {
0000000000000000000000000000000000000000;;					detacher := newDetacher(testcase)
0000000000000000000000000000000000000000;;					mountPath := "/mnt/" + string(diskName)
0000000000000000000000000000000000000000;;					return "", detacher.Detach(mountPath, nodeName)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedError: detachError,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testcase := range tests {
0000000000000000000000000000000000000000;;			testcase.t = t
0000000000000000000000000000000000000000;;			device, err := testcase.test(&testcase)
0000000000000000000000000000000000000000;;			if err != testcase.expectedError {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed: expected err=%q, got %q", testcase.name, testcase.expectedError.Error(), err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if device != testcase.expectedDevice {
0000000000000000000000000000000000000000;;				t.Errorf("%s failed: expected device=%q, got %q", testcase.name, testcase.expectedDevice, device)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("Test %q succeeded", testcase.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPlugin creates a new gcePersistentDiskPlugin with fake cloud, NewAttacher
0000000000000000000000000000000000000000;;	// and NewDetacher won't work.
0000000000000000000000000000000000000000;;	func newPlugin() *awsElasticBlockStorePlugin {
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost("/tmp", nil, nil)
0000000000000000000000000000000000000000;;		plugins := ProbeVolumePlugins()
0000000000000000000000000000000000000000;;		plugin := plugins[0]
0000000000000000000000000000000000000000;;		plugin.Init(host)
0000000000000000000000000000000000000000;;		return plugin.(*awsElasticBlockStorePlugin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAttacher(testcase *testcase) *awsElasticBlockStoreAttacher {
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreAttacher{
0000000000000000000000000000000000000000;;			host:       nil,
0000000000000000000000000000000000000000;;			awsVolumes: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDetacher(testcase *testcase) *awsElasticBlockStoreDetacher {
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreDetacher{
0000000000000000000000000000000000000000;;			awsVolumes: testcase,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createVolSpec(name aws.KubernetesVolumeID, readOnly bool) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{
0000000000000000000000000000000000000000;;				VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;					AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;						VolumeID: string(name),
0000000000000000000000000000000000000000;;						ReadOnly: readOnly,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPVSpec(name aws.KubernetesVolumeID, readOnly bool) *volume.Spec {
0000000000000000000000000000000000000000;;		return &volume.Spec{
0000000000000000000000000000000000000000;;			PersistentVolume: &v1.PersistentVolume{
0000000000000000000000000000000000000000;;				Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;					PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;						AWSElasticBlockStore: &v1.AWSElasticBlockStoreVolumeSource{
0000000000000000000000000000000000000000;;							VolumeID: string(name),
0000000000000000000000000000000000000000;;							ReadOnly: readOnly,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake AWS implementation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type attachCall struct {
0000000000000000000000000000000000000000;;		diskName      aws.KubernetesVolumeID
0000000000000000000000000000000000000000;;		nodeName      types.NodeName
0000000000000000000000000000000000000000;;		readOnly      bool
0000000000000000000000000000000000000000;;		retDeviceName string
0000000000000000000000000000000000000000;;		ret           error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type detachCall struct {
0000000000000000000000000000000000000000;;		diskName      aws.KubernetesVolumeID
0000000000000000000000000000000000000000;;		nodeName      types.NodeName
0000000000000000000000000000000000000000;;		retDeviceName string
0000000000000000000000000000000000000000;;		ret           error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type diskIsAttachedCall struct {
0000000000000000000000000000000000000000;;		diskName   aws.KubernetesVolumeID
0000000000000000000000000000000000000000;;		nodeName   types.NodeName
0000000000000000000000000000000000000000;;		isAttached bool
0000000000000000000000000000000000000000;;		ret        error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) AttachDisk(diskName aws.KubernetesVolumeID, nodeName types.NodeName, readOnly bool) (string, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.attach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.attach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// AttachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected AttachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected AttachDisk call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected AttachDisk call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.readOnly != readOnly {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected AttachDisk call: expected readOnly %v, got %v", expected.readOnly, readOnly)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected AttachDisk call: wrong readOnly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("AttachDisk call: %s, %s, %v, returning %q, %v", diskName, nodeName, readOnly, expected.retDeviceName, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.retDeviceName, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DetachDisk(diskName aws.KubernetesVolumeID, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.detach
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.detach looks uninitialized, test did not expect to call
0000000000000000000000000000000000000000;;			// DetachDisk
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected DetachDisk call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected DetachDisk call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DetachDisk call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return "", errors.New("Unexpected DetachDisk call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DetachDisk call: %s, %s, returning %q, %v", diskName, nodeName, expected.retDeviceName, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.retDeviceName, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DiskIsAttached(diskName aws.KubernetesVolumeID, nodeName types.NodeName) (bool, error) {
0000000000000000000000000000000000000000;;		expected := &testcase.diskIsAttached
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName == "" && expected.nodeName == "" {
0000000000000000000000000000000000000000;;			// testcase.diskIsAttached looks uninitialized, test did not expect to
0000000000000000000000000000000000000000;;			// call DiskIsAttached
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.diskName != diskName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected diskName %s, got %s", expected.diskName, diskName)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong diskName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.nodeName != nodeName {
0000000000000000000000000000000000000000;;			testcase.t.Errorf("Unexpected DiskIsAttached call: expected nodeName %s, got %s", expected.nodeName, nodeName)
0000000000000000000000000000000000000000;;			return false, errors.New("Unexpected DiskIsAttached call: wrong nodeName")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DiskIsAttached call: %s, %s, returning %v, %v", diskName, nodeName, expected.isAttached, expected.ret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expected.isAttached, expected.ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DisksAreAttached(nodeDisks map[types.NodeName][]aws.KubernetesVolumeID) (map[types.NodeName]map[aws.KubernetesVolumeID]bool, error) {
0000000000000000000000000000000000000000;;		return nil, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) CreateDisk(volumeOptions *aws.VolumeOptions) (volumeName aws.KubernetesVolumeID, err error) {
0000000000000000000000000000000000000000;;		return "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) DeleteDisk(volumeName aws.KubernetesVolumeID) (bool, error) {
0000000000000000000000000000000000000000;;		return false, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) GetVolumeLabels(volumeName aws.KubernetesVolumeID) (map[string]string, error) {
0000000000000000000000000000000000000000;;		return map[string]string{}, errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testcase *testcase) GetDiskPath(volumeName aws.KubernetesVolumeID) (string, error) {
0000000000000000000000000000000000000000;;		return "", errors.New("Not implemented")
0000000000000000000000000000000000000000;;	}
