0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
4bb8edea185476a33845e7f8ccbfba179d4728f1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package aws_ebs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/aws"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsElasticBlockStoreAttacher struct {
0000000000000000000000000000000000000000;;		host       volume.VolumeHost
0000000000000000000000000000000000000000;;		awsVolumes aws.Volumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Attacher = &awsElasticBlockStoreAttacher{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.AttachableVolumePlugin = &awsElasticBlockStorePlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) NewAttacher() (volume.Attacher, error) {
0000000000000000000000000000000000000000;;		awsCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreAttacher{
0000000000000000000000000000000000000000;;			host:       plugin.host,
0000000000000000000000000000000000000000;;			awsVolumes: awsCloud,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		return mount.GetMountRefs(mounter, deviceMountPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *awsElasticBlockStoreAttacher) Attach(spec *volume.Spec, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID := aws.KubernetesVolumeID(volumeSource.VolumeID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// awsCloud.AttachDisk checks if disk is already attached to node and
0000000000000000000000000000000000000000;;		// succeeds in that case, so no need to do that separately.
0000000000000000000000000000000000000000;;		devicePath, err := attacher.awsVolumes.AttachDisk(volumeID, nodeName, readOnly)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error attaching volume %q to node %q: %+v", volumeID, nodeName, err)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return devicePath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *awsElasticBlockStoreAttacher) VolumesAreAttached(specs []*volume.Spec, nodeName types.NodeName) (map[*volume.Spec]bool, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Warningf("Attacher.VolumesAreAttached called for node %q - Please use BulkVerifyVolumes for AWS", nodeName)
0000000000000000000000000000000000000000;;		volumeNodeMap := map[types.NodeName][]*volume.Spec{
0000000000000000000000000000000000000000;;			nodeName: specs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeVolumesResult := make(map[*volume.Spec]bool)
0000000000000000000000000000000000000000;;		nodesVerificationMap, err := attacher.BulkVerifyVolumes(volumeNodeMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Attacher.VolumesAreAttached - error checking volumes for node %q with %v", nodeName, err)
0000000000000000000000000000000000000000;;			return nodeVolumesResult, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if result, ok := nodesVerificationMap[nodeName]; ok {
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodeVolumesResult, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *awsElasticBlockStoreAttacher) BulkVerifyVolumes(volumesByNode map[types.NodeName][]*volume.Spec) (map[types.NodeName]map[*volume.Spec]bool, error) {
0000000000000000000000000000000000000000;;		volumesAttachedCheck := make(map[types.NodeName]map[*volume.Spec]bool)
0000000000000000000000000000000000000000;;		diskNamesByNode := make(map[types.NodeName][]aws.KubernetesVolumeID)
0000000000000000000000000000000000000000;;		volumeSpecMap := make(map[aws.KubernetesVolumeID]*volume.Spec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for nodeName, volumeSpecs := range volumesByNode {
0000000000000000000000000000000000000000;;			for _, volumeSpec := range volumeSpecs {
0000000000000000000000000000000000000000;;				volumeSource, _, err := getVolumeSource(volumeSpec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Error getting volume (%q) source : %v", volumeSpec.Name(), err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				name := aws.KubernetesVolumeID(volumeSource.VolumeID)
0000000000000000000000000000000000000000;;				diskNamesByNode[nodeName] = append(diskNamesByNode[nodeName], name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nodeDisk, nodeDiskExists := volumesAttachedCheck[nodeName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !nodeDiskExists {
0000000000000000000000000000000000000000;;					nodeDisk = make(map[*volume.Spec]bool)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nodeDisk[volumeSpec] = true
0000000000000000000000000000000000000000;;				volumeSpecMap[name] = volumeSpec
0000000000000000000000000000000000000000;;				volumesAttachedCheck[nodeName] = nodeDisk
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachedResult, err := attacher.awsVolumes.DisksAreAttached(diskNamesByNode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error checking if volumes are attached to nodes err = %v", err)
0000000000000000000000000000000000000000;;			return volumesAttachedCheck, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for nodeName, nodeDisks := range attachedResult {
0000000000000000000000000000000000000000;;			for diskName, attached := range nodeDisks {
0000000000000000000000000000000000000000;;				if !attached {
0000000000000000000000000000000000000000;;					spec := volumeSpecMap[diskName]
0000000000000000000000000000000000000000;;					setNodeDisk(volumesAttachedCheck, spec, nodeName, false)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumesAttachedCheck, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *awsElasticBlockStoreAttacher) WaitForAttach(spec *volume.Spec, devicePath string, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID := volumeSource.VolumeID
0000000000000000000000000000000000000000;;		partition := ""
0000000000000000000000000000000000000000;;		if volumeSource.Partition != 0 {
0000000000000000000000000000000000000000;;			partition = strconv.Itoa(int(volumeSource.Partition))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if devicePath == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("WaitForAttach failed for AWS Volume %q: devicePath is empty.", volumeID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(checkSleepDuration)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		timer := time.NewTimer(timeout)
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Checking AWS Volume %q is attached.", volumeID)
0000000000000000000000000000000000000000;;				if devicePath != "" {
0000000000000000000000000000000000000000;;					devicePaths := getDiskByIdPaths(partition, devicePath)
0000000000000000000000000000000000000000;;					path, err := verifyDevicePath(devicePaths)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Log error, if any, and continue checking periodically. See issue #11321
0000000000000000000000000000000000000000;;						glog.Errorf("Error verifying AWS Volume (%q) is attached: %v", volumeID, err)
0000000000000000000000000000000000000000;;					} else if path != "" {
0000000000000000000000000000000000000000;;						// A device path has successfully been created for the PD
0000000000000000000000000000000000000000;;						glog.Infof("Successfully found attached AWS Volume %q.", volumeID)
0000000000000000000000000000000000000000;;						return path, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("AWS Volume (%q) is not attached yet", volumeID)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer.C:
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("Could not find attached AWS Volume %q. Timeout waiting for mount paths to be created.", volumeID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *awsElasticBlockStoreAttacher) GetDeviceMountPath(
0000000000000000000000000000000000000000;;		spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return makeGlobalPDPath(attacher.host, aws.KubernetesVolumeID(volumeSource.VolumeID)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FIXME: this method can be further pruned.
0000000000000000000000000000000000000000;;	func (attacher *awsElasticBlockStoreAttacher) MountDevice(spec *volume.Spec, devicePath string, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		mounter := attacher.host.GetMounter()
0000000000000000000000000000000000000000;;		notMnt, err := mounter.IsLikelyNotMountPoint(deviceMountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(deviceMountPath, 0750); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSource, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;		if readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			diskMounter := &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()}
0000000000000000000000000000000000000000;;			mountOptions := volume.MountOptionFromSpec(spec, options...)
0000000000000000000000000000000000000000;;			err = diskMounter.FormatAndMount(devicePath, deviceMountPath, volumeSource.FSType, mountOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				os.Remove(deviceMountPath)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type awsElasticBlockStoreDetacher struct {
0000000000000000000000000000000000000000;;		mounter    mount.Interface
0000000000000000000000000000000000000000;;		awsVolumes aws.Volumes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Detacher = &awsElasticBlockStoreDetacher{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *awsElasticBlockStorePlugin) NewDetacher() (volume.Detacher, error) {
0000000000000000000000000000000000000000;;		awsCloud, err := getCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &awsElasticBlockStoreDetacher{
0000000000000000000000000000000000000000;;			mounter:    plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;			awsVolumes: awsCloud,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (detacher *awsElasticBlockStoreDetacher) Detach(deviceMountPath string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		volumeID := aws.KubernetesVolumeID(path.Base(deviceMountPath))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attached, err := detacher.awsVolumes.DiskIsAttached(volumeID, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log error and continue with detach
0000000000000000000000000000000000000000;;			glog.Errorf(
0000000000000000000000000000000000000000;;				"Error checking if volume (%q) is already attached to current node (%q). Will continue and try detach anyway. err=%v",
0000000000000000000000000000000000000000;;				volumeID, nodeName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil && !attached {
0000000000000000000000000000000000000000;;			// Volume is already detached from node.
0000000000000000000000000000000000000000;;			glog.Infof("detach operation was successful. volume %q is already detached from node %q.", volumeID, nodeName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err = detacher.awsVolumes.DetachDisk(volumeID, nodeName); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error detaching volumeID %q: %v", volumeID, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (detacher *awsElasticBlockStoreDetacher) UnmountDevice(deviceMountPath string) error {
0000000000000000000000000000000000000000;;		return volumeutil.UnmountPath(deviceMountPath, detacher.mounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNodeDisk(
0000000000000000000000000000000000000000;;		nodeDiskMap map[types.NodeName]map[*volume.Spec]bool,
0000000000000000000000000000000000000000;;		volumeSpec *volume.Spec,
0000000000000000000000000000000000000000;;		nodeName types.NodeName,
0000000000000000000000000000000000000000;;		check bool) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeMap := nodeDiskMap[nodeName]
0000000000000000000000000000000000000000;;		if volumeMap == nil {
0000000000000000000000000000000000000000;;			volumeMap = make(map[*volume.Spec]bool)
0000000000000000000000000000000000000000;;			nodeDiskMap[nodeName] = volumeMap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volumeMap[volumeSpec] = check
0000000000000000000000000000000000000000;;	}
