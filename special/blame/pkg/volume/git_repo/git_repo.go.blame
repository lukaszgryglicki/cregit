0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/git_repo/git_repo.go[pkg/kubelet/volume/git_repo/git_repo.go][pkg/volume/git_repo/git_repo.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package git_repo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&gitRepoPlugin{nil}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type gitRepoPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &gitRepoPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrappedVolumeSpec() volume.Spec {
0000000000000000000000000000000000000000;;		return volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		gitRepoPluginName = "kubernetes.io/git-repo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return gitRepoPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _ := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if volumeSource == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Spec does not reference a Git repo volume type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%v:%v:%v",
0000000000000000000000000000000000000000;;			volumeSource.Repository,
0000000000000000000000000000000000000000;;			volumeSource.Revision,
0000000000000000000000000000000000000000;;			volumeSource.Directory), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return spec.Volume != nil && spec.Volume.GitRepo != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return &gitRepoVolumeMounter{
0000000000000000000000000000000000000000;;			gitRepoVolume: &gitRepoVolume{
0000000000000000000000000000000000000000;;				volName: spec.Name(),
0000000000000000000000000000000000000000;;				podUID:  pod.UID,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			pod:      *pod,
0000000000000000000000000000000000000000;;			source:   spec.Volume.GitRepo.Repository,
0000000000000000000000000000000000000000;;			revision: spec.Volume.GitRepo.Revision,
0000000000000000000000000000000000000000;;			target:   spec.Volume.GitRepo.Directory,
0000000000000000000000000000000000000000;;			exec:     exec.New(),
0000000000000000000000000000000000000000;;			opts:     opts,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &gitRepoVolumeUnmounter{
0000000000000000000000000000000000000000;;			&gitRepoVolume{
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *gitRepoPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		gitVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				GitRepo: &v1.GitRepoVolumeSource{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(gitVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gitRepo volumes are directories which are pre-filled from a git repository.
0000000000000000000000000000000000000000;;	// These do not persist beyond the lifetime of a pod.
0000000000000000000000000000000000000000;;	type gitRepoVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		plugin  *gitRepoPlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Volume = &gitRepoVolume{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gr *gitRepoVolume) GetPath() string {
0000000000000000000000000000000000000000;;		name := gitRepoPluginName
0000000000000000000000000000000000000000;;		return gr.plugin.host.GetPodVolumeDir(gr.podUID, utilstrings.EscapeQualifiedNameForDisk(name), gr.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gitRepoVolumeMounter builds git repo volumes.
0000000000000000000000000000000000000000;;	type gitRepoVolumeMounter struct {
0000000000000000000000000000000000000000;;		*gitRepoVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod      v1.Pod
0000000000000000000000000000000000000000;;		source   string
0000000000000000000000000000000000000000;;		revision string
0000000000000000000000000000000000000000;;		target   string
0000000000000000000000000000000000000000;;		exec     exec.Interface
0000000000000000000000000000000000000000;;		opts     volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &gitRepoVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *gitRepoVolumeMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        false,
0000000000000000000000000000000000000000;;			Managed:         true,
0000000000000000000000000000000000000000;;			SupportsSELinux: true, // xattr change should be okay, TODO: double check
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *gitRepoVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp creates new directory and clones a git repo.
0000000000000000000000000000000000000000;;	func (b *gitRepoVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt creates new directory and clones a git repo.
0000000000000000000000000000000000000000;;	func (b *gitRepoVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		if volumeutil.IsReady(b.getMetaDir()) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wrap EmptyDir, let it do the setup.
0000000000000000000000000000000000000000;;		wrapped, err := b.plugin.host.NewWrapperMounter(b.volName, wrappedVolumeSpec(), &b.pod, b.opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wrapped.SetUpAt(dir, fsGroup); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := []string{"clone", b.source}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.target) != 0 {
0000000000000000000000000000000000000000;;			args = append(args, b.target)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if output, err := b.execCommand("git", args, dir); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to exec 'git %s': %s: %v",
0000000000000000000000000000000000000000;;				strings.Join(args, " "), output, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.revision) == 0 {
0000000000000000000000000000000000000000;;			// Done!
0000000000000000000000000000000000000000;;			volumeutil.SetReady(b.getMetaDir())
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var subdir string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b.target == ".":
0000000000000000000000000000000000000000;;			// if target dir is '.', use the current dir
0000000000000000000000000000000000000000;;			subdir = path.Join(dir)
0000000000000000000000000000000000000000;;		case len(files) == 1:
0000000000000000000000000000000000000000;;			// if target is not '.', use the generated folder
0000000000000000000000000000000000000000;;			subdir = path.Join(dir, files[0].Name())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// if target is not '.', but generated many files, it's wrong
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected directory contents: %v", files)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if output, err := b.execCommand("git", []string{"checkout", b.revision}, subdir); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to exec 'git checkout %s': %s: %v", b.revision, output, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if output, err := b.execCommand("git", []string{"reset", "--hard"}, subdir); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to exec 'git reset --hard': %s: %v", output, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeutil.SetReady(b.getMetaDir())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *gitRepoVolumeMounter) getMetaDir() string {
0000000000000000000000000000000000000000;;		return path.Join(b.plugin.host.GetPodPluginDir(b.podUID, utilstrings.EscapeQualifiedNameForDisk(gitRepoPluginName)), b.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *gitRepoVolumeMounter) execCommand(command string, args []string, dir string) ([]byte, error) {
0000000000000000000000000000000000000000;;		cmd := b.exec.Command(command, args...)
0000000000000000000000000000000000000000;;		cmd.SetDir(dir)
0000000000000000000000000000000000000000;;		return cmd.CombinedOutput()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gitRepoVolumeUnmounter cleans git repo volumes.
0000000000000000000000000000000000000000;;	type gitRepoVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*gitRepoVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &gitRepoVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDown simply deletes everything in the directory.
0000000000000000000000000000000000000000;;	func (c *gitRepoVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDownAt simply deletes everything in the directory.
0000000000000000000000000000000000000000;;	func (c *gitRepoVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return volume.UnmountViaEmptyDir(dir, c.plugin.host, c.volName, wrappedVolumeSpec(), c.podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.GitRepoVolumeSource, bool) {
0000000000000000000000000000000000000000;;		var readOnly bool
0000000000000000000000000000000000000000;;		var volumeSource *v1.GitRepoVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.GitRepo != nil {
0000000000000000000000000000000000000000;;			volumeSource = spec.Volume.GitRepo
0000000000000000000000000000000000000000;;			readOnly = spec.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource, readOnly
0000000000000000000000000000000000000000;;	}
