0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d3342ef184d2fe00b2aea4310cae8fa7797b21d3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure_dd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ioHandler interface {
0000000000000000000000000000000000000000;;		ReadDir(dirname string) ([]os.FileInfo, error)
0000000000000000000000000000000000000000;;		WriteFile(filename string, data []byte, perm os.FileMode) error
0000000000000000000000000000000000000000;;		Readlink(name string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type osIOHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *osIOHandler) ReadDir(dirname string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return ioutil.ReadDir(dirname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (handler *osIOHandler) WriteFile(filename string, data []byte, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(filename, data, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (handler *osIOHandler) Readlink(name string) (string, error) {
0000000000000000000000000000000000000000;;		return os.Readlink(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exclude those used by azure as resource and OS root in /dev/disk/azure
0000000000000000000000000000000000000000;;	func listAzureDiskPath(io ioHandler) []string {
0000000000000000000000000000000000000000;;		azureDiskPath := "/dev/disk/azure/"
0000000000000000000000000000000000000000;;		var azureDiskList []string
0000000000000000000000000000000000000000;;		if dirs, err := io.ReadDir(azureDiskPath); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				name := f.Name()
0000000000000000000000000000000000000000;;				diskPath := azureDiskPath + name
0000000000000000000000000000000000000000;;				if link, linkErr := io.Readlink(diskPath); linkErr == nil {
0000000000000000000000000000000000000000;;					sd := link[(strings.LastIndex(link, "/") + 1):]
0000000000000000000000000000000000000000;;					azureDiskList = append(azureDiskList, sd)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(12).Infof("Azure sys disks paths: %v", azureDiskList)
0000000000000000000000000000000000000000;;		return azureDiskList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// given a LUN find the VHD device path like /dev/sdd
0000000000000000000000000000000000000000;;	// exclude those disks used by Azure resources and OS root
0000000000000000000000000000000000000000;;	func findDiskByLun(lun int, io ioHandler, exe exec.Interface) (string, error) {
0000000000000000000000000000000000000000;;		azureDisks := listAzureDiskPath(io)
0000000000000000000000000000000000000000;;		return findDiskByLunWithConstraint(lun, io, exe, azureDisks)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// look for device /dev/sdX and validate it is a VHD
0000000000000000000000000000000000000000;;	// return empty string if no disk is found
0000000000000000000000000000000000000000;;	func findDiskByLunWithConstraint(lun int, io ioHandler, exe exec.Interface, azureDisks []string) (string, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		sys_path := "/sys/bus/scsi/devices"
0000000000000000000000000000000000000000;;		if dirs, err := io.ReadDir(sys_path); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				name := f.Name()
0000000000000000000000000000000000000000;;				// look for path like /sys/bus/scsi/devices/3:0:0:1
0000000000000000000000000000000000000000;;				arr := strings.Split(name, ":")
0000000000000000000000000000000000000000;;				if len(arr) < 4 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// extract LUN from the path.
0000000000000000000000000000000000000000;;				// LUN is the last index of the array, i.e. 1 in /sys/bus/scsi/devices/3:0:0:1
0000000000000000000000000000000000000000;;				l, err := strconv.Atoi(arr[3])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// unknown path format, continue to read the next one
0000000000000000000000000000000000000000;;					glog.Errorf("failed to parse lun from %v (%v), err %v", arr[3], name, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if lun == l {
0000000000000000000000000000000000000000;;					// find the matching LUN
0000000000000000000000000000000000000000;;					// read vendor and model to ensure it is a VHD disk
0000000000000000000000000000000000000000;;					vendor := path.Join(sys_path, name, "vendor")
0000000000000000000000000000000000000000;;					model := path.Join(sys_path, name, "model")
0000000000000000000000000000000000000000;;					out, err := exe.Command("cat", vendor, model).CombinedOutput()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("failed to cat device vendor and model, err: %v", err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					matched, err := regexp.MatchString("^MSFT[ ]{0,}\nVIRTUAL DISK[ ]{0,}\n$", strings.ToUpper(string(out)))
0000000000000000000000000000000000000000;;					if err != nil || !matched {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("doesn't match VHD, output %v, error %v", string(out), err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// find a disk, validate name
0000000000000000000000000000000000000000;;					dir := path.Join(sys_path, name, "block")
0000000000000000000000000000000000000000;;					if dev, err := io.ReadDir(dir); err == nil {
0000000000000000000000000000000000000000;;						found := false
0000000000000000000000000000000000000000;;						for _, diskName := range azureDisks {
0000000000000000000000000000000000000000;;							glog.V(12).Infof("validating disk %q with sys disk %q", dev[0].Name(), diskName)
0000000000000000000000000000000000000000;;							if string(dev[0].Name()) == diskName {
0000000000000000000000000000000000000000;;								found = true
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !found {
0000000000000000000000000000000000000000;;							return "/dev/" + dev[0].Name(), nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rescan scsi bus
0000000000000000000000000000000000000000;;	func scsiHostRescan(io ioHandler) {
0000000000000000000000000000000000000000;;		scsi_path := "/sys/class/scsi_host/"
0000000000000000000000000000000000000000;;		if dirs, err := io.ReadDir(scsi_path); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				name := scsi_path + f.Name() + "/scan"
0000000000000000000000000000000000000000;;				data := []byte("- - -")
0000000000000000000000000000000000000000;;				if err = io.WriteFile(name, data, 0666); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to rescan scsi host %s", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to read %s, err %v", scsi_path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
