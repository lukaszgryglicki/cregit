0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d3342ef184d2fe00b2aea4310cae8fa7797b21d3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure_dd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/compute"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider/providers/azure"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/keymutex"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		utilstrings "k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&azureDataDiskPlugin{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureDataDiskPlugin struct {
0000000000000000000000000000000000000000;;		host        volume.VolumeHost
0000000000000000000000000000000000000000;;		volumeLocks keymutex.KeyMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstract interface to disk operations.
0000000000000000000000000000000000000000;;	// azure cloud provider should implement it
0000000000000000000000000000000000000000;;	type azureCloudProvider interface {
0000000000000000000000000000000000000000;;		// Attaches the disk to the host machine.
0000000000000000000000000000000000000000;;		AttachDisk(diskName, diskUri string, nodeName types.NodeName, lun int32, cachingMode compute.CachingTypes) error
0000000000000000000000000000000000000000;;		// Detaches the disk, identified by disk name or uri, from the host machine.
0000000000000000000000000000000000000000;;		DetachDiskByName(diskName, diskUri string, nodeName types.NodeName) error
0000000000000000000000000000000000000000;;		// Check if a list of volumes are attached to the node with the specified NodeName
0000000000000000000000000000000000000000;;		DisksAreAttached(diskNames []string, nodeName types.NodeName) (map[string]bool, error)
0000000000000000000000000000000000000000;;		// Get the LUN number of the disk that is attached to the host
0000000000000000000000000000000000000000;;		GetDiskLun(diskName, diskUri string, nodeName types.NodeName) (int32, error)
0000000000000000000000000000000000000000;;		// Get the next available LUN number to attach a new VHD
0000000000000000000000000000000000000000;;		GetNextDiskLun(nodeName types.NodeName) (int32, error)
0000000000000000000000000000000000000000;;		// InstanceID returns the cloud provider ID of the specified instance.
0000000000000000000000000000000000000000;;		InstanceID(nodeName types.NodeName) (string, error)
0000000000000000000000000000000000000000;;		// Create a VHD blob
0000000000000000000000000000000000000000;;		CreateVolume(name, storageAccount, storageType, location string, requestGB int) (string, string, int, error)
0000000000000000000000000000000000000000;;		// Delete a VHD blob
0000000000000000000000000000000000000000;;		DeleteVolume(name, uri string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &azureDataDiskPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &azureDataDiskPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		azureDataDiskPluginName = "kubernetes.io/azure-disk"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		plugin.volumeLocks = keymutex.NewKeyMutex()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return azureDataDiskPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource.DiskName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.AzureDisk != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.AzureDisk != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		// azures used directly in a pod have a ReadOnly flag set by the pod author.
0000000000000000000000000000000000000000;;		// azures used as a PersistentVolume gets the ReadOnly flag indirectly through the persistent-claim volume used to mount the PV
0000000000000000000000000000000000000000;;		azure, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fsType := "ext4"
0000000000000000000000000000000000000000;;		if azure.FSType != nil {
0000000000000000000000000000000000000000;;			fsType = *azure.FSType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cachingMode := v1.AzureDataDiskCachingNone
0000000000000000000000000000000000000000;;		if azure.CachingMode != nil {
0000000000000000000000000000000000000000;;			cachingMode = *azure.CachingMode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readOnly := false
0000000000000000000000000000000000000000;;		if azure.ReadOnly != nil {
0000000000000000000000000000000000000000;;			readOnly = *azure.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diskName := azure.DiskName
0000000000000000000000000000000000000000;;		diskUri := azure.DataDiskURI
0000000000000000000000000000000000000000;;		return &azureDiskMounter{
0000000000000000000000000000000000000000;;			azureDisk: &azureDisk{
0000000000000000000000000000000000000000;;				podUID:      podUID,
0000000000000000000000000000000000000000;;				volName:     spec.Name(),
0000000000000000000000000000000000000000;;				diskName:    diskName,
0000000000000000000000000000000000000000;;				diskUri:     diskUri,
0000000000000000000000000000000000000000;;				cachingMode: cachingMode,
0000000000000000000000000000000000000000;;				mounter:     mounter,
0000000000000000000000000000000000000000;;				plugin:      plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			fsType:      fsType,
0000000000000000000000000000000000000000;;			readOnly:    readOnly,
0000000000000000000000000000000000000000;;			diskMounter: &mount.SafeFormatAndMount{Interface: plugin.host.GetMounter(), Runner: exec.New()}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) newUnmounterInternal(volName string, podUID types.UID, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &azureDiskUnmounter{
0000000000000000000000000000000000000000;;			&azureDisk{
0000000000000000000000000000000000000000;;				podUID:  podUID,
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				mounter: mounter,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) ConstructVolumeSpec(volName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		pluginDir := plugin.host.GetPluginDir(plugin.GetPluginName())
0000000000000000000000000000000000000000;;		sourceName, err := mounter.GetDeviceNameFromMount(mountPath, pluginDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		azVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				AzureDisk: &v1.AzureDiskVolumeSource{
0000000000000000000000000000000000000000;;					DiskName: sourceName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(azVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) GetDeviceMountRefs(deviceMountPath string) ([]string, error) {
0000000000000000000000000000000000000000;;		mounter := plugin.host.GetMounter()
0000000000000000000000000000000000000000;;		return mount.GetMountRefs(mounter, deviceMountPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureDisk struct {
0000000000000000000000000000000000000000;;		volName     string
0000000000000000000000000000000000000000;;		podUID      types.UID
0000000000000000000000000000000000000000;;		diskName    string
0000000000000000000000000000000000000000;;		diskUri     string
0000000000000000000000000000000000000000;;		cachingMode v1.AzureDataDiskCachingMode
0000000000000000000000000000000000000000;;		mounter     mount.Interface
0000000000000000000000000000000000000000;;		plugin      *azureDataDiskPlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureDiskMounter struct {
0000000000000000000000000000000000000000;;		*azureDisk
0000000000000000000000000000000000000000;;		// Filesystem type, optional.
0000000000000000000000000000000000000000;;		fsType string
0000000000000000000000000000000000000000;;		// Specifies whether the disk will be attached as read-only.
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;		// diskMounter provides the interface that is used to mount the actual block device.
0000000000000000000000000000000000000000;;		diskMounter *mount.SafeFormatAndMount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &azureDiskMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *azureDiskMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         !b.readOnly,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *azureDiskMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *azureDiskMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (b *azureDiskMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		b.plugin.volumeLocks.LockKey(b.diskName)
0000000000000000000000000000000000000000;;		defer b.plugin.volumeLocks.UnlockKey(b.diskName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: handle failed mounts here.
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("DataDisk set up: %s %v %v", dir, !notMnt, err)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("IsLikelyNotMountPoint failed: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("%s is a mount point", dir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		globalPDPath := makeGlobalPDPath(b.plugin.host, b.diskName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Could not create directory %s: %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a bind mount to the full path to allow duplicate mounts of the same PD.
0000000000000000000000000000000000000000;;		options := []string{"bind"}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = b.mounter.Mount(globalPDPath, dir, "", options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;			if mntErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !notMnt {
0000000000000000000000000000000000000000;;				if mntErr = b.mounter.Unmount(dir); mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to unmount: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;				if mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !notMnt {
0000000000000000000000000000000000000000;;					// This is very odd, we don't expect it.  We'll try again next sync loop.
0000000000000000000000000000000000000000;;					glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.", dir)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Remove(dir)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !b.readOnly {
0000000000000000000000000000000000000000;;			volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Azure disk volume %s mounted to %s", b.diskName, dir)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeGlobalPDPath(host volume.VolumeHost, volume string) string {
0000000000000000000000000000000000000000;;		return path.Join(host.GetPluginDir(azureDataDiskPluginName), mount.MountsInGlobalPDPath, volume)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (azure *azureDisk) GetPath() string {
0000000000000000000000000000000000000000;;		name := azureDataDiskPluginName
0000000000000000000000000000000000000000;;		return azure.plugin.host.GetPodVolumeDir(azure.podUID, utilstrings.EscapeQualifiedNameForDisk(name), azure.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureDiskUnmounter struct {
0000000000000000000000000000000000000000;;		*azureDisk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &azureDiskUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *azureDiskUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *azureDiskUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		if pathExists, pathErr := util.PathExists(dir); pathErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error checking if path exists: %v", pathErr)
0000000000000000000000000000000000000000;;		} else if !pathExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: Unmount skipped because path does not exist: %v", dir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		notMnt, err := c.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error checking if mountpoint %s: %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			glog.V(2).Info("Not mountpoint, deleting")
0000000000000000000000000000000000000000;;			return os.Remove(dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// lock the volume (and thus wait for any concurrrent SetUpAt to finish)
0000000000000000000000000000000000000000;;		c.plugin.volumeLocks.LockKey(c.diskName)
0000000000000000000000000000000000000000;;		defer c.plugin.volumeLocks.UnlockKey(c.diskName)
0000000000000000000000000000000000000000;;		refs, err := mount.GetMountRefs(c.mounter, dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error getting mountrefs for %s: %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(refs) == 0 {
0000000000000000000000000000000000000000;;			glog.Errorf("Did not find pod-mount for %s during tear down", dir)
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s is not mounted", dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.diskName = path.Base(refs[0])
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Found volume %s mounted to %s", c.diskName, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unmount the bind-mount inside this pod
0000000000000000000000000000000000000000;;		if err := c.mounter.Unmount(dir); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error unmounting dir %s %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		notMnt, mntErr := c.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		if mntErr != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("IsLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			if err := os.Remove(dir); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error removing mountpoint %s %v", dir, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.AzureDiskVolumeSource, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.AzureDisk != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.AzureDisk, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.AzureDisk != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.AzureDisk, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Spec does not reference an Azure disk volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return cloud provider
0000000000000000000000000000000000000000;;	func getAzureCloudProvider(cloudProvider cloudprovider.Interface) (azureCloudProvider, error) {
0000000000000000000000000000000000000000;;		azureCloudProvider, ok := cloudProvider.(*azure.Cloud)
0000000000000000000000000000000000000000;;		if !ok || azureCloudProvider == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to get Azure Cloud Provider. GetCloudProvider returned %v instead", cloudProvider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return azureCloudProvider, nil
0000000000000000000000000000000000000000;;	}
