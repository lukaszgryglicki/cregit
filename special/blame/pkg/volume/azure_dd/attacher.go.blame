0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d3342ef184d2fe00b2aea4310cae8fa7797b21d3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure_dd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/azure-sdk-for-go/arm/compute"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/keymutex"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureDiskAttacher struct {
0000000000000000000000000000000000000000;;		host          volume.VolumeHost
0000000000000000000000000000000000000000;;		azureProvider azureCloudProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Attacher = &azureDiskAttacher{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.AttachableVolumePlugin = &azureDataDiskPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		checkSleepDuration = time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// acquire lock to get an lun number
0000000000000000000000000000000000000000;;	var getLunMutex = keymutex.NewKeyMutex()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAttacher initializes an Attacher
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) NewAttacher() (volume.Attacher, error) {
0000000000000000000000000000000000000000;;		azure, err := getAzureCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("failed to get azure provider")
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &azureDiskAttacher{
0000000000000000000000000000000000000000;;			host:          plugin.host,
0000000000000000000000000000000000000000;;			azureProvider: azure,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attach attaches a volume.Spec to an Azure VM referenced by NodeName, returning the disk's LUN
0000000000000000000000000000000000000000;;	func (attacher *azureDiskAttacher) Attach(spec *volume.Spec, nodeName types.NodeName) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("failed to get azure disk spec")
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instanceid, err := attacher.azureProvider.InstanceID(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("failed to get azure instance id")
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get azure instance id for node %q", nodeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ind := strings.LastIndex(instanceid, "/"); ind >= 0 {
0000000000000000000000000000000000000000;;			instanceid = instanceid[(ind + 1):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lun, err := attacher.azureProvider.GetDiskLun(volumeSource.DiskName, volumeSource.DataDiskURI, nodeName)
0000000000000000000000000000000000000000;;		if err == cloudprovider.InstanceNotFound {
0000000000000000000000000000000000000000;;			// Log error and continue with attach
0000000000000000000000000000000000000000;;			glog.Warningf(
0000000000000000000000000000000000000000;;				"Error checking if volume is already attached to current node (%q). Will continue and try attach anyway. err=%v",
0000000000000000000000000000000000000000;;				instanceid, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// Volume is already attached to node.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Attach operation is successful. volume %q is already attached to node %q at lun %d.", volumeSource.DiskName, instanceid, lun)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("GetDiskLun returned: %v. Initiating attaching volume %q to node %q.", err, volumeSource.DataDiskURI, nodeName)
0000000000000000000000000000000000000000;;			getLunMutex.LockKey(instanceid)
0000000000000000000000000000000000000000;;			defer getLunMutex.UnlockKey(instanceid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lun, err = attacher.azureProvider.GetNextDiskLun(nodeName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("no LUN available for instance %q", nodeName)
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("all LUNs are used, cannot attach volume %q to instance %q", volumeSource.DiskName, instanceid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Trying to attach volume %q lun %d to node %q.", volumeSource.DataDiskURI, lun, nodeName)
0000000000000000000000000000000000000000;;			err = attacher.azureProvider.AttachDisk(volumeSource.DiskName, volumeSource.DataDiskURI, nodeName, lun, compute.CachingTypes(*volumeSource.CachingMode))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Attach operation successful: volume %q attached to node %q.", volumeSource.DataDiskURI, nodeName)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Attach volume %q to instance %q failed with %v", volumeSource.DataDiskURI, instanceid, err)
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("Attach volume %q to instance %q failed with %v", volumeSource.DiskName, instanceid, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strconv.Itoa(int(lun)), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (attacher *azureDiskAttacher) VolumesAreAttached(specs []*volume.Spec, nodeName types.NodeName) (map[*volume.Spec]bool, error) {
0000000000000000000000000000000000000000;;		volumesAttachedCheck := make(map[*volume.Spec]bool)
0000000000000000000000000000000000000000;;		volumeSpecMap := make(map[string]*volume.Spec)
0000000000000000000000000000000000000000;;		volumeIDList := []string{}
0000000000000000000000000000000000000000;;		for _, spec := range specs {
0000000000000000000000000000000000000000;;			volumeSource, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Error getting volume (%q) source : %v", spec.Name(), err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			volumeIDList = append(volumeIDList, volumeSource.DiskName)
0000000000000000000000000000000000000000;;			volumesAttachedCheck[spec] = true
0000000000000000000000000000000000000000;;			volumeSpecMap[volumeSource.DiskName] = spec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attachedResult, err := attacher.azureProvider.DisksAreAttached(volumeIDList, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log error and continue with attach
0000000000000000000000000000000000000000;;			glog.Errorf(
0000000000000000000000000000000000000000;;				"Error checking if volumes (%v) are attached to current node (%q). err=%v",
0000000000000000000000000000000000000000;;				volumeIDList, nodeName, err)
0000000000000000000000000000000000000000;;			return volumesAttachedCheck, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for volumeID, attached := range attachedResult {
0000000000000000000000000000000000000000;;			if !attached {
0000000000000000000000000000000000000000;;				spec := volumeSpecMap[volumeID]
0000000000000000000000000000000000000000;;				volumesAttachedCheck[spec] = false
0000000000000000000000000000000000000000;;				glog.V(2).Infof("VolumesAreAttached: check volume %q (specName: %q) is no longer attached", volumeID, spec.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumesAttachedCheck, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForAttach runs on the node to detect if the volume (referenced by LUN) is attached. If attached, the device path is returned
0000000000000000000000000000000000000000;;	func (attacher *azureDiskAttacher) WaitForAttach(spec *volume.Spec, lunStr string, timeout time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(lunStr) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("WaitForAttach failed for Azure disk %q: lun is empty.", volumeSource.DiskName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lun, err := strconv.Atoi(lunStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("WaitForAttach: wrong lun %q, err: %v", lunStr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scsiHostRescan(&osIOHandler{})
0000000000000000000000000000000000000000;;		exe := exec.New()
0000000000000000000000000000000000000000;;		devicePath := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = wait.Poll(checkSleepDuration, timeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Checking Azure disk %q(lun %s) is attached.", volumeSource.DiskName, lunStr)
0000000000000000000000000000000000000000;;			if devicePath, err = findDiskByLun(lun, &osIOHandler{}, exe); err == nil {
0000000000000000000000000000000000000000;;				if len(devicePath) == 0 {
0000000000000000000000000000000000000000;;					glog.Warningf("cannot find attached Azure disk %q(lun %s) locally.", volumeSource.DiskName, lunStr)
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("cannot find attached Azure disk %q(lun %s) locally.", volumeSource.DiskName, lunStr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Successfully found attached Azure disk %q(lun %s, device path %s).", volumeSource.DiskName, lunStr, devicePath)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				//Log error, if any, and continue checking periodically
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Error Stat Azure disk (%q) is attached: %v", volumeSource.DiskName, err)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return devicePath, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDeviceMountPath finds the volume's mount path on the node
0000000000000000000000000000000000000000;;	func (attacher *azureDiskAttacher) GetDeviceMountPath(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return makeGlobalPDPath(attacher.host, volumeSource.DiskName), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MountDevice runs mount command on the node to mount the volume
0000000000000000000000000000000000000000;;	func (attacher *azureDiskAttacher) MountDevice(spec *volume.Spec, devicePath string, deviceMountPath string) error {
0000000000000000000000000000000000000000;;		mounter := attacher.host.GetMounter()
0000000000000000000000000000000000000000;;		notMnt, err := mounter.IsLikelyNotMountPoint(deviceMountPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(deviceMountPath, 0750); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeSource, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := []string{}
0000000000000000000000000000000000000000;;		if spec.ReadOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notMnt {
0000000000000000000000000000000000000000;;			diskMounter := &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()}
0000000000000000000000000000000000000000;;			mountOptions := volume.MountOptionFromSpec(spec, options...)
0000000000000000000000000000000000000000;;			err = diskMounter.FormatAndMount(devicePath, deviceMountPath, *volumeSource.FSType, mountOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				os.Remove(deviceMountPath)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureDiskDetacher struct {
0000000000000000000000000000000000000000;;		mounter       mount.Interface
0000000000000000000000000000000000000000;;		azureProvider azureCloudProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Detacher = &azureDiskDetacher{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDetacher initializes a volume Detacher
0000000000000000000000000000000000000000;;	func (plugin *azureDataDiskPlugin) NewDetacher() (volume.Detacher, error) {
0000000000000000000000000000000000000000;;		azure, err := getAzureCloudProvider(plugin.host.GetCloudProvider())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &azureDiskDetacher{
0000000000000000000000000000000000000000;;			mounter:       plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;			azureProvider: azure,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detach detaches disk from Azure VM.
0000000000000000000000000000000000000000;;	func (detacher *azureDiskDetacher) Detach(diskName string, nodeName types.NodeName) error {
0000000000000000000000000000000000000000;;		if diskName == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid disk to detach: %q", diskName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		instanceid, err := detacher.azureProvider.InstanceID(nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("no instance id for node %q, skip detaching", nodeName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ind := strings.LastIndex(instanceid, "/"); ind >= 0 {
0000000000000000000000000000000000000000;;			instanceid = instanceid[(ind + 1):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("detach %v from node %q", diskName, nodeName)
0000000000000000000000000000000000000000;;		err = detacher.azureProvider.DetachDiskByName(diskName, "" /* diskURI */, nodeName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to detach azure disk %q, err %v", diskName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmountDevice unmounts the volume on the node
0000000000000000000000000000000000000000;;	func (detacher *azureDiskDetacher) UnmountDevice(deviceMountPath string) error {
0000000000000000000000000000000000000000;;		volume := path.Base(deviceMountPath)
0000000000000000000000000000000000000000;;		if err := util.UnmountPath(deviceMountPath, detacher.mounter); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error unmounting %q: %v", volume, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
