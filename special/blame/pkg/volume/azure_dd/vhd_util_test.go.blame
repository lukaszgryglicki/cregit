0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d3342ef184d2fe00b2aea4310cae8fa7797b21d3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure_dd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeFileInfo struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Name() string {
0000000000000000000000000000000000000000;;		return fi.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Size() int64 {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Mode() os.FileMode {
0000000000000000000000000000000000000000;;		return 777
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) ModTime() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) IsDir() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi *fakeFileInfo) Sys() interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		lun       = 1
0000000000000000000000000000000000000000;;		lunStr    = "1"
0000000000000000000000000000000000000000;;		diskPath  = "4:0:0:" + lunStr
0000000000000000000000000000000000000000;;		devName   = "sdd"
0000000000000000000000000000000000000000;;		lun1      = 2
0000000000000000000000000000000000000000;;		lunStr1   = "2"
0000000000000000000000000000000000000000;;		diskPath1 = "3:0:0:" + lunStr1
0000000000000000000000000000000000000000;;		devName1  = "sde"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeIOHandler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *fakeIOHandler) ReadDir(dirname string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		switch dirname {
0000000000000000000000000000000000000000;;		case "/sys/bus/scsi/devices":
0000000000000000000000000000000000000000;;			f1 := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "3:0:0:1",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f2 := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "4:0:0:0",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f3 := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: diskPath,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f4 := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "host1",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f5 := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: "target2:0:0",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []os.FileInfo{f1, f2, f3, f4, f5}, nil
0000000000000000000000000000000000000000;;		case "/sys/bus/scsi/devices/" + diskPath + "/block":
0000000000000000000000000000000000000000;;			n := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: devName,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []os.FileInfo{n}, nil
0000000000000000000000000000000000000000;;		case "/sys/bus/scsi/devices/" + diskPath1 + "/block":
0000000000000000000000000000000000000000;;			n := &fakeFileInfo{
0000000000000000000000000000000000000000;;				name: devName1,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []os.FileInfo{n}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("bad dir")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *fakeIOHandler) WriteFile(filename string, data []byte, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *fakeIOHandler) Readlink(name string) (string, error) {
0000000000000000000000000000000000000000;;		return "/dev/azure/disk/sda", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIoHandler(t *testing.T) {
0000000000000000000000000000000000000000;;		var fcmd exec.FakeCmd
0000000000000000000000000000000000000000;;		fcmd = exec.FakeCmd{
0000000000000000000000000000000000000000;;			CombinedOutputScript: []exec.FakeCombinedOutputAction{
0000000000000000000000000000000000000000;;				// cat
0000000000000000000000000000000000000000;;				func() ([]byte, error) {
0000000000000000000000000000000000000000;;					return []byte("Msft    \nVirtual Disk \n"), nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// cat
0000000000000000000000000000000000000000;;				func() ([]byte, error) {
0000000000000000000000000000000000000000;;					return []byte("Msft    \nVirtual Disk \n"), nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fake := exec.FakeExec{
0000000000000000000000000000000000000000;;			CommandScript: []exec.FakeCommandAction{
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;				func(cmd string, args ...string) exec.Cmd { return exec.InitFakeCmd(&fcmd, cmd, args...) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disk, err := findDiskByLun(lun, &fakeIOHandler{}, &fake)
0000000000000000000000000000000000000000;;		// if no disk matches lun, exit
0000000000000000000000000000000000000000;;		if disk != "/dev/"+devName || err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("no data disk found: disk %v err %v", disk, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
