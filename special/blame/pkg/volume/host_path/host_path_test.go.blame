0000000000000000000000000000000000000000;;	// +build linux
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/host_path/host_path_test.go[pkg/kubelet/volume/host_path/host_path_test.go][pkg/volume/host_path/host_path_test.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package host_path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{}), volumetest.NewFakeVolumeHost("fake", nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/host-path")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.GetPluginName() != "kubernetes.io/host-path" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plug.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{HostPath: &v1.HostPathVolumeSource{}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plug.CanSupport(&volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{HostPath: &v1.HostPathVolumeSource{}}}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{}), volumetest.NewFakeVolumeHost("/tmp/fake", nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPersistentPluginByName("kubernetes.io/host-path")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(plug.GetAccessModes()) != 1 || plug.GetAccessModes()[0] != v1.ReadWriteOnce {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s PersistentVolumeAccessMode", v1.ReadWriteOnce)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRecycler(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		pluginHost := volumetest.NewFakeVolumeHost("/tmp/fake", nil, nil)
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins([]volume.VolumePlugin{&hostPathPlugin{nil, volume.VolumeConfig{}}}, pluginHost)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec := &volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{HostPath: &v1.HostPathVolumeSource{Path: "/foo"}}}}}
0000000000000000000000000000000000000000;;		_, err := plugMgr.FindRecyclablePluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleter(t *testing.T) {
0000000000000000000000000000000000000000;;		// Deleter has a hard-coded regex for "/tmp".
0000000000000000000000000000000000000000;;		tempPath := fmt.Sprintf("/tmp/hostpath/%s", uuid.NewUUID())
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tempPath)
0000000000000000000000000000000000000000;;		err := os.MkdirAll(tempPath, 0750)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to create tmp directory for deleter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{}), volumetest.NewFakeVolumeHost("/tmp/fake", nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec := &volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{HostPath: &v1.HostPathVolumeSource{Path: tempPath}}}}}
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindDeletablePluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deleter, err := plug.NewDeleter(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Deleter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deleter.GetPath() != tempPath {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %s but got %s", tempPath, deleter.GetPath())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := deleter.Delete(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Mock Recycler expected to return nil but got %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists, _ := util.FileExists("foo"); exists {
0000000000000000000000000000000000000000;;			t.Errorf("Temp path expected to be deleted, but was found at %s", tempPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeleterTempDir(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			expectedFailure bool
0000000000000000000000000000000000000000;;			path            string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"just-tmp": {true, "/tmp"},
0000000000000000000000000000000000000000;;			"not-tmp":  {true, "/nottmp"},
0000000000000000000000000000000000000000;;			"good-tmp": {false, "/tmp/scratch"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, test := range tests {
0000000000000000000000000000000000000000;;			plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;			plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{}), volumetest.NewFakeVolumeHost("/tmp/fake", nil, nil))
0000000000000000000000000000000000000000;;			spec := &volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{HostPath: &v1.HostPathVolumeSource{Path: test.path}}}}}
0000000000000000000000000000000000000000;;			plug, _ := plugMgr.FindDeletablePluginBySpec(spec)
0000000000000000000000000000000000000000;;			deleter, _ := plug.NewDeleter(spec)
0000000000000000000000000000000000000000;;			err := deleter.Delete()
0000000000000000000000000000000000000000;;			if err == nil && test.expectedFailure {
0000000000000000000000000000000000000000;;				t.Errorf("Expected failure for test '%s' but got nil err", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !test.expectedFailure {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected failure for test '%s': %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProvisioner(t *testing.T) {
0000000000000000000000000000000000000000;;		tempPath := fmt.Sprintf("/tmp/hostpath/%s", uuid.NewUUID())
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tempPath)
0000000000000000000000000000000000000000;;		err := os.MkdirAll(tempPath, 0750)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{ProvisioningEnabled: true}),
0000000000000000000000000000000000000000;;			volumetest.NewFakeVolumeHost("/tmp/fake", nil, nil))
0000000000000000000000000000000000000000;;		spec := &volume.Spec{PersistentVolume: &v1.PersistentVolume{Spec: v1.PersistentVolumeSpec{PersistentVolumeSource: v1.PersistentVolumeSource{HostPath: &v1.HostPathVolumeSource{Path: tempPath}}}}}
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindCreatablePluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options := volume.VolumeOptions{
0000000000000000000000000000000000000000;;			PVC: volumetest.CreateTestPVC("1Gi", []v1.PersistentVolumeAccessMode{v1.ReadWriteOnce}),
0000000000000000000000000000000000000000;;			PersistentVolumeReclaimPolicy: v1.PersistentVolumeReclaimDelete,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		creater, err := plug.NewProvisioner(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Provisioner: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv, err := creater.Provision()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error creating volume: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pv.Spec.HostPath.Path == "" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected pv.Spec.HostPath.Path to not be empty: %#v", pv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedCapacity := resource.NewQuantity(1*1024*1024*1024, resource.BinarySI)
0000000000000000000000000000000000000000;;		actualCapacity := pv.Spec.Capacity[v1.ResourceStorage]
0000000000000000000000000000000000000000;;		expectedAmt := expectedCapacity.Value()
0000000000000000000000000000000000000000;;		actualAmt := actualCapacity.Value()
0000000000000000000000000000000000000000;;		if expectedAmt != actualAmt {
0000000000000000000000000000000000000000;;			t.Errorf("Expected capacity %+v but got %+v", expectedAmt, actualAmt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pv.Spec.PersistentVolumeReclaimPolicy != v1.PersistentVolumeReclaimDelete {
0000000000000000000000000000000000000000;;			t.Errorf("Expected reclaim policy %+v but got %+v", v1.PersistentVolumeReclaimDelete, pv.Spec.PersistentVolumeReclaimPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os.RemoveAll(pv.Spec.HostPath.Path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInvalidHostPath(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{}), volumetest.NewFakeVolumeHost("fake", nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName(hostPathPluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unable to find plugin %s by name: %v", hostPathPluginName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		spec := &v1.Volume{
0000000000000000000000000000000000000000;;			Name:         "vol1",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{HostPath: &v1.HostPathVolumeSource{Path: "/no/backsteps/allowed/.."}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, err := plug.NewMounter(volume.NewSpecFromVolume(spec), pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = mounter.SetUp(nil)
0000000000000000000000000000000000000000;;		expectedMsg := "invalid HostPath `/no/backsteps/allowed/..`: must not contain '..'"
0000000000000000000000000000000000000000;;		if err.Error() != expectedMsg {
0000000000000000000000000000000000000000;;			t.Fatalf("expected error `%s` but got `%s`", expectedMsg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPlugin(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{}), volumetest.NewFakeVolumeHost("fake", nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/host-path")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		spec := &v1.Volume{
0000000000000000000000000000000000000000;;			Name:         "vol1",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{HostPath: &v1.HostPathVolumeSource{Path: "/vol1"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, err := plug.NewMounter(volume.NewSpecFromVolume(spec), pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := mounter.GetPath()
0000000000000000000000000000000000000000;;		if path != "/vol1" {
0000000000000000000000000000000000000000;;			t.Errorf("Got unexpected path: %s", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := mounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unmounter, err := plug.NewUnmounter("vol1", types.UID("poduid"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unmounter == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Got a nil Unmounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := unmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentClaimReadOnlyFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &v1.HostPathVolumeSource{Path: "foo"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ClaimRef: &v1.ObjectReference{
0000000000000000000000000000000000000000;;					Name: "claimA",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claimA",
0000000000000000000000000000000000000000;;				Namespace: "nsA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				VolumeName: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PersistentVolumeClaimStatus{
0000000000000000000000000000000000000000;;				Phase: v1.ClaimBound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(pv, claim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(volume.VolumeConfig{}), volumetest.NewFakeVolumeHost("/tmp/fake", client, nil))
0000000000000000000000000000000000000000;;		plug, _ := plugMgr.FindPluginByName(hostPathPluginName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readOnly bool is supplied by persistent-claim volume source when its mounter creates other volumes
0000000000000000000000000000000000000000;;		spec := volume.NewSpecFromPersistentVolume(pv, true)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, _ := plug.NewMounter(spec, pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !mounter.GetAttributes().ReadOnly {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true for mounter.IsReadOnly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
