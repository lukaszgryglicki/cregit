0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/host_path/host_path.go[pkg/kubelet/volume/host_path/host_path.go][pkg/volume/host_path/host_path.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package host_path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	// The volumeConfig arg provides the ability to configure volume behavior.  It is implemented as a pointer to allow nils.
0000000000000000000000000000000000000000;;	// The hostPathPlugin is used to store the volumeConfig and give it, when needed, to the func that Recycles.
0000000000000000000000000000000000000000;;	// Tests that exercise recycling should not use this func but instead use ProbeRecyclablePlugins() to override default behavior.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins(volumeConfig volume.VolumeConfig) []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{
0000000000000000000000000000000000000000;;			&hostPathPlugin{
0000000000000000000000000000000000000000;;				host:   nil,
0000000000000000000000000000000000000000;;				config: volumeConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostPathPlugin struct {
0000000000000000000000000000000000000000;;		host   volume.VolumeHost
0000000000000000000000000000000000000000;;		config volume.VolumeConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &hostPathPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &hostPathPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.RecyclableVolumePlugin = &hostPathPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &hostPathPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &hostPathPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		hostPathPluginName = "kubernetes.io/host-path"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return hostPathPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource.Path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.HostPath != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.HostPath != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		hostPathVolumeSource, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &hostPathMounter{
0000000000000000000000000000000000000000;;			hostPath: &hostPath{path: hostPathVolumeSource.Path},
0000000000000000000000000000000000000000;;			readOnly: readOnly,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &hostPathUnmounter{&hostPath{
0000000000000000000000000000000000000000;;			path: "",
0000000000000000000000000000000000000000;;		}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recycle recycles/scrubs clean a HostPath volume.
0000000000000000000000000000000000000000;;	// Recycle blocks until the pod has completed or any error occurs.
0000000000000000000000000000000000000000;;	// HostPath recycling only works in single node clusters and is meant for testing purposes only.
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) Recycle(pvName string, spec *volume.Spec, eventRecorder volume.RecycleEventRecorder) error {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume == nil || spec.PersistentVolume.Spec.HostPath == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("spec.PersistentVolumeSource.HostPath is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := plugin.config.RecyclerPodTemplate
0000000000000000000000000000000000000000;;		timeout := volume.CalculateTimeoutForVolume(plugin.config.RecyclerMinimumTimeout, plugin.config.RecyclerTimeoutIncrement, spec.PersistentVolume)
0000000000000000000000000000000000000000;;		// overrides
0000000000000000000000000000000000000000;;		pod.Spec.ActiveDeadlineSeconds = &timeout
0000000000000000000000000000000000000000;;		pod.Spec.Volumes[0].VolumeSource = v1.VolumeSource{
0000000000000000000000000000000000000000;;			HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;				Path: spec.PersistentVolume.Spec.HostPath.Path,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.RecycleVolumeByWatchingPodUntilCompletion(pvName, pod, plugin.host.GetKubeClient(), eventRecorder)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		return newDeleter(spec, plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		if !plugin.config.ProvisioningEnabled {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Provisioning in volume plugin %q is disabled", plugin.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newProvisioner(options, plugin.host, plugin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *hostPathPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		hostPathVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;					Path: volumeName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(hostPathVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDeleter(spec *volume.Spec, host volume.VolumeHost) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.HostPath == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.HostPath is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path := spec.PersistentVolume.Spec.HostPath.Path
0000000000000000000000000000000000000000;;		return &hostPathDeleter{name: spec.Name(), path: path, host: host}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProvisioner(options volume.VolumeOptions, host volume.VolumeHost, plugin *hostPathPlugin) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &hostPathProvisioner{options: options, host: host, plugin: plugin}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostPath volumes represent a bare host file or directory mount.
0000000000000000000000000000000000000000;;	// The direct at the specified path will be directly exposed to the container.
0000000000000000000000000000000000000000;;	type hostPath struct {
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hp *hostPath) GetPath() string {
0000000000000000000000000000000000000000;;		return hp.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostPathMounter struct {
0000000000000000000000000000000000000000;;		*hostPath
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &hostPathMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *hostPathMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         false,
0000000000000000000000000000000000000000;;			SupportsSELinux: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *hostPathMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp does nothing.
0000000000000000000000000000000000000000;;	func (b *hostPathMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		err := validation.ValidatePathNoBacksteps(b.GetPath())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid HostPath `%s`: %v", b.GetPath(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpAt does not make sense for host paths - probably programmer error.
0000000000000000000000000000000000000000;;	func (b *hostPathMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("SetUpAt() does not make sense for host paths")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *hostPathMounter) GetPath() string {
0000000000000000000000000000000000000000;;		return b.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hostPathUnmounter struct {
0000000000000000000000000000000000000000;;		*hostPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &hostPathUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDown does nothing.
0000000000000000000000000000000000000000;;	func (c *hostPathUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDownAt does not make sense for host paths - probably programmer error.
0000000000000000000000000000000000000000;;	func (c *hostPathUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("TearDownAt() does not make sense for host paths")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hostPathProvisioner implements a Provisioner for the HostPath plugin
0000000000000000000000000000000000000000;;	// This implementation is meant for testing only and only works in a single node cluster.
0000000000000000000000000000000000000000;;	type hostPathProvisioner struct {
0000000000000000000000000000000000000000;;		host    volume.VolumeHost
0000000000000000000000000000000000000000;;		options volume.VolumeOptions
0000000000000000000000000000000000000000;;		plugin  *hostPathPlugin
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create for hostPath simply creates a local /tmp/hostpath_pv/%s directory as a new PersistentVolume.
0000000000000000000000000000000000000000;;	// This Provisioner is meant for development and testing only and WILL NOT WORK in a multi-node cluster.
0000000000000000000000000000000000000000;;	func (r *hostPathProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		fullpath := fmt.Sprintf("/tmp/hostpath_pv/%s", uuid.NewUUID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capacity := r.options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: r.options.PVName,
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeDynamicallyCreatedByKey: "hostpath-dynamic-provisioner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: r.options.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				AccessModes:                   r.options.PVC.Spec.AccessModes,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): capacity,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					HostPath: &v1.HostPathVolumeSource{
0000000000000000000000000000000000000000;;						Path: fullpath,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.options.PVC.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = r.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pv, os.MkdirAll(pv.Spec.HostPath.Path, 0750)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hostPathDeleter deletes a hostPath PV from the cluster.
0000000000000000000000000000000000000000;;	// This deleter only works on a single host cluster and is for testing purposes only.
0000000000000000000000000000000000000000;;	type hostPathDeleter struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *hostPathDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		return r.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete for hostPath removes the local directory so long as it is beneath /tmp/*.
0000000000000000000000000000000000000000;;	// THIS IS FOR TESTING AND LOCAL DEVELOPMENT ONLY!  This message should scare you away from using
0000000000000000000000000000000000000000;;	// this deleter for anything other than development and testing.
0000000000000000000000000000000000000000;;	func (r *hostPathDeleter) Delete() error {
0000000000000000000000000000000000000000;;		regexp := regexp.MustCompile("/tmp/.+")
0000000000000000000000000000000000000000;;		if !regexp.MatchString(r.GetPath()) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("host_path deleter only supports /tmp/.+ but received provided %s", r.GetPath())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.RemoveAll(r.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.HostPathVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.HostPath != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.HostPath, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.HostPath != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.HostPath, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference an HostPath volume type")
0000000000000000000000000000000000000000;;	}
