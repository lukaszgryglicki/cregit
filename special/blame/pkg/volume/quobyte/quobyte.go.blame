0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
da3fa83320d50573e8894e508d4d964e6e1b6442;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package quobyte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		gostrings "strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeVolumePlugins is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&quobytePlugin{nil}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quobytePlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This user is used to authenticate against the
0000000000000000000000000000000000000000;;	// Quobyte API server and holds all information
0000000000000000000000000000000000000000;;	type quobyteAPIConfig struct {
0000000000000000000000000000000000000000;;		quobyteUser      string
0000000000000000000000000000000000000000;;		quobytePassword  string
0000000000000000000000000000000000000000;;		quobyteAPIServer string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &quobytePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &quobytePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &quobytePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &quobytePlugin{}
0000000000000000000000000000000000000000;;	var _ volume.Provisioner = &quobyteVolumeProvisioner{}
0000000000000000000000000000000000000000;;	var _ volume.Deleter = &quobyteVolumeDeleter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		quobytePluginName = "kubernetes.io/quobyte"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return quobytePluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%v:%v",
0000000000000000000000000000000000000000;;			volumeSource.Registry,
0000000000000000000000000000000000000000;;			volumeSource.Volume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		if (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Quobyte == nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.Quobyte == nil) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Quobyte is already mounted we don't need to check if the binary is installed
0000000000000000000000000000000000000000;;		if mounter, err := plugin.newMounterInternal(spec, nil, plugin.host.GetMounter()); err == nil {
0000000000000000000000000000000000000000;;			qm, _ := mounter.(*quobyteMounter)
0000000000000000000000000000000000000000;;			pluginDir := plugin.host.GetPluginDir(strings.EscapeQualifiedNameForDisk(quobytePluginName))
0000000000000000000000000000000000000000;;			if mounted, err := qm.pluginDirIsMounted(pluginDir); mounted && err == nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("quobyte: can support")
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("quobyte: Error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if out, err := exec.New().Command("ls", "/sbin/mount.quobyte").CombinedOutput(); err == nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("quobyte: can support: %s", string(out))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;			v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;			v1.ReadWriteMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.QuobyteVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.Quobyte != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.Quobyte, spec.Volume.Quobyte.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.Quobyte != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.Quobyte, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a Quobyte volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		quobyteVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				Quobyte: &v1.QuobyteVolumeSource{
0000000000000000000000000000000000000000;;					Volume: volumeName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(quobyteVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) newMounterInternal(spec *volume.Spec, pod *v1.Pod, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		source, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &quobyteMounter{
0000000000000000000000000000000000000000;;			quobyte: &quobyte{
0000000000000000000000000000000000000000;;				volName: spec.Name(),
0000000000000000000000000000000000000000;;				user:    source.User,
0000000000000000000000000000000000000000;;				group:   source.Group,
0000000000000000000000000000000000000000;;				mounter: mounter,
0000000000000000000000000000000000000000;;				pod:     pod,
0000000000000000000000000000000000000000;;				volume:  source.Volume,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			registry:     source.Registry,
0000000000000000000000000000000000000000;;			readOnly:     readOnly,
0000000000000000000000000000000000000000;;			mountOptions: volume.MountOptionFromSpec(spec),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) newUnmounterInternal(volName string, podUID types.UID, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &quobyteUnmounter{
0000000000000000000000000000000000000000;;			&quobyte{
0000000000000000000000000000000000000000;;				volName: volName,
0000000000000000000000000000000000000000;;				mounter: mounter,
0000000000000000000000000000000000000000;;				pod:     &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: podUID}},
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Quobyte volumes represent a bare host directory mount of an quobyte export.
0000000000000000000000000000000000000000;;	type quobyte struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		pod     *v1.Pod
0000000000000000000000000000000000000000;;		user    string
0000000000000000000000000000000000000000;;		group   string
0000000000000000000000000000000000000000;;		volume  string
0000000000000000000000000000000000000000;;		tenant  string
0000000000000000000000000000000000000000;;		config  string
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		plugin  *quobytePlugin
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quobyteMounter struct {
0000000000000000000000000000000000000000;;		*quobyte
0000000000000000000000000000000000000000;;		registry     string
0000000000000000000000000000000000000000;;		readOnly     bool
0000000000000000000000000000000000000000;;		mountOptions []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &quobyteMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mounter *quobyteMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        mounter.readOnly,
0000000000000000000000000000000000000000;;			Managed:         false,
0000000000000000000000000000000000000000;;			SupportsSELinux: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (mounter *quobyteMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp attaches the disk and bind mounts to the volume path.
0000000000000000000000000000000000000000;;	func (mounter *quobyteMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		pluginDir := mounter.plugin.host.GetPluginDir(strings.EscapeQualifiedNameForDisk(quobytePluginName))
0000000000000000000000000000000000000000;;		return mounter.SetUpAt(pluginDir, fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mounter *quobyteMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		// Check if Quobyte is already mounted on the host in the Plugin Dir
0000000000000000000000000000000000000000;;		// if so we can use this mountpoint instead of creating a new one
0000000000000000000000000000000000000000;;		// IsLikelyNotMountPoint wouldn't check the mount type
0000000000000000000000000000000000000000;;		if mounted, err := mounter.pluginDirIsMounted(dir); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if mounted {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os.MkdirAll(dir, 0750)
0000000000000000000000000000000000000000;;		var options []string
0000000000000000000000000000000000000000;;		if mounter.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//if a trailing slash is missing we add it here
0000000000000000000000000000000000000000;;		mountOptions := volume.JoinMountOptions(mounter.mountOptions, options)
0000000000000000000000000000000000000000;;		if err := mounter.mounter.Mount(mounter.correctTraillingSlash(mounter.registry), dir, "quobyte", mountOptions); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("quobyte: mount failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("quobyte: mount set up: %s", dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPath returns the path to the user specific mount of a Quobyte volume
0000000000000000000000000000000000000000;;	// Returns a path in the format ../user#group@volume
0000000000000000000000000000000000000000;;	func (quobyteVolume *quobyte) GetPath() string {
0000000000000000000000000000000000000000;;		user := quobyteVolume.user
0000000000000000000000000000000000000000;;		if len(user) == 0 {
0000000000000000000000000000000000000000;;			user = "root"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		group := quobyteVolume.group
0000000000000000000000000000000000000000;;		if len(group) == 0 {
0000000000000000000000000000000000000000;;			group = "nfsnobody"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Quobyte has only one mount in the PluginDir where all Volumes are mounted
0000000000000000000000000000000000000000;;		// The Quobyte client does a fixed-user mapping
0000000000000000000000000000000000000000;;		pluginDir := quobyteVolume.plugin.host.GetPluginDir(strings.EscapeQualifiedNameForDisk(quobytePluginName))
0000000000000000000000000000000000000000;;		return path.Join(pluginDir, fmt.Sprintf("%s#%s@%s", user, group, quobyteVolume.volume))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quobyteUnmounter struct {
0000000000000000000000000000000000000000;;		*quobyte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &quobyteUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (unmounter *quobyteUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return unmounter.TearDownAt(unmounter.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We don't need to unmount on the host because only one mount exists
0000000000000000000000000000000000000000;;	func (unmounter *quobyteUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quobyteVolumeDeleter struct {
0000000000000000000000000000000000000000;;		*quobyteMounter
0000000000000000000000000000000000000000;;		pv *v1.PersistentVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Quobyte == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.Spec.Quobyte is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plugin.newDeleterInternal(spec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) newDeleterInternal(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		source, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &quobyteVolumeDeleter{
0000000000000000000000000000000000000000;;			quobyteMounter: &quobyteMounter{
0000000000000000000000000000000000000000;;				quobyte: &quobyte{
0000000000000000000000000000000000000000;;					volName: spec.Name(),
0000000000000000000000000000000000000000;;					user:    source.User,
0000000000000000000000000000000000000000;;					group:   source.Group,
0000000000000000000000000000000000000000;;					volume:  source.Volume,
0000000000000000000000000000000000000000;;					plugin:  plugin,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				registry: source.Registry,
0000000000000000000000000000000000000000;;				readOnly: readOnly,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			pv: spec.PersistentVolume,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return plugin.newProvisionerInternal(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *quobytePlugin) newProvisionerInternal(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &quobyteVolumeProvisioner{
0000000000000000000000000000000000000000;;			quobyteMounter: &quobyteMounter{
0000000000000000000000000000000000000000;;				quobyte: &quobyte{
0000000000000000000000000000000000000000;;					plugin: plugin,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options: options,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quobyteVolumeProvisioner struct {
0000000000000000000000000000000000000000;;		*quobyteMounter
0000000000000000000000000000000000000000;;		options volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (provisioner *quobyteVolumeProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if !volume.AccessModesContainedInAll(provisioner.plugin.GetAccessModes(), provisioner.options.PVC.Spec.AccessModes) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported", provisioner.options.PVC.Spec.AccessModes, provisioner.plugin.GetAccessModes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if provisioner.options.PVC.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("claim Selector is not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		provisioner.config = "BASE"
0000000000000000000000000000000000000000;;		provisioner.tenant = "DEFAULT"
0000000000000000000000000000000000000000;;		createQuota := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg, err := parseAPIConfig(provisioner.plugin, provisioner.options.Parameters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range provisioner.options.Parameters {
0000000000000000000000000000000000000000;;			switch gostrings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "registry":
0000000000000000000000000000000000000000;;				provisioner.registry = v
0000000000000000000000000000000000000000;;			case "user":
0000000000000000000000000000000000000000;;				provisioner.user = v
0000000000000000000000000000000000000000;;			case "group":
0000000000000000000000000000000000000000;;				provisioner.group = v
0000000000000000000000000000000000000000;;			case "quobytetenant":
0000000000000000000000000000000000000000;;				provisioner.tenant = v
0000000000000000000000000000000000000000;;			case "quobyteconfig":
0000000000000000000000000000000000000000;;				provisioner.config = v
0000000000000000000000000000000000000000;;			case "createquota":
0000000000000000000000000000000000000000;;				createQuota = gostrings.ToLower(v) == "true"
0000000000000000000000000000000000000000;;			case "adminsecretname",
0000000000000000000000000000000000000000;;				"adminsecretnamespace",
0000000000000000000000000000000000000000;;				"quobyteapiserver":
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid option %q for volume plugin %s", k, provisioner.plugin.GetPluginName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !validateRegistry(provisioner.registry) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Quoybte registry missing or malformed: must be a host:port pair or multiple pairs separated by commas")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create random image name
0000000000000000000000000000000000000000;;		provisioner.volume = fmt.Sprintf("kubernetes-dynamic-pvc-%s", uuid.NewUUID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manager := &quobyteVolumeManager{
0000000000000000000000000000000000000000;;			config: cfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, sizeGB, err := manager.createVolume(provisioner, createQuota)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv := new(v1.PersistentVolume)
0000000000000000000000000000000000000000;;		metav1.SetMetaDataAnnotation(&pv.ObjectMeta, volumehelper.VolumeDynamicallyCreatedByKey, "quobyte-dynamic-provisioner")
0000000000000000000000000000000000000000;;		pv.Spec.PersistentVolumeSource.Quobyte = vol
0000000000000000000000000000000000000000;;		pv.Spec.PersistentVolumeReclaimPolicy = provisioner.options.PersistentVolumeReclaimPolicy
0000000000000000000000000000000000000000;;		pv.Spec.AccessModes = provisioner.options.PVC.Spec.AccessModes
0000000000000000000000000000000000000000;;		if len(pv.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = provisioner.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv.Spec.Capacity = v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dGi", sizeGB)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (deleter *quobyteVolumeDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		return deleter.quobyte.GetPath()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (deleter *quobyteVolumeDeleter) Delete() error {
0000000000000000000000000000000000000000;;		class, err := util.GetClassForVolume(deleter.plugin.host.GetKubeClient(), deleter.pv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg, err := parseAPIConfig(deleter.plugin, class.Parameters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		manager := &quobyteVolumeManager{
0000000000000000000000000000000000000000;;			config: cfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return manager.deleteVolume(deleter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse API configuration (url, username and password) out of class.Parameters.
0000000000000000000000000000000000000000;;	func parseAPIConfig(plugin *quobytePlugin, params map[string]string) (*quobyteAPIConfig, error) {
0000000000000000000000000000000000000000;;		var apiServer, secretName string
0000000000000000000000000000000000000000;;		secretNamespace := "default"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleteKeys := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range params {
0000000000000000000000000000000000000000;;			switch gostrings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "adminsecretname":
0000000000000000000000000000000000000000;;				secretName = v
0000000000000000000000000000000000000000;;				deleteKeys = append(deleteKeys, k)
0000000000000000000000000000000000000000;;			case "adminsecretnamespace":
0000000000000000000000000000000000000000;;				secretNamespace = v
0000000000000000000000000000000000000000;;				deleteKeys = append(deleteKeys, k)
0000000000000000000000000000000000000000;;			case "quobyteapiserver":
0000000000000000000000000000000000000000;;				apiServer = v
0000000000000000000000000000000000000000;;				deleteKeys = append(deleteKeys, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(apiServer) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Quoybte API server missing or malformed: must be a http(s)://host:port pair or multiple pairs separated by commas")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretMap, err := util.GetSecretForPV(secretNamespace, secretName, quobytePluginName, plugin.host.GetKubeClient())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &quobyteAPIConfig{
0000000000000000000000000000000000000000;;			quobyteAPIServer: apiServer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if cfg.quobyteUser, ok = secretMap["user"]; !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Missing \"user\" in secret %s/%s", secretNamespace, secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.quobytePassword, ok = secretMap["password"]; !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Missing \"password\" in secret %s/%s", secretNamespace, secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cfg, nil
0000000000000000000000000000000000000000;;	}
