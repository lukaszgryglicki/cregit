0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7c414f8cc84feccc71083d094122d69a5d28cad1;pkg/kubelet/volume/secret/secret.go[pkg/kubelet/volume/secret/secret.go][pkg/volume/secret/secret.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package secret
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		ioutil "k8s.io/kubernetes/pkg/util/io"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumeutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProbeVolumePlugin is the entry point for plugin detection in a package.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&secretPlugin{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		secretPluginName = "kubernetes.io/secret"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// secretPlugin implements the VolumePlugin interface.
0000000000000000000000000000000000000000;;	type secretPlugin struct {
0000000000000000000000000000000000000000;;		host      volume.VolumeHost
0000000000000000000000000000000000000000;;		getSecret func(namespace, name string) (*v1.Secret, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &secretPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrappedVolumeSpec() volume.Spec {
0000000000000000000000000000000000000000;;		return volume.Spec{
0000000000000000000000000000000000000000;;			Volume: &v1.Volume{VolumeSource: v1.VolumeSource{EmptyDir: &v1.EmptyDirVolumeSource{Medium: v1.StorageMediumMemory}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPath(uid types.UID, volName string, host volume.VolumeHost) string {
0000000000000000000000000000000000000000;;		return host.GetPodVolumeDir(uid, strings.EscapeQualifiedNameForDisk(secretPluginName), volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		plugin.getSecret = host.GetSecretFunc()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return secretPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _ := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if volumeSource == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Spec does not reference a Secret volume type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource.SecretName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return spec.Volume != nil && spec.Volume.Secret != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, opts volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		return &secretVolumeMounter{
0000000000000000000000000000000000000000;;			secretVolume: &secretVolume{
0000000000000000000000000000000000000000;;				spec.Name(),
0000000000000000000000000000000000000000;;				pod.UID,
0000000000000000000000000000000000000000;;				plugin,
0000000000000000000000000000000000000000;;				plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;				plugin.host.GetWriter(),
0000000000000000000000000000000000000000;;				volume.NewCachedMetrics(volume.NewMetricsDu(getPath(pod.UID, spec.Name(), plugin.host))),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			source:    *spec.Volume.Secret,
0000000000000000000000000000000000000000;;			pod:       *pod,
0000000000000000000000000000000000000000;;			opts:      &opts,
0000000000000000000000000000000000000000;;			getSecret: plugin.getSecret,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &secretVolumeUnmounter{
0000000000000000000000000000000000000000;;			&secretVolume{
0000000000000000000000000000000000000000;;				volName,
0000000000000000000000000000000000000000;;				podUID,
0000000000000000000000000000000000000000;;				plugin,
0000000000000000000000000000000000000000;;				plugin.host.GetMounter(),
0000000000000000000000000000000000000000;;				plugin.host.GetWriter(),
0000000000000000000000000000000000000000;;				volume.NewCachedMetrics(volume.NewMetricsDu(getPath(podUID, volName, plugin.host))),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *secretPlugin) ConstructVolumeSpec(volName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		secretVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				Secret: &v1.SecretVolumeSource{
0000000000000000000000000000000000000000;;					SecretName: volName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(secretVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type secretVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		plugin  *secretPlugin
0000000000000000000000000000000000000000;;		mounter mount.Interface
0000000000000000000000000000000000000000;;		writer  ioutil.Writer
0000000000000000000000000000000000000000;;		volume.MetricsProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Volume = &secretVolume{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv *secretVolume) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(sv.podUID, sv.volName, sv.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// secretVolumeMounter handles retrieving secrets from the API server
0000000000000000000000000000000000000000;;	// and placing them into the volume on the host.
0000000000000000000000000000000000000000;;	type secretVolumeMounter struct {
0000000000000000000000000000000000000000;;		*secretVolume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		source    v1.SecretVolumeSource
0000000000000000000000000000000000000000;;		pod       v1.Pod
0000000000000000000000000000000000000000;;		opts      *volume.VolumeOptions
0000000000000000000000000000000000000000;;		getSecret func(namespace, name string) (*v1.Secret, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &secretVolumeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv *secretVolume) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        true,
0000000000000000000000000000000000000000;;			Managed:         true,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *secretVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *secretVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *secretVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Setting up volume %v for pod %v at %v", b.volName, b.pod.UID, dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wrap EmptyDir, let it do the setup.
0000000000000000000000000000000000000000;;		wrapped, err := b.plugin.host.NewWrapperMounter(b.volName, wrappedVolumeSpec(), &b.pod, *b.opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := wrapped.SetUpAt(dir, fsGroup); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optional := b.source.Optional != nil && *b.source.Optional
0000000000000000000000000000000000000000;;		secret, err := b.getSecret(b.pod.Namespace, b.source.SecretName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !(errors.IsNotFound(err) && optional) {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get secret %v/%v: %v", b.pod.Namespace, b.source.SecretName, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secret = &v1.Secret{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Namespace: b.pod.Namespace,
0000000000000000000000000000000000000000;;					Name:      b.source.SecretName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		totalBytes := totalSecretBytes(secret)
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Received secret %v/%v containing (%v) pieces of data, %v total bytes",
0000000000000000000000000000000000000000;;			b.pod.Namespace,
0000000000000000000000000000000000000000;;			b.source.SecretName,
0000000000000000000000000000000000000000;;			len(secret.Data),
0000000000000000000000000000000000000000;;			totalBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload, err := MakePayload(b.source.Items, secret, b.source.DefaultMode, optional)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writerContext := fmt.Sprintf("pod %v/%v volume %v", b.pod.Namespace, b.pod.Name, b.volName)
0000000000000000000000000000000000000000;;		writer, err := volumeutil.NewAtomicWriter(dir, writerContext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error creating atomic writer: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = writer.Write(payload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error writing payload to dir: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error applying volume ownership settings for group: %v", fsGroup)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: this function is exported so that it can be called from the projection volume driver
0000000000000000000000000000000000000000;;	func MakePayload(mappings []v1.KeyToPath, secret *v1.Secret, defaultMode *int32, optional bool) (map[string]volumeutil.FileProjection, error) {
0000000000000000000000000000000000000000;;		if defaultMode == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No defaultMode used, not even the default value for it")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload := make(map[string]volumeutil.FileProjection, len(secret.Data))
0000000000000000000000000000000000000000;;		var fileProjection volumeutil.FileProjection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(mappings) == 0 {
0000000000000000000000000000000000000000;;			for name, data := range secret.Data {
0000000000000000000000000000000000000000;;				fileProjection.Data = []byte(data)
0000000000000000000000000000000000000000;;				fileProjection.Mode = *defaultMode
0000000000000000000000000000000000000000;;				payload[name] = fileProjection
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, ktp := range mappings {
0000000000000000000000000000000000000000;;				content, ok := secret.Data[ktp.Key]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					if optional {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					err_msg := "references non-existent secret key"
0000000000000000000000000000000000000000;;					glog.Errorf(err_msg)
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf(err_msg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fileProjection.Data = []byte(content)
0000000000000000000000000000000000000000;;				if ktp.Mode != nil {
0000000000000000000000000000000000000000;;					fileProjection.Mode = *ktp.Mode
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fileProjection.Mode = *defaultMode
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				payload[ktp.Path] = fileProjection
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return payload, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func totalSecretBytes(secret *v1.Secret) int {
0000000000000000000000000000000000000000;;		totalSize := 0
0000000000000000000000000000000000000000;;		for _, bytes := range secret.Data {
0000000000000000000000000000000000000000;;			totalSize += len(bytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return totalSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// secretVolumeUnmounter handles cleaning up secret volumes.
0000000000000000000000000000000000000000;;	type secretVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*secretVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &secretVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *secretVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *secretVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return volume.UnmountViaEmptyDir(dir, c.plugin.host, c.volName, wrappedVolumeSpec(), c.podUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.SecretVolumeSource, bool) {
0000000000000000000000000000000000000000;;		var readOnly bool
0000000000000000000000000000000000000000;;		var volumeSource *v1.SecretVolumeSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.Secret != nil {
0000000000000000000000000000000000000000;;			volumeSource = spec.Volume.Secret
0000000000000000000000000000000000000000;;			readOnly = spec.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource, readOnly
0000000000000000000000000000000000000000;;	}
