0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
29f50278a649609e9f0ab6ad6b87814a1ddcf9d5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flocker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/env"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flockerapi "github.com/clusterhq/flocker-go"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&flockerPlugin{nil}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flockerPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flockerVolume struct {
0000000000000000000000000000000000000000;;		volName string
0000000000000000000000000000000000000000;;		podUID  types.UID
0000000000000000000000000000000000000000;;		// dataset metadata name deprecated
0000000000000000000000000000000000000000;;		datasetName string
0000000000000000000000000000000000000000;;		// dataset uuid
0000000000000000000000000000000000000000;;		datasetUUID string
0000000000000000000000000000000000000000;;		//pod           *v1.Pod
0000000000000000000000000000000000000000;;		flockerClient flockerapi.Clientable
0000000000000000000000000000000000000000;;		manager       volumeManager
0000000000000000000000000000000000000000;;		plugin        *flockerPlugin
0000000000000000000000000000000000000000;;		mounter       mount.Interface
0000000000000000000000000000000000000000;;		volume.MetricsProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &flockerPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &flockerPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &flockerPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &flockerPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		flockerPluginName = "kubernetes.io/flocker"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultHost           = "localhost"
0000000000000000000000000000000000000000;;		defaultPort           = 4523
0000000000000000000000000000000000000000;;		defaultCACertFile     = "/etc/flocker/cluster.crt"
0000000000000000000000000000000000000000;;		defaultClientKeyFile  = "/etc/flocker/apiuser.key"
0000000000000000000000000000000000000000;;		defaultClientCertFile = "/etc/flocker/apiuser.crt"
0000000000000000000000000000000000000000;;		defaultMountPath      = "/flocker"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeoutWaitingForVolume = 2 * time.Minute
0000000000000000000000000000000000000000;;		tickerWaitingForVolume  = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPath(uid types.UID, volName string, host volume.VolumeHost) string {
0000000000000000000000000000000000000000;;		return host.GetPodVolumeDir(uid, strings.EscapeQualifiedNameForDisk(flockerPluginName), volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeGlobalFlockerPath(datasetUUID string) string {
0000000000000000000000000000000000000000;;		return path.Join(defaultMountPath, datasetUUID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		p.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return flockerPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeSource.DatasetName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Flocker != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.Flocker != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) getFlockerVolumeSource(spec *volume.Spec) (*v1.FlockerVolumeSource, bool) {
0000000000000000000000000000000000000000;;		// AFAIK this will always be r/w, but perhaps for the future it will be needed
0000000000000000000000000000000000000000;;		readOnly := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.Flocker != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.Flocker, readOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return spec.PersistentVolume.Spec.Flocker, readOnly
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, &FlockerUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, manager volumeManager, mounter mount.Interface) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		volumeSource, readOnly, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		datasetName := volumeSource.DatasetName
0000000000000000000000000000000000000000;;		datasetUUID := volumeSource.DatasetUUID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &flockerVolumeMounter{
0000000000000000000000000000000000000000;;			flockerVolume: &flockerVolume{
0000000000000000000000000000000000000000;;				podUID:          podUID,
0000000000000000000000000000000000000000;;				volName:         spec.Name(),
0000000000000000000000000000000000000000;;				datasetName:     datasetName,
0000000000000000000000000000000000000000;;				datasetUUID:     datasetUUID,
0000000000000000000000000000000000000000;;				mounter:         mounter,
0000000000000000000000000000000000000000;;				manager:         manager,
0000000000000000000000000000000000000000;;				plugin:          plugin,
0000000000000000000000000000000000000000;;				MetricsProvider: volume.NewMetricsStatFS(getPath(podUID, spec.Name(), plugin.host)),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			readOnly: readOnly}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return p.newUnmounterInternal(volName, podUID, &FlockerUtil{}, p.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) newUnmounterInternal(volName string, podUID types.UID, manager volumeManager, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &flockerVolumeUnmounter{&flockerVolume{
0000000000000000000000000000000000000000;;			podUID:          podUID,
0000000000000000000000000000000000000000;;			volName:         volName,
0000000000000000000000000000000000000000;;			manager:         manager,
0000000000000000000000000000000000000000;;			mounter:         mounter,
0000000000000000000000000000000000000000;;			plugin:          p,
0000000000000000000000000000000000000000;;			MetricsProvider: volume.NewMetricsStatFS(getPath(podUID, volName, p.host)),
0000000000000000000000000000000000000000;;		}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		flockerVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				Flocker: &v1.FlockerVolumeSource{
0000000000000000000000000000000000000000;;					DatasetName: volumeName,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(flockerVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *flockerVolume) GetDatasetUUID() (datasetUUID string, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return UUID if set
0000000000000000000000000000000000000000;;		if len(b.datasetUUID) > 0 {
0000000000000000000000000000000000000000;;			return b.datasetUUID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b.flockerClient == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Flocker client is not initialized")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lookup in flocker API otherwise
0000000000000000000000000000000000000000;;		return b.flockerClient.GetDatasetID(b.datasetName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flockerVolumeMounter struct {
0000000000000000000000000000000000000000;;		*flockerVolume
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *flockerVolumeMounter) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.readOnly,
0000000000000000000000000000000000000000;;			Managed:         false,
0000000000000000000000000000000000000000;;			SupportsSELinux: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *flockerVolumeMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *flockerVolumeMounter) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(b.podUID, b.volName, b.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUp bind mounts the disk global mount to the volume path.
0000000000000000000000000000000000000000;;	func (b *flockerVolumeMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newFlockerClient uses environment variables and pod attributes to return a
0000000000000000000000000000000000000000;;	// flocker client capable of talking with the Flocker control service.
0000000000000000000000000000000000000000;;	func (p *flockerPlugin) newFlockerClient(hostIP string) (*flockerapi.Client, error) {
0000000000000000000000000000000000000000;;		host := env.GetEnvAsStringOrFallback("FLOCKER_CONTROL_SERVICE_HOST", defaultHost)
0000000000000000000000000000000000000000;;		port, err := env.GetEnvAsIntOrFallback("FLOCKER_CONTROL_SERVICE_PORT", defaultPort)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		caCertPath := env.GetEnvAsStringOrFallback("FLOCKER_CONTROL_SERVICE_CA_FILE", defaultCACertFile)
0000000000000000000000000000000000000000;;		keyPath := env.GetEnvAsStringOrFallback("FLOCKER_CONTROL_SERVICE_CLIENT_KEY_FILE", defaultClientKeyFile)
0000000000000000000000000000000000000000;;		certPath := env.GetEnvAsStringOrFallback("FLOCKER_CONTROL_SERVICE_CLIENT_CERT_FILE", defaultClientCertFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := flockerapi.NewClient(host, port, hostIP, caCertPath, keyPath, certPath)
0000000000000000000000000000000000000000;;		return c, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *flockerVolumeMounter) newFlockerClient() (*flockerapi.Client, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostIP, err := b.plugin.host.GetHostIP()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b.plugin.newFlockerClient(hostIP.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	SetUpAt will setup a Flocker volume following this flow of calls to the Flocker
0000000000000000000000000000000000000000;;	control service:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. Get the dataset id for the given volume name/dir
0000000000000000000000000000000000000000;;	2. It should already be there, if it's not the user needs to manually create it
0000000000000000000000000000000000000000;;	3. Check the current Primary UUID
0000000000000000000000000000000000000000;;	4. If it doesn't match with the Primary UUID that we got on 2, then we will
0000000000000000000000000000000000000000;;	   need to update the Primary UUID for this volume.
0000000000000000000000000000000000000000;;	5. Wait until the Primary UUID was updated or timeout.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (b *flockerVolumeMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if b.flockerClient == nil {
0000000000000000000000000000000000000000;;			b.flockerClient, err = b.newFlockerClient()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		datasetUUID, err := b.GetDatasetUUID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("The datasetUUID for volume with datasetName='%s' can not be found using flocker: %s", b.datasetName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		datasetState, err := b.flockerClient.GetDatasetState(datasetUUID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("The datasetState for volume with datasetUUID='%s' could not determinted uusing flocker: %s", datasetUUID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		primaryUUID, err := b.flockerClient.GetPrimaryUUID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if datasetState.Primary != primaryUUID {
0000000000000000000000000000000000000000;;			if err := b.updateDatasetPrimary(datasetUUID, primaryUUID); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := b.flockerClient.GetDatasetState(datasetUUID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("The volume with datasetUUID='%s' migrated unsuccessfully.", datasetUUID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: handle failed mounts here.
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("flockerVolume set up: %s %v %v, datasetUUID %v readOnly %v", dir, !notMnt, err, datasetUUID, b.readOnly)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			glog.Errorf("cannot validate mount point: %s %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("mkdir failed on disk %s (%v)", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a bind mount to the full path to allow duplicate mounts of the same PD.
0000000000000000000000000000000000000000;;		options := []string{"bind"}
0000000000000000000000000000000000000000;;		if b.readOnly {
0000000000000000000000000000000000000000;;			options = append(options, "ro")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		globalFlockerPath := makeGlobalFlockerPath(datasetUUID)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("attempting to mount %s", dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = b.mounter.Mount(globalFlockerPath, dir, "", options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;			if mntErr != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("isLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !notMnt {
0000000000000000000000000000000000000000;;				if mntErr = b.mounter.Unmount(dir); mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to unmount: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notMnt, mntErr := b.mounter.IsLikelyNotMountPoint(dir)
0000000000000000000000000000000000000000;;				if mntErr != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("isLikelyNotMountPoint check failed: %v", mntErr)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !notMnt {
0000000000000000000000000000000000000000;;					// This is very odd, we don't expect it.  We'll try again next sync loop.
0000000000000000000000000000000000000000;;					glog.Errorf("%s is still mounted, despite call to unmount().  Will try again next sync loop.", dir)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Remove(dir)
0000000000000000000000000000000000000000;;			glog.Errorf("mount of disk %s failed: %v", dir, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !b.readOnly {
0000000000000000000000000000000000000000;;			volume.SetVolumeOwnership(b, fsGroup)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("successfully mounted %s", dir)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateDatasetPrimary will update the primary in Flocker and wait for it to
0000000000000000000000000000000000000000;;	// be ready. If it never gets to ready state it will timeout and error.
0000000000000000000000000000000000000000;;	func (b *flockerVolumeMounter) updateDatasetPrimary(datasetUUID string, primaryUUID string) error {
0000000000000000000000000000000000000000;;		// We need to update the primary and wait for it to be ready
0000000000000000000000000000000000000000;;		_, err := b.flockerClient.UpdatePrimaryForDataset(primaryUUID, datasetUUID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeoutChan := time.NewTimer(timeoutWaitingForVolume)
0000000000000000000000000000000000000000;;		defer timeoutChan.Stop()
0000000000000000000000000000000000000000;;		tickChan := time.NewTicker(tickerWaitingForVolume)
0000000000000000000000000000000000000000;;		defer tickChan.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if s, err := b.flockerClient.GetDatasetState(datasetUUID); err == nil && s.Primary == primaryUUID {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChan.C:
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"Timed out waiting for the datasetUUID: '%s' to be moved to the primary: '%s'\n%v",
0000000000000000000000000000000000000000;;					datasetUUID, primaryUUID, err,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			case <-tickChan.C:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(spec *volume.Spec) (*v1.FlockerVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.Flocker != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.Flocker, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.Flocker != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.Flocker, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a Flocker volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flockerVolumeUnmounter struct {
0000000000000000000000000000000000000000;;		*flockerVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &flockerVolumeUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *flockerVolumeUnmounter) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(c.podUID, c.volName, c.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the PD
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *flockerVolumeUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TearDownAt unmounts the bind mount
0000000000000000000000000000000000000000;;	func (c *flockerVolumeUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		return util.UnmountPath(dir, c.mounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		return plugin.newDeleterInternal(spec, &FlockerUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) newDeleterInternal(spec *volume.Spec, manager volumeManager) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.Flocker == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.Flocker is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &flockerVolumeDeleter{
0000000000000000000000000000000000000000;;			flockerVolume: &flockerVolume{
0000000000000000000000000000000000000000;;				volName:     spec.Name(),
0000000000000000000000000000000000000000;;				datasetName: spec.PersistentVolume.Spec.Flocker.DatasetName,
0000000000000000000000000000000000000000;;				datasetUUID: spec.PersistentVolume.Spec.Flocker.DatasetUUID,
0000000000000000000000000000000000000000;;				manager:     manager,
0000000000000000000000000000000000000000;;			}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return plugin.newProvisionerInternal(options, &FlockerUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *flockerPlugin) newProvisionerInternal(options volume.VolumeOptions, manager volumeManager) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &flockerVolumeProvisioner{
0000000000000000000000000000000000000000;;			flockerVolume: &flockerVolume{
0000000000000000000000000000000000000000;;				manager: manager,
0000000000000000000000000000000000000000;;				plugin:  plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options: options,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
