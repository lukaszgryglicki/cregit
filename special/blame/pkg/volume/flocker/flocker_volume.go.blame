0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
29f50278a649609e9f0ab6ad6b87814a1ddcf9d5;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package flocker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type volumeManager interface {
0000000000000000000000000000000000000000;;		// Creates a volume
0000000000000000000000000000000000000000;;		CreateVolume(provisioner *flockerVolumeProvisioner) (datasetUUID string, volumeSizeGB int, labels map[string]string, err error)
0000000000000000000000000000000000000000;;		// Deletes a volume
0000000000000000000000000000000000000000;;		DeleteVolume(deleter *flockerVolumeDeleter) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flockerVolumeDeleter struct {
0000000000000000000000000000000000000000;;		*flockerVolume
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Deleter = &flockerVolumeDeleter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *flockerVolumeDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		return getPath(b.podUID, b.volName, b.plugin.host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *flockerVolumeDeleter) Delete() error {
0000000000000000000000000000000000000000;;		return d.manager.DeleteVolume(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flockerVolumeProvisioner struct {
0000000000000000000000000000000000000000;;		*flockerVolume
0000000000000000000000000000000000000000;;		options volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Provisioner = &flockerVolumeProvisioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *flockerVolumeProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if !volume.AccessModesContainedInAll(c.plugin.GetAccessModes(), c.options.PVC.Spec.AccessModes) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported", c.options.PVC.Spec.AccessModes, c.plugin.GetAccessModes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.options.Parameters) > 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Provisioning failed: Specified at least one unsupported parameter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.options.PVC.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Provisioning failed: Specified unsupported selector")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		datasetUUID, sizeGB, labels, err := c.manager.CreateVolume(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:   c.options.PVName,
0000000000000000000000000000000000000000;;				Labels: map[string]string{},
0000000000000000000000000000000000000000;;				Annotations: map[string]string{
0000000000000000000000000000000000000000;;					volumehelper.VolumeDynamicallyCreatedByKey: "flocker-dynamic-provisioner",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeReclaimPolicy: c.options.PersistentVolumeReclaimPolicy,
0000000000000000000000000000000000000000;;				AccessModes:                   c.options.PVC.Spec.AccessModes,
0000000000000000000000000000000000000000;;				Capacity: v1.ResourceList{
0000000000000000000000000000000000000000;;					v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dGi", sizeGB)),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					Flocker: &v1.FlockerVolumeSource{
0000000000000000000000000000000000000000;;						DatasetUUID: datasetUUID,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.options.PVC.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = c.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(labels) != 0 {
0000000000000000000000000000000000000000;;			if pv.Labels == nil {
0000000000000000000000000000000000000000;;				pv.Labels = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range labels {
0000000000000000000000000000000000000000;;				pv.Labels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
