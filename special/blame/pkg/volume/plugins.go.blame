0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
28d1b811f32f22d79e3d1a03efc572f4fe6fc926;pkg/kubelet/volume/plugins.go[pkg/kubelet/volume/plugins.go][pkg/volume/plugins.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/cloudprovider"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/io"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeOptions contains option information about a volume.
0000000000000000000000000000000000000000;;	type VolumeOptions struct {
0000000000000000000000000000000000000000;;		// The attributes below are required by volume.Provisioner
0000000000000000000000000000000000000000;;		// TODO: refactor all of this out of volumes when an admin can configure
0000000000000000000000000000000000000000;;		// many kinds of provisioners.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reclamation policy for a persistent volume
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimPolicy v1.PersistentVolumeReclaimPolicy
0000000000000000000000000000000000000000;;		// Suggested PV.Name of the PersistentVolume to provision.
0000000000000000000000000000000000000000;;		// This is a generated name guaranteed to be unique in Kubernetes cluster.
0000000000000000000000000000000000000000;;		// If you choose not to use it as volume name, ensure uniqueness by either
0000000000000000000000000000000000000000;;		// combining it with your value or create unique values of your own.
0000000000000000000000000000000000000000;;		PVName string
0000000000000000000000000000000000000000;;		// PVC is reference to the claim that lead to provisioning of a new PV.
0000000000000000000000000000000000000000;;		// Provisioners *must* create a PV that would be matched by this PVC,
0000000000000000000000000000000000000000;;		// i.e. with required capacity, accessMode, labels matching PVC.Selector and
0000000000000000000000000000000000000000;;		// so on.
0000000000000000000000000000000000000000;;		PVC *v1.PersistentVolumeClaim
0000000000000000000000000000000000000000;;		// Unique name of Kubernetes cluster.
0000000000000000000000000000000000000000;;		ClusterName string
0000000000000000000000000000000000000000;;		// Tags to attach to the real volume in the cloud provider - e.g. AWS EBS
0000000000000000000000000000000000000000;;		CloudTags *map[string]string
0000000000000000000000000000000000000000;;		// Volume provisioning parameters from StorageClass
0000000000000000000000000000000000000000;;		Parameters map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumePlugin is an interface to volume plugins that can be used on a
0000000000000000000000000000000000000000;;	// kubernetes node (e.g. by kubelet) to instantiate and manage volumes.
0000000000000000000000000000000000000000;;	type VolumePlugin interface {
0000000000000000000000000000000000000000;;		// Init initializes the plugin.  This will be called exactly once
0000000000000000000000000000000000000000;;		// before any New* calls are made - implementations of plugins may
0000000000000000000000000000000000000000;;		// depend on this.
0000000000000000000000000000000000000000;;		Init(host VolumeHost) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name returns the plugin's name.  Plugins must use namespaced names
0000000000000000000000000000000000000000;;		// such as "example.com/volume" and contain exactly one '/' character.
0000000000000000000000000000000000000000;;		// The "kubernetes.io" namespace is reserved for plugins which are
0000000000000000000000000000000000000000;;		// bundled with kubernetes.
0000000000000000000000000000000000000000;;		GetPluginName() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetVolumeName returns the name/ID to uniquely identifying the actual
0000000000000000000000000000000000000000;;		// backing device, directory, path, etc. referenced by the specified volume
0000000000000000000000000000000000000000;;		// spec.
0000000000000000000000000000000000000000;;		// For Attachable volumes, this value must be able to be passed back to
0000000000000000000000000000000000000000;;		// volume Detach methods to identify the device to act on.
0000000000000000000000000000000000000000;;		// If the plugin does not support the given spec, this returns an error.
0000000000000000000000000000000000000000;;		GetVolumeName(spec *Spec) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CanSupport tests whether the plugin supports a given volume
0000000000000000000000000000000000000000;;		// specification from the API.  The spec pointer should be considered
0000000000000000000000000000000000000000;;		// const.
0000000000000000000000000000000000000000;;		CanSupport(spec *Spec) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequiresRemount returns true if this plugin requires mount calls to be
0000000000000000000000000000000000000000;;		// reexecuted. Atomically updating volumes, like Downward API, depend on
0000000000000000000000000000000000000000;;		// this to update the contents of the volume.
0000000000000000000000000000000000000000;;		RequiresRemount() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewMounter creates a new volume.Mounter from an API specification.
0000000000000000000000000000000000000000;;		// Ownership of the spec pointer in *not* transferred.
0000000000000000000000000000000000000000;;		// - spec: The v1.Volume spec
0000000000000000000000000000000000000000;;		// - pod: The enclosing pod
0000000000000000000000000000000000000000;;		NewMounter(spec *Spec, podRef *v1.Pod, opts VolumeOptions) (Mounter, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewUnmounter creates a new volume.Unmounter from recoverable state.
0000000000000000000000000000000000000000;;		// - name: The volume name, as per the v1.Volume spec.
0000000000000000000000000000000000000000;;		// - podUID: The UID of the enclosing pod
0000000000000000000000000000000000000000;;		NewUnmounter(name string, podUID types.UID) (Unmounter, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConstructVolumeSpec constructs a volume spec based on the given volume name
0000000000000000000000000000000000000000;;		// and mountPath. The spec may have incomplete information due to limited
0000000000000000000000000000000000000000;;		// information from input. This function is used by volume manager to reconstruct
0000000000000000000000000000000000000000;;		// volume spec by reading the volume directories from disk
0000000000000000000000000000000000000000;;		ConstructVolumeSpec(volumeName, mountPath string) (*Spec, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SupportsMountOption returns true if volume plugins supports Mount options
0000000000000000000000000000000000000000;;		// Specifying mount options in a volume plugin that doesn't support
0000000000000000000000000000000000000000;;		// user specified mount options will result in error creating persistent volumes
0000000000000000000000000000000000000000;;		SupportsMountOption() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SupportsBulkVolumeVerification checks if volume plugin type is capable
0000000000000000000000000000000000000000;;		// of enabling bulk polling of all nodes. This can speed up verification of
0000000000000000000000000000000000000000;;		// attached volumes by quite a bit, but underlying pluging must support it.
0000000000000000000000000000000000000000;;		SupportsBulkVolumeVerification() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumePlugin is an extended interface of VolumePlugin and is used
0000000000000000000000000000000000000000;;	// by volumes that want to provide long term persistence of data
0000000000000000000000000000000000000000;;	type PersistentVolumePlugin interface {
0000000000000000000000000000000000000000;;		VolumePlugin
0000000000000000000000000000000000000000;;		// GetAccessModes describes the ways a given volume can be accessed/mounted.
0000000000000000000000000000000000000000;;		GetAccessModes() []v1.PersistentVolumeAccessMode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecyclableVolumePlugin is an extended interface of VolumePlugin and is used
0000000000000000000000000000000000000000;;	// by persistent volumes that want to be recycled before being made available
0000000000000000000000000000000000000000;;	// again to new claims
0000000000000000000000000000000000000000;;	type RecyclableVolumePlugin interface {
0000000000000000000000000000000000000000;;		VolumePlugin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recycle knows how to reclaim this
0000000000000000000000000000000000000000;;		// resource after the volume's release from a PersistentVolumeClaim.
0000000000000000000000000000000000000000;;		// Recycle will use the provided recorder to write any events that might be
0000000000000000000000000000000000000000;;		// interesting to user. It's expected that caller will pass these events to
0000000000000000000000000000000000000000;;		// the PV being recycled.
0000000000000000000000000000000000000000;;		Recycle(pvName string, spec *Spec, eventRecorder RecycleEventRecorder) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletableVolumePlugin is an extended interface of VolumePlugin and is used
0000000000000000000000000000000000000000;;	// by persistent volumes that want to be deleted from the cluster after their
0000000000000000000000000000000000000000;;	// release from a PersistentVolumeClaim.
0000000000000000000000000000000000000000;;	type DeletableVolumePlugin interface {
0000000000000000000000000000000000000000;;		VolumePlugin
0000000000000000000000000000000000000000;;		// NewDeleter creates a new volume.Deleter which knows how to delete this
0000000000000000000000000000000000000000;;		// resource in accordance with the underlying storage provider after the
0000000000000000000000000000000000000000;;		// volume's release from a claim
0000000000000000000000000000000000000000;;		NewDeleter(spec *Spec) (Deleter, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Name of a volume in external cloud that is being provisioned and thus
0000000000000000000000000000000000000000;;		// should be ignored by rest of Kubernetes.
0000000000000000000000000000000000000000;;		ProvisionedVolumeName = "placeholder-for-provisioning"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProvisionableVolumePlugin is an extended interface of VolumePlugin and is
0000000000000000000000000000000000000000;;	// used to create volumes for the cluster.
0000000000000000000000000000000000000000;;	type ProvisionableVolumePlugin interface {
0000000000000000000000000000000000000000;;		VolumePlugin
0000000000000000000000000000000000000000;;		// NewProvisioner creates a new volume.Provisioner which knows how to
0000000000000000000000000000000000000000;;		// create PersistentVolumes in accordance with the plugin's underlying
0000000000000000000000000000000000000000;;		// storage provider
0000000000000000000000000000000000000000;;		NewProvisioner(options VolumeOptions) (Provisioner, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachableVolumePlugin is an extended interface of VolumePlugin and is used for volumes that require attachment
0000000000000000000000000000000000000000;;	// to a node before mounting.
0000000000000000000000000000000000000000;;	type AttachableVolumePlugin interface {
0000000000000000000000000000000000000000;;		VolumePlugin
0000000000000000000000000000000000000000;;		NewAttacher() (Attacher, error)
0000000000000000000000000000000000000000;;		NewDetacher() (Detacher, error)
0000000000000000000000000000000000000000;;		GetDeviceMountRefs(deviceMountPath string) ([]string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeHost is an interface that plugins can use to access the kubelet.
0000000000000000000000000000000000000000;;	type VolumeHost interface {
0000000000000000000000000000000000000000;;		// GetPluginDir returns the absolute path to a directory under which
0000000000000000000000000000000000000000;;		// a given plugin may store data.  This directory might not actually
0000000000000000000000000000000000000000;;		// exist on disk yet.  For plugin data that is per-pod, see
0000000000000000000000000000000000000000;;		// GetPodPluginDir().
0000000000000000000000000000000000000000;;		GetPluginDir(pluginName string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetPodVolumeDir returns the absolute path a directory which
0000000000000000000000000000000000000000;;		// represents the named volume under the named plugin for the given
0000000000000000000000000000000000000000;;		// pod.  If the specified pod does not exist, the result of this call
0000000000000000000000000000000000000000;;		// might not exist.
0000000000000000000000000000000000000000;;		GetPodVolumeDir(podUID types.UID, pluginName string, volumeName string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetPodPluginDir returns the absolute path to a directory under which
0000000000000000000000000000000000000000;;		// a given plugin may store data for a given pod.  If the specified pod
0000000000000000000000000000000000000000;;		// does not exist, the result of this call might not exist.  This
0000000000000000000000000000000000000000;;		// directory might not actually exist on disk yet.
0000000000000000000000000000000000000000;;		GetPodPluginDir(podUID types.UID, pluginName string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetKubeClient returns a client interface
0000000000000000000000000000000000000000;;		GetKubeClient() clientset.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewWrapperMounter finds an appropriate plugin with which to handle
0000000000000000000000000000000000000000;;		// the provided spec.  This is used to implement volume plugins which
0000000000000000000000000000000000000000;;		// "wrap" other plugins.  For example, the "secret" volume is
0000000000000000000000000000000000000000;;		// implemented in terms of the "emptyDir" volume.
0000000000000000000000000000000000000000;;		NewWrapperMounter(volName string, spec Spec, pod *v1.Pod, opts VolumeOptions) (Mounter, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewWrapperUnmounter finds an appropriate plugin with which to handle
0000000000000000000000000000000000000000;;		// the provided spec.  See comments on NewWrapperMounter for more
0000000000000000000000000000000000000000;;		// context.
0000000000000000000000000000000000000000;;		NewWrapperUnmounter(volName string, spec Spec, podUID types.UID) (Unmounter, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get cloud provider from kubelet.
0000000000000000000000000000000000000000;;		GetCloudProvider() cloudprovider.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get mounter interface.
0000000000000000000000000000000000000000;;		GetMounter() mount.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get writer interface for writing data to disk.
0000000000000000000000000000000000000000;;		GetWriter() io.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns the hostname of the host kubelet is running on
0000000000000000000000000000000000000000;;		GetHostName() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns host IP or nil in the case of error.
0000000000000000000000000000000000000000;;		GetHostIP() (net.IP, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns node allocatable.
0000000000000000000000000000000000000000;;		GetNodeAllocatable() (v1.ResourceList, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a function that returns a secret.
0000000000000000000000000000000000000000;;		GetSecretFunc() func(namespace, name string) (*v1.Secret, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a function that returns a configmap.
0000000000000000000000000000000000000000;;		GetConfigMapFunc() func(namespace, name string) (*v1.ConfigMap, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns the labels on the node
0000000000000000000000000000000000000000;;		GetNodeLabels() (map[string]string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumePluginMgr tracks registered plugins.
0000000000000000000000000000000000000000;;	type VolumePluginMgr struct {
0000000000000000000000000000000000000000;;		mutex   sync.Mutex
0000000000000000000000000000000000000000;;		plugins map[string]VolumePlugin
0000000000000000000000000000000000000000;;		Host    VolumeHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec is an internal representation of a volume.  All API volume types translate to Spec.
0000000000000000000000000000000000000000;;	type Spec struct {
0000000000000000000000000000000000000000;;		Volume           *v1.Volume
0000000000000000000000000000000000000000;;		PersistentVolume *v1.PersistentVolume
0000000000000000000000000000000000000000;;		ReadOnly         bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the name of either Volume or PersistentVolume, one of which must not be nil.
0000000000000000000000000000000000000000;;	func (spec *Spec) Name() string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case spec.Volume != nil:
0000000000000000000000000000000000000000;;			return spec.Volume.Name
0000000000000000000000000000000000000000;;		case spec.PersistentVolume != nil:
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Name
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeConfig is how volume plugins receive configuration.  An instance
0000000000000000000000000000000000000000;;	// specific to the plugin will be passed to the plugin's
0000000000000000000000000000000000000000;;	// ProbeVolumePlugins(config) func.  Reasonable defaults will be provided by
0000000000000000000000000000000000000000;;	// the binary hosting the plugins while allowing override of those default
0000000000000000000000000000000000000000;;	// values.  Those config values are then set to an instance of VolumeConfig
0000000000000000000000000000000000000000;;	// and passed to the plugin.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Values in VolumeConfig are intended to be relevant to several plugins, but
0000000000000000000000000000000000000000;;	// not necessarily all plugins.  The preference is to leverage strong typing
0000000000000000000000000000000000000000;;	// in this struct.  All config items must have a descriptive but non-specific
0000000000000000000000000000000000000000;;	// name (i.e, RecyclerMinimumTimeout is OK but RecyclerMinimumTimeoutForNFS is
0000000000000000000000000000000000000000;;	// !OK).  An instance of config will be given directly to the plugin, so
0000000000000000000000000000000000000000;;	// config names specific to plugins are unneeded and wrongly expose plugins in
0000000000000000000000000000000000000000;;	// this VolumeConfig struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// OtherAttributes is a map of string values intended for one-off
0000000000000000000000000000000000000000;;	// configuration of a plugin or config that is only relevant to a single
0000000000000000000000000000000000000000;;	// plugin.  All values are passed by string and require interpretation by the
0000000000000000000000000000000000000000;;	// plugin. Passing config as strings is the least desirable option but can be
0000000000000000000000000000000000000000;;	// used for truly one-off configuration. The binary should still use strong
0000000000000000000000000000000000000000;;	// typing for this value when binding CLI values before they are passed as
0000000000000000000000000000000000000000;;	// strings in OtherAttributes.
0000000000000000000000000000000000000000;;	type VolumeConfig struct {
0000000000000000000000000000000000000000;;		// RecyclerPodTemplate is pod template that understands how to scrub clean
0000000000000000000000000000000000000000;;		// a persistent volume after its release. The template is used by plugins
0000000000000000000000000000000000000000;;		// which override specific properties of the pod in accordance with that
0000000000000000000000000000000000000000;;		// plugin. See NewPersistentVolumeRecyclerPodTemplate for the properties
0000000000000000000000000000000000000000;;		// that are expected to be overridden.
0000000000000000000000000000000000000000;;		RecyclerPodTemplate *v1.Pod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RecyclerMinimumTimeout is the minimum amount of time in seconds for the
0000000000000000000000000000000000000000;;		// recycler pod's ActiveDeadlineSeconds attribute. Added to the minimum
0000000000000000000000000000000000000000;;		// timeout is the increment per Gi of capacity.
0000000000000000000000000000000000000000;;		RecyclerMinimumTimeout int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RecyclerTimeoutIncrement is the number of seconds added to the recycler
0000000000000000000000000000000000000000;;		// pod's ActiveDeadlineSeconds for each Gi of capacity in the persistent
0000000000000000000000000000000000000000;;		// volume. Example: 5Gi volume x 30s increment = 150s + 30s minimum = 180s
0000000000000000000000000000000000000000;;		// ActiveDeadlineSeconds for recycler pod
0000000000000000000000000000000000000000;;		RecyclerTimeoutIncrement int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PVName is name of the PersistentVolume instance that is being recycled.
0000000000000000000000000000000000000000;;		// It is used to generate unique recycler pod name.
0000000000000000000000000000000000000000;;		PVName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OtherAttributes stores config as strings.  These strings are opaque to
0000000000000000000000000000000000000000;;		// the system and only understood by the binary hosting the plugin and the
0000000000000000000000000000000000000000;;		// plugin itself.
0000000000000000000000000000000000000000;;		OtherAttributes map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ProvisioningEnabled configures whether provisioning of this plugin is
0000000000000000000000000000000000000000;;		// enabled or not. Currently used only in host_path plugin.
0000000000000000000000000000000000000000;;		ProvisioningEnabled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSpecFromVolume creates an Spec from an v1.Volume
0000000000000000000000000000000000000000;;	func NewSpecFromVolume(vs *v1.Volume) *Spec {
0000000000000000000000000000000000000000;;		return &Spec{
0000000000000000000000000000000000000000;;			Volume: vs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSpecFromPersistentVolume creates an Spec from an v1.PersistentVolume
0000000000000000000000000000000000000000;;	func NewSpecFromPersistentVolume(pv *v1.PersistentVolume, readOnly bool) *Spec {
0000000000000000000000000000000000000000;;		return &Spec{
0000000000000000000000000000000000000000;;			PersistentVolume: pv,
0000000000000000000000000000000000000000;;			ReadOnly:         readOnly,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitPlugins initializes each plugin.  All plugins must have unique names.
0000000000000000000000000000000000000000;;	// This must be called exactly once before any New* methods are called on any
0000000000000000000000000000000000000000;;	// plugins.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) InitPlugins(plugins []VolumePlugin, host VolumeHost) error {
0000000000000000000000000000000000000000;;		pm.mutex.Lock()
0000000000000000000000000000000000000000;;		defer pm.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pm.Host = host
0000000000000000000000000000000000000000;;		if pm.plugins == nil {
0000000000000000000000000000000000000000;;			pm.plugins = map[string]VolumePlugin{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs := []error{}
0000000000000000000000000000000000000000;;		for _, plugin := range plugins {
0000000000000000000000000000000000000000;;			name := plugin.GetPluginName()
0000000000000000000000000000000000000000;;			if errs := validation.IsQualifiedName(name); len(errs) != 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("volume plugin has invalid name: %q: %s", name, strings.Join(errs, ";")))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, found := pm.plugins[name]; found {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, fmt.Errorf("volume plugin %q was registered more than once", name))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := plugin.Init(host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to load volume plugin %s, error: %s", plugin, err.Error())
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pm.plugins[name] = plugin
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Loaded volume plugin %q", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(allErrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPluginBySpec looks for a plugin that can support a given volume
0000000000000000000000000000000000000000;;	// specification.  If no plugins can support or more than one plugin can
0000000000000000000000000000000000000000;;	// support it, return error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindPluginBySpec(spec *Spec) (VolumePlugin, error) {
0000000000000000000000000000000000000000;;		pm.mutex.Lock()
0000000000000000000000000000000000000000;;		defer pm.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matches := []string{}
0000000000000000000000000000000000000000;;		for k, v := range pm.plugins {
0000000000000000000000000000000000000000;;			if v.CanSupport(spec) {
0000000000000000000000000000000000000000;;				matches = append(matches, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matches) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no volume plugin matched")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matches) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple volume plugins matched: %s", strings.Join(matches, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pm.plugins[matches[0]], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPluginByName fetches a plugin by name or by legacy name.  If no plugin
0000000000000000000000000000000000000000;;	// is found, returns error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindPluginByName(name string) (VolumePlugin, error) {
0000000000000000000000000000000000000000;;		pm.mutex.Lock()
0000000000000000000000000000000000000000;;		defer pm.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Once we can get rid of legacy names we can reduce this to a map lookup.
0000000000000000000000000000000000000000;;		matches := []string{}
0000000000000000000000000000000000000000;;		for k, v := range pm.plugins {
0000000000000000000000000000000000000000;;			if v.GetPluginName() == name {
0000000000000000000000000000000000000000;;				matches = append(matches, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matches) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no volume plugin matched")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matches) > 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("multiple volume plugins matched: %s", strings.Join(matches, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pm.plugins[matches[0]], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPersistentPluginBySpec looks for a persistent volume plugin that can
0000000000000000000000000000000000000000;;	// support a given volume specification.  If no plugin is found, return an
0000000000000000000000000000000000000000;;	// error
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindPersistentPluginBySpec(spec *Spec) (PersistentVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Could not find volume plugin for spec: %#v", spec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if persistentVolumePlugin, ok := volumePlugin.(PersistentVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return persistentVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no persistent volume plugin matched")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPersistentPluginByName fetches a persistent volume plugin by name.  If
0000000000000000000000000000000000000000;;	// no plugin is found, returns error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindPersistentPluginByName(name string) (PersistentVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginByName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if persistentVolumePlugin, ok := volumePlugin.(PersistentVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return persistentVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no persistent volume plugin matched")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindRecyclablePluginByName fetches a persistent volume plugin by name.  If
0000000000000000000000000000000000000000;;	// no plugin is found, returns error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindRecyclablePluginBySpec(spec *Spec) (RecyclableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if recyclableVolumePlugin, ok := volumePlugin.(RecyclableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return recyclableVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no recyclable volume plugin matched")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindProvisionablePluginByName fetches  a persistent volume plugin by name.  If
0000000000000000000000000000000000000000;;	// no plugin is found, returns error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindProvisionablePluginByName(name string) (ProvisionableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginByName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if provisionableVolumePlugin, ok := volumePlugin.(ProvisionableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return provisionableVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no provisionable volume plugin matched")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindDeletablePluginBySppec fetches a persistent volume plugin by spec.  If
0000000000000000000000000000000000000000;;	// no plugin is found, returns error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindDeletablePluginBySpec(spec *Spec) (DeletableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deletableVolumePlugin, ok := volumePlugin.(DeletableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return deletableVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no deletable volume plugin matched")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindDeletablePluginByName fetches a persistent volume plugin by name.  If
0000000000000000000000000000000000000000;;	// no plugin is found, returns error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindDeletablePluginByName(name string) (DeletableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginByName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deletableVolumePlugin, ok := volumePlugin.(DeletableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return deletableVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no deletable volume plugin matched")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindCreatablePluginBySpec fetches a persistent volume plugin by name.  If
0000000000000000000000000000000000000000;;	// no plugin is found, returns error.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindCreatablePluginBySpec(spec *Spec) (ProvisionableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if provisionableVolumePlugin, ok := volumePlugin.(ProvisionableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return provisionableVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no creatable volume plugin matched")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindAttachablePluginBySpec fetches a persistent volume plugin by name.
0000000000000000000000000000000000000000;;	// Unlike the other "FindPlugin" methods, this does not return error if no
0000000000000000000000000000000000000000;;	// plugin is found.  All volumes require a mounter and unmounter, but not
0000000000000000000000000000000000000000;;	// every volume will have an attacher/detacher.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindAttachablePluginBySpec(spec *Spec) (AttachableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginBySpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if attachableVolumePlugin, ok := volumePlugin.(AttachableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return attachableVolumePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindAttachablePluginByName fetches an attachable volume plugin by name.
0000000000000000000000000000000000000000;;	// Unlike the other "FindPlugin" methods, this does not return error if no
0000000000000000000000000000000000000000;;	// plugin is found.  All volumes require a mounter and unmounter, but not
0000000000000000000000000000000000000000;;	// every volume will have an attacher/detacher.
0000000000000000000000000000000000000000;;	func (pm *VolumePluginMgr) FindAttachablePluginByName(name string) (AttachableVolumePlugin, error) {
0000000000000000000000000000000000000000;;		volumePlugin, err := pm.FindPluginByName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if attachablePlugin, ok := volumePlugin.(AttachableVolumePlugin); ok {
0000000000000000000000000000000000000000;;			return attachablePlugin, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPersistentVolumeRecyclerPodTemplate creates a template for a recycler
0000000000000000000000000000000000000000;;	// pod.  By default, a recycler pod simply runs "rm -rf" on a volume and tests
0000000000000000000000000000000000000000;;	// for emptiness.  Most attributes of the template will be correct for most
0000000000000000000000000000000000000000;;	// plugin implementations.  The following attributes can be overridden per
0000000000000000000000000000000000000000;;	// plugin via configuration:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1.  pod.Spec.Volumes[0].VolumeSource must be overridden.  Recycler
0000000000000000000000000000000000000000;;	//     implementations without a valid VolumeSource will fail.
0000000000000000000000000000000000000000;;	// 2.  pod.GenerateName helps distinguish recycler pods by name.  Recommended.
0000000000000000000000000000000000000000;;	//     Default is "pv-recycler-".
0000000000000000000000000000000000000000;;	// 3.  pod.Spec.ActiveDeadlineSeconds gives the recycler pod a maximum timeout
0000000000000000000000000000000000000000;;	//     before failing.  Recommended.  Default is 60 seconds.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See HostPath and NFS for working recycler examples
0000000000000000000000000000000000000000;;	func NewPersistentVolumeRecyclerPodTemplate() *v1.Pod {
0000000000000000000000000000000000000000;;		timeout := int64(60)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				GenerateName: "pv-recycler-",
0000000000000000000000000000000000000000;;				Namespace:    metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				ActiveDeadlineSeconds: &timeout,
0000000000000000000000000000000000000000;;				RestartPolicy:         v1.RestartPolicyNever,
0000000000000000000000000000000000000000;;				Volumes: []v1.Volume{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "vol",
0000000000000000000000000000000000000000;;						// IMPORTANT!  All plugins using this template MUST
0000000000000000000000000000000000000000;;						// override pod.Spec.Volumes[0].VolumeSource Recycler
0000000000000000000000000000000000000000;;						// implementations without a valid VolumeSource will fail.
0000000000000000000000000000000000000000;;						VolumeSource: v1.VolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name:    "pv-recycler",
0000000000000000000000000000000000000000;;						Image:   "gcr.io/google_containers/busybox",
0000000000000000000000000000000000000000;;						Command: []string{"/bin/sh"},
0000000000000000000000000000000000000000;;						Args:    []string{"-c", "test -e /scrub && rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  && test -z \"$(ls -A /scrub)\" || exit 1"},
0000000000000000000000000000000000000000;;						VolumeMounts: []v1.VolumeMount{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:      "vol",
0000000000000000000000000000000000000000;;								MountPath: "/scrub",
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check validity of recycle pod template
0000000000000000000000000000000000000000;;	// List of checks:
0000000000000000000000000000000000000000;;	// - at least one volume is defined in the recycle pod template
0000000000000000000000000000000000000000;;	// If successful, returns nil
0000000000000000000000000000000000000000;;	// if unsuccessful, returns an error.
0000000000000000000000000000000000000000;;	func ValidateRecyclerPodTemplate(pod *v1.Pod) error {
0000000000000000000000000000000000000000;;		if len(pod.Spec.Volumes) < 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("does not contain any volume(s)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
