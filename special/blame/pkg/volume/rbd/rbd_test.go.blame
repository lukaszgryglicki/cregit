0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
27eb00d606d55ee7423c57499e0422b4888f0962;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rbd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("rbd_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/rbd")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.GetPluginName() != "kubernetes.io/rbd" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plug.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.CanSupport(&volume.Spec{Volume: &v1.Volume{VolumeSource: v1.VolumeSource{}}}) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeDiskManager struct {
0000000000000000000000000000000000000000;;		tmpDir string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeDiskManager() *fakeDiskManager {
0000000000000000000000000000000000000000;;		return &fakeDiskManager{
0000000000000000000000000000000000000000;;			tmpDir: utiltesting.MkTmpdirOrDie("rbd_test"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) Cleanup() {
0000000000000000000000000000000000000000;;		os.RemoveAll(fake.tmpDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) MakeGlobalPDName(disk rbd) string {
0000000000000000000000000000000000000000;;		return fake.tmpDir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) AttachDisk(b rbdMounter) error {
0000000000000000000000000000000000000000;;		globalPath := b.manager.MakeGlobalPDName(*b.rbd)
0000000000000000000000000000000000000000;;		err := os.MkdirAll(globalPath, 0750)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) DetachDisk(c rbdUnmounter, mntPath string) error {
0000000000000000000000000000000000000000;;		globalPath := c.manager.MakeGlobalPDName(*c.rbd)
0000000000000000000000000000000000000000;;		err := os.RemoveAll(globalPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) CreateImage(provisioner *rbdVolumeProvisioner) (r *v1.RBDVolumeSource, volumeSizeGB int, err error) {
0000000000000000000000000000000000000000;;		return nil, 0, fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fake *fakeDiskManager) DeleteImage(deleter *rbdVolumeDeleter) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doTestPlugin(t *testing.T, spec *volume.Spec) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("rbd_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, nil, nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName("kubernetes.io/rbd")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin by name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fdm := NewFakeDiskManager()
0000000000000000000000000000000000000000;;		defer fdm.Cleanup()
0000000000000000000000000000000000000000;;		mounter, err := plug.(*rbdPlugin).newMounterInternal(spec, types.UID("poduid"), fdm, &mount.FakeMounter{}, "secrets")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mounter == nil {
0000000000000000000000000000000000000000;;			t.Error("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := mounter.GetPath()
0000000000000000000000000000000000000000;;		expectedPath := fmt.Sprintf("%s/pods/poduid/volumes/kubernetes.io~rbd/vol1", tmpDir)
0000000000000000000000000000000000000000;;		if path != expectedPath {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected path, expected %q, got: %q", expectedPath, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := mounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed, volume path not created: %s", path)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unmounter, err := plug.(*rbdPlugin).newUnmounterInternal("vol1", types.UID("poduid"), fdm, &mount.FakeMounter{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unmounter == nil {
0000000000000000000000000000000000000000;;			t.Error("Got a nil Unmounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := unmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("TearDown() failed, volume path still exists: %s", path)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluginVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		vol := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: "vol1",
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;					CephMonitors: []string{"a", "b"},
0000000000000000000000000000000000000000;;					RBDImage:     "bar",
0000000000000000000000000000000000000000;;					FSType:       "ext4",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		doTestPlugin(t, volume.NewSpecFromVolume(vol))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestPluginPersistentVolume(t *testing.T) {
0000000000000000000000000000000000000000;;		vol := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "vol1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;						CephMonitors: []string{"a", "b"},
0000000000000000000000000000000000000000;;						RBDImage:     "bar",
0000000000000000000000000000000000000000;;						FSType:       "ext4",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doTestPlugin(t, volume.NewSpecFromPersistentVolume(vol, false))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPersistentClaimReadOnlyFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("rbd_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error creating temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &v1.PersistentVolume{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;				PersistentVolumeSource: v1.PersistentVolumeSource{
0000000000000000000000000000000000000000;;					RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;						CephMonitors: []string{"a", "b"},
0000000000000000000000000000000000000000;;						RBDImage:     "bar",
0000000000000000000000000000000000000000;;						FSType:       "ext4",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ClaimRef: &v1.ObjectReference{
0000000000000000000000000000000000000000;;					Name: "claimA",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claim := &v1.PersistentVolumeClaim{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "claimA",
0000000000000000000000000000000000000000;;				Namespace: "nsA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PersistentVolumeClaimSpec{
0000000000000000000000000000000000000000;;				VolumeName: "pvA",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: v1.PersistentVolumeClaimStatus{
0000000000000000000000000000000000000000;;				Phase: v1.ClaimBound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := fake.NewSimpleClientset(pv, claim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plugMgr := volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), volumetest.NewFakeVolumeHost(tmpDir, client, nil))
0000000000000000000000000000000000000000;;		plug, _ := plugMgr.FindPluginByName(rbdPluginName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readOnly bool is supplied by persistent-claim volume source when its mounter creates other volumes
0000000000000000000000000000000000000000;;		spec := volume.NewSpecFromPersistentVolume(pv, true)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{UID: types.UID("poduid")}}
0000000000000000000000000000000000000000;;		mounter, _ := plug.NewMounter(spec, pod, volume.VolumeOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !mounter.GetAttributes().ReadOnly {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true for mounter.IsReadOnly")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
