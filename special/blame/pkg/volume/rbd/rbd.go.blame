0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
27eb00d606d55ee7423c57499e0422b4888f0962;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rbd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		dstrings "strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/uuid"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/strings"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume/util/volumehelper"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		supportedFeatures = sets.NewString("layering")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the primary entrypoint for volume plugins.
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{&rbdPlugin{nil, exec.New()}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rbdPlugin struct {
0000000000000000000000000000000000000000;;		host volume.VolumeHost
0000000000000000000000000000000000000000;;		exe  exec.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &rbdPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &rbdPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &rbdPlugin{}
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &rbdPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rbdPluginName   = "kubernetes.io/rbd"
0000000000000000000000000000000000000000;;		secretKeyName   = "key" // key name used in secret
0000000000000000000000000000000000000000;;		rbdImageFormat1 = "1"
0000000000000000000000000000000000000000;;		rbdImageFormat2 = "2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		plugin.host = host
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return rbdPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		volumeSource, _, err := getVolumeSource(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%v:%v",
0000000000000000000000000000000000000000;;			volumeSource.CephMonitors,
0000000000000000000000000000000000000000;;			volumeSource.RBDImage), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		if (spec.Volume != nil && spec.Volume.RBD == nil) || (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.RBD == nil) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) GetAccessModes() []v1.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []v1.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			v1.ReadWriteOnce,
0000000000000000000000000000000000000000;;			v1.ReadOnlyMany,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) NewMounter(spec *volume.Spec, pod *v1.Pod, _ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		var secret string
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		source, _ := plugin.getRBDVolumeSource(spec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if source.SecretRef != nil {
0000000000000000000000000000000000000000;;			if secret, err = parsePodSecret(pod, source.SecretRef.Name, plugin.host.GetKubeClient()); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get secret from %v/%v", pod.Namespace, source.SecretRef)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return plugin.newMounterInternal(spec, pod.UID, &RBDUtil{}, plugin.host.GetMounter(), secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) getRBDVolumeSource(spec *volume.Spec) (*v1.RBDVolumeSource, bool) {
0000000000000000000000000000000000000000;;		// rbd volumes used directly in a pod have a ReadOnly flag set by the pod author.
0000000000000000000000000000000000000000;;		// rbd volumes used as a PersistentVolume gets the ReadOnly flag indirectly through the persistent-claim volume used to mount the PV
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.RBD != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.RBD, spec.Volume.RBD.ReadOnly
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.RBD, spec.ReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) newMounterInternal(spec *volume.Spec, podUID types.UID, manager diskManager, mounter mount.Interface, secret string) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		source, readOnly := plugin.getRBDVolumeSource(spec)
0000000000000000000000000000000000000000;;		pool := source.RBDPool
0000000000000000000000000000000000000000;;		id := source.RadosUser
0000000000000000000000000000000000000000;;		keyring := source.Keyring
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rbdMounter{
0000000000000000000000000000000000000000;;			rbd: &rbd{
0000000000000000000000000000000000000000;;				podUID:   podUID,
0000000000000000000000000000000000000000;;				volName:  spec.Name(),
0000000000000000000000000000000000000000;;				Image:    source.RBDImage,
0000000000000000000000000000000000000000;;				Pool:     pool,
0000000000000000000000000000000000000000;;				ReadOnly: readOnly,
0000000000000000000000000000000000000000;;				manager:  manager,
0000000000000000000000000000000000000000;;				mounter:  &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()},
0000000000000000000000000000000000000000;;				plugin:   plugin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Mon:          source.CephMonitors,
0000000000000000000000000000000000000000;;			Id:           id,
0000000000000000000000000000000000000000;;			Keyring:      keyring,
0000000000000000000000000000000000000000;;			Secret:       secret,
0000000000000000000000000000000000000000;;			fsType:       source.FSType,
0000000000000000000000000000000000000000;;			mountOptions: volume.MountOptionFromSpec(spec),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) NewUnmounter(volName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		// Inject real implementations here, test through the internal function.
0000000000000000000000000000000000000000;;		return plugin.newUnmounterInternal(volName, podUID, &RBDUtil{}, plugin.host.GetMounter())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) newUnmounterInternal(volName string, podUID types.UID, manager diskManager, mounter mount.Interface) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		return &rbdUnmounter{
0000000000000000000000000000000000000000;;			rbdMounter: &rbdMounter{
0000000000000000000000000000000000000000;;				rbd: &rbd{
0000000000000000000000000000000000000000;;					podUID:  podUID,
0000000000000000000000000000000000000000;;					volName: volName,
0000000000000000000000000000000000000000;;					manager: manager,
0000000000000000000000000000000000000000;;					mounter: &mount.SafeFormatAndMount{Interface: mounter, Runner: exec.New()},
0000000000000000000000000000000000000000;;					plugin:  plugin,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Mon: make([]string, 0),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		rbdVolume := &v1.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: v1.VolumeSource{
0000000000000000000000000000000000000000;;				RBD: &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;					CephMonitors: []string{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(rbdVolume), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil && spec.PersistentVolume.Spec.RBD == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec.PersistentVolumeSource.Spec.RBD is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		class, err := volutil.GetClassForVolume(plugin.host.GetKubeClient(), spec.PersistentVolume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		adminSecretName := ""
0000000000000000000000000000000000000000;;		adminSecretNamespace := "default"
0000000000000000000000000000000000000000;;		admin := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range class.Parameters {
0000000000000000000000000000000000000000;;			switch dstrings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "adminid":
0000000000000000000000000000000000000000;;				admin = v
0000000000000000000000000000000000000000;;			case "adminsecretname":
0000000000000000000000000000000000000000;;				adminSecretName = v
0000000000000000000000000000000000000000;;			case "adminsecretnamespace":
0000000000000000000000000000000000000000;;				adminSecretNamespace = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secret, err := parsePVSecret(adminSecretNamespace, adminSecretName, plugin.host.GetKubeClient())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get admin secret from [%q/%q]: %v", adminSecretNamespace, adminSecretName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plugin.newDeleterInternal(spec, admin, secret, &RBDUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) newDeleterInternal(spec *volume.Spec, admin, secret string, manager diskManager) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		return &rbdVolumeDeleter{
0000000000000000000000000000000000000000;;			rbdMounter: &rbdMounter{
0000000000000000000000000000000000000000;;				rbd: &rbd{
0000000000000000000000000000000000000000;;					volName: spec.Name(),
0000000000000000000000000000000000000000;;					Image:   spec.PersistentVolume.Spec.RBD.RBDImage,
0000000000000000000000000000000000000000;;					Pool:    spec.PersistentVolume.Spec.RBD.RBDPool,
0000000000000000000000000000000000000000;;					manager: manager,
0000000000000000000000000000000000000000;;					plugin:  plugin,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Mon:         spec.PersistentVolume.Spec.RBD.CephMonitors,
0000000000000000000000000000000000000000;;				adminId:     admin,
0000000000000000000000000000000000000000;;				adminSecret: secret,
0000000000000000000000000000000000000000;;			}}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return plugin.newProvisionerInternal(options, &RBDUtil{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) newProvisionerInternal(options volume.VolumeOptions, manager diskManager) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		return &rbdVolumeProvisioner{
0000000000000000000000000000000000000000;;			rbdMounter: &rbdMounter{
0000000000000000000000000000000000000000;;				rbd: &rbd{
0000000000000000000000000000000000000000;;					manager: manager,
0000000000000000000000000000000000000000;;					plugin:  plugin,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			options: options,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rbdVolumeProvisioner struct {
0000000000000000000000000000000000000000;;		*rbdMounter
0000000000000000000000000000000000000000;;		options volume.VolumeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rbdVolumeProvisioner) Provision() (*v1.PersistentVolume, error) {
0000000000000000000000000000000000000000;;		if !volume.AccessModesContainedInAll(r.plugin.GetAccessModes(), r.options.PVC.Spec.AccessModes) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid AccessModes %v: only AccessModes %v are supported", r.options.PVC.Spec.AccessModes, r.plugin.GetAccessModes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.options.PVC.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("claim Selector is not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		adminSecretName := ""
0000000000000000000000000000000000000000;;		adminSecretNamespace := "default"
0000000000000000000000000000000000000000;;		secretName := ""
0000000000000000000000000000000000000000;;		secret := ""
0000000000000000000000000000000000000000;;		imageFormat := rbdImageFormat1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range r.options.Parameters {
0000000000000000000000000000000000000000;;			switch dstrings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "monitors":
0000000000000000000000000000000000000000;;				arr := dstrings.Split(v, ",")
0000000000000000000000000000000000000000;;				for _, m := range arr {
0000000000000000000000000000000000000000;;					r.Mon = append(r.Mon, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "adminid":
0000000000000000000000000000000000000000;;				r.adminId = v
0000000000000000000000000000000000000000;;			case "adminsecretname":
0000000000000000000000000000000000000000;;				adminSecretName = v
0000000000000000000000000000000000000000;;			case "adminsecretnamespace":
0000000000000000000000000000000000000000;;				adminSecretNamespace = v
0000000000000000000000000000000000000000;;			case "userid":
0000000000000000000000000000000000000000;;				r.Id = v
0000000000000000000000000000000000000000;;			case "pool":
0000000000000000000000000000000000000000;;				r.Pool = v
0000000000000000000000000000000000000000;;			case "usersecretname":
0000000000000000000000000000000000000000;;				secretName = v
0000000000000000000000000000000000000000;;			case "imageformat":
0000000000000000000000000000000000000000;;				imageFormat = v
0000000000000000000000000000000000000000;;			case "imagefeatures":
0000000000000000000000000000000000000000;;				arr := dstrings.Split(v, ",")
0000000000000000000000000000000000000000;;				for _, f := range arr {
0000000000000000000000000000000000000000;;					if !supportedFeatures.Has(f) {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("invalid feature %q for volume plugin %s, supported features are: %v", f, r.plugin.GetPluginName(), supportedFeatures)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						r.imageFeatures = append(r.imageFeatures, f)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid option %q for volume plugin %s", k, r.plugin.GetPluginName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// sanity check
0000000000000000000000000000000000000000;;		if imageFormat != rbdImageFormat1 && imageFormat != rbdImageFormat2 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid ceph imageformat %s, expecting %s or %s",
0000000000000000000000000000000000000000;;				imageFormat, rbdImageFormat1, rbdImageFormat2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.imageFormat = imageFormat
0000000000000000000000000000000000000000;;		if adminSecretName == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing Ceph admin secret name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if secret, err = parsePVSecret(adminSecretNamespace, adminSecretName, r.plugin.host.GetKubeClient()); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get admin secret from [%q/%q]: %v", adminSecretNamespace, adminSecretName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.adminSecret = secret
0000000000000000000000000000000000000000;;		if len(r.Mon) < 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing Ceph monitors")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if secretName == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing user secret name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.adminId == "" {
0000000000000000000000000000000000000000;;			r.adminId = "admin"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Pool == "" {
0000000000000000000000000000000000000000;;			r.Pool = "rbd"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Id == "" {
0000000000000000000000000000000000000000;;			r.Id = r.adminId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create random image name
0000000000000000000000000000000000000000;;		image := fmt.Sprintf("kubernetes-dynamic-pvc-%s", uuid.NewUUID())
0000000000000000000000000000000000000000;;		r.rbdMounter.Image = image
0000000000000000000000000000000000000000;;		rbd, sizeMB, err := r.manager.CreateImage(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("rbd: create volume failed, err: %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("successfully created rbd image %q", image)
0000000000000000000000000000000000000000;;		pv := new(v1.PersistentVolume)
0000000000000000000000000000000000000000;;		metav1.SetMetaDataAnnotation(&pv.ObjectMeta, volumehelper.VolumeDynamicallyCreatedByKey, "rbd-dynamic-provisioner")
0000000000000000000000000000000000000000;;		rbd.SecretRef = new(v1.LocalObjectReference)
0000000000000000000000000000000000000000;;		rbd.SecretRef.Name = secretName
0000000000000000000000000000000000000000;;		rbd.RadosUser = r.Id
0000000000000000000000000000000000000000;;		pv.Spec.PersistentVolumeSource.RBD = rbd
0000000000000000000000000000000000000000;;		pv.Spec.PersistentVolumeReclaimPolicy = r.options.PersistentVolumeReclaimPolicy
0000000000000000000000000000000000000000;;		pv.Spec.AccessModes = r.options.PVC.Spec.AccessModes
0000000000000000000000000000000000000000;;		if len(pv.Spec.AccessModes) == 0 {
0000000000000000000000000000000000000000;;			pv.Spec.AccessModes = r.plugin.GetAccessModes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pv.Spec.Capacity = v1.ResourceList{
0000000000000000000000000000000000000000;;			v1.ResourceName(v1.ResourceStorage): resource.MustParse(fmt.Sprintf("%dMi", sizeMB)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rbdVolumeDeleter struct {
0000000000000000000000000000000000000000;;		*rbdMounter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rbdVolumeDeleter) GetPath() string {
0000000000000000000000000000000000000000;;		name := rbdPluginName
0000000000000000000000000000000000000000;;		return r.plugin.host.GetPodVolumeDir(r.podUID, strings.EscapeQualifiedNameForDisk(name), r.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rbdVolumeDeleter) Delete() error {
0000000000000000000000000000000000000000;;		return r.manager.DeleteImage(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rbd struct {
0000000000000000000000000000000000000000;;		volName  string
0000000000000000000000000000000000000000;;		podUID   types.UID
0000000000000000000000000000000000000000;;		Pool     string
0000000000000000000000000000000000000000;;		Image    string
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;		plugin   *rbdPlugin
0000000000000000000000000000000000000000;;		mounter  *mount.SafeFormatAndMount
0000000000000000000000000000000000000000;;		// Utility interface that provides API calls to the provider to attach/detach disks.
0000000000000000000000000000000000000000;;		manager diskManager
0000000000000000000000000000000000000000;;		volume.MetricsNil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rbd *rbd) GetPath() string {
0000000000000000000000000000000000000000;;		name := rbdPluginName
0000000000000000000000000000000000000000;;		// safe to use PodVolumeDir now: volume teardown occurs before pod is cleaned up
0000000000000000000000000000000000000000;;		return rbd.plugin.host.GetPodVolumeDir(rbd.podUID, strings.EscapeQualifiedNameForDisk(name), rbd.volName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rbdMounter struct {
0000000000000000000000000000000000000000;;		*rbd
0000000000000000000000000000000000000000;;		// capitalized so they can be exported in persistRBD()
0000000000000000000000000000000000000000;;		Mon           []string
0000000000000000000000000000000000000000;;		Id            string
0000000000000000000000000000000000000000;;		Keyring       string
0000000000000000000000000000000000000000;;		Secret        string
0000000000000000000000000000000000000000;;		fsType        string
0000000000000000000000000000000000000000;;		adminSecret   string
0000000000000000000000000000000000000000;;		adminId       string
0000000000000000000000000000000000000000;;		mountOptions  []string
0000000000000000000000000000000000000000;;		imageFormat   string
0000000000000000000000000000000000000000;;		imageFeatures []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Mounter = &rbdMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *rbd) GetAttributes() volume.Attributes {
0000000000000000000000000000000000000000;;		return volume.Attributes{
0000000000000000000000000000000000000000;;			ReadOnly:        b.ReadOnly,
0000000000000000000000000000000000000000;;			Managed:         !b.ReadOnly,
0000000000000000000000000000000000000000;;			SupportsSELinux: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks prior to mount operations to verify that the required components (binaries, etc.)
0000000000000000000000000000000000000000;;	// to mount the volume are available on the underlying node.
0000000000000000000000000000000000000000;;	// If not, it returns an error
0000000000000000000000000000000000000000;;	func (b *rbdMounter) CanMount() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *rbdMounter) SetUp(fsGroup *int64) error {
0000000000000000000000000000000000000000;;		return b.SetUpAt(b.GetPath(), fsGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *rbdMounter) SetUpAt(dir string, fsGroup *int64) error {
0000000000000000000000000000000000000000;;		// diskSetUp checks mountpoints and prevent repeated calls
0000000000000000000000000000000000000000;;		glog.V(4).Infof("rbd: attempting to SetUp and mount %s", dir)
0000000000000000000000000000000000000000;;		err := diskSetUp(b.manager, *b, dir, b.mounter, fsGroup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("rbd: failed to setup mount %s %v", dir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rbdUnmounter struct {
0000000000000000000000000000000000000000;;		*rbdMounter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ volume.Unmounter = &rbdUnmounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmounts the bind mount, and detaches the disk only if the disk
0000000000000000000000000000000000000000;;	// resource was the last reference to that disk on the kubelet.
0000000000000000000000000000000000000000;;	func (c *rbdUnmounter) TearDown() error {
0000000000000000000000000000000000000000;;		return c.TearDownAt(c.GetPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rbdUnmounter) TearDownAt(dir string) error {
0000000000000000000000000000000000000000;;		if pathExists, pathErr := volutil.PathExists(dir); pathErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error checking if path exists: %v", pathErr)
0000000000000000000000000000000000000000;;		} else if !pathExists {
0000000000000000000000000000000000000000;;			glog.Warningf("Warning: Unmount skipped because path does not exist: %v", dir)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return diskTearDown(c.manager, *c, dir, c.mounter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (plugin *rbdPlugin) execCommand(command string, args []string) ([]byte, error) {
0000000000000000000000000000000000000000;;		cmd := plugin.exe.Command(command, args...)
0000000000000000000000000000000000000000;;		return cmd.CombinedOutput()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVolumeSource(
0000000000000000000000000000000000000000;;		spec *volume.Spec) (*v1.RBDVolumeSource, bool, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.RBD != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.RBD, spec.Volume.RBD.ReadOnly, nil
0000000000000000000000000000000000000000;;		} else if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.RBD != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.RBD, spec.ReadOnly, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("Spec does not reference a RBD volume type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePodSecret(pod *v1.Pod, secretName string, kubeClient clientset.Interface) (string, error) {
0000000000000000000000000000000000000000;;		secret, err := volutil.GetSecretForPod(pod, secretName, kubeClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to get secret from [%q/%q]", pod.Namespace, secretName)
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get secret from [%q/%q]", pod.Namespace, secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseSecretMap(secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePVSecret(namespace, secretName string, kubeClient clientset.Interface) (string, error) {
0000000000000000000000000000000000000000;;		secret, err := volutil.GetSecretForPV(namespace, secretName, rbdPluginName, kubeClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to get secret from [%q/%q]", namespace, secretName)
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to get secret from [%q/%q]", namespace, secretName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseSecretMap(secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseSecretMap locates the secret by key name.
0000000000000000000000000000000000000000;;	func parseSecretMap(secretMap map[string]string) (string, error) {
0000000000000000000000000000000000000000;;		if len(secretMap) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("empty secret map")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		secret := ""
0000000000000000000000000000000000000000;;		for k, v := range secretMap {
0000000000000000000000000000000000000000;;			if k == secretKeyName {
0000000000000000000000000000000000000000;;				return v, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			secret = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If not found, the last secret in the map wins as done before
0000000000000000000000000000000000000000;;		return secret, nil
0000000000000000000000000000000000000000;;	}
