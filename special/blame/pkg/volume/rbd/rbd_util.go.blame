0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
27eb00d606d55ee7423c57499e0422b4888f0962;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// utility functions to setup rbd volume
0000000000000000000000000000000000000000;;	// mainly implement diskManager interface
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rbd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/exec"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		imageWatcherStr = "watcher="
0000000000000000000000000000000000000000;;		kubeLockMagic   = "kubelet_lock_magic_"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// search /sys/bus for rbd device that matches given pool and image
0000000000000000000000000000000000000000;;	func getDevFromImageAndPool(pool, image string) (string, bool) {
0000000000000000000000000000000000000000;;		// /sys/bus/rbd/devices/X/name and /sys/bus/rbd/devices/X/pool
0000000000000000000000000000000000000000;;		sys_path := "/sys/bus/rbd/devices"
0000000000000000000000000000000000000000;;		if dirs, err := ioutil.ReadDir(sys_path); err == nil {
0000000000000000000000000000000000000000;;			for _, f := range dirs {
0000000000000000000000000000000000000000;;				// pool and name format:
0000000000000000000000000000000000000000;;				// see rbd_pool_show() and rbd_name_show() at
0000000000000000000000000000000000000000;;				// https://github.com/torvalds/linux/blob/master/drivers/block/rbd.c
0000000000000000000000000000000000000000;;				name := f.Name()
0000000000000000000000000000000000000000;;				// first match pool, then match name
0000000000000000000000000000000000000000;;				po := path.Join(sys_path, name, "pool")
0000000000000000000000000000000000000000;;				img := path.Join(sys_path, name, "name")
0000000000000000000000000000000000000000;;				exe := exec.New()
0000000000000000000000000000000000000000;;				out, err := exe.Command("cat", po, img).CombinedOutput()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				matched, err := regexp.MatchString("^"+pool+"\n"+image+"\n$", string(out))
0000000000000000000000000000000000000000;;				if err != nil || !matched {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// found a match, check if device exists
0000000000000000000000000000000000000000;;				devicePath := "/dev/rbd" + name
0000000000000000000000000000000000000000;;				if _, err := os.Lstat(devicePath); err == nil {
0000000000000000000000000000000000000000;;					return devicePath, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stat a path, if not exists, retry maxRetries times
0000000000000000000000000000000000000000;;	func waitForPath(pool, image string, maxRetries int) (string, bool) {
0000000000000000000000000000000000000000;;		for i := 0; i < maxRetries; i++ {
0000000000000000000000000000000000000000;;			devicePath, found := getDevFromImageAndPool(pool, image)
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				return devicePath, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == maxRetries-1 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// make a directory like /var/lib/kubelet/plugins/kubernetes.io/pod/rbd/pool-image-image
0000000000000000000000000000000000000000;;	func makePDNameInternal(host volume.VolumeHost, pool string, image string) string {
0000000000000000000000000000000000000000;;		return path.Join(host.GetPluginDir(rbdPluginName), "rbd", pool+"-image-"+image)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RBDUtil struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) MakeGlobalPDName(rbd rbd) string {
0000000000000000000000000000000000000000;;		return makePDNameInternal(rbd.plugin.host, rbd.Pool, rbd.Image)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) rbdLock(b rbdMounter, lock bool) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var output, locker string
0000000000000000000000000000000000000000;;		var cmd []byte
0000000000000000000000000000000000000000;;		var secret_opt []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b.Secret != "" {
0000000000000000000000000000000000000000;;			secret_opt = []string{"--key=" + b.Secret}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			secret_opt = []string{"-k", b.Keyring}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.adminId) == 0 {
0000000000000000000000000000000000000000;;			b.adminId = b.Id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.adminSecret) == 0 {
0000000000000000000000000000000000000000;;			b.adminSecret = b.Secret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// construct lock id using host name and a magic prefix
0000000000000000000000000000000000000000;;		lock_id := kubeLockMagic + node.GetHostname("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := len(b.Mon)
0000000000000000000000000000000000000000;;		// avoid mount storm, pick a host randomly
0000000000000000000000000000000000000000;;		start := rand.Int() % l
0000000000000000000000000000000000000000;;		// iterate all hosts until mount succeeds.
0000000000000000000000000000000000000000;;		for i := start; i < start+l; i++ {
0000000000000000000000000000000000000000;;			mon := b.Mon[i%l]
0000000000000000000000000000000000000000;;			// cmd "rbd lock list" serves two purposes:
0000000000000000000000000000000000000000;;			// for fencing, check if lock already held for this host
0000000000000000000000000000000000000000;;			// this edge case happens if host crashes in the middle of acquiring lock and mounting rbd
0000000000000000000000000000000000000000;;			// for defencing, get the locker name, something like "client.1234"
0000000000000000000000000000000000000000;;			cmd, err = b.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;				append([]string{"lock", "list", b.Image, "--pool", b.Pool, "--id", b.Id, "-m", mon}, secret_opt...))
0000000000000000000000000000000000000000;;			output = string(cmd)
0000000000000000000000000000000000000000;;			glog.Infof("lock list output %q", output)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if lock {
0000000000000000000000000000000000000000;;				// check if lock is already held for this host by matching lock_id and rbd lock id
0000000000000000000000000000000000000000;;				if strings.Contains(output, lock_id) {
0000000000000000000000000000000000000000;;					// this host already holds the lock, exit
0000000000000000000000000000000000000000;;					glog.V(1).Infof("rbd: lock already held for %s", lock_id)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// clean up orphaned lock if no watcher on the image
0000000000000000000000000000000000000000;;				used, statusErr := util.rbdStatus(&b)
0000000000000000000000000000000000000000;;				if statusErr == nil && !used {
0000000000000000000000000000000000000000;;					re := regexp.MustCompile("client.* " + kubeLockMagic + ".*")
0000000000000000000000000000000000000000;;					locks := re.FindAllStringSubmatch(output, -1)
0000000000000000000000000000000000000000;;					for _, v := range locks {
0000000000000000000000000000000000000000;;						if len(v) > 0 {
0000000000000000000000000000000000000000;;							lockInfo := strings.Split(v[0], " ")
0000000000000000000000000000000000000000;;							if len(lockInfo) > 2 {
0000000000000000000000000000000000000000;;								cmd, err = b.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;									append([]string{"lock", "remove", b.Image, lockInfo[1], lockInfo[0], "--pool", b.Pool, "--id", b.Id, "-m", mon}, secret_opt...))
0000000000000000000000000000000000000000;;								glog.Infof("remove orphaned locker %s from client %s: err %v, output: %s", lockInfo[1], lockInfo[0], err, string(cmd))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// hold a lock: rbd lock add
0000000000000000000000000000000000000000;;				cmd, err = b.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;					append([]string{"lock", "add", b.Image, lock_id, "--pool", b.Pool, "--id", b.Id, "-m", mon}, secret_opt...))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// defencing, find locker name
0000000000000000000000000000000000000000;;				ind := strings.LastIndex(output, lock_id) - 1
0000000000000000000000000000000000000000;;				for i := ind; i >= 0; i-- {
0000000000000000000000000000000000000000;;					if output[i] == '\n' {
0000000000000000000000000000000000000000;;						locker = output[(i + 1):ind]
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// remove a lock: rbd lock remove
0000000000000000000000000000000000000000;;				cmd, err = b.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;					append([]string{"lock", "remove", b.Image, lock_id, locker, "--pool", b.Pool, "--id", b.Id, "-m", mon}, secret_opt...))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				//lock is acquired
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) persistRBD(rbd rbdMounter, mnt string) error {
0000000000000000000000000000000000000000;;		file := path.Join(mnt, "rbd.json")
0000000000000000000000000000000000000000;;		fp, err := os.Create(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd: create err %s/%s", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer fp.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoder := json.NewEncoder(fp)
0000000000000000000000000000000000000000;;		if err = encoder.Encode(rbd); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd: encode err: %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) loadRBD(mounter *rbdMounter, mnt string) error {
0000000000000000000000000000000000000000;;		file := path.Join(mnt, "rbd.json")
0000000000000000000000000000000000000000;;		fp, err := os.Open(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd: open err %s/%s", file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer fp.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(fp)
0000000000000000000000000000000000000000;;		if err = decoder.Decode(mounter); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd: decode err: %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) fencing(b rbdMounter) error {
0000000000000000000000000000000000000000;;		// no need to fence readOnly
0000000000000000000000000000000000000000;;		if (&b).GetAttributes().ReadOnly {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return util.rbdLock(b, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) defencing(c rbdUnmounter) error {
0000000000000000000000000000000000000000;;		// no need to fence readOnly
0000000000000000000000000000000000000000;;		if c.ReadOnly {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return util.rbdLock(*c.rbdMounter, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) AttachDisk(b rbdMounter) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var output []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create mount point
0000000000000000000000000000000000000000;;		globalPDPath := b.manager.MakeGlobalPDName(*b.rbd)
0000000000000000000000000000000000000000;;		notMnt, err := b.mounter.IsLikelyNotMountPoint(globalPDPath)
0000000000000000000000000000000000000000;;		// in the first time, the path shouldn't exist and IsLikelyNotMountPoint is expected to get NotExist
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd: %s failed to check mountpoint", globalPDPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !notMnt {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = os.MkdirAll(globalPDPath, 0750); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd: failed to mkdir %s, error", globalPDPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		devicePath, found := waitForPath(b.Pool, b.Image, 1)
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			// modprobe
0000000000000000000000000000000000000000;;			_, err = b.plugin.execCommand("modprobe", []string{"rbd"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("rbd: failed to load rbd kernel module:%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// fence off other mappers
0000000000000000000000000000000000000000;;			if err = util.fencing(b); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("rbd: failed to lock image %s (maybe locked by other nodes), error %v", b.Image, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// rbd lock remove needs ceph and image config
0000000000000000000000000000000000000000;;			// but kubelet doesn't get them from apiserver during teardown
0000000000000000000000000000000000000000;;			// so persit rbd config so upon disk detach, rbd lock can be removed
0000000000000000000000000000000000000000;;			// since rbd json is persisted in the same local directory that is used as rbd mountpoint later,
0000000000000000000000000000000000000000;;			// the json file remains invisible during rbd mount and thus won't be removed accidentally.
0000000000000000000000000000000000000000;;			util.persistRBD(b, globalPDPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// rbd map
0000000000000000000000000000000000000000;;			l := len(b.Mon)
0000000000000000000000000000000000000000;;			// avoid mount storm, pick a host randomly
0000000000000000000000000000000000000000;;			start := rand.Int() % l
0000000000000000000000000000000000000000;;			// iterate all hosts until mount succeeds.
0000000000000000000000000000000000000000;;			for i := start; i < start+l; i++ {
0000000000000000000000000000000000000000;;				mon := b.Mon[i%l]
0000000000000000000000000000000000000000;;				glog.V(1).Infof("rbd: map mon %s", mon)
0000000000000000000000000000000000000000;;				if b.Secret != "" {
0000000000000000000000000000000000000000;;					output, err = b.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;						[]string{"map", b.Image, "--pool", b.Pool, "--id", b.Id, "-m", mon, "--key=" + b.Secret})
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					output, err = b.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;						[]string{"map", b.Image, "--pool", b.Pool, "--id", b.Id, "-m", mon, "-k", b.Keyring})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(1).Infof("rbd: map error %v %s", err, string(output))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("rbd: map failed %v %s", err, string(output))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			devicePath, found = waitForPath(b.Pool, b.Image, 10)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return errors.New("Could not map image: Timeout after 10s")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mount it
0000000000000000000000000000000000000000;;		if err = b.mounter.FormatAndMount(devicePath, globalPDPath, b.fsType, nil); err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("rbd: failed to mount rbd volume %s [%s] to %s, error %v", devicePath, b.fsType, globalPDPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) DetachDisk(c rbdUnmounter, mntPath string) error {
0000000000000000000000000000000000000000;;		device, cnt, err := mount.GetDeviceNameFromMount(c.mounter, mntPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd detach disk: failed to get device from mnt: %s\nError: %v", mntPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = c.mounter.Unmount(mntPath); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd detach disk: failed to umount: %s\nError: %v", mntPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if device is no longer used, see if can unmap
0000000000000000000000000000000000000000;;		if cnt <= 1 {
0000000000000000000000000000000000000000;;			// rbd unmap
0000000000000000000000000000000000000000;;			_, err = c.plugin.execCommand("rbd", []string{"unmap", device})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("rbd: failed to unmap device %s:Error: %v", device, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// load ceph and image/pool info to remove fencing
0000000000000000000000000000000000000000;;			if err := util.loadRBD(c.rbdMounter, mntPath); err == nil {
0000000000000000000000000000000000000000;;				// remove rbd lock
0000000000000000000000000000000000000000;;				util.defencing(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.Infof("rbd: successfully unmap device %s", device)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) CreateImage(p *rbdVolumeProvisioner) (r *v1.RBDVolumeSource, size int, err error) {
0000000000000000000000000000000000000000;;		var output []byte
0000000000000000000000000000000000000000;;		capacity := p.options.PVC.Spec.Resources.Requests[v1.ResourceName(v1.ResourceStorage)]
0000000000000000000000000000000000000000;;		volSizeBytes := capacity.Value()
0000000000000000000000000000000000000000;;		// convert to MB that rbd defaults on
0000000000000000000000000000000000000000;;		sz := int(volume.RoundUpSize(volSizeBytes, 1024*1024))
0000000000000000000000000000000000000000;;		volSz := fmt.Sprintf("%d", sz)
0000000000000000000000000000000000000000;;		// rbd create
0000000000000000000000000000000000000000;;		l := len(p.rbdMounter.Mon)
0000000000000000000000000000000000000000;;		// pick a mon randomly
0000000000000000000000000000000000000000;;		start := rand.Int() % l
0000000000000000000000000000000000000000;;		// iterate all monitors until create succeeds.
0000000000000000000000000000000000000000;;		for i := start; i < start+l; i++ {
0000000000000000000000000000000000000000;;			mon := p.Mon[i%l]
0000000000000000000000000000000000000000;;			if p.rbdMounter.imageFormat == rbdImageFormat2 {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("rbd: create %s size %s format %s (features: %s) using mon %s, pool %s id %s key %s", p.rbdMounter.Image, volSz, p.rbdMounter.imageFormat, p.rbdMounter.imageFeatures, mon, p.rbdMounter.Pool, p.rbdMounter.adminId, p.rbdMounter.adminSecret)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("rbd: create %s size %s format %s using mon %s, pool %s id %s key %s", p.rbdMounter.Image, volSz, p.rbdMounter.imageFormat, mon, p.rbdMounter.Pool, p.rbdMounter.adminId, p.rbdMounter.adminSecret)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			args := []string{"create", p.rbdMounter.Image, "--size", volSz, "--pool", p.rbdMounter.Pool, "--id", p.rbdMounter.adminId, "-m", mon, "--key=" + p.rbdMounter.adminSecret, "--image-format", p.rbdMounter.imageFormat}
0000000000000000000000000000000000000000;;			if p.rbdMounter.imageFormat == rbdImageFormat2 {
0000000000000000000000000000000000000000;;				// if no image features is provided, it results in empty string
0000000000000000000000000000000000000000;;				// which disable all RBD image format 2 features as we expected
0000000000000000000000000000000000000000;;				features := strings.Join(p.rbdMounter.imageFeatures, ",")
0000000000000000000000000000000000000000;;				args = append(args, "--image-feature", features)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			output, err = p.rbdMounter.plugin.execCommand("rbd", args)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Warningf("failed to create rbd image, output %v", string(output))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, fmt.Errorf("failed to create rbd image: %v, command output: %s", err, string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &v1.RBDVolumeSource{
0000000000000000000000000000000000000000;;			CephMonitors: p.rbdMounter.Mon,
0000000000000000000000000000000000000000;;			RBDImage:     p.rbdMounter.Image,
0000000000000000000000000000000000000000;;			RBDPool:      p.rbdMounter.Pool,
0000000000000000000000000000000000000000;;		}, sz, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (util *RBDUtil) DeleteImage(p *rbdVolumeDeleter) error {
0000000000000000000000000000000000000000;;		var output []byte
0000000000000000000000000000000000000000;;		found, err := util.rbdStatus(p.rbdMounter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			glog.Info("rbd is still being used ", p.rbdMounter.Image)
0000000000000000000000000000000000000000;;			return fmt.Errorf("rbd %s is still being used", p.rbdMounter.Image)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// rbd rm
0000000000000000000000000000000000000000;;		l := len(p.rbdMounter.Mon)
0000000000000000000000000000000000000000;;		// pick a mon randomly
0000000000000000000000000000000000000000;;		start := rand.Int() % l
0000000000000000000000000000000000000000;;		// iterate all monitors until rm succeeds.
0000000000000000000000000000000000000000;;		for i := start; i < start+l; i++ {
0000000000000000000000000000000000000000;;			mon := p.rbdMounter.Mon[i%l]
0000000000000000000000000000000000000000;;			glog.V(4).Infof("rbd: rm %s using mon %s, pool %s id %s key %s", p.rbdMounter.Image, mon, p.rbdMounter.Pool, p.rbdMounter.adminId, p.rbdMounter.adminSecret)
0000000000000000000000000000000000000000;;			output, err = p.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;				[]string{"rm", p.rbdMounter.Image, "--pool", p.rbdMounter.Pool, "--id", p.rbdMounter.adminId, "-m", mon, "--key=" + p.rbdMounter.adminSecret})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Errorf("failed to delete rbd image: %v, command output: %s", err, string(output))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// run rbd status command to check if there is watcher on the image
0000000000000000000000000000000000000000;;	func (util *RBDUtil) rbdStatus(b *rbdMounter) (bool, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var output string
0000000000000000000000000000000000000000;;		var cmd []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := len(b.Mon)
0000000000000000000000000000000000000000;;		start := rand.Int() % l
0000000000000000000000000000000000000000;;		// iterate all hosts until mount succeeds.
0000000000000000000000000000000000000000;;		for i := start; i < start+l; i++ {
0000000000000000000000000000000000000000;;			mon := b.Mon[i%l]
0000000000000000000000000000000000000000;;			// cmd "rbd status" list the rbd client watch with the following output:
0000000000000000000000000000000000000000;;			// Watchers:
0000000000000000000000000000000000000000;;			//   watcher=10.16.153.105:0/710245699 client.14163 cookie=1
0000000000000000000000000000000000000000;;			glog.V(4).Infof("rbd: status %s using mon %s, pool %s id %s key %s", b.Image, mon, b.Pool, b.adminId, b.adminSecret)
0000000000000000000000000000000000000000;;			cmd, err = b.plugin.execCommand("rbd",
0000000000000000000000000000000000000000;;				[]string{"status", b.Image, "--pool", b.Pool, "-m", mon, "--id", b.adminId, "--key=" + b.adminSecret})
0000000000000000000000000000000000000000;;			output = string(cmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// ignore error code, just checkout output for watcher string
0000000000000000000000000000000000000000;;				glog.Warningf("failed to execute rbd status on mon %s", mon)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.Contains(output, imageWatcherStr) {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("rbd: watchers on %s: %s", b.Image, output)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Warningf("rbd: no watchers on %s", b.Image)
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
