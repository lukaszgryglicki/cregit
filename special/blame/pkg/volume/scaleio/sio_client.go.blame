0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
035d8c1abe71a2fddb25ce05367578ce9dfeca59;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scaleio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sio "github.com/codedellemc/goscaleio"
0000000000000000000000000000000000000000;;		siotypes "github.com/codedellemc/goscaleio/types/v1"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		sioDiskIDPath = "/dev/disk/by-id"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sioVolumeID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sioInterface interface {
0000000000000000000000000000000000000000;;		FindVolume(name string) (*siotypes.Volume, error)
0000000000000000000000000000000000000000;;		Volume(sioVolumeID) (*siotypes.Volume, error)
0000000000000000000000000000000000000000;;		CreateVolume(name string, sizeGB int64) (*siotypes.Volume, error)
0000000000000000000000000000000000000000;;		AttachVolume(sioVolumeID) error
0000000000000000000000000000000000000000;;		DetachVolume(sioVolumeID) error
0000000000000000000000000000000000000000;;		DeleteVolume(sioVolumeID) error
0000000000000000000000000000000000000000;;		IID() (string, error)
0000000000000000000000000000000000000000;;		Devs() (map[string]string, error)
0000000000000000000000000000000000000000;;		WaitForAttachedDevice(token string) (string, error)
0000000000000000000000000000000000000000;;		WaitForDetachedDevice(token string) error
0000000000000000000000000000000000000000;;		GetVolumeRefs(sioVolumeID) (int, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sioClient struct {
0000000000000000000000000000000000000000;;		client           *sio.Client
0000000000000000000000000000000000000000;;		gateway          string
0000000000000000000000000000000000000000;;		username         string
0000000000000000000000000000000000000000;;		password         string
0000000000000000000000000000000000000000;;		insecure         bool
0000000000000000000000000000000000000000;;		certsEnabled     bool
0000000000000000000000000000000000000000;;		system           *siotypes.System
0000000000000000000000000000000000000000;;		sysName          string
0000000000000000000000000000000000000000;;		sysClient        *sio.System
0000000000000000000000000000000000000000;;		protectionDomain *siotypes.ProtectionDomain
0000000000000000000000000000000000000000;;		pdName           string
0000000000000000000000000000000000000000;;		pdClient         *sio.ProtectionDomain
0000000000000000000000000000000000000000;;		storagePool      *siotypes.StoragePool
0000000000000000000000000000000000000000;;		spName           string
0000000000000000000000000000000000000000;;		spClient         *sio.StoragePool
0000000000000000000000000000000000000000;;		provisionMode    string
0000000000000000000000000000000000000000;;		sdcPath          string
0000000000000000000000000000000000000000;;		instanceID       string
0000000000000000000000000000000000000000;;		inited           bool
0000000000000000000000000000000000000000;;		diskRegex        *regexp.Regexp
0000000000000000000000000000000000000000;;		mtx              sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSioClient(gateway, username, password string, sslEnabled bool) (*sioClient, error) {
0000000000000000000000000000000000000000;;		client := new(sioClient)
0000000000000000000000000000000000000000;;		client.gateway = gateway
0000000000000000000000000000000000000000;;		client.username = username
0000000000000000000000000000000000000000;;		client.password = password
0000000000000000000000000000000000000000;;		if sslEnabled {
0000000000000000000000000000000000000000;;			client.insecure = false
0000000000000000000000000000000000000000;;			client.certsEnabled = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			client.insecure = true
0000000000000000000000000000000000000000;;			client.certsEnabled = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, err := regexp.Compile(`^emc-vol-\w*-\w*$`)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to compile regex: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client.diskRegex = r
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delay client setup/login until init()
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init setups client and authenticate
0000000000000000000000000000000000000000;;	func (c *sioClient) init() error {
0000000000000000000000000000000000000000;;		c.mtx.Lock()
0000000000000000000000000000000000000000;;		defer c.mtx.Unlock()
0000000000000000000000000000000000000000;;		if c.inited {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infoln(log("initializing scaleio client"))
0000000000000000000000000000000000000000;;		client, err := sio.NewClientWithArgs(c.gateway, "", c.insecure, c.certsEnabled)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to create client: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.client = client
0000000000000000000000000000000000000000;;		if _, err = c.client.Authenticate(
0000000000000000000000000000000000000000;;			&sio.ConfigConnect{
0000000000000000000000000000000000000000;;				Endpoint: c.gateway,
0000000000000000000000000000000000000000;;				Version:  "",
0000000000000000000000000000000000000000;;				Username: c.username,
0000000000000000000000000000000000000000;;				Password: c.password},
0000000000000000000000000000000000000000;;		); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("client authentication failed: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve system
0000000000000000000000000000000000000000;;		if c.system, err = c.findSystem(c.sysName); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("unable to find system %s: %v", c.sysName, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve protection domain
0000000000000000000000000000000000000000;;		if c.protectionDomain, err = c.findProtectionDomain(c.pdName); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("unable to find protection domain %s: %v", c.protectionDomain, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// retrieve storage pool
0000000000000000000000000000000000000000;;		if c.storagePool, err = c.findStoragePool(c.spName); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("unable to find storage pool %s: %v", c.storagePool, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.inited = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) Volumes() ([]*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vols, err := c.getVolumes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to retrieve volumes: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vols, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) Volume(id sioVolumeID) (*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vols, err := c.getVolumesByID(id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to retrieve volume by id: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vol := vols[0]
0000000000000000000000000000000000000000;;		if vol == nil {
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("volume not found, id %s", id))
0000000000000000000000000000000000000000;;			return nil, errors.New("volume not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vol, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) FindVolume(name string) (*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("searching for volume %s", name))
0000000000000000000000000000000000000000;;		volumes, err := c.getVolumesByName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to find volume by name %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, volume := range volumes {
0000000000000000000000000000000000000000;;			if volume.Name == name {
0000000000000000000000000000000000000000;;				glog.V(4).Info(log("found volume %s", name))
0000000000000000000000000000000000000000;;				return volume, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("volume not found, name %s", name))
0000000000000000000000000000000000000000;;		return nil, errors.New("volume not found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) CreateVolume(name string, sizeGB int64) (*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := &siotypes.VolumeParam{
0000000000000000000000000000000000000000;;			Name:           name,
0000000000000000000000000000000000000000;;			VolumeSizeInKb: strconv.Itoa(int(sizeGB) * 1024 * 1024),
0000000000000000000000000000000000000000;;			VolumeType:     c.provisionMode,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createResponse, err := c.client.CreateVolume(params, c.storagePool.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to create volume %s: %v", name, err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.Volume(sioVolumeID(createResponse.ID))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachVolume maps the scaleio volume to an sdc node.
0000000000000000000000000000000000000000;;	func (c *sioClient) AttachVolume(id sioVolumeID) error {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to init'd client in attach volume: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iid, err := c.IID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to get instanceIID for attach volume: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := &siotypes.MapVolumeSdcParam{
0000000000000000000000000000000000000000;;			SdcID: iid,
0000000000000000000000000000000000000000;;			AllowMultipleMappings: "false",
0000000000000000000000000000000000000000;;			AllSdcs:               "",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volClient := sio.NewVolume(c.client)
0000000000000000000000000000000000000000;;		volClient.Volume = &siotypes.Volume{ID: string(id)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := volClient.MapVolumeSdc(params); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to attach volume id %s: %v", id, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("volume %s attached successfully", id))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetachVolume detaches the volume with specified id.
0000000000000000000000000000000000000000;;	func (c *sioClient) DetachVolume(id sioVolumeID) error {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iid, err := c.IID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := &siotypes.UnmapVolumeSdcParam{
0000000000000000000000000000000000000000;;			SdcID:                "",
0000000000000000000000000000000000000000;;			IgnoreScsiInitiators: "true",
0000000000000000000000000000000000000000;;			AllSdcs:              iid,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volClient := sio.NewVolume(c.client)
0000000000000000000000000000000000000000;;		volClient.Volume = &siotypes.Volume{ID: string(id)}
0000000000000000000000000000000000000000;;		if err := volClient.UnmapVolumeSdc(params); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteVolume deletes the volume with the specified id
0000000000000000000000000000000000000000;;	func (c *sioClient) DeleteVolume(id sioVolumeID) error {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := c.Volume(id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		volClient := sio.NewVolume(c.client)
0000000000000000000000000000000000000000;;		volClient.Volume = vol
0000000000000000000000000000000000000000;;		if err := volClient.RemoveVolume("ONLY_ME"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) IID() (string, error) {
0000000000000000000000000000000000000000;;		if err := c.init(); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.instanceID == "" {
0000000000000000000000000000000000000000;;			cmd := c.getSdcCmd()
0000000000000000000000000000000000000000;;			output, err := exec.Command(cmd, "--query_guid").Output()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("drv_cfg --query_guid failed: %v", err))
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			guid := strings.TrimSpace(string(output))
0000000000000000000000000000000000000000;;			sdc, err := c.sysClient.FindSdc("SdcGuid", guid)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("failed to get sdc info %s", err))
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.instanceID = sdc.Sdc.ID
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("got instanceID %s", c.instanceID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.instanceID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSioDiskPaths traverse local disk devices to retrieve device path
0000000000000000000000000000000000000000;;	// The path is extracted from /dev/disk/by-id; each sio device path has format:
0000000000000000000000000000000000000000;;	// emc-vol-<mdmID-volID> e.g.:
0000000000000000000000000000000000000000;;	// emc-vol-788d9efb0a8f20cb-a2b8419300000000
0000000000000000000000000000000000000000;;	func (c *sioClient) getSioDiskPaths() ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(sioDiskIDPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to ReadDir %s: %v", sioDiskIDPath, err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := []os.FileInfo{}
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			if c.diskRegex.MatchString(file.Name()) {
0000000000000000000000000000000000000000;;				result = append(result, file)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetVolumeRefs counts the number of references an SIO volume has a disk device.
0000000000000000000000000000000000000000;;	// This is useful in preventing premature detach.
0000000000000000000000000000000000000000;;	func (c *sioClient) GetVolumeRefs(volId sioVolumeID) (refs int, err error) {
0000000000000000000000000000000000000000;;		files, err := c.getSioDiskPaths()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			if strings.Contains(file.Name(), string(volId)) {
0000000000000000000000000000000000000000;;				refs++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Devs returns a map of local devices as map[<volume.id>]<deviceName>
0000000000000000000000000000000000000000;;	func (c *sioClient) Devs() (map[string]string, error) {
0000000000000000000000000000000000000000;;		volumeMap := make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// grab the sdc tool output
0000000000000000000000000000000000000000;;		out, err := exec.Command(c.getSdcCmd(), "--query_vols").Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("sdc --query_vols failed: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// --query_vols output is a heading followed by list of attached vols as follows:
0000000000000000000000000000000000000000;;		// Retrieve ? volume(s)
0000000000000000000000000000000000000000;;		// VOL-ID a2b8419300000000 MDM-ID 788d9efb0a8f20cb
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;		// parse output and store it in a map as  map[<mdmID-volID>]volID
0000000000000000000000000000000000000000;;		// that map is used later to retrieve device path (next section)
0000000000000000000000000000000000000000;;		result := string(out)
0000000000000000000000000000000000000000;;		mdmMap := make(map[string]string)
0000000000000000000000000000000000000000;;		lines := strings.Split(result, "\n")
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			//line e.g.: "VOL-ID a2b8419300000000 MDM-ID 788d9efb0a8f20cb"
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "VOL-ID") {
0000000000000000000000000000000000000000;;				//split[1] = volID; split[3] = mdmID
0000000000000000000000000000000000000000;;				split := strings.Split(line, " ")
0000000000000000000000000000000000000000;;				key := fmt.Sprintf("%s-%s", split[3], split[1])
0000000000000000000000000000000000000000;;				mdmMap[key] = split[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files, err := c.getSioDiskPaths()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			// remove emec-vol- prefix to be left with concated mdmID-volID
0000000000000000000000000000000000000000;;			mdmVolumeID := strings.Replace(f.Name(), "emc-vol-", "", 1)
0000000000000000000000000000000000000000;;			devPath, err := filepath.EvalSymlinks(fmt.Sprintf("%s/%s", sioDiskIDPath, f.Name()))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("devicepath-to-volID mapping error: %v", err))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// map volID to devicePath
0000000000000000000000000000000000000000;;			if volumeID, ok := mdmMap[mdmVolumeID]; ok {
0000000000000000000000000000000000000000;;				volumeMap[volumeID] = devPath
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumeMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForAttachedDevice sets up a timer to wait for an attached device to appear in the instance's list.
0000000000000000000000000000000000000000;;	func (c *sioClient) WaitForAttachedDevice(token string) (string, error) {
0000000000000000000000000000000000000000;;		if token == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid attach token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for device to  show up in local device list
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(time.Second)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		timer := time.NewTimer(30 * time.Second)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;				devMap, err := c.Devs()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Error(log("failed while waiting for volume to attach: %v", err))
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					glog.V(4).Infof(log("waiting for volume %s to be mapped/attached", token))
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				if path, ok := devMap[token]; ok {
0000000000000000000000000000000000000000;;					glog.V(4).Info(log("device %s mapped to vol %s", path, token))
0000000000000000000000000000000000000000;;					return path, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer.C:
0000000000000000000000000000000000000000;;				glog.Error(log("timed out while waiting for volume to be mapped to a device"))
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("volume attach timeout")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForDetachedDevice waits for device to be detached
0000000000000000000000000000000000000000;;	func (c *sioClient) WaitForDetachedDevice(token string) error {
0000000000000000000000000000000000000000;;		if token == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid detach token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for attach.Token to show up in local device list
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(time.Second)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		timer := time.NewTimer(30 * time.Second)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;				devMap, err := c.Devs()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Error(log("failed while waiting for volume to unmap/detach: %v", err))
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					glog.V(4).Infof(log("waiting for volume %s to be unmapped/detached", token))
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				// cant find vol id, then ok.
0000000000000000000000000000000000000000;;				if _, ok := devMap[token]; !ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-timer.C:
0000000000000000000000000000000000000000;;				glog.Error(log("timed out while waiting for volume %s to be unmapped/detached", token))
0000000000000000000000000000000000000000;;				return fmt.Errorf("volume detach timeout")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ***********************************************************************
0000000000000000000000000000000000000000;;	// Little Helpers!
0000000000000000000000000000000000000000;;	// ***********************************************************************
0000000000000000000000000000000000000000;;	func (c *sioClient) findSystem(sysname string) (sys *siotypes.System, err error) {
0000000000000000000000000000000000000000;;		if c.sysClient, err = c.client.FindSystem("", sysname, ""); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		systems, err := c.client.GetInstance("")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to retrieve instances: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, sys = range systems {
0000000000000000000000000000000000000000;;			if sys.Name == sysname {
0000000000000000000000000000000000000000;;				return sys, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Error(log("system %s not found", sysname))
0000000000000000000000000000000000000000;;		return nil, errors.New("system not found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) findProtectionDomain(pdname string) (*siotypes.ProtectionDomain, error) {
0000000000000000000000000000000000000000;;		c.pdClient = sio.NewProtectionDomain(c.client)
0000000000000000000000000000000000000000;;		if c.sysClient != nil {
0000000000000000000000000000000000000000;;			protectionDomain, err := c.sysClient.FindProtectionDomain("", pdname, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("failed to retrieve protection domains: %v", err))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.pdClient.ProtectionDomain = protectionDomain
0000000000000000000000000000000000000000;;			return protectionDomain, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Error(log("protection domain %s not set", pdname))
0000000000000000000000000000000000000000;;		return nil, errors.New("protection domain not set")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) findStoragePool(spname string) (*siotypes.StoragePool, error) {
0000000000000000000000000000000000000000;;		c.spClient = sio.NewStoragePool(c.client)
0000000000000000000000000000000000000000;;		if c.pdClient != nil {
0000000000000000000000000000000000000000;;			sp, err := c.pdClient.FindStoragePool("", spname, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("failed to retrieve storage pool: %v", err))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.spClient.StoragePool = sp
0000000000000000000000000000000000000000;;			return sp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Error(log("storage pool %s not set", spname))
0000000000000000000000000000000000000000;;		return nil, errors.New("storage pool not set")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) getVolumes() ([]*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		return c.client.GetVolume("", "", "", "", true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *sioClient) getVolumesByID(id sioVolumeID) ([]*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		return c.client.GetVolume("", string(id), "", "", true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) getVolumesByName(name string) ([]*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		return c.client.GetVolume("", "", "", name, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) getSdcPath() string {
0000000000000000000000000000000000000000;;		return sdcRootPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sioClient) getSdcCmd() string {
0000000000000000000000000000000000000000;;		return path.Join(c.getSdcPath(), "drv_cfg")
0000000000000000000000000000000000000000;;	}
