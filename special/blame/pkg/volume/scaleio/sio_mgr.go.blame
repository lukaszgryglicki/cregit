0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
035d8c1abe71a2fddb25ce05367578ce9dfeca59;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scaleio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		siotypes "github.com/codedellemc/goscaleio/types/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageInterface interface {
0000000000000000000000000000000000000000;;		CreateVolume(string, int64) (*siotypes.Volume, error)
0000000000000000000000000000000000000000;;		AttachVolume(string) (string, error)
0000000000000000000000000000000000000000;;		IsAttached(string) (bool, error)
0000000000000000000000000000000000000000;;		DetachVolume(string) error
0000000000000000000000000000000000000000;;		DeleteVolume(string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sioMgr struct {
0000000000000000000000000000000000000000;;		client     sioInterface
0000000000000000000000000000000000000000;;		configData map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSioMgr(configs map[string]string) (*sioMgr, error) {
0000000000000000000000000000000000000000;;		if configs == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("missing configuration data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		configs[confKey.protectionDomain] = defaultString(configs[confKey.protectionDomain], "default")
0000000000000000000000000000000000000000;;		configs[confKey.storagePool] = defaultString(configs[confKey.storagePool], "default")
0000000000000000000000000000000000000000;;		configs[confKey.sdcRootPath] = defaultString(configs[confKey.sdcRootPath], sdcRootPath)
0000000000000000000000000000000000000000;;		configs[confKey.storageMode] = defaultString(configs[confKey.storageMode], "ThinProvisioned")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mgr := &sioMgr{configData: configs}
0000000000000000000000000000000000000000;;		return mgr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getClient safely returns an sioInterface
0000000000000000000000000000000000000000;;	func (m *sioMgr) getClient() (sioInterface, error) {
0000000000000000000000000000000000000000;;		if m.client == nil {
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("creating scaleio client"))
0000000000000000000000000000000000000000;;			configs := m.configData
0000000000000000000000000000000000000000;;			username := configs[confKey.username]
0000000000000000000000000000000000000000;;			password := configs[confKey.password]
0000000000000000000000000000000000000000;;			gateway := configs[confKey.gateway]
0000000000000000000000000000000000000000;;			b, err := strconv.ParseBool(configs[confKey.sslEnabled])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("failed to parse sslEnabled, must be either \"true\" or \"false\""))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			certsEnabled := b
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("creating new client for gateway %s", gateway))
0000000000000000000000000000000000000000;;			client, err := newSioClient(gateway, username, password, certsEnabled)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("failed to create scaleio client: %v", err))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			client.sysName = configs[confKey.system]
0000000000000000000000000000000000000000;;			client.pdName = configs[confKey.protectionDomain]
0000000000000000000000000000000000000000;;			client.spName = configs[confKey.storagePool]
0000000000000000000000000000000000000000;;			client.sdcPath = configs[confKey.sdcRootPath]
0000000000000000000000000000000000000000;;			client.provisionMode = configs[confKey.storageMode]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			m.client = client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("client created successfully [gateway=%s]", gateway))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateVolume creates a new ScaleIO volume
0000000000000000000000000000000000000000;;	func (m *sioMgr) CreateVolume(volName string, sizeGB int64) (*siotypes.Volume, error) {
0000000000000000000000000000000000000000;;		client, err := m.getClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("scaleio: creating volume %s", volName)
0000000000000000000000000000000000000000;;		vol, err := client.CreateVolume(volName, sizeGB)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("scaleio: failed creating volume %s: %v", volName, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("scaleio: created volume %s successfully", volName)
0000000000000000000000000000000000000000;;		return vol, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachVolume maps a ScaleIO volume to the running node
0000000000000000000000000000000000000000;;	func (m *sioMgr) AttachVolume(volName string) (string, error) {
0000000000000000000000000000000000000000;;		client, err := m.getClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("attach volume failed: %v", err))
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infoln(log("attaching volume %s", volName))
0000000000000000000000000000000000000000;;		iid, err := client.IID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to get instanceID"))
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("attaching volume %s to host instance %s", volName, iid))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		devs, err := client.Devs()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := client.FindVolume(volName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to find volume %s: %v", volName, err))
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle vol if already attached
0000000000000000000000000000000000000000;;		if len(vol.MappedSdcInfo) > 0 {
0000000000000000000000000000000000000000;;			if m.isSdcMappedToVol(iid, vol) {
0000000000000000000000000000000000000000;;				glog.V(4).Info(log("skippping attachment, volume %s already attached to sdc %s", volName, iid))
0000000000000000000000000000000000000000;;				return devs[vol.ID], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attach volume, get deviceName
0000000000000000000000000000000000000000;;		if err := client.AttachVolume(sioVolumeID(vol.ID)); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("attachment for volume %s failed :%v", volName, err))
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		device, err := client.WaitForAttachedDevice(vol.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed while waiting for device to attach: %v", err))
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("volume %s attached successfully as %s to instance %s", volName, device, iid))
0000000000000000000000000000000000000000;;		return device, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAttached verifies that the named ScaleIO volume is still attached
0000000000000000000000000000000000000000;;	func (m *sioMgr) IsAttached(volName string) (bool, error) {
0000000000000000000000000000000000000000;;		client, err := m.getClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iid, err := client.IID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error("scaleio: failed to get instanceID")
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := client.FindVolume(volName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.isSdcMappedToVol(iid, vol), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetachVolume detaches the name ScaleIO volume from an instance
0000000000000000000000000000000000000000;;	func (m *sioMgr) DetachVolume(volName string) error {
0000000000000000000000000000000000000000;;		client, err := m.getClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iid, err := client.IID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to get instanceID: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := client.FindVolume(volName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !m.isSdcMappedToVol(iid, vol) {
0000000000000000000000000000000000000000;;			glog.Warning(log(
0000000000000000000000000000000000000000;;				"skipping detached, vol %s not attached to instance %s",
0000000000000000000000000000000000000000;;				volName, iid,
0000000000000000000000000000000000000000;;			))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := client.DetachVolume(sioVolumeID(vol.ID)); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to detach vol %s: %v", volName, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("volume %s detached successfully", volName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteVolumes removes the ScaleIO volume
0000000000000000000000000000000000000000;;	func (m *sioMgr) DeleteVolume(volName string) error {
0000000000000000000000000000000000000000;;		client, err := m.getClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iid, err := client.IID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to get instanceID: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := client.FindVolume(volName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if still attached, stop
0000000000000000000000000000000000000000;;		if m.isSdcMappedToVol(iid, vol) {
0000000000000000000000000000000000000000;;			glog.Error(log("volume %s still attached,  unable to delete", volName))
0000000000000000000000000000000000000000;;			return errors.New("volume still attached")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := client.DeleteVolume(sioVolumeID(vol.ID)); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to delete volume %s: %v", volName, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("deleted volume %s successfully", volName))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//*****************************************************************
0000000000000000000000000000000000000000;;	// Helpers
0000000000000000000000000000000000000000;;	//*****************************************************************
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSdcMappedToVol returns true if the sdc is mapped to the volume
0000000000000000000000000000000000000000;;	func (m *sioMgr) isSdcMappedToVol(sdcID string, vol *siotypes.Volume) bool {
0000000000000000000000000000000000000000;;		if len(vol.MappedSdcInfo) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("no attachment found"))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sdcInfo := range vol.MappedSdcInfo {
0000000000000000000000000000000000000000;;			if sdcInfo.SdcID == sdcID {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
