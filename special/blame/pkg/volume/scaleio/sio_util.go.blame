0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
035d8c1abe71a2fddb25ce05367578ce9dfeca59;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scaleio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/gob"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		api "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volutil "k8s.io/kubernetes/pkg/volume/util"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		confKey = struct {
0000000000000000000000000000000000000000;;			gateway,
0000000000000000000000000000000000000000;;			sslEnabled,
0000000000000000000000000000000000000000;;			secretRef,
0000000000000000000000000000000000000000;;			system,
0000000000000000000000000000000000000000;;			protectionDomain,
0000000000000000000000000000000000000000;;			storagePool,
0000000000000000000000000000000000000000;;			storageMode,
0000000000000000000000000000000000000000;;			sdcRootPath,
0000000000000000000000000000000000000000;;			volumeName,
0000000000000000000000000000000000000000;;			volSpecName,
0000000000000000000000000000000000000000;;			fsType,
0000000000000000000000000000000000000000;;			readOnly,
0000000000000000000000000000000000000000;;			username,
0000000000000000000000000000000000000000;;			password,
0000000000000000000000000000000000000000;;			namespace string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			gateway:          "gateway",
0000000000000000000000000000000000000000;;			sslEnabled:       "sslEnabled",
0000000000000000000000000000000000000000;;			secretRef:        "secretRef",
0000000000000000000000000000000000000000;;			system:           "system",
0000000000000000000000000000000000000000;;			protectionDomain: "protectionDomain",
0000000000000000000000000000000000000000;;			storagePool:      "storagePool",
0000000000000000000000000000000000000000;;			storageMode:      "storageMode",
0000000000000000000000000000000000000000;;			sdcRootPath:      "sdcRootPath",
0000000000000000000000000000000000000000;;			volumeName:       "volumeName",
0000000000000000000000000000000000000000;;			volSpecName:      "volSpecName",
0000000000000000000000000000000000000000;;			fsType:           "fsType",
0000000000000000000000000000000000000000;;			readOnly:         "readOnly",
0000000000000000000000000000000000000000;;			username:         "username",
0000000000000000000000000000000000000000;;			password:         "password",
0000000000000000000000000000000000000000;;			namespace:        "namespace",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nsSep       = "%"
0000000000000000000000000000000000000000;;		sdcRootPath = "/opt/emc/scaleio/sdc/bin"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secretNotFoundErr       = errors.New("secret not found")
0000000000000000000000000000000000000000;;		configMapNotFoundErr    = errors.New("configMap not found")
0000000000000000000000000000000000000000;;		gatewayNotProvidedErr   = errors.New("gateway not provided")
0000000000000000000000000000000000000000;;		secretRefNotProvidedErr = errors.New("secret ref not provided")
0000000000000000000000000000000000000000;;		systemNotProvidedErr    = errors.New("secret not provided")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapScaleIOVolumeSource maps attributes from a ScaleIOVolumeSource to config
0000000000000000000000000000000000000000;;	func mapVolumeSource(config map[string]string, source *api.ScaleIOVolumeSource) {
0000000000000000000000000000000000000000;;		config[confKey.gateway] = source.Gateway
0000000000000000000000000000000000000000;;		config[confKey.secretRef] = func() string {
0000000000000000000000000000000000000000;;			if source.SecretRef != nil {
0000000000000000000000000000000000000000;;				return string(source.SecretRef.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		config[confKey.system] = source.System
0000000000000000000000000000000000000000;;		config[confKey.volumeName] = source.VolumeName
0000000000000000000000000000000000000000;;		config[confKey.sslEnabled] = strconv.FormatBool(source.SSLEnabled)
0000000000000000000000000000000000000000;;		config[confKey.protectionDomain] = source.ProtectionDomain
0000000000000000000000000000000000000000;;		config[confKey.storagePool] = source.StoragePool
0000000000000000000000000000000000000000;;		config[confKey.storageMode] = source.StorageMode
0000000000000000000000000000000000000000;;		config[confKey.fsType] = source.FSType
0000000000000000000000000000000000000000;;		config[confKey.readOnly] = strconv.FormatBool(source.ReadOnly)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//optionals
0000000000000000000000000000000000000000;;		applyConfigDefaults(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateConfigs(config map[string]string) error {
0000000000000000000000000000000000000000;;		if config[confKey.gateway] == "" {
0000000000000000000000000000000000000000;;			return gatewayNotProvidedErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config[confKey.secretRef] == "" {
0000000000000000000000000000000000000000;;			return secretRefNotProvidedErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config[confKey.system] == "" {
0000000000000000000000000000000000000000;;			return systemNotProvidedErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyConfigDefaults apply known defaults to incoming spec for dynamic PVCs.
0000000000000000000000000000000000000000;;	func applyConfigDefaults(config map[string]string) {
0000000000000000000000000000000000000000;;		b, err := strconv.ParseBool(config[confKey.sslEnabled])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warning(log("failed to parse param sslEnabled, setting it to false"))
0000000000000000000000000000000000000000;;			b = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config[confKey.sslEnabled] = strconv.FormatBool(b)
0000000000000000000000000000000000000000;;		config[confKey.protectionDomain] = defaultString(config[confKey.protectionDomain], "default")
0000000000000000000000000000000000000000;;		config[confKey.storagePool] = defaultString(config[confKey.storagePool], "default")
0000000000000000000000000000000000000000;;		config[confKey.storageMode] = defaultString(config[confKey.storageMode], "ThinProvisioned")
0000000000000000000000000000000000000000;;		config[confKey.fsType] = defaultString(config[confKey.fsType], "xfs")
0000000000000000000000000000000000000000;;		b, err = strconv.ParseBool(config[confKey.readOnly])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warning(log("failed to parse param readOnly, setting it to false"))
0000000000000000000000000000000000000000;;			b = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config[confKey.readOnly] = strconv.FormatBool(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultString(val, defVal string) string {
0000000000000000000000000000000000000000;;		if val == "" {
0000000000000000000000000000000000000000;;			return defVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadConfig loads configuration data from a file on disk
0000000000000000000000000000000000000000;;	func loadConfig(configName string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("loading config file %s", configName))
0000000000000000000000000000000000000000;;		file, err := os.Open(configName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to open config file %s: %v", configName, err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		data := map[string]string{}
0000000000000000000000000000000000000000;;		if err := gob.NewDecoder(file).Decode(&data); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to parse config data %s: %v", configName, err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		applyConfigDefaults(data)
0000000000000000000000000000000000000000;;		if err := validateConfigs(data); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to load ConfigMap %s: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// saveConfig saves the configuration data to local disk
0000000000000000000000000000000000000000;;	func saveConfig(configName string, data map[string]string) error {
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("saving config file %s", configName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dir := path.Dir(configName)
0000000000000000000000000000000000000000;;		if _, err := os.Stat(dir); err != nil {
0000000000000000000000000000000000000000;;			if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("creating config dir for config data: %s", dir))
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(dir, 0750); err != nil {
0000000000000000000000000000000000000000;;				glog.Error(log("failed to create config data dir %v", err))
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := os.Create(configName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Info(log("failed to save config data file %s: %v", configName, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		if err := gob.NewEncoder(file).Encode(data); err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to save config %s: %v", configName, err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("config data file saved successfully as %s", configName))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// attachSecret loads secret object and attaches to configData
0000000000000000000000000000000000000000;;	func attachSecret(plug *sioPlugin, namespace string, configData map[string]string) error {
0000000000000000000000000000000000000000;;		// load secret
0000000000000000000000000000000000000000;;		secretRefName := configData[confKey.secretRef]
0000000000000000000000000000000000000000;;		kubeClient := plug.host.GetKubeClient()
0000000000000000000000000000000000000000;;		secretMap, err := volutil.GetSecretForPV(namespace, secretRefName, sioPluginName, kubeClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to get secret: %v", err))
0000000000000000000000000000000000000000;;			return secretNotFoundErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// merge secret data
0000000000000000000000000000000000000000;;		for key, val := range secretMap {
0000000000000000000000000000000000000000;;			configData[key] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getVolumeSourceFromSpec safely extracts ScaleIOVolumeSource from spec
0000000000000000000000000000000000000000;;	func getVolumeSourceFromSpec(spec *volume.Spec) (*api.ScaleIOVolumeSource, error) {
0000000000000000000000000000000000000000;;		if spec.Volume != nil && spec.Volume.ScaleIO != nil {
0000000000000000000000000000000000000000;;			return spec.Volume.ScaleIO, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if spec.PersistentVolume != nil &&
0000000000000000000000000000000000000000;;			spec.PersistentVolume.Spec.ScaleIO != nil {
0000000000000000000000000000000000000000;;			return spec.PersistentVolume.Spec.ScaleIO, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("ScaleIO not defined in spec")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func log(msg string, parts ...interface{}) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(fmt.Sprintf("scaleio: %s", msg), parts...)
0000000000000000000000000000000000000000;;	}
