0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
035d8c1abe71a2fddb25ce05367578ce9dfeca59;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scaleio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		api "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/keymutex"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		sioName           = "scaleio"
0000000000000000000000000000000000000000;;		sioPluginName     = "kubernetes.io/scaleio"
0000000000000000000000000000000000000000;;		sioConfigFileName = "sioconf.dat"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sioPlugin struct {
0000000000000000000000000000000000000000;;		host      volume.VolumeHost
0000000000000000000000000000000000000000;;		mounter   mount.Interface
0000000000000000000000000000000000000000;;		volumeMtx keymutex.KeyMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ProbeVolumePlugins() []volume.VolumePlugin {
0000000000000000000000000000000000000000;;		p := &sioPlugin{
0000000000000000000000000000000000000000;;			host: nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []volume.VolumePlugin{p}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// *******************
0000000000000000000000000000000000000000;;	// VolumePlugin Impl
0000000000000000000000000000000000000000;;	// *******************
0000000000000000000000000000000000000000;;	var _ volume.VolumePlugin = &sioPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) Init(host volume.VolumeHost) error {
0000000000000000000000000000000000000000;;		p.host = host
0000000000000000000000000000000000000000;;		p.mounter = host.GetMounter()
0000000000000000000000000000000000000000;;		p.volumeMtx = keymutex.NewKeyMutex()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) GetPluginName() string {
0000000000000000000000000000000000000000;;		return sioPluginName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) GetVolumeName(spec *volume.Spec) (string, error) {
0000000000000000000000000000000000000000;;		source, err := getVolumeSourceFromSpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return source.VolumeName, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) CanSupport(spec *volume.Spec) bool {
0000000000000000000000000000000000000000;;		return (spec.PersistentVolume != nil && spec.PersistentVolume.Spec.ScaleIO != nil) ||
0000000000000000000000000000000000000000;;			(spec.Volume != nil && spec.Volume.ScaleIO != nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) RequiresRemount() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) NewMounter(
0000000000000000000000000000000000000000;;		spec *volume.Spec,
0000000000000000000000000000000000000000;;		pod *api.Pod,
0000000000000000000000000000000000000000;;		_ volume.VolumeOptions) (volume.Mounter, error) {
0000000000000000000000000000000000000000;;		sioSource, err := getVolumeSourceFromSpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("failed to extract ScaleIOVolumeSource from spec: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &sioVolume{
0000000000000000000000000000000000000000;;			pod:         pod,
0000000000000000000000000000000000000000;;			spec:        spec,
0000000000000000000000000000000000000000;;			source:      sioSource,
0000000000000000000000000000000000000000;;			namespace:   pod.Namespace,
0000000000000000000000000000000000000000;;			volSpecName: spec.Name(),
0000000000000000000000000000000000000000;;			volName:     sioSource.VolumeName,
0000000000000000000000000000000000000000;;			podUID:      pod.UID,
0000000000000000000000000000000000000000;;			readOnly:    sioSource.ReadOnly,
0000000000000000000000000000000000000000;;			fsType:      sioSource.FSType,
0000000000000000000000000000000000000000;;			plugin:      p,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnmounter creates a representation of the volume to unmount
0000000000000000000000000000000000000000;;	// The specName param can be used to carry the namespace value (if needed) using format:
0000000000000000000000000000000000000000;;	// specName = [<namespace>nsSep]<somevalue> where the specname is pre-pended with the namespace
0000000000000000000000000000000000000000;;	func (p *sioPlugin) NewUnmounter(specName string, podUID types.UID) (volume.Unmounter, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("Unmounter for %s", specName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &sioVolume{
0000000000000000000000000000000000000000;;			podUID:      podUID,
0000000000000000000000000000000000000000;;			volSpecName: specName,
0000000000000000000000000000000000000000;;			plugin:      p,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) ConstructVolumeSpec(volumeName, mountPath string) (*volume.Spec, error) {
0000000000000000000000000000000000000000;;		sioVol := &api.Volume{
0000000000000000000000000000000000000000;;			Name: volumeName,
0000000000000000000000000000000000000000;;			VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;				ScaleIO: &api.ScaleIOVolumeSource{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volume.NewSpecFromVolume(sioVol), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportsMountOption returns true if volume plugins supports Mount options
0000000000000000000000000000000000000000;;	// Specifying mount options in a volume plugin that doesn't support
0000000000000000000000000000000000000000;;	// user specified mount options will result in error creating persistent volumes
0000000000000000000000000000000000000000;;	func (p *sioPlugin) SupportsMountOption() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportsBulkVolumeVerification checks if volume plugin type is capable
0000000000000000000000000000000000000000;;	// of enabling bulk polling of all nodes. This can speed up verification of
0000000000000000000000000000000000000000;;	// attached volumes by quite a bit, but underlying pluging must support it.
0000000000000000000000000000000000000000;;	func (p *sioPlugin) SupportsBulkVolumeVerification() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//******************************
0000000000000000000000000000000000000000;;	// PersistentVolumePlugin Impl
0000000000000000000000000000000000000000;;	// *****************************
0000000000000000000000000000000000000000;;	var _ volume.PersistentVolumePlugin = &sioPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) GetAccessModes() []api.PersistentVolumeAccessMode {
0000000000000000000000000000000000000000;;		return []api.PersistentVolumeAccessMode{
0000000000000000000000000000000000000000;;			api.ReadWriteOnce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ***************************
0000000000000000000000000000000000000000;;	// DeletableVolumePlugin Impl
0000000000000000000000000000000000000000;;	//****************************
0000000000000000000000000000000000000000;;	var _ volume.DeletableVolumePlugin = &sioPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) NewDeleter(spec *volume.Spec) (volume.Deleter, error) {
0000000000000000000000000000000000000000;;		sioSource, err := getVolumeSourceFromSpec(spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Error(log("deleter failed to extract source from spec: %v", err))
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace := spec.PersistentVolume.Spec.ClaimRef.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &sioVolume{
0000000000000000000000000000000000000000;;			spec:        spec,
0000000000000000000000000000000000000000;;			source:      sioSource,
0000000000000000000000000000000000000000;;			namespace:   namespace,
0000000000000000000000000000000000000000;;			volSpecName: spec.Name(),
0000000000000000000000000000000000000000;;			volName:     sioSource.VolumeName,
0000000000000000000000000000000000000000;;			plugin:      p,
0000000000000000000000000000000000000000;;			readOnly:    sioSource.ReadOnly,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// *********************************
0000000000000000000000000000000000000000;;	// ProvisionableVolumePlugin Impl
0000000000000000000000000000000000000000;;	// *********************************
0000000000000000000000000000000000000000;;	var _ volume.ProvisionableVolumePlugin = &sioPlugin{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sioPlugin) NewProvisioner(options volume.VolumeOptions) (volume.Provisioner, error) {
0000000000000000000000000000000000000000;;		glog.V(4).Info(log("creating Provisioner"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configData := options.Parameters
0000000000000000000000000000000000000000;;		if configData == nil {
0000000000000000000000000000000000000000;;			glog.Error(log("provisioner missing parameters, unable to continue"))
0000000000000000000000000000000000000000;;			return nil, errors.New("option parameters missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace := options.PVC.Namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &sioVolume{
0000000000000000000000000000000000000000;;			configData:  configData,
0000000000000000000000000000000000000000;;			plugin:      p,
0000000000000000000000000000000000000000;;			options:     options,
0000000000000000000000000000000000000000;;			namespace:   namespace,
0000000000000000000000000000000000000000;;			volSpecName: options.PVName,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
