0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
035d8c1abe71a2fddb25ce05367578ce9dfeca59;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package scaleio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		api "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		meta "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		utiltesting "k8s.io/client-go/util/testing"
0000000000000000000000000000000000000000;;		fakeclient "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/mount"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/volume"
0000000000000000000000000000000000000000;;		volumetest "k8s.io/kubernetes/pkg/volume/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		testSioSystem  = "sio"
0000000000000000000000000000000000000000;;		testSioPD      = "default"
0000000000000000000000000000000000000000;;		testSioVol     = "vol-0001"
0000000000000000000000000000000000000000;;		testns         = "default"
0000000000000000000000000000000000000000;;		testSioVolName = fmt.Sprintf("%s%s%s", testns, "-", testSioVol)
0000000000000000000000000000000000000000;;		podUID         = types.UID("sio-pod")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPluginMgr(t *testing.T) (*volume.VolumePluginMgr, string) {
0000000000000000000000000000000000000000;;		tmpDir, err := utiltesting.MkTmpdir("scaleio-test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("can't make a temp dir: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config := &api.Secret{
0000000000000000000000000000000000000000;;			ObjectMeta: meta.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "sio-secret",
0000000000000000000000000000000000000000;;				Namespace: testns,
0000000000000000000000000000000000000000;;				UID:       "1234567890",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Type: api.SecretType("kubernetes.io/scaleio"),
0000000000000000000000000000000000000000;;			Data: map[string][]byte{
0000000000000000000000000000000000000000;;				"username": []byte("username"),
0000000000000000000000000000000000000000;;				"password": []byte("password"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fakeClient := fakeclient.NewSimpleClientset(config)
0000000000000000000000000000000000000000;;		host := volumetest.NewFakeVolumeHost(tmpDir, fakeClient, nil)
0000000000000000000000000000000000000000;;		plugMgr := &volume.VolumePluginMgr{}
0000000000000000000000000000000000000000;;		plugMgr.InitPlugins(ProbeVolumePlugins(), host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plugMgr, tmpDir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeCanSupport(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr, tmpDir := newPluginMgr(t)
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName(sioPluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin %s by name", sioPluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if plug.GetPluginName() != "kubernetes.io/scaleio" {
0000000000000000000000000000000000000000;;			t.Errorf("Wrong name: %s", plug.GetPluginName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plug.CanSupport(
0000000000000000000000000000000000000000;;			&volume.Spec{
0000000000000000000000000000000000000000;;				Volume: &api.Volume{
0000000000000000000000000000000000000000;;					VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;						ScaleIO: &api.ScaleIOVolumeSource{},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true for CanSupport LibStorage VolumeSource")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !plug.CanSupport(
0000000000000000000000000000000000000000;;			&volume.Spec{
0000000000000000000000000000000000000000;;				PersistentVolume: &api.PersistentVolume{
0000000000000000000000000000000000000000;;					Spec: api.PersistentVolumeSpec{
0000000000000000000000000000000000000000;;						PersistentVolumeSource: api.PersistentVolumeSource{
0000000000000000000000000000000000000000;;							ScaleIO: &api.ScaleIOVolumeSource{},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected true for CanSupport LibStorage PersistentVolumeSource")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeGetAccessModes(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr, tmpDir := newPluginMgr(t)
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPersistentPluginByName(sioPluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin %v", sioPluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containsMode(plug.GetAccessModes(), api.ReadWriteOnce) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected two AccessModeTypes:  %s or %s", api.ReadWriteOnce, api.ReadOnlyMany)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func containsMode(modes []api.PersistentVolumeAccessMode, mode api.PersistentVolumeAccessMode) bool {
0000000000000000000000000000000000000000;;		for _, m := range modes {
0000000000000000000000000000000000000000;;			if m == mode {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeMounterUnmounter(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr, tmpDir := newPluginMgr(t)
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName(sioPluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin %v", sioPluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioPlug, ok := plug.(*sioPlugin)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Cannot assert plugin to be type sioPlugin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sioPlug.mounter = &mount.FakeMounter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol := &api.Volume{
0000000000000000000000000000000000000000;;			Name: testSioVolName,
0000000000000000000000000000000000000000;;			VolumeSource: api.VolumeSource{
0000000000000000000000000000000000000000;;				ScaleIO: &api.ScaleIOVolumeSource{
0000000000000000000000000000000000000000;;					Gateway:          "http://test.scaleio:1111",
0000000000000000000000000000000000000000;;					System:           testSioSystem,
0000000000000000000000000000000000000000;;					ProtectionDomain: testSioPD,
0000000000000000000000000000000000000000;;					StoragePool:      "default",
0000000000000000000000000000000000000000;;					VolumeName:       testSioVol,
0000000000000000000000000000000000000000;;					FSType:           "ext4",
0000000000000000000000000000000000000000;;					SecretRef:        &api.LocalObjectReference{Name: "sio-secret"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sioMounter, err := sioPlug.NewMounter(
0000000000000000000000000000000000000000;;			volume.NewSpecFromVolume(vol),
0000000000000000000000000000000000000000;;			&api.Pod{ObjectMeta: meta.ObjectMeta{UID: podUID, Namespace: testns}},
0000000000000000000000000000000000000000;;			volume.VolumeOptions{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sioMounter == nil {
0000000000000000000000000000000000000000;;			t.Fatal("Got a nil Mounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sio := newFakeSio()
0000000000000000000000000000000000000000;;		sioVol := sioMounter.(*sioVolume)
0000000000000000000000000000000000000000;;		if err := sioVol.setSioMgr(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create sio mgr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol.sioMgr.client = sio
0000000000000000000000000000000000000000;;		sioVol.sioMgr.CreateVolume(testSioVol, 8) //create vol ahead of time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volPath := path.Join(tmpDir, fmt.Sprintf("pods/%s/volumes/kubernetes.io~scaleio/%s", podUID, testSioVolName))
0000000000000000000000000000000000000000;;		path := sioMounter.GetPath()
0000000000000000000000000000000000000000;;		if path != volPath {
0000000000000000000000000000000000000000;;			t.Errorf("Got unexpected path: %s", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := sioMounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed, volume path not created: %s", path)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rebuild spec
0000000000000000000000000000000000000000;;		builtSpec, err := sioPlug.ConstructVolumeSpec(volume.NewSpecFromVolume(vol).Name(), path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("ConstructVolumeSpec failed %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if builtSpec.Name() != vol.Name {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected spec name %s", builtSpec.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unmount
0000000000000000000000000000000000000000;;		sioUnmounter, err := sioPlug.NewUnmounter(volume.NewSpecFromVolume(vol).Name(), podUID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sioUnmounter == nil {
0000000000000000000000000000000000000000;;			t.Fatal("Got a nil Unmounter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol = sioUnmounter.(*sioVolume)
0000000000000000000000000000000000000000;;		if err := sioVol.resetSioMgr(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to reset sio mgr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol.sioMgr.client = sio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := sioUnmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// is mount point gone ?
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("TearDown() failed, volume path still exists: %s", path)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("SetUp() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// are we still mapped
0000000000000000000000000000000000000000;;		if sio.volume.MappedSdcInfo != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected SdcMappedInfo to be nil, volume may still be mapped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVolumeProvisioner(t *testing.T) {
0000000000000000000000000000000000000000;;		plugMgr, tmpDir := newPluginMgr(t)
0000000000000000000000000000000000000000;;		defer os.RemoveAll(tmpDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plug, err := plugMgr.FindPluginByName(sioPluginName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Can't find the plugin %v", sioPluginName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioPlug, ok := plug.(*sioPlugin)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Errorf("Cannot assert plugin to be type sioPlugin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := volume.VolumeOptions{
0000000000000000000000000000000000000000;;			ClusterName: "testcluster",
0000000000000000000000000000000000000000;;			PVName:      "pvc-sio-dynamic-vol",
0000000000000000000000000000000000000000;;			PVC:         volumetest.CreateTestPVC("100Mi", []api.PersistentVolumeAccessMode{api.ReadWriteOnce}),
0000000000000000000000000000000000000000;;			PersistentVolumeReclaimPolicy: api.PersistentVolumeReclaimDelete,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options.PVC.Namespace = testns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// incomplete options, test should fail
0000000000000000000000000000000000000000;;		_, err = sioPlug.NewProvisioner(options)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected failure due to incomplete options")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options.Parameters = map[string]string{
0000000000000000000000000000000000000000;;			confKey.gateway:          "http://test.scaleio:11111",
0000000000000000000000000000000000000000;;			confKey.system:           "sio",
0000000000000000000000000000000000000000;;			confKey.protectionDomain: testSioPD,
0000000000000000000000000000000000000000;;			confKey.storagePool:      "default",
0000000000000000000000000000000000000000;;			confKey.secretRef:        "sio-secret",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provisioner, err := sioPlug.NewProvisioner(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create new provisioner: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if provisioner == nil {
0000000000000000000000000000000000000000;;			t.Fatal("got a nil provisioner")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sio := newFakeSio()
0000000000000000000000000000000000000000;;		sioVol := provisioner.(*sioVolume)
0000000000000000000000000000000000000000;;		if err := sioVol.setSioMgrFromConfig(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create scaleio mgr from config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol.sioMgr.client = sio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec, err := provisioner.Provision()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("call to Provision() failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.Spec.ClaimRef = &api.ObjectReference{Namespace: testns}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate provision
0000000000000000000000000000000000000000;;		actualSpecName := spec.Name
0000000000000000000000000000000000000000;;		actualVolName := spec.Spec.PersistentVolumeSource.ScaleIO.VolumeName
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(actualSpecName, "pvc-") {
0000000000000000000000000000000000000000;;			t.Errorf("expecting volume name to start with pov-, got %s", actualSpecName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vol, err := sio.FindVolume(actualVolName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed getting volume %v: %v", actualVolName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vol.Name != actualVolName {
0000000000000000000000000000000000000000;;			t.Errorf("expected volume name to be %s, got %s", actualVolName, vol.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mount dynamic vol
0000000000000000000000000000000000000000;;		sioMounter, err := sioPlug.NewMounter(
0000000000000000000000000000000000000000;;			volume.NewSpecFromPersistentVolume(spec, false),
0000000000000000000000000000000000000000;;			&api.Pod{ObjectMeta: meta.ObjectMeta{UID: podUID, Namespace: testns}},
0000000000000000000000000000000000000000;;			volume.VolumeOptions{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to make a new Mounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol = sioMounter.(*sioVolume)
0000000000000000000000000000000000000000;;		if err := sioVol.setSioMgr(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create sio mgr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol.sioMgr.client = sio
0000000000000000000000000000000000000000;;		if err := sioMounter.SetUp(nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// teardown dynamic vol
0000000000000000000000000000000000000000;;		sioUnmounter, err := sioPlug.NewUnmounter(spec.Name, podUID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to make a new Unmounter: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol = sioUnmounter.(*sioVolume)
0000000000000000000000000000000000000000;;		if err := sioVol.resetSioMgr(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to reset sio mgr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol.sioMgr.client = sio
0000000000000000000000000000000000000000;;		if err := sioUnmounter.TearDown(); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected success, got: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test deleter
0000000000000000000000000000000000000000;;		deleter, err := sioPlug.NewDeleter(volume.NewSpecFromPersistentVolume(spec, false))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to create a deleter %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol = deleter.(*sioVolume)
0000000000000000000000000000000000000000;;		if err := sioVol.setSioMgrFromSpec(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed to set sio mgr: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sioVol.sioMgr.client = sio
0000000000000000000000000000000000000000;;		if err := deleter.Delete(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("failed while deleteing vol: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path := deleter.GetPath()
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("TearDown() failed, volume path still exists: %s", path)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			t.Errorf("Deleter did not delete path %v: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
