0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
761e7227e33613a758dc2cfb3225d5a1fec491cf;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/user"
0000000000000000000000000000000000000000;;		genericapifilters "k8s.io/apiserver/pkg/endpoints/filters"
0000000000000000000000000000000000000000;;		apirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/features"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		genericfilters "k8s.io/apiserver/pkg/server/filters"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsecureServingInfo is required to serve http.  HTTP does NOT include authentication or authorization.
0000000000000000000000000000000000000000;;	// You shouldn't be using this.  It makes sig-auth sad.
0000000000000000000000000000000000000000;;	// InsecureServingInfo *ServingInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BuildInsecureHandlerChain(apiHandler http.Handler, c *server.Config) http.Handler {
0000000000000000000000000000000000000000;;		handler := apiHandler
0000000000000000000000000000000000000000;;		if utilfeature.DefaultFeatureGate.Enabled(features.AdvancedAuditing) {
0000000000000000000000000000000000000000;;			handler = genericapifilters.WithAudit(handler, c.RequestContextMapper, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			handler = genericapifilters.WithLegacyAudit(handler, c.RequestContextMapper, c.LegacyAuditWriter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithAuthentication(handler, c.RequestContextMapper, insecureSuperuser{}, nil)
0000000000000000000000000000000000000000;;		handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, nil, nil, nil, "true")
0000000000000000000000000000000000000000;;		handler = genericfilters.WithPanicRecovery(handler)
0000000000000000000000000000000000000000;;		handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.RequestContextMapper, c.LongRunningFunc)
0000000000000000000000000000000000000000;;		handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.RequestContextMapper, c.LongRunningFunc)
0000000000000000000000000000000000000000;;		handler = genericapifilters.WithRequestInfo(handler, server.NewRequestInfoResolver(c), c.RequestContextMapper)
0000000000000000000000000000000000000000;;		handler = apirequest.WithRequestContext(handler, c.RequestContextMapper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InsecureServingInfo struct {
0000000000000000000000000000000000000000;;		// BindAddress is the ip:port to serve on
0000000000000000000000000000000000000000;;		BindAddress string
0000000000000000000000000000000000000000;;		// BindNetwork is the type of network to bind to - defaults to "tcp", accepts "tcp",
0000000000000000000000000000000000000000;;		// "tcp4", and "tcp6".
0000000000000000000000000000000000000000;;		BindNetwork string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *InsecureServingInfo) NewLoopbackClientConfig(token string) (*rest.Config, error) {
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, port, err := server.LoopbackHostPort(s.BindAddress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rest.Config{
0000000000000000000000000000000000000000;;			Host: "http://" + net.JoinHostPort(host, port),
0000000000000000000000000000000000000000;;			// Increase QPS limits. The client is currently passed to all admission plugins,
0000000000000000000000000000000000000000;;			// and those can be throttled in case of higher load on apiserver - see #22340 and #22422
0000000000000000000000000000000000000000;;			// for more details. Once #22422 is fixed, we may want to remove it.
0000000000000000000000000000000000000000;;			QPS:   50,
0000000000000000000000000000000000000000;;			Burst: 100,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NonBlockingRun spawns the insecure http server. An error is
0000000000000000000000000000000000000000;;	// returned if the ports cannot be listened on.
0000000000000000000000000000000000000000;;	func NonBlockingRun(insecureServingInfo *InsecureServingInfo, insecureHandler http.Handler, stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		// Use an internal stop channel to allow cleanup of the listeners on error.
0000000000000000000000000000000000000000;;		internalStopCh := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if insecureServingInfo != nil && insecureHandler != nil {
0000000000000000000000000000000000000000;;			if err := serveInsecurely(insecureServingInfo, insecureHandler, internalStopCh); err != nil {
0000000000000000000000000000000000000000;;				close(internalStopCh)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now that the listener has bound successfully, it is the
0000000000000000000000000000000000000000;;		// responsibility of the caller to close the provided channel to
0000000000000000000000000000000000000000;;		// ensure cleanup.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-stopCh
0000000000000000000000000000000000000000;;			close(internalStopCh)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveInsecurely run the insecure http server. It fails only if the initial listen
0000000000000000000000000000000000000000;;	// call fails. The actual server loop (stoppable by closing stopCh) runs in a go
0000000000000000000000000000000000000000;;	// routine, i.e. serveInsecurely does not block.
0000000000000000000000000000000000000000;;	func serveInsecurely(insecureServingInfo *InsecureServingInfo, insecureHandler http.Handler, stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		insecureServer := &http.Server{
0000000000000000000000000000000000000000;;			Addr:           insecureServingInfo.BindAddress,
0000000000000000000000000000000000000000;;			Handler:        insecureHandler,
0000000000000000000000000000000000000000;;			MaxHeaderBytes: 1 << 20,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Serving insecurely on %s", insecureServingInfo.BindAddress)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		_, err = server.RunServer(insecureServer, insecureServingInfo.BindNetwork, stopCh)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insecureSuperuser implements authenticator.Request to always return a superuser.
0000000000000000000000000000000000000000;;	// This is functionally equivalent to skipping authentication and authorization,
0000000000000000000000000000000000000000;;	// but allows apiserver code to stop special-casing a nil user to skip authorization checks.
0000000000000000000000000000000000000000;;	type insecureSuperuser struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (insecureSuperuser) AuthenticateRequest(req *http.Request) (user.Info, bool, error) {
0000000000000000000000000000000000000000;;		return &user.DefaultInfo{
0000000000000000000000000000000000000000;;			Name:   "system:unsecured",
0000000000000000000000000000000000000000;;			Groups: []string{user.SystemPrivilegedGroup, user.AllAuthenticated},
0000000000000000000000000000000000000000;;		}, true, nil
0000000000000000000000000000000000000000;;	}
