0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
144aa8716716fc8bf38b30cdeb11582fd7a883b3;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		genericoptions "k8s.io/apiserver/pkg/server/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubeapiserver/authenticator"
0000000000000000000000000000000000000000;;		authzmodes "k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BuiltInAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		Anonymous       *AnonymousAuthenticationOptions
0000000000000000000000000000000000000000;;		AnyToken        *AnyTokenAuthenticationOptions
0000000000000000000000000000000000000000;;		BootstrapToken  *BootstrapTokenAuthenticationOptions
0000000000000000000000000000000000000000;;		ClientCert      *genericoptions.ClientCertAuthenticationOptions
0000000000000000000000000000000000000000;;		Keystone        *KeystoneAuthenticationOptions
0000000000000000000000000000000000000000;;		OIDC            *OIDCAuthenticationOptions
0000000000000000000000000000000000000000;;		PasswordFile    *PasswordFileAuthenticationOptions
0000000000000000000000000000000000000000;;		RequestHeader   *genericoptions.RequestHeaderAuthenticationOptions
0000000000000000000000000000000000000000;;		ServiceAccounts *ServiceAccountAuthenticationOptions
0000000000000000000000000000000000000000;;		TokenFile       *TokenFileAuthenticationOptions
0000000000000000000000000000000000000000;;		WebHook         *WebHookAuthenticationOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AnyTokenAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		Allow bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AnonymousAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		Allow bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BootstrapTokenAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		Allow bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KeystoneAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		URL    string
0000000000000000000000000000000000000000;;		CAFile string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		CAFile        string
0000000000000000000000000000000000000000;;		ClientID      string
0000000000000000000000000000000000000000;;		IssuerURL     string
0000000000000000000000000000000000000000;;		UsernameClaim string
0000000000000000000000000000000000000000;;		GroupsClaim   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PasswordFileAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		BasicAuthFile string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ServiceAccountAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		KeyFiles []string
0000000000000000000000000000000000000000;;		Lookup   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TokenFileAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		TokenFile string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WebHookAuthenticationOptions struct {
0000000000000000000000000000000000000000;;		ConfigFile string
0000000000000000000000000000000000000000;;		CacheTTL   time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBuiltInAuthenticationOptions() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		return &BuiltInAuthenticationOptions{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithAll() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		return s.
0000000000000000000000000000000000000000;;			WithAnyonymous().
0000000000000000000000000000000000000000;;			WithAnyToken().
0000000000000000000000000000000000000000;;			WithBootstrapToken().
0000000000000000000000000000000000000000;;			WithClientCert().
0000000000000000000000000000000000000000;;			WithKeystone().
0000000000000000000000000000000000000000;;			WithOIDC().
0000000000000000000000000000000000000000;;			WithPasswordFile().
0000000000000000000000000000000000000000;;			WithRequestHeader().
0000000000000000000000000000000000000000;;			WithServiceAccounts().
0000000000000000000000000000000000000000;;			WithTokenFile().
0000000000000000000000000000000000000000;;			WithWebHook()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithAnyonymous() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.Anonymous = &AnonymousAuthenticationOptions{Allow: true}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithAnyToken() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.AnyToken = &AnyTokenAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithBootstrapToken() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.BootstrapToken = &BootstrapTokenAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithClientCert() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.ClientCert = &genericoptions.ClientCertAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithKeystone() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.Keystone = &KeystoneAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithOIDC() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.OIDC = &OIDCAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithPasswordFile() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.PasswordFile = &PasswordFileAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithRequestHeader() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.RequestHeader = &genericoptions.RequestHeaderAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithServiceAccounts() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.ServiceAccounts = &ServiceAccountAuthenticationOptions{Lookup: true}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithTokenFile() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.TokenFile = &TokenFileAuthenticationOptions{}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) WithWebHook() *BuiltInAuthenticationOptions {
0000000000000000000000000000000000000000;;		s.WebHook = &WebHookAuthenticationOptions{
0000000000000000000000000000000000000000;;			CacheTTL: 2 * time.Minute,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks invalid config combination
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) Validate() []error {
0000000000000000000000000000000000000000;;		allErrors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.OIDC != nil && (len(s.OIDC.IssuerURL) > 0) != (len(s.OIDC.ClientID) > 0) {
0000000000000000000000000000000000000000;;			allErrors = append(allErrors, fmt.Errorf("oidc-issuer-url and oidc-client-id should be specified together"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		if s.Anonymous != nil {
0000000000000000000000000000000000000000;;			fs.BoolVar(&s.Anonymous.Allow, "anonymous-auth", s.Anonymous.Allow, ""+
0000000000000000000000000000000000000000;;				"Enables anonymous requests to the secure port of the API server. "+
0000000000000000000000000000000000000000;;				"Requests that are not rejected by another authentication method are treated as anonymous requests. "+
0000000000000000000000000000000000000000;;				"Anonymous requests have a username of system:anonymous, and a group name of system:unauthenticated.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.AnyToken != nil {
0000000000000000000000000000000000000000;;			fs.BoolVar(&s.AnyToken.Allow, "insecure-allow-any-token", s.AnyToken.Allow, ""+
0000000000000000000000000000000000000000;;				"If set, your server will be INSECURE.  Any token will be allowed and user information will be parsed "+
0000000000000000000000000000000000000000;;				"from the token as `username/group1,group2`")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.BootstrapToken != nil {
0000000000000000000000000000000000000000;;			fs.BoolVar(&s.BootstrapToken.Allow, "experimental-bootstrap-token-auth", s.BootstrapToken.Allow, ""+
0000000000000000000000000000000000000000;;				"Enable to allow secrets of type 'bootstrap.kubernetes.io/token' in the 'kube-system' "+
0000000000000000000000000000000000000000;;				"namespace to be used for TLS bootstrapping authentication.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.ClientCert != nil {
0000000000000000000000000000000000000000;;			s.ClientCert.AddFlags(fs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Keystone != nil {
0000000000000000000000000000000000000000;;			fs.StringVar(&s.Keystone.URL, "experimental-keystone-url", s.Keystone.URL,
0000000000000000000000000000000000000000;;				"If passed, activates the keystone authentication plugin.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs.StringVar(&s.Keystone.CAFile, "experimental-keystone-ca-file", s.Keystone.CAFile, ""+
0000000000000000000000000000000000000000;;				"If set, the Keystone server's certificate will be verified by one of the authorities "+
0000000000000000000000000000000000000000;;				"in the experimental-keystone-ca-file, otherwise the host's root CA set will be used.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.OIDC != nil {
0000000000000000000000000000000000000000;;			fs.StringVar(&s.OIDC.IssuerURL, "oidc-issuer-url", s.OIDC.IssuerURL, ""+
0000000000000000000000000000000000000000;;				"The URL of the OpenID issuer, only HTTPS scheme will be accepted. "+
0000000000000000000000000000000000000000;;				"If set, it will be used to verify the OIDC JSON Web Token (JWT).")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs.StringVar(&s.OIDC.ClientID, "oidc-client-id", s.OIDC.ClientID,
0000000000000000000000000000000000000000;;				"The client ID for the OpenID Connect client, must be set if oidc-issuer-url is set.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs.StringVar(&s.OIDC.CAFile, "oidc-ca-file", s.OIDC.CAFile, ""+
0000000000000000000000000000000000000000;;				"If set, the OpenID server's certificate will be verified by one of the authorities "+
0000000000000000000000000000000000000000;;				"in the oidc-ca-file, otherwise the host's root CA set will be used.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs.StringVar(&s.OIDC.UsernameClaim, "oidc-username-claim", "sub", ""+
0000000000000000000000000000000000000000;;				"The OpenID claim to use as the user name. Note that claims other than the default ('sub') "+
0000000000000000000000000000000000000000;;				"is not guaranteed to be unique and immutable. This flag is experimental, please see "+
0000000000000000000000000000000000000000;;				"the authentication documentation for further details.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs.StringVar(&s.OIDC.GroupsClaim, "oidc-groups-claim", "", ""+
0000000000000000000000000000000000000000;;				"If provided, the name of a custom OpenID Connect claim for specifying user groups. "+
0000000000000000000000000000000000000000;;				"The claim value is expected to be a string or array of strings. This flag is experimental, "+
0000000000000000000000000000000000000000;;				"please see the authentication documentation for further details.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.PasswordFile != nil {
0000000000000000000000000000000000000000;;			fs.StringVar(&s.PasswordFile.BasicAuthFile, "basic-auth-file", s.PasswordFile.BasicAuthFile, ""+
0000000000000000000000000000000000000000;;				"If set, the file that will be used to admit requests to the secure port of the API server "+
0000000000000000000000000000000000000000;;				"via http basic authentication.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.RequestHeader != nil {
0000000000000000000000000000000000000000;;			s.RequestHeader.AddFlags(fs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.ServiceAccounts != nil {
0000000000000000000000000000000000000000;;			fs.StringArrayVar(&s.ServiceAccounts.KeyFiles, "service-account-key-file", s.ServiceAccounts.KeyFiles, ""+
0000000000000000000000000000000000000000;;				"File containing PEM-encoded x509 RSA or ECDSA private or public keys, used to verify "+
0000000000000000000000000000000000000000;;				"ServiceAccount tokens. If unspecified, --tls-private-key-file is used. "+
0000000000000000000000000000000000000000;;				"The specified file can contain multiple keys, and the flag can be specified multiple times with different files.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs.BoolVar(&s.ServiceAccounts.Lookup, "service-account-lookup", s.ServiceAccounts.Lookup,
0000000000000000000000000000000000000000;;				"If true, validate ServiceAccount tokens exist in etcd as part of authentication.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.TokenFile != nil {
0000000000000000000000000000000000000000;;			fs.StringVar(&s.TokenFile.TokenFile, "token-auth-file", s.TokenFile.TokenFile, ""+
0000000000000000000000000000000000000000;;				"If set, the file that will be used to secure the secure port of the API server "+
0000000000000000000000000000000000000000;;				"via token authentication.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.WebHook != nil {
0000000000000000000000000000000000000000;;			fs.StringVar(&s.WebHook.ConfigFile, "authentication-token-webhook-config-file", s.WebHook.ConfigFile, ""+
0000000000000000000000000000000000000000;;				"File with webhook configuration for token authentication in kubeconfig format. "+
0000000000000000000000000000000000000000;;				"The API server will query the remote service to determine authentication for bearer tokens.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs.DurationVar(&s.WebHook.CacheTTL, "authentication-token-webhook-cache-ttl", s.WebHook.CacheTTL,
0000000000000000000000000000000000000000;;				"The duration to cache responses from the webhook token authenticator.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthenticationOptions) ToAuthenticationConfig() authenticator.AuthenticatorConfig {
0000000000000000000000000000000000000000;;		ret := authenticator.AuthenticatorConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Anonymous != nil {
0000000000000000000000000000000000000000;;			ret.Anonymous = s.Anonymous.Allow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.AnyToken != nil {
0000000000000000000000000000000000000000;;			ret.AnyToken = s.AnyToken.Allow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.BootstrapToken != nil {
0000000000000000000000000000000000000000;;			ret.BootstrapToken = s.BootstrapToken.Allow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.ClientCert != nil {
0000000000000000000000000000000000000000;;			ret.ClientCAFile = s.ClientCert.ClientCA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Keystone != nil {
0000000000000000000000000000000000000000;;			ret.KeystoneURL = s.Keystone.URL
0000000000000000000000000000000000000000;;			ret.KeystoneCAFile = s.Keystone.CAFile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.OIDC != nil {
0000000000000000000000000000000000000000;;			ret.OIDCCAFile = s.OIDC.CAFile
0000000000000000000000000000000000000000;;			ret.OIDCClientID = s.OIDC.ClientID
0000000000000000000000000000000000000000;;			ret.OIDCGroupsClaim = s.OIDC.GroupsClaim
0000000000000000000000000000000000000000;;			ret.OIDCIssuerURL = s.OIDC.IssuerURL
0000000000000000000000000000000000000000;;			ret.OIDCUsernameClaim = s.OIDC.UsernameClaim
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.PasswordFile != nil {
0000000000000000000000000000000000000000;;			ret.BasicAuthFile = s.PasswordFile.BasicAuthFile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.RequestHeader != nil {
0000000000000000000000000000000000000000;;			ret.RequestHeaderConfig = s.RequestHeader.ToAuthenticationRequestHeaderConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.ServiceAccounts != nil {
0000000000000000000000000000000000000000;;			ret.ServiceAccountKeyFiles = s.ServiceAccounts.KeyFiles
0000000000000000000000000000000000000000;;			ret.ServiceAccountLookup = s.ServiceAccounts.Lookup
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.TokenFile != nil {
0000000000000000000000000000000000000000;;			ret.TokenAuthFile = s.TokenFile.TokenFile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.WebHook != nil {
0000000000000000000000000000000000000000;;			ret.WebhookTokenAuthnConfigFile = s.WebHook.ConfigFile
0000000000000000000000000000000000000000;;			ret.WebhookTokenAuthnCacheTTL = s.WebHook.CacheTTL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *BuiltInAuthenticationOptions) ApplyTo(c *genericapiserver.Config) error {
0000000000000000000000000000000000000000;;		if o == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if o.ClientCert != nil {
0000000000000000000000000000000000000000;;			c, err = c.ApplyClientCert(o.ClientCert.ClientCA)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to load client CA file: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.RequestHeader != nil {
0000000000000000000000000000000000000000;;			c, err = c.ApplyClientCert(o.RequestHeader.ClientCAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to load client CA file: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.SupportsBasicAuth = o.PasswordFile != nil && len(o.PasswordFile.BasicAuthFile) > 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ApplyAuthorization will conditionally modify the authentication options based on the authorization options
0000000000000000000000000000000000000000;;	func (o *BuiltInAuthenticationOptions) ApplyAuthorization(authorization *BuiltInAuthorizationOptions) {
0000000000000000000000000000000000000000;;		if o == nil || authorization == nil || o.Anonymous == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// authorization ModeAlwaysAllow cannot be combined with AnonymousAuth.
0000000000000000000000000000000000000000;;		// in such a case the AnonymousAuth is stomped to false and you get a message
0000000000000000000000000000000000000000;;		if o.Anonymous.Allow {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, mode := range strings.Split(authorization.Mode, ",") {
0000000000000000000000000000000000000000;;				if mode == authzmodes.ModeAlwaysAllow {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				glog.Warningf("AnonymousAuth is not allowed with the AllowAll authorizer.  Resetting AnonymousAuth to false. You should use a different authorizer")
0000000000000000000000000000000000000000;;				o.Anonymous.Allow = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
