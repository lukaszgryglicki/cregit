0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b2186cb8851f3f7a2a1b91ce1a835b8578c0b956;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package options contains flags and options for initializing an apiserver
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		genericoptions "k8s.io/apiserver/pkg/server/options"
0000000000000000000000000000000000000000;;		kubeserver "k8s.io/kubernetes/pkg/kubeapiserver/server"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSecureServingOptions gives default values for the kube-apiserver and federation-apiserver which are not the options wanted by
0000000000000000000000000000000000000000;;	// "normal" API servers running on the platform
0000000000000000000000000000000000000000;;	func NewSecureServingOptions() *genericoptions.SecureServingOptions {
0000000000000000000000000000000000000000;;		return &genericoptions.SecureServingOptions{
0000000000000000000000000000000000000000;;			BindAddress: net.ParseIP("0.0.0.0"),
0000000000000000000000000000000000000000;;			BindPort:    6443,
0000000000000000000000000000000000000000;;			ServerCert: genericoptions.GeneratableKeyCert{
0000000000000000000000000000000000000000;;				PairName:      "apiserver",
0000000000000000000000000000000000000000;;				CertDirectory: "/var/run/kubernetes",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultAdvertiseAddress sets the field AdvertiseAddress if
0000000000000000000000000000000000000000;;	// unset. The field will be set based on the SecureServingOptions. If
0000000000000000000000000000000000000000;;	// the SecureServingOptions is not present, DefaultExternalAddress
0000000000000000000000000000000000000000;;	// will fall back to the insecure ServingOptions.
0000000000000000000000000000000000000000;;	func DefaultAdvertiseAddress(s *genericoptions.ServerRunOptions, insecure *InsecureServingOptions) error {
0000000000000000000000000000000000000000;;		if insecure == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.AdvertiseAddress == nil || s.AdvertiseAddress.IsUnspecified() {
0000000000000000000000000000000000000000;;			hostIP, err := insecure.DefaultExternalAddress()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to find suitable network address.error='%v'. "+
0000000000000000000000000000000000000000;;					"Try to set the AdvertiseAddress directly or provide a valid BindAddress to fix this.", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.AdvertiseAddress = hostIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsecureServingOptions are for creating an unauthenticated, unauthorized, insecure port.
0000000000000000000000000000000000000000;;	// No one should be using these anymore.
0000000000000000000000000000000000000000;;	type InsecureServingOptions struct {
0000000000000000000000000000000000000000;;		BindAddress net.IP
0000000000000000000000000000000000000000;;		BindPort    int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInsecureServingOptions is for creating an unauthenticated, unauthorized, insecure port.
0000000000000000000000000000000000000000;;	// No one should be using these anymore.
0000000000000000000000000000000000000000;;	func NewInsecureServingOptions() *InsecureServingOptions {
0000000000000000000000000000000000000000;;		return &InsecureServingOptions{
0000000000000000000000000000000000000000;;			BindAddress: net.ParseIP("127.0.0.1"),
0000000000000000000000000000000000000000;;			BindPort:    8080,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s InsecureServingOptions) Validate(portArg string) []error {
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.BindPort < 0 || s.BindPort > 65535 {
0000000000000000000000000000000000000000;;			errors = append(errors, fmt.Errorf("--insecure-port %v must be between 0 and 65535, inclusive. 0 for turning off secure port.", s.BindPort))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *InsecureServingOptions) DefaultExternalAddress() (net.IP, error) {
0000000000000000000000000000000000000000;;		return utilnet.ChooseBindAddress(s.BindAddress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *InsecureServingOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.IPVar(&s.BindAddress, "insecure-bind-address", s.BindAddress, ""+
0000000000000000000000000000000000000000;;			"The IP address on which to serve the --insecure-port (set to 0.0.0.0 for all interfaces).")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.IntVar(&s.BindPort, "insecure-port", s.BindPort, ""+
0000000000000000000000000000000000000000;;			"The port on which to serve unsecured, unauthenticated access. It is assumed "+
0000000000000000000000000000000000000000;;			"that firewall rules are set up such that this port is not reachable from outside of "+
0000000000000000000000000000000000000000;;			"the cluster and that port 443 on the cluster's public address is proxied to this "+
0000000000000000000000000000000000000000;;			"port. This is performed by nginx in the default setup.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *InsecureServingOptions) AddDeprecatedFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.IPVar(&s.BindAddress, "address", s.BindAddress,
0000000000000000000000000000000000000000;;			"DEPRECATED: see --insecure-bind-address instead.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("address", "see --insecure-bind-address instead.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.IntVar(&s.BindPort, "port", s.BindPort, "DEPRECATED: see --insecure-port instead.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("port", "see --insecure-port instead.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *InsecureServingOptions) ApplyTo(c *server.Config) (*kubeserver.InsecureServingInfo, error) {
0000000000000000000000000000000000000000;;		if s.BindPort <= 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := &kubeserver.InsecureServingInfo{
0000000000000000000000000000000000000000;;			BindAddress: net.JoinHostPort(s.BindAddress.String(), strconv.Itoa(s.BindPort)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		privilegedLoopbackToken := uuid.NewRandom().String()
0000000000000000000000000000000000000000;;		if c.LoopbackClientConfig, err = ret.NewLoopbackClientConfig(privilegedLoopbackToken); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
