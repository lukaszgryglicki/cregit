0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ee7891cd8b4c7adaa0f6ab4c8e19965003335a00;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubeapiserver/authorizer"
0000000000000000000000000000000000000000;;		authzmodes "k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BuiltInAuthorizationOptions struct {
0000000000000000000000000000000000000000;;		Mode                        string
0000000000000000000000000000000000000000;;		PolicyFile                  string
0000000000000000000000000000000000000000;;		WebhookConfigFile           string
0000000000000000000000000000000000000000;;		WebhookCacheAuthorizedTTL   time.Duration
0000000000000000000000000000000000000000;;		WebhookCacheUnauthorizedTTL time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBuiltInAuthorizationOptions() *BuiltInAuthorizationOptions {
0000000000000000000000000000000000000000;;		return &BuiltInAuthorizationOptions{
0000000000000000000000000000000000000000;;			Mode: authzmodes.ModeAlwaysAllow,
0000000000000000000000000000000000000000;;			WebhookCacheAuthorizedTTL:   5 * time.Minute,
0000000000000000000000000000000000000000;;			WebhookCacheUnauthorizedTTL: 30 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthorizationOptions) Validate() []error {
0000000000000000000000000000000000000000;;		allErrors := []error{}
0000000000000000000000000000000000000000;;		return allErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthorizationOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringVar(&s.Mode, "authorization-mode", s.Mode, ""+
0000000000000000000000000000000000000000;;			"Ordered list of plug-ins to do authorization on secure port. Comma-delimited list of: "+
0000000000000000000000000000000000000000;;			strings.Join(authzmodes.AuthorizationModeChoices, ",")+".")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.PolicyFile, "authorization-policy-file", s.PolicyFile, ""+
0000000000000000000000000000000000000000;;			"File with authorization policy in csv format, used with --authorization-mode=ABAC, on the secure port.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.WebhookConfigFile, "authorization-webhook-config-file", s.WebhookConfigFile, ""+
0000000000000000000000000000000000000000;;			"File with webhook configuration in kubeconfig format, used with --authorization-mode=Webhook. "+
0000000000000000000000000000000000000000;;			"The API server will query the remote service to determine access on the API server's secure port.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.DurationVar(&s.WebhookCacheAuthorizedTTL, "authorization-webhook-cache-authorized-ttl",
0000000000000000000000000000000000000000;;			s.WebhookCacheAuthorizedTTL,
0000000000000000000000000000000000000000;;			"The duration to cache 'authorized' responses from the webhook authorizer.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.DurationVar(&s.WebhookCacheUnauthorizedTTL,
0000000000000000000000000000000000000000;;			"authorization-webhook-cache-unauthorized-ttl", s.WebhookCacheUnauthorizedTTL,
0000000000000000000000000000000000000000;;			"The duration to cache 'unauthorized' responses from the webhook authorizer.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.String("authorization-rbac-super-user", "", ""+
0000000000000000000000000000000000000000;;			"If specified, a username which avoids RBAC authorization checks and role binding "+
0000000000000000000000000000000000000000;;			"privilege escalation checks, to be used with --authorization-mode=RBAC.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("authorization-rbac-super-user", "Removed during alpha to beta.  The 'system:masters' group has privileged access.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthorizationOptions) Modes() []string {
0000000000000000000000000000000000000000;;		modes := []string{}
0000000000000000000000000000000000000000;;		if len(s.Mode) > 0 {
0000000000000000000000000000000000000000;;			modes = strings.Split(s.Mode, ",")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return modes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BuiltInAuthorizationOptions) ToAuthorizationConfig(informerFactory informers.SharedInformerFactory) authorizer.AuthorizationConfig {
0000000000000000000000000000000000000000;;		return authorizer.AuthorizationConfig{
0000000000000000000000000000000000000000;;			AuthorizationModes:          s.Modes(),
0000000000000000000000000000000000000000;;			PolicyFile:                  s.PolicyFile,
0000000000000000000000000000000000000000;;			WebhookConfigFile:           s.WebhookConfigFile,
0000000000000000000000000000000000000000;;			WebhookCacheAuthorizedTTL:   s.WebhookCacheAuthorizedTTL,
0000000000000000000000000000000000000000;;			WebhookCacheUnauthorizedTTL: s.WebhookCacheUnauthorizedTTL,
0000000000000000000000000000000000000000;;			InformerFactory:             informerFactory,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
