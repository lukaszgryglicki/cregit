0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
90318f730ab8d18b25150dd0c617622f458a0c5f;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultEtcdPathPrefix = "/registry"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageSerializationOptions contains the options for encoding resources.
0000000000000000000000000000000000000000;;	type StorageSerializationOptions struct {
0000000000000000000000000000000000000000;;		StorageVersions string
0000000000000000000000000000000000000000;;		// The default values for StorageVersions. StorageVersions overrides
0000000000000000000000000000000000000000;;		// these; you can change this if you want to change the defaults (e.g.,
0000000000000000000000000000000000000000;;		// for testing). This is not actually exposed as a flag.
0000000000000000000000000000000000000000;;		DefaultStorageVersions string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStorageSerializationOptions() *StorageSerializationOptions {
0000000000000000000000000000000000000000;;		return &StorageSerializationOptions{
0000000000000000000000000000000000000000;;			DefaultStorageVersions: api.Registry.AllPreferredGroupVersions(),
0000000000000000000000000000000000000000;;			StorageVersions:        api.Registry.AllPreferredGroupVersions(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageGroupsToEncodingVersion returns a map from group name to group version,
0000000000000000000000000000000000000000;;	// computed from s.StorageVersions flag.
0000000000000000000000000000000000000000;;	func (s *StorageSerializationOptions) StorageGroupsToEncodingVersion() (map[string]schema.GroupVersion, error) {
0000000000000000000000000000000000000000;;		storageVersionMap := map[string]schema.GroupVersion{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First, get the defaults.
0000000000000000000000000000000000000000;;		if err := mergeGroupVersionIntoMap(s.DefaultStorageVersions, storageVersionMap); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Override any defaults with the user settings.
0000000000000000000000000000000000000000;;		if err := mergeGroupVersionIntoMap(s.StorageVersions, storageVersionMap); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return storageVersionMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dest must be a map of group to groupVersion.
0000000000000000000000000000000000000000;;	func mergeGroupVersionIntoMap(gvList string, dest map[string]schema.GroupVersion) error {
0000000000000000000000000000000000000000;;		for _, gvString := range strings.Split(gvList, ",") {
0000000000000000000000000000000000000000;;			if gvString == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We accept two formats. "group/version" OR
0000000000000000000000000000000000000000;;			// "group=group/version". The latter is used when types
0000000000000000000000000000000000000000;;			// move between groups.
0000000000000000000000000000000000000000;;			if !strings.Contains(gvString, "=") {
0000000000000000000000000000000000000000;;				gv, err := schema.ParseGroupVersion(gvString)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dest[gv.Group] = gv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				parts := strings.SplitN(gvString, "=", 2)
0000000000000000000000000000000000000000;;				gv, err := schema.ParseGroupVersion(parts[1])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dest[parts[0]] = gv
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlags adds flags for a specific APIServer to the specified FlagSet
0000000000000000000000000000000000000000;;	func (s *StorageSerializationOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		// Note: the weird ""+ in below lines seems to be the only way to get gofmt to
0000000000000000000000000000000000000000;;		// arrange these text blocks sensibly. Grrr.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deprecatedStorageVersion := ""
0000000000000000000000000000000000000000;;		fs.StringVar(&deprecatedStorageVersion, "storage-version", deprecatedStorageVersion,
0000000000000000000000000000000000000000;;			"DEPRECATED: the version to store the legacy v1 resources with. Defaults to server preferred.")
0000000000000000000000000000000000000000;;		fs.MarkDeprecated("storage-version", "--storage-version is deprecated and will be removed when the v1 API "+
0000000000000000000000000000000000000000;;			"is retired. Setting this has no effect. See --storage-versions instead.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.StringVar(&s.StorageVersions, "storage-versions", s.StorageVersions, ""+
0000000000000000000000000000000000000000;;			"The per-group version to store resources in. "+
0000000000000000000000000000000000000000;;			"Specified in the format \"group1/version1,group2/version2,...\". "+
0000000000000000000000000000000000000000;;			"In the case where objects are moved from one group to the other, "+
0000000000000000000000000000000000000000;;			"you may specify the format \"group1=group2/v1beta1,group3/v1beta1,...\". "+
0000000000000000000000000000000000000000;;			"You only need to pass the groups you wish to change from the defaults. "+
0000000000000000000000000000000000000000;;			"It defaults to a list of preferred versions of all registered groups, "+
0000000000000000000000000000000000000000;;			"which is derived from the KUBE_API_VERSIONS environment variable.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
