0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
ac735243f7c46a94a8944b413ed6b942694d86ba;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package configuration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultInterval             = 1 * time.Second
0000000000000000000000000000000000000000;;		defaultFailureThreshold     = 5
0000000000000000000000000000000000000000;;		defaultBootstrapRetries     = 5
0000000000000000000000000000000000000000;;		defaultBootstrapGraceperiod = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrNotReady = fmt.Errorf("configuration is not ready")
0000000000000000000000000000000000000000;;		ErrDisabled = fmt.Errorf("disabled")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type getFunc func() (runtime.Object, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When running, poller calls `get` every `interval`. If `get` is
0000000000000000000000000000000000000000;;	// successful, `Ready()` returns ready and `configuration()` returns the
0000000000000000000000000000000000000000;;	// `mergedConfiguration`; if `get` has failed more than `failureThreshold ` times,
0000000000000000000000000000000000000000;;	// `Ready()` returns not ready and `configuration()` returns nil configuration.
0000000000000000000000000000000000000000;;	// In an HA setup, the poller is consistent only if the `get` is
0000000000000000000000000000000000000000;;	// doing consistent read.
0000000000000000000000000000000000000000;;	type poller struct {
0000000000000000000000000000000000000000;;		// a function to consistently read the latest configuration
0000000000000000000000000000000000000000;;		get getFunc
0000000000000000000000000000000000000000;;		// consistent read interval
0000000000000000000000000000000000000000;;		// read-only
0000000000000000000000000000000000000000;;		interval time.Duration
0000000000000000000000000000000000000000;;		// if the number of consecutive read failure equals or exceeds the failureThreshold , the
0000000000000000000000000000000000000000;;		// configuration is regarded as not ready.
0000000000000000000000000000000000000000;;		// read-only
0000000000000000000000000000000000000000;;		failureThreshold int
0000000000000000000000000000000000000000;;		// number of consecutive failures so far.
0000000000000000000000000000000000000000;;		failures int
0000000000000000000000000000000000000000;;		// If the poller has passed the bootstrap phase. The poller is considered
0000000000000000000000000000000000000000;;		// bootstrapped either bootstrapGracePeriod after the first call of
0000000000000000000000000000000000000000;;		// configuration(), or when setConfigurationAndReady() is called, whichever
0000000000000000000000000000000000000000;;		// comes first.
0000000000000000000000000000000000000000;;		bootstrapped bool
0000000000000000000000000000000000000000;;		// configuration() retries bootstrapRetries times if poller is not bootstrapped
0000000000000000000000000000000000000000;;		// read-only
0000000000000000000000000000000000000000;;		bootstrapRetries int
0000000000000000000000000000000000000000;;		// Grace period for bootstrapping
0000000000000000000000000000000000000000;;		// read-only
0000000000000000000000000000000000000000;;		bootstrapGracePeriod time.Duration
0000000000000000000000000000000000000000;;		once                 sync.Once
0000000000000000000000000000000000000000;;		// if the configuration is regarded as ready.
0000000000000000000000000000000000000000;;		ready               bool
0000000000000000000000000000000000000000;;		mergedConfiguration runtime.Object
0000000000000000000000000000000000000000;;		lastErr             error
0000000000000000000000000000000000000000;;		// lock must be hold when reading/writing the data fields of poller.
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPoller(get getFunc) *poller {
0000000000000000000000000000000000000000;;		p := poller{
0000000000000000000000000000000000000000;;			get:                  get,
0000000000000000000000000000000000000000;;			interval:             defaultInterval,
0000000000000000000000000000000000000000;;			failureThreshold:     defaultFailureThreshold,
0000000000000000000000000000000000000000;;			bootstrapRetries:     defaultBootstrapRetries,
0000000000000000000000000000000000000000;;			bootstrapGracePeriod: defaultBootstrapGraceperiod,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *poller) lastError(err error) {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;		a.lastErr = err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *poller) notReady() {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;		a.ready = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *poller) bootstrapping() {
0000000000000000000000000000000000000000;;		// bootstrapGracePeriod is read-only, so no lock is required
0000000000000000000000000000000000000000;;		timer := time.NewTimer(a.bootstrapGracePeriod)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-timer.C
0000000000000000000000000000000000000000;;			a.lock.Lock()
0000000000000000000000000000000000000000;;			defer a.lock.Unlock()
0000000000000000000000000000000000000000;;			a.bootstrapped = true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If the poller is not bootstrapped yet, the configuration() gets a few chances
0000000000000000000000000000000000000000;;	// to retry. This hides transient failures during system startup.
0000000000000000000000000000000000000000;;	func (a *poller) configuration() (runtime.Object, error) {
0000000000000000000000000000000000000000;;		a.once.Do(a.bootstrapping)
0000000000000000000000000000000000000000;;		a.lock.RLock()
0000000000000000000000000000000000000000;;		defer a.lock.RUnlock()
0000000000000000000000000000000000000000;;		retries := 1
0000000000000000000000000000000000000000;;		if !a.bootstrapped {
0000000000000000000000000000000000000000;;			retries = a.bootstrapRetries
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for count := 0; count < retries; count++ {
0000000000000000000000000000000000000000;;			if count > 0 {
0000000000000000000000000000000000000000;;				a.lock.RUnlock()
0000000000000000000000000000000000000000;;				time.Sleep(a.interval)
0000000000000000000000000000000000000000;;				a.lock.RLock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a.ready {
0000000000000000000000000000000000000000;;				return a.mergedConfiguration, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.lastErr != nil {
0000000000000000000000000000000000000000;;			return nil, a.lastErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, ErrNotReady
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *poller) setConfigurationAndReady(value runtime.Object) {
0000000000000000000000000000000000000000;;		a.lock.Lock()
0000000000000000000000000000000000000000;;		defer a.lock.Unlock()
0000000000000000000000000000000000000000;;		a.bootstrapped = true
0000000000000000000000000000000000000000;;		a.mergedConfiguration = value
0000000000000000000000000000000000000000;;		a.ready = true
0000000000000000000000000000000000000000;;		a.lastErr = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *poller) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		go wait.Until(a.sync, a.interval, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *poller) sync() {
0000000000000000000000000000000000000000;;		configuration, err := a.get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.failures++
0000000000000000000000000000000000000000;;			a.lastError(err)
0000000000000000000000000000000000000000;;			if a.failures >= a.failureThreshold {
0000000000000000000000000000000000000000;;				a.notReady()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.failures = 0
0000000000000000000000000000000000000000;;		a.setConfigurationAndReady(configuration)
0000000000000000000000000000000000000000;;	}
