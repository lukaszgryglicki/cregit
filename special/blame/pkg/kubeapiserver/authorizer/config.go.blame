0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ee7891cd8b4c7adaa0f6ab4c8e19965003335a00;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package authorizer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/authorizerfactory"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authorization/union"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authorizer/webhook"
0000000000000000000000000000000000000000;;		rbacapi "k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/auth/authorizer/abac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/auth/nodeidentifier"
0000000000000000000000000000000000000000;;		informers "k8s.io/kubernetes/pkg/client/informers/informers_generated/internalversion"
0000000000000000000000000000000000000000;;		rbaclisters "k8s.io/kubernetes/pkg/client/listers/rbac/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/auth/authorizer/node"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/auth/authorizer/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/plugin/pkg/auth/authorizer/rbac/bootstrappolicy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuthorizationConfig struct {
0000000000000000000000000000000000000000;;		AuthorizationModes []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Options for ModeABAC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path to an ABAC policy file.
0000000000000000000000000000000000000000;;		PolicyFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Options for ModeWebhook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Kubeconfig file for Webhook authorization plugin.
0000000000000000000000000000000000000000;;		WebhookConfigFile string
0000000000000000000000000000000000000000;;		// TTL for caching of authorized responses from the webhook server.
0000000000000000000000000000000000000000;;		WebhookCacheAuthorizedTTL time.Duration
0000000000000000000000000000000000000000;;		// TTL for caching of unauthorized responses from the webhook server.
0000000000000000000000000000000000000000;;		WebhookCacheUnauthorizedTTL time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		InformerFactory informers.SharedInformerFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type roleGetter struct {
0000000000000000000000000000000000000000;;		lister rbaclisters.RoleLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *roleGetter) GetRole(namespace, name string) (*rbacapi.Role, error) {
0000000000000000000000000000000000000000;;		return g.lister.Roles(namespace).Get(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type roleBindingLister struct {
0000000000000000000000000000000000000000;;		lister rbaclisters.RoleBindingLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *roleBindingLister) ListRoleBindings(namespace string) ([]*rbacapi.RoleBinding, error) {
0000000000000000000000000000000000000000;;		return l.lister.RoleBindings(namespace).List(labels.Everything())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clusterRoleGetter struct {
0000000000000000000000000000000000000000;;		lister rbaclisters.ClusterRoleLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *clusterRoleGetter) GetClusterRole(name string) (*rbacapi.ClusterRole, error) {
0000000000000000000000000000000000000000;;		return g.lister.Get(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clusterRoleBindingLister struct {
0000000000000000000000000000000000000000;;		lister rbaclisters.ClusterRoleBindingLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *clusterRoleBindingLister) ListClusterRoleBindings() ([]*rbacapi.ClusterRoleBinding, error) {
0000000000000000000000000000000000000000;;		return l.lister.List(labels.Everything())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns the right sort of union of multiple authorizer.Authorizer objects
0000000000000000000000000000000000000000;;	// based on the authorizationMode or an error.
0000000000000000000000000000000000000000;;	func (config AuthorizationConfig) New() (authorizer.Authorizer, error) {
0000000000000000000000000000000000000000;;		if len(config.AuthorizationModes) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("At least one authorization mode should be passed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var authorizers []authorizer.Authorizer
0000000000000000000000000000000000000000;;		authorizerMap := make(map[string]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, authorizationMode := range config.AuthorizationModes {
0000000000000000000000000000000000000000;;			if authorizerMap[authorizationMode] {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Authorization mode %s specified more than once", authorizationMode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Keep cases in sync with constant list above.
0000000000000000000000000000000000000000;;			switch authorizationMode {
0000000000000000000000000000000000000000;;			case modes.ModeNode:
0000000000000000000000000000000000000000;;				graph := node.NewGraph()
0000000000000000000000000000000000000000;;				node.AddGraphEventHandlers(
0000000000000000000000000000000000000000;;					graph,
0000000000000000000000000000000000000000;;					config.InformerFactory.Core().InternalVersion().Pods(),
0000000000000000000000000000000000000000;;					config.InformerFactory.Core().InternalVersion().PersistentVolumes(),
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				nodeAuthorizer := node.NewAuthorizer(graph, nodeidentifier.NewDefaultNodeIdentifier(), bootstrappolicy.NodeRules())
0000000000000000000000000000000000000000;;				authorizers = append(authorizers, nodeAuthorizer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Don't bind system:nodes to the system:node role
0000000000000000000000000000000000000000;;				bootstrappolicy.AddClusterRoleBindingFilter(bootstrappolicy.OmitNodesGroupBinding)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case modes.ModeAlwaysAllow:
0000000000000000000000000000000000000000;;				authorizers = append(authorizers, authorizerfactory.NewAlwaysAllowAuthorizer())
0000000000000000000000000000000000000000;;			case modes.ModeAlwaysDeny:
0000000000000000000000000000000000000000;;				authorizers = append(authorizers, authorizerfactory.NewAlwaysDenyAuthorizer())
0000000000000000000000000000000000000000;;			case modes.ModeABAC:
0000000000000000000000000000000000000000;;				if config.PolicyFile == "" {
0000000000000000000000000000000000000000;;					return nil, errors.New("ABAC's authorization policy file not passed")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				abacAuthorizer, err := abac.NewFromFile(config.PolicyFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				authorizers = append(authorizers, abacAuthorizer)
0000000000000000000000000000000000000000;;			case modes.ModeWebhook:
0000000000000000000000000000000000000000;;				if config.WebhookConfigFile == "" {
0000000000000000000000000000000000000000;;					return nil, errors.New("Webhook's configuration file not passed")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				webhookAuthorizer, err := webhook.New(config.WebhookConfigFile,
0000000000000000000000000000000000000000;;					config.WebhookCacheAuthorizedTTL,
0000000000000000000000000000000000000000;;					config.WebhookCacheUnauthorizedTTL)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				authorizers = append(authorizers, webhookAuthorizer)
0000000000000000000000000000000000000000;;			case modes.ModeRBAC:
0000000000000000000000000000000000000000;;				rbacAuthorizer := rbac.New(
0000000000000000000000000000000000000000;;					&roleGetter{config.InformerFactory.Rbac().InternalVersion().Roles().Lister()},
0000000000000000000000000000000000000000;;					&roleBindingLister{config.InformerFactory.Rbac().InternalVersion().RoleBindings().Lister()},
0000000000000000000000000000000000000000;;					&clusterRoleGetter{config.InformerFactory.Rbac().InternalVersion().ClusterRoles().Lister()},
0000000000000000000000000000000000000000;;					&clusterRoleBindingLister{config.InformerFactory.Rbac().InternalVersion().ClusterRoleBindings().Lister()},
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				authorizers = append(authorizers, rbacAuthorizer)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Unknown authorization mode %s specified", authorizationMode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authorizerMap[authorizationMode] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !authorizerMap[modes.ModeABAC] && config.PolicyFile != "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("Cannot specify --authorization-policy-file without mode ABAC")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !authorizerMap[modes.ModeWebhook] && config.WebhookConfigFile != "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("Cannot specify --authorization-webhook-config-file without mode Webhook")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return union.New(authorizers...), nil
0000000000000000000000000000000000000000;;	}
