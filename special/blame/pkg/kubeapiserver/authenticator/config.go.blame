0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
28d14283d408655f7045f4408b552262b032c3ac;pkg/apiserver/authn.go[pkg/apiserver/authn.go][pkg/kubeapiserver/authenticator/config.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package authenticator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticator"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/authenticatorfactory"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/group"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/anonymous"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/bearertoken"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/headerrequest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/union"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/websocket"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/request/x509"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/authentication/token/tokenfile"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/password/keystone"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/password/passwordfile"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/request/basicauth"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/token/anytoken"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/token/oidc"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/plugin/pkg/authenticator/token/webhook"
0000000000000000000000000000000000000000;;		certutil "k8s.io/client-go/util/cert"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/serviceaccount"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize all known client auth plugins.
0000000000000000000000000000000000000000;;		_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
0000000000000000000000000000000000000000;;		_ "k8s.io/client-go/plugin/pkg/client/auth/oidc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuthenticatorConfig struct {
0000000000000000000000000000000000000000;;		Anonymous                   bool
0000000000000000000000000000000000000000;;		AnyToken                    bool
0000000000000000000000000000000000000000;;		BasicAuthFile               string
0000000000000000000000000000000000000000;;		BootstrapToken              bool
0000000000000000000000000000000000000000;;		ClientCAFile                string
0000000000000000000000000000000000000000;;		TokenAuthFile               string
0000000000000000000000000000000000000000;;		OIDCIssuerURL               string
0000000000000000000000000000000000000000;;		OIDCClientID                string
0000000000000000000000000000000000000000;;		OIDCCAFile                  string
0000000000000000000000000000000000000000;;		OIDCUsernameClaim           string
0000000000000000000000000000000000000000;;		OIDCGroupsClaim             string
0000000000000000000000000000000000000000;;		ServiceAccountKeyFiles      []string
0000000000000000000000000000000000000000;;		ServiceAccountLookup        bool
0000000000000000000000000000000000000000;;		KeystoneURL                 string
0000000000000000000000000000000000000000;;		KeystoneCAFile              string
0000000000000000000000000000000000000000;;		WebhookTokenAuthnConfigFile string
0000000000000000000000000000000000000000;;		WebhookTokenAuthnCacheTTL   time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RequestHeaderConfig *authenticatorfactory.RequestHeaderConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO, this is the only non-serializable part of the entire config.  Factor it out into a clientconfig
0000000000000000000000000000000000000000;;		ServiceAccountTokenGetter   serviceaccount.ServiceAccountTokenGetter
0000000000000000000000000000000000000000;;		BootstrapTokenAuthenticator authenticator.Token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns an authenticator.Request or an error that supports the standard
0000000000000000000000000000000000000000;;	// Kubernetes authentication mechanisms.
0000000000000000000000000000000000000000;;	func (config AuthenticatorConfig) New() (authenticator.Request, *spec.SecurityDefinitions, error) {
0000000000000000000000000000000000000000;;		var authenticators []authenticator.Request
0000000000000000000000000000000000000000;;		securityDefinitions := spec.SecurityDefinitions{}
0000000000000000000000000000000000000000;;		hasBasicAuth := false
0000000000000000000000000000000000000000;;		hasTokenAuth := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// front-proxy, BasicAuth methods, local first, then remote
0000000000000000000000000000000000000000;;		// Add the front proxy authenticator if requested
0000000000000000000000000000000000000000;;		if config.RequestHeaderConfig != nil {
0000000000000000000000000000000000000000;;			requestHeaderAuthenticator, err := headerrequest.NewSecure(
0000000000000000000000000000000000000000;;				config.RequestHeaderConfig.ClientCA,
0000000000000000000000000000000000000000;;				config.RequestHeaderConfig.AllowedClientNames,
0000000000000000000000000000000000000000;;				config.RequestHeaderConfig.UsernameHeaders,
0000000000000000000000000000000000000000;;				config.RequestHeaderConfig.GroupHeaders,
0000000000000000000000000000000000000000;;				config.RequestHeaderConfig.ExtraHeaderPrefixes,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, requestHeaderAuthenticator)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.BasicAuthFile) > 0 {
0000000000000000000000000000000000000000;;			basicAuth, err := newAuthenticatorFromBasicAuthFile(config.BasicAuthFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, basicAuth)
0000000000000000000000000000000000000000;;			hasBasicAuth = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.KeystoneURL) > 0 {
0000000000000000000000000000000000000000;;			keystoneAuth, err := newAuthenticatorFromKeystoneURL(config.KeystoneURL, config.KeystoneCAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, keystoneAuth)
0000000000000000000000000000000000000000;;			hasBasicAuth = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// X509 methods
0000000000000000000000000000000000000000;;		if len(config.ClientCAFile) > 0 {
0000000000000000000000000000000000000000;;			certAuth, err := newAuthenticatorFromClientCAFile(config.ClientCAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, certAuth)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bearer token methods, local first, then remote
0000000000000000000000000000000000000000;;		if len(config.TokenAuthFile) > 0 {
0000000000000000000000000000000000000000;;			tokenAuth, err := newAuthenticatorFromTokenFile(config.TokenAuthFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))
0000000000000000000000000000000000000000;;			hasTokenAuth = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.ServiceAccountKeyFiles) > 0 {
0000000000000000000000000000000000000000;;			serviceAccountAuth, err := newServiceAccountAuthenticator(config.ServiceAccountKeyFiles, config.ServiceAccountLookup, config.ServiceAccountTokenGetter)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, bearertoken.New(serviceAccountAuth), websocket.NewProtocolAuthenticator(serviceAccountAuth))
0000000000000000000000000000000000000000;;			hasTokenAuth = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.BootstrapToken {
0000000000000000000000000000000000000000;;			if config.BootstrapTokenAuthenticator != nil {
0000000000000000000000000000000000000000;;				// TODO: This can sometimes be nil because of
0000000000000000000000000000000000000000;;				authenticators = append(authenticators, bearertoken.New(config.BootstrapTokenAuthenticator), websocket.NewProtocolAuthenticator(config.BootstrapTokenAuthenticator))
0000000000000000000000000000000000000000;;				hasTokenAuth = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// NOTE(ericchiang): Keep the OpenID Connect after Service Accounts.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Because both plugins verify JWTs whichever comes first in the union experiences
0000000000000000000000000000000000000000;;		// cache misses for all requests using the other. While the service account plugin
0000000000000000000000000000000000000000;;		// simply returns an error, the OpenID Connect plugin may query the provider to
0000000000000000000000000000000000000000;;		// update the keys, causing performance hits.
0000000000000000000000000000000000000000;;		if len(config.OIDCIssuerURL) > 0 && len(config.OIDCClientID) > 0 {
0000000000000000000000000000000000000000;;			oidcAuth, err := newAuthenticatorFromOIDCIssuerURL(config.OIDCIssuerURL, config.OIDCClientID, config.OIDCCAFile, config.OIDCUsernameClaim, config.OIDCGroupsClaim)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, bearertoken.New(oidcAuth), websocket.NewProtocolAuthenticator(oidcAuth))
0000000000000000000000000000000000000000;;			hasTokenAuth = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.WebhookTokenAuthnConfigFile) > 0 {
0000000000000000000000000000000000000000;;			webhookTokenAuth, err := newWebhookTokenAuthenticator(config.WebhookTokenAuthnConfigFile, config.WebhookTokenAuthnCacheTTL)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, bearertoken.New(webhookTokenAuth), websocket.NewProtocolAuthenticator(webhookTokenAuth))
0000000000000000000000000000000000000000;;			hasTokenAuth = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always add anytoken last, so that every other token authenticator gets to try first
0000000000000000000000000000000000000000;;		if config.AnyToken {
0000000000000000000000000000000000000000;;			authenticators = append(authenticators, bearertoken.New(anytoken.AnyTokenAuthenticator{}), websocket.NewProtocolAuthenticator(anytoken.AnyTokenAuthenticator{}))
0000000000000000000000000000000000000000;;			hasTokenAuth = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasBasicAuth {
0000000000000000000000000000000000000000;;			securityDefinitions["HTTPBasic"] = &spec.SecurityScheme{
0000000000000000000000000000000000000000;;				SecuritySchemeProps: spec.SecuritySchemeProps{
0000000000000000000000000000000000000000;;					Type:        "basic",
0000000000000000000000000000000000000000;;					Description: "HTTP Basic authentication",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasTokenAuth {
0000000000000000000000000000000000000000;;			securityDefinitions["BearerToken"] = &spec.SecurityScheme{
0000000000000000000000000000000000000000;;				SecuritySchemeProps: spec.SecuritySchemeProps{
0000000000000000000000000000000000000000;;					Type:        "apiKey",
0000000000000000000000000000000000000000;;					Name:        "authorization",
0000000000000000000000000000000000000000;;					In:          "header",
0000000000000000000000000000000000000000;;					Description: "Bearer Token authentication",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(authenticators) == 0 {
0000000000000000000000000000000000000000;;			if config.Anonymous {
0000000000000000000000000000000000000000;;				return anonymous.NewAuthenticator(), &securityDefinitions, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(authenticators) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return nil, &securityDefinitions, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticator := union.New(authenticators...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authenticator = group.NewAuthenticatedGroupAdder(authenticator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.Anonymous {
0000000000000000000000000000000000000000;;			// If the authenticator chain returns an error, return an error (don't consider a bad bearer token
0000000000000000000000000000000000000000;;			// or invalid username/password combination anonymous).
0000000000000000000000000000000000000000;;			authenticator = union.NewFailOnError(authenticator, anonymous.NewAuthenticator())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return authenticator, &securityDefinitions, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidServiceAccountKeyFile returns true if a valid public RSA key can be read from the given file
0000000000000000000000000000000000000000;;	func IsValidServiceAccountKeyFile(file string) bool {
0000000000000000000000000000000000000000;;		_, err := serviceaccount.ReadPublicKeys(file)
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAuthenticatorFromBasicAuthFile returns an authenticator.Request or an error
0000000000000000000000000000000000000000;;	func newAuthenticatorFromBasicAuthFile(basicAuthFile string) (authenticator.Request, error) {
0000000000000000000000000000000000000000;;		basicAuthenticator, err := passwordfile.NewCSV(basicAuthFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return basicauth.New(basicAuthenticator), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAuthenticatorFromTokenFile returns an authenticator.Request or an error
0000000000000000000000000000000000000000;;	func newAuthenticatorFromTokenFile(tokenAuthFile string) (authenticator.Token, error) {
0000000000000000000000000000000000000000;;		tokenAuthenticator, err := tokenfile.NewCSV(tokenAuthFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tokenAuthenticator, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAuthenticatorFromOIDCIssuerURL returns an authenticator.Request or an error.
0000000000000000000000000000000000000000;;	func newAuthenticatorFromOIDCIssuerURL(issuerURL, clientID, caFile, usernameClaim, groupsClaim string) (authenticator.Token, error) {
0000000000000000000000000000000000000000;;		tokenAuthenticator, err := oidc.New(oidc.OIDCOptions{
0000000000000000000000000000000000000000;;			IssuerURL:     issuerURL,
0000000000000000000000000000000000000000;;			ClientID:      clientID,
0000000000000000000000000000000000000000;;			CAFile:        caFile,
0000000000000000000000000000000000000000;;			UsernameClaim: usernameClaim,
0000000000000000000000000000000000000000;;			GroupsClaim:   groupsClaim,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tokenAuthenticator, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newServiceAccountAuthenticator returns an authenticator.Request or an error
0000000000000000000000000000000000000000;;	func newServiceAccountAuthenticator(keyfiles []string, lookup bool, serviceAccountGetter serviceaccount.ServiceAccountTokenGetter) (authenticator.Token, error) {
0000000000000000000000000000000000000000;;		allPublicKeys := []interface{}{}
0000000000000000000000000000000000000000;;		for _, keyfile := range keyfiles {
0000000000000000000000000000000000000000;;			publicKeys, err := serviceaccount.ReadPublicKeys(keyfile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allPublicKeys = append(allPublicKeys, publicKeys...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenAuthenticator := serviceaccount.JWTTokenAuthenticator(allPublicKeys, lookup, serviceAccountGetter)
0000000000000000000000000000000000000000;;		return tokenAuthenticator, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAuthenticatorFromClientCAFile returns an authenticator.Request or an error
0000000000000000000000000000000000000000;;	func newAuthenticatorFromClientCAFile(clientCAFile string) (authenticator.Request, error) {
0000000000000000000000000000000000000000;;		roots, err := certutil.NewPool(clientCAFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := x509.DefaultVerifyOptions()
0000000000000000000000000000000000000000;;		opts.Roots = roots
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return x509.New(opts, x509.CommonNameUserConversion), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newAuthenticatorFromKeystoneURL returns an authenticator.Request or an error
0000000000000000000000000000000000000000;;	func newAuthenticatorFromKeystoneURL(keystoneURL string, keystoneCAFile string) (authenticator.Request, error) {
0000000000000000000000000000000000000000;;		keystoneAuthenticator, err := keystone.NewKeystoneAuthenticator(keystoneURL, keystoneCAFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return basicauth.New(keystoneAuthenticator), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWebhookTokenAuthenticator(webhookConfigFile string, ttl time.Duration) (authenticator.Token, error) {
0000000000000000000000000000000000000000;;		webhookTokenAuthenticator, err := webhook.New(webhookConfigFile, ttl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return webhookTokenAuthenticator, nil
0000000000000000000000000000000000000000;;	}
