0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
75d24ec01a9bf21c11e6217a4686a76a4bd8e805;pkg/kubectl/custom_column_printer.go[pkg/kubectl/custom_column_printer.go][pkg/printers/customcolumn.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package printers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/jsonpath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		columnwidth       = 10
0000000000000000000000000000000000000000;;		tabwidth          = 4
0000000000000000000000000000000000000000;;		padding           = 3
0000000000000000000000000000000000000000;;		padding_character = ' '
0000000000000000000000000000000000000000;;		flags             = 0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var jsonRegexp = regexp.MustCompile("^\\{\\.?([^{}]+)\\}$|^\\.?([^{}]+)$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RelaxedJSONPathExpression attempts to be flexible with JSONPath expressions, it accepts:
0000000000000000000000000000000000000000;;	//   * metadata.name (no leading '.' or curly brances '{...}'
0000000000000000000000000000000000000000;;	//   * {metadata.name} (no leading '.')
0000000000000000000000000000000000000000;;	//   * .metadata.name (no curly braces '{...}')
0000000000000000000000000000000000000000;;	//   * {.metadata.name} (complete expression)
0000000000000000000000000000000000000000;;	// And transforms them all into a valid jsonpath expression:
0000000000000000000000000000000000000000;;	//   {.metadata.name}
0000000000000000000000000000000000000000;;	func RelaxedJSONPathExpression(pathExpression string) (string, error) {
0000000000000000000000000000000000000000;;		if len(pathExpression) == 0 {
0000000000000000000000000000000000000000;;			return pathExpression, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		submatches := jsonRegexp.FindStringSubmatch(pathExpression)
0000000000000000000000000000000000000000;;		if submatches == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected path string, expected a 'name1.name2' or '.name1.name2' or '{name1.name2}' or '{.name1.name2}'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(submatches) != 3 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unexpected submatch list: %v", submatches)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var fieldSpec string
0000000000000000000000000000000000000000;;		if len(submatches[1]) != 0 {
0000000000000000000000000000000000000000;;			fieldSpec = submatches[1]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fieldSpec = submatches[2]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("{.%s}", fieldSpec), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCustomColumnsPrinterFromSpec creates a custom columns printer from a comma separated list of <header>:<jsonpath-field-spec> pairs.
0000000000000000000000000000000000000000;;	// e.g. NAME:metadata.name,API_VERSION:apiVersion creates a printer that prints:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      NAME               API_VERSION
0000000000000000000000000000000000000000;;	//      foo                bar
0000000000000000000000000000000000000000;;	func NewCustomColumnsPrinterFromSpec(spec string, decoder runtime.Decoder, noHeaders bool) (*CustomColumnsPrinter, error) {
0000000000000000000000000000000000000000;;		if len(spec) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("custom-columns format specified but no custom columns given")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.Split(spec, ",")
0000000000000000000000000000000000000000;;		columns := make([]Column, len(parts))
0000000000000000000000000000000000000000;;		for ix := range parts {
0000000000000000000000000000000000000000;;			colSpec := strings.Split(parts[ix], ":")
0000000000000000000000000000000000000000;;			if len(colSpec) != 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected custom-columns spec: %s, expected <header>:<json-path-expr>", parts[ix])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			spec, err := RelaxedJSONPathExpression(colSpec[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			columns[ix] = Column{Header: colSpec[0], FieldSpec: spec}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &CustomColumnsPrinter{Columns: columns, Decoder: decoder, NoHeaders: noHeaders}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func splitOnWhitespace(line string) []string {
0000000000000000000000000000000000000000;;		lineScanner := bufio.NewScanner(bytes.NewBufferString(line))
0000000000000000000000000000000000000000;;		lineScanner.Split(bufio.ScanWords)
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for lineScanner.Scan() {
0000000000000000000000000000000000000000;;			result = append(result, lineScanner.Text())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCustomColumnsPrinterFromTemplate creates a custom columns printer from a template stream.  The template is expected
0000000000000000000000000000000000000000;;	// to consist of two lines, whitespace separated.  The first line is the header line, the second line is the jsonpath field spec
0000000000000000000000000000000000000000;;	// For example, the template below:
0000000000000000000000000000000000000000;;	// NAME               API_VERSION
0000000000000000000000000000000000000000;;	// {metadata.name}    {apiVersion}
0000000000000000000000000000000000000000;;	func NewCustomColumnsPrinterFromTemplate(templateReader io.Reader, decoder runtime.Decoder) (*CustomColumnsPrinter, error) {
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(templateReader)
0000000000000000000000000000000000000000;;		if !scanner.Scan() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid template, missing header line. Expected format is one line of space separated headers, one line of space separated column specs.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := splitOnWhitespace(scanner.Text())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !scanner.Scan() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid template, missing spec line. Expected format is one line of space separated headers, one line of space separated column specs.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		specs := splitOnWhitespace(scanner.Text())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(headers) != len(specs) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("number of headers (%d) and field specifications (%d) don't match", len(headers), len(specs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		columns := make([]Column, len(headers))
0000000000000000000000000000000000000000;;		for ix := range headers {
0000000000000000000000000000000000000000;;			spec, err := RelaxedJSONPathExpression(specs[ix])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			columns[ix] = Column{
0000000000000000000000000000000000000000;;				Header:    headers[ix],
0000000000000000000000000000000000000000;;				FieldSpec: spec,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &CustomColumnsPrinter{Columns: columns, Decoder: decoder, NoHeaders: false}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Column represents a user specified column
0000000000000000000000000000000000000000;;	type Column struct {
0000000000000000000000000000000000000000;;		// The header to print above the column, general style is ALL_CAPS
0000000000000000000000000000000000000000;;		Header string
0000000000000000000000000000000000000000;;		// The pointer to the field in the object to print in JSONPath form
0000000000000000000000000000000000000000;;		// e.g. {.ObjectMeta.Name}, see pkg/util/jsonpath for more details.
0000000000000000000000000000000000000000;;		FieldSpec string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CustomColumnPrinter is a printer that knows how to print arbitrary columns
0000000000000000000000000000000000000000;;	// of data from templates specified in the `Columns` array
0000000000000000000000000000000000000000;;	type CustomColumnsPrinter struct {
0000000000000000000000000000000000000000;;		Columns   []Column
0000000000000000000000000000000000000000;;		Decoder   runtime.Decoder
0000000000000000000000000000000000000000;;		NoHeaders bool
0000000000000000000000000000000000000000;;		// lastType records type of resource printed last so that we don't repeat
0000000000000000000000000000000000000000;;		// header while printing same type of resources.
0000000000000000000000000000000000000000;;		lastType reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CustomColumnsPrinter) AfterPrint(w io.Writer, res string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CustomColumnsPrinter) PrintObj(obj runtime.Object, out io.Writer) error {
0000000000000000000000000000000000000000;;		w := tabwriter.NewWriter(out, columnwidth, tabwidth, padding, padding_character, flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		if !s.NoHeaders && t != s.lastType {
0000000000000000000000000000000000000000;;			headers := make([]string, len(s.Columns))
0000000000000000000000000000000000000000;;			for ix := range s.Columns {
0000000000000000000000000000000000000000;;				headers[ix] = s.Columns[ix].Header
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintln(w, strings.Join(headers, "\t"))
0000000000000000000000000000000000000000;;			s.lastType = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parsers := make([]*jsonpath.JSONPath, len(s.Columns))
0000000000000000000000000000000000000000;;		for ix := range s.Columns {
0000000000000000000000000000000000000000;;			parsers[ix] = jsonpath.New(fmt.Sprintf("column%d", ix))
0000000000000000000000000000000000000000;;			if err := parsers[ix].Parse(s.Columns[ix].FieldSpec); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if meta.IsListType(obj) {
0000000000000000000000000000000000000000;;			objs, err := meta.ExtractList(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for ix := range objs {
0000000000000000000000000000000000000000;;				if err := s.printOneObject(objs[ix], parsers, w); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err := s.printOneObject(obj, parsers, w); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CustomColumnsPrinter) printOneObject(obj runtime.Object, parsers []*jsonpath.JSONPath, out io.Writer) error {
0000000000000000000000000000000000000000;;		columns := make([]string, len(parsers))
0000000000000000000000000000000000000000;;		switch u := obj.(type) {
0000000000000000000000000000000000000000;;		case *runtime.Unknown:
0000000000000000000000000000000000000000;;			if len(u.Raw) > 0 {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if obj, err = runtime.Decode(s.Decoder, u.Raw); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("can't decode object for printing: %v (%s)", err, u.Raw)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ix := range parsers {
0000000000000000000000000000000000000000;;			parser := parsers[ix]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var values [][]reflect.Value
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if unstructured, ok := obj.(runtime.Unstructured); ok {
0000000000000000000000000000000000000000;;				values, err = parser.FindResults(unstructured.UnstructuredContent())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				values, err = parser.FindResults(reflect.ValueOf(obj).Elem().Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(values) == 0 || len(values[0]) == 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "<none>\t")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			valueStrings := []string{}
0000000000000000000000000000000000000000;;			for arrIx := range values {
0000000000000000000000000000000000000000;;				for valIx := range values[arrIx] {
0000000000000000000000000000000000000000;;					valueStrings = append(valueStrings, fmt.Sprintf("%v", values[arrIx][valIx].Interface()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			columns[ix] = strings.Join(valueStrings, ",")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(out, strings.Join(columns, "\t"))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CustomColumnsPrinter) HandledResources() []string {
0000000000000000000000000000000000000000;;		return []string{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CustomColumnsPrinter) IsGeneric() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
