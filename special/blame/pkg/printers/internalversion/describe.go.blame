0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
109abe04daa011acab1be0d57acf1b4cc20aaf7d;pkg/kubectl/describe.go[pkg/kubectl/describe.go][pkg/printers/internalversion/describe.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package internalversion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/fatih/camelcase"
0000000000000000000000000000000000000000;;		versionedextension "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/dynamic"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/federation/apis/federation"
0000000000000000000000000000000000000000;;		fedclientset "k8s.io/kubernetes/federation/client/clientset_generated/federation_internalclientset"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/events"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/helper/qos"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/ref"
0000000000000000000000000000000000000000;;		resourcehelper "k8s.io/kubernetes/pkg/api/resource"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/autoscaling"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/certificates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/networking"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/policy"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/storage"
0000000000000000000000000000000000000000;;		storageutil "k8s.io/kubernetes/pkg/apis/storage/util"
0000000000000000000000000000000000000000;;		versionedclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		coreclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		extensionsclientset "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/extensions/v1beta1"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;		deploymentutil "k8s.io/kubernetes/pkg/controller/deployment/util"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/fieldpath"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/rbac/validation"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/slice"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Each level has 2 spaces for PrefixWriter
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LEVEL_0 = iota
0000000000000000000000000000000000000000;;		LEVEL_1
0000000000000000000000000000000000000000;;		LEVEL_2
0000000000000000000000000000000000000000;;		LEVEL_3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrefixWriter can write text at various indentation levels.
0000000000000000000000000000000000000000;;	type PrefixWriter interface {
0000000000000000000000000000000000000000;;		// Write writes text with the specified indentation level.
0000000000000000000000000000000000000000;;		Write(level int, format string, a ...interface{})
0000000000000000000000000000000000000000;;		// WriteLine writes an entire line with no indentation level.
0000000000000000000000000000000000000000;;		WriteLine(a ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prefixWriter implements PrefixWriter
0000000000000000000000000000000000000000;;	type prefixWriter struct {
0000000000000000000000000000000000000000;;		out io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ PrefixWriter = &prefixWriter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPrefixWriter creates a new PrefixWriter.
0000000000000000000000000000000000000000;;	func NewPrefixWriter(out io.Writer) PrefixWriter {
0000000000000000000000000000000000000000;;		return &prefixWriter{out: out}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pw *prefixWriter) Write(level int, format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		levelSpace := "  "
0000000000000000000000000000000000000000;;		prefix := ""
0000000000000000000000000000000000000000;;		for i := 0; i < level; i++ {
0000000000000000000000000000000000000000;;			prefix += levelSpace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(pw.out, prefix+format, a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pw *prefixWriter) WriteLine(a ...interface{}) {
0000000000000000000000000000000000000000;;		fmt.Fprintln(pw.out, a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describerMap(c clientset.Interface) map[schema.GroupKind]printers.Describer {
0000000000000000000000000000000000000000;;		m := map[schema.GroupKind]printers.Describer{
0000000000000000000000000000000000000000;;			api.Kind("Pod"):                   &PodDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("ReplicationController"): &ReplicationControllerDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("Secret"):                &SecretDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("Service"):               &ServiceDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("ServiceAccount"):        &ServiceAccountDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("Node"):                  &NodeDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("LimitRange"):            &LimitRangeDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("ResourceQuota"):         &ResourceQuotaDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("PersistentVolume"):      &PersistentVolumeDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("PersistentVolumeClaim"): &PersistentVolumeClaimDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("Namespace"):             &NamespaceDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("Endpoints"):             &EndpointsDescriber{c},
0000000000000000000000000000000000000000;;			api.Kind("ConfigMap"):             &ConfigMapDescriber{c},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			extensions.Kind("ReplicaSet"):                  &ReplicaSetDescriber{c},
0000000000000000000000000000000000000000;;			extensions.Kind("NetworkPolicy"):               &ExtensionsNetworkPolicyDescriber{c},
0000000000000000000000000000000000000000;;			autoscaling.Kind("HorizontalPodAutoscaler"):    &HorizontalPodAutoscalerDescriber{c},
0000000000000000000000000000000000000000;;			extensions.Kind("DaemonSet"):                   &DaemonSetDescriber{c},
0000000000000000000000000000000000000000;;			extensions.Kind("Deployment"):                  &DeploymentDescriber{c, versionedClientsetForDeployment(c)},
0000000000000000000000000000000000000000;;			extensions.Kind("Ingress"):                     &IngressDescriber{c},
0000000000000000000000000000000000000000;;			batch.Kind("Job"):                              &JobDescriber{c},
0000000000000000000000000000000000000000;;			batch.Kind("CronJob"):                          &CronJobDescriber{c},
0000000000000000000000000000000000000000;;			apps.Kind("StatefulSet"):                       &StatefulSetDescriber{c},
0000000000000000000000000000000000000000;;			apps.Kind("Deployment"):                        &DeploymentDescriber{c, versionedClientsetForDeployment(c)},
0000000000000000000000000000000000000000;;			certificates.Kind("CertificateSigningRequest"): &CertificateSigningRequestDescriber{c},
0000000000000000000000000000000000000000;;			storage.Kind("StorageClass"):                   &StorageClassDescriber{c},
0000000000000000000000000000000000000000;;			policy.Kind("PodDisruptionBudget"):             &PodDisruptionBudgetDescriber{c},
0000000000000000000000000000000000000000;;			rbac.Kind("Role"):                              &RoleDescriber{c},
0000000000000000000000000000000000000000;;			rbac.Kind("ClusterRole"):                       &ClusterRoleDescriber{c},
0000000000000000000000000000000000000000;;			rbac.Kind("RoleBinding"):                       &RoleBindingDescriber{c},
0000000000000000000000000000000000000000;;			rbac.Kind("ClusterRoleBinding"):                &ClusterRoleBindingDescriber{c},
0000000000000000000000000000000000000000;;			networking.Kind("NetworkPolicy"):               &NetworkPolicyDescriber{c},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DescribableResources lists all resource types we can describe.
0000000000000000000000000000000000000000;;	func DescribableResources() []string {
0000000000000000000000000000000000000000;;		keys := make([]string, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := range describerMap(nil) {
0000000000000000000000000000000000000000;;			resource := strings.ToLower(k.Kind)
0000000000000000000000000000000000000000;;			keys = append(keys, resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DescriberFor returns the default describe functions for each of the standard
0000000000000000000000000000000000000000;;	// Kubernetes types.
0000000000000000000000000000000000000000;;	func DescriberFor(kind schema.GroupKind, c clientset.Interface) (printers.Describer, bool) {
0000000000000000000000000000000000000000;;		f, ok := describerMap(c)[kind]
0000000000000000000000000000000000000000;;		return f, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenericDescriberFor returns a generic describer for the specified mapping
0000000000000000000000000000000000000000;;	// that uses only information available from runtime.Unstructured
0000000000000000000000000000000000000000;;	func GenericDescriberFor(mapping *meta.RESTMapping, dynamic *dynamic.Client, events coreclient.EventsGetter) printers.Describer {
0000000000000000000000000000000000000000;;		return &genericDescriber{mapping, dynamic, events}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genericDescriber struct {
0000000000000000000000000000000000000000;;		mapping *meta.RESTMapping
0000000000000000000000000000000000000000;;		dynamic *dynamic.Client
0000000000000000000000000000000000000000;;		events  coreclient.EventsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genericDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (output string, err error) {
0000000000000000000000000000000000000000;;		apiResource := &metav1.APIResource{
0000000000000000000000000000000000000000;;			Name:       g.mapping.Resource,
0000000000000000000000000000000000000000;;			Namespaced: g.mapping.Scope.Name() == meta.RESTScopeNameNamespace,
0000000000000000000000000000000000000000;;			Kind:       g.mapping.GroupVersionKind.Kind,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, err := g.dynamic.Resource(apiResource, namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = g.events.Events(namespace).Search(api.Scheme, obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", obj.GetName())
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", obj.GetNamespace())
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", obj.GetLabels())
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", obj.GetAnnotations())
0000000000000000000000000000000000000000;;			printUnstructuredContent(w, LEVEL_0, obj.UnstructuredContent(), "", ".metadata.name", ".metadata.namespace", ".metadata.labels", ".metadata.annotations")
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printUnstructuredContent(w PrefixWriter, level int, content map[string]interface{}, skipPrefix string, skip ...string) {
0000000000000000000000000000000000000000;;		fields := []string{}
0000000000000000000000000000000000000000;;		for field := range content {
0000000000000000000000000000000000000000;;			fields = append(fields, field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(fields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, field := range fields {
0000000000000000000000000000000000000000;;			value := content[field]
0000000000000000000000000000000000000000;;			switch typedValue := value.(type) {
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				skipExpr := fmt.Sprintf("%s.%s", skipPrefix, field)
0000000000000000000000000000000000000000;;				if slice.ContainsString(skip, skipExpr, nil) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(level, "%s:\n", smartLabelFor(field))
0000000000000000000000000000000000000000;;				printUnstructuredContent(w, level+1, typedValue, skipExpr, skip...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case []interface{}:
0000000000000000000000000000000000000000;;				skipExpr := fmt.Sprintf("%s.%s", skipPrefix, field)
0000000000000000000000000000000000000000;;				if slice.ContainsString(skip, skipExpr, nil) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(level, "%s:\n", smartLabelFor(field))
0000000000000000000000000000000000000000;;				for _, child := range typedValue {
0000000000000000000000000000000000000000;;					switch typedChild := child.(type) {
0000000000000000000000000000000000000000;;					case map[string]interface{}:
0000000000000000000000000000000000000000;;						printUnstructuredContent(w, level+1, typedChild, skipExpr, skip...)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						w.Write(level+1, "%v\n", typedChild)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				skipExpr := fmt.Sprintf("%s.%s", skipPrefix, field)
0000000000000000000000000000000000000000;;				if slice.ContainsString(skip, skipExpr, nil) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(level, "%s:\t%v\n", smartLabelFor(field), typedValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartLabelFor(field string) string {
0000000000000000000000000000000000000000;;		commonAcronyms := []string{"API", "URL", "UID", "OSB", "GUID"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		splitted := camelcase.Split(field)
0000000000000000000000000000000000000000;;		for i := 0; i < len(splitted); i++ {
0000000000000000000000000000000000000000;;			part := splitted[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if slice.ContainsString(commonAcronyms, strings.ToUpper(part), nil) {
0000000000000000000000000000000000000000;;				part = strings.ToUpper(part)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				part = strings.Title(part)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			splitted[i] = part
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(splitted, " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultObjectDescriber can describe the default Kubernetes objects.
0000000000000000000000000000000000000000;;	var DefaultObjectDescriber printers.ObjectDescriber
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		d := &Describers{}
0000000000000000000000000000000000000000;;		err := d.Add(
0000000000000000000000000000000000000000;;			describeLimitRange,
0000000000000000000000000000000000000000;;			describeQuota,
0000000000000000000000000000000000000000;;			describePod,
0000000000000000000000000000000000000000;;			describeService,
0000000000000000000000000000000000000000;;			describeReplicationController,
0000000000000000000000000000000000000000;;			describeDaemonSet,
0000000000000000000000000000000000000000;;			describeNode,
0000000000000000000000000000000000000000;;			describeNamespace,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Cannot register describers: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		DefaultObjectDescriber = d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceDescriber generates information about a namespace
0000000000000000000000000000000000000000;;	type NamespaceDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *NamespaceDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		ns, err := d.Core().Namespaces().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceQuotaList, err := d.Core().ResourceQuotas(name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// Server does not support resource quotas.
0000000000000000000000000000000000000000;;				// Not an error, will not show resource quotas information.
0000000000000000000000000000000000000000;;				resourceQuotaList = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		limitRangeList, err := d.Core().LimitRanges(name).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				// Server does not support limit ranges.
0000000000000000000000000000000000000000;;				// Not an error, will not show limit ranges information.
0000000000000000000000000000000000000000;;				limitRangeList = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return describeNamespace(ns, resourceQuotaList, limitRangeList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeNamespace(namespace *api.Namespace, resourceQuotaList *api.ResourceQuotaList, limitRangeList *api.LimitRangeList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", namespace.Name)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", namespace.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", namespace.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Status:\t%s\n", string(namespace.Status.Phase))
0000000000000000000000000000000000000000;;			if resourceQuotaList != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "\n")
0000000000000000000000000000000000000000;;				DescribeResourceQuotas(resourceQuotaList, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if limitRangeList != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "\n")
0000000000000000000000000000000000000000;;				DescribeLimitRanges(limitRangeList, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeLimitRangeSpec(spec api.LimitRangeSpec, prefix string, w PrefixWriter) {
0000000000000000000000000000000000000000;;		for i := range spec.Limits {
0000000000000000000000000000000000000000;;			item := spec.Limits[i]
0000000000000000000000000000000000000000;;			maxResources := item.Max
0000000000000000000000000000000000000000;;			minResources := item.Min
0000000000000000000000000000000000000000;;			defaultLimitResources := item.Default
0000000000000000000000000000000000000000;;			defaultRequestResources := item.DefaultRequest
0000000000000000000000000000000000000000;;			ratio := item.MaxLimitRequestRatio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			set := map[api.ResourceName]bool{}
0000000000000000000000000000000000000000;;			for k := range maxResources {
0000000000000000000000000000000000000000;;				set[k] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k := range minResources {
0000000000000000000000000000000000000000;;				set[k] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k := range defaultLimitResources {
0000000000000000000000000000000000000000;;				set[k] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k := range defaultRequestResources {
0000000000000000000000000000000000000000;;				set[k] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k := range ratio {
0000000000000000000000000000000000000000;;				set[k] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k := range set {
0000000000000000000000000000000000000000;;				// if no value is set, we output -
0000000000000000000000000000000000000000;;				maxValue := "-"
0000000000000000000000000000000000000000;;				minValue := "-"
0000000000000000000000000000000000000000;;				defaultLimitValue := "-"
0000000000000000000000000000000000000000;;				defaultRequestValue := "-"
0000000000000000000000000000000000000000;;				ratioValue := "-"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				maxQuantity, maxQuantityFound := maxResources[k]
0000000000000000000000000000000000000000;;				if maxQuantityFound {
0000000000000000000000000000000000000000;;					maxValue = maxQuantity.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				minQuantity, minQuantityFound := minResources[k]
0000000000000000000000000000000000000000;;				if minQuantityFound {
0000000000000000000000000000000000000000;;					minValue = minQuantity.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defaultLimitQuantity, defaultLimitQuantityFound := defaultLimitResources[k]
0000000000000000000000000000000000000000;;				if defaultLimitQuantityFound {
0000000000000000000000000000000000000000;;					defaultLimitValue = defaultLimitQuantity.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				defaultRequestQuantity, defaultRequestQuantityFound := defaultRequestResources[k]
0000000000000000000000000000000000000000;;				if defaultRequestQuantityFound {
0000000000000000000000000000000000000000;;					defaultRequestValue = defaultRequestQuantity.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ratioQuantity, ratioQuantityFound := ratio[k]
0000000000000000000000000000000000000000;;				if ratioQuantityFound {
0000000000000000000000000000000000000000;;					ratioValue = ratioQuantity.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				msg := "%s%s\t%v\t%v\t%v\t%v\t%v\t%v\n"
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, msg, prefix, item.Type, k, minValue, maxValue, defaultRequestValue, defaultLimitValue, ratioValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DescribeLimitRanges merges a set of limit range items into a single tabular description
0000000000000000000000000000000000000000;;	func DescribeLimitRanges(limitRanges *api.LimitRangeList, w PrefixWriter) {
0000000000000000000000000000000000000000;;		if len(limitRanges.Items) == 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "No resource limits.\n")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Resource Limits\n Type\tResource\tMin\tMax\tDefault Request\tDefault Limit\tMax Limit/Request Ratio\n")
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, " ----\t--------\t---\t---\t---------------\t-------------\t-----------------------\n")
0000000000000000000000000000000000000000;;		for _, limitRange := range limitRanges.Items {
0000000000000000000000000000000000000000;;			describeLimitRangeSpec(limitRange.Spec, " ", w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DescribeResourceQuotas merges a set of quota items into a single tabular description of all quotas
0000000000000000000000000000000000000000;;	func DescribeResourceQuotas(quotas *api.ResourceQuotaList, w PrefixWriter) {
0000000000000000000000000000000000000000;;		if len(quotas.Items) == 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "No resource quota.\n")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(SortableResourceQuotas(quotas.Items))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Resource Quotas")
0000000000000000000000000000000000000000;;		for _, q := range quotas.Items {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "\n Name:\t%s\n", q.Name)
0000000000000000000000000000000000000000;;			if len(q.Spec.Scopes) > 0 {
0000000000000000000000000000000000000000;;				scopes := make([]string, 0, len(q.Spec.Scopes))
0000000000000000000000000000000000000000;;				for _, scope := range q.Spec.Scopes {
0000000000000000000000000000000000000000;;					scopes = append(scopes, string(scope))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Strings(scopes)
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, " Scopes:\t%s\n", strings.Join(scopes, ", "))
0000000000000000000000000000000000000000;;				for _, scope := range scopes {
0000000000000000000000000000000000000000;;					helpText := helpTextForResourceQuotaScope(api.ResourceQuotaScope(scope))
0000000000000000000000000000000000000000;;					if len(helpText) > 0 {
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, "  * %s\n", helpText)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Resource\tUsed\tHard\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " --------\t---\t---\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resources := make([]api.ResourceName, 0, len(q.Status.Hard))
0000000000000000000000000000000000000000;;			for resource := range q.Status.Hard {
0000000000000000000000000000000000000000;;				resources = append(resources, resource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(SortableResourceNames(resources))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, resource := range resources {
0000000000000000000000000000000000000000;;				hardQuantity := q.Status.Hard[resource]
0000000000000000000000000000000000000000;;				usedQuantity := q.Status.Used[resource]
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, " %s\t%s\t%s\n", string(resource), usedQuantity.String(), hardQuantity.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRangeDescriber generates information about a limit range
0000000000000000000000000000000000000000;;	type LimitRangeDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *LimitRangeDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		lr := d.Core().LimitRanges(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		limitRange, err := lr.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return describeLimitRange(limitRange)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeLimitRange(limitRange *api.LimitRange) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", limitRange.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", limitRange.Namespace)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Type\tResource\tMin\tMax\tDefault Request\tDefault Limit\tMax Limit/Request Ratio\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "----\t--------\t---\t---\t---------------\t-------------\t-----------------------\n")
0000000000000000000000000000000000000000;;			describeLimitRangeSpec(limitRange.Spec, "", w)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuotaDescriber generates information about a resource quota
0000000000000000000000000000000000000000;;	type ResourceQuotaDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ResourceQuotaDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		rq := d.Core().ResourceQuotas(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceQuota, err := rq.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeQuota(resourceQuota)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func helpTextForResourceQuotaScope(scope api.ResourceQuotaScope) string {
0000000000000000000000000000000000000000;;		switch scope {
0000000000000000000000000000000000000000;;		case api.ResourceQuotaScopeTerminating:
0000000000000000000000000000000000000000;;			return "Matches all pods that have an active deadline. These pods have a limited lifespan on a node before being actively terminated by the system."
0000000000000000000000000000000000000000;;		case api.ResourceQuotaScopeNotTerminating:
0000000000000000000000000000000000000000;;			return "Matches all pods that do not have an active deadline. These pods usually include long running pods whose container command is not expected to terminate."
0000000000000000000000000000000000000000;;		case api.ResourceQuotaScopeBestEffort:
0000000000000000000000000000000000000000;;			return "Matches all pods that do not have resource requirements set. These pods have a best effort quality of service."
0000000000000000000000000000000000000000;;		case api.ResourceQuotaScopeNotBestEffort:
0000000000000000000000000000000000000000;;			return "Matches all pods that have at least one resource requirement set. These pods have a burstable or guaranteed quality of service."
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func describeQuota(resourceQuota *api.ResourceQuota) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", resourceQuota.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", resourceQuota.Namespace)
0000000000000000000000000000000000000000;;			if len(resourceQuota.Spec.Scopes) > 0 {
0000000000000000000000000000000000000000;;				scopes := make([]string, 0, len(resourceQuota.Spec.Scopes))
0000000000000000000000000000000000000000;;				for _, scope := range resourceQuota.Spec.Scopes {
0000000000000000000000000000000000000000;;					scopes = append(scopes, string(scope))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Strings(scopes)
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Scopes:\t%s\n", strings.Join(scopes, ", "))
0000000000000000000000000000000000000000;;				for _, scope := range scopes {
0000000000000000000000000000000000000000;;					helpText := helpTextForResourceQuotaScope(api.ResourceQuotaScope(scope))
0000000000000000000000000000000000000000;;					if len(helpText) > 0 {
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, " * %s\n", helpText)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Resource\tUsed\tHard\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "--------\t----\t----\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resources := make([]api.ResourceName, 0, len(resourceQuota.Status.Hard))
0000000000000000000000000000000000000000;;			for resource := range resourceQuota.Status.Hard {
0000000000000000000000000000000000000000;;				resources = append(resources, resource)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(SortableResourceNames(resources))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			msg := "%v\t%v\t%v\n"
0000000000000000000000000000000000000000;;			for i := range resources {
0000000000000000000000000000000000000000;;				resource := resources[i]
0000000000000000000000000000000000000000;;				hardQuantity := resourceQuota.Status.Hard[resource]
0000000000000000000000000000000000000000;;				usedQuantity := resourceQuota.Status.Used[resource]
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, msg, resource, usedQuantity.String(), hardQuantity.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodDescriber generates information about a pod and the replication controllers that
0000000000000000000000000000000000000000;;	// create it.
0000000000000000000000000000000000000000;;	type PodDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *PodDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		pod, err := d.Core().Pods(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;				eventsInterface := d.Core().Events(namespace)
0000000000000000000000000000000000000000;;				selector := eventsInterface.GetFieldSelector(&name, &namespace, nil, nil)
0000000000000000000000000000000000000000;;				options := metav1.ListOptions{FieldSelector: selector.String()}
0000000000000000000000000000000000000000;;				events, err2 := eventsInterface.List(options)
0000000000000000000000000000000000000000;;				if describerSettings.ShowEvents && err2 == nil && len(events.Items) > 0 {
0000000000000000000000000000000000000000;;					return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;						w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, "Pod '%v': error '%v', but found events.\n", name, err)
0000000000000000000000000000000000000000;;						DescribeEvents(events, w)
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			if ref, err := ref.GetReference(api.Scheme, pod); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to construct reference to '%#v': %v", pod, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ref.Kind = ""
0000000000000000000000000000000000000000;;				events, _ = d.Core().Events(namespace).Search(api.Scheme, ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describePod(pod, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describePod(pod *api.Pod, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", pod.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", pod.Namespace)
0000000000000000000000000000000000000000;;			if pod.Spec.NodeName == "" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Node:\t<none>\n")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Node:\t%s\n", pod.Spec.NodeName+"/"+pod.Status.HostIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.Status.StartTime != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Start Time:\t%s\n", pod.Status.StartTime.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", pod.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", pod.Annotations)
0000000000000000000000000000000000000000;;			if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Status:\tTerminating (expires %s)\n", pod.DeletionTimestamp.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Termination Grace Period:\t%ds\n", *pod.DeletionGracePeriodSeconds)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Status:\t%s\n", string(pod.Status.Phase))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pod.Status.Reason) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Reason:\t%s\n", pod.Status.Reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pod.Status.Message) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Message:\t%s\n", pod.Status.Message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "IP:\t%s\n", pod.Status.PodIP)
0000000000000000000000000000000000000000;;			if createdBy := printCreator(pod.Annotations); len(createdBy) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Created By:\t%s\n", createdBy)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if controlledBy := printController(pod); len(controlledBy) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Controlled By:\t%s\n", controlledBy)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(pod.Spec.InitContainers) > 0 {
0000000000000000000000000000000000000000;;				describeContainers("Init Containers", pod.Spec.InitContainers, pod.Status.InitContainerStatuses, EnvValueRetriever(pod), w, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			describeContainers("Containers", pod.Spec.Containers, pod.Status.ContainerStatuses, EnvValueRetriever(pod), w, "")
0000000000000000000000000000000000000000;;			if len(pod.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Conditions:\n  Type\tStatus\n")
0000000000000000000000000000000000000000;;				for _, c := range pod.Status.Conditions {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%v \t%v \n",
0000000000000000000000000000000000000000;;						c.Type,
0000000000000000000000000000000000000000;;						c.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			describeVolumes(pod.Spec.Volumes, w, "")
0000000000000000000000000000000000000000;;			if pod.Status.QOSClass != "" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "QoS Class:\t%s\n", pod.Status.QOSClass)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "QoS Class:\t%s\n", qos.GetPodQOS(pod))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Node-Selectors", pod.Spec.NodeSelector)
0000000000000000000000000000000000000000;;			printPodTolerationsMultiline(w, "Tolerations", pod.Spec.Tolerations)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printController(controllee metav1.Object) string {
0000000000000000000000000000000000000000;;		if controllerRef := controller.GetControllerOf(controllee); controllerRef != nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s/%s", controllerRef.Kind, controllerRef.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printCreator(annotation map[string]string) string {
0000000000000000000000000000000000000000;;		value, ok := annotation[api.CreatedByAnnotation]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			var r api.SerializedReference
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(value), &r)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("%s/%s", r.Reference.Kind, r.Reference.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeVolumes(volumes []api.Volume, w PrefixWriter, space string) {
0000000000000000000000000000000000000000;;		if volumes == nil || len(volumes) == 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "%sVolumes:\t<none>\n", space)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "%sVolumes:\n", space)
0000000000000000000000000000000000000000;;		for _, volume := range volumes {
0000000000000000000000000000000000000000;;			nameIndent := ""
0000000000000000000000000000000000000000;;			if len(space) > 0 {
0000000000000000000000000000000000000000;;				nameIndent = " "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "%s%v:\n", nameIndent, volume.Name)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case volume.VolumeSource.HostPath != nil:
0000000000000000000000000000000000000000;;				printHostPathVolumeSource(volume.VolumeSource.HostPath, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.EmptyDir != nil:
0000000000000000000000000000000000000000;;				printEmptyDirVolumeSource(volume.VolumeSource.EmptyDir, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.GCEPersistentDisk != nil:
0000000000000000000000000000000000000000;;				printGCEPersistentDiskVolumeSource(volume.VolumeSource.GCEPersistentDisk, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.AWSElasticBlockStore != nil:
0000000000000000000000000000000000000000;;				printAWSElasticBlockStoreVolumeSource(volume.VolumeSource.AWSElasticBlockStore, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.GitRepo != nil:
0000000000000000000000000000000000000000;;				printGitRepoVolumeSource(volume.VolumeSource.GitRepo, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.Secret != nil:
0000000000000000000000000000000000000000;;				printSecretVolumeSource(volume.VolumeSource.Secret, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.ConfigMap != nil:
0000000000000000000000000000000000000000;;				printConfigMapVolumeSource(volume.VolumeSource.ConfigMap, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.NFS != nil:
0000000000000000000000000000000000000000;;				printNFSVolumeSource(volume.VolumeSource.NFS, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.ISCSI != nil:
0000000000000000000000000000000000000000;;				printISCSIVolumeSource(volume.VolumeSource.ISCSI, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.Glusterfs != nil:
0000000000000000000000000000000000000000;;				printGlusterfsVolumeSource(volume.VolumeSource.Glusterfs, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.PersistentVolumeClaim != nil:
0000000000000000000000000000000000000000;;				printPersistentVolumeClaimVolumeSource(volume.VolumeSource.PersistentVolumeClaim, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.RBD != nil:
0000000000000000000000000000000000000000;;				printRBDVolumeSource(volume.VolumeSource.RBD, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.Quobyte != nil:
0000000000000000000000000000000000000000;;				printQuobyteVolumeSource(volume.VolumeSource.Quobyte, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.DownwardAPI != nil:
0000000000000000000000000000000000000000;;				printDownwardAPIVolumeSource(volume.VolumeSource.DownwardAPI, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.AzureDisk != nil:
0000000000000000000000000000000000000000;;				printAzureDiskVolumeSource(volume.VolumeSource.AzureDisk, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.VsphereVolume != nil:
0000000000000000000000000000000000000000;;				printVsphereVolumeSource(volume.VolumeSource.VsphereVolume, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.Cinder != nil:
0000000000000000000000000000000000000000;;				printCinderVolumeSource(volume.VolumeSource.Cinder, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.PhotonPersistentDisk != nil:
0000000000000000000000000000000000000000;;				printPhotonPersistentDiskVolumeSource(volume.VolumeSource.PhotonPersistentDisk, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.PortworxVolume != nil:
0000000000000000000000000000000000000000;;				printPortworxVolumeSource(volume.VolumeSource.PortworxVolume, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.ScaleIO != nil:
0000000000000000000000000000000000000000;;				printScaleIOVolumeSource(volume.VolumeSource.ScaleIO, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.CephFS != nil:
0000000000000000000000000000000000000000;;				printCephFSVolumeSource(volume.VolumeSource.CephFS, w)
0000000000000000000000000000000000000000;;			case volume.VolumeSource.StorageOS != nil:
0000000000000000000000000000000000000000;;				printStorageOSVolumeSource(volume.VolumeSource.StorageOS, w)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "<unknown>\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printHostPathVolumeSource(hostPath *api.HostPathVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tHostPath (bare host directory volume)\n"+
0000000000000000000000000000000000000000;;			"    Path:\t%v\n", hostPath.Path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printEmptyDirVolumeSource(emptyDir *api.EmptyDirVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tEmptyDir (a temporary directory that shares a pod's lifetime)\n"+
0000000000000000000000000000000000000000;;			"    Medium:\t%v\n", emptyDir.Medium)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printGCEPersistentDiskVolumeSource(gce *api.GCEPersistentDiskVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tGCEPersistentDisk (a Persistent Disk resource in Google Compute Engine)\n"+
0000000000000000000000000000000000000000;;			"    PDName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Partition:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			gce.PDName, gce.FSType, gce.Partition, gce.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printAWSElasticBlockStoreVolumeSource(aws *api.AWSElasticBlockStoreVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tAWSElasticBlockStore (a Persistent Disk resource in AWS)\n"+
0000000000000000000000000000000000000000;;			"    VolumeID:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Partition:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			aws.VolumeID, aws.FSType, aws.Partition, aws.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printGitRepoVolumeSource(git *api.GitRepoVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tGitRepo (a volume that is pulled from git when the pod is created)\n"+
0000000000000000000000000000000000000000;;			"    Repository:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Revision:\t%v\n",
0000000000000000000000000000000000000000;;			git.Repository, git.Revision)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printSecretVolumeSource(secret *api.SecretVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		optional := secret.Optional != nil && *secret.Optional
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tSecret (a volume populated by a Secret)\n"+
0000000000000000000000000000000000000000;;			"    SecretName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Optional:\t%v\n",
0000000000000000000000000000000000000000;;			secret.SecretName, optional)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printConfigMapVolumeSource(configMap *api.ConfigMapVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		optional := configMap.Optional != nil && *configMap.Optional
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tConfigMap (a volume populated by a ConfigMap)\n"+
0000000000000000000000000000000000000000;;			"    Name:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Optional:\t%v\n",
0000000000000000000000000000000000000000;;			configMap.Name, optional)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printNFSVolumeSource(nfs *api.NFSVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tNFS (an NFS mount that lasts the lifetime of a pod)\n"+
0000000000000000000000000000000000000000;;			"    Server:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Path:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			nfs.Server, nfs.Path, nfs.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printQuobyteVolumeSource(quobyte *api.QuobyteVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tQuobyte (a Quobyte mount on the host that shares a pod's lifetime)\n"+
0000000000000000000000000000000000000000;;			"    Registry:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Volume:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			quobyte.Registry, quobyte.Volume, quobyte.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printPortworxVolumeSource(pwxVolume *api.PortworxVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tPortworxVolume (a Portworx Volume resource)\n"+
0000000000000000000000000000000000000000;;			"    VolumeID:\t%v\n",
0000000000000000000000000000000000000000;;			pwxVolume.VolumeID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printISCSIVolumeSource(iscsi *api.ISCSIVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tISCSI (an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod)\n"+
0000000000000000000000000000000000000000;;			"    TargetPortal:\t%v\n"+
0000000000000000000000000000000000000000;;			"    IQN:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Lun:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ISCSIInterface\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Portals:\t%v\n"+
0000000000000000000000000000000000000000;;			"    DiscoveryCHAPAuth:\t%v\n"+
0000000000000000000000000000000000000000;;			"    SessionCHAPAuth:\t%v\n"+
0000000000000000000000000000000000000000;;			"    SecretRef:\t%v\n",
0000000000000000000000000000000000000000;;			iscsi.TargetPortal, iscsi.IQN, iscsi.Lun, iscsi.ISCSIInterface, iscsi.FSType, iscsi.ReadOnly, iscsi.Portals, iscsi.DiscoveryCHAPAuth, iscsi.SessionCHAPAuth, iscsi.SecretRef)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printGlusterfsVolumeSource(glusterfs *api.GlusterfsVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tGlusterfs (a Glusterfs mount on the host that shares a pod's lifetime)\n"+
0000000000000000000000000000000000000000;;			"    EndpointsName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Path:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			glusterfs.EndpointsName, glusterfs.Path, glusterfs.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printPersistentVolumeClaimVolumeSource(claim *api.PersistentVolumeClaimVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tPersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)\n"+
0000000000000000000000000000000000000000;;			"    ClaimName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			claim.ClaimName, claim.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printRBDVolumeSource(rbd *api.RBDVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tRBD (a Rados Block Device mount on the host that shares a pod's lifetime)\n"+
0000000000000000000000000000000000000000;;			"    CephMonitors:\t%v\n"+
0000000000000000000000000000000000000000;;			"    RBDImage:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    RBDPool:\t%v\n"+
0000000000000000000000000000000000000000;;			"    RadosUser:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Keyring:\t%v\n"+
0000000000000000000000000000000000000000;;			"    SecretRef:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			rbd.CephMonitors, rbd.RBDImage, rbd.FSType, rbd.RBDPool, rbd.RadosUser, rbd.Keyring, rbd.SecretRef, rbd.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printDownwardAPIVolumeSource(d *api.DownwardAPIVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tDownwardAPI (a volume populated by information about the pod)\n    Items:\n")
0000000000000000000000000000000000000000;;		for _, mapping := range d.Items {
0000000000000000000000000000000000000000;;			if mapping.FieldRef != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%v -> %v\n", mapping.FieldRef.FieldPath, mapping.Path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mapping.ResourceFieldRef != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%v -> %v\n", mapping.ResourceFieldRef.Resource, mapping.Path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printAzureDiskVolumeSource(d *api.AzureDiskVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tAzureDisk (an Azure Data Disk mount on the host and bind mount to the pod)\n"+
0000000000000000000000000000000000000000;;			"    DiskName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    DiskURI:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Kind: \t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    CachingMode:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			d.DiskName, d.DataDiskURI, *d.Kind, *d.FSType, *d.CachingMode, *d.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printVsphereVolumeSource(vsphere *api.VsphereVirtualDiskVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tvSphereVolume (a Persistent Disk resource in vSphere)\n"+
0000000000000000000000000000000000000000;;			"    VolumePath:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n",
0000000000000000000000000000000000000000;;			"    StoragePolicyName:\t%v\n",
0000000000000000000000000000000000000000;;			vsphere.VolumePath, vsphere.FSType, vsphere.StoragePolicyName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printPhotonPersistentDiskVolumeSource(photon *api.PhotonPersistentDiskVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tPhotonPersistentDisk (a Persistent Disk resource in photon platform)\n"+
0000000000000000000000000000000000000000;;			"    PdID:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n",
0000000000000000000000000000000000000000;;			photon.PdID, photon.FSType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printCinderVolumeSource(cinder *api.CinderVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tCinder (a Persistent Disk resource in OpenStack)\n"+
0000000000000000000000000000000000000000;;			"    VolumeID:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			cinder.VolumeID, cinder.FSType, cinder.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printScaleIOVolumeSource(sio *api.ScaleIOVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tScaleIO (a persistent volume backed by a block device in ScaleIO)\n"+
0000000000000000000000000000000000000000;;			"    Gateway:\t%v\n"+
0000000000000000000000000000000000000000;;			"    System:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Protection Domain:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Storage Pool:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Storage Mode:\t%v\n"+
0000000000000000000000000000000000000000;;			"    VolumeName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			sio.Gateway, sio.System, sio.ProtectionDomain, sio.StoragePool, sio.StorageMode, sio.VolumeName, sio.FSType, sio.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printLocalVolumeSource(ls *api.LocalVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tLocalVolume (a persistent volume backed by local storage on a node)\n"+
0000000000000000000000000000000000000000;;			"    Path:\t%v\n",
0000000000000000000000000000000000000000;;			ls.Path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printCephFSVolumeSource(cephfs *api.CephFSVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tCephFS (a CephFS mount on the host that shares a pod's lifetime)\n"+
0000000000000000000000000000000000000000;;			"    Monitors:\t%v\n"+
0000000000000000000000000000000000000000;;			"    Path:\t%v\n"+
0000000000000000000000000000000000000000;;			"    User:\t%v\n"+
0000000000000000000000000000000000000000;;			"    SecretFile:\t%v\n"+
0000000000000000000000000000000000000000;;			"    SecretRef:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			cephfs.Monitors, cephfs.Path, cephfs.User, cephfs.SecretFile, cephfs.SecretRef, cephfs.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printStorageOSVolumeSource(storageos *api.StorageOSVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tStorageOS (a StorageOS Persistent Disk resource)\n"+
0000000000000000000000000000000000000000;;			"    VolumeName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    VolumeNamespace:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			storageos.VolumeName, storageos.VolumeNamespace, storageos.FSType, storageos.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printStorageOSPersistentVolumeSource(storageos *api.StorageOSPersistentVolumeSource, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Type:\tStorageOS (a StorageOS Persistent Disk resource)\n"+
0000000000000000000000000000000000000000;;			"    VolumeName:\t%v\n"+
0000000000000000000000000000000000000000;;			"    VolumeNamespace:\t%v\n"+
0000000000000000000000000000000000000000;;			"    FSType:\t%v\n"+
0000000000000000000000000000000000000000;;			"    ReadOnly:\t%v\n",
0000000000000000000000000000000000000000;;			storageos.VolumeName, storageos.VolumeNamespace, storageos.FSType, storageos.ReadOnly)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *PersistentVolumeDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Core().PersistentVolumes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, pv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describePersistentVolume(pv, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describePersistentVolume(pv *api.PersistentVolume, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", pv.Name)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", pv.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", pv.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "StorageClass:\t%s\n", helper.GetPersistentVolumeClass(pv))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Status:\t%s\n", pv.Status.Phase)
0000000000000000000000000000000000000000;;			if pv.Spec.ClaimRef != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Claim:\t%s\n", pv.Spec.ClaimRef.Namespace+"/"+pv.Spec.ClaimRef.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Claim:\t%s\n", "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Reclaim Policy:\t%v\n", pv.Spec.PersistentVolumeReclaimPolicy)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Access Modes:\t%s\n", helper.GetAccessModesAsString(pv.Spec.AccessModes))
0000000000000000000000000000000000000000;;			storage := pv.Spec.Capacity[api.ResourceStorage]
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Capacity:\t%s\n", storage.String())
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Message:\t%s\n", pv.Status.Message)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Source:\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case pv.Spec.HostPath != nil:
0000000000000000000000000000000000000000;;				printHostPathVolumeSource(pv.Spec.HostPath, w)
0000000000000000000000000000000000000000;;			case pv.Spec.GCEPersistentDisk != nil:
0000000000000000000000000000000000000000;;				printGCEPersistentDiskVolumeSource(pv.Spec.GCEPersistentDisk, w)
0000000000000000000000000000000000000000;;			case pv.Spec.AWSElasticBlockStore != nil:
0000000000000000000000000000000000000000;;				printAWSElasticBlockStoreVolumeSource(pv.Spec.AWSElasticBlockStore, w)
0000000000000000000000000000000000000000;;			case pv.Spec.NFS != nil:
0000000000000000000000000000000000000000;;				printNFSVolumeSource(pv.Spec.NFS, w)
0000000000000000000000000000000000000000;;			case pv.Spec.ISCSI != nil:
0000000000000000000000000000000000000000;;				printISCSIVolumeSource(pv.Spec.ISCSI, w)
0000000000000000000000000000000000000000;;			case pv.Spec.Glusterfs != nil:
0000000000000000000000000000000000000000;;				printGlusterfsVolumeSource(pv.Spec.Glusterfs, w)
0000000000000000000000000000000000000000;;			case pv.Spec.RBD != nil:
0000000000000000000000000000000000000000;;				printRBDVolumeSource(pv.Spec.RBD, w)
0000000000000000000000000000000000000000;;			case pv.Spec.Quobyte != nil:
0000000000000000000000000000000000000000;;				printQuobyteVolumeSource(pv.Spec.Quobyte, w)
0000000000000000000000000000000000000000;;			case pv.Spec.VsphereVolume != nil:
0000000000000000000000000000000000000000;;				printVsphereVolumeSource(pv.Spec.VsphereVolume, w)
0000000000000000000000000000000000000000;;			case pv.Spec.Cinder != nil:
0000000000000000000000000000000000000000;;				printCinderVolumeSource(pv.Spec.Cinder, w)
0000000000000000000000000000000000000000;;			case pv.Spec.AzureDisk != nil:
0000000000000000000000000000000000000000;;				printAzureDiskVolumeSource(pv.Spec.AzureDisk, w)
0000000000000000000000000000000000000000;;			case pv.Spec.PhotonPersistentDisk != nil:
0000000000000000000000000000000000000000;;				printPhotonPersistentDiskVolumeSource(pv.Spec.PhotonPersistentDisk, w)
0000000000000000000000000000000000000000;;			case pv.Spec.PortworxVolume != nil:
0000000000000000000000000000000000000000;;				printPortworxVolumeSource(pv.Spec.PortworxVolume, w)
0000000000000000000000000000000000000000;;			case pv.Spec.ScaleIO != nil:
0000000000000000000000000000000000000000;;				printScaleIOVolumeSource(pv.Spec.ScaleIO, w)
0000000000000000000000000000000000000000;;			case pv.Spec.Local != nil:
0000000000000000000000000000000000000000;;				printLocalVolumeSource(pv.Spec.Local, w)
0000000000000000000000000000000000000000;;			case pv.Spec.CephFS != nil:
0000000000000000000000000000000000000000;;				printCephFSVolumeSource(pv.Spec.CephFS, w)
0000000000000000000000000000000000000000;;			case pv.Spec.StorageOS != nil:
0000000000000000000000000000000000000000;;				printStorageOSPersistentVolumeSource(pv.Spec.StorageOS, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *PersistentVolumeClaimDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Core().PersistentVolumeClaims(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvc, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		events, _ := d.Core().Events(namespace).Search(api.Scheme, pvc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describePersistentVolumeClaim(pvc, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describePersistentVolumeClaim(pvc *api.PersistentVolumeClaim, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", pvc.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", pvc.Namespace)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "StorageClass:\t%s\n", helper.GetPersistentVolumeClaimClass(pvc))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Status:\t%v\n", pvc.Status.Phase)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Volume:\t%s\n", pvc.Spec.VolumeName)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", pvc.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", pvc.Annotations)
0000000000000000000000000000000000000000;;			storage := pvc.Spec.Resources.Requests[api.ResourceStorage]
0000000000000000000000000000000000000000;;			capacity := ""
0000000000000000000000000000000000000000;;			accessModes := ""
0000000000000000000000000000000000000000;;			if pvc.Spec.VolumeName != "" {
0000000000000000000000000000000000000000;;				accessModes = helper.GetAccessModesAsString(pvc.Status.AccessModes)
0000000000000000000000000000000000000000;;				storage = pvc.Status.Capacity[api.ResourceStorage]
0000000000000000000000000000000000000000;;				capacity = storage.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Capacity:\t%s\n", capacity)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Access Modes:\t%s\n", accessModes)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainers(label string, containers []api.Container, containerStatuses []api.ContainerStatus,
0000000000000000000000000000000000000000;;		resolverFn EnvVarResolverFunc, w PrefixWriter, space string) {
0000000000000000000000000000000000000000;;		statuses := map[string]api.ContainerStatus{}
0000000000000000000000000000000000000000;;		for _, status := range containerStatuses {
0000000000000000000000000000000000000000;;			statuses[status.Name] = status
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		describeContainersLabel(containers, label, space, w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, container := range containers {
0000000000000000000000000000000000000000;;			status, ok := statuses[container.Name]
0000000000000000000000000000000000000000;;			describeContainerBasicInfo(container, status, ok, space, w)
0000000000000000000000000000000000000000;;			describeContainerCommand(container, w)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				describeContainerState(status, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			describeContainerResource(container, w)
0000000000000000000000000000000000000000;;			describeContainerProbe(container, w)
0000000000000000000000000000000000000000;;			if len(container.EnvFrom) > 0 {
0000000000000000000000000000000000000000;;				describeContainerEnvFrom(container, resolverFn, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			describeContainerEnvVars(container, resolverFn, w)
0000000000000000000000000000000000000000;;			describeContainerVolumes(container, w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainersLabel(containers []api.Container, label, space string, w PrefixWriter) {
0000000000000000000000000000000000000000;;		none := ""
0000000000000000000000000000000000000000;;		if len(containers) == 0 {
0000000000000000000000000000000000000000;;			none = " <none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "%s%s:%s\n", space, label, none)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerBasicInfo(container api.Container, status api.ContainerStatus, ok bool, space string, w PrefixWriter) {
0000000000000000000000000000000000000000;;		nameIndent := ""
0000000000000000000000000000000000000000;;		if len(space) > 0 {
0000000000000000000000000000000000000000;;			nameIndent = " "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_1, "%s%v:\n", nameIndent, container.Name)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Container ID:\t%s\n", status.ContainerID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Image:\t%s\n", container.Image)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Image ID:\t%s\n", status.ImageID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		portString := describeContainerPorts(container.Ports)
0000000000000000000000000000000000000000;;		if strings.Contains(portString, ",") {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Ports:\t%s\n", portString)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if len(portString) == 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_2, "Port:\t<none>\n")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_2, "Port:\t%s\n", portString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerPorts(cPorts []api.ContainerPort) string {
0000000000000000000000000000000000000000;;		ports := make([]string, 0, len(cPorts))
0000000000000000000000000000000000000000;;		for _, cPort := range cPorts {
0000000000000000000000000000000000000000;;			ports = append(ports, fmt.Sprintf("%d/%s", cPort.ContainerPort, cPort.Protocol))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(ports, ", ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerCommand(container api.Container, w PrefixWriter) {
0000000000000000000000000000000000000000;;		if len(container.Command) > 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Command:\n")
0000000000000000000000000000000000000000;;			for _, c := range container.Command {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s\n", c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(container.Args) > 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Args:\n")
0000000000000000000000000000000000000000;;			for _, arg := range container.Args {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s\n", arg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerResource(container api.Container, w PrefixWriter) {
0000000000000000000000000000000000000000;;		resources := container.Resources
0000000000000000000000000000000000000000;;		if len(resources.Limits) > 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Limits:\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range SortedResourceNames(resources.Limits) {
0000000000000000000000000000000000000000;;			quantity := resources.Limits[name]
0000000000000000000000000000000000000000;;			w.Write(LEVEL_3, "%s:\t%s\n", name, quantity.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(resources.Requests) > 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Requests:\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, name := range SortedResourceNames(resources.Requests) {
0000000000000000000000000000000000000000;;			quantity := resources.Requests[name]
0000000000000000000000000000000000000000;;			w.Write(LEVEL_3, "%s:\t%s\n", name, quantity.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerState(status api.ContainerStatus, w PrefixWriter) {
0000000000000000000000000000000000000000;;		describeStatus("State", status.State, w)
0000000000000000000000000000000000000000;;		if status.LastTerminationState.Terminated != nil {
0000000000000000000000000000000000000000;;			describeStatus("Last State", status.LastTerminationState, w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Ready:\t%v\n", printBool(status.Ready))
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Restart Count:\t%d\n", status.RestartCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerProbe(container api.Container, w PrefixWriter) {
0000000000000000000000000000000000000000;;		if container.LivenessProbe != nil {
0000000000000000000000000000000000000000;;			probe := DescribeProbe(container.LivenessProbe)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Liveness:\t%s\n", probe)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if container.ReadinessProbe != nil {
0000000000000000000000000000000000000000;;			probe := DescribeProbe(container.ReadinessProbe)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Readiness:\t%s\n", probe)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerVolumes(container api.Container, w PrefixWriter) {
0000000000000000000000000000000000000000;;		none := ""
0000000000000000000000000000000000000000;;		if len(container.VolumeMounts) == 0 {
0000000000000000000000000000000000000000;;			none = "\t<none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Mounts:%s\n", none)
0000000000000000000000000000000000000000;;		sort.Sort(SortableVolumeMounts(container.VolumeMounts))
0000000000000000000000000000000000000000;;		for _, mount := range container.VolumeMounts {
0000000000000000000000000000000000000000;;			flags := []string{}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case mount.ReadOnly:
0000000000000000000000000000000000000000;;				flags = append(flags, "ro")
0000000000000000000000000000000000000000;;			case !mount.ReadOnly:
0000000000000000000000000000000000000000;;				flags = append(flags, "rw")
0000000000000000000000000000000000000000;;			case len(mount.SubPath) > 0:
0000000000000000000000000000000000000000;;				flags = append(flags, fmt.Sprintf("path=%q", mount.SubPath))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_3, "%s from %s (%s)\n", mount.MountPath, mount.Name, strings.Join(flags, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerEnvVars(container api.Container, resolverFn EnvVarResolverFunc, w PrefixWriter) {
0000000000000000000000000000000000000000;;		none := ""
0000000000000000000000000000000000000000;;		if len(container.Env) == 0 {
0000000000000000000000000000000000000000;;			none = "\t<none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Environment:%s\n", none)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, e := range container.Env {
0000000000000000000000000000000000000000;;			if e.ValueFrom == nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s:\t%s\n", e.Name, e.Value)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case e.ValueFrom.FieldRef != nil:
0000000000000000000000000000000000000000;;				var valueFrom string
0000000000000000000000000000000000000000;;				if resolverFn != nil {
0000000000000000000000000000000000000000;;					valueFrom = resolverFn(e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s:\t%s (%s:%s)\n", e.Name, valueFrom, e.ValueFrom.FieldRef.APIVersion, e.ValueFrom.FieldRef.FieldPath)
0000000000000000000000000000000000000000;;			case e.ValueFrom.ResourceFieldRef != nil:
0000000000000000000000000000000000000000;;				valueFrom, err := resourcehelper.ExtractContainerResourceValue(e.ValueFrom.ResourceFieldRef, &container)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					valueFrom = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resource := e.ValueFrom.ResourceFieldRef.Resource
0000000000000000000000000000000000000000;;				if valueFrom == "0" && (resource == "limits.cpu" || resource == "limits.memory") {
0000000000000000000000000000000000000000;;					valueFrom = "node allocatable"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s:\t%s (%s)\n", e.Name, valueFrom, resource)
0000000000000000000000000000000000000000;;			case e.ValueFrom.SecretKeyRef != nil:
0000000000000000000000000000000000000000;;				optional := e.ValueFrom.SecretKeyRef.Optional != nil && *e.ValueFrom.SecretKeyRef.Optional
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s:\t<set to the key '%s' in secret '%s'>\tOptional: %t\n", e.Name, e.ValueFrom.SecretKeyRef.Key, e.ValueFrom.SecretKeyRef.Name, optional)
0000000000000000000000000000000000000000;;			case e.ValueFrom.ConfigMapKeyRef != nil:
0000000000000000000000000000000000000000;;				optional := e.ValueFrom.ConfigMapKeyRef.Optional != nil && *e.ValueFrom.ConfigMapKeyRef.Optional
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s:\t<set to the key '%s' of config map '%s'>\tOptional: %t\n", e.Name, e.ValueFrom.ConfigMapKeyRef.Key, e.ValueFrom.ConfigMapKeyRef.Name, optional)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeContainerEnvFrom(container api.Container, resolverFn EnvVarResolverFunc, w PrefixWriter) {
0000000000000000000000000000000000000000;;		none := ""
0000000000000000000000000000000000000000;;		if len(container.EnvFrom) == 0 {
0000000000000000000000000000000000000000;;			none = "\t<none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_2, "Environment Variables from:%s\n", none)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, e := range container.EnvFrom {
0000000000000000000000000000000000000000;;			from := ""
0000000000000000000000000000000000000000;;			name := ""
0000000000000000000000000000000000000000;;			optional := false
0000000000000000000000000000000000000000;;			if e.ConfigMapRef != nil {
0000000000000000000000000000000000000000;;				from = "ConfigMap"
0000000000000000000000000000000000000000;;				name = e.ConfigMapRef.Name
0000000000000000000000000000000000000000;;				optional = e.ConfigMapRef.Optional != nil && *e.ConfigMapRef.Optional
0000000000000000000000000000000000000000;;			} else if e.SecretRef != nil {
0000000000000000000000000000000000000000;;				from = "Secret"
0000000000000000000000000000000000000000;;				name = e.SecretRef.Name
0000000000000000000000000000000000000000;;				optional = e.SecretRef.Optional != nil && *e.SecretRef.Optional
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(e.Prefix) == 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s\t%s\tOptional: %t\n", name, from, optional)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "%s\t%s with prefix '%s'\tOptional: %t\n", name, from, e.Prefix, optional)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DescribeProbe is exported for consumers in other API groups that have probes
0000000000000000000000000000000000000000;;	func DescribeProbe(probe *api.Probe) string {
0000000000000000000000000000000000000000;;		attrs := fmt.Sprintf("delay=%ds timeout=%ds period=%ds #success=%d #failure=%d", probe.InitialDelaySeconds, probe.TimeoutSeconds, probe.PeriodSeconds, probe.SuccessThreshold, probe.FailureThreshold)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case probe.Exec != nil:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("exec %v %s", probe.Exec.Command, attrs)
0000000000000000000000000000000000000000;;		case probe.HTTPGet != nil:
0000000000000000000000000000000000000000;;			url := &url.URL{}
0000000000000000000000000000000000000000;;			url.Scheme = strings.ToLower(string(probe.HTTPGet.Scheme))
0000000000000000000000000000000000000000;;			if len(probe.HTTPGet.Port.String()) > 0 {
0000000000000000000000000000000000000000;;				url.Host = net.JoinHostPort(probe.HTTPGet.Host, probe.HTTPGet.Port.String())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				url.Host = probe.HTTPGet.Host
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			url.Path = probe.HTTPGet.Path
0000000000000000000000000000000000000000;;			return fmt.Sprintf("http-get %s %s", url.String(), attrs)
0000000000000000000000000000000000000000;;		case probe.TCPSocket != nil:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("tcp-socket %s:%s %s", probe.TCPSocket.Host, probe.TCPSocket.Port.String(), attrs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("unknown %s", attrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EnvVarResolverFunc func(e api.EnvVar) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvValueFrom is exported for use by describers in other packages
0000000000000000000000000000000000000000;;	func EnvValueRetriever(pod *api.Pod) EnvVarResolverFunc {
0000000000000000000000000000000000000000;;		return func(e api.EnvVar) string {
0000000000000000000000000000000000000000;;			internalFieldPath, _, err := api.Scheme.ConvertFieldLabel(e.ValueFrom.FieldRef.APIVersion, "Pod", e.ValueFrom.FieldRef.FieldPath, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "" // pod validation should catch this on create
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			valueFrom, err := fieldpath.ExtractFieldPathAsString(pod, internalFieldPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "" // pod validation should catch this on create
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return valueFrom
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeStatus(stateName string, state api.ContainerState, w PrefixWriter) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case state.Running != nil:
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "%s:\tRunning\n", stateName)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_3, "Started:\t%v\n", state.Running.StartedAt.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;		case state.Waiting != nil:
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "%s:\tWaiting\n", stateName)
0000000000000000000000000000000000000000;;			if state.Waiting.Reason != "" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "Reason:\t%s\n", state.Waiting.Reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case state.Terminated != nil:
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "%s:\tTerminated\n", stateName)
0000000000000000000000000000000000000000;;			if state.Terminated.Reason != "" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "Reason:\t%s\n", state.Terminated.Reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if state.Terminated.Message != "" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "Message:\t%s\n", state.Terminated.Message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_3, "Exit Code:\t%d\n", state.Terminated.ExitCode)
0000000000000000000000000000000000000000;;			if state.Terminated.Signal > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_3, "Signal:\t%d\n", state.Terminated.Signal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_3, "Started:\t%s\n", state.Terminated.StartedAt.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_3, "Finished:\t%s\n", state.Terminated.FinishedAt.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "%s:\tWaiting\n", stateName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeVolumeClaimTemplates(templates []api.PersistentVolumeClaim, w PrefixWriter) {
0000000000000000000000000000000000000000;;		if len(templates) == 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Volume Claims:\t<none>\n")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Volume Claims:\n")
0000000000000000000000000000000000000000;;		for _, pvc := range templates {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Name:\t%s\n", pvc.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "StorageClass:\t%s\n", helper.GetPersistentVolumeClaimClass(&pvc))
0000000000000000000000000000000000000000;;			printLabelsMultilineWithIndent(w, "  ", "Labels", "\t", pvc.Labels, sets.NewString())
0000000000000000000000000000000000000000;;			printLabelsMultilineWithIndent(w, "  ", "Annotations", "\t", pvc.Annotations, sets.NewString())
0000000000000000000000000000000000000000;;			if capacity, ok := pvc.Spec.Resources.Requests[api.ResourceStorage]; ok {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "Capacity:\t%s\n", capacity.String())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "Capacity:\t%s\n", "<default>")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Access Modes:\t%s\n", pvc.Spec.AccessModes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printBoolPtr(value *bool) string {
0000000000000000000000000000000000000000;;		if value != nil {
0000000000000000000000000000000000000000;;			return printBool(*value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "<unset>"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printBool(value bool) string {
0000000000000000000000000000000000000000;;		if value {
0000000000000000000000000000000000000000;;			return "True"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "False"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerDescriber generates information about a replication controller
0000000000000000000000000000000000000000;;	// and the pods it has created.
0000000000000000000000000000000000000000;;	type ReplicationControllerDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ReplicationControllerDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		rc := d.Core().ReplicationControllers(namespace)
0000000000000000000000000000000000000000;;		pc := d.Core().Pods(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller, err := rc.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		running, waiting, succeeded, failed, err := getPodStatusForController(pc, labels.SelectorFromSet(controller.Spec.Selector), controller.UID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, controller)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeReplicationController(controller, events, running, waiting, succeeded, failed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeReplicationController(controller *api.ReplicationController, events *api.EventList, running, waiting, succeeded, failed int) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", controller.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", controller.Namespace)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", labels.FormatLabels(controller.Spec.Selector))
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", controller.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", controller.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Replicas:\t%d current / %d desired\n", controller.Status.Replicas, controller.Spec.Replicas)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Pods Status:\t%d Running / %d Waiting / %d Succeeded / %d Failed\n", running, waiting, succeeded, failed)
0000000000000000000000000000000000000000;;			DescribePodTemplate(controller.Spec.Template, w)
0000000000000000000000000000000000000000;;			if len(controller.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Conditions:\n  Type\tStatus\tReason\n")
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "----\t------\t------\n")
0000000000000000000000000000000000000000;;				for _, c := range controller.Status.Conditions {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%v \t%v\t%v\n", c.Type, c.Status, c.Reason)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DescribePodTemplate(template *api.PodTemplateSpec, w PrefixWriter) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Pod Template:\n")
0000000000000000000000000000000000000000;;		if template == nil {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "<unset>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		printLabelsMultiline(w, "  Labels", template.Labels)
0000000000000000000000000000000000000000;;		if len(template.Annotations) > 0 {
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "  Annotations", template.Annotations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(template.Spec.ServiceAccountName) > 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Service Account:\t%s\n", template.Spec.ServiceAccountName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(template.Spec.InitContainers) > 0 {
0000000000000000000000000000000000000000;;			describeContainers("Init Containers", template.Spec.InitContainers, nil, nil, w, "  ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		describeContainers("Containers", template.Spec.Containers, nil, nil, w, "  ")
0000000000000000000000000000000000000000;;		describeVolumes(template.Spec.Volumes, w, "  ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicaSetDescriber generates information about a ReplicaSet and the pods it has created.
0000000000000000000000000000000000000000;;	type ReplicaSetDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ReplicaSetDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		rsc := d.Extensions().ReplicaSets(namespace)
0000000000000000000000000000000000000000;;		pc := d.Core().Pods(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs, err := rsc.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		running, waiting, succeeded, failed, getPodErr := getPodStatusForController(pc, selector, rs.UID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, rs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeReplicaSet(rs, events, running, waiting, succeeded, failed, getPodErr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeReplicaSet(rs *extensions.ReplicaSet, events *api.EventList, running, waiting, succeeded, failed int, getPodErr error) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", rs.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", rs.Namespace)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", metav1.FormatLabelSelector(rs.Spec.Selector))
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", rs.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", rs.Annotations)
0000000000000000000000000000000000000000;;			if controlledBy := printController(rs); len(controlledBy) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Controlled By:\t%s\n", controlledBy)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Replicas:\t%d current / %d desired\n", rs.Status.Replicas, rs.Spec.Replicas)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Pods Status:\t")
0000000000000000000000000000000000000000;;			if getPodErr != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "error in fetching pods: %s\n", getPodErr)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "%d Running / %d Waiting / %d Succeeded / %d Failed\n", running, waiting, succeeded, failed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			DescribePodTemplate(&rs.Spec.Template, w)
0000000000000000000000000000000000000000;;			if len(rs.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Conditions:\n  Type\tStatus\tReason\n")
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "----\t------\t------\n")
0000000000000000000000000000000000000000;;				for _, c := range rs.Status.Conditions {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%v \t%v\t%v\n", c.Type, c.Status, c.Reason)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JobDescriber generates information about a job and the pods it has created.
0000000000000000000000000000000000000000;;	type JobDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *JobDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		job, err := d.Batch().Jobs(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, job)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeJob(job, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeJob(job *batch.Job, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", job.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", job.Namespace)
0000000000000000000000000000000000000000;;			selector, _ := metav1.LabelSelectorAsSelector(job.Spec.Selector)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", selector)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", job.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", job.Annotations)
0000000000000000000000000000000000000000;;			if createdBy := printCreator(job.Annotations); len(createdBy) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Created By:\t%s\n", createdBy)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Parallelism:\t%d\n", *job.Spec.Parallelism)
0000000000000000000000000000000000000000;;			if job.Spec.Completions != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Completions:\t%d\n", *job.Spec.Completions)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Completions:\t<unset>\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if job.Status.StartTime != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Start Time:\t%s\n", job.Status.StartTime.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if job.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Active Deadline Seconds:\t%ds\n", *job.Spec.ActiveDeadlineSeconds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Pods Statuses:\t%d Running / %d Succeeded / %d Failed\n", job.Status.Active, job.Status.Succeeded, job.Status.Failed)
0000000000000000000000000000000000000000;;			DescribePodTemplate(&job.Spec.Template, w)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CronJobDescriber generates information about a cron job and the jobs it has created.
0000000000000000000000000000000000000000;;	type CronJobDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *CronJobDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		cronJob, err := d.Batch().CronJobs(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, cronJob)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeCronJob(cronJob, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeCronJob(cronJob *batch.CronJob, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", cronJob.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", cronJob.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", cronJob.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", cronJob.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Schedule:\t%s\n", cronJob.Spec.Schedule)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Concurrency Policy:\t%s\n", cronJob.Spec.ConcurrencyPolicy)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Suspend:\t%s\n", printBoolPtr(cronJob.Spec.Suspend))
0000000000000000000000000000000000000000;;			if cronJob.Spec.StartingDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Starting Deadline Seconds:\t%ds\n", *cronJob.Spec.StartingDeadlineSeconds)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Starting Deadline Seconds:\t<unset>\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			describeJobTemplate(cronJob.Spec.JobTemplate, w)
0000000000000000000000000000000000000000;;			if cronJob.Status.LastScheduleTime != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Last Schedule Time:\t%s\n", cronJob.Status.LastScheduleTime.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Last Schedule Time:\t<unset>\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			printActiveJobs(w, "Active Jobs", cronJob.Status.Active)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeJobTemplate(jobTemplate batch.JobTemplateSpec, w PrefixWriter) {
0000000000000000000000000000000000000000;;		if jobTemplate.Spec.Selector != nil {
0000000000000000000000000000000000000000;;			selector, _ := metav1.LabelSelectorAsSelector(jobTemplate.Spec.Selector)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", selector)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t<unset>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if jobTemplate.Spec.Parallelism != nil {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Parallelism:\t%d\n", *jobTemplate.Spec.Parallelism)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Parallelism:\t<unset>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if jobTemplate.Spec.Completions != nil {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Completions:\t%d\n", *jobTemplate.Spec.Completions)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Completions:\t<unset>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if jobTemplate.Spec.ActiveDeadlineSeconds != nil {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Active Deadline Seconds:\t%ds\n", *jobTemplate.Spec.ActiveDeadlineSeconds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		DescribePodTemplate(&jobTemplate.Spec.Template, w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printActiveJobs(w PrefixWriter, title string, jobs []api.ObjectReference) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "%s:\t", title)
0000000000000000000000000000000000000000;;		if len(jobs) == 0 {
0000000000000000000000000000000000000000;;			w.WriteLine("<none>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, job := range jobs {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, ", ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "%s", job.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.WriteLine("")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DaemonSetDescriber generates information about a daemon set and the pods it has created.
0000000000000000000000000000000000000000;;	type DaemonSetDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *DaemonSetDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		dc := d.Extensions().DaemonSets(namespace)
0000000000000000000000000000000000000000;;		pc := d.Core().Pods(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		daemon, err := dc.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(daemon.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		running, waiting, succeeded, failed, err := getPodStatusForController(pc, selector, daemon.UID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, daemon)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeDaemonSet(daemon, events, running, waiting, succeeded, failed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeDaemonSet(daemon *extensions.DaemonSet, events *api.EventList, running, waiting, succeeded, failed int) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", daemon.Name)
0000000000000000000000000000000000000000;;			selector, err := metav1.LabelSelectorAsSelector(daemon.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// this shouldn't happen if LabelSelector passed validation
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", selector)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Node-Selector:\t%s\n", labels.FormatLabels(daemon.Spec.Template.Spec.NodeSelector))
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", daemon.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", daemon.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Desired Number of Nodes Scheduled: %d\n", daemon.Status.DesiredNumberScheduled)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Current Number of Nodes Scheduled: %d\n", daemon.Status.CurrentNumberScheduled)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Number of Nodes Scheduled with Up-to-date Pods: %d\n", daemon.Status.UpdatedNumberScheduled)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Number of Nodes Scheduled with Available Pods: %d\n", daemon.Status.NumberAvailable)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Number of Nodes Misscheduled: %d\n", daemon.Status.NumberMisscheduled)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Pods Status:\t%d Running / %d Waiting / %d Succeeded / %d Failed\n", running, waiting, succeeded, failed)
0000000000000000000000000000000000000000;;			DescribePodTemplate(&daemon.Spec.Template, w)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretDescriber generates information about a secret
0000000000000000000000000000000000000000;;	type SecretDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *SecretDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Core().Secrets(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		secret, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeSecret(secret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeSecret(secret *api.Secret) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", secret.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", secret.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", secret.Labels)
0000000000000000000000000000000000000000;;			skipAnnotations := sets.NewString(api.LastAppliedConfigAnnotation)
0000000000000000000000000000000000000000;;			printAnnotationsMultilineWithFilter(w, "Annotations", secret.Annotations, skipAnnotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "\nType:\t%s\n", secret.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "\nData\n====\n")
0000000000000000000000000000000000000000;;			for k, v := range secret.Data {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case k == api.ServiceAccountTokenKey && secret.Type == api.SecretTypeServiceAccountToken:
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "%s:\t%s\n", k, string(v))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "%s:\t%d bytes\n", k, len(v))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IngressDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *IngressDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := i.Extensions().Ingresses(namespace)
0000000000000000000000000000000000000000;;		ing, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i.describeIngress(ing, describerSettings)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *IngressDescriber) describeBackend(ns string, backend *extensions.IngressBackend) string {
0000000000000000000000000000000000000000;;		endpoints, _ := i.Core().Endpoints(ns).Get(backend.ServiceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		service, _ := i.Core().Services(ns).Get(backend.ServiceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		spName := ""
0000000000000000000000000000000000000000;;		for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;			sp := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;			switch backend.ServicePort.Type {
0000000000000000000000000000000000000000;;			case intstr.String:
0000000000000000000000000000000000000000;;				if backend.ServicePort.StrVal == sp.Name {
0000000000000000000000000000000000000000;;					spName = sp.Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case intstr.Int:
0000000000000000000000000000000000000000;;				if int32(backend.ServicePort.IntVal) == sp.Port {
0000000000000000000000000000000000000000;;					spName = sp.Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return formatEndpoints(endpoints, sets.NewString(spName))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *IngressDescriber) describeIngress(ing *extensions.Ingress, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%v\n", ing.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%v\n", ing.Namespace)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Address:\t%v\n", loadBalancerStatusStringer(ing.Status.LoadBalancer, true))
0000000000000000000000000000000000000000;;			def := ing.Spec.Backend
0000000000000000000000000000000000000000;;			ns := ing.Namespace
0000000000000000000000000000000000000000;;			if def == nil {
0000000000000000000000000000000000000000;;				// Ingresses that don't specify a default backend inherit the
0000000000000000000000000000000000000000;;				// default backend in the kube-system namespace.
0000000000000000000000000000000000000000;;				def = &extensions.IngressBackend{
0000000000000000000000000000000000000000;;					ServiceName: "default-http-backend",
0000000000000000000000000000000000000000;;					ServicePort: intstr.IntOrString{Type: intstr.Int, IntVal: 80},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ns = metav1.NamespaceSystem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Default backend:\t%s (%s)\n", backendStringer(def), i.describeBackend(ns, def))
0000000000000000000000000000000000000000;;			if len(ing.Spec.TLS) != 0 {
0000000000000000000000000000000000000000;;				describeIngressTLS(w, ing.Spec.TLS)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Rules:\n  Host\tPath\tBackends\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "----\t----\t--------\n")
0000000000000000000000000000000000000000;;			count := 0
0000000000000000000000000000000000000000;;			for _, rules := range ing.Spec.Rules {
0000000000000000000000000000000000000000;;				if rules.HTTP == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;				host := rules.Host
0000000000000000000000000000000000000000;;				if len(host) == 0 {
0000000000000000000000000000000000000000;;					host = "*"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%s\t\n", host)
0000000000000000000000000000000000000000;;				for _, path := range rules.HTTP.Paths {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_2, "\t%s \t%s (%s)\n", path.Path, backendStringer(&path.Backend), i.describeBackend(ns, &path.Backend))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if count == 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%s\t%s \t%s (%s)\n", "*", "*", backendStringer(def), i.describeBackend(ns, def))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			describeIngressAnnotations(w, ing.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;				events, _ := i.Core().Events(ing.Namespace).Search(api.Scheme, ing)
0000000000000000000000000000000000000000;;				if events != nil {
0000000000000000000000000000000000000000;;					DescribeEvents(events, w)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeIngressTLS(w PrefixWriter, ingTLS []extensions.IngressTLS) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "TLS:\n")
0000000000000000000000000000000000000000;;		for _, t := range ingTLS {
0000000000000000000000000000000000000000;;			if t.SecretName == "" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "SNI routes %v\n", strings.Join(t.Hosts, ","))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%v terminates %v\n", t.SecretName, strings.Join(t.Hosts, ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Move from annotations into Ingress status.
0000000000000000000000000000000000000000;;	func describeIngressAnnotations(w PrefixWriter, annotations map[string]string) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Annotations:\n")
0000000000000000000000000000000000000000;;		for k, v := range annotations {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(k, "ingress") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts := strings.Split(k, "/")
0000000000000000000000000000000000000000;;			name := parts[len(parts)-1]
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "%v:\t%s\n", name, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceDescriber generates information about a service.
0000000000000000000000000000000000000000;;	type ServiceDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ServiceDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Core().Services(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoints, _ := d.Core().Endpoints(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, service)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return describeService(service, endpoints, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildIngressString(ingress []api.LoadBalancerIngress) string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range ingress {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				buffer.WriteString(", ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ingress[i].IP != "" {
0000000000000000000000000000000000000000;;				buffer.WriteString(ingress[i].IP)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buffer.WriteString(ingress[i].Hostname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeService(service *api.Service, endpoints *api.Endpoints, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		if endpoints == nil {
0000000000000000000000000000000000000000;;			endpoints = &api.Endpoints{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", service.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", service.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", service.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", service.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", labels.FormatLabels(service.Spec.Selector))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Type:\t%s\n", service.Spec.Type)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "IP:\t%s\n", service.Spec.ClusterIP)
0000000000000000000000000000000000000000;;			if len(service.Spec.ExternalIPs) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "External IPs:\t%v\n", strings.Join(service.Spec.ExternalIPs, ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if service.Spec.ExternalName != "" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "External Name:\t%s\n", service.Spec.ExternalName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(service.Status.LoadBalancer.Ingress) > 0 {
0000000000000000000000000000000000000000;;				list := buildIngressString(service.Status.LoadBalancer.Ingress)
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "LoadBalancer Ingress:\t%s\n", list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range service.Spec.Ports {
0000000000000000000000000000000000000000;;				sp := &service.Spec.Ports[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				name := sp.Name
0000000000000000000000000000000000000000;;				if name == "" {
0000000000000000000000000000000000000000;;					name = "<unset>"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Port:\t%s\t%d/%s\n", name, sp.Port, sp.Protocol)
0000000000000000000000000000000000000000;;				if sp.NodePort != 0 {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "NodePort:\t%s\t%d/%s\n", name, sp.NodePort, sp.Protocol)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Endpoints:\t%s\n", formatEndpoints(endpoints, sets.NewString(sp.Name)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Session Affinity:\t%s\n", service.Spec.SessionAffinity)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointsDescriber generates information about an Endpoint.
0000000000000000000000000000000000000000;;	type EndpointsDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *EndpointsDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Core().Endpoints(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.Core().Events(namespace).Search(api.Scheme, ep)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeEndpoints(ep, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeEndpoints(ep *api.Endpoints, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", ep.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", ep.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", ep.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", ep.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Subsets:\n")
0000000000000000000000000000000000000000;;			for i := range ep.Subsets {
0000000000000000000000000000000000000000;;				subset := &ep.Subsets[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				addresses := make([]string, 0, len(subset.Addresses))
0000000000000000000000000000000000000000;;				for _, addr := range subset.Addresses {
0000000000000000000000000000000000000000;;					addresses = append(addresses, addr.IP)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addressesString := strings.Join(addresses, ",")
0000000000000000000000000000000000000000;;				if len(addressesString) == 0 {
0000000000000000000000000000000000000000;;					addressesString = "<none>"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "Addresses:\t%s\n", addressesString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				notReadyAddresses := make([]string, 0, len(subset.NotReadyAddresses))
0000000000000000000000000000000000000000;;				for _, addr := range subset.NotReadyAddresses {
0000000000000000000000000000000000000000;;					notReadyAddresses = append(notReadyAddresses, addr.IP)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				notReadyAddressesString := strings.Join(notReadyAddresses, ",")
0000000000000000000000000000000000000000;;				if len(notReadyAddressesString) == 0 {
0000000000000000000000000000000000000000;;					notReadyAddressesString = "<none>"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "NotReadyAddresses:\t%s\n", notReadyAddressesString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(subset.Ports) > 0 {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "Ports:\n")
0000000000000000000000000000000000000000;;					w.Write(LEVEL_2, "Name\tPort\tProtocol\n")
0000000000000000000000000000000000000000;;					w.Write(LEVEL_2, "----\t----\t--------\n")
0000000000000000000000000000000000000000;;					for _, port := range subset.Ports {
0000000000000000000000000000000000000000;;						name := port.Name
0000000000000000000000000000000000000000;;						if len(name) == 0 {
0000000000000000000000000000000000000000;;							name = "<unset>"
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						w.Write(LEVEL_2, "%s\t%d\t%s\n", name, port.Port, port.Protocol)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountDescriber generates information about a service.
0000000000000000000000000000000000000000;;	type ServiceAccountDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ServiceAccountDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Core().ServiceAccounts(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceAccount, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokens := []api.Secret{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// missingSecrets is the set of all secrets present in the
0000000000000000000000000000000000000000;;		// serviceAccount but not present in the set of existing secrets.
0000000000000000000000000000000000000000;;		missingSecrets := sets.NewString()
0000000000000000000000000000000000000000;;		secrets, err := d.Core().Secrets(namespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// errors are tolerated here in order to describe the serviceAccount with all
0000000000000000000000000000000000000000;;		// of the secrets that it references, even if those secrets cannot be fetched.
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// existingSecrets is the set of all secrets remaining on a
0000000000000000000000000000000000000000;;			// service account that are not present in the "tokens" slice.
0000000000000000000000000000000000000000;;			existingSecrets := sets.NewString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, s := range secrets.Items {
0000000000000000000000000000000000000000;;				if s.Type == api.SecretTypeServiceAccountToken {
0000000000000000000000000000000000000000;;					name, _ := s.Annotations[api.ServiceAccountNameKey]
0000000000000000000000000000000000000000;;					uid, _ := s.Annotations[api.ServiceAccountUIDKey]
0000000000000000000000000000000000000000;;					if name == serviceAccount.Name && uid == string(serviceAccount.UID) {
0000000000000000000000000000000000000000;;						tokens = append(tokens, s)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				existingSecrets.Insert(s.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, s := range serviceAccount.Secrets {
0000000000000000000000000000000000000000;;				if !existingSecrets.Has(s.Name) {
0000000000000000000000000000000000000000;;					missingSecrets.Insert(s.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, s := range serviceAccount.ImagePullSecrets {
0000000000000000000000000000000000000000;;				if !existingSecrets.Has(s.Name) {
0000000000000000000000000000000000000000;;					missingSecrets.Insert(s.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeServiceAccount(serviceAccount, tokens, missingSecrets)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeServiceAccount(serviceAccount *api.ServiceAccount, tokens []api.Secret, missingSecrets sets.String) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", serviceAccount.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", serviceAccount.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", serviceAccount.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", serviceAccount.Annotations)
0000000000000000000000000000000000000000;;			w.WriteLine()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				emptyHeader = "                   "
0000000000000000000000000000000000000000;;				pullHeader  = "Image pull secrets:"
0000000000000000000000000000000000000000;;				mountHeader = "Mountable secrets: "
0000000000000000000000000000000000000000;;				tokenHeader = "Tokens:            "
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pullSecretNames  = []string{}
0000000000000000000000000000000000000000;;				mountSecretNames = []string{}
0000000000000000000000000000000000000000;;				tokenSecretNames = []string{}
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, s := range serviceAccount.ImagePullSecrets {
0000000000000000000000000000000000000000;;				pullSecretNames = append(pullSecretNames, s.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, s := range serviceAccount.Secrets {
0000000000000000000000000000000000000000;;				mountSecretNames = append(mountSecretNames, s.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, s := range tokens {
0000000000000000000000000000000000000000;;				tokenSecretNames = append(tokenSecretNames, s.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			types := map[string][]string{
0000000000000000000000000000000000000000;;				pullHeader:  pullSecretNames,
0000000000000000000000000000000000000000;;				mountHeader: mountSecretNames,
0000000000000000000000000000000000000000;;				tokenHeader: tokenSecretNames,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for header, names := range types {
0000000000000000000000000000000000000000;;				if len(names) == 0 {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "%s\t<none>\n", header)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					prefix := header
0000000000000000000000000000000000000000;;					for _, name := range names {
0000000000000000000000000000000000000000;;						if missingSecrets.Has(name) {
0000000000000000000000000000000000000000;;							w.Write(LEVEL_0, "%s\t%s (not found)\n", prefix, name)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							w.Write(LEVEL_0, "%s\t%s\n", prefix, name)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						prefix = emptyHeader
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.WriteLine()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoleDescriber generates information about a node.
0000000000000000000000000000000000000000;;	type RoleDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *RoleDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		role, err := d.Rbac().Roles(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		breakdownRules := []rbac.PolicyRule{}
0000000000000000000000000000000000000000;;		for _, rule := range role.Rules {
0000000000000000000000000000000000000000;;			breakdownRules = append(breakdownRules, validation.BreakdownRule(rule)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compactRules, err := validation.CompactRules(breakdownRules)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Stable(rbac.SortableRuleSlice(compactRules))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", role.Name)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", role.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", role.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "PolicyRule:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Resources\tNon-Resource URLs\tResource Names\tVerbs\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "---------\t-----------------\t--------------\t-----\n")
0000000000000000000000000000000000000000;;			for _, r := range compactRules {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%s\t%v\t%v\t%v\n", combineResourceGroup(r.Resources, r.APIGroups), r.NonResourceURLs, r.ResourceNames, r.Verbs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleDescriber generates information about a node.
0000000000000000000000000000000000000000;;	type ClusterRoleDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ClusterRoleDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		role, err := d.Rbac().ClusterRoles().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		breakdownRules := []rbac.PolicyRule{}
0000000000000000000000000000000000000000;;		for _, rule := range role.Rules {
0000000000000000000000000000000000000000;;			breakdownRules = append(breakdownRules, validation.BreakdownRule(rule)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compactRules, err := validation.CompactRules(breakdownRules)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Stable(rbac.SortableRuleSlice(compactRules))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", role.Name)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", role.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", role.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "PolicyRule:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Resources\tNon-Resource URLs\tResource Names\tVerbs\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "---------\t-----------------\t--------------\t-----\n")
0000000000000000000000000000000000000000;;			for _, r := range compactRules {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%s\t%v\t%v\t%v\n", combineResourceGroup(r.Resources, r.APIGroups), r.NonResourceURLs, r.ResourceNames, r.Verbs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func combineResourceGroup(resource, group []string) string {
0000000000000000000000000000000000000000;;		if len(resource) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.SplitN(resource[0], "/", 2)
0000000000000000000000000000000000000000;;		combine := parts[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(group) > 0 && group[0] != "" {
0000000000000000000000000000000000000000;;			combine = combine + "." + group[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parts) == 2 {
0000000000000000000000000000000000000000;;			combine = combine + "/" + parts[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return combine
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoleBindingDescriber generates information about a node.
0000000000000000000000000000000000000000;;	type RoleBindingDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *RoleBindingDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		binding, err := d.Rbac().RoleBindings(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", binding.Name)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", binding.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", binding.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Role:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Kind:\t%s\n", binding.RoleRef.Kind)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Name:\t%s\n", binding.RoleRef.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Subjects:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Kind\tName\tNamespace\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "----\t----\t---------\n")
0000000000000000000000000000000000000000;;			for _, s := range binding.Subjects {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%s\t%s\t%s\n", s.Kind, s.Name, s.Namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleBindingDescriber generates information about a node.
0000000000000000000000000000000000000000;;	type ClusterRoleBindingDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ClusterRoleBindingDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		binding, err := d.Rbac().ClusterRoleBindings().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", binding.Name)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", binding.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", binding.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Role:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Kind:\t%s\n", binding.RoleRef.Kind)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Name:\t%s\n", binding.RoleRef.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Subjects:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "Kind\tName\tNamespace\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "----\t----\t---------\n")
0000000000000000000000000000000000000000;;			for _, s := range binding.Subjects {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%s\t%s\t%s\n", s.Kind, s.Name, s.Namespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeDescriber generates information about a node.
0000000000000000000000000000000000000000;;	type NodeDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *NodeDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		mc := d.Core().Nodes()
0000000000000000000000000000000000000000;;		node, err := mc.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldSelector, err := fields.ParseSelector("spec.nodeName=" + name + ",status.phase!=" + string(api.PodSucceeded) + ",status.phase!=" + string(api.PodFailed))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// in a policy aware setting, users may have access to a node, but not all pods
0000000000000000000000000000000000000000;;		// in that case, we note that the user does not have access to the pods
0000000000000000000000000000000000000000;;		canViewPods := true
0000000000000000000000000000000000000000;;		nodeNonTerminatedPodsList, err := d.Core().Pods(namespace).List(metav1.ListOptions{FieldSelector: fieldSelector.String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !errors.IsForbidden(err) {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			canViewPods = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			if ref, err := ref.GetReference(api.Scheme, node); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to construct reference to '%#v': %v", node, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// TODO: We haven't decided the namespace for Node object yet.
0000000000000000000000000000000000000000;;				ref.UID = types.UID(ref.Name)
0000000000000000000000000000000000000000;;				events, _ = d.Core().Events("").Search(api.Scheme, ref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeNode(node, nodeNonTerminatedPodsList, events, canViewPods)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeNode(node *api.Node, nodeNonTerminatedPodsList *api.PodList, events *api.EventList, canViewPods bool) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", node.Name)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", node.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", node.Annotations)
0000000000000000000000000000000000000000;;			printNodeTaintsMultiline(w, "Taints", node.Spec.Taints)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "CreationTimestamp:\t%s\n", node.CreationTimestamp.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			if len(node.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Conditions:\n  Type\tStatus\tLastHeartbeatTime\tLastTransitionTime\tReason\tMessage\n")
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "----\t------\t-----------------\t------------------\t------\t-------\n")
0000000000000000000000000000000000000000;;				for _, c := range node.Status.Conditions {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%v \t%v \t%s \t%s \t%v \t%v\n",
0000000000000000000000000000000000000000;;						c.Type,
0000000000000000000000000000000000000000;;						c.Status,
0000000000000000000000000000000000000000;;						c.LastHeartbeatTime.Time.Format(time.RFC1123Z),
0000000000000000000000000000000000000000;;						c.LastTransitionTime.Time.Format(time.RFC1123Z),
0000000000000000000000000000000000000000;;						c.Reason,
0000000000000000000000000000000000000000;;						c.Message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Addresses:\n")
0000000000000000000000000000000000000000;;			for _, address := range node.Status.Addresses {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%s:\t%s\n", address.Type, address.Address)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			printResourceList := func(resourceList api.ResourceList) {
0000000000000000000000000000000000000000;;				resources := make([]api.ResourceName, 0, len(resourceList))
0000000000000000000000000000000000000000;;				for resource := range resourceList {
0000000000000000000000000000000000000000;;					resources = append(resources, resource)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(SortableResourceNames(resources))
0000000000000000000000000000000000000000;;				for _, resource := range resources {
0000000000000000000000000000000000000000;;					value := resourceList[resource]
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, " %s:\t%s\n", resource, value.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(node.Status.Capacity) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Capacity:\n")
0000000000000000000000000000000000000000;;				printResourceList(node.Status.Capacity)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(node.Status.Allocatable) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Allocatable:\n")
0000000000000000000000000000000000000000;;				printResourceList(node.Status.Allocatable)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "System Info:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Machine ID:\t%s\n", node.Status.NodeInfo.MachineID)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " System UUID:\t%s\n", node.Status.NodeInfo.SystemUUID)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Boot ID:\t%s\n", node.Status.NodeInfo.BootID)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Kernel Version:\t%s\n", node.Status.NodeInfo.KernelVersion)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " OS Image:\t%s\n", node.Status.NodeInfo.OSImage)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Operating System:\t%s\n", node.Status.NodeInfo.OperatingSystem)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Architecture:\t%s\n", node.Status.NodeInfo.Architecture)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Container Runtime Version:\t%s\n", node.Status.NodeInfo.ContainerRuntimeVersion)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Kubelet Version:\t%s\n", node.Status.NodeInfo.KubeletVersion)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, " Kube-Proxy Version:\t%s\n", node.Status.NodeInfo.KubeProxyVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(node.Spec.PodCIDR) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "PodCIDR:\t%s\n", node.Spec.PodCIDR)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(node.Spec.ExternalID) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "ExternalID:\t%s\n", node.Spec.ExternalID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if canViewPods && nodeNonTerminatedPodsList != nil {
0000000000000000000000000000000000000000;;				if err := describeNodeResource(nodeNonTerminatedPodsList, node, w); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Pods:\tnot authorized\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatefulSetDescriber struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *StatefulSetDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		ps, err := p.client.Apps().StatefulSets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pc := p.client.Core().Pods(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(ps.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		running, waiting, succeeded, failed, err := getPodStatusForController(pc, selector, ps.UID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = p.client.Core().Events(namespace).Search(api.Scheme, ps)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeStatefulSet(ps, selector, events, running, waiting, succeeded, failed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeStatefulSet(ps *apps.StatefulSet, selector labels.Selector, events *api.EventList, running, waiting, succeeded, failed int) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", ps.ObjectMeta.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", ps.ObjectMeta.Namespace)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "CreationTimestamp:\t%s\n", ps.CreationTimestamp.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", selector)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", ps.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", ps.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Replicas:\t%d desired | %d total\n", ps.Spec.Replicas, ps.Status.Replicas)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Pods Status:\t%d Running / %d Waiting / %d Succeeded / %d Failed\n", running, waiting, succeeded, failed)
0000000000000000000000000000000000000000;;			DescribePodTemplate(&ps.Spec.Template, w)
0000000000000000000000000000000000000000;;			describeVolumeClaimTemplates(ps.Spec.VolumeClaimTemplates, w)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CertificateSigningRequestDescriber struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *CertificateSigningRequestDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		csr, err := p.client.Certificates().CertificateSigningRequests().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cr, err := certificates.ParseCSR(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Error parsing CSR: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		status, err := extractCSRStatus(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = p.client.Core().Events(namespace).Search(api.Scheme, csr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeCertificateSigningRequest(csr, cr, status, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeCertificateSigningRequest(csr *certificates.CertificateSigningRequest, cr *x509.CertificateRequest, status string, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		printListHelper := func(w PrefixWriter, prefix, name string, values []string) {
0000000000000000000000000000000000000000;;			if len(values) == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, prefix+name+":\t")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, strings.Join(values, "\n"+prefix+"\t"))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", csr.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Labels:\t%s\n", labels.FormatLabels(csr.Labels))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Annotations:\t%s\n", labels.FormatLabels(csr.Annotations))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "CreationTimestamp:\t%s\n", csr.CreationTimestamp.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Requesting User:\t%s\n", csr.Spec.Username)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Status:\t%s\n", status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Subject:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "\tCommon Name:\t%s\n", cr.Subject.CommonName)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "\tSerial Number:\t%s\n", cr.Subject.SerialNumber)
0000000000000000000000000000000000000000;;			printListHelper(w, "\t", "Organization", cr.Subject.Organization)
0000000000000000000000000000000000000000;;			printListHelper(w, "\t", "Organizational Unit", cr.Subject.OrganizationalUnit)
0000000000000000000000000000000000000000;;			printListHelper(w, "\t", "Country", cr.Subject.Country)
0000000000000000000000000000000000000000;;			printListHelper(w, "\t", "Locality", cr.Subject.Locality)
0000000000000000000000000000000000000000;;			printListHelper(w, "\t", "Province", cr.Subject.Province)
0000000000000000000000000000000000000000;;			printListHelper(w, "\t", "StreetAddress", cr.Subject.StreetAddress)
0000000000000000000000000000000000000000;;			printListHelper(w, "\t", "PostalCode", cr.Subject.PostalCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(cr.DNSNames)+len(cr.EmailAddresses)+len(cr.IPAddresses) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Subject Alternative Names:\n")
0000000000000000000000000000000000000000;;				printListHelper(w, "\t", "DNS Names", cr.DNSNames)
0000000000000000000000000000000000000000;;				printListHelper(w, "\t", "Email Addresses", cr.EmailAddresses)
0000000000000000000000000000000000000000;;				var ipaddrs []string
0000000000000000000000000000000000000000;;				for _, ipaddr := range cr.IPAddresses {
0000000000000000000000000000000000000000;;					ipaddrs = append(ipaddrs, ipaddr.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				printListHelper(w, "\t", "IP Addresses", ipaddrs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HorizontalPodAutoscalerDescriber generates information about a horizontal pod autoscaler.
0000000000000000000000000000000000000000;;	type HorizontalPodAutoscalerDescriber struct {
0000000000000000000000000000000000000000;;		client clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *HorizontalPodAutoscalerDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		hpa, err := d.client.Autoscaling().HorizontalPodAutoscalers(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = d.client.Core().Events(namespace).Search(api.Scheme, hpa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeHorizontalPodAutoscaler(hpa, events, d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeHorizontalPodAutoscaler(hpa *autoscaling.HorizontalPodAutoscaler, events *api.EventList, d *HorizontalPodAutoscalerDescriber) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", hpa.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", hpa.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", hpa.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", hpa.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "CreationTimestamp:\t%s\n", hpa.CreationTimestamp.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Reference:\t%s/%s\n",
0000000000000000000000000000000000000000;;				hpa.Spec.ScaleTargetRef.Kind,
0000000000000000000000000000000000000000;;				hpa.Spec.ScaleTargetRef.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Metrics:\t( current / target )\n")
0000000000000000000000000000000000000000;;			for i, metric := range hpa.Spec.Metrics {
0000000000000000000000000000000000000000;;				switch metric.Type {
0000000000000000000000000000000000000000;;				case autoscaling.PodsMetricSourceType:
0000000000000000000000000000000000000000;;					current := "<unknown>"
0000000000000000000000000000000000000000;;					if len(hpa.Status.CurrentMetrics) > i && hpa.Status.CurrentMetrics[i].Pods != nil {
0000000000000000000000000000000000000000;;						current = hpa.Status.CurrentMetrics[i].Pods.CurrentAverageValue.String()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%q on pods:\t%s / %s\n", metric.Pods.MetricName, current, metric.Pods.TargetAverageValue.String())
0000000000000000000000000000000000000000;;				case autoscaling.ObjectMetricSourceType:
0000000000000000000000000000000000000000;;					current := "<unknown>"
0000000000000000000000000000000000000000;;					if len(hpa.Status.CurrentMetrics) > i && hpa.Status.CurrentMetrics[i].Object != nil {
0000000000000000000000000000000000000000;;						current = hpa.Status.CurrentMetrics[i].Object.CurrentValue.String()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%q on %s/%s:\t%s / %s\n", metric.Object.MetricName, metric.Object.Target.Kind, metric.Object.Target.Name, current, metric.Object.TargetValue.String())
0000000000000000000000000000000000000000;;				case autoscaling.ResourceMetricSourceType:
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "resource %s on pods", string(metric.Resource.Name))
0000000000000000000000000000000000000000;;					if metric.Resource.TargetAverageValue != nil {
0000000000000000000000000000000000000000;;						current := "<unknown>"
0000000000000000000000000000000000000000;;						if len(hpa.Status.CurrentMetrics) > i && hpa.Status.CurrentMetrics[i].Resource != nil {
0000000000000000000000000000000000000000;;							current = hpa.Status.CurrentMetrics[i].Resource.CurrentAverageValue.String()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, ":\t%s / %s\n", current, metric.Resource.TargetAverageValue.String())
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						current := "<unknown>"
0000000000000000000000000000000000000000;;						if len(hpa.Status.CurrentMetrics) > i && hpa.Status.CurrentMetrics[i].Resource != nil && hpa.Status.CurrentMetrics[i].Resource.CurrentAverageUtilization != nil {
0000000000000000000000000000000000000000;;							current = fmt.Sprintf("%d%% (%s)", *hpa.Status.CurrentMetrics[i].Resource.CurrentAverageUtilization, hpa.Status.CurrentMetrics[i].Resource.CurrentAverageValue.String())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						target := "<auto>"
0000000000000000000000000000000000000000;;						if metric.Resource.TargetAverageUtilization != nil {
0000000000000000000000000000000000000000;;							target = fmt.Sprintf("%d%%", *metric.Resource.TargetAverageUtilization)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						w.Write(LEVEL_1, "(as a percentage of request):\t%s / %s\n", current, target)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "<unknown metric type %q>", string(metric.Type))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			minReplicas := "<unset>"
0000000000000000000000000000000000000000;;			if hpa.Spec.MinReplicas != nil {
0000000000000000000000000000000000000000;;				minReplicas = fmt.Sprintf("%d", *hpa.Spec.MinReplicas)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Min replicas:\t%s\n", minReplicas)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Max replicas:\t%d\n", hpa.Spec.MaxReplicas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: switch to scale subresource once the required code is submitted.
0000000000000000000000000000000000000000;;			if strings.ToLower(hpa.Spec.ScaleTargetRef.Kind) == "replicationcontroller" {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "ReplicationController pods:\t")
0000000000000000000000000000000000000000;;				rc, err := d.client.Core().ReplicationControllers(hpa.Namespace).Get(hpa.Spec.ScaleTargetRef.Name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "%d current / %d desired\n", rc.Status.Replicas, rc.Spec.Replicas)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "failed to check Replication Controller\n")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(hpa.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Conditions:\n")
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "Type\tStatus\tReason\tMessage\n")
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "----\t------\t------\t-------\n")
0000000000000000000000000000000000000000;;				for _, c := range hpa.Status.Conditions {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%v\t%v\t%v\t%v\n", c.Type, c.Status, c.Reason, c.Message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeNodeResource(nodeNonTerminatedPodsList *api.PodList, node *api.Node, w PrefixWriter) error {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Non-terminated Pods:\t(%d in total)\n", len(nodeNonTerminatedPodsList.Items))
0000000000000000000000000000000000000000;;		w.Write(LEVEL_1, "Namespace\tName\t\tCPU Requests\tCPU Limits\tMemory Requests\tMemory Limits\n")
0000000000000000000000000000000000000000;;		w.Write(LEVEL_1, "---------\t----\t\t------------\t----------\t---------------\t-------------\n")
0000000000000000000000000000000000000000;;		allocatable := node.Status.Capacity
0000000000000000000000000000000000000000;;		if len(node.Status.Allocatable) > 0 {
0000000000000000000000000000000000000000;;			allocatable = node.Status.Allocatable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range nodeNonTerminatedPodsList.Items {
0000000000000000000000000000000000000000;;			req, limit, err := resourcehelper.PodRequestsAndLimits(&pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cpuReq, cpuLimit, memoryReq, memoryLimit := req[api.ResourceCPU], limit[api.ResourceCPU], req[api.ResourceMemory], limit[api.ResourceMemory]
0000000000000000000000000000000000000000;;			fractionCpuReq := float64(cpuReq.MilliValue()) / float64(allocatable.Cpu().MilliValue()) * 100
0000000000000000000000000000000000000000;;			fractionCpuLimit := float64(cpuLimit.MilliValue()) / float64(allocatable.Cpu().MilliValue()) * 100
0000000000000000000000000000000000000000;;			fractionMemoryReq := float64(memoryReq.Value()) / float64(allocatable.Memory().Value()) * 100
0000000000000000000000000000000000000000;;			fractionMemoryLimit := float64(memoryLimit.Value()) / float64(allocatable.Memory().Value()) * 100
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "%s\t%s\t\t%s (%d%%)\t%s (%d%%)\t%s (%d%%)\t%s (%d%%)\n", pod.Namespace, pod.Name,
0000000000000000000000000000000000000000;;				cpuReq.String(), int64(fractionCpuReq), cpuLimit.String(), int64(fractionCpuLimit),
0000000000000000000000000000000000000000;;				memoryReq.String(), int64(fractionMemoryReq), memoryLimit.String(), int64(fractionMemoryLimit))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Allocated resources:\n  (Total limits may be over 100 percent, i.e., overcommitted.)\n  CPU Requests\tCPU Limits\tMemory Requests\tMemory Limits\n")
0000000000000000000000000000000000000000;;		w.Write(LEVEL_1, "------------\t----------\t---------------\t-------------\n")
0000000000000000000000000000000000000000;;		reqs, limits, err := getPodsTotalRequestsAndLimits(nodeNonTerminatedPodsList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cpuReqs, cpuLimits, memoryReqs, memoryLimits := reqs[api.ResourceCPU], limits[api.ResourceCPU], reqs[api.ResourceMemory], limits[api.ResourceMemory]
0000000000000000000000000000000000000000;;		fractionCpuReqs := float64(cpuReqs.MilliValue()) / float64(allocatable.Cpu().MilliValue()) * 100
0000000000000000000000000000000000000000;;		fractionCpuLimits := float64(cpuLimits.MilliValue()) / float64(allocatable.Cpu().MilliValue()) * 100
0000000000000000000000000000000000000000;;		fractionMemoryReqs := float64(memoryReqs.Value()) / float64(allocatable.Memory().Value()) * 100
0000000000000000000000000000000000000000;;		fractionMemoryLimits := float64(memoryLimits.Value()) / float64(allocatable.Memory().Value()) * 100
0000000000000000000000000000000000000000;;		w.Write(LEVEL_1, "%s (%d%%)\t%s (%d%%)\t%s (%d%%)\t%s (%d%%)\n",
0000000000000000000000000000000000000000;;			cpuReqs.String(), int64(fractionCpuReqs), cpuLimits.String(), int64(fractionCpuLimits),
0000000000000000000000000000000000000000;;			memoryReqs.String(), int64(fractionMemoryReqs), memoryLimits.String(), int64(fractionMemoryLimits))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodsTotalRequestsAndLimits(podList *api.PodList) (reqs map[api.ResourceName]resource.Quantity, limits map[api.ResourceName]resource.Quantity, err error) {
0000000000000000000000000000000000000000;;		reqs, limits = map[api.ResourceName]resource.Quantity{}, map[api.ResourceName]resource.Quantity{}
0000000000000000000000000000000000000000;;		for _, pod := range podList.Items {
0000000000000000000000000000000000000000;;			podReqs, podLimits, err := resourcehelper.PodRequestsAndLimits(&pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for podReqName, podReqValue := range podReqs {
0000000000000000000000000000000000000000;;				if value, ok := reqs[podReqName]; !ok {
0000000000000000000000000000000000000000;;					reqs[podReqName] = *podReqValue.Copy()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value.Add(podReqValue)
0000000000000000000000000000000000000000;;					reqs[podReqName] = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for podLimitName, podLimitValue := range podLimits {
0000000000000000000000000000000000000000;;				if value, ok := limits[podLimitName]; !ok {
0000000000000000000000000000000000000000;;					limits[podLimitName] = *podLimitValue.Copy()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value.Add(podLimitValue)
0000000000000000000000000000000000000000;;					limits[podLimitName] = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DescribeEvents(el *api.EventList, w PrefixWriter) {
0000000000000000000000000000000000000000;;		if len(el.Items) == 0 {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Events:\t<none>\n")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(events.SortableEvents(el.Items))
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "Events:\n  FirstSeen\tLastSeen\tCount\tFrom\tSubObjectPath\tType\tReason\tMessage\n")
0000000000000000000000000000000000000000;;		w.Write(LEVEL_1, "---------\t--------\t-----\t----\t-------------\t--------\t------\t-------\n")
0000000000000000000000000000000000000000;;		for _, e := range el.Items {
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "%s\t%s\t%d\t%v\t%v\t%v\t%v\t%v\n",
0000000000000000000000000000000000000000;;				translateTimestamp(e.FirstTimestamp),
0000000000000000000000000000000000000000;;				translateTimestamp(e.LastTimestamp),
0000000000000000000000000000000000000000;;				e.Count,
0000000000000000000000000000000000000000;;				formatEventSource(e.Source),
0000000000000000000000000000000000000000;;				e.InvolvedObject.FieldPath,
0000000000000000000000000000000000000000;;				e.Type,
0000000000000000000000000000000000000000;;				e.Reason,
0000000000000000000000000000000000000000;;				e.Message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentDescriber generates information about a deployment.
0000000000000000000000000000000000000000;;	type DeploymentDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;		versionedClient versionedclientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dd *DeploymentDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		d, err := dd.versionedClient.Extensions().Deployments(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector, err := metav1.LabelSelectorAsSelector(d.Spec.Selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		internalDeployment := &extensions.Deployment{}
0000000000000000000000000000000000000000;;		if err := api.Scheme.Convert(d, internalDeployment, extensions.SchemeGroupVersion); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = dd.Core().Events(namespace).Search(api.Scheme, d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeDeployment(d, selector, internalDeployment, events, dd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeDeployment(d *versionedextension.Deployment, selector labels.Selector, internalDeployment *extensions.Deployment, events *api.EventList, dd *DeploymentDescriber) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", d.ObjectMeta.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", d.ObjectMeta.Namespace)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "CreationTimestamp:\t%s\n", d.CreationTimestamp.Time.Format(time.RFC1123Z))
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", d.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", d.Annotations)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Selector:\t%s\n", selector)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Replicas:\t%d desired | %d updated | %d total | %d available | %d unavailable\n", *(d.Spec.Replicas), d.Status.UpdatedReplicas, d.Status.Replicas, d.Status.AvailableReplicas, d.Status.UnavailableReplicas)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "StrategyType:\t%s\n", d.Spec.Strategy.Type)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "MinReadySeconds:\t%d\n", d.Spec.MinReadySeconds)
0000000000000000000000000000000000000000;;			if d.Spec.Strategy.RollingUpdate != nil {
0000000000000000000000000000000000000000;;				ru := d.Spec.Strategy.RollingUpdate
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "RollingUpdateStrategy:\t%s max unavailable, %s max surge\n", ru.MaxUnavailable.String(), ru.MaxSurge.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			DescribePodTemplate(&internalDeployment.Spec.Template, w)
0000000000000000000000000000000000000000;;			if len(d.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Conditions:\n  Type\tStatus\tReason\n")
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "----\t------\t------\n")
0000000000000000000000000000000000000000;;				for _, c := range d.Status.Conditions {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%v \t%v\t%v\n", c.Type, c.Status, c.Reason)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oldRSs, _, newRS, err := deploymentutil.GetAllReplicaSets(d, dd.versionedClient)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "OldReplicaSets:\t%s\n", printReplicaSetsByLabels(oldRSs))
0000000000000000000000000000000000000000;;				var newRSs []*versionedextension.ReplicaSet
0000000000000000000000000000000000000000;;				if newRS != nil {
0000000000000000000000000000000000000000;;					newRSs = append(newRSs, newRS)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "NewReplicaSet:\t%s\n", printReplicaSetsByLabels(newRSs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printReplicaSetsByLabels(matchingRSs []*versionedextension.ReplicaSet) string {
0000000000000000000000000000000000000000;;		// Format the matching ReplicaSets into strings.
0000000000000000000000000000000000000000;;		rsStrings := make([]string, 0, len(matchingRSs))
0000000000000000000000000000000000000000;;		for _, rs := range matchingRSs {
0000000000000000000000000000000000000000;;			rsStrings = append(rsStrings, fmt.Sprintf("%s (%d/%d replicas created)", rs.Name, rs.Status.Replicas, *rs.Spec.Replicas))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list := strings.Join(rsStrings, ", ")
0000000000000000000000000000000000000000;;		if list == "" {
0000000000000000000000000000000000000000;;			return "<none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPodStatusForController(c coreclient.PodInterface, selector labels.Selector, uid types.UID) (running, waiting, succeeded, failed int, err error) {
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{LabelSelector: selector.String()}
0000000000000000000000000000000000000000;;		rcPods, err := c.List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pod := range rcPods.Items {
0000000000000000000000000000000000000000;;			controllerRef := controller.GetControllerOf(&pod)
0000000000000000000000000000000000000000;;			// Skip pods that are orphans or owned by other controllers.
0000000000000000000000000000000000000000;;			if controllerRef == nil || controllerRef.UID != uid {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch pod.Status.Phase {
0000000000000000000000000000000000000000;;			case api.PodRunning:
0000000000000000000000000000000000000000;;				running++
0000000000000000000000000000000000000000;;			case api.PodPending:
0000000000000000000000000000000000000000;;				waiting++
0000000000000000000000000000000000000000;;			case api.PodSucceeded:
0000000000000000000000000000000000000000;;				succeeded++
0000000000000000000000000000000000000000;;			case api.PodFailed:
0000000000000000000000000000000000000000;;				failed++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMapDescriber generates information about a ConfigMap
0000000000000000000000000000000000000000;;	type ConfigMapDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ConfigMapDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Core().ConfigMaps(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configMap, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", configMap.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", configMap.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", configMap.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", configMap.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "\nData\n====\n")
0000000000000000000000000000000000000000;;			for k, v := range configMap.Data {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "%s:\n----\n", k)
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "%s\n", string(v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;				events, err := d.Core().Events(namespace).Search(api.Scheme, configMap)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if events != nil {
0000000000000000000000000000000000000000;;					DescribeEvents(events, w)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterDescriber struct {
0000000000000000000000000000000000000000;;		fedclientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ClusterDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		cluster, err := d.Federation().Clusters().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return describeCluster(cluster)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeCluster(cluster *federation.Cluster) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", cluster.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Labels:\t%s\n", labels.FormatLabels(cluster.Labels))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "ServerAddressByClientCIDRs:\n  ClientCIDR\tServerAddress\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_1, "----\t----\n")
0000000000000000000000000000000000000000;;			for _, cidrAddr := range cluster.Spec.ServerAddressByClientCIDRs {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "%v \t%v\n\n", cidrAddr.ClientCIDR, cidrAddr.ServerAddress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(cluster.Status.Conditions) > 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Conditions:\n  Type\tStatus\tLastUpdateTime\tLastTransitionTime\tReason\tMessage\n")
0000000000000000000000000000000000000000;;				w.Write(LEVEL_1, "----\t------\t-----------------\t------------------\t------\t-------\n")
0000000000000000000000000000000000000000;;				for _, c := range cluster.Status.Conditions {
0000000000000000000000000000000000000000;;					w.Write(LEVEL_1, "%v \t%v \t%s \t%s \t%v \t%v\n",
0000000000000000000000000000000000000000;;						c.Type,
0000000000000000000000000000000000000000;;						c.Status,
0000000000000000000000000000000000000000;;						c.LastProbeTime.Time.Format(time.RFC1123Z),
0000000000000000000000000000000000000000;;						c.LastTransitionTime.Time.Format(time.RFC1123Z),
0000000000000000000000000000000000000000;;						c.Reason,
0000000000000000000000000000000000000000;;						c.Message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtensionsNetworkPolicyDescriber generates information about an extensions.NetworkPolicy
0000000000000000000000000000000000000000;;	type ExtensionsNetworkPolicyDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *ExtensionsNetworkPolicyDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Extensions().NetworkPolicies(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		networkPolicy, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeExtensionsNetworkPolicy(networkPolicy)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeExtensionsNetworkPolicy(networkPolicy *extensions.NetworkPolicy) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", networkPolicy.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", networkPolicy.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", networkPolicy.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", networkPolicy.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkPolicyDescriber generates information about a networking.NetworkPolicy
0000000000000000000000000000000000000000;;	type NetworkPolicyDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *NetworkPolicyDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		c := d.Networking().NetworkPolicies(namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		networkPolicy, err := c.Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeNetworkPolicy(networkPolicy)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeNetworkPolicy(networkPolicy *networking.NetworkPolicy) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", networkPolicy.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Namespace:\t%s\n", networkPolicy.Namespace)
0000000000000000000000000000000000000000;;			printLabelsMultiline(w, "Labels", networkPolicy.Labels)
0000000000000000000000000000000000000000;;			printAnnotationsMultiline(w, "Annotations", networkPolicy.Annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StorageClassDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *StorageClassDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		sc, err := s.Storage().StorageClasses().Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = s.Core().Events(namespace).Search(api.Scheme, sc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describeStorageClass(sc, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describeStorageClass(sc *storage.StorageClass, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", sc.Name)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "IsDefaultClass:\t%s\n", storageutil.IsDefaultAnnotationText(sc.ObjectMeta))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Annotations:\t%s\n", labels.FormatLabels(sc.Annotations))
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Provisioner:\t%s\n", sc.Provisioner)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Parameters:\t%s\n", labels.FormatLabels(sc.Parameters))
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PodDisruptionBudgetDescriber struct {
0000000000000000000000000000000000000000;;		clientset.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PodDisruptionBudgetDescriber) Describe(namespace, name string, describerSettings printers.DescriberSettings) (string, error) {
0000000000000000000000000000000000000000;;		pdb, err := p.Policy().PodDisruptionBudgets(namespace).Get(name, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var events *api.EventList
0000000000000000000000000000000000000000;;		if describerSettings.ShowEvents {
0000000000000000000000000000000000000000;;			events, _ = p.Core().Events(namespace).Search(api.Scheme, pdb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return describePodDisruptionBudget(pdb, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func describePodDisruptionBudget(pdb *policy.PodDisruptionBudget, events *api.EventList) (string, error) {
0000000000000000000000000000000000000000;;		return tabbedString(func(out io.Writer) error {
0000000000000000000000000000000000000000;;			w := NewPrefixWriter(out)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Name:\t%s\n", pdb.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pdb.Spec.MinAvailable != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Min available:\t%s\n", pdb.Spec.MinAvailable.String())
0000000000000000000000000000000000000000;;			} else if pdb.Spec.MaxUnavailable != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Max unavailable:\t%s\n", pdb.Spec.MaxUnavailable.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pdb.Spec.Selector != nil {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Selector:\t%s\n", metav1.FormatLabelSelector(pdb.Spec.Selector))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "Selector:\t<unset>\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "Status:\n")
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Allowed disruptions:\t%d\n", pdb.Status.PodDisruptionsAllowed)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Current:\t%d\n", pdb.Status.CurrentHealthy)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Desired:\t%d\n", pdb.Status.DesiredHealthy)
0000000000000000000000000000000000000000;;			w.Write(LEVEL_2, "Total:\t%d\n", pdb.Status.ExpectedPods)
0000000000000000000000000000000000000000;;			if events != nil {
0000000000000000000000000000000000000000;;				DescribeEvents(events, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newErrNoDescriber creates a new ErrNoDescriber with the names of the provided types.
0000000000000000000000000000000000000000;;	func newErrNoDescriber(types ...reflect.Type) error {
0000000000000000000000000000000000000000;;		names := make([]string, 0, len(types))
0000000000000000000000000000000000000000;;		for _, t := range types {
0000000000000000000000000000000000000000;;			names = append(names, t.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return printers.ErrNoDescriber{Types: names}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describers implements ObjectDescriber against functions registered via Add. Those functions can
0000000000000000000000000000000000000000;;	// be strongly typed. Types are exactly matched (no conversion or assignable checks).
0000000000000000000000000000000000000000;;	type Describers struct {
0000000000000000000000000000000000000000;;		searchFns map[reflect.Type][]typeFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DescribeObject implements ObjectDescriber and will attempt to print the provided object to a string,
0000000000000000000000000000000000000000;;	// if at least one describer function has been registered with the exact types passed, or if any
0000000000000000000000000000000000000000;;	// describer can print the exact object in its first argument (the remainder will be provided empty
0000000000000000000000000000000000000000;;	// values). If no function registered with Add can satisfy the passed objects, an ErrNoDescriber will
0000000000000000000000000000000000000000;;	// be returned
0000000000000000000000000000000000000000;;	// TODO: reorder and partial match extra.
0000000000000000000000000000000000000000;;	func (d *Describers) DescribeObject(exact interface{}, extra ...interface{}) (string, error) {
0000000000000000000000000000000000000000;;		exactType := reflect.TypeOf(exact)
0000000000000000000000000000000000000000;;		fns, ok := d.searchFns[exactType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", newErrNoDescriber(exactType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(extra) == 0 {
0000000000000000000000000000000000000000;;			for _, typeFn := range fns {
0000000000000000000000000000000000000000;;				if len(typeFn.Extra) == 0 {
0000000000000000000000000000000000000000;;					return typeFn.Describe(exact, extra...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			typeFn := fns[0]
0000000000000000000000000000000000000000;;			for _, t := range typeFn.Extra {
0000000000000000000000000000000000000000;;				v := reflect.New(t).Elem()
0000000000000000000000000000000000000000;;				extra = append(extra, v.Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fns[0].Describe(exact, extra...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		types := make([]reflect.Type, 0, len(extra))
0000000000000000000000000000000000000000;;		for _, obj := range extra {
0000000000000000000000000000000000000000;;			types = append(types, reflect.TypeOf(obj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, typeFn := range fns {
0000000000000000000000000000000000000000;;			if typeFn.Matches(types) {
0000000000000000000000000000000000000000;;				return typeFn.Describe(exact, extra...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", newErrNoDescriber(append([]reflect.Type{exactType}, types...)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds one or more describer functions to the printers.Describer. The passed function must
0000000000000000000000000000000000000000;;	// match the signature:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     func(...) (string, error)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Any number of arguments may be provided.
0000000000000000000000000000000000000000;;	func (d *Describers) Add(fns ...interface{}) error {
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			fv := reflect.ValueOf(fn)
0000000000000000000000000000000000000000;;			ft := fv.Type()
0000000000000000000000000000000000000000;;			if ft.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;				return fmt.Errorf("expected func, got: %v", ft)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			numIn := ft.NumIn()
0000000000000000000000000000000000000000;;			if numIn == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("expected at least one 'in' params, got: %v", ft)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ft.NumOut() != 2 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("expected two 'out' params - (string, error), got: %v", ft)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			types := make([]reflect.Type, 0, numIn)
0000000000000000000000000000000000000000;;			for i := 0; i < numIn; i++ {
0000000000000000000000000000000000000000;;				types = append(types, ft.In(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ft.Out(0) != reflect.TypeOf(string("")) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("expected string return, got: %v", ft)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var forErrorType error
0000000000000000000000000000000000000000;;			// This convolution is necessary, otherwise TypeOf picks up on the fact
0000000000000000000000000000000000000000;;			// that forErrorType is nil.
0000000000000000000000000000000000000000;;			errorType := reflect.TypeOf(&forErrorType).Elem()
0000000000000000000000000000000000000000;;			if ft.Out(1) != errorType {
0000000000000000000000000000000000000000;;				return fmt.Errorf("expected error return, got: %v", ft)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			exact := types[0]
0000000000000000000000000000000000000000;;			extra := types[1:]
0000000000000000000000000000000000000000;;			if d.searchFns == nil {
0000000000000000000000000000000000000000;;				d.searchFns = make(map[reflect.Type][]typeFunc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fns := d.searchFns[exact]
0000000000000000000000000000000000000000;;			fn := typeFunc{Extra: extra, Fn: fv}
0000000000000000000000000000000000000000;;			fns = append(fns, fn)
0000000000000000000000000000000000000000;;			d.searchFns[exact] = fns
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeFunc holds information about a describer function and the types it accepts
0000000000000000000000000000000000000000;;	type typeFunc struct {
0000000000000000000000000000000000000000;;		Extra []reflect.Type
0000000000000000000000000000000000000000;;		Fn    reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matches returns true when the passed types exactly match the Extra list.
0000000000000000000000000000000000000000;;	func (fn typeFunc) Matches(types []reflect.Type) bool {
0000000000000000000000000000000000000000;;		if len(fn.Extra) != len(types) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// reorder the items in array types and fn.Extra
0000000000000000000000000000000000000000;;		// convert the type into string and sort them, check if they are matched
0000000000000000000000000000000000000000;;		varMap := make(map[reflect.Type]bool)
0000000000000000000000000000000000000000;;		for i := range fn.Extra {
0000000000000000000000000000000000000000;;			varMap[fn.Extra[i]] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range types {
0000000000000000000000000000000000000000;;			if _, found := varMap[types[i]]; !found {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describe invokes the nested function with the exact number of arguments.
0000000000000000000000000000000000000000;;	func (fn typeFunc) Describe(exact interface{}, extra ...interface{}) (string, error) {
0000000000000000000000000000000000000000;;		values := []reflect.Value{reflect.ValueOf(exact)}
0000000000000000000000000000000000000000;;		for _, obj := range extra {
0000000000000000000000000000000000000000;;			values = append(values, reflect.ValueOf(obj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := fn.Fn.Call(values)
0000000000000000000000000000000000000000;;		s := out[0].Interface().(string)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if !out[1].IsNil() {
0000000000000000000000000000000000000000;;			err = out[1].Interface().(error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printLabelsMultiline prints multiple labels with a proper alignment.
0000000000000000000000000000000000000000;;	func printLabelsMultiline(w PrefixWriter, title string, labels map[string]string) {
0000000000000000000000000000000000000000;;		printLabelsMultilineWithIndent(w, "", title, "\t", labels, sets.NewString())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printLabelsMultiline prints multiple labels with a user-defined alignment.
0000000000000000000000000000000000000000;;	func printLabelsMultilineWithIndent(w PrefixWriter, initialIndent, title, innerIndent string, labels map[string]string, skip sets.String) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "%s%s:%s", initialIndent, title, innerIndent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if labels == nil || len(labels) == 0 {
0000000000000000000000000000000000000000;;			w.WriteLine("<none>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// to print labels in the sorted order
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(labels))
0000000000000000000000000000000000000000;;		for key := range labels {
0000000000000000000000000000000000000000;;			if skip.Has(key) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keys = append(keys, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(keys) == 0 {
0000000000000000000000000000000000000000;;			w.WriteLine("<none>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, key := range keys {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "%s", initialIndent)
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "%s", innerIndent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(LEVEL_0, "%s=%s\n", key, labels[key])
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printTaintsMultiline prints multiple taints with a proper alignment.
0000000000000000000000000000000000000000;;	func printNodeTaintsMultiline(w PrefixWriter, title string, taints []api.Taint) {
0000000000000000000000000000000000000000;;		printTaintsMultilineWithIndent(w, "", title, "\t", taints)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printTaintsMultilineWithIndent prints multiple taints with a user-defined alignment.
0000000000000000000000000000000000000000;;	func printTaintsMultilineWithIndent(w PrefixWriter, initialIndent, title, innerIndent string, taints []api.Taint) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "%s%s:%s", initialIndent, title, innerIndent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if taints == nil || len(taints) == 0 {
0000000000000000000000000000000000000000;;			w.WriteLine("<none>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// to print taints in the sorted order
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(taints))
0000000000000000000000000000000000000000;;		for _, taint := range taints {
0000000000000000000000000000000000000000;;			keys = append(keys, string(taint.Effect)+","+taint.Key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, key := range keys {
0000000000000000000000000000000000000000;;			for _, taint := range taints {
0000000000000000000000000000000000000000;;				if string(taint.Effect)+","+taint.Key == key {
0000000000000000000000000000000000000000;;					if i != 0 {
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, "%s", initialIndent)
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, "%s", innerIndent)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "%s\n", taint.ToString())
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printPodTolerationsMultiline prints multiple tolerations with a proper alignment.
0000000000000000000000000000000000000000;;	func printPodTolerationsMultiline(w PrefixWriter, title string, tolerations []api.Toleration) {
0000000000000000000000000000000000000000;;		printTolerationsMultilineWithIndent(w, "", title, "\t", tolerations)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printTolerationsMultilineWithIndent prints multiple tolerations with a user-defined alignment.
0000000000000000000000000000000000000000;;	func printTolerationsMultilineWithIndent(w PrefixWriter, initialIndent, title, innerIndent string, tolerations []api.Toleration) {
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "%s%s:%s", initialIndent, title, innerIndent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tolerations == nil || len(tolerations) == 0 {
0000000000000000000000000000000000000000;;			w.WriteLine("<none>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// to print tolerations in the sorted order
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(tolerations))
0000000000000000000000000000000000000000;;		for _, toleration := range tolerations {
0000000000000000000000000000000000000000;;			keys = append(keys, toleration.Key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, key := range keys {
0000000000000000000000000000000000000000;;			for _, toleration := range tolerations {
0000000000000000000000000000000000000000;;				if toleration.Key == key {
0000000000000000000000000000000000000000;;					if i != 0 {
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, "%s", initialIndent)
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, "%s", innerIndent)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "%s", toleration.Key)
0000000000000000000000000000000000000000;;					if len(toleration.Value) != 0 {
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, "=%s", toleration.Value)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(toleration.Effect) != 0 {
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, ":%s", toleration.Effect)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if toleration.TolerationSeconds != nil {
0000000000000000000000000000000000000000;;						w.Write(LEVEL_0, " for %ds", *toleration.TolerationSeconds)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.Write(LEVEL_0, "\n")
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tabbedString(f func(io.Writer) error) (string, error) {
0000000000000000000000000000000000000000;;		out := new(tabwriter.Writer)
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		out.Init(buf, 0, 8, 1, '\t', 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := f(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Flush()
0000000000000000000000000000000000000000;;		str := string(buf.String())
0000000000000000000000000000000000000000;;		return str, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SortableResourceNames []api.ResourceName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableResourceNames) Len() int {
0000000000000000000000000000000000000000;;		return len(list)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableResourceNames) Swap(i, j int) {
0000000000000000000000000000000000000000;;		list[i], list[j] = list[j], list[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableResourceNames) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return list[i] < list[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SortedResourceNames returns the sorted resource names of a resource list.
0000000000000000000000000000000000000000;;	func SortedResourceNames(list api.ResourceList) []api.ResourceName {
0000000000000000000000000000000000000000;;		resources := make([]api.ResourceName, 0, len(list))
0000000000000000000000000000000000000000;;		for res := range list {
0000000000000000000000000000000000000000;;			resources = append(resources, res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(SortableResourceNames(resources))
0000000000000000000000000000000000000000;;		return resources
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SortableResourceQuotas []api.ResourceQuota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableResourceQuotas) Len() int {
0000000000000000000000000000000000000000;;		return len(list)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableResourceQuotas) Swap(i, j int) {
0000000000000000000000000000000000000000;;		list[i], list[j] = list[j], list[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableResourceQuotas) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return list[i].Name < list[j].Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SortableVolumeMounts []api.VolumeMount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableVolumeMounts) Len() int {
0000000000000000000000000000000000000000;;		return len(list)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableVolumeMounts) Swap(i, j int) {
0000000000000000000000000000000000000000;;		list[i], list[j] = list[j], list[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (list SortableVolumeMounts) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return list[i].MountPath < list[j].MountPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func versionedClientsetForDeployment(internalClient clientset.Interface) versionedclientset.Interface {
0000000000000000000000000000000000000000;;		if internalClient == nil {
0000000000000000000000000000000000000000;;			return &versionedclientset.Clientset{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &versionedclientset.Clientset{
0000000000000000000000000000000000000000;;			CoreV1Client:            coreclientset.New(internalClient.Core().RESTClient()),
0000000000000000000000000000000000000000;;			ExtensionsV1beta1Client: extensionsclientset.New(internalClient.Extensions().RESTClient()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var maxAnnotationLen = 200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printAnnotationsMultilineWithFilter prints filtered multiple annotations with a proper alignment.
0000000000000000000000000000000000000000;;	func printAnnotationsMultilineWithFilter(w PrefixWriter, title string, annotations map[string]string, skip sets.String) {
0000000000000000000000000000000000000000;;		printAnnotationsMultilineWithIndent(w, "", title, "\t", annotations, skip)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printAnnotationsMultiline prints multiple annotations with a proper alignment.
0000000000000000000000000000000000000000;;	func printAnnotationsMultiline(w PrefixWriter, title string, annotations map[string]string) {
0000000000000000000000000000000000000000;;		printAnnotationsMultilineWithIndent(w, "", title, "\t", annotations, sets.NewString())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printAnnotationsMultilineWithIndent prints multiple annotations with a user-defined alignment.
0000000000000000000000000000000000000000;;	// If annotation string is too long, we omit chars more than 200 length.
0000000000000000000000000000000000000000;;	func printAnnotationsMultilineWithIndent(w PrefixWriter, initialIndent, title, innerIndent string, annotations map[string]string, skip sets.String) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Write(LEVEL_0, "%s%s:%s", initialIndent, title, innerIndent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(annotations) == 0 {
0000000000000000000000000000000000000000;;			w.WriteLine("<none>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// to print labels in the sorted order
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(annotations))
0000000000000000000000000000000000000000;;		for key := range annotations {
0000000000000000000000000000000000000000;;			if skip.Has(key) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keys = append(keys, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(annotations) == 0 {
0000000000000000000000000000000000000000;;			w.WriteLine("<none>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, key := range keys {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, initialIndent)
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, innerIndent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := fmt.Sprintf("%s=%s", key, annotations[key])
0000000000000000000000000000000000000000;;			if len(line) > maxAnnotationLen {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "%s...\n", line[:maxAnnotationLen])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(LEVEL_0, "%s\n", line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
