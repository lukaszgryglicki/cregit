0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
d4c1bea151e6a908e64c0756c48fb11aeb0af019;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package printers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		metav1alpha1 "k8s.io/apimachinery/pkg/apis/meta/v1alpha1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TablePrinter interface {
0000000000000000000000000000000000000000;;		PrintTable(obj runtime.Object, options PrintOptions) (*metav1alpha1.Table, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PrintHandler interface {
0000000000000000000000000000000000000000;;		Handler(columns, columnsWithWide []string, printFunc interface{}) error
0000000000000000000000000000000000000000;;		TableHandler(columns []metav1alpha1.TableColumnDefinition, printFunc interface{}) error
0000000000000000000000000000000000000000;;		DefaultTableHandler(columns []metav1alpha1.TableColumnDefinition, printFunc interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var withNamespacePrefixColumns = []string{"NAMESPACE"} // TODO(erictune): print cluster name too.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type handlerEntry struct {
0000000000000000000000000000000000000000;;		columnDefinitions []metav1alpha1.TableColumnDefinition
0000000000000000000000000000000000000000;;		printRows         bool
0000000000000000000000000000000000000000;;		printFunc         reflect.Value
0000000000000000000000000000000000000000;;		args              []reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HumanReadablePrinter is an implementation of ResourcePrinter which attempts to provide
0000000000000000000000000000000000000000;;	// more elegant output. It is not threadsafe, but you may call PrintObj repeatedly; headers
0000000000000000000000000000000000000000;;	// will only be printed if the object type changes. This makes it useful for printing items
0000000000000000000000000000000000000000;;	// received from watches.
0000000000000000000000000000000000000000;;	type HumanReadablePrinter struct {
0000000000000000000000000000000000000000;;		handlerMap     map[reflect.Type]*handlerEntry
0000000000000000000000000000000000000000;;		defaultHandler *handlerEntry
0000000000000000000000000000000000000000;;		options        PrintOptions
0000000000000000000000000000000000000000;;		lastType       interface{}
0000000000000000000000000000000000000000;;		skipTabWriter  bool
0000000000000000000000000000000000000000;;		encoder        runtime.Encoder
0000000000000000000000000000000000000000;;		decoder        runtime.Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ PrintHandler = &HumanReadablePrinter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHumanReadablePrinter creates a HumanReadablePrinter.
0000000000000000000000000000000000000000;;	// If encoder and decoder are provided, an attempt to convert unstructured types to internal types is made.
0000000000000000000000000000000000000000;;	func NewHumanReadablePrinter(encoder runtime.Encoder, decoder runtime.Decoder, options PrintOptions) *HumanReadablePrinter {
0000000000000000000000000000000000000000;;		printer := &HumanReadablePrinter{
0000000000000000000000000000000000000000;;			handlerMap: make(map[reflect.Type]*handlerEntry),
0000000000000000000000000000000000000000;;			options:    options,
0000000000000000000000000000000000000000;;			encoder:    encoder,
0000000000000000000000000000000000000000;;			decoder:    decoder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return printer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTablePrinter creates a HumanReadablePrinter suitable for calling PrintTable().
0000000000000000000000000000000000000000;;	func NewTablePrinter() *HumanReadablePrinter {
0000000000000000000000000000000000000000;;		return &HumanReadablePrinter{
0000000000000000000000000000000000000000;;			handlerMap: make(map[reflect.Type]*handlerEntry),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddTabWriter sets whether the PrintObj function will format with tabwriter (true
0000000000000000000000000000000000000000;;	// by default).
0000000000000000000000000000000000000000;;	func (a *HumanReadablePrinter) AddTabWriter(t bool) *HumanReadablePrinter {
0000000000000000000000000000000000000000;;		a.skipTabWriter = !t
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *HumanReadablePrinter) With(fns ...func(PrintHandler)) *HumanReadablePrinter {
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			fn(a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResourceKind returns the type currently set for a resource
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) GetResourceKind() string {
0000000000000000000000000000000000000000;;		return h.options.Kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsurePrintWithKind sets HumanReadablePrinter options "WithKind" to true
0000000000000000000000000000000000000000;;	// and "Kind" to the string arg it receives, pre-pending this string
0000000000000000000000000000000000000000;;	// to the "NAME" column in an output of resources.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) EnsurePrintWithKind(kind string) {
0000000000000000000000000000000000000000;;		h.options.WithKind = true
0000000000000000000000000000000000000000;;		h.options.Kind = kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsurePrintHeaders sets the HumanReadablePrinter option "NoHeaders" to false
0000000000000000000000000000000000000000;;	// and removes the .lastType that was printed, which forces headers to be
0000000000000000000000000000000000000000;;	// printed in cases where multiple lists of the same resource are printed
0000000000000000000000000000000000000000;;	// consecutively, but are separated by non-printer related information.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) EnsurePrintHeaders() {
0000000000000000000000000000000000000000;;		h.options.NoHeaders = false
0000000000000000000000000000000000000000;;		h.lastType = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler adds a print handler with a given set of columns to HumanReadablePrinter instance.
0000000000000000000000000000000000000000;;	// See ValidatePrintHandlerFunc for required method signature.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) Handler(columns, columnsWithWide []string, printFunc interface{}) error {
0000000000000000000000000000000000000000;;		var columnDefinitions []metav1alpha1.TableColumnDefinition
0000000000000000000000000000000000000000;;		for _, column := range columns {
0000000000000000000000000000000000000000;;			columnDefinitions = append(columnDefinitions, metav1alpha1.TableColumnDefinition{
0000000000000000000000000000000000000000;;				Name: column,
0000000000000000000000000000000000000000;;				Type: "string",
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, column := range columnsWithWide {
0000000000000000000000000000000000000000;;			columnDefinitions = append(columnDefinitions, metav1alpha1.TableColumnDefinition{
0000000000000000000000000000000000000000;;				Name:     column,
0000000000000000000000000000000000000000;;				Type:     "string",
0000000000000000000000000000000000000000;;				Priority: 1,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		printFuncValue := reflect.ValueOf(printFunc)
0000000000000000000000000000000000000000;;		if err := ValidatePrintHandlerFunc(printFuncValue); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unable to register print function: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entry := &handlerEntry{
0000000000000000000000000000000000000000;;			columnDefinitions: columnDefinitions,
0000000000000000000000000000000000000000;;			printFunc:         printFuncValue,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objType := printFuncValue.Type().In(0)
0000000000000000000000000000000000000000;;		if _, ok := h.handlerMap[objType]; ok {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("registered duplicate printer for %v", objType)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.handlerMap[objType] = entry
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TableHandler adds a print handler with a given set of columns to HumanReadablePrinter instance.
0000000000000000000000000000000000000000;;	// See ValidateRowPrintHandlerFunc for required method signature.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) TableHandler(columnDefinitions []metav1alpha1.TableColumnDefinition, printFunc interface{}) error {
0000000000000000000000000000000000000000;;		printFuncValue := reflect.ValueOf(printFunc)
0000000000000000000000000000000000000000;;		if err := ValidateRowPrintHandlerFunc(printFuncValue); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unable to register print function: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entry := &handlerEntry{
0000000000000000000000000000000000000000;;			columnDefinitions: columnDefinitions,
0000000000000000000000000000000000000000;;			printRows:         true,
0000000000000000000000000000000000000000;;			printFunc:         printFuncValue,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objType := printFuncValue.Type().In(0)
0000000000000000000000000000000000000000;;		if _, ok := h.handlerMap[objType]; ok {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("registered duplicate printer for %v", objType)
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.handlerMap[objType] = entry
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultTableHandler registers a set of columns and a print func that is given a chance to process
0000000000000000000000000000000000000000;;	// any object without an explicit handler. Only the most recently set print handler is used.
0000000000000000000000000000000000000000;;	// See ValidateRowPrintHandlerFunc for required method signature.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) DefaultTableHandler(columnDefinitions []metav1alpha1.TableColumnDefinition, printFunc interface{}) error {
0000000000000000000000000000000000000000;;		printFuncValue := reflect.ValueOf(printFunc)
0000000000000000000000000000000000000000;;		if err := ValidateRowPrintHandlerFunc(printFuncValue); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unable to register print function: %v", err))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entry := &handlerEntry{
0000000000000000000000000000000000000000;;			columnDefinitions: columnDefinitions,
0000000000000000000000000000000000000000;;			printRows:         true,
0000000000000000000000000000000000000000;;			printFunc:         printFuncValue,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.defaultHandler = entry
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateRowPrintHandlerFunc validates print handler signature.
0000000000000000000000000000000000000000;;	// printFunc is the function that will be called to print an object.
0000000000000000000000000000000000000000;;	// It must be of the following type:
0000000000000000000000000000000000000000;;	//  func printFunc(object ObjectType, options PrintOptions) ([]metav1alpha1.TableRow, error)
0000000000000000000000000000000000000000;;	// where ObjectType is the type of the object that will be printed, and the first
0000000000000000000000000000000000000000;;	// return value is an array of rows, with each row containing a number of cells that
0000000000000000000000000000000000000000;;	// match the number of coulmns defined for that printer function.
0000000000000000000000000000000000000000;;	func ValidateRowPrintHandlerFunc(printFunc reflect.Value) error {
0000000000000000000000000000000000000000;;		if printFunc.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid print handler. %#v is not a function", printFunc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcType := printFunc.Type()
0000000000000000000000000000000000000000;;		if funcType.NumIn() != 2 || funcType.NumOut() != 2 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid print handler." +
0000000000000000000000000000000000000000;;				"Must accept 2 parameters and return 2 value.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if funcType.In(1) != reflect.TypeOf((*PrintOptions)(nil)).Elem() ||
0000000000000000000000000000000000000000;;			funcType.Out(0) != reflect.TypeOf((*[]metav1alpha1.TableRow)(nil)).Elem() ||
0000000000000000000000000000000000000000;;			funcType.Out(1) != reflect.TypeOf((*error)(nil)).Elem() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid print handler. The expected signature is: "+
0000000000000000000000000000000000000000;;				"func handler(obj %v, options PrintOptions) ([]metav1alpha1.TableRow, error)", funcType.In(0))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidatePrintHandlerFunc validates print handler signature.
0000000000000000000000000000000000000000;;	// printFunc is the function that will be called to print an object.
0000000000000000000000000000000000000000;;	// It must be of the following type:
0000000000000000000000000000000000000000;;	//  func printFunc(object ObjectType, w io.Writer, options PrintOptions) error
0000000000000000000000000000000000000000;;	// where ObjectType is the type of the object that will be printed.
0000000000000000000000000000000000000000;;	// DEPRECATED: will be replaced with ValidateRowPrintHandlerFunc
0000000000000000000000000000000000000000;;	func ValidatePrintHandlerFunc(printFunc reflect.Value) error {
0000000000000000000000000000000000000000;;		if printFunc.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid print handler. %#v is not a function", printFunc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcType := printFunc.Type()
0000000000000000000000000000000000000000;;		if funcType.NumIn() != 3 || funcType.NumOut() != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid print handler." +
0000000000000000000000000000000000000000;;				"Must accept 3 parameters and return 1 value.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if funcType.In(1) != reflect.TypeOf((*io.Writer)(nil)).Elem() ||
0000000000000000000000000000000000000000;;			funcType.In(2) != reflect.TypeOf((*PrintOptions)(nil)).Elem() ||
0000000000000000000000000000000000000000;;			funcType.Out(0) != reflect.TypeOf((*error)(nil)).Elem() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid print handler. The expected signature is: "+
0000000000000000000000000000000000000000;;				"func handler(obj %v, w io.Writer, options PrintOptions) error", funcType.In(0))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) HandledResources() []string {
0000000000000000000000000000000000000000;;		keys := make([]string, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := range h.handlerMap {
0000000000000000000000000000000000000000;;			// k.String looks like "*api.PodList" and we want just "pod"
0000000000000000000000000000000000000000;;			api := strings.Split(k.String(), ".")
0000000000000000000000000000000000000000;;			resource := api[len(api)-1]
0000000000000000000000000000000000000000;;			if strings.HasSuffix(resource, "List") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resource = strings.ToLower(resource)
0000000000000000000000000000000000000000;;			keys = append(keys, resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) AfterPrint(output io.Writer, res string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) IsGeneric() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) unknown(data []byte, w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, "Unknown object: %s", string(data))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printHeader(columnNames []string, w io.Writer) error {
0000000000000000000000000000000000000000;;		if _, err := fmt.Fprintf(w, "%s\n", strings.Join(columnNames, "\t")); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintObj prints the obj in a human-friendly format according to the type of the obj.
0000000000000000000000000000000000000000;;	// TODO: unify the behavior of PrintObj, which often expects single items and tracks
0000000000000000000000000000000000000000;;	// headers and filtering, with other printers, that expect list objects. The tracking
0000000000000000000000000000000000000000;;	// behavior should probably be a higher level wrapper (MultiObjectTablePrinter) that
0000000000000000000000000000000000000000;;	// calls into the PrintTable method and then displays consistent output.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) PrintObj(obj runtime.Object, output io.Writer) error {
0000000000000000000000000000000000000000;;		if w, found := output.(*tabwriter.Writer); !found && !h.skipTabWriter {
0000000000000000000000000000000000000000;;			w = GetNewTabWriter(output)
0000000000000000000000000000000000000000;;			output = w
0000000000000000000000000000000000000000;;			defer w.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// display tables following the rules of options
0000000000000000000000000000000000000000;;		if table, ok := obj.(*metav1alpha1.Table); ok {
0000000000000000000000000000000000000000;;			if err := DecorateTable(table, h.options); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return PrintTable(table, output, h.options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if the object is unstructured.  If so, let's attempt to convert it to a type we can understand before
0000000000000000000000000000000000000000;;		// trying to print, since the printers are keyed by type.  This is extremely expensive.
0000000000000000000000000000000000000000;;		if h.encoder != nil && h.decoder != nil {
0000000000000000000000000000000000000000;;			obj, _ = decodeUnknownObject(obj, h.encoder, h.decoder)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// print with a registered handler
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		if handler := h.handlerMap[t]; handler != nil {
0000000000000000000000000000000000000000;;			includeHeaders := h.lastType != t && !h.options.NoHeaders
0000000000000000000000000000000000000000;;			if err := printRowsForHandlerEntry(output, handler, obj, h.options, includeHeaders); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.lastType = t
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// print with the default handler if set, and use the columns from the last time
0000000000000000000000000000000000000000;;		if h.defaultHandler != nil {
0000000000000000000000000000000000000000;;			includeHeaders := h.lastType != h.defaultHandler && !h.options.NoHeaders
0000000000000000000000000000000000000000;;			if err := printRowsForHandlerEntry(output, h.defaultHandler, obj, h.options, includeHeaders); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.lastType = h.defaultHandler
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we failed all reasonable printing efforts, report failure
0000000000000000000000000000000000000000;;		return fmt.Errorf("error: unknown type %#v", obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasCondition(conditions []metav1alpha1.TableRowCondition, t metav1alpha1.RowConditionType) bool {
0000000000000000000000000000000000000000;;		for _, condition := range conditions {
0000000000000000000000000000000000000000;;			if condition.Type == t {
0000000000000000000000000000000000000000;;				return condition.Status == metav1alpha1.ConditionTrue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintTable prints a table to the provided output respecting the filtering rules for options
0000000000000000000000000000000000000000;;	// for wide columns and filetred rows. It filters out rows that are Completed. You should call
0000000000000000000000000000000000000000;;	// DecorateTable if you receive a table from a remote server before calling PrintTable.
0000000000000000000000000000000000000000;;	func PrintTable(table *metav1alpha1.Table, output io.Writer, options PrintOptions) error {
0000000000000000000000000000000000000000;;		if !options.NoHeaders {
0000000000000000000000000000000000000000;;			first := true
0000000000000000000000000000000000000000;;			for _, column := range table.ColumnDefinitions {
0000000000000000000000000000000000000000;;				if !options.Wide && column.Priority != 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if first {
0000000000000000000000000000000000000000;;					first = false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprint(output, "\t")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprint(output, strings.ToUpper(column.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintln(output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, row := range table.Rows {
0000000000000000000000000000000000000000;;			if !options.ShowAll && hasCondition(row.Conditions, metav1alpha1.RowCompleted) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			first := true
0000000000000000000000000000000000000000;;			for i, cell := range row.Cells {
0000000000000000000000000000000000000000;;				column := table.ColumnDefinitions[i]
0000000000000000000000000000000000000000;;				if !options.Wide && column.Priority != 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if first {
0000000000000000000000000000000000000000;;					first = false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprint(output, "\t")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cell != nil {
0000000000000000000000000000000000000000;;					fmt.Fprint(output, cell)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintln(output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecorateTable takes a table and attempts to add label columns and the
0000000000000000000000000000000000000000;;	// namespace column. It will fill empty columns with nil (if the object
0000000000000000000000000000000000000000;;	// does not expose metadata). It returns an error if the table cannot
0000000000000000000000000000000000000000;;	// be decorated.
0000000000000000000000000000000000000000;;	func DecorateTable(table *metav1alpha1.Table, options PrintOptions) error {
0000000000000000000000000000000000000000;;		width := len(table.ColumnDefinitions) + len(options.ColumnLabels)
0000000000000000000000000000000000000000;;		if options.WithNamespace {
0000000000000000000000000000000000000000;;			width++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.ShowLabels {
0000000000000000000000000000000000000000;;			width++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		columns := table.ColumnDefinitions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameColumn := -1
0000000000000000000000000000000000000000;;		if options.WithKind && len(options.Kind) > 0 {
0000000000000000000000000000000000000000;;			for i := range columns {
0000000000000000000000000000000000000000;;				if columns[i].Format == "name" && columns[i].Type == "string" {
0000000000000000000000000000000000000000;;					nameColumn = i
0000000000000000000000000000000000000000;;					fmt.Printf("found name column: %d\n", i)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if width != len(table.ColumnDefinitions) {
0000000000000000000000000000000000000000;;			columns = make([]metav1alpha1.TableColumnDefinition, 0, width)
0000000000000000000000000000000000000000;;			if options.WithNamespace {
0000000000000000000000000000000000000000;;				columns = append(columns, metav1alpha1.TableColumnDefinition{
0000000000000000000000000000000000000000;;					Name: "Namespace",
0000000000000000000000000000000000000000;;					Type: "string",
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			columns = append(columns, table.ColumnDefinitions...)
0000000000000000000000000000000000000000;;			for _, label := range formatLabelHeaders(options.ColumnLabels) {
0000000000000000000000000000000000000000;;				columns = append(columns, metav1alpha1.TableColumnDefinition{
0000000000000000000000000000000000000000;;					Name: label,
0000000000000000000000000000000000000000;;					Type: "string",
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.ShowLabels {
0000000000000000000000000000000000000000;;				columns = append(columns, metav1alpha1.TableColumnDefinition{
0000000000000000000000000000000000000000;;					Name: "Labels",
0000000000000000000000000000000000000000;;					Type: "string",
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rows := table.Rows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		includeLabels := len(options.ColumnLabels) > 0 || options.ShowLabels
0000000000000000000000000000000000000000;;		if includeLabels || options.WithNamespace || nameColumn != -1 {
0000000000000000000000000000000000000000;;			for i := range rows {
0000000000000000000000000000000000000000;;				row := rows[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if nameColumn != -1 {
0000000000000000000000000000000000000000;;					row.Cells[nameColumn] = fmt.Sprintf("%s/%s", options.Kind, row.Cells[nameColumn])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var m metav1.Object
0000000000000000000000000000000000000000;;				if obj := row.Object.Object; obj != nil {
0000000000000000000000000000000000000000;;					if acc, err := meta.Accessor(obj); err == nil {
0000000000000000000000000000000000000000;;						m = acc
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// if we can't get an accessor, fill out the appropriate columns with empty spaces
0000000000000000000000000000000000000000;;				if m == nil {
0000000000000000000000000000000000000000;;					if options.WithNamespace {
0000000000000000000000000000000000000000;;						r := make([]interface{}, 1, width)
0000000000000000000000000000000000000000;;						row.Cells = append(r, row.Cells...)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for j := 0; j < width-len(row.Cells); j++ {
0000000000000000000000000000000000000000;;						row.Cells = append(row.Cells, nil)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rows[i] = row
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if options.WithNamespace {
0000000000000000000000000000000000000000;;					r := make([]interface{}, 1, width)
0000000000000000000000000000000000000000;;					r[0] = m.GetNamespace()
0000000000000000000000000000000000000000;;					row.Cells = append(r, row.Cells...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if includeLabels {
0000000000000000000000000000000000000000;;					row.Cells = appendLabelCells(row.Cells, m.GetLabels(), options)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rows[i] = row
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table.ColumnDefinitions = columns
0000000000000000000000000000000000000000;;		table.Rows = rows
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintTable returns a table for the provided object, using the printer registered for that type. It returns
0000000000000000000000000000000000000000;;	// a table that includes all of the information requested by options, but will not remove rows or columns. The
0000000000000000000000000000000000000000;;	// caller is responsible for applying rules related to filtering rows or columns.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) PrintTable(obj runtime.Object, options PrintOptions) (*metav1alpha1.Table, error) {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		handler, ok := h.handlerMap[t]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no table handler registered for this type %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !handler.printRows {
0000000000000000000000000000000000000000;;			return h.legacyPrinterToTable(obj, handler)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := []reflect.Value{reflect.ValueOf(obj), reflect.ValueOf(options)}
0000000000000000000000000000000000000000;;		results := handler.printFunc.Call(args)
0000000000000000000000000000000000000000;;		if !results[1].IsNil() {
0000000000000000000000000000000000000000;;			return nil, results[1].Interface().(error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		columns := handler.columnDefinitions
0000000000000000000000000000000000000000;;		if !options.Wide {
0000000000000000000000000000000000000000;;			columns = make([]metav1alpha1.TableColumnDefinition, 0, len(handler.columnDefinitions))
0000000000000000000000000000000000000000;;			for i := range handler.columnDefinitions {
0000000000000000000000000000000000000000;;				if handler.columnDefinitions[i].Priority != 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				columns = append(columns, handler.columnDefinitions[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := &metav1alpha1.Table{
0000000000000000000000000000000000000000;;			ListMeta: metav1.ListMeta{
0000000000000000000000000000000000000000;;				ResourceVersion: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ColumnDefinitions: columns,
0000000000000000000000000000000000000000;;			Rows:              results[0].Interface().([]metav1alpha1.TableRow),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := DecorateTable(table, options); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return table, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printRowsForHandlerEntry prints the incremental table output (headers if the current type is
0000000000000000000000000000000000000000;;	// different from lastType) including all the rows in the object. It returns the current type
0000000000000000000000000000000000000000;;	// or an error, if any.
0000000000000000000000000000000000000000;;	func printRowsForHandlerEntry(output io.Writer, handler *handlerEntry, obj runtime.Object, options PrintOptions, includeHeaders bool) error {
0000000000000000000000000000000000000000;;		if includeHeaders {
0000000000000000000000000000000000000000;;			var headers []string
0000000000000000000000000000000000000000;;			for _, column := range handler.columnDefinitions {
0000000000000000000000000000000000000000;;				if column.Priority != 0 && !options.Wide {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				headers = append(headers, strings.ToUpper(column.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			headers = append(headers, formatLabelHeaders(options.ColumnLabels)...)
0000000000000000000000000000000000000000;;			// LABELS is always the last column.
0000000000000000000000000000000000000000;;			headers = append(headers, formatShowLabelsHeader(options.ShowLabels)...)
0000000000000000000000000000000000000000;;			if options.WithNamespace {
0000000000000000000000000000000000000000;;				headers = append(withNamespacePrefixColumns, headers...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			printHeader(headers, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !handler.printRows {
0000000000000000000000000000000000000000;;			// TODO: this code path is deprecated and will be removed when all handlers are row printers
0000000000000000000000000000000000000000;;			args := []reflect.Value{reflect.ValueOf(obj), reflect.ValueOf(output), reflect.ValueOf(options)}
0000000000000000000000000000000000000000;;			resultValue := handler.printFunc.Call(args)[0]
0000000000000000000000000000000000000000;;			if resultValue.IsNil() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resultValue.Interface().(error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := []reflect.Value{reflect.ValueOf(obj), reflect.ValueOf(options)}
0000000000000000000000000000000000000000;;		results := handler.printFunc.Call(args)
0000000000000000000000000000000000000000;;		if results[1].IsNil() {
0000000000000000000000000000000000000000;;			rows := results[0].Interface().([]metav1alpha1.TableRow)
0000000000000000000000000000000000000000;;			printRows(output, rows, options)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results[1].Interface().(error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printRows writes the provided rows to output.
0000000000000000000000000000000000000000;;	func printRows(output io.Writer, rows []metav1alpha1.TableRow, options PrintOptions) {
0000000000000000000000000000000000000000;;		for _, row := range rows {
0000000000000000000000000000000000000000;;			if options.WithNamespace {
0000000000000000000000000000000000000000;;				if obj := row.Object.Object; obj != nil {
0000000000000000000000000000000000000000;;					if m, err := meta.Accessor(obj); err == nil {
0000000000000000000000000000000000000000;;						fmt.Fprint(output, m.GetNamespace())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprint(output, "\t")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, cell := range row.Cells {
0000000000000000000000000000000000000000;;				if i != 0 {
0000000000000000000000000000000000000000;;					fmt.Fprint(output, "\t")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// TODO: remove this once we drop the legacy printers
0000000000000000000000000000000000000000;;					if options.WithKind && len(options.Kind) > 0 {
0000000000000000000000000000000000000000;;						fmt.Fprintf(output, "%s/%s", options.Kind, cell)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprint(output, cell)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hasLabels := len(options.ColumnLabels) > 0
0000000000000000000000000000000000000000;;			if obj := row.Object.Object; obj != nil && (hasLabels || options.ShowLabels) {
0000000000000000000000000000000000000000;;				if m, err := meta.Accessor(obj); err == nil {
0000000000000000000000000000000000000000;;					for _, value := range labelValues(m.GetLabels(), options) {
0000000000000000000000000000000000000000;;						output.Write([]byte("\t"))
0000000000000000000000000000000000000000;;						output.Write([]byte(value))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			output.Write([]byte("\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// legacyPrinterToTable uses the old printFunc with tabbed writer to generate a table.
0000000000000000000000000000000000000000;;	// TODO: remove when all legacy printers are removed.
0000000000000000000000000000000000000000;;	func (h *HumanReadablePrinter) legacyPrinterToTable(obj runtime.Object, handler *handlerEntry) (*metav1alpha1.Table, error) {
0000000000000000000000000000000000000000;;		printFunc := handler.printFunc
0000000000000000000000000000000000000000;;		table := &metav1alpha1.Table{
0000000000000000000000000000000000000000;;			ColumnDefinitions: handler.columnDefinitions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := PrintOptions{
0000000000000000000000000000000000000000;;			NoHeaders: true,
0000000000000000000000000000000000000000;;			Wide:      true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		args := []reflect.Value{reflect.ValueOf(obj), reflect.ValueOf(buf), reflect.ValueOf(options)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if meta.IsListType(obj) {
0000000000000000000000000000000000000000;;			// TODO: this uses more memory than it has to, as we refactor printers we should remove the need
0000000000000000000000000000000000000000;;			// for this.
0000000000000000000000000000000000000000;;			args[0] = reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;			resultValue := printFunc.Call(args)[0]
0000000000000000000000000000000000000000;;			if !resultValue.IsNil() {
0000000000000000000000000000000000000000;;				return nil, resultValue.Interface().(error)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data := buf.Bytes()
0000000000000000000000000000000000000000;;			i := 0
0000000000000000000000000000000000000000;;			items, err := meta.ExtractList(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for len(data) > 0 {
0000000000000000000000000000000000000000;;				cells, remainder := tabbedLineToCells(data, len(table.ColumnDefinitions))
0000000000000000000000000000000000000000;;				table.Rows = append(table.Rows, metav1alpha1.TableRow{
0000000000000000000000000000000000000000;;					Cells:  cells,
0000000000000000000000000000000000000000;;					Object: runtime.RawExtension{Object: items[i]},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				data = remainder
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			args[0] = reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;			resultValue := printFunc.Call(args)[0]
0000000000000000000000000000000000000000;;			if !resultValue.IsNil() {
0000000000000000000000000000000000000000;;				return nil, resultValue.Interface().(error)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data := buf.Bytes()
0000000000000000000000000000000000000000;;			cells, _ := tabbedLineToCells(data, len(table.ColumnDefinitions))
0000000000000000000000000000000000000000;;			table.Rows = append(table.Rows, metav1alpha1.TableRow{
0000000000000000000000000000000000000000;;				Cells:  cells,
0000000000000000000000000000000000000000;;				Object: runtime.RawExtension{Object: obj},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return table, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: this method assumes the meta/v1 server API, so should be refactored out of this package
0000000000000000000000000000000000000000;;	func printUnstructured(unstructured runtime.Unstructured, w io.Writer, additionalFields []string, options PrintOptions) error {
0000000000000000000000000000000000000000;;		metadata, err := meta.Accessor(unstructured)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.WithNamespace {
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprintf(w, "%s\t", metadata.GetNamespace()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		content := unstructured.UnstructuredContent()
0000000000000000000000000000000000000000;;		kind := "<missing>"
0000000000000000000000000000000000000000;;		if objKind, ok := content["kind"]; ok {
0000000000000000000000000000000000000000;;			if str, ok := objKind.(string); ok {
0000000000000000000000000000000000000000;;				kind = str
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if objAPIVersion, ok := content["apiVersion"]; ok {
0000000000000000000000000000000000000000;;			if str, ok := objAPIVersion.(string); ok {
0000000000000000000000000000000000000000;;				version, err := schema.ParseGroupVersion(str)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kind = kind + "." + version.Version + "." + version.Group
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := FormatResourceName(options.Kind, metadata.GetName(), options.WithKind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := fmt.Fprintf(w, "%s\t%s", name, kind); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, field := range additionalFields {
0000000000000000000000000000000000000000;;			if value, ok := content[field]; ok {
0000000000000000000000000000000000000000;;				var formattedValue string
0000000000000000000000000000000000000000;;				switch typedValue := value.(type) {
0000000000000000000000000000000000000000;;				case []interface{}:
0000000000000000000000000000000000000000;;					formattedValue = fmt.Sprintf("%d item(s)", len(typedValue))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					formattedValue = fmt.Sprintf("%v", value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err := fmt.Fprintf(w, "\t%s", formattedValue); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := fmt.Fprint(w, AppendLabels(metadata.GetLabels(), options.ColumnLabels)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := fmt.Fprint(w, AppendAllLabels(options.ShowLabels, metadata.GetLabels())); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatLabelHeaders(columnLabels []string) []string {
0000000000000000000000000000000000000000;;		formHead := make([]string, len(columnLabels))
0000000000000000000000000000000000000000;;		for i, l := range columnLabels {
0000000000000000000000000000000000000000;;			p := strings.Split(l, "/")
0000000000000000000000000000000000000000;;			formHead[i] = strings.ToUpper((p[len(p)-1]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return formHead
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// headers for --show-labels=true
0000000000000000000000000000000000000000;;	func formatShowLabelsHeader(showLabels bool) []string {
0000000000000000000000000000000000000000;;		if showLabels {
0000000000000000000000000000000000000000;;			return []string{"LABELS"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// labelValues returns a slice of value columns matching the requested print options.
0000000000000000000000000000000000000000;;	func labelValues(itemLabels map[string]string, opts PrintOptions) []string {
0000000000000000000000000000000000000000;;		var values []string
0000000000000000000000000000000000000000;;		for _, key := range opts.ColumnLabels {
0000000000000000000000000000000000000000;;			values = append(values, itemLabels[key])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.ShowLabels {
0000000000000000000000000000000000000000;;			values = append(values, labels.FormatLabels(itemLabels))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return values
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendLabelCells returns a slice of value columns matching the requested print options.
0000000000000000000000000000000000000000;;	// Intended for use with tables.
0000000000000000000000000000000000000000;;	func appendLabelCells(values []interface{}, itemLabels map[string]string, opts PrintOptions) []interface{} {
0000000000000000000000000000000000000000;;		for _, key := range opts.ColumnLabels {
0000000000000000000000000000000000000000;;			values = append(values, itemLabels[key])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.ShowLabels {
0000000000000000000000000000000000000000;;			values = append(values, labels.FormatLabels(itemLabels))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return values
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatResourceName receives a resource kind, name, and boolean specifying
0000000000000000000000000000000000000000;;	// whether or not to update the current name to "kind/name"
0000000000000000000000000000000000000000;;	func FormatResourceName(kind, name string, withKind bool) string {
0000000000000000000000000000000000000000;;		if !withKind || kind == "" {
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return kind + "/" + name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AppendLabels(itemLabels map[string]string, columnLabels []string) string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cl := range columnLabels {
0000000000000000000000000000000000000000;;			buffer.WriteString(fmt.Sprint("\t"))
0000000000000000000000000000000000000000;;			if il, ok := itemLabels[cl]; ok {
0000000000000000000000000000000000000000;;				buffer.WriteString(fmt.Sprint(il))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buffer.WriteString("<none>")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Append all labels to a single column. We need this even when show-labels flag* is
0000000000000000000000000000000000000000;;	// false, since this adds newline delimiter to the end of each row.
0000000000000000000000000000000000000000;;	func AppendAllLabels(showLabels bool, itemLabels map[string]string) string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if showLabels {
0000000000000000000000000000000000000000;;			buffer.WriteString(fmt.Sprint("\t"))
0000000000000000000000000000000000000000;;			buffer.WriteString(labels.FormatLabels(itemLabels))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buffer.WriteString("\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// check if the object is unstructured. If so, attempt to convert it to a type we can understand.
0000000000000000000000000000000000000000;;	func decodeUnknownObject(obj runtime.Object, encoder runtime.Encoder, decoder runtime.Decoder) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch obj.(type) {
0000000000000000000000000000000000000000;;		case runtime.Unstructured, *runtime.Unknown:
0000000000000000000000000000000000000000;;			if objBytes, err := runtime.Encode(encoder, obj); err == nil {
0000000000000000000000000000000000000000;;				if decodedObj, err := runtime.Decode(decoder, objBytes); err == nil {
0000000000000000000000000000000000000000;;					obj = decodedObj
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tabbedLineToCells(data []byte, expected int) ([]interface{}, []byte) {
0000000000000000000000000000000000000000;;		var remainder []byte
0000000000000000000000000000000000000000;;		max := bytes.Index(data, []byte("\n"))
0000000000000000000000000000000000000000;;		if max != -1 {
0000000000000000000000000000000000000000;;			remainder = data[max+1:]
0000000000000000000000000000000000000000;;			data = data[:max]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cells := make([]interface{}, expected)
0000000000000000000000000000000000000000;;		for i := 0; i < expected; i++ {
0000000000000000000000000000000000000000;;			next := bytes.Index(data, []byte("\t"))
0000000000000000000000000000000000000000;;			if next == -1 {
0000000000000000000000000000000000000000;;				cells[i] = string(data)
0000000000000000000000000000000000000000;;				// fill the remainder with empty strings, this indicates a printer bug
0000000000000000000000000000000000000000;;				for j := i + 1; j < expected; j++ {
0000000000000000000000000000000000000000;;					cells[j] = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cells[i] = string(data[:next])
0000000000000000000000000000000000000000;;			data = data[next+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cells, remainder
0000000000000000000000000000000000000000;;	}
