0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
667f579068799477fdbcbb017bfc292825f8ec26;pkg/master/publish.go[pkg/master/publish.go][pkg/master/controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/endpoints"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/rangeallocation"
0000000000000000000000000000000000000000;;		corerest "k8s.io/kubernetes/pkg/registry/core/rest"
0000000000000000000000000000000000000000;;		servicecontroller "k8s.io/kubernetes/pkg/registry/core/service/ipallocator/controller"
0000000000000000000000000000000000000000;;		portallocatorcontroller "k8s.io/kubernetes/pkg/registry/core/service/portallocator/controller"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util/async"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const kubernetesServiceName = "kubernetes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Controller is the controller manager for the core bootstrap Kubernetes
0000000000000000000000000000000000000000;;	// controller loops, which manage creating the "kubernetes" service, the
0000000000000000000000000000000000000000;;	// "default", "kube-system" and "kube-public" namespaces, and provide the IP
0000000000000000000000000000000000000000;;	// repair check on service IPs
0000000000000000000000000000000000000000;;	type Controller struct {
0000000000000000000000000000000000000000;;		ServiceClient   coreclient.ServicesGetter
0000000000000000000000000000000000000000;;		NamespaceClient coreclient.NamespacesGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ServiceClusterIPRegistry rangeallocation.RangeRegistry
0000000000000000000000000000000000000000;;		ServiceClusterIPInterval time.Duration
0000000000000000000000000000000000000000;;		ServiceClusterIPRange    net.IPNet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ServiceNodePortRegistry rangeallocation.RangeRegistry
0000000000000000000000000000000000000000;;		ServiceNodePortInterval time.Duration
0000000000000000000000000000000000000000;;		ServiceNodePortRange    utilnet.PortRange
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EndpointReconciler EndpointReconciler
0000000000000000000000000000000000000000;;		EndpointInterval   time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SystemNamespaces         []string
0000000000000000000000000000000000000000;;		SystemNamespacesInterval time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PublicIP net.IP
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceIP indicates where the kubernetes service will live.  It may not be nil.
0000000000000000000000000000000000000000;;		ServiceIP                 net.IP
0000000000000000000000000000000000000000;;		ServicePort               int
0000000000000000000000000000000000000000;;		ExtraServicePorts         []api.ServicePort
0000000000000000000000000000000000000000;;		ExtraEndpointPorts        []api.EndpointPort
0000000000000000000000000000000000000000;;		PublicServicePort         int
0000000000000000000000000000000000000000;;		KubernetesServiceNodePort int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner *async.Runner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBootstrapController returns a controller for watching the core capabilities of the master
0000000000000000000000000000000000000000;;	func (c *Config) NewBootstrapController(legacyRESTStorage corerest.LegacyRESTStorage, serviceClient coreclient.ServicesGetter, nsClient coreclient.NamespacesGetter) *Controller {
0000000000000000000000000000000000000000;;		return &Controller{
0000000000000000000000000000000000000000;;			ServiceClient:   serviceClient,
0000000000000000000000000000000000000000;;			NamespaceClient: nsClient,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			EndpointReconciler: c.EndpointReconcilerConfig.Reconciler,
0000000000000000000000000000000000000000;;			EndpointInterval:   c.EndpointReconcilerConfig.Interval,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			SystemNamespaces:         []string{metav1.NamespaceSystem, metav1.NamespacePublic},
0000000000000000000000000000000000000000;;			SystemNamespacesInterval: 1 * time.Minute,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ServiceClusterIPRegistry: legacyRESTStorage.ServiceClusterIPAllocator,
0000000000000000000000000000000000000000;;			ServiceClusterIPRange:    c.ServiceIPRange,
0000000000000000000000000000000000000000;;			ServiceClusterIPInterval: 3 * time.Minute,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ServiceNodePortRegistry: legacyRESTStorage.ServiceNodePortAllocator,
0000000000000000000000000000000000000000;;			ServiceNodePortRange:    c.ServiceNodePortRange,
0000000000000000000000000000000000000000;;			ServiceNodePortInterval: 3 * time.Minute,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			PublicIP: c.GenericConfig.PublicAddress,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ServiceIP:                 c.APIServerServiceIP,
0000000000000000000000000000000000000000;;			ServicePort:               c.APIServerServicePort,
0000000000000000000000000000000000000000;;			ExtraServicePorts:         c.ExtraServicePorts,
0000000000000000000000000000000000000000;;			ExtraEndpointPorts:        c.ExtraEndpointPorts,
0000000000000000000000000000000000000000;;			PublicServicePort:         c.GenericConfig.ReadWritePort,
0000000000000000000000000000000000000000;;			KubernetesServiceNodePort: c.KubernetesServiceNodePort,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Controller) PostStartHook(hookContext genericapiserver.PostStartHookContext) error {
0000000000000000000000000000000000000000;;		c.Start()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start begins the core controller loops that must exist for bootstrapping
0000000000000000000000000000000000000000;;	// a cluster.
0000000000000000000000000000000000000000;;	func (c *Controller) Start() {
0000000000000000000000000000000000000000;;		if c.runner != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		repairClusterIPs := servicecontroller.NewRepair(c.ServiceClusterIPInterval, c.ServiceClient, &c.ServiceClusterIPRange, c.ServiceClusterIPRegistry)
0000000000000000000000000000000000000000;;		repairNodePorts := portallocatorcontroller.NewRepair(c.ServiceNodePortInterval, c.ServiceClient, c.ServiceNodePortRange, c.ServiceNodePortRegistry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// run all of the controllers once prior to returning from Start.
0000000000000000000000000000000000000000;;		if err := repairClusterIPs.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			// If we fail to repair cluster IPs apiserver is useless. We should restart and retry.
0000000000000000000000000000000000000000;;			glog.Fatalf("Unable to perform initial IP allocation check: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := repairNodePorts.RunOnce(); err != nil {
0000000000000000000000000000000000000000;;			// If we fail to repair node ports apiserver is useless. We should restart and retry.
0000000000000000000000000000000000000000;;			glog.Fatalf("Unable to perform initial service nodePort check: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Service definition is reconciled during first run to correct port and type per expectations.
0000000000000000000000000000000000000000;;		if err := c.UpdateKubernetesService(true); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to perform initial Kubernetes service initialization: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.runner = async.NewRunner(c.RunKubernetesNamespaces, c.RunKubernetesService, repairClusterIPs.RunUntil, repairNodePorts.RunUntil)
0000000000000000000000000000000000000000;;		c.runner.Start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunKubernetesNamespaces periodically makes sure that all internal namespaces exist
0000000000000000000000000000000000000000;;	func (c *Controller) RunKubernetesNamespaces(ch chan struct{}) {
0000000000000000000000000000000000000000;;		wait.Until(func() {
0000000000000000000000000000000000000000;;			// Loop the system namespace list, and create them if they do not exist
0000000000000000000000000000000000000000;;			for _, ns := range c.SystemNamespaces {
0000000000000000000000000000000000000000;;				if err := c.CreateNamespaceIfNeeded(ns); err != nil {
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("unable to create required kubernetes system namespace %s: %v", ns, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, c.SystemNamespacesInterval, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunKubernetesService periodically updates the kubernetes service
0000000000000000000000000000000000000000;;	func (c *Controller) RunKubernetesService(ch chan struct{}) {
0000000000000000000000000000000000000000;;		wait.Until(func() {
0000000000000000000000000000000000000000;;			// Service definition is not reconciled after first
0000000000000000000000000000000000000000;;			// run, ports and type will be corrected only during
0000000000000000000000000000000000000000;;			// start.
0000000000000000000000000000000000000000;;			if err := c.UpdateKubernetesService(false); err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("unable to sync kubernetes service: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, c.EndpointInterval, ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateKubernetesService attempts to update the default Kube service.
0000000000000000000000000000000000000000;;	func (c *Controller) UpdateKubernetesService(reconcile bool) error {
0000000000000000000000000000000000000000;;		// Update service & endpoint records.
0000000000000000000000000000000000000000;;		// TODO: when it becomes possible to change this stuff,
0000000000000000000000000000000000000000;;		// stop polling and start watching.
0000000000000000000000000000000000000000;;		// TODO: add endpoints of all replicas, not just the elected master.
0000000000000000000000000000000000000000;;		if err := c.CreateNamespaceIfNeeded(metav1.NamespaceDefault); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		servicePorts, serviceType := createPortAndServiceSpec(c.ServicePort, c.PublicServicePort, c.KubernetesServiceNodePort, "https", c.ExtraServicePorts)
0000000000000000000000000000000000000000;;		if err := c.CreateOrUpdateMasterServiceIfNeeded(kubernetesServiceName, c.ServiceIP, servicePorts, serviceType, reconcile); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpointPorts := createEndpointPortSpec(c.PublicServicePort, "https", c.ExtraEndpointPorts)
0000000000000000000000000000000000000000;;		if err := c.EndpointReconciler.ReconcileEndpoints(kubernetesServiceName, c.PublicIP, endpointPorts, reconcile); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateNamespaceIfNeeded will create a namespace if it doesn't already exist
0000000000000000000000000000000000000000;;	func (c *Controller) CreateNamespaceIfNeeded(ns string) error {
0000000000000000000000000000000000000000;;		if _, err := c.NamespaceClient.Namespaces().Get(ns, metav1.GetOptions{}); err == nil {
0000000000000000000000000000000000000000;;			// the namespace already exists
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newNs := &api.Namespace{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      ns,
0000000000000000000000000000000000000000;;				Namespace: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := c.NamespaceClient.Namespaces().Create(newNs)
0000000000000000000000000000000000000000;;		if err != nil && errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createPortAndServiceSpec creates an array of service ports.
0000000000000000000000000000000000000000;;	// If the NodePort value is 0, just the servicePort is used, otherwise, a node port is exposed.
0000000000000000000000000000000000000000;;	func createPortAndServiceSpec(servicePort int, targetServicePort int, nodePort int, servicePortName string, extraServicePorts []api.ServicePort) ([]api.ServicePort, api.ServiceType) {
0000000000000000000000000000000000000000;;		//Use the Cluster IP type for the service port if NodePort isn't provided.
0000000000000000000000000000000000000000;;		//Otherwise, we will be binding the master service to a NodePort.
0000000000000000000000000000000000000000;;		servicePorts := []api.ServicePort{{Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;			Port:       int32(servicePort),
0000000000000000000000000000000000000000;;			Name:       servicePortName,
0000000000000000000000000000000000000000;;			TargetPort: intstr.FromInt(targetServicePort)}}
0000000000000000000000000000000000000000;;		serviceType := api.ServiceTypeClusterIP
0000000000000000000000000000000000000000;;		if nodePort > 0 {
0000000000000000000000000000000000000000;;			servicePorts[0].NodePort = int32(nodePort)
0000000000000000000000000000000000000000;;			serviceType = api.ServiceTypeNodePort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraServicePorts != nil {
0000000000000000000000000000000000000000;;			servicePorts = append(servicePorts, extraServicePorts...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return servicePorts, serviceType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createEndpointPortSpec creates an array of endpoint ports
0000000000000000000000000000000000000000;;	func createEndpointPortSpec(endpointPort int, endpointPortName string, extraEndpointPorts []api.EndpointPort) []api.EndpointPort {
0000000000000000000000000000000000000000;;		endpointPorts := []api.EndpointPort{{Protocol: api.ProtocolTCP,
0000000000000000000000000000000000000000;;			Port: int32(endpointPort),
0000000000000000000000000000000000000000;;			Name: endpointPortName,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		if extraEndpointPorts != nil {
0000000000000000000000000000000000000000;;			endpointPorts = append(endpointPorts, extraEndpointPorts...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return endpointPorts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateMasterServiceIfNeeded will create the specified service if it
0000000000000000000000000000000000000000;;	// doesn't already exist.
0000000000000000000000000000000000000000;;	func (c *Controller) CreateOrUpdateMasterServiceIfNeeded(serviceName string, serviceIP net.IP, servicePorts []api.ServicePort, serviceType api.ServiceType, reconcile bool) error {
0000000000000000000000000000000000000000;;		if s, err := c.ServiceClient.Services(metav1.NamespaceDefault).Get(serviceName, metav1.GetOptions{}); err == nil {
0000000000000000000000000000000000000000;;			// The service already exists.
0000000000000000000000000000000000000000;;			if reconcile {
0000000000000000000000000000000000000000;;				if svc, updated := getMasterServiceUpdateIfNeeded(s, servicePorts, serviceType); updated {
0000000000000000000000000000000000000000;;					glog.Warningf("Resetting master service %q to %#v", serviceName, svc)
0000000000000000000000000000000000000000;;					_, err := c.ServiceClient.Services(metav1.NamespaceDefault).Update(svc)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svc := &api.Service{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      serviceName,
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				Labels:    map[string]string{"provider": "kubernetes", "component": "apiserver"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: api.ServiceSpec{
0000000000000000000000000000000000000000;;				Ports: servicePorts,
0000000000000000000000000000000000000000;;				// maintained by this code, not by the pod selector
0000000000000000000000000000000000000000;;				Selector:        nil,
0000000000000000000000000000000000000000;;				ClusterIP:       serviceIP.String(),
0000000000000000000000000000000000000000;;				SessionAffinity: api.ServiceAffinityClientIP,
0000000000000000000000000000000000000000;;				Type:            serviceType,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := c.ServiceClient.Services(metav1.NamespaceDefault).Create(svc)
0000000000000000000000000000000000000000;;		if errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;			return c.CreateOrUpdateMasterServiceIfNeeded(serviceName, serviceIP, servicePorts, serviceType, reconcile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointReconciler knows how to reconcile the endpoints for the apiserver service.
0000000000000000000000000000000000000000;;	type EndpointReconciler interface {
0000000000000000000000000000000000000000;;		// ReconcileEndpoints sets the endpoints for the given apiserver service (ro or rw).
0000000000000000000000000000000000000000;;		// ReconcileEndpoints expects that the endpoints objects it manages will all be
0000000000000000000000000000000000000000;;		// managed only by ReconcileEndpoints; therefore, to understand this, you need only
0000000000000000000000000000000000000000;;		// understand the requirements.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Requirements:
0000000000000000000000000000000000000000;;		//  * All apiservers MUST use the same ports for their {rw, ro} services.
0000000000000000000000000000000000000000;;		//  * All apiservers MUST use ReconcileEndpoints and only ReconcileEndpoints to manage the
0000000000000000000000000000000000000000;;		//      endpoints for their {rw, ro} services.
0000000000000000000000000000000000000000;;		//  * ReconcileEndpoints is called periodically from all apiservers.
0000000000000000000000000000000000000000;;		ReconcileEndpoints(serviceName string, ip net.IP, endpointPorts []api.EndpointPort, reconcilePorts bool) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// masterCountEndpointReconciler reconciles endpoints based on a specified expected number of
0000000000000000000000000000000000000000;;	// masters. masterCountEndpointReconciler implements EndpointReconciler.
0000000000000000000000000000000000000000;;	type masterCountEndpointReconciler struct {
0000000000000000000000000000000000000000;;		masterCount    int
0000000000000000000000000000000000000000;;		endpointClient coreclient.EndpointsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ EndpointReconciler = &masterCountEndpointReconciler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMasterCountEndpointReconciler creates a new EndpointReconciler that reconciles based on a
0000000000000000000000000000000000000000;;	// specified expected number of masters.
0000000000000000000000000000000000000000;;	func NewMasterCountEndpointReconciler(masterCount int, endpointClient coreclient.EndpointsGetter) *masterCountEndpointReconciler {
0000000000000000000000000000000000000000;;		return &masterCountEndpointReconciler{
0000000000000000000000000000000000000000;;			masterCount:    masterCount,
0000000000000000000000000000000000000000;;			endpointClient: endpointClient,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReconcileEndpoints sets the endpoints for the given apiserver service (ro or rw).
0000000000000000000000000000000000000000;;	// ReconcileEndpoints expects that the endpoints objects it manages will all be
0000000000000000000000000000000000000000;;	// managed only by ReconcileEndpoints; therefore, to understand this, you need only
0000000000000000000000000000000000000000;;	// understand the requirements and the body of this function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Requirements:
0000000000000000000000000000000000000000;;	//  * All apiservers MUST use the same ports for their {rw, ro} services.
0000000000000000000000000000000000000000;;	//  * All apiservers MUST use ReconcileEndpoints and only ReconcileEndpoints to manage the
0000000000000000000000000000000000000000;;	//      endpoints for their {rw, ro} services.
0000000000000000000000000000000000000000;;	//  * All apiservers MUST know and agree on the number of apiservers expected
0000000000000000000000000000000000000000;;	//      to be running (c.masterCount).
0000000000000000000000000000000000000000;;	//  * ReconcileEndpoints is called periodically from all apiservers.
0000000000000000000000000000000000000000;;	func (r *masterCountEndpointReconciler) ReconcileEndpoints(serviceName string, ip net.IP, endpointPorts []api.EndpointPort, reconcilePorts bool) error {
0000000000000000000000000000000000000000;;		e, err := r.endpointClient.Endpoints(metav1.NamespaceDefault).Get(serviceName, metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			e = &api.Endpoints{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:      serviceName,
0000000000000000000000000000000000000000;;					Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			// Simply create non-existing endpoints for the service.
0000000000000000000000000000000000000000;;			e.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: ip.String()}},
0000000000000000000000000000000000000000;;				Ports:     endpointPorts,
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;			_, err = r.endpointClient.Endpoints(metav1.NamespaceDefault).Create(e)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First, determine if the endpoint is in the format we expect (one
0000000000000000000000000000000000000000;;		// subset, ports matching endpointPorts, N IP addresses).
0000000000000000000000000000000000000000;;		formatCorrect, ipCorrect, portsCorrect := checkEndpointSubsetFormat(e, ip.String(), endpointPorts, r.masterCount, reconcilePorts)
0000000000000000000000000000000000000000;;		if !formatCorrect {
0000000000000000000000000000000000000000;;			// Something is egregiously wrong, just re-make the endpoints record.
0000000000000000000000000000000000000000;;			e.Subsets = []api.EndpointSubset{{
0000000000000000000000000000000000000000;;				Addresses: []api.EndpointAddress{{IP: ip.String()}},
0000000000000000000000000000000000000000;;				Ports:     endpointPorts,
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;			glog.Warningf("Resetting endpoints for master service %q to %#v", serviceName, e)
0000000000000000000000000000000000000000;;			_, err = r.endpointClient.Endpoints(metav1.NamespaceDefault).Update(e)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ipCorrect && portsCorrect {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ipCorrect {
0000000000000000000000000000000000000000;;			// We *always* add our own IP address.
0000000000000000000000000000000000000000;;			e.Subsets[0].Addresses = append(e.Subsets[0].Addresses, api.EndpointAddress{IP: ip.String()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Lexicographic order is retained by this step.
0000000000000000000000000000000000000000;;			e.Subsets = endpoints.RepackSubsets(e.Subsets)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If too many IP addresses, remove the ones lexicographically after our
0000000000000000000000000000000000000000;;			// own IP address.  Given the requirements stated at the top of
0000000000000000000000000000000000000000;;			// this function, this should cause the list of IP addresses to
0000000000000000000000000000000000000000;;			// become eventually correct.
0000000000000000000000000000000000000000;;			if addrs := &e.Subsets[0].Addresses; len(*addrs) > r.masterCount {
0000000000000000000000000000000000000000;;				// addrs is a pointer because we're going to mutate it.
0000000000000000000000000000000000000000;;				for i, addr := range *addrs {
0000000000000000000000000000000000000000;;					if addr.IP == ip.String() {
0000000000000000000000000000000000000000;;						for len(*addrs) > r.masterCount {
0000000000000000000000000000000000000000;;							// wrap around if necessary.
0000000000000000000000000000000000000000;;							remove := (i + 1) % len(*addrs)
0000000000000000000000000000000000000000;;							*addrs = append((*addrs)[:remove], (*addrs)[remove+1:]...)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !portsCorrect {
0000000000000000000000000000000000000000;;			// Reset ports.
0000000000000000000000000000000000000000;;			e.Subsets[0].Ports = endpointPorts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Warningf("Resetting endpoints for master service %q to %v", serviceName, e)
0000000000000000000000000000000000000000;;		_, err = r.endpointClient.Endpoints(metav1.NamespaceDefault).Update(e)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determine if the endpoint is in the format ReconcileEndpoints expects.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Return values:
0000000000000000000000000000000000000000;;	// * formatCorrect is true if exactly one subset is found.
0000000000000000000000000000000000000000;;	// * ipCorrect is true when current master's IP is found and the number
0000000000000000000000000000000000000000;;	//     of addresses is less than or equal to the master count.
0000000000000000000000000000000000000000;;	// * portsCorrect is true when endpoint ports exactly match provided ports.
0000000000000000000000000000000000000000;;	//     portsCorrect is only evaluated when reconcilePorts is set to true.
0000000000000000000000000000000000000000;;	func checkEndpointSubsetFormat(e *api.Endpoints, ip string, ports []api.EndpointPort, count int, reconcilePorts bool) (formatCorrect bool, ipCorrect bool, portsCorrect bool) {
0000000000000000000000000000000000000000;;		if len(e.Subsets) != 1 {
0000000000000000000000000000000000000000;;			return false, false, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sub := &e.Subsets[0]
0000000000000000000000000000000000000000;;		portsCorrect = true
0000000000000000000000000000000000000000;;		if reconcilePorts {
0000000000000000000000000000000000000000;;			if len(sub.Ports) != len(ports) {
0000000000000000000000000000000000000000;;				portsCorrect = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, port := range ports {
0000000000000000000000000000000000000000;;				if len(sub.Ports) <= i || port != sub.Ports[i] {
0000000000000000000000000000000000000000;;					portsCorrect = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, addr := range sub.Addresses {
0000000000000000000000000000000000000000;;			if addr.IP == ip {
0000000000000000000000000000000000000000;;				ipCorrect = len(sub.Addresses) <= count
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, ipCorrect, portsCorrect
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// * getMasterServiceUpdateIfNeeded sets service attributes for the
0000000000000000000000000000000000000000;;	//     given apiserver service.
0000000000000000000000000000000000000000;;	// * getMasterServiceUpdateIfNeeded expects that the service object it
0000000000000000000000000000000000000000;;	//     manages will be managed only by getMasterServiceUpdateIfNeeded;
0000000000000000000000000000000000000000;;	//     therefore, to understand this, you need only understand the
0000000000000000000000000000000000000000;;	//     requirements and the body of this function.
0000000000000000000000000000000000000000;;	// * getMasterServiceUpdateIfNeeded ensures that the correct ports are
0000000000000000000000000000000000000000;;	//     are set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Requirements:
0000000000000000000000000000000000000000;;	// * All apiservers MUST use getMasterServiceUpdateIfNeeded and only
0000000000000000000000000000000000000000;;	//     getMasterServiceUpdateIfNeeded to manage service attributes
0000000000000000000000000000000000000000;;	// * updateMasterService is called periodically from all apiservers.
0000000000000000000000000000000000000000;;	func getMasterServiceUpdateIfNeeded(svc *api.Service, servicePorts []api.ServicePort, serviceType api.ServiceType) (s *api.Service, updated bool) {
0000000000000000000000000000000000000000;;		// Determine if the service is in the format we expect
0000000000000000000000000000000000000000;;		// (servicePorts are present and service type matches)
0000000000000000000000000000000000000000;;		formatCorrect := checkServiceFormat(svc, servicePorts, serviceType)
0000000000000000000000000000000000000000;;		if formatCorrect {
0000000000000000000000000000000000000000;;			return svc, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		svc.Spec.Ports = servicePorts
0000000000000000000000000000000000000000;;		svc.Spec.Type = serviceType
0000000000000000000000000000000000000000;;		return svc, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determine if the service is in the correct format
0000000000000000000000000000000000000000;;	// getMasterServiceUpdateIfNeeded expects (servicePorts are correct
0000000000000000000000000000000000000000;;	// and service type matches).
0000000000000000000000000000000000000000;;	func checkServiceFormat(s *api.Service, ports []api.ServicePort, serviceType api.ServiceType) (formatCorrect bool) {
0000000000000000000000000000000000000000;;		if s.Spec.Type != serviceType {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ports) != len(s.Spec.Ports) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, port := range ports {
0000000000000000000000000000000000000000;;			if port != s.Spec.Ports[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
