0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
e7e14dae295bf58ee8e386180dd74c03fc52c1b6;pkg/master/thirdparty/tprregistration_controller.go[pkg/master/thirdparty/tprregistration_controller.go][pkg/master/controller/crdregistration/crdregistration_controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package crdregistration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
0000000000000000000000000000000000000000;;		crdinformers "k8s.io/apiextensions-apiserver/pkg/client/informers/internalversion/apiextensions/internalversion"
0000000000000000000000000000000000000000;;		crdlisters "k8s.io/apiextensions-apiserver/pkg/client/listers/apiextensions/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/controller"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AutoAPIServiceRegistration is an interface which callers can re-declare locally and properly cast to for
0000000000000000000000000000000000000000;;	// adding and removing APIServices
0000000000000000000000000000000000000000;;	type AutoAPIServiceRegistration interface {
0000000000000000000000000000000000000000;;		// AddAPIServiceToSync adds an API service to auto-register.
0000000000000000000000000000000000000000;;		AddAPIServiceToSync(in *apiregistration.APIService)
0000000000000000000000000000000000000000;;		// RemoveAPIServiceToSync removes an API service to auto-register.
0000000000000000000000000000000000000000;;		RemoveAPIServiceToSync(name string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type crdRegistrationController struct {
0000000000000000000000000000000000000000;;		crdLister crdlisters.CustomResourceDefinitionLister
0000000000000000000000000000000000000000;;		crdSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServiceRegistration AutoAPIServiceRegistration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		syncHandler func(groupVersion schema.GroupVersion) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// queue is where incoming work is placed to de-dup and to allow "easy" rate limited requeues on errors
0000000000000000000000000000000000000000;;		// this is actually keyed by a groupVersion
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAutoRegistrationController returns a controller which will register TPR GroupVersions with the auto APIService registration
0000000000000000000000000000000000000000;;	// controller so they automatically stay in sync.
0000000000000000000000000000000000000000;;	// In order to stay sane with both TPR and CRD present, we have a single controller that manages both.  When choosing whether to have an
0000000000000000000000000000000000000000;;	// APIService, we simply iterate through both.
0000000000000000000000000000000000000000;;	func NewAutoRegistrationController(crdinformer crdinformers.CustomResourceDefinitionInformer, apiServiceRegistration AutoAPIServiceRegistration) *crdRegistrationController {
0000000000000000000000000000000000000000;;		c := &crdRegistrationController{
0000000000000000000000000000000000000000;;			crdLister:              crdinformer.Lister(),
0000000000000000000000000000000000000000;;			crdSynced:              crdinformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			apiServiceRegistration: apiServiceRegistration,
0000000000000000000000000000000000000000;;			queue: workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "crd-autoregister"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.syncHandler = c.handleVersionUpdate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crdinformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				cast := obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;				c.enqueueCRD(cast)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UpdateFunc: func(_, obj interface{}) {
0000000000000000000000000000000000000000;;				cast := obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;				c.enqueueCRD(cast)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				cast, ok := obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Couldn't get object from tombstone %#v", obj)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cast, ok = tombstone.Obj.(*apiextensions.CustomResourceDefinition)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Tombstone contained unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.enqueueCRD(cast)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *crdRegistrationController) Run(threadiness int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		// make sure the work queue is shutdown which will trigger workers to end
0000000000000000000000000000000000000000;;		defer c.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting crd-autoregister controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down crd-autoregister controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for your secondary caches to fill before starting your work
0000000000000000000000000000000000000000;;		if !controller.WaitForCacheSync("crd-autoregister", stopCh, c.crdSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start up your worker threads based on threadiness.  Some controllers have multiple kinds of workers
0000000000000000000000000000000000000000;;		for i := 0; i < threadiness; i++ {
0000000000000000000000000000000000000000;;			// runWorker will loop until "something bad" happens.  The .Until will then rekick the worker
0000000000000000000000000000000000000000;;			// after one second
0000000000000000000000000000000000000000;;			go wait.Until(c.runWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until we're told to stop
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *crdRegistrationController) runWorker() {
0000000000000000000000000000000000000000;;		// hot loop until we're told to stop.  processNextWorkItem will automatically wait until there's work
0000000000000000000000000000000000000000;;		// available, so we don't worry about secondary waits
0000000000000000000000000000000000000000;;		for c.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.
0000000000000000000000000000000000000000;;	func (c *crdRegistrationController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		// pull the next work item from queue.  It should be a key we use to lookup something in a cache
0000000000000000000000000000000000000000;;		key, quit := c.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// you always have to indicate to the queue that you've completed a piece of work
0000000000000000000000000000000000000000;;		defer c.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do your work on the key.  This method will contains your "do stuff" logic
0000000000000000000000000000000000000000;;		err := c.syncHandler(key.(schema.GroupVersion))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// if you had no error, tell the queue to stop tracking history for your key.  This will
0000000000000000000000000000000000000000;;			// reset things like failure counts for per-item rate limiting
0000000000000000000000000000000000000000;;			c.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// there was a failure so be sure to report it.  This method allows for pluggable error handling
0000000000000000000000000000000000000000;;		// which can be used for things like cluster-monitoring
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("%v failed with : %v", key, err))
0000000000000000000000000000000000000000;;		// since we failed, we should requeue the item to work on later.  This method will add a backoff
0000000000000000000000000000000000000000;;		// to avoid hotlooping on particular items (they're probably still not going to work right away)
0000000000000000000000000000000000000000;;		// and overall controller protection (everything I've done is broken, this controller needs to
0000000000000000000000000000000000000000;;		// calm down or it can starve other useful work) cases.
0000000000000000000000000000000000000000;;		c.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *crdRegistrationController) enqueueCRD(crd *apiextensions.CustomResourceDefinition) {
0000000000000000000000000000000000000000;;		c.queue.Add(schema.GroupVersion{Group: crd.Spec.Group, Version: crd.Spec.Version})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *crdRegistrationController) handleVersionUpdate(groupVersion schema.GroupVersion) error {
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		apiServiceName := groupVersion.Version + "." + groupVersion.Group
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check all CRDs.  There shouldn't that many, but if we have problems later we can index them
0000000000000000000000000000000000000000;;		crds, err := c.crdLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, crd := range crds {
0000000000000000000000000000000000000000;;			if crd.Spec.Version == groupVersion.Version && crd.Spec.Group == groupVersion.Group {
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			c.apiServiceRegistration.RemoveAPIServiceToSync(apiServiceName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.apiServiceRegistration.AddAPIServiceToSync(&apiregistration.APIService{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: apiServiceName},
0000000000000000000000000000000000000000;;			Spec: apiregistration.APIServiceSpec{
0000000000000000000000000000000000000000;;				Group:                groupVersion.Group,
0000000000000000000000000000000000000000;;				Version:              groupVersion.Version,
0000000000000000000000000000000000000000;;				GroupPriorityMinimum: 1000, // TPRs should have relatively low priority
0000000000000000000000000000000000000000;;				VersionPriority:      100,  // TPRs should have relatively low priority
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
