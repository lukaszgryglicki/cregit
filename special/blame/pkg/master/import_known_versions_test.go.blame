0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
98145277699521faaf2cd36da07207ca91958f81;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGroupVersions(t *testing.T) {
0000000000000000000000000000000000000000;;		// legacyUnsuffixedGroups contains the groups released prior to deciding that kubernetes API groups should be dns-suffixed
0000000000000000000000000000000000000000;;		// new groups should be suffixed with ".k8s.io" (https://github.com/kubernetes/kubernetes/pull/31887#issuecomment-244462396)
0000000000000000000000000000000000000000;;		legacyUnsuffixedGroups := sets.NewString(
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			"apps",
0000000000000000000000000000000000000000;;			"autoscaling",
0000000000000000000000000000000000000000;;			"batch",
0000000000000000000000000000000000000000;;			"componentconfig",
0000000000000000000000000000000000000000;;			"extensions",
0000000000000000000000000000000000000000;;			"federation",
0000000000000000000000000000000000000000;;			"policy",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No new groups should be added to the legacyUnsuffixedGroups exclusion list
0000000000000000000000000000000000000000;;		if len(legacyUnsuffixedGroups) != 8 {
0000000000000000000000000000000000000000;;			t.Errorf("No additional unnamespaced groups should be created")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, gv := range api.Registry.RegisteredGroupVersions() {
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(gv.Group, ".k8s.io") && !legacyUnsuffixedGroups.Has(gv.Group) {
0000000000000000000000000000000000000000;;				t.Errorf("Group %s does not have the standard kubernetes API group suffix of .k8s.io", gv.Group)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTypeTags(t *testing.T) {
0000000000000000000000000000000000000000;;		for gvk, knownType := range api.Scheme.AllKnownTypes() {
0000000000000000000000000000000000000000;;			if gvk.Version == runtime.APIVersionInternal {
0000000000000000000000000000000000000000;;				ensureNoTags(t, gvk, knownType, nil)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ensureTags(t, gvk, knownType, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These types are registered in external versions, and therefore include json tags,
0000000000000000000000000000000000000000;;	// but are also registered in internal versions (or referenced from internal types),
0000000000000000000000000000000000000000;;	// so we explicitly allow tags for them
0000000000000000000000000000000000000000;;	var typesAllowedTags = map[reflect.Type]bool{
0000000000000000000000000000000000000000;;		reflect.TypeOf(intstr.IntOrString{}):          true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.Time{}):                 true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.Duration{}):             true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.TypeMeta{}):             true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.ListMeta{}):             true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.ObjectMeta{}):           true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.OwnerReference{}):       true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.LabelSelector{}):        true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.GetOptions{}):           true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.ExportOptions{}):        true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.ListOptions{}):          true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.DeleteOptions{}):        true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.GroupVersionKind{}):     true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.GroupVersionResource{}): true,
0000000000000000000000000000000000000000;;		reflect.TypeOf(metav1.Status{}):               true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureNoTags(t *testing.T, gvk schema.GroupVersionKind, tp reflect.Type, parents []reflect.Type) {
0000000000000000000000000000000000000000;;		if _, ok := typesAllowedTags[tp]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parents = append(parents, tp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tp.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map, reflect.Slice, reflect.Ptr:
0000000000000000000000000000000000000000;;			ensureNoTags(t, gvk, tp.Elem(), parents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.String, reflect.Bool, reflect.Float32, reflect.Int, reflect.Int32, reflect.Int64, reflect.Uint8, reflect.Uintptr, reflect.Uint32, reflect.Uint64, reflect.Interface:
0000000000000000000000000000000000000000;;			// no-op
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < tp.NumField(); i++ {
0000000000000000000000000000000000000000;;				f := tp.Field(i)
0000000000000000000000000000000000000000;;				jsonTag := f.Tag.Get("json")
0000000000000000000000000000000000000000;;				protoTag := f.Tag.Get("protobuf")
0000000000000000000000000000000000000000;;				if len(jsonTag) > 0 || len(protoTag) > 0 {
0000000000000000000000000000000000000000;;					t.Errorf("Internal types should not have json or protobuf tags. %#v has tag on field %v: %v", gvk, f.Name, f.Tag)
0000000000000000000000000000000000000000;;					for i, tp := range parents {
0000000000000000000000000000000000000000;;						t.Logf("%s%v:", strings.Repeat("  ", i), tp)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ensureNoTags(t, gvk, f.Type, parents)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected type %v in %#v", tp.Kind(), gvk)
0000000000000000000000000000000000000000;;			for i, tp := range parents {
0000000000000000000000000000000000000000;;				t.Logf("%s%v:", strings.Repeat("  ", i), tp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		marshalerType   = reflect.TypeOf((*json.Marshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		unmarshalerType = reflect.TypeOf((*json.Unmarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These fields are limited exceptions to the standard JSON naming structure.
0000000000000000000000000000000000000000;;	// Additions should only be made if a non-standard field name was released and cannot be changed for compatibility reasons.
0000000000000000000000000000000000000000;;	var allowedNonstandardJSONNames = map[reflect.Type]string{
0000000000000000000000000000000000000000;;		reflect.TypeOf(v1.DaemonEndpoint{}): "Port",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureTags(t *testing.T, gvk schema.GroupVersionKind, tp reflect.Type, parents []reflect.Type) {
0000000000000000000000000000000000000000;;		// This type handles its own encoding/decoding and doesn't need json tags
0000000000000000000000000000000000000000;;		if tp.Implements(marshalerType) && (tp.Implements(unmarshalerType) || reflect.PtrTo(tp).Implements(unmarshalerType)) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parents = append(parents, tp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tp.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map, reflect.Slice, reflect.Ptr:
0000000000000000000000000000000000000000;;			ensureTags(t, gvk, tp.Elem(), parents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.String, reflect.Bool, reflect.Float32, reflect.Int, reflect.Int32, reflect.Int64, reflect.Uint8, reflect.Uintptr, reflect.Uint32, reflect.Uint64, reflect.Interface:
0000000000000000000000000000000000000000;;			// no-op
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < tp.NumField(); i++ {
0000000000000000000000000000000000000000;;				f := tp.Field(i)
0000000000000000000000000000000000000000;;				jsonTag := f.Tag.Get("json")
0000000000000000000000000000000000000000;;				if len(jsonTag) == 0 {
0000000000000000000000000000000000000000;;					t.Errorf("External types should have json tags. %#v tags on field %v are: %s", gvk, f.Name, f.Tag)
0000000000000000000000000000000000000000;;					for i, tp := range parents {
0000000000000000000000000000000000000000;;						t.Logf("%s%v", strings.Repeat("  ", i), tp)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				jsonTagName := strings.Split(jsonTag, ",")[0]
0000000000000000000000000000000000000000;;				if len(jsonTagName) > 0 && (jsonTagName[0] < 'a' || jsonTagName[0] > 'z') && jsonTagName != "-" && allowedNonstandardJSONNames[tp] != jsonTagName {
0000000000000000000000000000000000000000;;					t.Errorf("External types should have json names starting with lowercase letter. %#v has json tag on field %v with name %s", gvk, f.Name, jsonTagName)
0000000000000000000000000000000000000000;;					t.Log(tp)
0000000000000000000000000000000000000000;;					t.Log(allowedNonstandardJSONNames[tp])
0000000000000000000000000000000000000000;;					for i, tp := range parents {
0000000000000000000000000000000000000000;;						t.Logf("%s%v", strings.Repeat("  ", i), tp)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ensureTags(t, gvk, f.Type, parents)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected type %v in %#v", tp.Kind(), gvk)
0000000000000000000000000000000000000000;;			for i, tp := range parents {
0000000000000000000000000000000000000000;;				t.Logf("%s%v:", strings.Repeat("  ", i), tp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
