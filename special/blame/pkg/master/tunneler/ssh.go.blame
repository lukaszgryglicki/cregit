0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e80c67ada9be48c9a4c3bbc9b9d067fc1caa2743;pkg/master/tunneler.go[pkg/master/tunneler.go][pkg/master/tunneler/ssh.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tunneler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/ssh"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InstallSSHKey func(user string, data []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AddressFunc func() (addresses []string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Tunneler interface {
0000000000000000000000000000000000000000;;		Run(AddressFunc)
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;		Dial(net, addr string) (net.Conn, error)
0000000000000000000000000000000000000000;;		SecondsSinceSync() int64
0000000000000000000000000000000000000000;;		SecondsSinceSSHKeySync() int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TunnelSyncHealthChecker returns a health func that indicates if a tunneler is healthy.
0000000000000000000000000000000000000000;;	// It's compatible with healthz.NamedCheck
0000000000000000000000000000000000000000;;	func TunnelSyncHealthChecker(tunneler Tunneler) func(req *http.Request) error {
0000000000000000000000000000000000000000;;		return func(req *http.Request) error {
0000000000000000000000000000000000000000;;			if tunneler == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lag := tunneler.SecondsSinceSync()
0000000000000000000000000000000000000000;;			if lag > 600 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Tunnel sync is taking to long: %d", lag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sshKeyLag := tunneler.SecondsSinceSSHKeySync()
0000000000000000000000000000000000000000;;			if sshKeyLag > 600 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("SSHKey sync is taking to long: %d", sshKeyLag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SSHTunneler struct {
0000000000000000000000000000000000000000;;		// Important: Since these two int64 fields are using sync/atomic, they have to be at the top of the struct due to a bug on 32-bit platforms
0000000000000000000000000000000000000000;;		// See: https://golang.org/pkg/sync/atomic/ for more information
0000000000000000000000000000000000000000;;		lastSync       int64 // Seconds since Epoch
0000000000000000000000000000000000000000;;		lastSSHKeySync int64 // Seconds since Epoch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SSHUser        string
0000000000000000000000000000000000000000;;		SSHKeyfile     string
0000000000000000000000000000000000000000;;		InstallSSHKey  InstallSSHKey
0000000000000000000000000000000000000000;;		HealthCheckURL *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tunnels        *ssh.SSHTunnelList
0000000000000000000000000000000000000000;;		lastSyncMetric prometheus.GaugeFunc
0000000000000000000000000000000000000000;;		clock          clock.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getAddresses AddressFunc
0000000000000000000000000000000000000000;;		stopChan     chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(sshUser, sshKeyfile string, healthCheckURL *url.URL, installSSHKey InstallSSHKey) Tunneler {
0000000000000000000000000000000000000000;;		return &SSHTunneler{
0000000000000000000000000000000000000000;;			SSHUser:        sshUser,
0000000000000000000000000000000000000000;;			SSHKeyfile:     sshKeyfile,
0000000000000000000000000000000000000000;;			InstallSSHKey:  installSSHKey,
0000000000000000000000000000000000000000;;			HealthCheckURL: healthCheckURL,
0000000000000000000000000000000000000000;;			clock:          clock.RealClock{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run establishes tunnel loops and returns
0000000000000000000000000000000000000000;;	func (c *SSHTunneler) Run(getAddresses AddressFunc) {
0000000000000000000000000000000000000000;;		if c.stopChan != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.stopChan = make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the address getter
0000000000000000000000000000000000000000;;		if getAddresses != nil {
0000000000000000000000000000000000000000;;			c.getAddresses = getAddresses
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Usernames are capped @ 32
0000000000000000000000000000000000000000;;		if len(c.SSHUser) > 32 {
0000000000000000000000000000000000000000;;			glog.Warning("SSH User is too long, truncating to 32 chars")
0000000000000000000000000000000000000000;;			c.SSHUser = c.SSHUser[0:32]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Setting up proxy: %s %s", c.SSHUser, c.SSHKeyfile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// public keyfile is written last, so check for that.
0000000000000000000000000000000000000000;;		publicKeyFile := c.SSHKeyfile + ".pub"
0000000000000000000000000000000000000000;;		exists, err := util.FileExists(publicKeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error detecting if key exists: %v", err)
0000000000000000000000000000000000000000;;		} else if !exists {
0000000000000000000000000000000000000000;;			glog.Infof("Key doesn't exist, attempting to create")
0000000000000000000000000000000000000000;;			if err := generateSSHKey(c.SSHKeyfile, publicKeyFile); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to create key pair: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.tunnels = ssh.NewSSHTunnelList(c.SSHUser, c.SSHKeyfile, c.HealthCheckURL, c.stopChan)
0000000000000000000000000000000000000000;;		// Sync loop to ensure that the SSH key has been installed.
0000000000000000000000000000000000000000;;		c.lastSSHKeySync = c.clock.Now().Unix()
0000000000000000000000000000000000000000;;		c.installSSHKeySyncLoop(c.SSHUser, publicKeyFile)
0000000000000000000000000000000000000000;;		// Sync tunnelList w/ nodes.
0000000000000000000000000000000000000000;;		c.lastSync = c.clock.Now().Unix()
0000000000000000000000000000000000000000;;		c.nodesSyncLoop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop gracefully shuts down the tunneler
0000000000000000000000000000000000000000;;	func (c *SSHTunneler) Stop() {
0000000000000000000000000000000000000000;;		if c.stopChan != nil {
0000000000000000000000000000000000000000;;			close(c.stopChan)
0000000000000000000000000000000000000000;;			c.stopChan = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *SSHTunneler) Dial(net, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		return c.tunnels.Dial(net, addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *SSHTunneler) SecondsSinceSync() int64 {
0000000000000000000000000000000000000000;;		now := c.clock.Now().Unix()
0000000000000000000000000000000000000000;;		then := atomic.LoadInt64(&c.lastSync)
0000000000000000000000000000000000000000;;		return now - then
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *SSHTunneler) SecondsSinceSSHKeySync() int64 {
0000000000000000000000000000000000000000;;		now := c.clock.Now().Unix()
0000000000000000000000000000000000000000;;		then := atomic.LoadInt64(&c.lastSSHKeySync)
0000000000000000000000000000000000000000;;		return now - then
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *SSHTunneler) installSSHKeySyncLoop(user, publicKeyfile string) {
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			if c.InstallSSHKey == nil {
0000000000000000000000000000000000000000;;				glog.Error("Won't attempt to install ssh key: InstallSSHKey function is nil")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key, err := ssh.ParsePublicKeyFromFile(publicKeyfile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to load public key: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyData, err := ssh.EncodeSSHKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to encode public key: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := c.InstallSSHKey(user, keyData); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to install ssh key: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			atomic.StoreInt64(&c.lastSSHKeySync, c.clock.Now().Unix())
0000000000000000000000000000000000000000;;		}, 5*time.Minute, c.stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodesSyncLoop lists nodes every 15 seconds, calling Update() on the TunnelList
0000000000000000000000000000000000000000;;	// each time (Update() is a noop if no changes are necessary).
0000000000000000000000000000000000000000;;	func (c *SSHTunneler) nodesSyncLoop() {
0000000000000000000000000000000000000000;;		// TODO (cjcullen) make this watch.
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			addrs, err := c.getAddresses()
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Calling update w/ addrs: %v", addrs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to getAddresses: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.tunnels.Update(addrs)
0000000000000000000000000000000000000000;;			atomic.StoreInt64(&c.lastSync, c.clock.Now().Unix())
0000000000000000000000000000000000000000;;		}, 15*time.Second, c.stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateSSHKey(privateKeyfile, publicKeyfile string) error {
0000000000000000000000000000000000000000;;		private, public, err := ssh.GenerateKey(2048)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If private keyfile already exists, we must have only made it halfway
0000000000000000000000000000000000000000;;		// through last time, so delete it.
0000000000000000000000000000000000000000;;		exists, err := util.FileExists(privateKeyfile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Error detecting if private key exists: %v", err)
0000000000000000000000000000000000000000;;		} else if exists {
0000000000000000000000000000000000000000;;			glog.Infof("Private key exists, but public key does not")
0000000000000000000000000000000000000000;;			if err := os.Remove(privateKeyfile); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to remove stale private key: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(privateKeyfile, ssh.EncodePrivateKey(private), 0600); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		publicKeyBytes, err := ssh.EncodePublicKey(public)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(publicKeyfile+".tmp", publicKeyBytes, 0600); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.Rename(publicKeyfile+".tmp", publicKeyfile)
0000000000000000000000000000000000000000;;	}
