0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e80c67ada9be48c9a4c3bbc9b9d067fc1caa2743;pkg/master/tunneler_test.go[pkg/master/tunneler_test.go][pkg/master/tunneler/ssh_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package tunneler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestSecondsSinceSync verifies that proper results are returned
0000000000000000000000000000000000000000;;	// when checking the time between syncs
0000000000000000000000000000000000000000;;	func TestSecondsSinceSync(t *testing.T) {
0000000000000000000000000000000000000000;;		tunneler := &SSHTunneler{}
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tunneler.lastSync = time.Date(2015, time.January, 1, 1, 1, 1, 1, time.UTC).Unix()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nano Second. No difference.
0000000000000000000000000000000000000000;;		tunneler.clock = clock.NewFakeClock(time.Date(2015, time.January, 1, 1, 1, 1, 2, time.UTC))
0000000000000000000000000000000000000000;;		assert.Equal(int64(0), tunneler.SecondsSinceSync())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Second
0000000000000000000000000000000000000000;;		tunneler.clock = clock.NewFakeClock(time.Date(2015, time.January, 1, 1, 1, 2, 1, time.UTC))
0000000000000000000000000000000000000000;;		assert.Equal(int64(1), tunneler.SecondsSinceSync())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minute
0000000000000000000000000000000000000000;;		tunneler.clock = clock.NewFakeClock(time.Date(2015, time.January, 1, 1, 2, 1, 1, time.UTC))
0000000000000000000000000000000000000000;;		assert.Equal(int64(60), tunneler.SecondsSinceSync())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hour
0000000000000000000000000000000000000000;;		tunneler.clock = clock.NewFakeClock(time.Date(2015, time.January, 1, 2, 1, 1, 1, time.UTC))
0000000000000000000000000000000000000000;;		assert.Equal(int64(3600), tunneler.SecondsSinceSync())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Day
0000000000000000000000000000000000000000;;		tunneler.clock = clock.NewFakeClock(time.Date(2015, time.January, 2, 1, 1, 1, 1, time.UTC))
0000000000000000000000000000000000000000;;		assert.Equal(int64(86400), tunneler.SecondsSinceSync())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Month
0000000000000000000000000000000000000000;;		tunneler.clock = clock.NewFakeClock(time.Date(2015, time.February, 1, 1, 1, 1, 1, time.UTC))
0000000000000000000000000000000000000000;;		assert.Equal(int64(2678400), tunneler.SecondsSinceSync())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Future Month. Should be -Month.
0000000000000000000000000000000000000000;;		tunneler.lastSync = time.Date(2015, time.February, 1, 1, 1, 1, 1, time.UTC).Unix()
0000000000000000000000000000000000000000;;		tunneler.clock = clock.NewFakeClock(time.Date(2015, time.January, 1, 1, 1, 1, 1, time.UTC))
0000000000000000000000000000000000000000;;		assert.Equal(int64(-2678400), tunneler.SecondsSinceSync())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateTempFile creates a temporary file path
0000000000000000000000000000000000000000;;	func generateTempFilePath(prefix string) string {
0000000000000000000000000000000000000000;;		tmpPath, _ := filepath.Abs(fmt.Sprintf("%s/%s-%d", os.TempDir(), prefix, time.Now().Unix()))
0000000000000000000000000000000000000000;;		return tmpPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestGenerateSSHKey verifies that SSH key generation does indeed
0000000000000000000000000000000000000000;;	// generate keys even with keys already exist.
0000000000000000000000000000000000000000;;	func TestGenerateSSHKey(t *testing.T) {
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateKey := generateTempFilePath("private")
0000000000000000000000000000000000000000;;		publicKey := generateTempFilePath("public")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we have no test keys laying around
0000000000000000000000000000000000000000;;		os.Remove(privateKey)
0000000000000000000000000000000000000000;;		os.Remove(publicKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pass case: Sunny day case
0000000000000000000000000000000000000000;;		err := generateSSHKey(privateKey, publicKey)
0000000000000000000000000000000000000000;;		assert.NoError(err, "generateSSHKey should not have retuend an error: %s", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pass case: PrivateKey exists test case
0000000000000000000000000000000000000000;;		os.Remove(publicKey)
0000000000000000000000000000000000000000;;		err = generateSSHKey(privateKey, publicKey)
0000000000000000000000000000000000000000;;		assert.NoError(err, "generateSSHKey should not have retuend an error: %s", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pass case: PublicKey exists test case
0000000000000000000000000000000000000000;;		os.Remove(privateKey)
0000000000000000000000000000000000000000;;		err = generateSSHKey(privateKey, publicKey)
0000000000000000000000000000000000000000;;		assert.NoError(err, "generateSSHKey should not have retuend an error: %s", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we have no test keys laying around
0000000000000000000000000000000000000000;;		os.Remove(privateKey)
0000000000000000000000000000000000000000;;		os.Remove(publicKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: testing error cases where the file can not be removed?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakeTunneler struct {
0000000000000000000000000000000000000000;;		SecondsSinceSyncValue       int64
0000000000000000000000000000000000000000;;		SecondsSinceSSHKeySyncValue int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *FakeTunneler) Run(AddressFunc)                         {}
0000000000000000000000000000000000000000;;	func (t *FakeTunneler) Stop()                                   {}
0000000000000000000000000000000000000000;;	func (t *FakeTunneler) Dial(net, addr string) (net.Conn, error) { return nil, nil }
0000000000000000000000000000000000000000;;	func (t *FakeTunneler) SecondsSinceSync() int64                 { return t.SecondsSinceSyncValue }
0000000000000000000000000000000000000000;;	func (t *FakeTunneler) SecondsSinceSSHKeySync() int64           { return t.SecondsSinceSSHKeySyncValue }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestIsTunnelSyncHealthy verifies that the 600 second lag test
0000000000000000000000000000000000000000;;	// is honored.
0000000000000000000000000000000000000000;;	func TestIsTunnelSyncHealthy(t *testing.T) {
0000000000000000000000000000000000000000;;		tunneler := &FakeTunneler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pass case: 540 second lag
0000000000000000000000000000000000000000;;		tunneler.SecondsSinceSyncValue = 540
0000000000000000000000000000000000000000;;		healthFn := TunnelSyncHealthChecker(tunneler)
0000000000000000000000000000000000000000;;		err := healthFn(nil)
0000000000000000000000000000000000000000;;		assert.NoError(t, err, "IsTunnelSyncHealthy() should not have returned an error.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fail case: 720 second lag
0000000000000000000000000000000000000000;;		tunneler.SecondsSinceSyncValue = 720
0000000000000000000000000000000000000000;;		err = healthFn(nil)
0000000000000000000000000000000000000000;;		assert.Error(t, err, "IsTunnelSyncHealthy() should have returned an error.")
0000000000000000000000000000000000000000;;	}
