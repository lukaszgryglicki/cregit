0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3625428de58efecc63424c6ae5ea7249e97d1ca9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsapiv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		autoscalingapiv1 "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;		batchapiv1 "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		batchapiv2alpha1 "k8s.io/api/batch/v2alpha1"
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensionsapiv1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/options"
0000000000000000000000000000000000000000;;		serverstorage "k8s.io/apiserver/pkg/server/storage"
0000000000000000000000000000000000000000;;		etcdtesting "k8s.io/apiserver/pkg/storage/etcd/testing"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/testapi"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/autoscaling"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/certificates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/extensions"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/rbac"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/clientset_generated/clientset/fake"
0000000000000000000000000000000000000000;;		kubeletclient "k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;		kubeversion "k8s.io/kubernetes/pkg/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setUp is a convience function for setting up for (most) tests.
0000000000000000000000000000000000000000;;	func setUp(t *testing.T) (*etcdtesting.EtcdTestServer, Config, *assert.Assertions) {
0000000000000000000000000000000000000000;;		server, storageConfig := etcdtesting.NewUnsecuredEtcd3TestClientServer(t, api.Scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := &Config{
0000000000000000000000000000000000000000;;			GenericConfig:           genericapiserver.NewConfig(api.Codecs),
0000000000000000000000000000000000000000;;			APIResourceConfigSource: DefaultAPIResourceConfigSource(),
0000000000000000000000000000000000000000;;			APIServerServicePort:    443,
0000000000000000000000000000000000000000;;			MasterCount:             1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceEncoding := serverstorage.NewDefaultResourceEncodingConfig(api.Registry)
0000000000000000000000000000000000000000;;		resourceEncoding.SetVersionEncoding(api.GroupName, api.Registry.GroupOrDie(api.GroupName).GroupVersion, schema.GroupVersion{Group: api.GroupName, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		resourceEncoding.SetVersionEncoding(autoscaling.GroupName, *testapi.Autoscaling.GroupVersion(), schema.GroupVersion{Group: autoscaling.GroupName, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		resourceEncoding.SetVersionEncoding(batch.GroupName, *testapi.Batch.GroupVersion(), schema.GroupVersion{Group: batch.GroupName, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		resourceEncoding.SetVersionEncoding(apps.GroupName, *testapi.Apps.GroupVersion(), schema.GroupVersion{Group: apps.GroupName, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		resourceEncoding.SetVersionEncoding(extensions.GroupName, *testapi.Extensions.GroupVersion(), schema.GroupVersion{Group: extensions.GroupName, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		resourceEncoding.SetVersionEncoding(rbac.GroupName, *testapi.Rbac.GroupVersion(), schema.GroupVersion{Group: rbac.GroupName, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		resourceEncoding.SetVersionEncoding(certificates.GroupName, *testapi.Certificates.GroupVersion(), schema.GroupVersion{Group: certificates.GroupName, Version: runtime.APIVersionInternal})
0000000000000000000000000000000000000000;;		storageFactory := serverstorage.NewDefaultStorageFactory(*storageConfig, testapi.StorageMediaType(), api.Codecs, resourceEncoding, DefaultAPIResourceConfigSource())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := options.NewEtcdOptions(storageConfig).ApplyWithStorageFactoryTo(storageFactory, config.GenericConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeVersion := kubeversion.Get()
0000000000000000000000000000000000000000;;		config.GenericConfig.Version = &kubeVersion
0000000000000000000000000000000000000000;;		config.StorageFactory = storageFactory
0000000000000000000000000000000000000000;;		config.GenericConfig.LoopbackClientConfig = &restclient.Config{APIPath: "/api", ContentConfig: restclient.ContentConfig{NegotiatedSerializer: api.Codecs}}
0000000000000000000000000000000000000000;;		config.GenericConfig.PublicAddress = net.ParseIP("192.168.10.4")
0000000000000000000000000000000000000000;;		config.GenericConfig.LegacyAPIGroupPrefixes = sets.NewString("/api")
0000000000000000000000000000000000000000;;		config.GenericConfig.RequestContextMapper = genericapirequest.NewRequestContextMapper()
0000000000000000000000000000000000000000;;		config.GenericConfig.LoopbackClientConfig = &restclient.Config{APIPath: "/api", ContentConfig: restclient.ContentConfig{NegotiatedSerializer: api.Codecs}}
0000000000000000000000000000000000000000;;		config.GenericConfig.EnableMetrics = true
0000000000000000000000000000000000000000;;		config.EnableCoreControllers = false
0000000000000000000000000000000000000000;;		config.KubeletClientConfig = kubeletclient.KubeletClientConfig{Port: 10250}
0000000000000000000000000000000000000000;;		config.ProxyTransport = utilnet.SetTransportDefaults(&http.Transport{
0000000000000000000000000000000000000000;;			Dial:            func(network, addr string) (net.Conn, error) { return nil, nil },
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientset, err := kubernetes.NewForConfig(config.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unable to create client set due to %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.GenericConfig.SharedInformerFactory = informers.NewSharedInformerFactory(clientset, config.GenericConfig.LoopbackClientConfig.Timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server, *config, assert.New(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMaster(t *testing.T) (*Master, *etcdtesting.EtcdTestServer, Config, *assert.Assertions) {
0000000000000000000000000000000000000000;;		etcdserver, config, assert := setUp(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		master, err := config.Complete().New(genericapiserver.EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in bringing up the master: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return master, etcdserver, config, assert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// limitedAPIResourceConfigSource only enables the core group, the extensions group, the batch group, and the autoscaling group.
0000000000000000000000000000000000000000;;	func limitedAPIResourceConfigSource() *serverstorage.ResourceConfig {
0000000000000000000000000000000000000000;;		ret := serverstorage.NewResourceConfig()
0000000000000000000000000000000000000000;;		ret.EnableVersions(
0000000000000000000000000000000000000000;;			apiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			batchapiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			batchapiv2alpha1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			appsapiv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			autoscalingapiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newLimitedMaster only enables the core group, the extensions group, the batch group, and the autoscaling group.
0000000000000000000000000000000000000000;;	func newLimitedMaster(t *testing.T) (*Master, *etcdtesting.EtcdTestServer, Config, *assert.Assertions) {
0000000000000000000000000000000000000000;;		etcdserver, config, assert := setUp(t)
0000000000000000000000000000000000000000;;		config.APIResourceConfigSource = limitedAPIResourceConfigSource()
0000000000000000000000000000000000000000;;		master, err := config.Complete().New(genericapiserver.EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error in bringing up the master: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return master, etcdserver, config, assert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestVersion tests /version
0000000000000000000000000000000000000000;;	func TestVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		s, etcdserver, _, _ := newMaster(t)
0000000000000000000000000000000000000000;;		defer etcdserver.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest("GET", "/version", nil)
0000000000000000000000000000000000000000;;		resp := httptest.NewRecorder()
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.ServeHTTP(resp, req)
0000000000000000000000000000000000000000;;		if resp.Code != 200 {
0000000000000000000000000000000000000000;;			t.Fatalf("expected http 200, got: %d", resp.Code)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var info version.Info
0000000000000000000000000000000000000000;;		err := json.NewDecoder(resp.Body).Decode(&info)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(kubeversion.Get(), info) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, Got %#v", kubeversion.Get(), info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeEndpointReconciler struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*fakeEndpointReconciler) ReconcileEndpoints(serviceName string, ip net.IP, endpointPorts []api.EndpointPort, reconcilePorts bool) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeNodeList(nodes []string, nodeResources apiv1.NodeResources) *apiv1.NodeList {
0000000000000000000000000000000000000000;;		list := apiv1.NodeList{
0000000000000000000000000000000000000000;;			Items: make([]apiv1.Node, len(nodes)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range nodes {
0000000000000000000000000000000000000000;;			list.Items[i].Name = nodes[i]
0000000000000000000000000000000000000000;;			list.Items[i].Status.Capacity = nodeResources.Capacity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestGetNodeAddresses verifies that proper results are returned
0000000000000000000000000000000000000000;;	// when requesting node addresses.
0000000000000000000000000000000000000000;;	func TestGetNodeAddresses(t *testing.T) {
0000000000000000000000000000000000000000;;		assert := assert.New(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeNodeClient := fake.NewSimpleClientset(makeNodeList([]string{"node1", "node2"}, apiv1.NodeResources{})).Core().Nodes()
0000000000000000000000000000000000000000;;		addressProvider := nodeAddressProvider{fakeNodeClient}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fail case (no addresses associated with nodes)
0000000000000000000000000000000000000000;;		nodes, _ := fakeNodeClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		addrs, err := addressProvider.externalAddresses()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assert.Error(err, "addresses should have caused an error as there are no addresses.")
0000000000000000000000000000000000000000;;		assert.Equal([]string(nil), addrs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pass case with External type IP
0000000000000000000000000000000000000000;;		nodes, _ = fakeNodeClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		for index := range nodes.Items {
0000000000000000000000000000000000000000;;			nodes.Items[index].Status.Addresses = []apiv1.NodeAddress{{Type: apiv1.NodeExternalIP, Address: "127.0.0.1"}}
0000000000000000000000000000000000000000;;			fakeNodeClient.Update(&nodes.Items[index])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addrs, err = addressProvider.externalAddresses()
0000000000000000000000000000000000000000;;		assert.NoError(err, "addresses should not have returned an error.")
0000000000000000000000000000000000000000;;		assert.Equal([]string{"127.0.0.1", "127.0.0.1"}, addrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeResponse(resp *http.Response, obj interface{}) error {
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Because we need to be backwards compatible with release 1.1, at endpoints
0000000000000000000000000000000000000000;;	// that exist in release 1.1, the responses should have empty APIVersion.
0000000000000000000000000000000000000000;;	func TestAPIVersionOfDiscoveryEndpoints(t *testing.T) {
0000000000000000000000000000000000000000;;		master, etcdserver, _, assert := newMaster(t)
0000000000000000000000000000000000000000;;		defer etcdserver.Terminate(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := httptest.NewServer(genericapirequest.WithRequestContext(master.GenericAPIServer.Handler.GoRestfulContainer.ServeMux, master.GenericAPIServer.RequestContextMapper()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// /api exists in release-1.1
0000000000000000000000000000000000000000;;		resp, err := http.Get(server.URL + "/api")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiVersions := metav1.APIVersions{}
0000000000000000000000000000000000000000;;		assert.NoError(decodeResponse(resp, &apiVersions))
0000000000000000000000000000000000000000;;		assert.Equal(apiVersions.APIVersion, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// /api/v1 exists in release-1.1
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/api/v1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceList := metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		assert.NoError(decodeResponse(resp, &resourceList))
0000000000000000000000000000000000000000;;		assert.Equal(resourceList.APIVersion, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// /apis exists in release-1.1
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/apis")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupList := metav1.APIGroupList{}
0000000000000000000000000000000000000000;;		assert.NoError(decodeResponse(resp, &groupList))
0000000000000000000000000000000000000000;;		assert.Equal(groupList.APIVersion, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// /apis/extensions exists in release-1.1
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/apis/extensions")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		group := metav1.APIGroup{}
0000000000000000000000000000000000000000;;		assert.NoError(decodeResponse(resp, &group))
0000000000000000000000000000000000000000;;		assert.Equal(group.APIVersion, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// /apis/extensions/v1beta1 exists in release-1.1
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/apis/extensions/v1beta1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceList = metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		assert.NoError(decodeResponse(resp, &resourceList))
0000000000000000000000000000000000000000;;		assert.Equal(resourceList.APIVersion, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// /apis/autoscaling doesn't exist in release-1.1, so the APIVersion field
0000000000000000000000000000000000000000;;		// should be non-empty in the results returned by the server.
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/apis/autoscaling")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		group = metav1.APIGroup{}
0000000000000000000000000000000000000000;;		assert.NoError(decodeResponse(resp, &group))
0000000000000000000000000000000000000000;;		assert.Equal(group.APIVersion, "v1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// apis/autoscaling/v1 doesn't exist in release-1.1, so the APIVersion field
0000000000000000000000000000000000000000;;		// should be non-empty in the results returned by the server.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err = http.Get(server.URL + "/apis/autoscaling/v1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceList = metav1.APIResourceList{}
0000000000000000000000000000000000000000;;		assert.NoError(decodeResponse(resp, &resourceList))
0000000000000000000000000000000000000000;;		assert.Equal(resourceList.APIVersion, "v1")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
