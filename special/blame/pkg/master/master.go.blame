0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
aff871ab218f970a1bd75c42536017e650e775cb;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package master
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		authenticationv1 "k8s.io/api/authentication/v1"
0000000000000000000000000000000000000000;;		authenticationv1beta1 "k8s.io/api/authentication/v1beta1"
0000000000000000000000000000000000000000;;		authorizationapiv1 "k8s.io/api/authorization/v1"
0000000000000000000000000000000000000000;;		authorizationapiv1beta1 "k8s.io/api/authorization/v1beta1"
0000000000000000000000000000000000000000;;		autoscalingapiv1 "k8s.io/api/autoscaling/v1"
0000000000000000000000000000000000000000;;		batchapiv1 "k8s.io/api/batch/v1"
0000000000000000000000000000000000000000;;		certificatesapiv1beta1 "k8s.io/api/certificates/v1beta1"
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		extensionsapiv1beta1 "k8s.io/api/extensions/v1beta1"
0000000000000000000000000000000000000000;;		networkingapiv1 "k8s.io/api/networking/v1"
0000000000000000000000000000000000000000;;		policyapiv1beta1 "k8s.io/api/policy/v1beta1"
0000000000000000000000000000000000000000;;		rbacv1alpha1 "k8s.io/api/rbac/v1alpha1"
0000000000000000000000000000000000000000;;		rbacv1beta1 "k8s.io/api/rbac/v1beta1"
0000000000000000000000000000000000000000;;		settingv1alpha1 "k8s.io/api/settings/v1alpha1"
0000000000000000000000000000000000000000;;		storageapiv1 "k8s.io/api/storage/v1"
0000000000000000000000000000000000000000;;		storageapiv1beta1 "k8s.io/api/storage/v1beta1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/discovery"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/healthz"
0000000000000000000000000000000000000000;;		serverstorage "k8s.io/apiserver/pkg/server/storage"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/cmd/kube-apiserver/app/options"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		corev1client "k8s.io/kubernetes/pkg/client/clientset_generated/clientset/typed/core/v1"
0000000000000000000000000000000000000000;;		coreclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/core/internalversion"
0000000000000000000000000000000000000000;;		kubeletclient "k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/master/tunneler"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/routes"
0000000000000000000000000000000000000000;;		nodeutil "k8s.io/kubernetes/pkg/util/node"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RESTStorage installers
0000000000000000000000000000000000000000;;		admissionregistrationrest "k8s.io/kubernetes/pkg/registry/admissionregistration/rest"
0000000000000000000000000000000000000000;;		appsrest "k8s.io/kubernetes/pkg/registry/apps/rest"
0000000000000000000000000000000000000000;;		authenticationrest "k8s.io/kubernetes/pkg/registry/authentication/rest"
0000000000000000000000000000000000000000;;		authorizationrest "k8s.io/kubernetes/pkg/registry/authorization/rest"
0000000000000000000000000000000000000000;;		autoscalingrest "k8s.io/kubernetes/pkg/registry/autoscaling/rest"
0000000000000000000000000000000000000000;;		batchrest "k8s.io/kubernetes/pkg/registry/batch/rest"
0000000000000000000000000000000000000000;;		certificatesrest "k8s.io/kubernetes/pkg/registry/certificates/rest"
0000000000000000000000000000000000000000;;		corerest "k8s.io/kubernetes/pkg/registry/core/rest"
0000000000000000000000000000000000000000;;		extensionsrest "k8s.io/kubernetes/pkg/registry/extensions/rest"
0000000000000000000000000000000000000000;;		networkingrest "k8s.io/kubernetes/pkg/registry/networking/rest"
0000000000000000000000000000000000000000;;		policyrest "k8s.io/kubernetes/pkg/registry/policy/rest"
0000000000000000000000000000000000000000;;		rbacrest "k8s.io/kubernetes/pkg/registry/rbac/rest"
0000000000000000000000000000000000000000;;		settingsrest "k8s.io/kubernetes/pkg/registry/settings/rest"
0000000000000000000000000000000000000000;;		storagerest "k8s.io/kubernetes/pkg/registry/storage/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultEndpointReconcilerInterval is the default amount of time for how often the endpoints for
0000000000000000000000000000000000000000;;		// the kubernetes Service are reconciled.
0000000000000000000000000000000000000000;;		DefaultEndpointReconcilerInterval = 10 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		GenericConfig *genericapiserver.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ClientCARegistrationHook ClientCARegistrationHook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		APIResourceConfigSource  serverstorage.APIResourceConfigSource
0000000000000000000000000000000000000000;;		StorageFactory           serverstorage.StorageFactory
0000000000000000000000000000000000000000;;		EnableCoreControllers    bool
0000000000000000000000000000000000000000;;		EndpointReconcilerConfig EndpointReconcilerConfig
0000000000000000000000000000000000000000;;		EventTTL                 time.Duration
0000000000000000000000000000000000000000;;		KubeletClientConfig      kubeletclient.KubeletClientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used to start and monitor tunneling
0000000000000000000000000000000000000000;;		Tunneler          tunneler.Tunneler
0000000000000000000000000000000000000000;;		EnableUISupport   bool
0000000000000000000000000000000000000000;;		EnableLogsSupport bool
0000000000000000000000000000000000000000;;		ProxyTransport    http.RoundTripper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Values to build the IP addresses used by discovery
0000000000000000000000000000000000000000;;		// The range of IPs to be assigned to services with type=ClusterIP or greater
0000000000000000000000000000000000000000;;		ServiceIPRange net.IPNet
0000000000000000000000000000000000000000;;		// The IP address for the GenericAPIServer service (must be inside ServiceIPRange)
0000000000000000000000000000000000000000;;		APIServerServiceIP net.IP
0000000000000000000000000000000000000000;;		// Port for the apiserver service.
0000000000000000000000000000000000000000;;		APIServerServicePort int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO, we can probably group service related items into a substruct to make it easier to configure
0000000000000000000000000000000000000000;;		// the API server items and `Extra*` fields likely fit nicely together.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The range of ports to be assigned to services with type=NodePort or greater
0000000000000000000000000000000000000000;;		ServiceNodePortRange utilnet.PortRange
0000000000000000000000000000000000000000;;		// Additional ports to be exposed on the GenericAPIServer service
0000000000000000000000000000000000000000;;		// extraServicePorts is injectable in the event that more ports
0000000000000000000000000000000000000000;;		// (other than the default 443/tcp) are exposed on the GenericAPIServer
0000000000000000000000000000000000000000;;		// and those ports need to be load balanced by the GenericAPIServer
0000000000000000000000000000000000000000;;		// service because this pkg is linked by out-of-tree projects
0000000000000000000000000000000000000000;;		// like openshift which want to use the GenericAPIServer but also do
0000000000000000000000000000000000000000;;		// more stuff.
0000000000000000000000000000000000000000;;		ExtraServicePorts []api.ServicePort
0000000000000000000000000000000000000000;;		// Additional ports to be exposed on the GenericAPIServer endpoints
0000000000000000000000000000000000000000;;		// Port names should align with ports defined in ExtraServicePorts
0000000000000000000000000000000000000000;;		ExtraEndpointPorts []api.EndpointPort
0000000000000000000000000000000000000000;;		// If non-zero, the "kubernetes" services uses this port as NodePort.
0000000000000000000000000000000000000000;;		KubernetesServiceNodePort int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of masters running; all masters must be started with the
0000000000000000000000000000000000000000;;		// same value for this field. (Numbers > 1 currently untested.)
0000000000000000000000000000000000000000;;		MasterCount int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointReconcilerConfig holds the endpoint reconciler and endpoint reconciliation interval to be
0000000000000000000000000000000000000000;;	// used by the master.
0000000000000000000000000000000000000000;;	type EndpointReconcilerConfig struct {
0000000000000000000000000000000000000000;;		Reconciler EndpointReconciler
0000000000000000000000000000000000000000;;		Interval   time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Master contains state for a Kubernetes cluster master/api server.
0000000000000000000000000000000000000000;;	type Master struct {
0000000000000000000000000000000000000000;;		GenericAPIServer *genericapiserver.GenericAPIServer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ClientCARegistrationHook ClientCARegistrationHook
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type completedConfig struct {
0000000000000000000000000000000000000000;;		*Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete fills in any fields not set that are required to have valid data. It's mutating the receiver.
0000000000000000000000000000000000000000;;	func (c *Config) Complete() completedConfig {
0000000000000000000000000000000000000000;;		c.GenericConfig.Complete()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceIPRange, apiServerServiceIP, err := DefaultServiceIPRange(c.ServiceIPRange)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Error determining service IP ranges: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.ServiceIPRange.IP == nil {
0000000000000000000000000000000000000000;;			c.ServiceIPRange = serviceIPRange
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.APIServerServiceIP == nil {
0000000000000000000000000000000000000000;;			c.APIServerServiceIP = apiServerServiceIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discoveryAddresses := discovery.DefaultAddresses{DefaultAddress: c.GenericConfig.ExternalAddress}
0000000000000000000000000000000000000000;;		discoveryAddresses.CIDRRules = append(discoveryAddresses.CIDRRules,
0000000000000000000000000000000000000000;;			discovery.CIDRRule{IPRange: c.ServiceIPRange, Address: net.JoinHostPort(c.APIServerServiceIP.String(), strconv.Itoa(c.APIServerServicePort))})
0000000000000000000000000000000000000000;;		c.GenericConfig.DiscoveryAddresses = discoveryAddresses
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.ServiceNodePortRange.Size == 0 {
0000000000000000000000000000000000000000;;			// TODO: Currently no way to specify an empty range (do we need to allow this?)
0000000000000000000000000000000000000000;;			// We should probably allow this for clouds that don't require NodePort to do load-balancing (GCE)
0000000000000000000000000000000000000000;;			// but then that breaks the strict nestedness of ServiceType.
0000000000000000000000000000000000000000;;			// Review post-v1
0000000000000000000000000000000000000000;;			c.ServiceNodePortRange = options.DefaultServiceNodePortRange
0000000000000000000000000000000000000000;;			glog.Infof("Node port range unspecified. Defaulting to %v.", c.ServiceNodePortRange)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// enable swagger UI only if general UI support is on
0000000000000000000000000000000000000000;;		c.GenericConfig.EnableSwaggerUI = c.GenericConfig.EnableSwaggerUI && c.EnableUISupport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.EndpointReconcilerConfig.Interval == 0 {
0000000000000000000000000000000000000000;;			c.EndpointReconcilerConfig.Interval = DefaultEndpointReconcilerInterval
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.EndpointReconcilerConfig.Reconciler == nil {
0000000000000000000000000000000000000000;;			// use a default endpoint reconciler if nothing is set
0000000000000000000000000000000000000000;;			endpointClient := coreclient.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;			c.EndpointReconcilerConfig.Reconciler = NewMasterCountEndpointReconciler(c.MasterCount, endpointClient)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this has always been hardcoded true in the past
0000000000000000000000000000000000000000;;		c.GenericConfig.EnableMetrics = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SkipComplete provides a way to construct a server instance without config completion.
0000000000000000000000000000000000000000;;	func (c *Config) SkipComplete() completedConfig {
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new instance of Master from the given config.
0000000000000000000000000000000000000000;;	// Certain config fields will be set to a default value if unset.
0000000000000000000000000000000000000000;;	// Certain config fields must be specified, including:
0000000000000000000000000000000000000000;;	//   KubeletClientConfig
0000000000000000000000000000000000000000;;	func (c completedConfig) New(delegationTarget genericapiserver.DelegationTarget) (*Master, error) {
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(c.KubeletClientConfig, kubeletclient.KubeletClientConfig{}) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Master.New() called with empty config.KubeletClientConfig")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := c.Config.GenericConfig.SkipComplete().New("kube-apiserver", delegationTarget) // completion is done in Complete, no need for a second time
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.EnableUISupport {
0000000000000000000000000000000000000000;;			routes.UIRedirect{}.Install(s.Handler.NonGoRestfulMux)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.EnableLogsSupport {
0000000000000000000000000000000000000000;;			routes.Logs{}.Install(s.Handler.GoRestfulContainer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := &Master{
0000000000000000000000000000000000000000;;			GenericAPIServer: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// install legacy rest storage
0000000000000000000000000000000000000000;;		if c.APIResourceConfigSource.AnyResourcesForVersionEnabled(apiv1.SchemeGroupVersion) {
0000000000000000000000000000000000000000;;			legacyRESTStorageProvider := corerest.LegacyRESTStorageProvider{
0000000000000000000000000000000000000000;;				StorageFactory:       c.StorageFactory,
0000000000000000000000000000000000000000;;				ProxyTransport:       c.ProxyTransport,
0000000000000000000000000000000000000000;;				KubeletClientConfig:  c.KubeletClientConfig,
0000000000000000000000000000000000000000;;				EventTTL:             c.EventTTL,
0000000000000000000000000000000000000000;;				ServiceIPRange:       c.ServiceIPRange,
0000000000000000000000000000000000000000;;				ServiceNodePortRange: c.ServiceNodePortRange,
0000000000000000000000000000000000000000;;				LoopbackClientConfig: c.GenericConfig.LoopbackClientConfig,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.InstallLegacyAPI(c.Config, c.Config.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The order here is preserved in discovery.
0000000000000000000000000000000000000000;;		// If resources with identical names exist in more than one of these groups (e.g. "deployments.apps"" and "deployments.extensions"),
0000000000000000000000000000000000000000;;		// the order of this list determines which group an unqualified resource name (e.g. "deployments") should prefer.
0000000000000000000000000000000000000000;;		// This priority order is used for local discovery, but it ends up aggregated in `k8s.io/kubernetes/cmd/kube-apiserver/app/aggregator.go
0000000000000000000000000000000000000000;;		// with specific priorities.
0000000000000000000000000000000000000000;;		// TODO: describe the priority all the way down in the RESTStorageProviders and plumb it back through the various discovery
0000000000000000000000000000000000000000;;		// handlers that we have.
0000000000000000000000000000000000000000;;		restStorageProviders := []RESTStorageProvider{
0000000000000000000000000000000000000000;;			authenticationrest.RESTStorageProvider{Authenticator: c.GenericConfig.Authenticator},
0000000000000000000000000000000000000000;;			authorizationrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorizer},
0000000000000000000000000000000000000000;;			autoscalingrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			batchrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			certificatesrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			extensionsrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			networkingrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			policyrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			rbacrest.RESTStorageProvider{Authorizer: c.GenericConfig.Authorizer},
0000000000000000000000000000000000000000;;			settingsrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			storagerest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			// keep apps after extensions so legacy clients resolve the extensions versions of shared resource names.
0000000000000000000000000000000000000000;;			// See https://github.com/kubernetes/kubernetes/issues/42392
0000000000000000000000000000000000000000;;			appsrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;			admissionregistrationrest.RESTStorageProvider{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.InstallAPIs(c.Config.APIResourceConfigSource, c.Config.GenericConfig.RESTOptionsGetter, restStorageProviders...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Tunneler != nil {
0000000000000000000000000000000000000000;;			m.installTunneler(c.Tunneler, corev1client.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig).Nodes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := m.GenericAPIServer.AddPostStartHook("ca-registration", c.ClientCARegistrationHook.PostStartHook); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Error registering PostStartHook %q: %v", "ca-registration", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Master) InstallLegacyAPI(c *Config, restOptionsGetter generic.RESTOptionsGetter, legacyRESTStorageProvider corerest.LegacyRESTStorageProvider) {
0000000000000000000000000000000000000000;;		legacyRESTStorage, apiGroupInfo, err := legacyRESTStorageProvider.NewLegacyRESTStorage(restOptionsGetter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Error building core storage: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.EnableCoreControllers {
0000000000000000000000000000000000000000;;			coreClient := coreclient.NewForConfigOrDie(c.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;			bootstrapController := c.NewBootstrapController(legacyRESTStorage, coreClient, coreClient)
0000000000000000000000000000000000000000;;			if err := m.GenericAPIServer.AddPostStartHook("bootstrap-controller", bootstrapController.PostStartHook); err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("Error registering PostStartHook %q: %v", "bootstrap-controller", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := m.GenericAPIServer.InstallLegacyAPIGroup(genericapiserver.DefaultLegacyAPIPrefix, &apiGroupInfo); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Error in registering group versions: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Master) installTunneler(nodeTunneler tunneler.Tunneler, nodeClient corev1client.NodeInterface) {
0000000000000000000000000000000000000000;;		nodeTunneler.Run(nodeAddressProvider{nodeClient}.externalAddresses)
0000000000000000000000000000000000000000;;		m.GenericAPIServer.AddHealthzChecks(healthz.NamedCheck("SSH Tunnel Check", tunneler.TunnelSyncHealthChecker(nodeTunneler)))
0000000000000000000000000000000000000000;;		prometheus.NewGaugeFunc(prometheus.GaugeOpts{
0000000000000000000000000000000000000000;;			Name: "apiserver_proxy_tunnel_sync_latency_secs",
0000000000000000000000000000000000000000;;			Help: "The time since the last successful synchronization of the SSH tunnels for proxy requests.",
0000000000000000000000000000000000000000;;		}, func() float64 { return float64(nodeTunneler.SecondsSinceSync()) })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTStorageProvider is a factory type for REST storage.
0000000000000000000000000000000000000000;;	type RESTStorageProvider interface {
0000000000000000000000000000000000000000;;		GroupName() string
0000000000000000000000000000000000000000;;		NewRESTStorage(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter) (genericapiserver.APIGroupInfo, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstallAPIs will install the APIs for the restStorageProviders if they are enabled.
0000000000000000000000000000000000000000;;	func (m *Master) InstallAPIs(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter, restStorageProviders ...RESTStorageProvider) {
0000000000000000000000000000000000000000;;		apiGroupsInfo := []genericapiserver.APIGroupInfo{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, restStorageBuilder := range restStorageProviders {
0000000000000000000000000000000000000000;;			groupName := restStorageBuilder.GroupName()
0000000000000000000000000000000000000000;;			if !apiResourceConfigSource.AnyResourcesForGroupEnabled(groupName) {
0000000000000000000000000000000000000000;;				glog.V(1).Infof("Skipping disabled API group %q.", groupName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			apiGroupInfo, enabled := restStorageBuilder.NewRESTStorage(apiResourceConfigSource, restOptionsGetter)
0000000000000000000000000000000000000000;;			if !enabled {
0000000000000000000000000000000000000000;;				glog.Warningf("Problem initializing API group %q, skipping.", groupName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(1).Infof("Enabling API group %q.", groupName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if postHookProvider, ok := restStorageBuilder.(genericapiserver.PostStartHookProvider); ok {
0000000000000000000000000000000000000000;;				name, hook, err := postHookProvider.PostStartHook()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Fatalf("Error building PostStartHook: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := m.GenericAPIServer.AddPostStartHook(name, hook); err != nil {
0000000000000000000000000000000000000000;;					glog.Fatalf("Error registering PostStartHook %q: %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			apiGroupsInfo = append(apiGroupsInfo, apiGroupInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range apiGroupsInfo {
0000000000000000000000000000000000000000;;			if err := m.GenericAPIServer.InstallAPIGroup(&apiGroupsInfo[i]); err != nil {
0000000000000000000000000000000000000000;;				glog.Fatalf("Error in registering group versions: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodeAddressProvider struct {
0000000000000000000000000000000000000000;;		nodeClient corev1client.NodeInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n nodeAddressProvider) externalAddresses() ([]string, error) {
0000000000000000000000000000000000000000;;		preferredAddressTypes := []apiv1.NodeAddressType{
0000000000000000000000000000000000000000;;			apiv1.NodeExternalIP,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodes, err := n.nodeClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addrs := []string{}
0000000000000000000000000000000000000000;;		for ix := range nodes.Items {
0000000000000000000000000000000000000000;;			node := &nodes.Items[ix]
0000000000000000000000000000000000000000;;			addr, err := nodeutil.GetPreferredNodeAddress(node, preferredAddressTypes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addrs = append(addrs, addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultAPIResourceConfigSource() *serverstorage.ResourceConfig {
0000000000000000000000000000000000000000;;		ret := serverstorage.NewResourceConfig()
0000000000000000000000000000000000000000;;		// NOTE: GroupVersions listed here will be enabled by default. Don't put alpha versions in the list.
0000000000000000000000000000000000000000;;		ret.EnableVersions(
0000000000000000000000000000000000000000;;			apiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			batchapiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			authenticationv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			authenticationv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			autoscalingapiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			appsv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			policyapiv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			rbacv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			// Don't copy this pattern. We enable rbac/v1alpha1 and settings/v1laph1
0000000000000000000000000000000000000000;;			// by default only because they were enabled in previous releases.
0000000000000000000000000000000000000000;;			// See https://github.com/kubernetes/kubernetes/pull/47690.
0000000000000000000000000000000000000000;;			// TODO: disable rbac/v1alpha1 and settings/v1alpha1 by default in 1.8
0000000000000000000000000000000000000000;;			rbacv1alpha1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			settingv1alpha1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			storageapiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			storageapiv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			certificatesapiv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			authorizationapiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			authorizationapiv1beta1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			networkingapiv1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// all extensions resources except these are disabled by default
0000000000000000000000000000000000000000;;		ret.EnableResources(
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion.WithResource("daemonsets"),
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion.WithResource("deployments"),
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion.WithResource("ingresses"),
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion.WithResource("networkpolicies"),
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion.WithResource("replicasets"),
0000000000000000000000000000000000000000;;			extensionsapiv1beta1.SchemeGroupVersion.WithResource("podsecuritypolicies"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
