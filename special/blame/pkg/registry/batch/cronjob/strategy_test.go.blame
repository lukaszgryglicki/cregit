0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
17f962e95e13c6755f9557aa1a73f6de675f86da;pkg/registry/scheduledjob/strategy_test.go[pkg/registry/scheduledjob/strategy_test.go][pkg/registry/batch/cronjob/strategy_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cronjob
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		apitesting "k8s.io/kubernetes/pkg/api/testing"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/batch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBool(a bool) *bool {
0000000000000000000000000000000000000000;;		r := new(bool)
0000000000000000000000000000000000000000;;		*r = a
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCronJobStrategy(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		if !Strategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			t.Errorf("CronJob must be namespace scoped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if Strategy.AllowCreateOnUpdate() {
0000000000000000000000000000000000000000;;			t.Errorf("CronJob should not allow create on update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validPodTemplateSpec := api.PodTemplateSpec{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: api.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;				DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;				Containers:    []api.Container{{Name: "abc", Image: "image", ImagePullPolicy: "IfNotPresent", TerminationMessagePolicy: api.TerminationMessageReadFile}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scheduledJob := &batch.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "mycronjob",
0000000000000000000000000000000000000000;;				Namespace: metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batch.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          "* * * * ?",
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: batch.AllowConcurrent,
0000000000000000000000000000000000000000;;				JobTemplate: batch.JobTemplateSpec{
0000000000000000000000000000000000000000;;					Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;						Template: validPodTemplateSpec,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Strategy.PrepareForCreate(ctx, scheduledJob)
0000000000000000000000000000000000000000;;		if len(scheduledJob.Status.Active) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("CronJob does not allow setting status on create")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := Strategy.Validate(ctx, scheduledJob)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error validating %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		updatedCronJob := &batch.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "bar", ResourceVersion: "4"},
0000000000000000000000000000000000000000;;			Spec: batch.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule: "5 5 5 * ?",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: batch.CronJobStatus{
0000000000000000000000000000000000000000;;				LastScheduleTime: &now,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we do not change status
0000000000000000000000000000000000000000;;		Strategy.PrepareForUpdate(ctx, updatedCronJob, scheduledJob)
0000000000000000000000000000000000000000;;		if updatedCronJob.Status.Active != nil {
0000000000000000000000000000000000000000;;			t.Errorf("PrepareForUpdate should have preserved prior version status")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs = Strategy.ValidateUpdate(ctx, updatedCronJob, scheduledJob)
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected a validation error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we correctly implement the interface.
0000000000000000000000000000000000000000;;		// Otherwise a typo could silently change the default.
0000000000000000000000000000000000000000;;		var gcds rest.GarbageCollectionDeleteStrategy = Strategy
0000000000000000000000000000000000000000;;		if got, want := gcds.DefaultGarbageCollectionPolicy(), rest.OrphanDependents; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("DefaultGarbageCollectionPolicy() = %#v, want %#v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCronJobStatusStrategy(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		if !StatusStrategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			t.Errorf("CronJob must be namespace scoped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if StatusStrategy.AllowCreateOnUpdate() {
0000000000000000000000000000000000000000;;			t.Errorf("CronJob should not allow create on update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		validPodTemplateSpec := api.PodTemplateSpec{
0000000000000000000000000000000000000000;;			Spec: api.PodSpec{
0000000000000000000000000000000000000000;;				RestartPolicy: api.RestartPolicyOnFailure,
0000000000000000000000000000000000000000;;				DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;				Containers:    []api.Container{{Name: "abc", Image: "image", ImagePullPolicy: "IfNotPresent", TerminationMessagePolicy: api.TerminationMessageReadFile}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldSchedule := "* * * * ?"
0000000000000000000000000000000000000000;;		oldCronJob := &batch.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "mycronjob",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "10",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batch.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          oldSchedule,
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: batch.AllowConcurrent,
0000000000000000000000000000000000000000;;				JobTemplate: batch.JobTemplateSpec{
0000000000000000000000000000000000000000;;					Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;						Template: validPodTemplateSpec,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		newCronJob := &batch.CronJob{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:            "mycronjob",
0000000000000000000000000000000000000000;;				Namespace:       metav1.NamespaceDefault,
0000000000000000000000000000000000000000;;				ResourceVersion: "9",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: batch.CronJobSpec{
0000000000000000000000000000000000000000;;				Schedule:          "5 5 * * ?",
0000000000000000000000000000000000000000;;				ConcurrencyPolicy: batch.AllowConcurrent,
0000000000000000000000000000000000000000;;				JobTemplate: batch.JobTemplateSpec{
0000000000000000000000000000000000000000;;					Spec: batch.JobSpec{
0000000000000000000000000000000000000000;;						Template: validPodTemplateSpec,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: batch.CronJobStatus{
0000000000000000000000000000000000000000;;				LastScheduleTime: &now,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		StatusStrategy.PrepareForUpdate(ctx, newCronJob, oldCronJob)
0000000000000000000000000000000000000000;;		if newCronJob.Status.LastScheduleTime == nil {
0000000000000000000000000000000000000000;;			t.Errorf("CronJob status updates must allow changes to scheduledJob status")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newCronJob.Spec.Schedule != oldSchedule {
0000000000000000000000000000000000000000;;			t.Errorf("CronJob status updates must now allow changes to scheduledJob spec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := StatusStrategy.ValidateUpdate(ctx, newCronJob, oldCronJob)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newCronJob.ResourceVersion != "9" {
0000000000000000000000000000000000000000;;			t.Errorf("Incoming resource version on update should not be mutated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FIXME: this is failing conversion.go
0000000000000000000000000000000000000000;;	func TestSelectableFieldLabelConversions(t *testing.T) {
0000000000000000000000000000000000000000;;		apitesting.TestSelectableFieldLabelConversionsOfKind(t,
0000000000000000000000000000000000000000;;			"batch/v2alpha1",
0000000000000000000000000000000000000000;;			"CronJob",
0000000000000000000000000000000000000000;;			CronJobToSelectableFields(&batch.CronJob{}),
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
