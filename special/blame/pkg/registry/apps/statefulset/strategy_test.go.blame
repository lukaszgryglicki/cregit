0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3153317738b4c67ab9f03b69f43680dd0ce93c63;pkg/registry/petset/strategy_test.go[pkg/registry/petset/strategy_test.go][pkg/registry/apps/statefulset/strategy_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package statefulset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/apps"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStatefulSetStrategy(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		if !Strategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			t.Errorf("StatefulSet must be namespace scoped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if Strategy.AllowCreateOnUpdate() {
0000000000000000000000000000000000000000;;			t.Errorf("StatefulSet should not allow create on update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validSelector := map[string]string{"a": "b"}
0000000000000000000000000000000000000000;;		validPodTemplate := api.PodTemplate{
0000000000000000000000000000000000000000;;			Template: api.PodTemplateSpec{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Labels: validSelector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: api.PodSpec{
0000000000000000000000000000000000000000;;					RestartPolicy: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;					DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;					Containers:    []api.Container{{Name: "abc", Image: "image", ImagePullPolicy: "IfNotPresent"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ps := &apps.StatefulSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "abc", Namespace: metav1.NamespaceDefault},
0000000000000000000000000000000000000000;;			Spec: apps.StatefulSetSpec{
0000000000000000000000000000000000000000;;				PodManagementPolicy: apps.OrderedReadyPodManagement,
0000000000000000000000000000000000000000;;				Selector:            &metav1.LabelSelector{MatchLabels: validSelector},
0000000000000000000000000000000000000000;;				Template:            validPodTemplate.Template,
0000000000000000000000000000000000000000;;				UpdateStrategy:      apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: apps.StatefulSetStatus{Replicas: 3},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Strategy.PrepareForCreate(ctx, ps)
0000000000000000000000000000000000000000;;		if ps.Status.Replicas != 0 {
0000000000000000000000000000000000000000;;			t.Error("StatefulSet should not allow setting status.replicas on create")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := Strategy.Validate(ctx, ps)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error validating %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Just Spec.Replicas is allowed to change
0000000000000000000000000000000000000000;;		validPs := &apps.StatefulSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: ps.Name, Namespace: ps.Namespace, ResourceVersion: "1", Generation: 1},
0000000000000000000000000000000000000000;;			Spec: apps.StatefulSetSpec{
0000000000000000000000000000000000000000;;				PodManagementPolicy: apps.OrderedReadyPodManagement,
0000000000000000000000000000000000000000;;				Selector:            ps.Spec.Selector,
0000000000000000000000000000000000000000;;				Template:            validPodTemplate.Template,
0000000000000000000000000000000000000000;;				UpdateStrategy:      apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: apps.StatefulSetStatus{Replicas: 4},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Strategy.PrepareForUpdate(ctx, validPs, ps)
0000000000000000000000000000000000000000;;		errs = Strategy.ValidateUpdate(ctx, validPs, ps)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("updating spec.Replicas is allowed on a statefulset: %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validPs.Spec.Selector = &metav1.LabelSelector{MatchLabels: map[string]string{"a": "bar"}}
0000000000000000000000000000000000000000;;		Strategy.PrepareForUpdate(ctx, validPs, ps)
0000000000000000000000000000000000000000;;		errs = Strategy.ValidateUpdate(ctx, validPs, ps)
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected a validation error since updates are disallowed on statefulsets.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we correctly implement the interface.
0000000000000000000000000000000000000000;;		// Otherwise a typo could silently change the default.
0000000000000000000000000000000000000000;;		var gcds rest.GarbageCollectionDeleteStrategy = Strategy
0000000000000000000000000000000000000000;;		if got, want := gcds.DefaultGarbageCollectionPolicy(), rest.OrphanDependents; got != want {
0000000000000000000000000000000000000000;;			t.Errorf("DefaultGarbageCollectionPolicy() = %#v, want %#v", got, want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestStatefulSetStatusStrategy(t *testing.T) {
0000000000000000000000000000000000000000;;		ctx := genericapirequest.NewDefaultContext()
0000000000000000000000000000000000000000;;		if !StatusStrategy.NamespaceScoped() {
0000000000000000000000000000000000000000;;			t.Errorf("StatefulSet must be namespace scoped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if StatusStrategy.AllowCreateOnUpdate() {
0000000000000000000000000000000000000000;;			t.Errorf("StatefulSet should not allow create on update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		validSelector := map[string]string{"a": "b"}
0000000000000000000000000000000000000000;;		validPodTemplate := api.PodTemplate{
0000000000000000000000000000000000000000;;			Template: api.PodTemplateSpec{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Labels: validSelector,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Spec: api.PodSpec{
0000000000000000000000000000000000000000;;					RestartPolicy: api.RestartPolicyAlways,
0000000000000000000000000000000000000000;;					DNSPolicy:     api.DNSClusterFirst,
0000000000000000000000000000000000000000;;					Containers:    []api.Container{{Name: "abc", Image: "image", ImagePullPolicy: "IfNotPresent"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldPS := &apps.StatefulSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "abc", Namespace: metav1.NamespaceDefault, ResourceVersion: "10"},
0000000000000000000000000000000000000000;;			Spec: apps.StatefulSetSpec{
0000000000000000000000000000000000000000;;				Replicas:       3,
0000000000000000000000000000000000000000;;				Selector:       &metav1.LabelSelector{MatchLabels: validSelector},
0000000000000000000000000000000000000000;;				Template:       validPodTemplate.Template,
0000000000000000000000000000000000000000;;				UpdateStrategy: apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;				Replicas: 1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newPS := &apps.StatefulSet{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{Name: "abc", Namespace: metav1.NamespaceDefault, ResourceVersion: "9"},
0000000000000000000000000000000000000000;;			Spec: apps.StatefulSetSpec{
0000000000000000000000000000000000000000;;				Replicas:       1,
0000000000000000000000000000000000000000;;				Selector:       &metav1.LabelSelector{MatchLabels: validSelector},
0000000000000000000000000000000000000000;;				Template:       validPodTemplate.Template,
0000000000000000000000000000000000000000;;				UpdateStrategy: apps.StatefulSetUpdateStrategy{Type: apps.RollingUpdateStatefulSetStrategyType},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Status: apps.StatefulSetStatus{
0000000000000000000000000000000000000000;;				Replicas: 2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		StatusStrategy.PrepareForUpdate(ctx, newPS, oldPS)
0000000000000000000000000000000000000000;;		if newPS.Status.Replicas != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("StatefulSet status updates should allow change of pods: %v", newPS.Status.Replicas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newPS.Spec.Replicas != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("StatefulSet status updates should not clobber spec: %v", newPS.Spec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := StatusStrategy.ValidateUpdate(ctx, newPS, oldPS)
0000000000000000000000000000000000000000;;		if len(errs) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
