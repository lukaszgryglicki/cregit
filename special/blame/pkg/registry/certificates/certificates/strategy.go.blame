0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6207f4996446b241bfeec4e3539bf7e984c9fd1f;pkg/registry/certificates/strategy.go[pkg/registry/certificates/strategy.go][pkg/registry/certificates/certificates/strategy.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package certificates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		apistorage "k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage/names"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/certificates"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/certificates/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// csrStrategy implements behavior for CSRs
0000000000000000000000000000000000000000;;	type csrStrategy struct {
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;		names.NameGenerator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// csrStrategy is the default logic that applies when creating and updating
0000000000000000000000000000000000000000;;	// CSR objects.
0000000000000000000000000000000000000000;;	var Strategy = csrStrategy{api.Scheme, names.SimpleNameGenerator}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceScoped is true for CSRs.
0000000000000000000000000000000000000000;;	func (csrStrategy) NamespaceScoped() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowCreateOnUpdate is false for CSRs.
0000000000000000000000000000000000000000;;	func (csrStrategy) AllowCreateOnUpdate() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareForCreate clears fields that are not allowed to be set by end users
0000000000000000000000000000000000000000;;	// on creation.
0000000000000000000000000000000000000000;;	func (csrStrategy) PrepareForCreate(ctx genericapirequest.Context, obj runtime.Object) {
0000000000000000000000000000000000000000;;		csr := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clear any user-specified info
0000000000000000000000000000000000000000;;		csr.Spec.Username = ""
0000000000000000000000000000000000000000;;		csr.Spec.UID = ""
0000000000000000000000000000000000000000;;		csr.Spec.Groups = nil
0000000000000000000000000000000000000000;;		csr.Spec.Extra = nil
0000000000000000000000000000000000000000;;		// Inject user.Info from request context
0000000000000000000000000000000000000000;;		if user, ok := genericapirequest.UserFrom(ctx); ok {
0000000000000000000000000000000000000000;;			csr.Spec.Username = user.GetName()
0000000000000000000000000000000000000000;;			csr.Spec.UID = user.GetUID()
0000000000000000000000000000000000000000;;			csr.Spec.Groups = user.GetGroups()
0000000000000000000000000000000000000000;;			if extra := user.GetExtra(); len(extra) > 0 {
0000000000000000000000000000000000000000;;				csr.Spec.Extra = map[string]certificates.ExtraValue{}
0000000000000000000000000000000000000000;;				for k, v := range extra {
0000000000000000000000000000000000000000;;					csr.Spec.Extra[k] = certificates.ExtraValue(v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Be explicit that users cannot create pre-approved certificate requests.
0000000000000000000000000000000000000000;;		csr.Status = certificates.CertificateSigningRequestStatus{}
0000000000000000000000000000000000000000;;		csr.Status.Conditions = []certificates.CertificateSigningRequestCondition{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareForUpdate clears fields that are not allowed to be set by end users
0000000000000000000000000000000000000000;;	// on update. Certificate requests are immutable after creation except via subresources.
0000000000000000000000000000000000000000;;	func (csrStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {
0000000000000000000000000000000000000000;;		newCSR := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		oldCSR := old.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newCSR.Spec = oldCSR.Spec
0000000000000000000000000000000000000000;;		newCSR.Status = oldCSR.Status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates a new CSR. Validation must check for a correct signature.
0000000000000000000000000000000000000000;;	func (csrStrategy) Validate(ctx genericapirequest.Context, obj runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		csr := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		return validation.ValidateCertificateSigningRequest(csr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonicalize normalizes the object after validation (which includes a signature check).
0000000000000000000000000000000000000000;;	func (csrStrategy) Canonicalize(obj runtime.Object) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateUpdate is the default update validation for an end user.
0000000000000000000000000000000000000000;;	func (csrStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		oldCSR := old.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		newCSR := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		return validation.ValidateCertificateSigningRequestUpdate(newCSR, oldCSR)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If AllowUnconditionalUpdate() is true and the object specified by
0000000000000000000000000000000000000000;;	// the user does not have a resource version, then generic Update()
0000000000000000000000000000000000000000;;	// populates it with the latest version. Else, it checks that the
0000000000000000000000000000000000000000;;	// version specified by the user matches the version of latest etcd
0000000000000000000000000000000000000000;;	// object.
0000000000000000000000000000000000000000;;	func (csrStrategy) AllowUnconditionalUpdate() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s csrStrategy) Export(ctx genericapirequest.Context, obj runtime.Object, exact bool) error {
0000000000000000000000000000000000000000;;		csr, ok := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// unexpected programmer error
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected object: %v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.PrepareForCreate(ctx, obj)
0000000000000000000000000000000000000000;;		if exact {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// CSRs allow direct subresource edits, we clear them without exact so the CSR value can be reused.
0000000000000000000000000000000000000000;;		csr.Status = certificates.CertificateSigningRequestStatus{}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Storage strategy for the Status subresource
0000000000000000000000000000000000000000;;	type csrStatusStrategy struct {
0000000000000000000000000000000000000000;;		csrStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var StatusStrategy = csrStatusStrategy{Strategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (csrStatusStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {
0000000000000000000000000000000000000000;;		newCSR := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		oldCSR := old.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Updating the Status should only update the Status and not the spec
0000000000000000000000000000000000000000;;		// or approval conditions. The intent is to separate the concerns of
0000000000000000000000000000000000000000;;		// approval and certificate issuance.
0000000000000000000000000000000000000000;;		newCSR.Spec = oldCSR.Spec
0000000000000000000000000000000000000000;;		newCSR.Status.Conditions = oldCSR.Status.Conditions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (csrStatusStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		return validation.ValidateCertificateSigningRequestUpdate(obj.(*certificates.CertificateSigningRequest), old.(*certificates.CertificateSigningRequest))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonicalize normalizes the object after validation.
0000000000000000000000000000000000000000;;	func (csrStatusStrategy) Canonicalize(obj runtime.Object) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Storage strategy for the Approval subresource
0000000000000000000000000000000000000000;;	type csrApprovalStrategy struct {
0000000000000000000000000000000000000000;;		csrStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ApprovalStrategy = csrApprovalStrategy{Strategy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (csrApprovalStrategy) PrepareForUpdate(ctx genericapirequest.Context, obj, old runtime.Object) {
0000000000000000000000000000000000000000;;		newCSR := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		oldCSR := old.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Updating the approval should only update the conditions.
0000000000000000000000000000000000000000;;		newCSR.Spec = oldCSR.Spec
0000000000000000000000000000000000000000;;		oldCSR.Status.Conditions = newCSR.Status.Conditions
0000000000000000000000000000000000000000;;		newCSR.Status = oldCSR.Status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (csrApprovalStrategy) ValidateUpdate(ctx genericapirequest.Context, obj, old runtime.Object) field.ErrorList {
0000000000000000000000000000000000000000;;		return validation.ValidateCertificateSigningRequestUpdate(obj.(*certificates.CertificateSigningRequest), old.(*certificates.CertificateSigningRequest))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAttrs returns labels and fields of a given object for filtering purposes.
0000000000000000000000000000000000000000;;	func GetAttrs(obj runtime.Object) (labels.Set, fields.Set, bool, error) {
0000000000000000000000000000000000000000;;		sa, ok := obj.(*certificates.CertificateSigningRequest)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, false, fmt.Errorf("not a CertificateSigningRequest")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels.Set(sa.Labels), SelectableFields(sa), sa.Initializers != nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matcher returns a generic matcher for a given label and field selector.
0000000000000000000000000000000000000000;;	func Matcher(label labels.Selector, field fields.Selector) apistorage.SelectionPredicate {
0000000000000000000000000000000000000000;;		return apistorage.SelectionPredicate{
0000000000000000000000000000000000000000;;			Label:    label,
0000000000000000000000000000000000000000;;			Field:    field,
0000000000000000000000000000000000000000;;			GetAttrs: GetAttrs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectableFields returns a field set that can be used for filter selection
0000000000000000000000000000000000000000;;	func SelectableFields(obj *certificates.CertificateSigningRequest) fields.Set {
0000000000000000000000000000000000000000;;		return generic.ObjectMetaFieldsSet(&obj.ObjectMeta, false)
0000000000000000000000000000000000000000;;	}
