0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
2398a7a57830698bf18040e45a09944d03d9f720;pkg/registry/namespace/etcd/etcd.go[pkg/registry/namespace/etcd/etcd.go][pkg/registry/core/namespace/storage/storage.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metainternalversion "k8s.io/apimachinery/pkg/apis/meta/internalversion"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		storageerr "k8s.io/apiserver/pkg/storage/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/cachesize"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/namespace"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rest implements a RESTStorage for namespaces
0000000000000000000000000000000000000000;;	type REST struct {
0000000000000000000000000000000000000000;;		store  *genericregistry.Store
0000000000000000000000000000000000000000;;		status *genericregistry.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusREST implements the REST endpoint for changing the status of a namespace.
0000000000000000000000000000000000000000;;	type StatusREST struct {
0000000000000000000000000000000000000000;;		store *genericregistry.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FinalizeREST implements the REST endpoint for finalizing a namespace.
0000000000000000000000000000000000000000;;	type FinalizeREST struct {
0000000000000000000000000000000000000000;;		store *genericregistry.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewREST returns a RESTStorage object that will work against namespaces.
0000000000000000000000000000000000000000;;	func NewREST(optsGetter generic.RESTOptionsGetter) (*REST, *StatusREST, *FinalizeREST) {
0000000000000000000000000000000000000000;;		store := &genericregistry.Store{
0000000000000000000000000000000000000000;;			Copier:            api.Scheme,
0000000000000000000000000000000000000000;;			NewFunc:           func() runtime.Object { return &api.Namespace{} },
0000000000000000000000000000000000000000;;			NewListFunc:       func() runtime.Object { return &api.NamespaceList{} },
0000000000000000000000000000000000000000;;			PredicateFunc:     namespace.MatchNamespace,
0000000000000000000000000000000000000000;;			QualifiedResource: api.Resource("namespaces"),
0000000000000000000000000000000000000000;;			WatchCacheSize:    cachesize.GetWatchCacheSizeByResource("namespaces"),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			CreateStrategy:      namespace.Strategy,
0000000000000000000000000000000000000000;;			UpdateStrategy:      namespace.Strategy,
0000000000000000000000000000000000000000;;			DeleteStrategy:      namespace.Strategy,
0000000000000000000000000000000000000000;;			ReturnDeletedObject: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options := &generic.StoreOptions{RESTOptions: optsGetter, AttrFunc: namespace.GetAttrs}
0000000000000000000000000000000000000000;;		if err := store.CompleteWithOptions(options); err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO: Propagate error up
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		statusStore := *store
0000000000000000000000000000000000000000;;		statusStore.UpdateStrategy = namespace.StatusStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		finalizeStore := *store
0000000000000000000000000000000000000000;;		finalizeStore.UpdateStrategy = namespace.FinalizeStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &REST{store: store, status: &statusStore}, &StatusREST{store: &statusStore}, &FinalizeREST{store: &finalizeStore}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return r.store.New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) NewList() runtime.Object {
0000000000000000000000000000000000000000;;		return r.store.NewList()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) List(ctx genericapirequest.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return r.store.List(ctx, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) Create(ctx genericapirequest.Context, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return r.store.Create(ctx, obj, includeUninitialized)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) Update(ctx genericapirequest.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		return r.store.Update(ctx, name, objInfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) Get(ctx genericapirequest.Context, name string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return r.store.Get(ctx, name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) Watch(ctx genericapirequest.Context, options *metainternalversion.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return r.store.Watch(ctx, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *REST) Export(ctx genericapirequest.Context, name string, opts metav1.ExportOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return r.store.Export(ctx, name, opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete enforces life-cycle rules for namespace termination
0000000000000000000000000000000000000000;;	func (r *REST) Delete(ctx genericapirequest.Context, name string, options *metav1.DeleteOptions) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		nsObj, err := r.Get(ctx, name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace := nsObj.(*api.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure we have a UID precondition
0000000000000000000000000000000000000000;;		if options == nil {
0000000000000000000000000000000000000000;;			options = metav1.NewDeleteOptions(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.Preconditions == nil {
0000000000000000000000000000000000000000;;			options.Preconditions = &metav1.Preconditions{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.Preconditions.UID == nil {
0000000000000000000000000000000000000000;;			options.Preconditions.UID = &namespace.UID
0000000000000000000000000000000000000000;;		} else if *options.Preconditions.UID != namespace.UID {
0000000000000000000000000000000000000000;;			err = apierrors.NewConflict(
0000000000000000000000000000000000000000;;				api.Resource("namespaces"),
0000000000000000000000000000000000000000;;				name,
0000000000000000000000000000000000000000;;				fmt.Errorf("Precondition failed: UID in precondition: %v, UID in object meta: %v", *options.Preconditions.UID, namespace.UID),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// upon first request to delete, we switch the phase to start namespace termination
0000000000000000000000000000000000000000;;		// TODO: enhance graceful deletion's calls to DeleteStrategy to allow phase change and finalizer patterns
0000000000000000000000000000000000000000;;		if namespace.DeletionTimestamp.IsZero() {
0000000000000000000000000000000000000000;;			key, err := r.store.KeyFunc(ctx, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			preconditions := storage.Preconditions{UID: options.Preconditions.UID}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out := r.store.NewFunc()
0000000000000000000000000000000000000000;;			err = r.store.Storage.GuaranteedUpdate(
0000000000000000000000000000000000000000;;				ctx, key, out, false, &preconditions,
0000000000000000000000000000000000000000;;				storage.SimpleUpdate(func(existing runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					existingNamespace, ok := existing.(*api.Namespace)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						// wrong type
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("expected *api.Namespace, got %v", existing)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Set the deletion timestamp if needed
0000000000000000000000000000000000000000;;					if existingNamespace.DeletionTimestamp.IsZero() {
0000000000000000000000000000000000000000;;						now := metav1.Now()
0000000000000000000000000000000000000000;;						existingNamespace.DeletionTimestamp = &now
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Set the namespace phase to terminating, if needed
0000000000000000000000000000000000000000;;					if existingNamespace.Status.Phase != api.NamespaceTerminating {
0000000000000000000000000000000000000000;;						existingNamespace.Status.Phase = api.NamespaceTerminating
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Remove orphan finalizer if options.OrphanDependents = false.
0000000000000000000000000000000000000000;;					if options.OrphanDependents != nil && *options.OrphanDependents == false {
0000000000000000000000000000000000000000;;						// remove Orphan finalizer.
0000000000000000000000000000000000000000;;						newFinalizers := []string{}
0000000000000000000000000000000000000000;;						for i := range existingNamespace.ObjectMeta.Finalizers {
0000000000000000000000000000000000000000;;							finalizer := existingNamespace.ObjectMeta.Finalizers[i]
0000000000000000000000000000000000000000;;							if string(finalizer) != metav1.FinalizerOrphanDependents {
0000000000000000000000000000000000000000;;								newFinalizers = append(newFinalizers, finalizer)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						existingNamespace.ObjectMeta.Finalizers = newFinalizers
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return existingNamespace, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = storageerr.InterpretGetError(err, api.Resource("namespaces"), name)
0000000000000000000000000000000000000000;;				err = storageerr.InterpretUpdateError(err, api.Resource("namespaces"), name)
0000000000000000000000000000000000000000;;				if _, ok := err.(*apierrors.StatusError); !ok {
0000000000000000000000000000000000000000;;					err = apierrors.NewInternalError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return out, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// prior to final deletion, we must ensure that finalizers is empty
0000000000000000000000000000000000000000;;		if len(namespace.Spec.Finalizers) != 0 {
0000000000000000000000000000000000000000;;			err = apierrors.NewConflict(api.Resource("namespaces"), namespace.Name, fmt.Errorf("The system is ensuring all content is removed from this namespace.  Upon completion, this namespace will automatically be purged by the system."))
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.store.Delete(ctx, name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement ShortNamesProvider
0000000000000000000000000000000000000000;;	var _ rest.ShortNamesProvider = &REST{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShortNames implements the ShortNamesProvider interface. Returns a list of short names for a resource.
0000000000000000000000000000000000000000;;	func (r *REST) ShortNames() []string {
0000000000000000000000000000000000000000;;		return []string{"ns"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *StatusREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return r.store.New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves the object from the storage. It is required to support Patch.
0000000000000000000000000000000000000000;;	func (r *StatusREST) Get(ctx genericapirequest.Context, name string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return r.store.Get(ctx, name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update alters the status subset of an object.
0000000000000000000000000000000000000000;;	func (r *StatusREST) Update(ctx genericapirequest.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		return r.store.Update(ctx, name, objInfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *FinalizeREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return r.store.New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update alters the status finalizers subset of an object.
0000000000000000000000000000000000000000;;	func (r *FinalizeREST) Update(ctx genericapirequest.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		return r.store.Update(ctx, name, objInfo)
0000000000000000000000000000000000000000;;	}
