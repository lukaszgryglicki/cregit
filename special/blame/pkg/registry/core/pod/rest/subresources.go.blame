0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
19afee1ddd7eb1c00e19869a1c56ed47b992bf65;pkg/registry/pod/rest/subresources.go[pkg/registry/pod/rest/subresources.go][pkg/registry/core/pod/rest/subresources.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/proxy"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		genericfeatures "k8s.io/apiserver/pkg/features"
0000000000000000000000000000000000000000;;		genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/capabilities"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/pod"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyREST implements the proxy subresource for a Pod
0000000000000000000000000000000000000000;;	type ProxyREST struct {
0000000000000000000000000000000000000000;;		Store          *genericregistry.Store
0000000000000000000000000000000000000000;;		ProxyTransport http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Connecter
0000000000000000000000000000000000000000;;	var _ = rest.Connecter(&ProxyREST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var proxyMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns an empty pod resource
0000000000000000000000000000000000000000;;	func (r *ProxyREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectMethods returns the list of HTTP methods that can be proxied
0000000000000000000000000000000000000000;;	func (r *ProxyREST) ConnectMethods() []string {
0000000000000000000000000000000000000000;;		return proxyMethods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConnectOptions returns versioned resource that represents proxy parameters
0000000000000000000000000000000000000000;;	func (r *ProxyREST) NewConnectOptions() (runtime.Object, bool, string) {
0000000000000000000000000000000000000000;;		return &api.PodProxyOptions{}, true, "path"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connect returns a handler for the pod proxy
0000000000000000000000000000000000000000;;	func (r *ProxyREST) Connect(ctx genericapirequest.Context, id string, opts runtime.Object, responder rest.Responder) (http.Handler, error) {
0000000000000000000000000000000000000000;;		proxyOpts, ok := opts.(*api.PodProxyOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Invalid options object: %#v", opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		location, transport, err := pod.ResourceLocation(r.Store, r.ProxyTransport, ctx, id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		location.Path = path.Join(location.Path, proxyOpts.Path)
0000000000000000000000000000000000000000;;		// Return a proxy handler that uses the desired transport, wrapped with additional proxy handling (to get URL rewriting, X-Forwarded-* headers, etc)
0000000000000000000000000000000000000000;;		return newThrottledUpgradeAwareProxyHandler(location, transport, true, false, false, responder), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Support both GET and POST methods. We must support GET for browsers that want to use WebSockets.
0000000000000000000000000000000000000000;;	var upgradeableMethods = []string{"GET", "POST"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachREST implements the attach subresource for a Pod
0000000000000000000000000000000000000000;;	type AttachREST struct {
0000000000000000000000000000000000000000;;		Store       *genericregistry.Store
0000000000000000000000000000000000000000;;		KubeletConn client.ConnectionInfoGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Connecter
0000000000000000000000000000000000000000;;	var _ = rest.Connecter(&AttachREST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new Pod object
0000000000000000000000000000000000000000;;	func (r *AttachREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connect returns a handler for the pod exec proxy
0000000000000000000000000000000000000000;;	func (r *AttachREST) Connect(ctx genericapirequest.Context, name string, opts runtime.Object, responder rest.Responder) (http.Handler, error) {
0000000000000000000000000000000000000000;;		attachOpts, ok := opts.(*api.PodAttachOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Invalid options object: %#v", opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		location, transport, err := pod.AttachLocation(r.Store, r.KubeletConn, ctx, name, attachOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newThrottledUpgradeAwareProxyHandler(location, transport, false, true, true, responder), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConnectOptions returns the versioned object that represents exec parameters
0000000000000000000000000000000000000000;;	func (r *AttachREST) NewConnectOptions() (runtime.Object, bool, string) {
0000000000000000000000000000000000000000;;		return &api.PodAttachOptions{}, false, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectMethods returns the methods supported by exec
0000000000000000000000000000000000000000;;	func (r *AttachREST) ConnectMethods() []string {
0000000000000000000000000000000000000000;;		return upgradeableMethods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecREST implements the exec subresource for a Pod
0000000000000000000000000000000000000000;;	type ExecREST struct {
0000000000000000000000000000000000000000;;		Store       *genericregistry.Store
0000000000000000000000000000000000000000;;		KubeletConn client.ConnectionInfoGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Connecter
0000000000000000000000000000000000000000;;	var _ = rest.Connecter(&ExecREST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new Pod object
0000000000000000000000000000000000000000;;	func (r *ExecREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connect returns a handler for the pod exec proxy
0000000000000000000000000000000000000000;;	func (r *ExecREST) Connect(ctx genericapirequest.Context, name string, opts runtime.Object, responder rest.Responder) (http.Handler, error) {
0000000000000000000000000000000000000000;;		execOpts, ok := opts.(*api.PodExecOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid options object: %#v", opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		location, transport, err := pod.ExecLocation(r.Store, r.KubeletConn, ctx, name, execOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newThrottledUpgradeAwareProxyHandler(location, transport, false, true, true, responder), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConnectOptions returns the versioned object that represents exec parameters
0000000000000000000000000000000000000000;;	func (r *ExecREST) NewConnectOptions() (runtime.Object, bool, string) {
0000000000000000000000000000000000000000;;		return &api.PodExecOptions{}, false, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectMethods returns the methods supported by exec
0000000000000000000000000000000000000000;;	func (r *ExecREST) ConnectMethods() []string {
0000000000000000000000000000000000000000;;		return upgradeableMethods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortForwardREST implements the portforward subresource for a Pod
0000000000000000000000000000000000000000;;	type PortForwardREST struct {
0000000000000000000000000000000000000000;;		Store       *genericregistry.Store
0000000000000000000000000000000000000000;;		KubeletConn client.ConnectionInfoGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Connecter
0000000000000000000000000000000000000000;;	var _ = rest.Connecter(&PortForwardREST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns an empty pod object
0000000000000000000000000000000000000000;;	func (r *PortForwardREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConnectOptions returns the versioned object that represents the
0000000000000000000000000000000000000000;;	// portforward parameters
0000000000000000000000000000000000000000;;	func (r *PortForwardREST) NewConnectOptions() (runtime.Object, bool, string) {
0000000000000000000000000000000000000000;;		return &api.PodPortForwardOptions{}, false, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectMethods returns the methods supported by portforward
0000000000000000000000000000000000000000;;	func (r *PortForwardREST) ConnectMethods() []string {
0000000000000000000000000000000000000000;;		return upgradeableMethods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connect returns a handler for the pod portforward proxy
0000000000000000000000000000000000000000;;	func (r *PortForwardREST) Connect(ctx genericapirequest.Context, name string, opts runtime.Object, responder rest.Responder) (http.Handler, error) {
0000000000000000000000000000000000000000;;		portForwardOpts, ok := opts.(*api.PodPortForwardOptions)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid options object: %#v", opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		location, transport, err := pod.PortForwardLocation(r.Store, r.KubeletConn, ctx, name, portForwardOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newThrottledUpgradeAwareProxyHandler(location, transport, false, true, true, responder), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newThrottledUpgradeAwareProxyHandler(location *url.URL, transport http.RoundTripper, wrapTransport, upgradeRequired, interceptRedirects bool, responder rest.Responder) *proxy.UpgradeAwareHandler {
0000000000000000000000000000000000000000;;		handler := proxy.NewUpgradeAwareHandler(location, transport, wrapTransport, upgradeRequired, responder)
0000000000000000000000000000000000000000;;		handler.InterceptRedirects = interceptRedirects && utilfeature.DefaultFeatureGate.Enabled(genericfeatures.StreamingProxyRedirects)
0000000000000000000000000000000000000000;;		handler.MaxBytesPerSec = capabilities.Get().PerConnectionBandwidthLimitBytesPerSec
0000000000000000000000000000000000000000;;		return handler
0000000000000000000000000000000000000000;;	}
