0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
b0a861390a5cf7573d403657e1bd3f3521f6a4f5;pkg/registry/pod/etcd/etcd.go[pkg/registry/pod/etcd/etcd.go][pkg/registry/core/pod/storage/storage.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/generic"
0000000000000000000000000000000000000000;;		genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/storage"
0000000000000000000000000000000000000000;;		storeerr "k8s.io/apiserver/pkg/storage/errors"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		podutil "k8s.io/kubernetes/pkg/api/pod"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api/validation"
0000000000000000000000000000000000000000;;		policyclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/policy/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/kubelet/client"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/printers"
0000000000000000000000000000000000000000;;		printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
0000000000000000000000000000000000000000;;		printerstorage "k8s.io/kubernetes/pkg/printers/storage"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/cachesize"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/registry/core/pod"
0000000000000000000000000000000000000000;;		podrest "k8s.io/kubernetes/pkg/registry/core/pod/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodStorage includes storage for pods and all sub resources
0000000000000000000000000000000000000000;;	type PodStorage struct {
0000000000000000000000000000000000000000;;		Pod         *REST
0000000000000000000000000000000000000000;;		Binding     *BindingREST
0000000000000000000000000000000000000000;;		Eviction    *EvictionREST
0000000000000000000000000000000000000000;;		Status      *StatusREST
0000000000000000000000000000000000000000;;		Log         *podrest.LogREST
0000000000000000000000000000000000000000;;		Proxy       *podrest.ProxyREST
0000000000000000000000000000000000000000;;		Exec        *podrest.ExecREST
0000000000000000000000000000000000000000;;		Attach      *podrest.AttachREST
0000000000000000000000000000000000000000;;		PortForward *podrest.PortForwardREST
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// REST implements a RESTStorage for pods
0000000000000000000000000000000000000000;;	type REST struct {
0000000000000000000000000000000000000000;;		*genericregistry.Store
0000000000000000000000000000000000000000;;		proxyTransport http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStorage returns a RESTStorage object that will work against pods.
0000000000000000000000000000000000000000;;	func NewStorage(optsGetter generic.RESTOptionsGetter, k client.ConnectionInfoGetter, proxyTransport http.RoundTripper, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter) PodStorage {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		store := &genericregistry.Store{
0000000000000000000000000000000000000000;;			Copier:            api.Scheme,
0000000000000000000000000000000000000000;;			NewFunc:           func() runtime.Object { return &api.Pod{} },
0000000000000000000000000000000000000000;;			NewListFunc:       func() runtime.Object { return &api.PodList{} },
0000000000000000000000000000000000000000;;			PredicateFunc:     pod.MatchPod,
0000000000000000000000000000000000000000;;			QualifiedResource: api.Resource("pods"),
0000000000000000000000000000000000000000;;			WatchCacheSize:    cachesize.GetWatchCacheSizeByResource("pods"),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			CreateStrategy:      pod.Strategy,
0000000000000000000000000000000000000000;;			UpdateStrategy:      pod.Strategy,
0000000000000000000000000000000000000000;;			DeleteStrategy:      pod.Strategy,
0000000000000000000000000000000000000000;;			ReturnDeletedObject: true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			TableConvertor: printerstorage.TableConvertor{TablePrinter: printers.NewTablePrinter().With(printersinternal.AddHandlers)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options := &generic.StoreOptions{RESTOptions: optsGetter, AttrFunc: pod.GetAttrs, TriggerFunc: pod.NodeNameTriggerFunc}
0000000000000000000000000000000000000000;;		if err := store.CompleteWithOptions(options); err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO: Propagate error up
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		statusStore := *store
0000000000000000000000000000000000000000;;		statusStore.UpdateStrategy = pod.StatusStrategy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return PodStorage{
0000000000000000000000000000000000000000;;			Pod:         &REST{store, proxyTransport},
0000000000000000000000000000000000000000;;			Binding:     &BindingREST{store: store},
0000000000000000000000000000000000000000;;			Eviction:    newEvictionStorage(store, podDisruptionBudgetClient),
0000000000000000000000000000000000000000;;			Status:      &StatusREST{store: &statusStore},
0000000000000000000000000000000000000000;;			Log:         &podrest.LogREST{Store: store, KubeletConn: k},
0000000000000000000000000000000000000000;;			Proxy:       &podrest.ProxyREST{Store: store, ProxyTransport: proxyTransport},
0000000000000000000000000000000000000000;;			Exec:        &podrest.ExecREST{Store: store, KubeletConn: k},
0000000000000000000000000000000000000000;;			Attach:      &podrest.AttachREST{Store: store, KubeletConn: k},
0000000000000000000000000000000000000000;;			PortForward: &podrest.PortForwardREST{Store: store, KubeletConn: k},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement Redirector.
0000000000000000000000000000000000000000;;	var _ = rest.Redirector(&REST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceLocation returns a pods location from its HostIP
0000000000000000000000000000000000000000;;	func (r *REST) ResourceLocation(ctx genericapirequest.Context, name string) (*url.URL, http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		return pod.ResourceLocation(r, r.proxyTransport, ctx, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement ShortNamesProvider
0000000000000000000000000000000000000000;;	var _ rest.ShortNamesProvider = &REST{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShortNames implements the ShortNamesProvider interface. Returns a list of short names for a resource.
0000000000000000000000000000000000000000;;	func (r *REST) ShortNames() []string {
0000000000000000000000000000000000000000;;		return []string{"po"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement CategoriesProvider
0000000000000000000000000000000000000000;;	var _ rest.CategoriesProvider = &REST{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Categories implements the CategoriesProvider interface. Returns a list of categories a resource is part of.
0000000000000000000000000000000000000000;;	func (r *REST) Categories() []string {
0000000000000000000000000000000000000000;;		return []string{"all"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BindingREST implements the REST endpoint for binding pods to nodes when etcd is in use.
0000000000000000000000000000000000000000;;	type BindingREST struct {
0000000000000000000000000000000000000000;;		store *genericregistry.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new binding resource
0000000000000000000000000000000000000000;;	func (r *BindingREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.Binding{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = rest.Creater(&BindingREST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create ensures a pod is bound to a specific host.
0000000000000000000000000000000000000000;;	func (r *BindingREST) Create(ctx genericapirequest.Context, obj runtime.Object, includeUninitialized bool) (out runtime.Object, err error) {
0000000000000000000000000000000000000000;;		binding := obj.(*api.Binding)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: move me to a binding strategy
0000000000000000000000000000000000000000;;		if errs := validation.ValidatePodBinding(binding); len(errs) != 0 {
0000000000000000000000000000000000000000;;			return nil, errs.ToAggregate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.assignPod(ctx, binding.Name, binding.Target.Name, binding.Annotations)
0000000000000000000000000000000000000000;;		out = &metav1.Status{Status: metav1.StatusSuccess}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setPodHostAndAnnotations sets the given pod's host to 'machine' if and only if it was
0000000000000000000000000000000000000000;;	// previously 'oldMachine' and merges the provided annotations with those of the pod.
0000000000000000000000000000000000000000;;	// Returns the current state of the pod, or an error.
0000000000000000000000000000000000000000;;	func (r *BindingREST) setPodHostAndAnnotations(ctx genericapirequest.Context, podID, oldMachine, machine string, annotations map[string]string) (finalPod *api.Pod, err error) {
0000000000000000000000000000000000000000;;		podKey, err := r.store.KeyFunc(ctx, podID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = r.store.Storage.GuaranteedUpdate(ctx, podKey, &api.Pod{}, false, nil, storage.SimpleUpdate(func(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;			pod, ok := obj.(*api.Pod)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.DeletionTimestamp != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("pod %s is being deleted, cannot be assigned to a host", pod.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pod.Spec.NodeName != oldMachine {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("pod %v is already assigned to node %q", pod.Name, pod.Spec.NodeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pod.Spec.NodeName = machine
0000000000000000000000000000000000000000;;			if pod.Annotations == nil {
0000000000000000000000000000000000000000;;				pod.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range annotations {
0000000000000000000000000000000000000000;;				pod.Annotations[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			podutil.UpdatePodCondition(&pod.Status, &api.PodCondition{
0000000000000000000000000000000000000000;;				Type:   api.PodScheduled,
0000000000000000000000000000000000000000;;				Status: api.ConditionTrue,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			finalPod = pod
0000000000000000000000000000000000000000;;			return pod, nil
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		return finalPod, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignPod assigns the given pod to the given machine.
0000000000000000000000000000000000000000;;	func (r *BindingREST) assignPod(ctx genericapirequest.Context, podID string, machine string, annotations map[string]string) (err error) {
0000000000000000000000000000000000000000;;		if _, err = r.setPodHostAndAnnotations(ctx, podID, "", machine, annotations); err != nil {
0000000000000000000000000000000000000000;;			err = storeerr.InterpretGetError(err, api.Resource("pods"), podID)
0000000000000000000000000000000000000000;;			err = storeerr.InterpretUpdateError(err, api.Resource("pods"), podID)
0000000000000000000000000000000000000000;;			if _, ok := err.(*errors.StatusError); !ok {
0000000000000000000000000000000000000000;;				err = errors.NewConflict(api.Resource("pods/binding"), podID, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusREST implements the REST endpoint for changing the status of a pod.
0000000000000000000000000000000000000000;;	type StatusREST struct {
0000000000000000000000000000000000000000;;		store *genericregistry.Store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new pod resource
0000000000000000000000000000000000000000;;	func (r *StatusREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &api.Pod{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves the object from the storage. It is required to support Patch.
0000000000000000000000000000000000000000;;	func (r *StatusREST) Get(ctx genericapirequest.Context, name string, options *metav1.GetOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return r.store.Get(ctx, name, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update alters the status subset of an object.
0000000000000000000000000000000000000000;;	func (r *StatusREST) Update(ctx genericapirequest.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {
0000000000000000000000000000000000000000;;		return r.store.Update(ctx, name, objInfo)
0000000000000000000000000000000000000000;;	}
