0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
0982215c21cfcf09d374afe661de71c1361c26e2;pkg/registry/core/pod/etcd/eviction.go[pkg/registry/core/pod/etcd/eviction.go][pkg/registry/core/pod/storage/eviction.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/api"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/apis/policy"
0000000000000000000000000000000000000000;;		policyclient "k8s.io/kubernetes/pkg/client/clientset_generated/internalclientset/typed/policy/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/pkg/client/retry"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// MaxDisruptedPodSize is the max size of PodDisruptionBudgetStatus.DisruptedPods. API server eviction
0000000000000000000000000000000000000000;;		// subresource handler will refuse to evict pods covered by the corresponding PDB
0000000000000000000000000000000000000000;;		// if the size of the map exceeds this value. It means a large number of
0000000000000000000000000000000000000000;;		// evictions have been approved by the API server but not noticed by the PDB controller yet.
0000000000000000000000000000000000000000;;		// This situation should self-correct because the PDB controller removes
0000000000000000000000000000000000000000;;		// entries from the map automatically after the PDB DeletionTimeout regardless.
0000000000000000000000000000000000000000;;		MaxDisruptedPodSize = 2000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EvictionsRetry is the retry for a conflict where multiple clients
0000000000000000000000000000000000000000;;	// are making changes to the same resource.
0000000000000000000000000000000000000000;;	var EvictionsRetry = wait.Backoff{
0000000000000000000000000000000000000000;;		Steps:    20,
0000000000000000000000000000000000000000;;		Duration: 500 * time.Millisecond,
0000000000000000000000000000000000000000;;		Factor:   1.0,
0000000000000000000000000000000000000000;;		Jitter:   0.1,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEvictionStorage(store *genericregistry.Store, podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter) *EvictionREST {
0000000000000000000000000000000000000000;;		return &EvictionREST{store: store, podDisruptionBudgetClient: podDisruptionBudgetClient}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EvictionREST implements the REST endpoint for evicting pods from nodes
0000000000000000000000000000000000000000;;	type EvictionREST struct {
0000000000000000000000000000000000000000;;		store                     *genericregistry.Store
0000000000000000000000000000000000000000;;		podDisruptionBudgetClient policyclient.PodDisruptionBudgetsGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = rest.Creater(&EvictionREST{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new eviction resource
0000000000000000000000000000000000000000;;	func (r *EvictionREST) New() runtime.Object {
0000000000000000000000000000000000000000;;		return &policy.Eviction{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create attempts to create a new eviction.  That is, it tries to evict a pod.
0000000000000000000000000000000000000000;;	func (r *EvictionREST) Create(ctx genericapirequest.Context, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		eviction := obj.(*policy.Eviction)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := r.store.Get(ctx, eviction.Name, &metav1.GetOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pod := obj.(*api.Pod)
0000000000000000000000000000000000000000;;		var rtStatus *metav1.Status
0000000000000000000000000000000000000000;;		var pdbName string
0000000000000000000000000000000000000000;;		err = retry.RetryOnConflict(EvictionsRetry, func() error {
0000000000000000000000000000000000000000;;			pdbs, err := r.getPodDisruptionBudgets(ctx, pod)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(pdbs) > 1 {
0000000000000000000000000000000000000000;;				rtStatus = &metav1.Status{
0000000000000000000000000000000000000000;;					Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;					Message: "This pod has more than one PodDisruptionBudget, which the eviction subresource does not support.",
0000000000000000000000000000000000000000;;					Code:    500,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if len(pdbs) == 1 {
0000000000000000000000000000000000000000;;				pdb := pdbs[0]
0000000000000000000000000000000000000000;;				pdbName = pdb.Name
0000000000000000000000000000000000000000;;				// Try to verify-and-decrement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If it was false already, or if it becomes false during the course of our retries,
0000000000000000000000000000000000000000;;				// raise an error marked as a 429.
0000000000000000000000000000000000000000;;				ok, err := r.checkAndDecrement(pod.Namespace, pod.Name, pdb)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					rtStatus = &metav1.Status{
0000000000000000000000000000000000000000;;						Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;						// TODO(mml): Include some more details about why the eviction is disallowed.
0000000000000000000000000000000000000000;;						// Ideally any such text is generated by the DisruptionController (offline).
0000000000000000000000000000000000000000;;						Message: "Cannot evict pod as it would violate the pod's disruption budget.",
0000000000000000000000000000000000000000;;						Code:    429,
0000000000000000000000000000000000000000;;						// TODO(mml): Add a Retry-After header.  Once there are time-based
0000000000000000000000000000000000000000;;						// budgets, we can sometimes compute a sensible suggested value.  But
0000000000000000000000000000000000000000;;						// even without that, we can give a suggestion (10 minutes?) that
0000000000000000000000000000000000000000;;						// prevents well-behaved clients from hammering us.
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == wait.ErrWaitTimeout {
0000000000000000000000000000000000000000;;			err = errors.NewTimeoutError(fmt.Sprintf("couldn't update PodDisruptionBudget %q due to conflicts", pdbName), 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rtStatus != nil {
0000000000000000000000000000000000000000;;			return rtStatus, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// At this point there was either no PDB or we succeded in decrementing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try the delete
0000000000000000000000000000000000000000;;		_, _, err = r.store.Delete(ctx, eviction.Name, eviction.DeleteOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Success!
0000000000000000000000000000000000000000;;		return &metav1.Status{Status: metav1.StatusSuccess}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkAndDecrement checks if the provided PodDisruptionBudget allows any disruption.
0000000000000000000000000000000000000000;;	func (r *EvictionREST) checkAndDecrement(namespace string, podName string, pdb policy.PodDisruptionBudget) (ok bool, err error) {
0000000000000000000000000000000000000000;;		if pdb.Status.ObservedGeneration < pdb.Generation {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pdb.Status.PodDisruptionsAllowed < 0 {
0000000000000000000000000000000000000000;;			return false, errors.NewForbidden(policy.Resource("poddisruptionbudget"), pdb.Name, fmt.Errorf("pdb disruptions allowed is negative"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pdb.Status.DisruptedPods) > MaxDisruptedPodSize {
0000000000000000000000000000000000000000;;			return false, errors.NewForbidden(policy.Resource("poddisruptionbudget"), pdb.Name, fmt.Errorf("DisrputedPods map too big - too many evictions not confirmed by PDB controller"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pdb.Status.PodDisruptionsAllowed == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pdb.Status.PodDisruptionsAllowed--
0000000000000000000000000000000000000000;;		if pdb.Status.DisruptedPods == nil {
0000000000000000000000000000000000000000;;			pdb.Status.DisruptedPods = make(map[string]metav1.Time)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Eviction handler needs to inform the PDB controller that it is about to delete a pod
0000000000000000000000000000000000000000;;		// so it should not consider it as available in calculations when updating PodDisruptions allowed.
0000000000000000000000000000000000000000;;		// If the pod is not deleted within a reasonable time limit PDB controller will assume that it won't
0000000000000000000000000000000000000000;;		// be deleted at all and remove it from DisruptedPod map.
0000000000000000000000000000000000000000;;		pdb.Status.DisruptedPods[podName] = metav1.Time{Time: time.Now()}
0000000000000000000000000000000000000000;;		if _, err := r.podDisruptionBudgetClient.PodDisruptionBudgets(namespace).UpdateStatus(&pdb); err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPodDisruptionBudgets returns any PDBs that match the pod or err if there's an error.
0000000000000000000000000000000000000000;;	func (r *EvictionREST) getPodDisruptionBudgets(ctx genericapirequest.Context, pod *api.Pod) ([]policy.PodDisruptionBudget, error) {
0000000000000000000000000000000000000000;;		if len(pod.Labels) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pdbList, err := r.podDisruptionBudgetClient.PodDisruptionBudgets(pod.Namespace).List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pdbs []policy.PodDisruptionBudget
0000000000000000000000000000000000000000;;		for _, pdb := range pdbList.Items {
0000000000000000000000000000000000000000;;			if pdb.Namespace != pod.Namespace {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selector, err := metav1.LabelSelectorAsSelector(pdb.Spec.Selector)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If a PDB with a nil or empty selector creeps in, it should match nothing, not everything.
0000000000000000000000000000000000000000;;			if selector.Empty() || !selector.Matches(labels.Set(pod.Labels)) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pdbs = append(pdbs, pdb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pdbs, nil
0000000000000000000000000000000000000000;;	}
